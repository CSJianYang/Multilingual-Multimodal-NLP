[
    {
        "title": "Finding the Topic of Each Post",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1568744,
                "content": [
                    {
                        "username": "arjunsuri",
                        "content": "WITH post_split AS (SELECT post_id, value split_word \\nFROM Posts  \\n    CROSS APPLY STRING_SPLIT(content, \\' \\')), #split your string \\n\\npost_topics AS (select distinct post_id, topic_id\\nFROM post_split p \\nLEFT JOIN Keywords k on LOWER(k.word) = LOWER(p.split_word)\\n) #match split words with Keywords table\\n\\n\\nselect post_id, isnull(string_agg(topic_id, \\',\\') WITHIN GROUP(ORDER BY topic_id ),\\'Ambiguous!\\') topic\\nfrom post_topics\\ngroup by post_id #concatenate the results"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum White Tiles After Covering With Carpets",
        "question_content": "<p>You are given a <strong>0-indexed binary</strong> string <code>floor</code>, which represents the colors of tiles on a floor:</p>\n\n<ul>\n\t<li><code>floor[i] = &#39;0&#39;</code> denotes that the <code>i<sup>th</sup></code> tile of the floor is colored <strong>black</strong>.</li>\n\t<li>On the other hand, <code>floor[i] = &#39;1&#39;</code> denotes that the <code>i<sup>th</sup></code> tile of the floor is colored <strong>white</strong>.</li>\n</ul>\n\n<p>You are also given <code>numCarpets</code> and <code>carpetLen</code>. You have <code>numCarpets</code> <strong>black</strong> carpets, each of length <code>carpetLen</code> tiles. Cover the tiles with the given carpets such that the number of <strong>white</strong> tiles still visible is <strong>minimum</strong>. Carpets may overlap one another.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of white tiles still visible.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/10/ex1-1.png\" style=\"width: 400px; height: 73px;\" />\n<pre>\n<strong>Input:</strong> floor = &quot;10110101&quot;, numCarpets = 2, carpetLen = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> \nThe figure above shows one way of covering the tiles with the carpets such that only 2 white tiles are visible.\nNo other way of covering the tiles with the carpets can leave less than 2 white tiles visible.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/10/ex2.png\" style=\"width: 353px; height: 123px;\" />\n<pre>\n<strong>Input:</strong> floor = &quot;11111&quot;, numCarpets = 2, carpetLen = 3\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> \nThe figure above shows one way of covering the tiles with the carpets such that no white tiles are visible.\nNote that the carpets are able to overlap one another.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= carpetLen &lt;= floor.length &lt;= 1000</code></li>\n\t<li><code>floor[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n\t<li><code>1 &lt;= numCarpets &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1863955,
                "title": "java-c-python-dp-solution",
                "content": "# **Explanation**\\n`dp[i][k]` means that,\\nusing `k` tiles to cover the first `i` tiles\\nthe minimum number of white tiles still visible.\\n\\n\\nFor each tile `s[i]`, we heve two options,\\nOne option is doing nothing, `jump` this tile,\\n`jump = dp[i - 1][k] + int(s[i - 1])`\\nThe other option is covering this tile\\n`cover = dp[i - l][k - 1]`\\n\\nThen we take the minimum result of two options:\\n`dp[i][k] = min(jump, cover)`\\n\\nFinally after explore all combination of `(i,k)`,\\nwe return `dp[n][nc]`.\\n<br>\\n\\n# **Complexity**\\nTime `O(NC)`\\nSpace `O(NC)`\\nwhere `N = floor.length` and `C = numCarpets`.\\nSpace can be optimized to `O(N)`.\\n<br>\\n\\n**Java**\\n```java\\n    public int minimumWhiteTiles(String s, int nc, int l) {\\n        int n = s.length(), dp[][] = new int[n + 1][nc + 1];\\n        for (int i = 1; i <= n; ++i) {\\n            for (int k = 0; k <= nc; ++k) {\\n                int jump = dp[i - 1][k] + s.charAt(i - 1) - \\'0\\';\\n                int cover = k > 0 ? dp[Math.max(i - l, 0)][k - 1] : 1000;\\n                dp[i][k] = Math.min(cover, jump);\\n            }\\n        }\\n        return dp[n][nc];\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minimumWhiteTiles(string s, int nc, int l) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(nc + 1));\\n        for (int i = 1; i <= n; ++i) {\\n            for (int k = 0; k <= nc; ++k) {\\n                int jump = dp[i - 1][k] + s[i - 1] - \\'0\\';\\n                int cover = k > 0 ? dp[max(i - l, 0)][k - 1] : 1000;\\n                dp[i][k] = min(cover, jump);\\n            }\\n        }\\n        return dp[n][nc];\\n    }\\n```\\n\\n**Python3**\\n```py\\n    def minimumWhiteTiles(self, A, k, l):\\n\\n        @lru_cache(None)\\n        def dp(i, k):\\n            if i <= 0: return 0\\n            return min(int(A[i - 1]) + dp(i - 1, k), dp(i - l, k - 1) if k else 1000)\\n            \\n        return dp(len(A), k) \\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minimumWhiteTiles(String s, int nc, int l) {\\n        int n = s.length(), dp[][] = new int[n + 1][nc + 1];\\n        for (int i = 1; i <= n; ++i) {\\n            for (int k = 0; k <= nc; ++k) {\\n                int jump = dp[i - 1][k] + s.charAt(i - 1) - \\'0\\';\\n                int cover = k > 0 ? dp[Math.max(i - l, 0)][k - 1] : 1000;\\n                dp[i][k] = Math.min(cover, jump);\\n            }\\n        }\\n        return dp[n][nc];\\n    }\\n```\n```cpp\\n    int minimumWhiteTiles(string s, int nc, int l) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(nc + 1));\\n        for (int i = 1; i <= n; ++i) {\\n            for (int k = 0; k <= nc; ++k) {\\n                int jump = dp[i - 1][k] + s[i - 1] - \\'0\\';\\n                int cover = k > 0 ? dp[max(i - l, 0)][k - 1] : 1000;\\n                dp[i][k] = min(cover, jump);\\n            }\\n        }\\n        return dp[n][nc];\\n    }\\n```\n```py\\n    def minimumWhiteTiles(self, A, k, l):\\n\\n        @lru_cache(None)\\n        def dp(i, k):\\n            if i <= 0: return 0\\n            return min(int(A[i - 1]) + dp(i - 1, k), dp(i - l, k - 1) if k else 1000)\\n            \\n        return dp(len(A), k) \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1864150,
                "title": "c-solution-top-down-dynamic-programming-recursion-memoization",
                "content": "Iterate over string `floor`:\\n\\n- At each index `pos` in the string `floor` we have two options:\\n\\n    - Use a carpet, that starts from the index `pos` and ends at `pos + carpetLength - 1`. All tiles in this part will change to black, hence move to index `pos + carpetLength`\\n    - Skip the index and move to next index `pos + 1`. This time the tile at index `pos` will be unchanged, thus add `1` to the answer if it\\'s a white tile.\\n\\n- After either of the options, recursively move to the next index. Return the minimum of the above two options.\\n\\nBase Case:\\n\\n- If we have traversed the whole string `floor`, then no white tiles present. Hence return `0`.\\n- If we have used all the available carpets, then the remaining string will not change. Hence return the number of `1`\\'s in the remaining string. (Store the number of `1`s for the suffix `[i, N]` in the array `suffix` beforehand, instead of finding it again and again).\\n\\nThere will be repeated subproblems corresponding to index (`pos`) and the number of carpet used (`used`). Hence store the result in the table `dp` and use it to answer repeated problems insetad of going into recursion.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int suffix[1001];\\n\\n    void findSuffixSum(string& floor) {\\n        int n = floor.size();\\n        \\n        suffix[n - 1] = (floor[n - 1] == \\'1\\');\\n        for (int i = n - 2; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] + (floor[i] == \\'1\\');\\n        }\\n    }\\n    \\n    int solve(string& floor, int numCarpets, int carpetLen, int pos, int used) {\\n        if (pos >= floor.size()) {\\n            return 0;\\n        } else if (used == numCarpets) {\\n            return suffix[pos];\\n        }\\n        \\n        if (dp[pos][used] != -1) {\\n            return dp[pos][used];\\n        }\\n\\n        return dp[pos][used] = min(solve(floor, numCarpets, carpetLen, pos + carpetLen, used + 1),\\n                      (floor[pos] == \\'1\\') + solve(floor, numCarpets, carpetLen, pos + 1, used));\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        memset(dp, -1, sizeof(dp));\\n        findSuffixSum(floor);\\n        \\n        return solve(floor, numCarpets, carpetLen, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int suffix[1001];\\n\\n    void findSuffixSum(string& floor) {\\n        int n = floor.size();\\n        \\n        suffix[n - 1] = (floor[n - 1] == \\'1\\');\\n        for (int i = n - 2; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] + (floor[i] == \\'1\\');\\n        }\\n    }\\n    \\n    int solve(string& floor, int numCarpets, int carpetLen, int pos, int used) {\\n        if (pos >= floor.size()) {\\n            return 0;\\n        } else if (used == numCarpets) {\\n            return suffix[pos];\\n        }\\n        \\n        if (dp[pos][used] != -1) {\\n            return dp[pos][used];\\n        }\\n\\n        return dp[pos][used] = min(solve(floor, numCarpets, carpetLen, pos + carpetLen, used + 1),\\n                      (floor[pos] == \\'1\\') + solve(floor, numCarpets, carpetLen, pos + 1, used));\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        memset(dp, -1, sizeof(dp));\\n        findSuffixSum(floor);\\n        \\n        return solve(floor, numCarpets, carpetLen, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863872,
                "title": "python-short-dp-explained",
                "content": "Problem constraints will help you to understand that this problem can be solved with `dp`. Let the state `dp(i, t)` be minimum number of white tiles when we allowed to use `t` number of carpets such that their right (and hence all carpets) lies in `[0, i]`. Then each moment of time we have option to take carpet or do not take it:\\n1. If we take, previous state is `dp(i - L, t - 1)`.\\n2. If we do not take it, previous state is `dp(i - 1, t) + `int(floor[i] == \"1\")`.\\n\\n#### Complexity\\nIt is `O(n^2)` for time and space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor, k, L):\\n        @lru_cache(None)\\n        def dp(i, t):\\n            if t < 0: return float(\"inf\")\\n            if i < 0: return 0\\n            return min(dp(i - L, t - 1), dp(i - 1, t) + int(floor[i] == \"1\"))\\n        \\n        return dp(len(floor) - 1, k)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor, k, L):\\n        @lru_cache(None)\\n        def dp(i, t):\\n            if t < 0: return float(\"inf\")\\n            if i < 0: return 0\\n            return min(dp(i - L, t - 1), dp(i - 1, t) + int(floor[i] == \"1\"))\\n        \\n        return dp(len(floor) - 1, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863912,
                "title": "dp-detailed-explanation-with-commented-code",
                "content": "Imagine we are covering the floor with carpets from left to right. At any point in this exercise, we will be at some point i and have carpetsRemaining carpets remaining. At this point we are only concerned with covering the floor from i to n - 1. \\nIn other words i can say that the state at any point is fully defined by (current position, carpets remaining)\\n\\nWhen we are standing at index i, we have 2 choices\\n\\t* either skip this tile and leave it uncovered\\n\\t* use one carpet starting from here.\\n\\nFirst off, If we are currently on a black tile, it makes no sense to start a new carpet here, so we just move one step to the right. (whatever white tiles we cover by starting here, we can cover from i + 1 and possibly more)\\nNow that we are on a white tile, \\n\\t* If we apply option 1 and skip this tile, we would expose 1 white tile and continue the exercise from tile i + 1 with the same number of carpets remaining\\n\\t* If we apply option 2 and start a new carpet here, we would use one carpet and continue the exercise from tile i + carpetLen.\\n\\twe would obviously want to take the option which would expose the minumum number of white tiles. \\n\\nIf f( i , carpetsRemaining ) represents the minimum number if white tiles exposed for the floor from i to n - 1 with carpetsRemaining carpets remaining, \\n//base cases\\n* if( i >= n) then ans = 0. ( we have fully covered the floor and are standing to the right of it)\\n* if( carpetsRemaining == 0 ) then ans = number of zeroes from i to n - 1. (We dont have any more carpets and will expose everything here on out)\\n```\\n\\tif(i >= a.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\tif(carpets_left == 0) {\\n\\t\\treturn suffix[i];      //suffix[i] = number of white tiles from index i to n (can be calculated using a simple for loop)\\n\\t}\\n```\\n//recursive cases\\n* if( floor[i] == BLACK ) then ans = f ( i + 1, carpetsRemaining). (Just ignore this tile, continue from next index)\\n* if( floor[i] == WHITE ) then ans = Max of\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t* 1 + f( i + 1, carpetsRemaining)      (expose this tile, hence + 1, and continue with same number of carpets)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t* f( i + carpetLen, carpetsRemaining - 1 )      (start a new carpet here, skip carpetLen tiles, but have 1 less carpet)\\n\\n```\\n\\t // first check if this state has already been visited, if so return the answer already computed\\n\\tif(dp[i][carpets_left] != UNVISITED) {      \\n\\t\\treturn dp[i][carpets_left];\\n\\t}\\n\\tif(a[i] == BLACK) {\\n\\t\\t//this tile is black, skip it\\n\\t\\tdp[i][carpets_left] = f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n\\t}\\n\\telse {\\n\\t\\t//start carpet here\\n\\t\\tint start_carpet_here = f(i + carpetLen, carpets_left - 1, a, dp, suffix, carpetLen);\\n\\t\\t//dont start carpet here\\n\\t\\tint dont_start_carpet_here = 1 + f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n\\t\\tdp[i][carpets_left] = Math.min(start_carpet_here, dont_start_carpet_here);\\n\\t}\\n\\n\\treturn dp[i][carpets_left];\\n```\\n\\nThere are (n * numCarpets) states, we momoize the result for each state in a 2D array.\\nTime Complexity: O(n * numCarpets)\\nSpace Complexity: O(n * numCarpets)\\n\\nFull Code:\\n```\\nclass Solution {\\n    private static final int UNVISITED = -1;\\n    private static final char BLACK = \\'0\\';\\n    private static final char WHITE = \\'1\\';\\n\\n    private int f(int i, int carpets_left, char[] a, int[][] dp, int[] suffix, int carpetLen) {\\n        if(i >= a.length) {\\n            return 0;\\n        }\\n        if(carpets_left == 0) {\\n            return suffix[i];\\n        }\\n        if(dp[i][carpets_left] != UNVISITED) {\\n            return dp[i][carpets_left];\\n        }\\n        if(a[i] == BLACK) {\\n            dp[i][carpets_left] = f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n        }\\n        else {\\n            //start carpet here\\n            int start = f(i + carpetLen, carpets_left - 1, a, dp, suffix, carpetLen);\\n            //dont start carpet here\\n            int dont = 1 + f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n\\n            dp[i][carpets_left] = Math.min(start, dont);\\n        }\\n\\n        return dp[i][carpets_left];\\n    }\\n\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        int n = floor.length();\\n        char[] a = floor.toCharArray();\\n        \\n        //calculating the suffix array\\n        int[] suffix = new int[n + 1];\\n        for(int i = n - 1; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1];\\n            if(a[i] == WHITE) {\\n                suffix[i] ++;\\n            }\\n        }\\n        \\n        int[][] dp = new int[n + 1][numCarpets + 1];\\n        for(int[] row : dp) {\\n            Arrays.fill(row, UNVISITED);\\n        }\\n\\n        return f(0, numCarpets, a, dp, suffix, carpetLen);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tif(i >= a.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\tif(carpets_left == 0) {\\n\\t\\treturn suffix[i];      //suffix[i] = number of white tiles from index i to n (can be calculated using a simple for loop)\\n\\t}\\n```\n```\\n\\t // first check if this state has already been visited, if so return the answer already computed\\n\\tif(dp[i][carpets_left] != UNVISITED) {      \\n\\t\\treturn dp[i][carpets_left];\\n\\t}\\n\\tif(a[i] == BLACK) {\\n\\t\\t//this tile is black, skip it\\n\\t\\tdp[i][carpets_left] = f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n\\t}\\n\\telse {\\n\\t\\t//start carpet here\\n\\t\\tint start_carpet_here = f(i + carpetLen, carpets_left - 1, a, dp, suffix, carpetLen);\\n\\t\\t//dont start carpet here\\n\\t\\tint dont_start_carpet_here = 1 + f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n\\t\\tdp[i][carpets_left] = Math.min(start_carpet_here, dont_start_carpet_here);\\n\\t}\\n\\n\\treturn dp[i][carpets_left];\\n```\n```\\nclass Solution {\\n    private static final int UNVISITED = -1;\\n    private static final char BLACK = \\'0\\';\\n    private static final char WHITE = \\'1\\';\\n\\n    private int f(int i, int carpets_left, char[] a, int[][] dp, int[] suffix, int carpetLen) {\\n        if(i >= a.length) {\\n            return 0;\\n        }\\n        if(carpets_left == 0) {\\n            return suffix[i];\\n        }\\n        if(dp[i][carpets_left] != UNVISITED) {\\n            return dp[i][carpets_left];\\n        }\\n        if(a[i] == BLACK) {\\n            dp[i][carpets_left] = f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n        }\\n        else {\\n            //start carpet here\\n            int start = f(i + carpetLen, carpets_left - 1, a, dp, suffix, carpetLen);\\n            //dont start carpet here\\n            int dont = 1 + f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n\\n            dp[i][carpets_left] = Math.min(start, dont);\\n        }\\n\\n        return dp[i][carpets_left];\\n    }\\n\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        int n = floor.length();\\n        char[] a = floor.toCharArray();\\n        \\n        //calculating the suffix array\\n        int[] suffix = new int[n + 1];\\n        for(int i = n - 1; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1];\\n            if(a[i] == WHITE) {\\n                suffix[i] ++;\\n            }\\n        }\\n        \\n        int[][] dp = new int[n + 1][numCarpets + 1];\\n        for(int[] row : dp) {\\n            Arrays.fill(row, UNVISITED);\\n        }\\n\\n        return f(0, numCarpets, a, dp, suffix, carpetLen);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863967,
                "title": "memory-optimized-dp",
                "content": "It feels like there could be some clever way to lay carpets, but there isn\\'t. We need to search for an optimal solution.\\n\\n> Note: problem constrains give it away.\\n\\nWe start with the top-down approach, and then convert it to the bottom-up one. By analyzing the tabulation, we can reduce the memory usage to O(n). The runtime for the final, memory-optimized bottom-up approach is 120 ms.\\n\\n#### Top-Down\\nFor the search, we can skip positions with black tiles.\\n**C++**\\n```cpp\\nint dp[1001][1001] = {};\\nint dfs(string &floor, int i, int n, int len) {\\n    if (n < 0)\\n        return floor.size();\\n    if (floor.size() - i <= n * len)\\n        return 0;\\n    if (floor[i] == \\'0\\')\\n        return dfs(floor, i + 1, n, len);\\n    if (dp[i][n] == 0)\\n        dp[i][n] = 1 + min(1 + dfs(floor, i + 1, n, len), dfs(floor, i + len, n - 1, len)); \\n    return dp[i][n] - 1;\\n}\\nint minimumWhiteTiles(string floor, int numCarpets, int len) {\\n    return dfs(floor, 0, numCarpets, len);\\n} \\n```\\n\\n#### Bottom-Up\\n**C++**\\n```cpp\\nint dp[1001][1001] = {};\\nint minimumWhiteTiles(string floor, int numCarpets, int len) {\\n    for (int i = floor.size() - 1; i >= 0; --i) {\\n        dp[i][0] = dp[i + 1][0] + (floor[i] == \\'1\\');\\n        for (int c = 1; c <= numCarpets; ++c)\\n            dp[i][c] = min(dp[i + 1][c] + (floor[i] == \\'1\\'), dp[min(1000, i + len)][c - 1]);\\n    }\\n    return dp[0][numCarpets];\\n}  \\n```\\n\\n#### Memory-Optimized Bottom-Up DP\\nWe can rearrange loops from the solution above so that the first loop iterates through carpets. That way, we only need to store tabulation values for the current and previous step. \\n\\n**C++**\\n```cpp\\nint minimumWhiteTiles(string floor, int numCarpets, int len) {\\n    int sz = floor.size(), dp[2][1001] = {};\\n    for (int i = 0; i < sz; ++i)\\n        dp[0][i + 1] += dp[0][i] + (floor[i] == \\'1\\');  \\n    for (int c = 1; c <= numCarpets; ++c)\\n        for (int i = 0; i < sz; ++i)\\n            dp[c % 2][i + 1] = min(dp[c % 2][i] + (floor[i] == \\'1\\'),\\n                dp[(c + 1) % 2][max(0, i + 1 - len)]);\\n    return dp[numCarpets % 2][sz];\\n} \\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dp[1001][1001] = {};\\nint dfs(string &floor, int i, int n, int len) {\\n    if (n < 0)\\n        return floor.size();\\n    if (floor.size() - i <= n * len)\\n        return 0;\\n    if (floor[i] == \\'0\\')\\n        return dfs(floor, i + 1, n, len);\\n    if (dp[i][n] == 0)\\n        dp[i][n] = 1 + min(1 + dfs(floor, i + 1, n, len), dfs(floor, i + len, n - 1, len)); \\n    return dp[i][n] - 1;\\n}\\nint minimumWhiteTiles(string floor, int numCarpets, int len) {\\n    return dfs(floor, 0, numCarpets, len);\\n} \\n```\n```cpp\\nint dp[1001][1001] = {};\\nint minimumWhiteTiles(string floor, int numCarpets, int len) {\\n    for (int i = floor.size() - 1; i >= 0; --i) {\\n        dp[i][0] = dp[i + 1][0] + (floor[i] == \\'1\\');\\n        for (int c = 1; c <= numCarpets; ++c)\\n            dp[i][c] = min(dp[i + 1][c] + (floor[i] == \\'1\\'), dp[min(1000, i + len)][c - 1]);\\n    }\\n    return dp[0][numCarpets];\\n}  \\n```\n```cpp\\nint minimumWhiteTiles(string floor, int numCarpets, int len) {\\n    int sz = floor.size(), dp[2][1001] = {};\\n    for (int i = 0; i < sz; ++i)\\n        dp[0][i + 1] += dp[0][i] + (floor[i] == \\'1\\');  \\n    for (int c = 1; c <= numCarpets; ++c)\\n        for (int i = 0; i < sz; ++i)\\n            dp[c % 2][i + 1] = min(dp[c % 2][i] + (floor[i] == \\'1\\'),\\n                dp[(c + 1) % 2][max(0, i + 1 - len)]);\\n    return dp[numCarpets % 2][sz];\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1863927,
                "title": "c-easy-to-understand-with-explanation-and-optimizations-dp",
                "content": "Hello, while it may seem like a difficult one, the fourth question can be done with an almost bruteforce approach with some optimizations.\\n\\nLet dp[i][j] denote the maximum number of ones we can cover with i carpets till index j(**with current carpet ending exactly at index j**). Assuming that the current carpet ends at exactly j *greatly simplifies* the problem\\n\\nNow, dp[i][j]= number of ones in string[j:j-len]+ max(dp[i-1][j-len], dp[i-1][j-len-1],....dp[i-1][0])\\n\\nOptimizations:\\nWe store this max part of previous iteration of i till j-len in a helper variable. (prevmax)\\nWe use prefix sum array to calculate number of white blocks in a range in O(1) time\\nWe only need the ith and i-1th rows of the dp array, so space can be reduced (didn\\'t do it due to time constraints during contest)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int dp[1001][1001]={0};\\n        int pre[1000]={0};\\n        if(floor[0]==\\'1\\')pre[0]=1;\\n        for(int i=1;i<floor.size();i++){\\n            pre[i]+=pre[i-1];\\n            if(floor[i]==\\'1\\')pre[i]++;\\n        }\\n        for(int i=1;i<=numCarpets;i++){\\n            int prevmax=0;\\n            for(int j=0;j<floor.size();j++){\\n                if(j<carpetLen) dp[i][j]=pre[j];\\n                else{\\n                    prevmax=max(prevmax,dp[i-1][j-carpetLen]);\\n                    dp[i][j]=pre[j]-pre[j-carpetLen]+prevmax;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<floor.size();i++)ans=max(ans,dp[numCarpets][i]);\\n        return pre[floor.size()-1]-ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int dp[1001][1001]={0};\\n        int pre[1000]={0};\\n        if(floor[0]==\\'1\\')pre[0]=1;\\n        for(int i=1;i<floor.size();i++){\\n            pre[i]+=pre[i-1];\\n            if(floor[i]==\\'1\\')pre[i]++;\\n        }\\n        for(int i=1;i<=numCarpets;i++){\\n            int prevmax=0;\\n            for(int j=0;j<floor.size();j++){\\n                if(j<carpetLen) dp[i][j]=pre[j];\\n                else{\\n                    prevmax=max(prevmax,dp[i-1][j-carpetLen]);\\n                    dp[i][j]=pre[j]-pre[j-carpetLen]+prevmax;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<floor.size();i++)ans=max(ans,dp[numCarpets][i]);\\n        return pre[floor.size()-1]-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864377,
                "title": "java-knapsack-solution",
                "content": "```\\nclass Solution {\\n    int pref[];\\n\\n    public int minimumWhiteTiles(String floor, int tot, int len) {\\n        char a[] = floor.toCharArray();\\n        this.pref = new int[a.length];\\n        int c = 0;\\n        this.dp = new int[a.length + 1][tot + 1];\\n        for (int d[] : dp) Arrays.fill(d, -1);\\n        for (int i = 0; i < a.length; i++) {\\n            if (a[i] == \\'1\\') c++;\\n            pref[i] = c;\\n        }\\n        return pref[a.length - 1] - solve(0, a, tot, len);  // total ones - max removed\\n    }\\n\\n    int dp[][];\\n\\n    private int solve(int index, char a[], int tot, int len) {\\n        if (index >= a.length || tot == 0) {\\n            return 0;\\n        }\\n        if (dp[index][tot] != -1) return dp[index][tot];\\n        int ones = pref[Math.min(index + len - 1, a.length - 1)] - (index == 0 ? 0 : pref[index - 1]);\\n        int take = ones + solve(index + len, a, tot - 1, len);  // either take it and add one\\'s count in that subsegment\\n        int dont = solve(index + 1, a, tot, len);  // or dont \\n        return dp[index][tot] = Math.max(take, dont);  // return max of both\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int pref[];\\n\\n    public int minimumWhiteTiles(String floor, int tot, int len) {\\n        char a[] = floor.toCharArray();\\n        this.pref = new int[a.length];\\n        int c = 0;\\n        this.dp = new int[a.length + 1][tot + 1];\\n        for (int d[] : dp) Arrays.fill(d, -1);\\n        for (int i = 0; i < a.length; i++) {\\n            if (a[i] == \\'1\\') c++;\\n            pref[i] = c;\\n        }\\n        return pref[a.length - 1] - solve(0, a, tot, len);  // total ones - max removed\\n    }\\n\\n    int dp[][];\\n\\n    private int solve(int index, char a[], int tot, int len) {\\n        if (index >= a.length || tot == 0) {\\n            return 0;\\n        }\\n        if (dp[index][tot] != -1) return dp[index][tot];\\n        int ones = pref[Math.min(index + len - 1, a.length - 1)] - (index == 0 ? 0 : pref[index - 1]);\\n        int take = ones + solve(index + len, a, tot - 1, len);  // either take it and add one\\'s count in that subsegment\\n        int dont = solve(index + 1, a, tot, len);  // or dont \\n        return dp[index][tot] = Math.max(take, dont);  // return max of both\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863879,
                "title": "c-fixed-length-sliding-window-dp",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Fixed-length Sliding Window + DP\\n\\n**Intuition**:\\n\\n1. Use a sliding window of length `carpetLen` to compute a `cover` array where `cover[i]` is the number of white tiles covered by a carpet placed ending at `floor[i]`.\\n2. Use DP to calculate the maximum coverable white tiles using `numCarpets` carpets.\\n\\n**Algorithm**:\\n\\n**Fixed-length Sliding Window**:\\n\\nKeep a rolling sum `white` as the number of white tiles within the sliding window.\\n\\nFor each `i` in range `[0, N)`, we:\\n* increment `white` if `s[i] == \\'1\\'`\\n* decrement `white` if `s[i - len] == \\'1\\'`\\n* Set `cover[i] = white`.\\n\\n**DP**:\\n\\nLet `dp[i][j + 1]` be the maximum number of coverable white tiles where `1 <= i <= numCarpet` is number of carpets used and `0 <= j < N` is the last index where we can place carpet.\\n\\nAll `dp` values are initialized as `0`s.\\n\\nFor each `dp[i][j + 1]`, we have two options:\\n1. Don\\'t place carpet at index `j`. `dp[i][j+1] = dp[i][j]`\\n2. Place carpet ending at index `j` covering `cover[j]` white tiles. And we can place `i-1` carpets at or before `j-carpetLen`. So, `dp[i][j+1] = dp[i-1][j-carpetLen+1] + cover[j]`.\\n\\n```\\ndp[i][j + 1] = max(\\n                    dp[i][j],                                                                   // don\\'t place carpet at index `j`\\n                    (j - carpetLen + 1 >= 0 ? dp[i - 1][j - carpetLen + 1] : 0) + cover[j]      // place carpet at index `j`\\n                  )\\n```\\n\\n`dp[numCarpet][N]` is the maximum number of white titles coverable. The answer is the number of total white tiles minus `dp[numCarpet][N]`. \\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-white-tiles-after-covering-with-carpets/\\n// Author: github.com/lzl124631x\\n// Time: O(N * numCarpet)\\n// Space: O(N * numCarpet)\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpet, int carpetLen) {\\n        int N = floor.size(), sum = 0;\\n        vector<int> cover(N);\\n        for (int i = 0, white = 0; i < N; ++i) {\\n            sum += floor[i] - \\'0\\';\\n            white += floor[i] - \\'0\\';\\n            if (i - carpetLen >= 0) white -= floor[i - carpetLen] - \\'0\\'; \\n            cover[i] = white;\\n        }\\n        vector<vector<int>> dp(numCarpet + 1, vector<int>(N + 1));\\n        for (int i = 1; i <= numCarpet; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                dp[i][j + 1] = max(dp[i][j], (j - carpetLen + 1 >= 0 ? dp[i - 1][j - carpetLen + 1] : 0) + cover[j]);\\n            }\\n        }\\n        return sum - dp[numCarpet][N];\\n    }\\n};\\n```\\n\\nWe can reduce the space complexity to `O(N)` by using rolling arrays.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-white-tiles-after-covering-with-carpets/\\n// Author: github.com/lzl124631x\\n// Time: O(N * numCarpet)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpet, int carpetLen) {\\n        int N = floor.size(), sum = 0;\\n        vector<int> cover(N);\\n        for (int i = 0, white = 0; i < N; ++i) {\\n            sum += floor[i] - \\'0\\';\\n            white += floor[i] - \\'0\\';\\n            if (i - carpetLen >= 0) white -= floor[i - carpetLen] - \\'0\\'; \\n            cover[i] = white;\\n        }\\n        vector<int> dp(N + 1);\\n        for (int i = 1; i <= numCarpet; ++i) {\\n            vector<int> next(N + 1);\\n            for (int j = 0; j < N; ++j) {\\n                next[j + 1] = max(next[j], (j - carpetLen + 1 >= 0 ? dp[j - carpetLen + 1] : 0) + cover[j]);\\n            }\\n            swap(dp, next);\\n        }\\n        return sum - dp[N];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i][j + 1] = max(\\n                    dp[i][j],                                                                   // don\\'t place carpet at index `j`\\n                    (j - carpetLen + 1 >= 0 ? dp[i - 1][j - carpetLen + 1] : 0) + cover[j]      // place carpet at index `j`\\n                  )\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-white-tiles-after-covering-with-carpets/\\n// Author: github.com/lzl124631x\\n// Time: O(N * numCarpet)\\n// Space: O(N * numCarpet)\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpet, int carpetLen) {\\n        int N = floor.size(), sum = 0;\\n        vector<int> cover(N);\\n        for (int i = 0, white = 0; i < N; ++i) {\\n            sum += floor[i] - \\'0\\';\\n            white += floor[i] - \\'0\\';\\n            if (i - carpetLen >= 0) white -= floor[i - carpetLen] - \\'0\\'; \\n            cover[i] = white;\\n        }\\n        vector<vector<int>> dp(numCarpet + 1, vector<int>(N + 1));\\n        for (int i = 1; i <= numCarpet; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                dp[i][j + 1] = max(dp[i][j], (j - carpetLen + 1 >= 0 ? dp[i - 1][j - carpetLen + 1] : 0) + cover[j]);\\n            }\\n        }\\n        return sum - dp[numCarpet][N];\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-white-tiles-after-covering-with-carpets/\\n// Author: github.com/lzl124631x\\n// Time: O(N * numCarpet)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpet, int carpetLen) {\\n        int N = floor.size(), sum = 0;\\n        vector<int> cover(N);\\n        for (int i = 0, white = 0; i < N; ++i) {\\n            sum += floor[i] - \\'0\\';\\n            white += floor[i] - \\'0\\';\\n            if (i - carpetLen >= 0) white -= floor[i - carpetLen] - \\'0\\'; \\n            cover[i] = white;\\n        }\\n        vector<int> dp(N + 1);\\n        for (int i = 1; i <= numCarpet; ++i) {\\n            vector<int> next(N + 1);\\n            for (int j = 0; j < N; ++j) {\\n                next[j + 1] = max(next[j], (j - carpetLen + 1 >= 0 ? dp[j - carpetLen + 1] : 0) + cover[j]);\\n            }\\n            swap(dp, next);\\n        }\\n        return sum - dp[N];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864445,
                "title": "c-knapsack-memoization",
                "content": "```\\nclass Solution {\\n    int n;\\n    vector<int> suffix;\\n    vector<vector<int>> memo;\\npublic:\\n    \\n    int doit(string& floor, int carp, int len, int ind) {\\n        if (ind >= n)   return 0;\\n        if (carp == 0)  return suffix[ind]; // if no carpets are left then all the white tiles from current index to the last will be visible\\n        if (memo[carp][ind] != -1)  return memo[carp][ind];\\n        int a = doit(floor, carp-1, len, ind+len); // carpet is used\\n        int b = doit(floor, carp, len, ind+1) + (floor[ind] == \\'1\\'); // carpet is not used\\n        return memo[carp][ind] = min(a, b);\\n    }\\n        \\n    int minimumWhiteTiles(string floor, int carp, int len) {\\n        \\n        n = size(floor);\\n        suffix.resize(n+1, 0);\\n        memo.resize(carp+1, vector<int>(n+1, -1));\\n        suffix[n-1] = (floor[n-1] == \\'1\\');\\n        for (int i=n-2; ~i; i--)\\n            suffix[i] = suffix[i+1] + (floor[i] == \\'1\\');\\n        \\n        return doit(floor, carp, len, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    vector<int> suffix;\\n    vector<vector<int>> memo;\\npublic:\\n    \\n    int doit(string& floor, int carp, int len, int ind) {\\n        if (ind >= n)   return 0;\\n        if (carp == 0)  return suffix[ind]; // if no carpets are left then all the white tiles from current index to the last will be visible\\n        if (memo[carp][ind] != -1)  return memo[carp][ind];\\n        int a = doit(floor, carp-1, len, ind+len); // carpet is used\\n        int b = doit(floor, carp, len, ind+1) + (floor[ind] == \\'1\\'); // carpet is not used\\n        return memo[carp][ind] = min(a, b);\\n    }\\n        \\n    int minimumWhiteTiles(string floor, int carp, int len) {\\n        \\n        n = size(floor);\\n        suffix.resize(n+1, 0);\\n        memo.resize(carp+1, vector<int>(n+1, -1));\\n        suffix[n-1] = (floor[n-1] == \\'1\\');\\n        for (int i=n-2; ~i; i--)\\n            suffix[i] = suffix[i+1] + (floor[i] == \\'1\\');\\n        \\n        return doit(floor, carp, len, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864242,
                "title": "c-dp-memoization",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int recur(string &s, int numCarpets, int len, int i, vector<vector < int>> &dp, vector< int > &sufOnes)\\n        {\\n            if (i >= s.size())\\n                return 0;\\n            if (numCarpets == 0)\\n                return sufOnes[i];\\n\\n            if (dp[i][numCarpets] != -1)\\n            {\\n                return dp[i][numCarpets];\\n            }\\n            if (s[i] == \\'0\\')\\n            {\\n                dp[i][numCarpets] = recur(s, numCarpets, len, i + 1, dp, sufOnes);\\n            }\\n            else\\n            {\\n               \\t//start carpet here\\n                int start = recur(s, numCarpets - 1, len, i + len, dp, sufOnes);\\n               \\t//dont start carpet here\\n                int dont = 1 + recur(s, numCarpets, len, i + 1, dp, sufOnes);\\n\\n                dp[i][numCarpets] = min(start, dont);\\n            }\\n\\n            return dp[i][numCarpets];\\n        }\\n    int minimumWhiteTiles(string s, int n, int len)\\n    {\\n        int nn = s.size() + 1, mm = n + 1;\\n        vector<int> sufOnes(s.size() + 1, 0);\\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            sufOnes[i] = sufOnes[i + 1];\\n            if (s[i] == \\'1\\')\\n            {\\n                sufOnes[i]++;\\n            }\\n        }\\n        vector<vector < int>> dp(nn, vector<int> (mm, -1));\\n        return recur(s, n, len, 0, dp, sufOnes);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int recur(string &s, int numCarpets, int len, int i, vector<vector < int>> &dp, vector< int > &sufOnes)\\n        {\\n            if (i >= s.size())\\n                return 0;\\n            if (numCarpets == 0)\\n                return sufOnes[i];\\n\\n            if (dp[i][numCarpets] != -1)\\n            {\\n                return dp[i][numCarpets];\\n            }\\n            if (s[i] == \\'0\\')\\n            {\\n                dp[i][numCarpets] = recur(s, numCarpets, len, i + 1, dp, sufOnes);\\n            }\\n            else\\n            {\\n               \\t//start carpet here\\n                int start = recur(s, numCarpets - 1, len, i + len, dp, sufOnes);\\n               \\t//dont start carpet here\\n                int dont = 1 + recur(s, numCarpets, len, i + 1, dp, sufOnes);\\n\\n                dp[i][numCarpets] = min(start, dont);\\n            }\\n\\n            return dp[i][numCarpets];\\n        }\\n    int minimumWhiteTiles(string s, int n, int len)\\n    {\\n        int nn = s.size() + 1, mm = n + 1;\\n        vector<int> sufOnes(s.size() + 1, 0);\\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            sufOnes[i] = sufOnes[i + 1];\\n            if (s[i] == \\'1\\')\\n            {\\n                sufOnes[i]++;\\n            }\\n        }\\n        vector<vector < int>> dp(nn, vector<int> (mm, -1));\\n        return recur(s, n, len, 0, dp, sufOnes);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863886,
                "title": "c-dp-memoization",
                "content": "```\\n\\tvector<vector<int>> dp;\\n    int func(int i,string& s,int car,int len){\\n        if(i>=s.size()) return 0;\\n        if(dp[i][car]!=-1) return dp[i][car];\\n        if(s[i]==\\'0\\') return dp[i][car]=func(i+1,s,car,len);\\n        else{ \\n            int ans=INT_MAX;\\n            ans=1+func(i+1,s,car,len);\\n            if(car>0) ans=min(ans,func(i+len,s,car-1,len));\\n            return dp[i][car]=ans;\\n        }\\n    }\\n    int minimumWhiteTiles(string s, int car, int len) {\\n        dp=vector<vector<int>>(s.size(),vector<int>(car+1,-1));\\n        return func(0,s,car,len);\\n    }",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\n\\tvector<vector<int>> dp;\\n    int func(int i,string& s,int car,int len){\\n        if(i>=s.size()) return 0;\\n        if(dp[i][car]!=-1) return dp[i][car];\\n        if(s[i]==\\'0\\') return dp[i][car]=func(i+1,s,car,len);\\n        else{ \\n            int ans=INT_MAX;\\n            ans=1+func(i+1,s,car,len);\\n            if(car>0) ans=min(ans,func(i+len,s,car-1,len));\\n            return dp[i][car]=ans;\\n        }\\n    }\\n    int minimumWhiteTiles(string s, int car, int len) {\\n        dp=vector<vector<int>>(s.size(),vector<int>(car+1,-1));\\n        return func(0,s,car,len);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1872882,
                "title": "python-readable-and-easy-understand-bottom-up-dp-solution-in-python",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n        if carpetLen*numCarpets >= n:\\n            return 0\\n        floorlist = []\\n        for i in floor:\\n            if i == \\'1\\':\\n                floorlist.append(1)\\n            else:\\n                floorlist.append(0)\\n        dp=[[0] * n for i in range(numCarpets)]\\n        \\n        for i in range(carpetLen, n):\\n            dp[0][i] = min(floorlist[i] + dp[0][i-1], sum(floorlist[:i - carpetLen + 1]))\\n        for j in range(1, numCarpets):\\n            for i in range(carpetLen * j, n):\\n                dp[j][i] = min(floorlist[i] + dp[j][i - 1], dp[j - 1][i - carpetLen])\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n        if carpetLen*numCarpets >= n:\\n            return 0\\n        floorlist = []\\n        for i in floor:\\n            if i == \\'1\\':\\n                floorlist.append(1)\\n            else:\\n                floorlist.append(0)\\n        dp=[[0] * n for i in range(numCarpets)]\\n        \\n        for i in range(carpetLen, n):\\n            dp[0][i] = min(floorlist[i] + dp[0][i-1], sum(floorlist[:i - carpetLen + 1]))\\n        for j in range(1, numCarpets):\\n            for i in range(carpetLen * j, n):\\n                dp[j][i] = min(floorlist[i] + dp[j][i - 1], dp[j - 1][i - carpetLen])\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332778,
                "title": "c-simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int dfs(string &floor, int Carpets, int Len, int idx, vector<vector<int>> &dp)\\n    {\\n        if(idx >= floor.size())\\n            return 0;\\n        int val = 0;\\n        if(dp[idx][Carpets] != -1) return dp[idx][Carpets];\\n        if(Carpets == 0)\\n        {\\n            for(int i = idx; i < floor.size(); i++)\\n                if(floor[i] == \\'1\\') val++;\\n        }\\n        else\\n        {\\n            if(floor[idx] == \\'0\\')\\n                val = dfs(floor, Carpets, Len, idx+1, dp);\\n            else\\n            {\\n                val = min(1+dfs(floor, Carpets, Len, idx+1, dp), dfs(floor, Carpets-1, Len, idx+Len, dp));\\n            }\\n        }\\n        return dp[idx][Carpets] = val;\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        vector<vector<int>> dp(n+1, vector<int> (numCarpets+1, -1));\\n        return dfs(floor, numCarpets, carpetLen, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(string &floor, int Carpets, int Len, int idx, vector<vector<int>> &dp)\\n    {\\n        if(idx >= floor.size())\\n            return 0;\\n        int val = 0;\\n        if(dp[idx][Carpets] != -1) return dp[idx][Carpets];\\n        if(Carpets == 0)\\n        {\\n            for(int i = idx; i < floor.size(); i++)\\n                if(floor[i] == \\'1\\') val++;\\n        }\\n        else\\n        {\\n            if(floor[idx] == \\'0\\')\\n                val = dfs(floor, Carpets, Len, idx+1, dp);\\n            else\\n            {\\n                val = min(1+dfs(floor, Carpets, Len, idx+1, dp), dfs(floor, Carpets-1, Len, idx+Len, dp));\\n            }\\n        }\\n        return dp[idx][Carpets] = val;\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        vector<vector<int>> dp(n+1, vector<int> (numCarpets+1, -1));\\n        return dfs(floor, numCarpets, carpetLen, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864204,
                "title": "recursion-memoization-time-saver-trick",
                "content": "```\\nclass Solution {\\npublic: \\n    int dp[1001][1001];\\n    int helper(string &floor, int idx, int numCarpets, int len)\\n    {\\n        if(idx >= floor.size())\\n            return 0;\\n\\t\\t\\t\\n        int &ans = dp[idx][numCarpets]; //reference variable so that we dont have to write this again \\n        \\n        if(ans != -1) //if state already calculated no need to calculate again directly return its value\\n            return ans;\\n        \\n        int op1 = INT_MAX, op2 = INT_MAX;\\n\\t\\t//when you dont use a new carpet from the current index\\n        op1 = (floor[idx] == \\'1\\') + helper(floor, idx+1, numCarpets, len);\\n\\t\\t//when you use a new carpet from the current index\\n        if(numCarpets > 0)\\n        op2 = helper(floor, idx+len, numCarpets-1, len);\\n        return ans = min(op1, op2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetlen) {\\n        memset(dp, -1, sizeof(dp));\\n        return helper(floor, 0, numCarpets, carpetlen);\\n    }\\n};\\n\\n```\\nThe question could be solved in a recursive manner where you just need to know the index and the number of carpets left, now at any index we have two options either we can use the available carpets or we can leave this index as it is. We can consider both options and return the minimum of both the available options.\\n\\nI have used a trick that is I used a reference variable to store dp[idx][numCarpets], now imagine those questions where we have 3 or 4 states and we don\\'t want those dp[][][] states again and again. We can simply use reference variables and we can use them our code to save sometime in competitions.\\n\\nPlease upvote if you have learnt anything from this post.",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int dp[1001][1001];\\n    int helper(string &floor, int idx, int numCarpets, int len)\\n    {\\n        if(idx >= floor.size())\\n            return 0;\\n\\t\\t\\t\\n        int &ans = dp[idx][numCarpets]; //reference variable so that we dont have to write this again \\n        \\n        if(ans != -1) //if state already calculated no need to calculate again directly return its value\\n            return ans;\\n        \\n        int op1 = INT_MAX, op2 = INT_MAX;\\n\\t\\t//when you dont use a new carpet from the current index\\n        op1 = (floor[idx] == \\'1\\') + helper(floor, idx+1, numCarpets, len);\\n\\t\\t//when you use a new carpet from the current index\\n        if(numCarpets > 0)\\n        op2 = helper(floor, idx+len, numCarpets-1, len);\\n        return ans = min(op1, op2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetlen) {\\n        memset(dp, -1, sizeof(dp));\\n        return helper(floor, 0, numCarpets, carpetlen);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863913,
                "title": "python-dynamic-programming-prefix-sum-solution-explained",
                "content": "So this is a dynamic programming question with a trick.\\nYou can guess it using the given constraints.\\nThe solution can be divided into two parts:\\n*  Recursively find ways to use carpets to cover the floor \\n* Optimize using **Prefix Sum** to find the number of white tiles present between two indices of the floor\\n\\nPlease read through the comments for better understanding!\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n\\t\\tn = len(floor)\\n\\t\\t#Using memo table to store predefined computations\\n        memo = [[-1 for x in range(numCarpets+1)] for x in range(len(floor)+1)] \\n        def solve(N,numCarpets):\\n\\t\\t\\t#Base Case\\n            if N>=n:\\n                return 0\\n\\t\\t\\t#If calculated previously use that solution\\n            if memo[N][numCarpets]!=-1:\\n                return memo[N][numCarpets]\\n\\t\\t\\t\\t\\n            used = 0 # If you use the carpet\\n            notused = 0 # If you donot use the carpet\\n\\t\\t\\t\\n            if floor[N]==\\'1\\': # We might use the carpet in this part\\n                if numCarpets>0: #Whether we even have some carpets or not\\n\\t\\t\\t\\t    \"\"\"\\n\\t\\t\\t\\t\\tOptimization Part\\n\\t\\t\\t\\t\\tWe are finding the number of ones present in this part of the floor.\\n\\t\\t\\t\\t\\tprefix[lastInd] - Number of ones till lastInd\\n\\t\\t\\t\\t\\tprefix[N] - Number of ones till Nth Index.\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tTheir difference gives us how many ones present between the two.\\n\\t\\t\\t\\t    \"\"\"\\n                    lastInd = min(N+carpetLen,len(floor)) \\n                    ans = prefix[lastInd] - prefix[N]\\n                    \\n\\t\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\t\\tFind the max if we use or donot use carpet at this index\\n\\t\\t\\t\\t\\tIf we do we add  --- ans and decrement remaining carpets\\n\\t\\t\\t\\t\\telse we donot\\n\\t\\t\\t\\t\\t\"\"\"\\n                    used = max(solve(N+carpetLen,numCarpets-1)+ans,solve(N+1,numCarpets))\\n                            \\n                else:\\n                    used = 0\\n            \\n            else:\\n\\t\\t\\t#If we donot use the carpet although I feel this might be redundant code\\n                notused = solve(N+1,numCarpets)\\n            \\n\\t\\t\\t#Using max function to find the number of white tiles removed\\n            memo[N][numCarpets] = max(used,notused)\\n            return memo[N][numCarpets]\\n\\t\\t\\n\\t\\t#Total White tiles\\n        ones = 0\\n        for x in floor:\\n            if x == \\'1\\':\\n                ones+=1\\n        \\n\\t\\t#Using Prefix array to store number of ones till i th index\\n        prefix = [0]*(n+1)\\n        for i in range(1,n+1):\\n            if floor[i-1]==\\'1\\':\\n                prefix[i] = prefix[i-1]+1\\n            else:\\n                prefix[i] = prefix[i-1]\\n\\t\\t\\t\\t\\n       \\n        removed = solve(0,numCarpets)\\n        \\n        return ones-removed\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n\\t\\tn = len(floor)\\n\\t\\t#Using memo table to store predefined computations\\n        memo = [[-1 for x in range(numCarpets+1)] for x in range(len(floor)+1)] \\n        def solve(N,numCarpets):\\n\\t\\t\\t#Base Case\\n            if N>=n:\\n                return 0\\n\\t\\t\\t#If calculated previously use that solution\\n            if memo[N][numCarpets]!=-1:\\n                return memo[N][numCarpets]\\n\\t\\t\\t\\t\\n            used = 0 # If you use the carpet\\n            notused = 0 # If you donot use the carpet\\n\\t\\t\\t\\n            if floor[N]==\\'1\\': # We might use the carpet in this part\\n                if numCarpets>0: #Whether we even have some carpets or not\\n\\t\\t\\t\\t    \"\"\"\\n\\t\\t\\t\\t\\tOptimization Part\\n\\t\\t\\t\\t\\tWe are finding the number of ones present in this part of the floor.\\n\\t\\t\\t\\t\\tprefix[lastInd] - Number of ones till lastInd\\n\\t\\t\\t\\t\\tprefix[N] - Number of ones till Nth Index.\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tTheir difference gives us how many ones present between the two.\\n\\t\\t\\t\\t    \"\"\"\\n                    lastInd = min(N+carpetLen,len(floor)) \\n                    ans = prefix[lastInd] - prefix[N]\\n                    \\n\\t\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\t\\tFind the max if we use or donot use carpet at this index\\n\\t\\t\\t\\t\\tIf we do we add  --- ans and decrement remaining carpets\\n\\t\\t\\t\\t\\telse we donot\\n\\t\\t\\t\\t\\t\"\"\"\\n                    used = max(solve(N+carpetLen,numCarpets-1)+ans,solve(N+1,numCarpets))\\n                            \\n                else:\\n                    used = 0\\n            \\n            else:\\n\\t\\t\\t#If we donot use the carpet although I feel this might be redundant code\\n                notused = solve(N+1,numCarpets)\\n            \\n\\t\\t\\t#Using max function to find the number of white tiles removed\\n            memo[N][numCarpets] = max(used,notused)\\n            return memo[N][numCarpets]\\n\\t\\t\\n\\t\\t#Total White tiles\\n        ones = 0\\n        for x in floor:\\n            if x == \\'1\\':\\n                ones+=1\\n        \\n\\t\\t#Using Prefix array to store number of ones till i th index\\n        prefix = [0]*(n+1)\\n        for i in range(1,n+1):\\n            if floor[i-1]==\\'1\\':\\n                prefix[i] = prefix[i-1]+1\\n            else:\\n                prefix[i] = prefix[i-1]\\n\\t\\t\\t\\t\\n       \\n        removed = solve(0,numCarpets)\\n        \\n        return ones-removed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889364,
                "title": "dynamic-programming-based-solution-recursion-memoization-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1002][1002];\\n    int min(int a, int b)\\n    {\\n        if(a<b) return a;\\n        return b;\\n    }\\n    \\n    int func(string &floor, int numCarpets, int &carpetLen, int i, vector<int> &prefix)\\n    {\\n        //Base Cases\\n        if(i>=floor.size())\\n            return 0;\\n        if(numCarpets==0)\\n            return 0;\\n        \\n        //Memoization\\n        if(dp[i][numCarpets]!=-1)\\n            return dp[i][numCarpets];\\n        \\n        //Check if current tile is black, if it is then skip it\\n        if(floor[i]==\\'0\\')\\n            return dp[i][numCarpets]=func(floor, numCarpets, carpetLen, i+1, prefix);\\n        \\n        //temp stores the value of index where pointer i should point after the carpet covers white tiles \\n        //sometimes i+len can place you out of scope of prefix array that\\'s why floor.size() is also considered\\n        int temp=min(i+carpetLen, floor.size())-1;\\n        int white=prefix[temp];\\n        if(i!=0) // i==0 is not fit for this condition(no elements before index 0)\\n            white-=prefix[i-1]; // this line gives exact number of white tiles in between(covered by carpet)\\n        /*Suppose 1 0 1 1 0 1 0 1 is the input floor array and carpetLen =2. Prefix array would be 1 1 2 3 3 4 4 5.\\n        Let us suppose  i=2 then \\n        temp=i+carpetLen-1 temp=2+2-1 temp=4-1 temp=3  \\n        white=prefix[temp] white=prefix[3] white=3 \\n        white=white-prefix[i-1]= white=3-prefix[2-1]= white=3-prefix[1] white=3-1 white=2*/\\n        \\n        \\n        int pick=white+func(floor,numCarpets-1,carpetLen, i+carpetLen, prefix); //when you use a new carpet from the current index\\n        int notpick=func(floor,numCarpets,carpetLen, i+1, prefix); //when you dont use a new carpet from the current index\\n        \\n        return dp[i][numCarpets]=max(pick, notpick); //maximum number of white tiles that can be covered by the carpet\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        //for faster i/p o/p\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        memset(dp,-1,sizeof dp);\\n        \\n        //prefix array is used to store total number of white tiles till current index\\n        vector<int>prefix(floor.size()); \\n        if(floor[0]==\\'1\\')\\n            prefix[0]=1;\\n        else\\n            prefix[0]=0;\\n        \\n        for(int i=1; i<floor.size(); i++)\\n        {\\n            prefix[i]=prefix[i-1]+(floor[i]==\\'1\\');\\n        }\\n        \\n        if(prefix[floor.size()-1]==0)\\n            return 0;\\n        \\n        // minimum number of white tiles still visible = total number of white tiles - maximum number of white tiles that can be covered by the carpet\\n        return prefix[floor.size()-1]-func(floor, numCarpets, carpetLen, 0, prefix); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1002][1002];\\n    int min(int a, int b)\\n    {\\n        if(a<b) return a;\\n        return b;\\n    }\\n    \\n    int func(string &floor, int numCarpets, int &carpetLen, int i, vector<int> &prefix)\\n    {\\n        //Base Cases\\n        if(i>=floor.size())\\n            return 0;\\n        if(numCarpets==0)\\n            return 0;\\n        \\n        //Memoization\\n        if(dp[i][numCarpets]!=-1)\\n            return dp[i][numCarpets];\\n        \\n        //Check if current tile is black, if it is then skip it\\n        if(floor[i]==\\'0\\')\\n            return dp[i][numCarpets]=func(floor, numCarpets, carpetLen, i+1, prefix);\\n        \\n        //temp stores the value of index where pointer i should point after the carpet covers white tiles \\n        //sometimes i+len can place you out of scope of prefix array that\\'s why floor.size() is also considered\\n        int temp=min(i+carpetLen, floor.size())-1;\\n        int white=prefix[temp];\\n        if(i!=0) // i==0 is not fit for this condition(no elements before index 0)\\n            white-=prefix[i-1]; // this line gives exact number of white tiles in between(covered by carpet)\\n        /*Suppose 1 0 1 1 0 1 0 1 is the input floor array and carpetLen =2. Prefix array would be 1 1 2 3 3 4 4 5.\\n        Let us suppose  i=2 then \\n        temp=i+carpetLen-1 temp=2+2-1 temp=4-1 temp=3  \\n        white=prefix[temp] white=prefix[3] white=3 \\n        white=white-prefix[i-1]= white=3-prefix[2-1]= white=3-prefix[1] white=3-1 white=2*/\\n        \\n        \\n        int pick=white+func(floor,numCarpets-1,carpetLen, i+carpetLen, prefix); //when you use a new carpet from the current index\\n        int notpick=func(floor,numCarpets,carpetLen, i+1, prefix); //when you dont use a new carpet from the current index\\n        \\n        return dp[i][numCarpets]=max(pick, notpick); //maximum number of white tiles that can be covered by the carpet\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        //for faster i/p o/p\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        memset(dp,-1,sizeof dp);\\n        \\n        //prefix array is used to store total number of white tiles till current index\\n        vector<int>prefix(floor.size()); \\n        if(floor[0]==\\'1\\')\\n            prefix[0]=1;\\n        else\\n            prefix[0]=0;\\n        \\n        for(int i=1; i<floor.size(); i++)\\n        {\\n            prefix[i]=prefix[i-1]+(floor[i]==\\'1\\');\\n        }\\n        \\n        if(prefix[floor.size()-1]==0)\\n            return 0;\\n        \\n        // minimum number of white tiles still visible = total number of white tiles - maximum number of white tiles that can be covered by the carpet\\n        return prefix[floor.size()-1]-func(floor, numCarpets, carpetLen, 0, prefix); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863869,
                "title": "python3-dp-accepted-is-my-runtime-analysis-correct-o-2-n",
                "content": "Below is accepted.\\n\\nI struggle with figuring out runtime for DP problems, can someone help? \\nIs it O(2^N)? My reasoning being that at each backtrack calll, you either cover the piano, or you don\\'t. That\\'s 2 choices with at most N steps/piano tiles.\\n\\nAlso what would be the best way to manually memoize the results without using @lru_cache here?\\n\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        if numCarpets * carpetLen >= len(floor):\\n            return 0\\n        \\n        white_to_right = [0] * len(floor)\\n        for i in range(len(floor)-1, -1, -1):\\n            if i == len(floor) - 1:\\n                white_to_right[i] = 1 if floor[i] == \\'1\\' else 0\\n            else:\\n                white_to_right[i] = white_to_right[i+1]\\n                white_to_right[i] += 1 if floor[i] == \\'1\\' else 0\\n        \\n        @lru_cache(maxsize=None)\\n        def backtrack(index, remaining):\\n            if index >= len(floor):\\n                return 0\\n            \\n            if remaining == 0:\\n                return white_to_right[index]\\n            \\n            # cover carpet starting at this index\\n            cover_now = backtrack(index + carpetLen, remaining - 1)\\n\\n            # no-op, cover at next index\\n            cover_later = backtrack(index + 1, remaining)\\n            cover_later += 1 if floor[index] == \\'1\\' else 0\\n            \\n            return min(cover_now, cover_later)\\n\\n        return backtrack(0, numCarpets)\\n\\n",
                "solutionTags": [],
                "code": "Below is accepted.\\n\\nI struggle with figuring out runtime for DP problems, can someone help? \\nIs it O(2^N)? My reasoning being that at each backtrack calll, you either cover the piano, or you don\\'t. That\\'s 2 choices with at most N steps/piano tiles.\\n\\nAlso what would be the best way to manually memoize the results without using @lru_cache here?\\n\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        if numCarpets * carpetLen >= len(floor):\\n            return 0\\n        \\n        white_to_right = [0] * len(floor)\\n        for i in range(len(floor)-1, -1, -1):\\n            if i == len(floor) - 1:\\n                white_to_right[i] = 1 if floor[i] == \\'1\\' else 0\\n            else:\\n                white_to_right[i] = white_to_right[i+1]\\n                white_to_right[i] += 1 if floor[i] == \\'1\\' else 0\\n        \\n        @lru_cache(maxsize=None)\\n        def backtrack(index, remaining):\\n            if index >= len(floor):\\n                return 0\\n            \\n            if remaining == 0:\\n                return white_to_right[index]\\n            \\n            # cover carpet starting at this index\\n            cover_now = backtrack(index + carpetLen, remaining - 1)\\n\\n            # no-op, cover at next index\\n            cover_later = backtrack(index + 1, remaining)\\n            cover_later += 1 if floor[index] == \\'1\\' else 0\\n            \\n            return min(cover_now, cover_later)\\n\\n        return backtrack(0, numCarpets)\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1985493,
                "title": "c-0-1-knapsack",
                "content": "```\\nclass Solution {\\nprivate:\\n    int dp[1001][1001];\\n    int solve(string& floor,int idx,int n,int car,int len,vector<int>&prefix)\\n    {\\n        if(idx==n || car==0)\\n            return 0;\\n        \\n        if(dp[idx][car]!=-1)\\n            return dp[idx][car];\\n        \\n        int range=min(idx+len-1,n-1);\\n        int cnt=prefix[range];\\n        \\n        if(idx>0)\\n            cnt-=prefix[idx-1];\\n        \\n        int pick=cnt+solve(floor,min(idx+len,n),n,car-1,len,prefix);\\n        int skip=solve(floor,idx+1,n,car,len,prefix);\\n        return dp[idx][car]=max(pick,skip);\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int Carpet, int carpetLen) {       \\n        \\n        memset(dp,-1,sizeof dp);\\n        int n=floor.size();\\n        vector<int>prefix(n,0);\\n        int cnt=0;\\n        for(auto i=0;i<n;++i)\\n        {\\n            if(floor[i]==\\'1\\')\\n                cnt++;\\n            \\n            prefix[i]=cnt;\\n        \\n        }\\n        return cnt-solve(floor,0,floor.size(),Carpet,carpetLen,prefix);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dp[1001][1001];\\n    int solve(string& floor,int idx,int n,int car,int len,vector<int>&prefix)\\n    {\\n        if(idx==n || car==0)\\n            return 0;\\n        \\n        if(dp[idx][car]!=-1)\\n            return dp[idx][car];\\n        \\n        int range=min(idx+len-1,n-1);\\n        int cnt=prefix[range];\\n        \\n        if(idx>0)\\n            cnt-=prefix[idx-1];\\n        \\n        int pick=cnt+solve(floor,min(idx+len,n),n,car-1,len,prefix);\\n        int skip=solve(floor,idx+1,n,car,len,prefix);\\n        return dp[idx][car]=max(pick,skip);\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int Carpet, int carpetLen) {       \\n        \\n        memset(dp,-1,sizeof dp);\\n        int n=floor.size();\\n        vector<int>prefix(n,0);\\n        int cnt=0;\\n        for(auto i=0;i<n;++i)\\n        {\\n            if(floor[i]==\\'1\\')\\n                cnt++;\\n            \\n            prefix[i]=cnt;\\n        \\n        }\\n        return cnt-solve(floor,0,floor.size(),Carpet,carpetLen,prefix);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880725,
                "title": "java-top-down-dynamic-programming-memoization",
                "content": "Solution:\\n```\\nclass Solution {\\n    Map<String, Integer> cache;\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        cache = new HashMap<>();\\n        return helper(floor, 0, numCarpets, carpetLen);\\n    }\\n    \\n    public int helper(String floor, int position, int numCarpets, int carpetLen) {\\n        if (position >= floor.length()) {\\n            return 0;\\n        }\\n        \\n        if (floor.length() - position <= numCarpets * carpetLen) {\\n            return 0;\\n        }\\n        \\n        String key = position + \", \" + numCarpets;\\n        if (cache.containsKey(key)) {\\n            return cache.get(key);\\n        }\\n        \\n        if (numCarpets == 0) {\\n            int output = floor.charAt(position) - \\'0\\' + helper(floor, position + 1, 0, carpetLen);\\n            \\n            cache.put(key, output);\\n            return output;\\n        }\\n        \\n        int output = Math.min(floor.charAt(position) - \\'0\\' + helper(floor, position + 1, numCarpets, carpetLen), helper(floor, position + carpetLen, numCarpets - 1, carpetLen));\\n        \\n        cache.put(key, output);\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, Integer> cache;\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        cache = new HashMap<>();\\n        return helper(floor, 0, numCarpets, carpetLen);\\n    }\\n    \\n    public int helper(String floor, int position, int numCarpets, int carpetLen) {\\n        if (position >= floor.length()) {\\n            return 0;\\n        }\\n        \\n        if (floor.length() - position <= numCarpets * carpetLen) {\\n            return 0;\\n        }\\n        \\n        String key = position + \", \" + numCarpets;\\n        if (cache.containsKey(key)) {\\n            return cache.get(key);\\n        }\\n        \\n        if (numCarpets == 0) {\\n            int output = floor.charAt(position) - \\'0\\' + helper(floor, position + 1, 0, carpetLen);\\n            \\n            cache.put(key, output);\\n            return output;\\n        }\\n        \\n        int output = Math.min(floor.charAt(position) - \\'0\\' + helper(floor, position + 1, numCarpets, carpetLen), helper(floor, position + carpetLen, numCarpets - 1, carpetLen));\\n        \\n        cache.put(key, output);\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877103,
                "title": "dynamic-programming-based-solution-recursion-memoization-c-clean-code",
                "content": "# Code :\\n\\n```\\n class Solution {\\n    vector<int> whiteCount; // Stores no. of white tiles from ith index till the end\\n    \\n\\t// Count number of white tile from index till end \\n\\t// Suffix sum of no. of white tiles\\n    void countTiles(string& floor, int n) {\\n        whiteCount.resize(n+2, 0);\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            whiteCount[i] = whiteCount[i+1] + (floor[i] == \\'1\\');\\n        }\\n    }\\n    \\n    int uncoveredWhiteTiles(string& floor, vector<vector<int>>& dp, int numCarpets, int idx, int carpetLen, int n) {\\n        \\n\\t\\t// If we reach the end, then no white is remaining\\n\\t\\t// Assuming that all previous white tiles are covered already using carpets\\n        if(idx >= n) {\\n            return 0;\\n        }\\n\\t\\t// If no carpet is available, then all the white tiles from current index\\n\\t\\t// Till the end are uncovered. Hence return its count\\n        if(numCarpets == 0) {\\n            return whiteCount[idx];\\n        }\\n        \\n\\t\\t// If we have some value for current state in DP table, then return it\\n        if(dp[idx][numCarpets] != -1) return dp[idx][numCarpets];\\n        \\n        int countWhites = n;\\n        \\n        // We have two choices at this point\\n\\t\\t// Choice 1 : Use a carpet starting from current index till carpetLen\\n\\t\\t// Choice 2 : Do no use any carpet, and move to next index. \\n\\t\\t// But if current tile is white then count it as uncovered\\n        countWhites = min(\\n            uncoveredWhiteTiles(floor, dp, numCarpets-1, idx+carpetLen, carpetLen, n),\\n            uncoveredWhiteTiles(floor, dp, numCarpets, idx+1, carpetLen, n) + (floor[idx] == \\'1\\')\\n        );\\n        \\n\\t\\t// Return minimum count of uncovered white tiles using one of the two choices\\n        return dp[idx][numCarpets] = countWhites;\\n    }\\n    \\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        countTiles(floor, n);\\n        vector<vector<int>> dp(n+1, vector<int>(numCarpets+1, -1));\\n         \\n        return uncoveredWhiteTiles(floor, dp, numCarpets, 0, carpetLen, n);\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(N*M)` \\n* Space : `O(N*M)`\\n\\t* N : length of `floor` string\\n\\t* M : number of carpets available\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n class Solution {\\n    vector<int> whiteCount; // Stores no. of white tiles from ith index till the end\\n    \\n\\t// Count number of white tile from index till end \\n\\t// Suffix sum of no. of white tiles\\n    void countTiles(string& floor, int n) {\\n        whiteCount.resize(n+2, 0);\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            whiteCount[i] = whiteCount[i+1] + (floor[i] == \\'1\\');\\n        }\\n    }\\n    \\n    int uncoveredWhiteTiles(string& floor, vector<vector<int>>& dp, int numCarpets, int idx, int carpetLen, int n) {\\n        \\n\\t\\t// If we reach the end, then no white is remaining\\n\\t\\t// Assuming that all previous white tiles are covered already using carpets\\n        if(idx >= n) {\\n            return 0;\\n        }\\n\\t\\t// If no carpet is available, then all the white tiles from current index\\n\\t\\t// Till the end are uncovered. Hence return its count\\n        if(numCarpets == 0) {\\n            return whiteCount[idx];\\n        }\\n        \\n\\t\\t// If we have some value for current state in DP table, then return it\\n        if(dp[idx][numCarpets] != -1) return dp[idx][numCarpets];\\n        \\n        int countWhites = n;\\n        \\n        // We have two choices at this point\\n\\t\\t// Choice 1 : Use a carpet starting from current index till carpetLen\\n\\t\\t// Choice 2 : Do no use any carpet, and move to next index. \\n\\t\\t// But if current tile is white then count it as uncovered\\n        countWhites = min(\\n            uncoveredWhiteTiles(floor, dp, numCarpets-1, idx+carpetLen, carpetLen, n),\\n            uncoveredWhiteTiles(floor, dp, numCarpets, idx+1, carpetLen, n) + (floor[idx] == \\'1\\')\\n        );\\n        \\n\\t\\t// Return minimum count of uncovered white tiles using one of the two choices\\n        return dp[idx][numCarpets] = countWhites;\\n    }\\n    \\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        countTiles(floor, n);\\n        vector<vector<int>> dp(n+1, vector<int>(numCarpets+1, -1));\\n         \\n        return uncoveredWhiteTiles(floor, dp, numCarpets, 0, carpetLen, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874969,
                "title": "python3-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/7e91381aab0f51486f380f703245463c99fed635) for solutions of biweekly 74. \\n\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        \\n        @cache\\n        def fn(i, n):\\n            \"\"\"Return min while tiles at k with n carpets left.\"\"\"\\n            if n < 0: return inf \\n            if i >= len(floor): return 0 \\n            if floor[i] == \\'1\\': return min(fn(i+carpetLen, n-1), 1 + fn(i+1, n))\\n            return fn(i+1, n)\\n        \\n        return fn(0, numCarpets)\\n```\\n\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        dp = [[0]*(1 + numCarpets) for _ in range(len(floor)+1)]\\n        for i in range(len(floor)-1, -1, -1): \\n            for j in range(0, numCarpets+1): \\n                if floor[i] == \\'1\\': \\n                    dp[i][j] = 1 + dp[i+1][j] \\n                    if j: \\n                        if i+carpetLen >= len(floor): dp[i][j] = 0 \\n                        else: dp[i][j] = min(dp[i+carpetLen][j-1], dp[i][j])\\n                else: dp[i][j] = dp[i+1][j]\\n        return dp[0][numCarpets]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        \\n        @cache\\n        def fn(i, n):\\n            \"\"\"Return min while tiles at k with n carpets left.\"\"\"\\n            if n < 0: return inf \\n            if i >= len(floor): return 0 \\n            if floor[i] == \\'1\\': return min(fn(i+carpetLen, n-1), 1 + fn(i+1, n))\\n            return fn(i+1, n)\\n        \\n        return fn(0, numCarpets)\\n```\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        dp = [[0]*(1 + numCarpets) for _ in range(len(floor)+1)]\\n        for i in range(len(floor)-1, -1, -1): \\n            for j in range(0, numCarpets+1): \\n                if floor[i] == \\'1\\': \\n                    dp[i][j] = 1 + dp[i+1][j] \\n                    if j: \\n                        if i+carpetLen >= len(floor): dp[i][j] = 0 \\n                        else: dp[i][j] = min(dp[i+carpetLen][j-1], dp[i][j])\\n                else: dp[i][j] = dp[i+1][j]\\n        return dp[0][numCarpets]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866410,
                "title": "java-solution-100-faster-using-dp-tabulation",
                "content": "Explatation in comments.\\nPlease **Upvote** if you undrstand this.\\n...\\nclass Solution {\\n\\n\\tpublic int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n\\t\\n\\t\\tchar[] arr = floor.toCharArray();\\n\\t\\t\\n\\t\\tint n = arr.length;\\n\\t\\t//using dp\\n\\t\\t\\n\\t\\tint[][] dp = new int[numCarpets + 1][n + 1];\\n\\t\\t//dp[i][j] -> no of whites in arr(0, i) when j carpet is used\\n\\t\\t//row -> number of carpets\\n\\t\\t//columns -> arr / floor\\n        \\n        for(int i = 0; i <= numCarpets; i++){\\n            for(int j = 1; j <= n; j++){\\n                if(i == 0)\\n                    dp[i][j] = dp[i][j - 1] + (arr[j - 1] - \\'0\\');\\n                else if(j <= carpetLen)//cover all floor\\n                    dp[i][j] = 0;\\n                else{\\n                    int w = Math.min(dp[i - 1][j - carpetLen], dp[i - 1][j]);\\n                    //minimum no of whites if only j - 1 carpet is used already\\n\\t\\t\\t\\t\\t//we want to minimize whites by using or not using jth carpet\\n                    \\n                    //dp[i][j - 1] -> minimum no of moves if we used i carpets already\\n\\t\\t\\t\\t\\t//arr[j - 1] - \\'0\\' -> adds white count for j - 1 th char\\n\\t\\t\\t\\t\\t\\n                    int min = Math.min(w, dp[i][j - 1] + (arr[j - 1] - \\'0\\'));\\n                    //minimum whites in any case\\n                    \\n                    dp[i][j] = min;//update\\n                }\\n            }\\n        }\\n        \\n        return dp[numCarpets][n];\\n    }\\n}\\n...",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\n\\tpublic int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n\\t\\n\\t\\tchar[] arr = floor.toCharArray();\\n\\t\\t\\n\\t\\tint n = arr.length;\\n\\t\\t//using dp\\n\\t\\t\\n\\t\\tint[][] dp = new int[numCarpets + 1][n + 1];\\n\\t\\t//dp[i][j] -> no of whites in arr(0, i) when j carpet is used\\n\\t\\t//row -> number of carpets\\n\\t\\t//columns -> arr / floor\\n        \\n        for(int i = 0; i <= numCarpets; i++){\\n            for(int j = 1; j <= n; j++){\\n                if(i == 0)\\n                    dp[i][j] = dp[i][j - 1] + (arr[j - 1] - \\'0\\');\\n                else if(j <= carpetLen)//cover all floor\\n                    dp[i][j] = 0;\\n                else{\\n                    int w = Math.min(dp[i - 1][j - carpetLen], dp[i - 1][j]);\\n                    //minimum no of whites if only j - 1 carpet is used already\\n\\t\\t\\t\\t\\t//we want to minimize whites by using or not using jth carpet\\n                    \\n                    //dp[i][j - 1] -> minimum no of moves if we used i carpets already\\n\\t\\t\\t\\t\\t//arr[j - 1] - \\'0\\' -> adds white count for j - 1 th char\\n\\t\\t\\t\\t\\t\\n                    int min = Math.min(w, dp[i][j - 1] + (arr[j - 1] - \\'0\\'));\\n                    //minimum whites in any case\\n                    \\n                    dp[i][j] = min;//update\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1866351,
                "title": "simple-solution-in-java-concise-and-elegant-with-memoization",
                "content": "```\\nclass Solution {\\n    private int[][] dp;\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        this.dp = new int[floor.length()+1][numCarpets+1];\\n        for(int i=0; i<floor.length(); i++){\\n            Arrays.fill(dp[i], -1);\\n        }\\n        \\n        char[] str = floor.toCharArray();\\n        return find(0, str, numCarpets, carpetLen);\\n    }\\n    \\n    // Find the minimum number of white tiles visible\\n    private int find(int index, char[] floor, int numCarpets, int carpetLen){\\n        if(numCarpets < 0) return Integer.MAX_VALUE;\\n        if(index >= floor.length) return 0;\\n        \\n        if(dp[index][numCarpets] != -1){\\n            return dp[index][numCarpets];\\n        }\\n        \\n        int min = Integer.MAX_VALUE;\\n        // If current tile is black, move to the next\\n        if(floor[index] == \\'0\\'){\\n            min = find(index+1, floor, numCarpets, carpetLen);\\n        }\\n        \\n        // If current tile is white, two options, cover the current white tile or not \\n        if(floor[index] == \\'1\\'){\\n            min = Math.min(min, find(index + carpetLen, floor, numCarpets - 1, carpetLen));\\n            min = Math.min(min, 1 + find(index + 1, floor, numCarpets, carpetLen));\\n        }\\n        \\n        dp[index][numCarpets] = min;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[][] dp;\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        this.dp = new int[floor.length()+1][numCarpets+1];\\n        for(int i=0; i<floor.length(); i++){\\n            Arrays.fill(dp[i], -1);\\n        }\\n        \\n        char[] str = floor.toCharArray();\\n        return find(0, str, numCarpets, carpetLen);\\n    }\\n    \\n    // Find the minimum number of white tiles visible\\n    private int find(int index, char[] floor, int numCarpets, int carpetLen){\\n        if(numCarpets < 0) return Integer.MAX_VALUE;\\n        if(index >= floor.length) return 0;\\n        \\n        if(dp[index][numCarpets] != -1){\\n            return dp[index][numCarpets];\\n        }\\n        \\n        int min = Integer.MAX_VALUE;\\n        // If current tile is black, move to the next\\n        if(floor[index] == \\'0\\'){\\n            min = find(index+1, floor, numCarpets, carpetLen);\\n        }\\n        \\n        // If current tile is white, two options, cover the current white tile or not \\n        if(floor[index] == \\'1\\'){\\n            min = Math.min(min, find(index + carpetLen, floor, numCarpets - 1, carpetLen));\\n            min = Math.min(min, 1 + find(index + 1, floor, numCarpets, carpetLen));\\n        }\\n        \\n        dp[index][numCarpets] = min;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864848,
                "title": "c-dynamic-programing-solution-time-o-n-2-space-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string a, int n, int k) {\\n        \\n        int m= a.size();\\n        \\n        vector<int> v(m+1,0),h;\\n        \\n        v[0] = 0;\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            v[i] = v[i-1];\\n            if(a[i-1]==\\'1\\')\\n                v[i]++;\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            h = v;\\n            v[0] = 0;\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(a[j-1]==\\'1\\')\\n                {   \\n                    if(j>=k)\\n                        v[j] = min(h[j-k],v[j-1]+1);\\n                    else\\n                        v[j] = 0;\\n                }\\n                else\\n                    v[j] = v[j-1];\\n            }\\n        } \\n        \\n        return v[m];\\n         \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string a, int n, int k) {\\n        \\n        int m= a.size();\\n        \\n        vector<int> v(m+1,0),h;\\n        \\n        v[0] = 0;\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            v[i] = v[i-1];\\n            if(a[i-1]==\\'1\\')\\n                v[i]++;\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            h = v;\\n            v[0] = 0;\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(a[j-1]==\\'1\\')\\n                {   \\n                    if(j>=k)\\n                        v[j] = min(h[j-k],v[j-1]+1);\\n                    else\\n                        v[j] = 0;\\n                }\\n                else\\n                    v[j] = v[j-1];\\n            }\\n        } \\n        \\n        return v[m];\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864331,
                "title": "python-dp-inspired-by-kadane-algo-and-buy-sell-stock-iv",
                "content": "I. Intuition:\\nThe key idea is that we find the maximum tiles can be covered with one carpet (at a time).\\n\\nFor the example:\\n`floor = \"10110101\"`\\n`numCarpets=2`\\n`carpetLen=2`\\n\\nWith numCapets = 2, that means we will have 2 carpets to use. \\nFirst, we find the maximum tiles that the first carpet can cover.\\n`dp[first_carpet] = [0, 1, 1, 1, 2, 2, 2, 2, 2]`\\nWe can say that at the end of 9th floor, with one carpet, we can cover at most 2 tiles. Now we store the maximum tiles can be covered with one carpet in `prev_state`\\nSecond, we now need to find the maxmimum tiles that the second carpet can cover. Then we take the sum of max tiles that the first carpet cover with the max tiles that the second carpet can cover. \\n`dp[second_carpet] = [0, 1, 1, 2, 3, 3, 3, 3, 3]`\\n\\nII. Resources:\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solution/627971\\n\\nIII. Code:\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n \\n        updated_floor = [0]*(len(floor)+1)\\n        running = 0\\n        for index, tiles in enumerate(floor):\\n            if tiles == \\'1\\':\\n                running += 1\\n            updated_floor[index+1] = running\\n  \\n        prev_state = [0]*(len(floor)+1)\\n        for i in range(numCarpets):\\n            dp = [0]*(len(floor)+1)\\n            for j in range(len(dp)-1):\\n                if floor[j] == \\'1\\':\\n                    \\n                    dp[j+1] = max(prev_state[j+1], prev_state[max(j+1-carpetLen, 0)] + updated_floor[j+1]-updated_floor[max(j+1-carpetLen, 0)], dp[j])\\n                    \\n                else:\\n                    dp[j+1] = max(prev_state[j+1], dp[j])\\n                    \\n            prev_state = dp\\n   \\n        return updated_floor[-1] - dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n \\n        updated_floor = [0]*(len(floor)+1)\\n        running = 0\\n        for index, tiles in enumerate(floor):\\n            if tiles == \\'1\\':\\n                running += 1\\n            updated_floor[index+1] = running\\n  \\n        prev_state = [0]*(len(floor)+1)\\n        for i in range(numCarpets):\\n            dp = [0]*(len(floor)+1)\\n            for j in range(len(dp)-1):\\n                if floor[j] == \\'1\\':\\n                    \\n                    dp[j+1] = max(prev_state[j+1], prev_state[max(j+1-carpetLen, 0)] + updated_floor[j+1]-updated_floor[max(j+1-carpetLen, 0)], dp[j])\\n                    \\n                else:\\n                    dp[j+1] = max(prev_state[j+1], dp[j])\\n                    \\n            prev_state = dp\\n   \\n        return updated_floor[-1] - dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864235,
                "title": "neat-and-clean-recursion-memoization-easy-to-understand",
                "content": "```class Solution {\\npublic:\\n    string s;\\n    int n;\\n    int prefix[1001];\\n    int len;\\n    int dp[1001][1001];\\n    int solve(int index, int carpet) {\\n        if(carpet <= 0 || index >= n)\\n            return 0;\\n        if(dp[index][carpet] != -1)\\n            return dp[index][carpet];\\n        int x = 0;\\n        if(index)\\n            x = prefix[index - 1];\\n        int y = prefix[min(index + len - 1, n)];\\n        return dp[index][carpet] = max(solve(index + 1, carpet), y - x + solve(index + len, carpet - 1));\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        s = floor;\\n        n = s.length();\\n        len = carpetLen;\\n        memset(dp, -1, sizeof(dp));\\n        prefix[0] = (s[0] == \\'1\\');\\n        for(int i = 1; i < n; ++i)\\n            prefix[i] = prefix[i-1] + (s[i] == \\'1\\');\\n        prefix[n] = prefix[n-1];\\n        int ans = solve(0, numCarpets);\\n        return max(0, prefix[n] - ans);\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    string s;\\n    int n;\\n    int prefix[1001];\\n    int len;\\n    int dp[1001][1001];\\n    int solve(int index, int carpet) {\\n        if(carpet <= 0 || index >= n)\\n            return 0;\\n        if(dp[index][carpet] != -1)\\n            return dp[index][carpet];\\n        int x = 0;\\n        if(index)\\n            x = prefix[index - 1];\\n        int y = prefix[min(index + len - 1, n)];\\n        return dp[index][carpet] = max(solve(index + 1, carpet), y - x + solve(index + len, carpet - 1));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1864225,
                "title": "python3-simple-bottom-up-dp-solution",
                "content": "```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n        dp = [[0]*(numCarpets+1) for _ in range(n+1)]\\n        for i in range(1, n+1):\\n            dp[i][0] = dp[i-1][0] + (floor[i-1] == \\'1\\')\\n        \\n        for k in range(1, numCarpets+1):\\n            for i in range(1, n+1):\\n                dp[i][k] = min(dp[max(0, i-carpetLen)][k-1], dp[i-1][k]+(floor[i-1] == \\'1\\'))\\n\\n        return dp[-1][numCarpets]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n        dp = [[0]*(numCarpets+1) for _ in range(n+1)]\\n        for i in range(1, n+1):\\n            dp[i][0] = dp[i-1][0] + (floor[i-1] == \\'1\\')\\n        \\n        for k in range(1, numCarpets+1):\\n            for i in range(1, n+1):\\n                dp[i][k] = min(dp[max(0, i-carpetLen)][k-1], dp[i-1][k]+(floor[i-1] == \\'1\\'))\\n\\n        return dp[-1][numCarpets]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864167,
                "title": "classical-dp-memoization-similiar-to-0-1-knapsack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pre;\\n    int n;\\n    vector<vector<int>> dp;\\n    int fun(int i,string &f,int nc,int len){\\n        \\n        if(i >= n) return 0;\\n        if(nc == 0){\\n            return pre[n-1] - (i == 0 ? 0 : pre[i-1]);\\n        }\\n        if(dp[i][nc] != -1) return dp[i][nc];\\n        int left = fun(i+len,f,nc-1,len);\\n        int right = (f[i] == \\'1\\' ? 1 : 0) + fun(i+1,f,nc,len);\\n        \\n        return dp[i][nc] = min(left,right);\\n        \\n    }\\n    int minimumWhiteTiles(string f, int nc, int len) {\\n        \\n        n = f.size();\\n        pre = vector<int> (n);\\n        dp = vector<vector<int>> (n,vector<int> (nc+1,-1));\\n        pre[0] = (f[0] == \\'1\\' ? 1 : 0);\\n        for(int i=1;i<n;i++){\\n            pre[i] = (f[i] == \\'1\\' ? 1 : 0) + pre[i-1];\\n        }\\n        \\n        return fun(0,f,nc,len);\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> pre;\\n    int n;\\n    vector<vector<int>> dp;\\n    int fun(int i,string &f,int nc,int len){\\n        \\n        if(i >= n) return 0;\\n        if(nc == 0){\\n            return pre[n-1] - (i == 0 ? 0 : pre[i-1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1864077,
                "title": "problem-analysis-with-formula-dynamic-programming-tabulation-approach",
                "content": "## At first glance\\n\\nLet\\'s analyze the problem at hand before writing the code. We are given the following inputs:\\n\\n - **Floor**, which is a string of characters `0` and `1` only.\\n\\t - **0** denotes a black tile.\\n\\t - **1** denotes a white tile.\\n - **Number of Carpets**, the number of carpets we can place.\\n - **Length of Carpet**, the range of a carpet to make everything black.\\n\\nThe problem is about *minimizing* the number of white tiles. Note the keyword \\'minimizing\\', which already tells us that this is going to be an optimization problem. You might have guessed it, dynamic programming is the answer to this problem. In specific, we will be using the *tabulation* approach.\\n\\n<br>\\n\\n## Problem Analysis\\n\\n*Note*: From this point forward, we will be referring the **Number of Carpets** as **R** (remaining carpets), **Length of Carpet** as **L** and the **Floor** as **F**.\\n\\nIn order to find minimum number of white tile possible, we need to find the optimal formula for minimizing the white tile count. After further inspection, we can see that at any index ***i***, we have two possible options:\\n\\n - Place a carpet on index ***i***, if and only if **R > 0**.\\n - Skip the current index.\\n\\nThis gives us the following optimal formula (denoted as ***opt***):\\n\\n![image](https://assets.leetcode.com/users/images/2145aad6-6484-40c5-b3f2-e352decf6ff4_1647705757.213423.png)\\n\\n## Implementation\\n\\nA reference implementation in C++ is given below:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int L) {\\n        vector<vector<int>> opt(floor.size() + 1, vector<int>(numCarpets + 1, 0));\\n\\n        for (int i = (int) floor.size() - 1; i >= 0; i--) {\\n            int F_i = floor[i] - \\'0\\';\\n\\n            for (int R = 0; R <= numCarpets; R++) {\\n\\n                if (R == 0)\\n                    opt[i][R] = F_i + opt[i + 1][R];\\n                else if (i + L >= floor.size())\\n                    opt[i][R] = 0;\\n                else\\n                    opt[i][R] = min(F_i + opt[i + 1][R], opt[i + L][R - 1]);\\n            }\\n        }\\n\\n        return opt[0][numCarpets];\\n    }\\n};\\n```\\n\\nThis runs in **pseudo-polynomial time O(|F| \\xD7 R)** and has a space complexity **O(|F| \\xD7 R)**. Note that this is *not polynomial*, but [pseudo-polynomial](https://en.wikipedia.org/wiki/Pseudo-polynomial_time).\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int L) {\\n        vector<vector<int>> opt(floor.size() + 1, vector<int>(numCarpets + 1, 0));\\n\\n        for (int i = (int) floor.size() - 1; i >= 0; i--) {\\n            int F_i = floor[i] - \\'0\\';\\n\\n            for (int R = 0; R <= numCarpets; R++) {\\n\\n                if (R == 0)\\n                    opt[i][R] = F_i + opt[i + 1][R];\\n                else if (i + L >= floor.size())\\n                    opt[i][R] = 0;\\n                else\\n                    opt[i][R] = min(F_i + opt[i + 1][R], opt[i + L][R - 1]);\\n            }\\n        }\\n\\n        return opt[0][numCarpets];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864073,
                "title": "c-simple-recursive-memoization-easy-to-think-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int minCover(string& s, int index, int numCarpets, int len){\\n        if(index >= s.length())     // if index >= s.length(), then there is no tiles present.\\n            return 0;\\n        if(dp[index][numCarpets] != -1)     // State of the dp is represented by current index and no of Carpets remaining\\n            return dp[index][numCarpets];\\n        int res1 = INT_MAX;\\n        if(numCarpets > 0)\\n            res1 = minCover(s, index + len, numCarpets-1, len);     // If carpet is still remaining, we can try covering tiles in the range [index, index + len - 1]\\n        int res2 = minCover(s, index+1, numCarpets, len);       // finding min no of white tiles visible if we doesn\\'t cover the tile on this particular index\\n        if(s[index] == \\'1\\')                 // white tile present at index, so if we don\\'t cover those tile, then add corresponding count to res2\\n            res2++;\\n        return dp[index][numCarpets] = min(res1, res2);   // finally we choose the minimum from the above two case\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        dp.resize(floor.length(), vector<int>(numCarpets+1, -1));\\n        return minCover(floor, 0, numCarpets, carpetLen);\\n    }\\n};\\n```\\n***If you find this helpful, please show some love in the form of upvote***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int minCover(string& s, int index, int numCarpets, int len){\\n        if(index >= s.length())     // if index >= s.length(), then there is no tiles present.\\n            return 0;\\n        if(dp[index][numCarpets] != -1)     // State of the dp is represented by current index and no of Carpets remaining\\n            return dp[index][numCarpets];\\n        int res1 = INT_MAX;\\n        if(numCarpets > 0)\\n            res1 = minCover(s, index + len, numCarpets-1, len);     // If carpet is still remaining, we can try covering tiles in the range [index, index + len - 1]\\n        int res2 = minCover(s, index+1, numCarpets, len);       // finding min no of white tiles visible if we doesn\\'t cover the tile on this particular index\\n        if(s[index] == \\'1\\')                 // white tile present at index, so if we don\\'t cover those tile, then add corresponding count to res2\\n            res2++;\\n        return dp[index][numCarpets] = min(res1, res2);   // finally we choose the minimum from the above two case\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        dp.resize(floor.length(), vector<int>(numCarpets+1, -1));\\n        return minCover(floor, 0, numCarpets, carpetLen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613914,
                "title": "python-top-down-dp-almost-one-liner",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, nums: str, numCarpets: int, carpetLen: int) -> int:\\n        @cache\\n        def dfs(i, rem):\\n            return 0 if i >= len(nums) else min((1 if nums[i]==\\'1\\' else 0) + dfs(i+1, rem), dfs(i+carpetLen, rem-1) if rem and nums[i]==\\'1\\' else float(\\'inf\\'))\\n        \\n        return dfs(0, numCarpets)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, nums: str, numCarpets: int, carpetLen: int) -> int:\\n        @cache\\n        def dfs(i, rem):\\n            return 0 if i >= len(nums) else min((1 if nums[i]==\\'1\\' else 0) + dfs(i+1, rem), dfs(i+carpetLen, rem-1) if rem and nums[i]==\\'1\\' else float(\\'inf\\'))\\n        \\n        return dfs(0, numCarpets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191050,
                "title": "c-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(string &s, int num, int len, int i, vector<vector<int>>&dp){\\n        if(i>=s.length()){\\n            return 0;\\n        }\\n        if(num==0){\\n            int count = 0;\\n        for(int j = i; j<=s.length()-1;j++){\\n            if(s[j]==\\'1\\'){\\n                count++;\\n            }\\n\\n        } \\n                       return count;\\n        }\\n        if(dp[i][num]!=-1){\\n            return dp[i][num];\\n        }\\n        if(s[i]==\\'0\\'){\\n            return dp[i][num] = helper(s,num,len,i+1,dp);\\n        }\\n        int mn = i + len-1;\\n        if(mn >= s.length()){\\n            mn = s.length()-1;\\n        }\\n    \\n        return dp[i][num] = min(helper(s,num-1,len,i+len,dp),1+helper(s,num,len,i+1,dp));\\n    }\\n    \\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>> dp(floor.length()+1, vector<int>(numCarpets+1,-1));\\n        return helper(floor,numCarpets,carpetLen,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(string &s, int num, int len, int i, vector<vector<int>>&dp){\\n        if(i>=s.length()){\\n            return 0;\\n        }\\n        if(num==0){\\n            int count = 0;\\n        for(int j = i; j<=s.length()-1;j++){\\n            if(s[j]==\\'1\\'){\\n                count++;\\n            }\\n\\n        } \\n                       return count;\\n        }\\n        if(dp[i][num]!=-1){\\n            return dp[i][num];\\n        }\\n        if(s[i]==\\'0\\'){\\n            return dp[i][num] = helper(s,num,len,i+1,dp);\\n        }\\n        int mn = i + len-1;\\n        if(mn >= s.length()){\\n            mn = s.length()-1;\\n        }\\n    \\n        return dp[i][num] = min(helper(s,num-1,len,i+len,dp),1+helper(s,num,len,i+1,dp));\\n    }\\n    \\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>> dp(floor.length()+1, vector<int>(numCarpets+1,-1));\\n        return helper(floor,numCarpets,carpetLen,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153754,
                "title": "python-2-liner-using-lambda-function-and-lru-cache",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, x: str, n: int, cl: int) -> int:\\n        f=lru_cache(None)(lambda i,n: 0 if i>=len(x) else min((1 if x[i]==\\'1\\' else 0)+f(i+1,n),(inf if n==0 else f(i+cl,n-1))))\\n        return f(0,n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, x: str, n: int, cl: int) -> int:\\n        f=lru_cache(None)(lambda i,n: 0 if i>=len(x) else min((1 if x[i]==\\'1\\' else 0)+f(i+1,n),(inf if n==0 else f(i+cl,n-1))))\\n        return f(0,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115070,
                "title": "c-dp-bottom-up-dp-similar-to-knapsack",
                "content": "Please upvote\\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int len) {\\n        int n=floor.size();\\n        int x=numCarpets;\\n        floor=\\'#\\'+floor;//so that ith row of dp matches with the ith character\\n        vector<vector<int>> dp(n+1,vector<int>(x+1,0));\\n        dp[0][0]=0;\\n        for(int i=0;i<=x;i++){\\n            dp[0][i]=0;\\n        }\\n        for(int i=1;i<=n;i++){\\n            dp[i][0]=dp[i-1][0]+(floor[i]==\\'1\\');\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=x;j++){\\n                if(j>=1){\\n\\t\\t\\t\\t//if we have atleast 1 carpet or even more\\n\\t\\t\\t\\t//then we can use\\n\\t\\t\\t\\t//however before usuing at i also check if i-len>=0\\n                    if(i-len>=0){\\n                        dp[i][j]=min(dp[i-len][j-1],dp[i-1][j]+(floor[i]==\\'1\\'));\\n                    }\\n                }\\n                else{\\n\\t\\t\\t\\t//if we do not have any carpet\\n                    dp[i][j]=dp[i-1][j]+(floor[i]==\\'1\\');\\n                }\\n            }\\n        }\\n        return dp[n][x];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int len) {\\n        int n=floor.size();\\n        int x=numCarpets;\\n        floor=\\'#\\'+floor;//so that ith row of dp matches with the ith character\\n        vector<vector<int>> dp(n+1,vector<int>(x+1,0));\\n        dp[0][0]=0;\\n        for(int i=0;i<=x;i++){\\n            dp[0][i]=0;\\n        }\\n        for(int i=1;i<=n;i++){\\n            dp[i][0]=dp[i-1][0]+(floor[i]==\\'1\\');\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=x;j++){\\n                if(j>=1){\\n\\t\\t\\t\\t//if we have atleast 1 carpet or even more\\n\\t\\t\\t\\t//then we can use\\n\\t\\t\\t\\t//however before usuing at i also check if i-len>=0\\n                    if(i-len>=0){\\n                        dp[i][j]=min(dp[i-len][j-1],dp[i-1][j]+(floor[i]==\\'1\\'));\\n                    }\\n                }\\n                else{\\n\\t\\t\\t\\t//if we do not have any carpet\\n                    dp[i][j]=dp[i-1][j]+(floor[i]==\\'1\\');\\n                }\\n            }\\n        }\\n        return dp[n][x];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052637,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        int[][] dp = new int[n + 1][numCarpets + 1];\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= numCarpets; j++) {\\n                if (floor.charAt(i - 1) == \\'1\\') dp[i][j] = dp[i - 1][j] + 1;\\n                else dp[i][j] = dp[i - 1][j];\\n                if (j > 0) dp[i][j] = Math.min(dp[i][j], dp[Math.max(0, i - carpetLen)][j - 1]);\\n            }\\n        }\\n        return dp[n][numCarpets];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        int[][] dp = new int[n + 1][numCarpets + 1];\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= numCarpets; j++) {\\n                if (floor.charAt(i - 1) == \\'1\\') dp[i][j] = dp[i - 1][j] + 1;\\n                else dp[i][j] = dp[i - 1][j];\\n                if (j > 0) dp[i][j] = Math.min(dp[i][j], dp[Math.max(0, i - carpetLen)][j - 1]);\\n            }\\n        }\\n        return dp[n][numCarpets];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880957,
                "title": "scala",
                "content": "```\\nimport scala.math.min\\nimport scala.util.chaining._\\n\\nobject Solution {\\n  private val Black = \\'0\\'\\n\\n  def minimumWhiteTiles(floor: String, numCarpets: Int, carpetLen: Int): Int = floor\\n    .indices\\n    .zip(floor.map(_ - Black).scanRight(0)(_ + _))\\n    .toMap\\n    .withDefaultValue(0)\\n    .pipe { (1 to numCarpets)\\n      .foldLeft(_) { case (previousNumWhiteTiles, _) => floor\\n        .indices\\n        .foldRight(Map[Int, Int]().withDefaultValue(0)) { case (i, currentNumWhiteTiles) =>\\n          currentNumWhiteTiles + \\n            (i -> min(floor(i) - Black + currentNumWhiteTiles(i + 1), previousNumWhiteTiles(i + carpetLen)))\\n        }\\n      }\\n      .apply(0)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport scala.math.min\\nimport scala.util.chaining._\\n\\nobject Solution {\\n  private val Black = \\'0\\'\\n\\n  def minimumWhiteTiles(floor: String, numCarpets: Int, carpetLen: Int): Int = floor\\n    .indices\\n    .zip(floor.map(_ - Black).scanRight(0)(_ + _))\\n    .toMap\\n    .withDefaultValue(0)\\n    .pipe { (1 to numCarpets)\\n      .foldLeft(_) { case (previousNumWhiteTiles, _) => floor\\n        .indices\\n        .foldRight(Map[Int, Int]().withDefaultValue(0)) { case (i, currentNumWhiteTiles) =>\\n          currentNumWhiteTiles + \\n            (i -> min(floor(i) - Black + currentNumWhiteTiles(i + 1), previousNumWhiteTiles(i + carpetLen)))\\n        }\\n      }\\n      .apply(0)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1879842,
                "title": "java-simple-memiozation",
                "content": "```\\nclass Solution {\\n    int[] suff;\\n    Integer[][] dp;\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {    \\n        if (carpetLen == floor.length()) {\\n            return 0;\\n        }\\n        dp = new Integer[floor.length()][numCarpets + 1];\\n        //  suff[i] = number of white tiles in s[i....]\\n\\t\\tsuff = cumulative(floor);\\n        return helper(floor, numCarpets, carpetLen, 0);\\n    }\\n    \\n\\t//  normal suffix array\\n    public int[] cumulative(String s) {\\n        int[] suff = new int[s.length()];\\n        suff[s.length() - 1] = (s.charAt(s.length() - 1) == \\'0\\' ? 0 : 1);\\n        for (int i = s.length() - 2; i >= 0; i--) {\\n            suff[i] = suff[i + 1] + (s.charAt(i) == \\'0\\' ? 0 : 1);\\n        }\\n        return suff;\\n    }\\n    \\n    public int helper(String s, int n, int k, int idx) {\\n        \\n        //  no more floors remaining so no white carpets need to be covered\\n        if (idx >= s.length()) {\\n            return 0;\\n        }\\n        \\n        if (dp[idx][n] != null) {\\n            return dp[idx][n];\\n        }\\n        \\n        //  floors remaining but carpets exhausted\\n        if (n == 0) {\\n            return suff[idx];\\n        }\\n        \\n        //  this is already black skip this floor\\n        if (s.charAt(idx) == \\'0\\') {\\n            return helper(s, n, k, idx + 1);\\n        }\\n        \\n        //  now we have two choices whether to leave this white\\n        //  as it is or cover this in black\\n        \\n        \\n        //  if covering this and any other black floor in range as black\\n        int answer = helper(s, n - 1, k, idx + k);\\n        \\n        //  leaving this as white as it was\\n        answer = Math.min(answer, helper(s, n, k, idx + 1) + 1);\\n        return dp[idx][n] = answer;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    int[] suff;\\n    Integer[][] dp;\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {    \\n        if (carpetLen == floor.length()) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1879319,
                "title": "why-my-bottom-up-code-is-giving-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    // int memo(int i, int j, vector<int>& pref, int cl,\\n    //          vector<vector<int>>& dp)\\n    // {\\n    //     if(i >= pref.size() || j <= 0)\\n    //         return 0;\\n    //     if(dp[i][j] != -1)\\n    //         return dp[i][j];\\n    //     else\\n    //     {\\n    //         dp[i][j] = max(memo(i+cl, j-1, pref, cl, dp)\\n    //                        + pref[i], \\n    //                        memo(i+1, j, pref, cl, dp));\\n    //     }\\n    //     return dp[i][j];\\n    // }\\n    int minimumWhiteTiles(string& f, int n, int cl) {\\n        vector<vector<int>> dp(1001, vector<int>(1001, -1));\\n        int tot = 0;\\n        for(auto x : f)\\n            if(x == \\'1\\')\\n                tot++;\\n        vector<int> pref(f.size(), 0);\\n        int x = f.size() - 1;\\n        for(int i = 0; i < cl; i++, x--)\\n        {\\n            if(x < f.size() - 1)\\n                pref[x] = pref[x+1];\\n            if(f[x] == \\'1\\')\\n                pref[x]++;\\n        }\\n        int y = f.size() - 1;\\n        while(x >= 0)\\n        {\\n            pref[x] = pref[x+1];\\n            if(f[y] == \\'1\\')\\n                pref[x]--;\\n            if(f[x] == \\'1\\')\\n                pref[x]++;\\n            x--;\\n            y--;\\n        }\\n        for(int i = 0; i <= f.size(); i++)\\n            dp[i][0] = 0;\\n        for(int j = 0; j <= n; j++)\\n            dp[f.size()][j] = 0;\\n        for(int i = f.size()-1; i >= 0; i--)\\n        {\\n            for(int j = 1; j <= n; j++)\\n            {\\n                dp[i][j] = max(dp[i+1][j],\\n                               dp[min(i+cl,int(f.size()-1))][j-1]\\n                               + pref[i]);\\n            }\\n        }\\n        return tot > dp[0][n] ? tot - dp[0][n] : 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // int memo(int i, int j, vector<int>& pref, int cl,\\n    //          vector<vector<int>>& dp)\\n    // {\\n    //     if(i >= pref.size() || j <= 0)\\n    //         return 0;\\n    //     if(dp[i][j] != -1)\\n    //         return dp[i][j];\\n    //     else\\n    //     {\\n    //         dp[i][j] = max(memo(i+cl, j-1, pref, cl, dp)\\n    //                        + pref[i], \\n    //                        memo(i+1, j, pref, cl, dp));\\n    //     }\\n    //     return dp[i][j];\\n    // }\\n    int minimumWhiteTiles(string& f, int n, int cl) {\\n        vector<vector<int>> dp(1001, vector<int>(1001, -1));\\n        int tot = 0;\\n        for(auto x : f)\\n            if(x == \\'1\\')\\n                tot++;\\n        vector<int> pref(f.size(), 0);\\n        int x = f.size() - 1;\\n        for(int i = 0; i < cl; i++, x--)\\n        {\\n            if(x < f.size() - 1)\\n                pref[x] = pref[x+1];\\n            if(f[x] == \\'1\\')\\n                pref[x]++;\\n        }\\n        int y = f.size() - 1;\\n        while(x >= 0)\\n        {\\n            pref[x] = pref[x+1];\\n            if(f[y] == \\'1\\')\\n                pref[x]--;\\n            if(f[x] == \\'1\\')\\n                pref[x]++;\\n            x--;\\n            y--;\\n        }\\n        for(int i = 0; i <= f.size(); i++)\\n            dp[i][0] = 0;\\n        for(int j = 0; j <= n; j++)\\n            dp[f.size()][j] = 0;\\n        for(int i = f.size()-1; i >= 0; i--)\\n        {\\n            for(int j = 1; j <= n; j++)\\n            {\\n                dp[i][j] = max(dp[i+1][j],\\n                               dp[min(i+cl,int(f.size()-1))][j-1]\\n                               + pref[i]);\\n            }\\n        }\\n        return tot > dp[0][n] ? tot - dp[0][n] : 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876280,
                "title": "c-dp-heavily-commented",
                "content": "```\\nclass Solution {\\n    \\nprivate:\\n    int dp[1001][1001];\\n    int suffix[1001];\\npublic:\\n    int recur(string &floor,int numCarpets,int carpetLen,int idx)\\n    {\\n        //Base Cases\\n        if(idx>=floor.size())\\n            return 0;\\n    \\n        if(numCarpets==0)\\n            return suffix[idx];\\n        \\n        //Memoization\\n        if(dp[idx][numCarpets]!=-1)\\n            return dp[idx][numCarpets];\\n        \\n        //Check if current tile is white,\\n        //We need to add 1 because we are skipping\\n        int op1=(floor[idx]==\\'1\\')+recur(floor,numCarpets,carpetLen,idx+1);\\n        //We are using one carpet and hence we jump directly \\n        //by carpetLen moves\\n        int op2=recur(floor,numCarpets-1,carpetLen,idx+carpetLen);\\n        return dp[idx][numCarpets]=min(op1,op2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n       int n=floor.size();\\n       memset(dp,-1,sizeof dp);\\n        \\n       /*We make a suffix array which will tell \\n       us count of white tiles after current tile\\n       (including current tile also), we need to do this step\\n       else we will get TLE */\\n       suffix[n - 1] = (floor[n - 1] == \\'1\\');\\n        for (int i = n - 2; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] + (floor[i] == \\'1\\');\\n        }\\n        return recur(floor,numCarpets,carpetLen,0);\\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\nprivate:\\n    int dp[1001][1001];\\n    int suffix[1001];\\npublic:\\n    int recur(string &floor,int numCarpets,int carpetLen,int idx)\\n    {\\n        //Base Cases\\n        if(idx>=floor.size())\\n            return 0;\\n    \\n        if(numCarpets==0)\\n            return suffix[idx];\\n        \\n        //Memoization\\n        if(dp[idx][numCarpets]!=-1)\\n            return dp[idx][numCarpets];\\n        \\n        //Check if current tile is white,\\n        //We need to add 1 because we are skipping\\n        int op1=(floor[idx]==\\'1\\')+recur(floor,numCarpets,carpetLen,idx+1);\\n        //We are using one carpet and hence we jump directly \\n        //by carpetLen moves\\n        int op2=recur(floor,numCarpets-1,carpetLen,idx+carpetLen);\\n        return dp[idx][numCarpets]=min(op1,op2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n       int n=floor.size();\\n       memset(dp,-1,sizeof dp);\\n        \\n       /*We make a suffix array which will tell \\n       us count of white tiles after current tile\\n       (including current tile also), we need to do this step\\n       else we will get TLE */\\n       suffix[n - 1] = (floor[n - 1] == \\'1\\');\\n        for (int i = n - 2; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] + (floor[i] == \\'1\\');\\n        }\\n        return recur(floor,numCarpets,carpetLen,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870498,
                "title": "java-simple-top-down-dp-with-explanation",
                "content": "Basically we consider each suffix from ```floor[0...I]``` using ```J``` carpets. There are 2 transition options to consider and minimize over for this building upon \"smaller\"* subproblems.\\n\\nCase 1: We use a carpet that ends at ```I```th position. So this means we simply need ```subproblem(I-carpetLen, J-1)``` because all tiles from ```I-carpetLen + 1``` to ```I``` now have 0 white tiles due to spending 1 carpet so we are at pos ```I - carpetLen``` with 1 less carpet.\\n\\nCase 2: We do not use a carpet that ends at ```I```th position. So the ```I```th tile is uncovered. So this tile has to be included towards count of white tiles so add ```floor(I) == 0? 1 : 0```. And then we\\'re left with ```subproblem(I-1, J)``` as we haven\\'t spent any carpets.\\n\\nThat is ```subproblem(I, J) = Min(subproblem(I-carpetLen, J-1), subproblem(I-1, J) + floor(I) == 0? 1 : 0)```\\n\\n\\\\* \"smaller\" in sense that subproblem(I\\', J\\') < subproblem(I, J) if I\\' <= I and J\\' <= J and not case that (I\\', J\\') = (I, J)\\n\\nThere are a few edge cases that should be easily understandable from code below.\\nCode:\\n```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        // memo[I][J] = subproblem of floor[0...I] with J numCarpets.\\n        // so I range from 0...(floor.len - 1) so floor.len possibilities\\n        // and J range from 0 ... numCarpets so numCarpets+1 possibilities\\n        Integer[][] memo = new Integer[floor.length()][numCarpets + 1];\\n        return dfs(floor.length() - 1, numCarpets, carpetLen, memo, floor);\\n    }\\n    \\n    // precond. i and j both >=0. don\\'t add check at start, instead maintain this\\n    private int dfs(int i, int j, int carpetLen, Integer[][] memo, String floor) {\\n        //if (i < 0 || j < 0) {\\n            //return 0;\\n        //}\\n        if (memo[i][j] != null) {\\n            return memo[i][j];\\n        }\\n        int min = Integer.MAX_VALUE;\\n        // case 1: only when have at least 1 carpet to work with so let one extend and end at I\\n        if (j > 0) {\\n            if (i - carpetLen >= 0) {\\n                min = Math.min(min, dfs(i - carpetLen, j-1, carpetLen, memo, floor));\\n            } else {\\n                // have enough carpet to span all of [0...i] so no while tiles visible\\n                memo[i][j] = 0;\\n                return 0;\\n            }\\n        }\\n        // case 2: tile does not extend till here\\n        if (i > 0) {\\n            min = Math.min(min, dfs(i-1, j, carpetLen, memo, floor) + ((floor.charAt(i) == \\'1\\')? 1 : 0));\\n        } else {\\n            min = Math.min(min, ((floor.charAt(i) == \\'1\\')? 1 : 0));\\n        }\\n        memo[i][j] = min;\\n        return min;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```floor[0...I]```\n```J```\n```I```\n```subproblem(I-carpetLen, J-1)```\n```I-carpetLen + 1```\n```I```\n```I - carpetLen```\n```I```\n```I```\n```floor(I) == 0? 1 : 0```\n```subproblem(I-1, J)```\n```subproblem(I, J) = Min(subproblem(I-carpetLen, J-1), subproblem(I-1, J) + floor(I) == 0? 1 : 0)```\n```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        // memo[I][J] = subproblem of floor[0...I] with J numCarpets.\\n        // so I range from 0...(floor.len - 1) so floor.len possibilities\\n        // and J range from 0 ... numCarpets so numCarpets+1 possibilities\\n        Integer[][] memo = new Integer[floor.length()][numCarpets + 1];\\n        return dfs(floor.length() - 1, numCarpets, carpetLen, memo, floor);\\n    }\\n    \\n    // precond. i and j both >=0. don\\'t add check at start, instead maintain this\\n    private int dfs(int i, int j, int carpetLen, Integer[][] memo, String floor) {\\n        //if (i < 0 || j < 0) {\\n            //return 0;\\n        //}\\n        if (memo[i][j] != null) {\\n            return memo[i][j];\\n        }\\n        int min = Integer.MAX_VALUE;\\n        // case 1: only when have at least 1 carpet to work with so let one extend and end at I\\n        if (j > 0) {\\n            if (i - carpetLen >= 0) {\\n                min = Math.min(min, dfs(i - carpetLen, j-1, carpetLen, memo, floor));\\n            } else {\\n                // have enough carpet to span all of [0...i] so no while tiles visible\\n                memo[i][j] = 0;\\n                return 0;\\n            }\\n        }\\n        // case 2: tile does not extend till here\\n        if (i > 0) {\\n            min = Math.min(min, dfs(i-1, j, carpetLen, memo, floor) + ((floor.charAt(i) == \\'1\\')? 1 : 0));\\n        } else {\\n            min = Math.min(min, ((floor.charAt(i) == \\'1\\')? 1 : 0));\\n        }\\n        memo[i][j] = min;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866616,
                "title": "java-solution-top-down-dp-2-approaches",
                "content": "**Explanation :**\\n\\nHere, I want to showcase 2 approaches for solving the problem using memoization :\\n\\t\\t1. counting the minimum number of exposed white tiles using `suffix-sum` and\\n\\t\\t2. counting the maximum number of white tiles covered by the given carpets and subtracting this from the total number of white tiles to get the exposed white tiles using `prefix-sum`\\n\\n**Approach 1 :**\\n\\n```\\npublic int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        Integer[][] dp = new Integer[floor.length() + 1][numCarpets + 1];\\n        int[] suffixSum = new int[floor.length()];\\n        suffixSum[floor.length() - 1] = (floor.charAt(floor.length() - 1) == \\'1\\' ? 1 : 0);\\n\\n        for (int i = floor.length() - 2; i >= 0; i--) {\\n            suffixSum[i] = suffixSum[i + 1] + (floor.charAt(i) == \\'1\\' ? 1 : 0);\\n        }\\n\\n        return coverTilesDP(floor, 0, carpetLen, numCarpets, dp, suffixSum);\\n    }\\n\\n    private int coverTilesDP(String str, int idx, int carpetLen,\\n                             int numCarpets, Integer[][] dp, int[] suffixSum) {\\n        if (idx >= str.length()) {\\n            return 0;\\n        } else if (numCarpets == 0) {\\n            return suffixSum[idx];\\n        }\\n\\n        if (dp[idx][numCarpets] != null) {\\n            return dp[idx][numCarpets];\\n        }\\n\\t\\t\\n        // include\\n        int min1 = coverTilesDP(str, idx + carpetLen, carpetLen, numCarpets - 1, dp, suffixSum);\\n        // exclude\\n        int min2 = coverTilesDP(str, idx + 1, carpetLen, numCarpets, dp, suffixSum) + (str.charAt(idx) == \\'1\\' ? 1 : 0);\\n\\n        return dp[idx][numCarpets] = Math.min(min1, min2);\\n    }\\n```\\n\\n**Approach 2 :**\\n\\n```\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        Integer[][] dp = new Integer[floor.length() + 1][numCarpets + 1];\\n        int[] prefixSum = new int[floor.length()];\\n        prefixSum[0] = (floor.charAt(0) == \\'1\\' ? 1 : 0);\\n\\n        for (int i = 1; i < floor.length(); i++) {\\n            prefixSum[i] = prefixSum[i - 1] + (floor.charAt(i) == \\'1\\' ? 1 : 0);\\n        }\\n        return prefixSum[floor.length() - 1] - coverTilesDP(floor, 0, carpetLen,\\n                                                            numCarpets, dp, prefixSum);\\n    }\\n\\n    private int coverTilesDP(String str, int idx, int carpetLen,\\n                             int numCarpets, Integer[][] dp, int[] prefixSum) {\\n        if (idx >= str.length() || numCarpets == 0) {\\n            return 0;\\n        }\\n\\n        if (dp[idx][numCarpets] != null) {\\n            return dp[idx][numCarpets];\\n        }\\n\\n        // include\\n        int max1 = coverTilesDP(str, idx + carpetLen, carpetLen, numCarpets - 1, dp, prefixSum) +\\n                   (prefixSum[Math.min(idx + carpetLen - 1, prefixSum.length - 1)] - (idx >= 1 ? prefixSum[idx - 1] : 0));\\n        // exclude\\n        int max2 = coverTilesDP(str, idx + 1, carpetLen, numCarpets, dp, prefixSum);\\n\\n        return dp[idx][numCarpets] = Math.max(max1, max2);\\n    }\\n```\\n\\n**PS -** Any suggestions or improvements are most welcome.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\npublic int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        Integer[][] dp = new Integer[floor.length() + 1][numCarpets + 1];\\n        int[] suffixSum = new int[floor.length()];\\n        suffixSum[floor.length() - 1] = (floor.charAt(floor.length() - 1) == \\'1\\' ? 1 : 0);\\n\\n        for (int i = floor.length() - 2; i >= 0; i--) {\\n            suffixSum[i] = suffixSum[i + 1] + (floor.charAt(i) == \\'1\\' ? 1 : 0);\\n        }\\n\\n        return coverTilesDP(floor, 0, carpetLen, numCarpets, dp, suffixSum);\\n    }\\n\\n    private int coverTilesDP(String str, int idx, int carpetLen,\\n                             int numCarpets, Integer[][] dp, int[] suffixSum) {\\n        if (idx >= str.length()) {\\n            return 0;\\n        } else if (numCarpets == 0) {\\n            return suffixSum[idx];\\n        }\\n\\n        if (dp[idx][numCarpets] != null) {\\n            return dp[idx][numCarpets];\\n        }\\n\\t\\t\\n        // include\\n        int min1 = coverTilesDP(str, idx + carpetLen, carpetLen, numCarpets - 1, dp, suffixSum);\\n        // exclude\\n        int min2 = coverTilesDP(str, idx + 1, carpetLen, numCarpets, dp, suffixSum) + (str.charAt(idx) == \\'1\\' ? 1 : 0);\\n\\n        return dp[idx][numCarpets] = Math.min(min1, min2);\\n    }\\n```\n```\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        Integer[][] dp = new Integer[floor.length() + 1][numCarpets + 1];\\n        int[] prefixSum = new int[floor.length()];\\n        prefixSum[0] = (floor.charAt(0) == \\'1\\' ? 1 : 0);\\n\\n        for (int i = 1; i < floor.length(); i++) {\\n            prefixSum[i] = prefixSum[i - 1] + (floor.charAt(i) == \\'1\\' ? 1 : 0);\\n        }\\n        return prefixSum[floor.length() - 1] - coverTilesDP(floor, 0, carpetLen,\\n                                                            numCarpets, dp, prefixSum);\\n    }\\n\\n    private int coverTilesDP(String str, int idx, int carpetLen,\\n                             int numCarpets, Integer[][] dp, int[] prefixSum) {\\n        if (idx >= str.length() || numCarpets == 0) {\\n            return 0;\\n        }\\n\\n        if (dp[idx][numCarpets] != null) {\\n            return dp[idx][numCarpets];\\n        }\\n\\n        // include\\n        int max1 = coverTilesDP(str, idx + carpetLen, carpetLen, numCarpets - 1, dp, prefixSum) +\\n                   (prefixSum[Math.min(idx + carpetLen - 1, prefixSum.length - 1)] - (idx >= 1 ? prefixSum[idx - 1] : 0));\\n        // exclude\\n        int max2 = coverTilesDP(str, idx + 1, carpetLen, numCarpets, dp, prefixSum);\\n\\n        return dp[idx][numCarpets] = Math.max(max1, max2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865413,
                "title": "top-down-c-solution-well-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int explore(int i,string &floor,int numCarpets, int &carpetLen, vector<vector<int>> &dp)\\n    {\\n        if(i==floor.length())\\n        {\\n            return 0;\\n        }\\n        if(dp[i][numCarpets]!=-1)\\n        {\\n            return dp[i][numCarpets];\\n        }\\n        \\n        int ans=0;\\n        //Put carpet here only if you have 1 or more carpet left\\n            if(i+carpetLen<=floor.length()&&numCarpets>0)\\n            {\\n                ans+=carpetLen+explore(i+carpetLen,floor,numCarpets-1,carpetLen,dp);\\n            }\\n            else if(numCarpets>0)\\n            {      //When current index+ carpet length > floor.length\\n                 ans+=floor.length()-i;\\n            }\\n        \\n        \\n        //Dont put carpert here\\n        if(floor[i]==\\'0\\')\\n        {   //If current carpet is black\\n            ans=max(ans,1+explore(i+1,floor,numCarpets,carpetLen,dp));\\n        }\\n        else\\n        {\\n            ans=max(ans,explore(i+1,floor,numCarpets,carpetLen,dp));\\n        }\\n        \\n        return dp[i][numCarpets]=ans;\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.length();\\n        //Store number of maximum black carpet from  index\\n        vector<vector<int>> dp(n,vector<int>(numCarpets+1,-1));\\n        //Explore will return maximum number of black carpet \\n\\t\\t//we just subtract it from floor length to get \\n\\t\\t//minimum number of white carpet\\n        return n-explore(0,floor,numCarpets,carpetLen,dp);\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int explore(int i,string &floor,int numCarpets, int &carpetLen, vector<vector<int>> &dp)\\n    {\\n        if(i==floor.length())\\n        {\\n            return 0;\\n        }\\n        if(dp[i][numCarpets]!=-1)\\n        {\\n            return dp[i][numCarpets];\\n        }\\n        \\n        int ans=0;\\n        //Put carpet here only if you have 1 or more carpet left\\n            if(i+carpetLen<=floor.length()&&numCarpets>0)\\n            {\\n                ans+=carpetLen+explore(i+carpetLen,floor,numCarpets-1,carpetLen,dp);\\n            }\\n            else if(numCarpets>0)\\n            {      //When current index+ carpet length > floor.length\\n                 ans+=floor.length()-i;\\n            }\\n        \\n        \\n        //Dont put carpert here\\n        if(floor[i]==\\'0\\')\\n        {   //If current carpet is black\\n            ans=max(ans,1+explore(i+1,floor,numCarpets,carpetLen,dp));\\n        }\\n        else\\n        {\\n            ans=max(ans,explore(i+1,floor,numCarpets,carpetLen,dp));\\n        }\\n        \\n        return dp[i][numCarpets]=ans;\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.length();\\n        //Store number of maximum black carpet from  index\\n        vector<vector<int>> dp(n,vector<int>(numCarpets+1,-1));\\n        //Explore will return maximum number of black carpet \\n\\t\\t//we just subtract it from floor length to get \\n\\t\\t//minimum number of white carpet\\n        return n-explore(0,floor,numCarpets,carpetLen,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865216,
                "title": "java-simple-solution-with-explaination",
                "content": "I was having the problem to think but got intuition of DP by seeing constraints. But Now how to implement DP what will be the variables to play . Basically think on which variables you are dependent;\\nYes You have to travel the complete the floor string so this variable is changing and second the number of carpet is changing. \\ncarpet length is constant .\\nThis is similar to knapsack yes , here each carpet has value that is length. \\nAt each index you have two choice either use carpet or don\\'t use it;\\nif already black skip and move forward\\nif white you can use carpet or you can leave white (thus cnt will be increased)\\n\\nif all carpet are used and still floor is not completed just return number of white tiles are left;\\nbelow is the code\\n\\n\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        // we have to cover the tiles  we first see the color if it is black \\n        // we leave if its white we have option to jump or we cover it;\\n        int dp[][]= new int[floor.length()+1][numCarpets+1];\\n        for(int a[]: dp){\\n            Arrays.fill(a, -1);\\n        }\\n        return helper( 0, numCarpets, carpetLen, dp, floor);\\n    }\\n    public int helper(int i, int nc, int l, int[][] dp, String s){\\n        \\n        if(i>= s.length()) return 0;\\n        if(nc<=0){\\n            int cnt=0;\\n            for(int j= i; j<s.length(); j++){\\n                if(s.charAt(j)==\\'1\\'){\\n                    cnt++;\\n                }\\n            }\\n            return cnt;\\n        }\\n        \\n        if(dp[i][nc]!=-1) return dp[i][nc];\\n        \\n        \\n        if(s.charAt(i)==\\'0\\'){\\n            return dp[i][nc]= helper(i+1, nc,l , dp , s);\\n        }\\n        else{\\n            int jump= 1+ helper(i+1, nc, l, dp, s);\\n            int cover= helper(i+ l, nc-1, l, dp, s);\\n            \\n            return dp[i][nc]= Math.min(jump, cover);\\n        }\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        // we have to cover the tiles  we first see the color if it is black \\n        // we leave if its white we have option to jump or we cover it;\\n        int dp[][]= new int[floor.length()+1][numCarpets+1];\\n        for(int a[]: dp){\\n            Arrays.fill(a, -1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1865059,
                "title": "dp-edge-case-optimization-with-explanations",
                "content": "Two edge cases can be handled explicitly before running DP:\\n(1) `if numCarpets * carpetLen >= n`, i.e. the totally length of carpets altogether is longer than the length of `floor`, return 0 immediately;\\n(2) `if carpetLen == 1`, then the problem becomes trivial and we can cover the carpets \"greedily\". Adding this edge check is particularly useful for a few long test cases (as it would save half of the time for such cases), which does help to get AC for this problem.\\nThe rest of the code deals with the general cases by using DP, where `dp[i][j]` represents the minimum white tiles after covering with `j` carpets for first `i` tiles.\\nPlease upvote if you find this solution helpful.\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n\\t\\t# edge case handling\\n        if numCarpets * carpetLen >= n:\\n            return 0\\n        if carpetLen == 1:\\n            return max(sum([int(c) for c in floor]) - numCarpets, 0)\\n\\t\\t# DP initialization\\n        dp = [[None] * (numCarpets + 1) for _ in range(n + 1)]\\n        for j in range(numCarpets + 1):\\n            dp[0][j] = 0\\n        for i in range(1, n + 1):\\n            dp[i][0] = dp[i - 1][0] + int(floor[i - 1])\\n\\t\\t# DP transition formula\\n        for i in range(1, n + 1):\\n            for j in range(1, numCarpets + 1):\\n                dp[i][j] = min(dp[i - 1][j] + int(floor[i - 1]), dp[max(i - carpetLen, 0)][j - 1])\\n        return dp[n][numCarpets]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n\\t\\t# edge case handling\\n        if numCarpets * carpetLen >= n:\\n            return 0\\n        if carpetLen == 1:\\n            return max(sum([int(c) for c in floor]) - numCarpets, 0)\\n\\t\\t# DP initialization\\n        dp = [[None] * (numCarpets + 1) for _ in range(n + 1)]\\n        for j in range(numCarpets + 1):\\n            dp[0][j] = 0\\n        for i in range(1, n + 1):\\n            dp[i][0] = dp[i - 1][0] + int(floor[i - 1])\\n\\t\\t# DP transition formula\\n        for i in range(1, n + 1):\\n            for j in range(1, numCarpets + 1):\\n                dp[i][j] = min(dp[i - 1][j] + int(floor[i - 1]), dp[max(i - carpetLen, 0)][j - 1])\\n        return dp[n][numCarpets]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864943,
                "title": "c-easy-to-understand-memoization-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1002][1002];\\n    int solve(string &floor,int i,int n,int l,vector<int> &prefix)\\n    {\\n        if(i>=floor.size()||n==0)\\n        return 0;\\n        if(dp[i][n]!=-1)\\n        return dp[i][n];\\n        if(floor[i]==\\'0\\')\\n        return dp[i][n]=solve(floor,i+1,n,l,prefix);\\n        int x=min((int)(floor.size()),(int)(i+l))-1;\\n        int white=prefix[x];\\n        if(i!=0)\\n        white-=prefix[i-1];\\n        int ans1=white+solve(floor,i+l,n-1,l,prefix);\\n        int ans2=solve(floor,i+1,n,l,prefix);\\n        return dp[i][n]=max(ans1,ans2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.size();\\n        vector<int> prefix(n);\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=numCarpets;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        if(floor[0]==\\'1\\')\\n        prefix[0]=1;\\n        else\\n        prefix[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[i]=prefix[i-1]+(floor[i]==\\'1\\');\\n        }\\n        int total_white=prefix[n-1];\\n        if(total_white==0)\\n        return 0;\\n        return total_white-solve(floor,0,numCarpets,carpetLen,prefix);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1002][1002];\\n    int solve(string &floor,int i,int n,int l,vector<int> &prefix)\\n    {\\n        if(i>=floor.size()||n==0)\\n        return 0;\\n        if(dp[i][n]!=-1)\\n        return dp[i][n];\\n        if(floor[i]==\\'0\\')\\n        return dp[i][n]=solve(floor,i+1,n,l,prefix);\\n        int x=min((int)(floor.size()),(int)(i+l))-1;\\n        int white=prefix[x];\\n        if(i!=0)\\n        white-=prefix[i-1];\\n        int ans1=white+solve(floor,i+l,n-1,l,prefix);\\n        int ans2=solve(floor,i+1,n,l,prefix);\\n        return dp[i][n]=max(ans1,ans2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.size();\\n        vector<int> prefix(n);\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=numCarpets;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        if(floor[0]==\\'1\\')\\n        prefix[0]=1;\\n        else\\n        prefix[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[i]=prefix[i-1]+(floor[i]==\\'1\\');\\n        }\\n        int total_white=prefix[n-1];\\n        if(total_white==0)\\n        return 0;\\n        return total_white-solve(floor,0,numCarpets,carpetLen,prefix);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864915,
                "title": "c-dp-recursion-memorization-easy-to-understand",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int carpetLen, fLen;\\n    vector<int> sum;\\n    vector<vector<int>> dp;\\n    int solve(int pos, int numCar, string& floor){\\n        if(pos >= fLen){\\n            return 0;\\n        }\\n        \\n        if(numCar == 0){\\n            return 0;\\n        }\\n        \\n        int &ret = dp[pos][numCar];\\n        \\n        if(ret != -1){\\n            return ret;\\n        }\\n        \\n        int taken = 0, notTaken = 0;\\n        int fSum = 0, lSum = 0;\\n        \\n        fSum = pos > 0 ? sum[pos - 1] : 0;\\n        lSum = pos + carpetLen > fLen ? sum[fLen - 1] : sum[pos + carpetLen - 1];\\n        \\n        taken = lSum - fSum + solve(pos + carpetLen,  numCar - 1, floor);\\n        notTaken = solve(pos + 1, numCar, floor);\\n        \\n        return ret = max(taken, notTaken);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        fLen = floor.size();\\n        this->carpetLen = carpetLen;\\n        sum.resize(fLen + 1, 0);\\n        dp.resize(fLen + 1, vector<int> (numCarpets + 1, -1));\\n        sum[0] = floor[0] - \\'0\\';\\n        \\n        for(int i = 1; i < fLen; i++){\\n            sum[i] = sum[i - 1] + (floor[i] - \\'0\\');\\n        }\\n        \\n        return sum[fLen - 1] - solve(0, numCarpets, floor);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int carpetLen, fLen;\\n    vector<int> sum;\\n    vector<vector<int>> dp;\\n    int solve(int pos, int numCar, string& floor){\\n        if(pos >= fLen){\\n            return 0;\\n        }\\n        \\n        if(numCar == 0){\\n            return 0;\\n        }\\n        \\n        int &ret = dp[pos][numCar];\\n        \\n        if(ret != -1){\\n            return ret;\\n        }\\n        \\n        int taken = 0, notTaken = 0;\\n        int fSum = 0, lSum = 0;\\n        \\n        fSum = pos > 0 ? sum[pos - 1] : 0;\\n        lSum = pos + carpetLen > fLen ? sum[fLen - 1] : sum[pos + carpetLen - 1];\\n        \\n        taken = lSum - fSum + solve(pos + carpetLen,  numCar - 1, floor);\\n        notTaken = solve(pos + 1, numCar, floor);\\n        \\n        return ret = max(taken, notTaken);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        fLen = floor.size();\\n        this->carpetLen = carpetLen;\\n        sum.resize(fLen + 1, 0);\\n        dp.resize(fLen + 1, vector<int> (numCarpets + 1, -1));\\n        sum[0] = floor[0] - \\'0\\';\\n        \\n        for(int i = 1; i < fLen; i++){\\n            sum[i] = sum[i - 1] + (floor[i] - \\'0\\');\\n        }\\n        \\n        return sum[fLen - 1] - solve(0, numCarpets, floor);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864513,
                "title": "java-using-dynamic-programming-simple-solution",
                "content": "First, if numCarpets * carpetLen > floor.size(), the answer is always 0 because the entire floor can be covered.\\nOtherwise,This problem can be solved by using dynamic programming.\\nThe variables in the DP are\\n1. length of confirmed Floor (starting from the left end at 0)\\n2. number of carpets used\\n\\nThe spatial computational complexity of a 2-dimensional array using the above variables is O(1e6).\\n\\nPlease see the image below for a sample transition with floor = \"10110\", numCarpets = 2, carpetLen = 2.\\n![image](https://assets.leetcode.com/users/images/20a2a6f5-af47-40d4-a972-6e2e000d96e3_1647710851.003477.png)\\n\\nThe red arrow shows the transition when the carpet is pulled.\\n`dp[i+cl][j+1] = Math.min(dp[i+cl][j+1], dp[i][j]);`\\n\\u203B Math.min(i+cl,f.length) is used in my code because the index could exceed floor.size().\\n\\nThe black arrow is the transition if the carpet is not pulled.\\nIf the next floor is white, increase the value by +1 from the current value.\\n`dp[i+1][j] = Math.min(dp[i+1][j], dp[i][j] + floor[i]);`\\n\\nWe have solved this problem by performing two different transitions for each item in the dp array.\\n\\nex) the gray items and arrows are not valid, we can show that there is no transition from dp[0][0] to dp[1][0],dp[1][1] for example, because the length of the carpet is more than 2.\\n\\n```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        //1. Redefine for variable name shortening\\n        int ln = floor.length();\\n        int nc = numCarpets;\\n        int cl = carpetLen;\\n        \\n        //2. Return 0 if all floors can be covered from carpet length * number of carpets.\\n        char[] f = floor.toCharArray();\\n        int cover = numCarpets * carpetLen;\\n        if(cover >= f.length) return 0;\\n        \\n        \\n        //3. Dynamic Programming\\n        int[][] dp = new int[ln+1][nc+1];\\n        for(int i = 0; i <= ln; i++) Arrays.fill(dp[i],f.length);\\n        dp[0][0] = 0;\\n        for(int i = 0; i < ln; i++){\\n            int plus = f[i]-\\'0\\';\\n            for(int j = 0; j <= nc; j++){\\n                dp[i+1][j] = Math.min(dp[i+1][j],dp[i][j] + plus);\\n                if(j != nc) dp[Math.min(i+cl,f.length)][j+1] = Math.min(dp[Math.min(i+cl,f.length)][j+1], dp[i][j]);\\n            }\\n        }\\n        return dp[ln][nc];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        //1. Redefine for variable name shortening\\n        int ln = floor.length();\\n        int nc = numCarpets;\\n        int cl = carpetLen;\\n        \\n        //2. Return 0 if all floors can be covered from carpet length * number of carpets.\\n        char[] f = floor.toCharArray();\\n        int cover = numCarpets * carpetLen;\\n        if(cover >= f.length) return 0;\\n        \\n        \\n        //3. Dynamic Programming\\n        int[][] dp = new int[ln+1][nc+1];\\n        for(int i = 0; i <= ln; i++) Arrays.fill(dp[i],f.length);\\n        dp[0][0] = 0;\\n        for(int i = 0; i < ln; i++){\\n            int plus = f[i]-\\'0\\';\\n            for(int j = 0; j <= nc; j++){\\n                dp[i+1][j] = Math.min(dp[i+1][j],dp[i][j] + plus);\\n                if(j != nc) dp[Math.min(i+cl,f.length)][j+1] = Math.min(dp[Math.min(i+cl,f.length)][j+1], dp[i][j]);\\n            }\\n        }\\n        return dp[ln][nc];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864481,
                "title": "c-dp-house-robber",
                "content": "This problem can be converted to [house robber](https://leetcode.com/problems/house-robber/) then solved by dynamic programming.\\nWhen the total length of carpet is equal to or exceed the length of the floor, there should be no white left. When it\\'s not, we should always looking for non-overlapping solution as at least one of the optimal solution doesn\\'t include overlapping. The reason is that we can always rearrange carpets to not overlap and covering all the original tiles and some more.\\nSo we can calculate how many white tiles can be covered starting from each position, the problem is to select ```numCarpet``` of positions, with minimum distance of any two position is ```carpetLen```, to get the maximum sum. It\\'s equivalent to house robber except that we not only can\\'t rob consecutive houses, we can\\'t rob houses within some given distance ```carpetLen```. Also we have a fixed amount of house we have to rob, so instead of a 1D DP as we did in house robber, a standard 2D DP approach should suffice. See annotation for details.\\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n\\t\\t//too many carpets, cover all the floor\\n        int l = floor.size();\\n        if(numCarpets*carpetLen>=l) {return 0;}\\n\\t\\t\\n        // sliding window to calculate how many white tiles can be covered for a carpet starting at position i\\n        int white = 0;             // number of total white tiles on the floor\\n        int m = l-carpetLen+1;     // number of possible carpet starting position\\n        vector<int> cover(m,0);    // number of white tiles covered for a carpet starting at each position\\n        for(int i=0; i<carpetLen; i++){\\n            cover[0] += (floor[i]==\\'1\\');\\n            white += (floor[i]==\\'1\\');\\n        }\\n        for(int i=1; i<m; i++){\\n            cover[i] = cover[i-1] - (floor[i-1]==\\'1\\') + (floor[i+carpetLen-1]==\\'1\\');\\n            white += (floor[i+carpetLen-1]==\\'1\\');\\n        }\\n\\t\\t\\n        // dp to find the maximum sum of numCarpets elements from cover[0:m-1], \\n\\t\\t// with any of the two elements having minimum distance of carpetLen\\n\\t\\t// dp[k][i] stands for the maximum sum for k elements in cover[0:i]\\n        vector<vector<int>> dp(numCarpets+1, vector<int>(m,0));\\n        dp[1][0] = cover[0];\\n        for(int i=1; i<m; i++){\\n            dp[1][i] = max(dp[1][i-1],cover[i]);\\n        }\\n        for(int carpet=2; carpet<=numCarpets; carpet++){\\n            for(int i=(carpet-1)*carpetLen; i<m; i++){\\n\\t\\t\\t\\t// either we don\\'t select current element, \\n\\t\\t\\t\\t// or we select current element and limit the range of last selected element before i-carpetLen\\n                dp[carpet][i] = max(dp[carpet][i-1],cover[i]+dp[carpet-1][i-carpetLen]);\\n            }\\n        }\\n        return white-dp[numCarpets][m-1];\\n    }\\n};\\n```\\nThis solution should be able to optimized to O(N) space complexity by using two 1D vectors.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```numCarpet```\n```carpetLen```\n```carpetLen```\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n\\t\\t//too many carpets, cover all the floor\\n        int l = floor.size();\\n        if(numCarpets*carpetLen>=l) {return 0;}\\n\\t\\t\\n        // sliding window to calculate how many white tiles can be covered for a carpet starting at position i\\n        int white = 0;             // number of total white tiles on the floor\\n        int m = l-carpetLen+1;     // number of possible carpet starting position\\n        vector<int> cover(m,0);    // number of white tiles covered for a carpet starting at each position\\n        for(int i=0; i<carpetLen; i++){\\n            cover[0] += (floor[i]==\\'1\\');\\n            white += (floor[i]==\\'1\\');\\n        }\\n        for(int i=1; i<m; i++){\\n            cover[i] = cover[i-1] - (floor[i-1]==\\'1\\') + (floor[i+carpetLen-1]==\\'1\\');\\n            white += (floor[i+carpetLen-1]==\\'1\\');\\n        }\\n\\t\\t\\n        // dp to find the maximum sum of numCarpets elements from cover[0:m-1], \\n\\t\\t// with any of the two elements having minimum distance of carpetLen\\n\\t\\t// dp[k][i] stands for the maximum sum for k elements in cover[0:i]\\n        vector<vector<int>> dp(numCarpets+1, vector<int>(m,0));\\n        dp[1][0] = cover[0];\\n        for(int i=1; i<m; i++){\\n            dp[1][i] = max(dp[1][i-1],cover[i]);\\n        }\\n        for(int carpet=2; carpet<=numCarpets; carpet++){\\n            for(int i=(carpet-1)*carpetLen; i<m; i++){\\n\\t\\t\\t\\t// either we don\\'t select current element, \\n\\t\\t\\t\\t// or we select current element and limit the range of last selected element before i-carpetLen\\n                dp[carpet][i] = max(dp[carpet][i-1],cover[i]+dp[carpet-1][i-carpetLen]);\\n            }\\n        }\\n        return white-dp[numCarpets][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864442,
                "title": "c-dp-solution-memoization-100-fast-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &hash, int &num, int &len, int i, int j, vector<vector<int>> &dp){\\n        int n = hash.size();\\n        if (j >= num or i >= n)  return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n//     Dont want to put the carpet on the ith place\\n        int not_take = solve(hash, num, len, i+1, j, dp);\\n//     Want to put the carpet on the ith place and the corresponding value which it gives is added\\n        int take = hash[i] + solve(hash, num, len, i+len, j+1, dp);\\n        \\n        return dp[i][j] = max(not_take, take);\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int num, int len) {\\n        int n = floor.size();\\n        if (num*len >= n)   return 0;    \\n        int var = 0, count = 0;\\n        for (int i = 0;i < n;i++)   count += (floor[i] == \\'1\\');\\n        if (count == n){\\n            return (n - (num*len));\\n        }\\n//     hash stores that if we put the carpet at the ith position \\n//     then how much white space i\\'ll cover\\n        vector<int> hash(n);\\n        for (int i = n-1;i >= 0;i--){\\n            if (floor[i] == \\'1\\'){\\n                var += 1;\\n            }\\n            if (i+len < n and floor[i+len] == \\'1\\'){\\n                var -= 1;\\n            }\\n            hash[i] = var;\\n        }\\n//     dp[i][j] stores if i am on the ith index and jth carpet is used \\n//     then how much maximum white spaces i\\'ll cover\\n        vector<vector<int>> dp(n, vector<int> (num, -1));\\n//     solve gives me the maximus white i can cover with carpet using the num number of carpets \\n//     of length len\\n        int temp = solve(hash, num, len, 0, 0, dp);\\n        return count - temp;\\n    }\\n};\\n```\\nComment below if you have any doubt\\nPlease upvote if you like\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &hash, int &num, int &len, int i, int j, vector<vector<int>> &dp){\\n        int n = hash.size();\\n        if (j >= num or i >= n)  return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n//     Dont want to put the carpet on the ith place\\n        int not_take = solve(hash, num, len, i+1, j, dp);\\n//     Want to put the carpet on the ith place and the corresponding value which it gives is added\\n        int take = hash[i] + solve(hash, num, len, i+len, j+1, dp);\\n        \\n        return dp[i][j] = max(not_take, take);\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int num, int len) {\\n        int n = floor.size();\\n        if (num*len >= n)   return 0;    \\n        int var = 0, count = 0;\\n        for (int i = 0;i < n;i++)   count += (floor[i] == \\'1\\');\\n        if (count == n){\\n            return (n - (num*len));\\n        }\\n//     hash stores that if we put the carpet at the ith position \\n//     then how much white space i\\'ll cover\\n        vector<int> hash(n);\\n        for (int i = n-1;i >= 0;i--){\\n            if (floor[i] == \\'1\\'){\\n                var += 1;\\n            }\\n            if (i+len < n and floor[i+len] == \\'1\\'){\\n                var -= 1;\\n            }\\n            hash[i] = var;\\n        }\\n//     dp[i][j] stores if i am on the ith index and jth carpet is used \\n//     then how much maximum white spaces i\\'ll cover\\n        vector<vector<int>> dp(n, vector<int> (num, -1));\\n//     solve gives me the maximus white i can cover with carpet using the num number of carpets \\n//     of length len\\n        int temp = solve(hash, num, len, 0, 0, dp);\\n        return count - temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864395,
                "title": "c-solution-memo-recursive-prefix-array",
                "content": "So , Here i changed the question instead of finding the minimum no of white tiles after placing k tiles , I am trying to find the maximum white tiles i can cover with the  k tiles and return the answer after subtracting with the  intital  no of white tiles present in the string.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    vector<int>prefix;\\n    int helper(int idx,int k,string& floor,int len){\\n        if(idx >= floor.size())return 0;\\n        if(dp[idx][k] != -1)return dp[idx][k];\\n        int op1 = helper(idx + 1,k,floor,len);\\n        int op2 = 0;\\n        if(floor[idx] == \\'1\\' && k > 0){\\n            int sz = min(idx + len,(int)floor.size());\\n            int y = prefix[sz - 1];\\n            if(idx - 1 >= 0){\\n                y -= prefix[idx - 1];\\n            }\\n            op2 = y + helper(idx + len,k - 1,floor,len);\\n        }\\n        return dp[idx][k] = max(op1,op2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int cnt = 0;\\n        int n = floor.size();\\n        memset(dp,-1,sizeof dp);\\n        for(int i =0;i<floor.size();i++){\\n            if(floor[i] == \\'1\\')cnt++;\\n        }\\n        prefix.resize(n + 1,0);\\n        prefix[0] = (floor[0] == \\'1\\');\\n        for(int i =1;i<=n;i++){\\n            if(floor[i] == \\'1\\'){\\n                prefix[i] = prefix[i - 1] + 1;\\n            }\\n            else prefix[i] = prefix[i - 1];\\n        }\\n        if(cnt == 0)return 0;\\n        return cnt - helper(0,numCarpets,floor,carpetLen);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    vector<int>prefix;\\n    int helper(int idx,int k,string& floor,int len){\\n        if(idx >= floor.size())return 0;\\n        if(dp[idx][k] != -1)return dp[idx][k];\\n        int op1 = helper(idx + 1,k,floor,len);\\n        int op2 = 0;\\n        if(floor[idx] == \\'1\\' && k > 0){\\n            int sz = min(idx + len,(int)floor.size());\\n            int y = prefix[sz - 1];\\n            if(idx - 1 >= 0){\\n                y -= prefix[idx - 1];\\n            }\\n            op2 = y + helper(idx + len,k - 1,floor,len);\\n        }\\n        return dp[idx][k] = max(op1,op2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int cnt = 0;\\n        int n = floor.size();\\n        memset(dp,-1,sizeof dp);\\n        for(int i =0;i<floor.size();i++){\\n            if(floor[i] == \\'1\\')cnt++;\\n        }\\n        prefix.resize(n + 1,0);\\n        prefix[0] = (floor[0] == \\'1\\');\\n        for(int i =1;i<=n;i++){\\n            if(floor[i] == \\'1\\'){\\n                prefix[i] = prefix[i - 1] + 1;\\n            }\\n            else prefix[i] = prefix[i - 1];\\n        }\\n        if(cnt == 0)return 0;\\n        return cnt - helper(0,numCarpets,floor,carpetLen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864304,
                "title": "python3-dp-o-n-numcarpets-solution-got-a-tle-is-this-intended",
                "content": "My solution is given as\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        dp = dict() # i, num_carpets remaining -> num white\\n        n = len(floor)\\n        for i in range(n+1)[::-1]:\\n            for j in range(numCarpets+1):\\n                if i == n:\\n                    dp[(i,j)] = 0\\n                    continue\\n                \\n                if floor[i] == \\'0\\':\\n                    dp[(i,j)] = dp[(i+1,j)]\\n                else:\\n                    dp[(i,j)] = 1+dp[(i+1,j)] \\n                    if j > 0:\\n                        dp[(i,j)] = min(dp[(i,j)], dp[(min(i+carpetLen, n),j-1)])\\n        \\n        return dp[(0, numCarpets)]\\n```\\nShould I make it more faster? \\nIs this intended?",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        dp = dict() # i, num_carpets remaining -> num white\\n        n = len(floor)\\n        for i in range(n+1)[::-1]:\\n            for j in range(numCarpets+1):\\n                if i == n:\\n                    dp[(i,j)] = 0\\n                    continue\\n                \\n                if floor[i] == \\'0\\':\\n                    dp[(i,j)] = dp[(i+1,j)]\\n                else:\\n                    dp[(i,j)] = 1+dp[(i+1,j)] \\n                    if j > 0:\\n                        dp[(i,j)] = min(dp[(i,j)], dp[(min(i+carpetLen, n),j-1)])\\n        \\n        return dp[(0, numCarpets)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864125,
                "title": "dp-intuition-with-explaination",
                "content": "**Intuition**\\n\\n\\nlets suppose are at ith index.\\n\\nsuppose we are at index i and with j carpets\\ndp[i][j] denotes minimum number of uncovered white cells from 0 to i with j \\ncarpets.\\n\\n1. if number of carpets = 0 dp[i][j] = number of carpets from 0 to i.\\n\\n\\nsuppose we are at index i and with j carpets\\n1. we dont put carpet. in this case number of uncovered white cells will be \\nnumber of uncovered white cells at i-1 +  1 (if ith cell is )\\ndp[i][j]  = dp[i-1][j] + 1 if ith carpet is red;\\n\\n\\n2. if we are placing carpet (j>0) such that ith is the last cell covered.\\n\\ni-carpetlength < 0 that means we are fulling covering from 0 to i.\\n[i][j] = 0\\n\\ni-carpetlength >= 0 that means we are covering from\\ni-carpetlength+1 to i and number of carpet left are j-1\\n\\nso dp[i][j] = dp[i-carpetlength][j-1] // cells i-carpetlength+1 to i is covered\\n\\nat last we will take minimmum of both the values \\ndp[i][j]  = min(dp[i-1][j]) + 1 if ith carpet is red, 0 if i-carpetlength < 0 else dp[i-carpetlength][j-1]\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        vector<vector<int>>dp(n,vector<int>(numCarpets+1));\\n        int ans = 0;\\n        vector<int>freq(n);\\n        for(int i = 0;i<n;i++)\\n        {\\n            ans += floor[i]-\\'0\\';\\n            freq[i] = ans;\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<=numCarpets;j++)\\n            {\\n                if(j == 0)\\n                {\\n                    dp[i][j] = freq[i];\\n                    continue;\\n                }\\n                if(i-carpetLen < 0)\\n                {\\n                    dp[i][j] = 0;\\n                }\\n                else if(i-carpetLen >= 0)\\n                {\\n                    dp[i][j] = dp[i-carpetLen][j-1];\\n                }\\n                int value = 0;\\n                if(i>0)\\n                {\\n                        value += floor[i]-\\'0\\';\\n                      dp[i][j] = min(dp[i-1][j] + value ,dp[i][j]);\\n                }\\n                else\\n                {\\n                      value += floor[i]-\\'0\\';\\n                    dp[i][j] = min(value ,dp[i][j]);\\n                }\\n          }\\n           \\n        }\\n        return dp[n-1][numCarpets];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        vector<vector<int>>dp(n,vector<int>(numCarpets+1));\\n        int ans = 0;\\n        vector<int>freq(n);\\n        for(int i = 0;i<n;i++)\\n        {\\n            ans += floor[i]-\\'0\\';\\n            freq[i] = ans;\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<=numCarpets;j++)\\n            {\\n                if(j == 0)\\n                {\\n                    dp[i][j] = freq[i];\\n                    continue;\\n                }\\n                if(i-carpetLen < 0)\\n                {\\n                    dp[i][j] = 0;\\n                }\\n                else if(i-carpetLen >= 0)\\n                {\\n                    dp[i][j] = dp[i-carpetLen][j-1];\\n                }\\n                int value = 0;\\n                if(i>0)\\n                {\\n                        value += floor[i]-\\'0\\';\\n                      dp[i][j] = min(dp[i-1][j] + value ,dp[i][j]);\\n                }\\n                else\\n                {\\n                      value += floor[i]-\\'0\\';\\n                    dp[i][j] = min(value ,dp[i][j]);\\n                }\\n          }\\n           \\n        }\\n        return dp[n-1][numCarpets];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864052,
                "title": "python-dp-memoization-solution",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        if numCarpets*carpetLen >= len(floor):\\n            return 0\\n        l = list(map(int,list(floor)))\\n        dp = [[-1]*(numCarpets+1) for j in range(len(l))]\\n        \\n        def rec(i,n):\\n            nonlocal l\\n            if n == 0 or i >= len(l):\\n                return sum(l[i:])\\n            if dp[i][n] != -1:\\n                return dp[i][n]\\n            dp[i][n] = min(rec(i+carpetLen,n-1),rec(i+1,n)+l[i])\\n            return dp[i][n]\\n        \\n        return rec(0,numCarpets)\\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        if numCarpets*carpetLen >= len(floor):\\n            return 0\\n        l = list(map(int,list(floor)))\\n        dp = [[-1]*(numCarpets+1) for j in range(len(l))]\\n        \\n        def rec(i,n):\\n            nonlocal l\\n            if n == 0 or i >= len(l):\\n                return sum(l[i:])\\n            if dp[i][n] != -1:\\n                return dp[i][n]\\n            dp[i][n] = min(rec(i+carpetLen,n-1),rec(i+1,n)+l[i])\\n            return dp[i][n]\\n        \\n        return rec(0,numCarpets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864031,
                "title": "dp-memorization-easy-to-understand-solution-c-o-n-2-time-and-o-n-2-space",
                "content": "We can solve this problem by using standard concepts of solving a 2-d DP problem.\\nFor each tile, we have two options --\\ni) We place a the carpet starting from the current tile\\nii) We do not place a carpet\\n\\nFurther, here is an observations to be made\\n-- Placing carpet starting from a black tile is not feasible. SO before placing a carpet, we will check whether the current tile is white or not.\\n\\n\\nBelow is the code for the approach explained above. Lines have been commented in order to understand better.\\n\\n```\\nint solve(string &a,int i,int j,int k,int len,vector<vector<long long int>> &dp)\\n{\\n    \\n    // dp states --\\n    //     i --> represents the index of the tiles\\n    //     j --> represents the number of black carpets used\\n    \\n    if(i>=a.size())\\n    {\\n        // base case\\n        return 0;\\n    }\\n    \\n    if(dp[i][j]!=-1)\\n    {\\n        // since the current tile is already black, no need of covering it\\n        \\n        return dp[i][j];\\n    }\\n    \\n    \\n    if(a[i]==\\'1\\')\\n    {\\n        // the current tile is white in color, so we have two options\\n        \\n        int op1=INT_MAX,op2=INT_MAX;\\n        \\n        // option 1 - place carpet\\n        \\n        if(j<k) // we can only place carpets if we have some remaining black carpets\\n            op1=solve(a,i+len,j+1,k,len,dp);\\n        \\n        // option 2 - dont place the carpet\\n        op2=1+solve(a,i+1,j,k,len,dp);\\n        \\n        \\n        return dp[i][j]=min(op1,op2);\\n    }\\n    \\n    return dp[i][j]=solve(a,i+1,j,k,len,dp);\\n    \\n}\\n\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string a, int k, int len) {\\n        \\n        // creating a two dimensional dp array\\n        vector<vector<long long int>> dp(a.size()+10,vector<long long int>(k+10,-1));\\n        \\n        return solve(a,0,0,k,len,dp);\\n        \\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint solve(string &a,int i,int j,int k,int len,vector<vector<long long int>> &dp)\\n{\\n    \\n    // dp states --\\n    //     i --> represents the index of the tiles\\n    //     j --> represents the number of black carpets used\\n    \\n    if(i>=a.size())\\n    {\\n        // base case\\n        return 0;\\n    }\\n    \\n    if(dp[i][j]!=-1)\\n    {\\n        // since the current tile is already black, no need of covering it\\n        \\n        return dp[i][j];\\n    }\\n    \\n    \\n    if(a[i]==\\'1\\')\\n    {\\n        // the current tile is white in color, so we have two options\\n        \\n        int op1=INT_MAX,op2=INT_MAX;\\n        \\n        // option 1 - place carpet\\n        \\n        if(j<k) // we can only place carpets if we have some remaining black carpets\\n            op1=solve(a,i+len,j+1,k,len,dp);\\n        \\n        // option 2 - dont place the carpet\\n        op2=1+solve(a,i+1,j,k,len,dp);\\n        \\n        \\n        return dp[i][j]=min(op1,op2);\\n    }\\n    \\n    return dp[i][j]=solve(a,i+1,j,k,len,dp);\\n    \\n}\\n\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string a, int k, int len) {\\n        \\n        // creating a two dimensional dp array\\n        vector<vector<long long int>> dp(a.size()+10,vector<long long int>(k+10,-1));\\n        \\n        return solve(a,0,0,k,len,dp);\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863972,
                "title": "python3-dp-solution-in-o-mn-time-and-o-n-space",
                "content": "# dp solution:\\n* `dp[i][j]` represents for the max number of covered white tiles within `floor[:j + 1]` using `i` carpets\\n* `dp[i][j] = max(max(dp[i][k] for k in range(j)), white count in floor[j - carpetLen : j + 1] + dp[i - 1][j - carpetLen])`\\n```\\ndef minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n    # dp\\n    n = len(floor)\\n    cnt_white = []\\n    cnt = 0\\n    for i in floor:\\n        cnt += int(i)\\n        cnt_white.append(cnt)\\n\\t\\t\\n    dp = [[0] * (n) for _ in range(numCarpets + 1)]\\n    for i in range(1, numCarpets + 1):\\n        max_ = 0\\n        for j in range(n):\\n            # i carpets\\n            # cover [0:j + 1] floor\\n            if j - carpetLen < 0:\\n                dp[i][j] = cnt_white[j]\\n            else:\\n                dp[i][j] = max(max_, cnt_white[j] - cnt_white[j - carpetLen] + dp[i - 1][j - carpetLen])\\n                max_ = dp[i][j]\\n    return cnt - dp[-1][-1]\\n```\\n\\n# optimization:\\nsince `dp[i]` only depend on `dp[i-1]`, we cound reduce space complexity to `O(N)`\\n```\\ndef minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n    # dp\\n\\tn = len(floor)\\n    cnt_white = []\\n    cnt = 0\\n    for i in floor:\\n        cnt += int(i)\\n        cnt_white.append(cnt)\\n    dp = [0] * (n)\\n    for i in range(1, numCarpets + 1):\\n        nxt = []\\n        max_ = 0\\n        for j in range(n):\\n            if j - carpetLen < 0:\\n                nxt.append(cnt_white[j])\\n            else:\\n                nxt.append(max(max_, cnt_white[j] - cnt_white[j - carpetLen] + dp[j - carpetLen]))\\n                max_ = nxt[-1]\\n        dp = nxt\\n    return cnt - dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n    # dp\\n    n = len(floor)\\n    cnt_white = []\\n    cnt = 0\\n    for i in floor:\\n        cnt += int(i)\\n        cnt_white.append(cnt)\\n\\t\\t\\n    dp = [[0] * (n) for _ in range(numCarpets + 1)]\\n    for i in range(1, numCarpets + 1):\\n        max_ = 0\\n        for j in range(n):\\n            # i carpets\\n            # cover [0:j + 1] floor\\n            if j - carpetLen < 0:\\n                dp[i][j] = cnt_white[j]\\n            else:\\n                dp[i][j] = max(max_, cnt_white[j] - cnt_white[j - carpetLen] + dp[i - 1][j - carpetLen])\\n                max_ = dp[i][j]\\n    return cnt - dp[-1][-1]\\n```\n```\\ndef minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n    # dp\\n\\tn = len(floor)\\n    cnt_white = []\\n    cnt = 0\\n    for i in floor:\\n        cnt += int(i)\\n        cnt_white.append(cnt)\\n    dp = [0] * (n)\\n    for i in range(1, numCarpets + 1):\\n        nxt = []\\n        max_ = 0\\n        for j in range(n):\\n            if j - carpetLen < 0:\\n                nxt.append(cnt_white[j])\\n            else:\\n                nxt.append(max(max_, cnt_white[j] - cnt_white[j - carpetLen] + dp[j - carpetLen]))\\n                max_ = nxt[-1]\\n        dp = nxt\\n    return cnt - dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1863921,
                "title": "python3-2d-dp-solution-explained",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        \\n        \"\"\"\\n        dp(pos, numC) -> returns min number of white tiles seen from pos to the end of the floor\\n                         if we have numC number of carpets left\\n        \\n        if numC > 0, i.e. we have some carpets remaining:\\n            if the tile at index pos is white, then we have two choices, \\n                either place a carpet from pos to pos + carpetLen - 1\\n                or skip this tile, so number of white tiles increases by one, and calculate the minimum answer from index\\n                pos + 1\\n            else\\n                no need to cover this tile, we can move ahead\\n        else:\\n            we cannot cover any more white tiles\\n            so return number of white tiles from pos to the end of floor\\n        \\n        \\n        time complexity : O(numCarpets * len(floor)) ~ O(n^2)\\n        \"\"\"\\n    \\n        @lru_cache(None) \\n        def dp(pos, numC):\\n            if pos >= n:\\n                return 0\\n            \\n            if numC > 0:\\n                if floor[pos] == \"1\":\\n                    return min(1 + dp(pos + 1, numC), dp(pos + carpetLen, numC - 1))\\n                else:\\n                    return dp(pos + 1, numC)\\n            else:\\n                return ones[pos]\\n                \\n        \\n        n = len(floor)\\n        \\n        #ones[i] stores the number of white tiles from index i to the end of floor \\n        ones = [0 for i in range(n)]\\n        ones[-1] = (floor[-1] == \"1\")\\n        \\n        for i in range(n-2, -1, -1):\\n            ones[i] = ones[i+1] + (floor[i] == \"1\")\\n            \\n            \\n        return dp(0, numCarpets)\\n                \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        \\n        \"\"\"\\n        dp(pos, numC) -> returns min number of white tiles seen from pos to the end of the floor\\n                         if we have numC number of carpets left\\n        \\n        if numC > 0, i.e. we have some carpets remaining:\\n            if the tile at index pos is white, then we have two choices, \\n                either place a carpet from pos to pos + carpetLen - 1\\n                or skip this tile, so number of white tiles increases by one, and calculate the minimum answer from index\\n                pos + 1\\n            else\\n                no need to cover this tile, we can move ahead\\n        else:\\n            we cannot cover any more white tiles\\n            so return number of white tiles from pos to the end of floor\\n        \\n        \\n        time complexity : O(numCarpets * len(floor)) ~ O(n^2)\\n        \"\"\"\\n    \\n        @lru_cache(None) \\n        def dp(pos, numC):\\n            if pos >= n:\\n                return 0\\n            \\n            if numC > 0:\\n                if floor[pos] == \"1\":\\n                    return min(1 + dp(pos + 1, numC), dp(pos + carpetLen, numC - 1))\\n                else:\\n                    return dp(pos + 1, numC)\\n            else:\\n                return ones[pos]\\n                \\n        \\n        n = len(floor)\\n        \\n        #ones[i] stores the number of white tiles from index i to the end of floor \\n        ones = [0 for i in range(n)]\\n        ones[-1] = (floor[-1] == \"1\")\\n        \\n        for i in range(n-2, -1, -1):\\n            ones[i] = ones[i+1] + (floor[i] == \"1\")\\n            \\n            \\n        return dp(0, numCarpets)\\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863880,
                "title": "c-with-comments-dp",
                "content": "```dp[idx][rem]``` wil store  maximum tiles we can cover from ```idx to last index``` if we are at index ```idx``` with ```rem``` amount of carpet\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>tile;\\n    vector<vector<int>>dp;\\n    int minimumWhiteTiles(string f, int num, int len) {\\n        int sz=f.size(),totalWHiteTiles=0;\\n        for(int i=0;i<sz;i++){\\n            if(f[i]==\\'1\\')\\n                totalWHiteTiles++;\\n            tile.push_back(totalWHiteTiles);\\n        }\\n        dp.resize(sz,vector<int>(num+1,-1));\\n        return totalWHiteTiles-helper(f,0,num,len);\\n    }\\n    int helper(string &floor,int idx,int rem,int &len){\\n        if(idx>=floor.size() || rem==0)\\n            return 0;\\n        if(dp[idx][rem]!=-1)\\n            return dp[idx][rem];\\n        int sz=floor.size();\\n        // don\\'t start covering the tiles from here\\n        int a=helper(floor,idx+1,rem,len);\\n        // start covering the  tiles from here\\n        int b=helper(floor,idx+len,rem-1,len);\\n        // last index where the carpet can go if we start coering from here\\n        int lastIdx=idx+len-1;\\n        // calculating how many tiles we will civer if we start from here\\n        b+=tile[lastIdx>=sz?(sz-1):lastIdx]-tile[idx];\\n        if(floor[idx]==\\'1\\')\\n            b++;\\n        dp[idx][rem]=max(a,b);\\n        return dp[idx][rem];\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```dp[idx][rem]```\n```idx to last index```\n```idx```\n```rem```\n```\\nclass Solution {\\npublic:\\n    vector<int>tile;\\n    vector<vector<int>>dp;\\n    int minimumWhiteTiles(string f, int num, int len) {\\n        int sz=f.size(),totalWHiteTiles=0;\\n        for(int i=0;i<sz;i++){\\n            if(f[i]==\\'1\\')\\n                totalWHiteTiles++;\\n            tile.push_back(totalWHiteTiles);\\n        }\\n        dp.resize(sz,vector<int>(num+1,-1));\\n        return totalWHiteTiles-helper(f,0,num,len);\\n    }\\n    int helper(string &floor,int idx,int rem,int &len){\\n        if(idx>=floor.size() || rem==0)\\n            return 0;\\n        if(dp[idx][rem]!=-1)\\n            return dp[idx][rem];\\n        int sz=floor.size();\\n        // don\\'t start covering the tiles from here\\n        int a=helper(floor,idx+1,rem,len);\\n        // start covering the  tiles from here\\n        int b=helper(floor,idx+len,rem-1,len);\\n        // last index where the carpet can go if we start coering from here\\n        int lastIdx=idx+len-1;\\n        // calculating how many tiles we will civer if we start from here\\n        b+=tile[lastIdx>=sz?(sz-1):lastIdx]-tile[idx];\\n        if(floor[idx]==\\'1\\')\\n            b++;\\n        dp[idx][rem]=max(a,b);\\n        return dp[idx][rem];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845101,
                "title": "easy-intuitive-solution-using-recursion-and-memoization",
                "content": "# Intuition\\nwe will try to put carpet on every white tile where it exists till\\nour number of carpets are over.\\n\\n# Approach\\nif we find a white tile we will put a carpet based on the length of\\nthe carpet and look for more white tile and put carpet over them too,\\nif the number of carpet is over we cant do anything at that case we \\nhave to count the white tiles. If it is black tile we ignore it.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>>dp(floor.size(),vector<int>(numCarpets+1,-1));\\n        return solve(0,floor,numCarpets,carpetLen,dp);\\n    }\\n    int solve(int i,string &floor, int numCarpets, int &carpetLen,vector<vector<int>>&dp){\\n        if(i == floor.size()) return 0;\\n        if(dp[i][numCarpets] != -1) return dp[i][numCarpets];\\n\\n        if(floor[i] == \\'1\\'){\\n            int putCarpet=INT_MAX;\\n            if(numCarpets!=0) \\n            {\\n               int temp= floor.size();\\n                putCarpet = solve( min(temp,i+carpetLen),floor,numCarpets-1,carpetLen,dp);\\n            }\\n\\n            int notput=1+solve(i+1,floor,numCarpets,carpetLen,dp);\\n\\n            return dp[i][numCarpets] = min(putCarpet,notput);\\n\\n        }else{\\n            //ignore black tiles\\n            return dp[i][numCarpets] =solve(i+1,floor,numCarpets,carpetLen,dp);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>>dp(floor.size(),vector<int>(numCarpets+1,-1));\\n        return solve(0,floor,numCarpets,carpetLen,dp);\\n    }\\n    int solve(int i,string &floor, int numCarpets, int &carpetLen,vector<vector<int>>&dp){\\n        if(i == floor.size()) return 0;\\n        if(dp[i][numCarpets] != -1) return dp[i][numCarpets];\\n\\n        if(floor[i] == \\'1\\'){\\n            int putCarpet=INT_MAX;\\n            if(numCarpets!=0) \\n            {\\n               int temp= floor.size();\\n                putCarpet = solve( min(temp,i+carpetLen),floor,numCarpets-1,carpetLen,dp);\\n            }\\n\\n            int notput=1+solve(i+1,floor,numCarpets,carpetLen,dp);\\n\\n            return dp[i][numCarpets] = min(putCarpet,notput);\\n\\n        }else{\\n            //ignore black tiles\\n            return dp[i][numCarpets] =solve(i+1,floor,numCarpets,carpetLen,dp);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843439,
                "title": "dp-solution-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int f(int ind,int count,string  &s,int carpetlen,vector<vector<int>>&dp){\\n        if(count<0)return -1e9;\\n        if(ind >= s.size())return 0;\\n\\n        if(dp[ind][count]!=-1)return dp[ind][count];\\n        int color = -1e9;\\n        int notcolor = -1e9;\\n        if(s[ind] == \\'0\\'){\\n            notcolor = 1 + f(ind+1,count,s,carpetlen,dp);//we donot need to color this index as it is laredy black \\n        }\\n        else if(s[ind] == \\'1\\'){\\n            notcolor = f(ind+1,count,s,carpetlen,dp);\\n            if(ind+carpetlen >=s.size()){\\n                color=(s.size() - ind);\\n            }\\n            else color=carpetlen;\\n            color+=f(ind+carpetlen,count-1,s,carpetlen,dp);//color means we are coloring \\n        }\\n\\n        return dp[ind][count] = max(color,notcolor);\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n        int n = floor.size();\\n        int count = numCarpets;\\n        vector<vector<int>>dp(n,vector<int>(count+1,-1));\\n        int k = f(0,count,floor,carpetLen,dp);\\n        cout<<k<<endl;\\n        return n - k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int f(int ind,int count,string  &s,int carpetlen,vector<vector<int>>&dp){\\n        if(count<0)return -1e9;\\n        if(ind >= s.size())return 0;\\n\\n        if(dp[ind][count]!=-1)return dp[ind][count];\\n        int color = -1e9;\\n        int notcolor = -1e9;\\n        if(s[ind] == \\'0\\'){\\n            notcolor = 1 + f(ind+1,count,s,carpetlen,dp);//we donot need to color this index as it is laredy black \\n        }\\n        else if(s[ind] == \\'1\\'){\\n            notcolor = f(ind+1,count,s,carpetlen,dp);\\n            if(ind+carpetlen >=s.size()){\\n                color=(s.size() - ind);\\n            }\\n            else color=carpetlen;\\n            color+=f(ind+carpetlen,count-1,s,carpetlen,dp);//color means we are coloring \\n        }\\n\\n        return dp[ind][count] = max(color,notcolor);\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n        int n = floor.size();\\n        int count = numCarpets;\\n        vector<vector<int>>dp(n,vector<int>(count+1,-1));\\n        int k = f(0,count,floor,carpetLen,dp);\\n        cout<<k<<endl;\\n        return n - k;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3784168,
                "title": "0-1-knapsack-pick-not-pick-easy-to-read-concise-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n,l;\\nint numCarpets;\\nint dp[1000+1][1000+1];\\n    int solve(string &floor, int ind, int rem){\\n        if(ind>=n) return 0;\\n        if(dp[ind][rem] != -1) return dp[ind][rem];\\n\\n        if(floor[ind]==\\'1\\'){\\n           int pick=INT_MAX,not_pick=INT_MAX;\\n\\n            if(rem) pick=solve(floor,ind+l,rem-1);\\n            not_pick=1+solve(floor,ind+1,rem);\\n            return dp[ind][rem]=min(op1,op2);\\n        }\\n        return dp[ind][rem]=solve(floor,ind+1,rem);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        n=floor.size(), l=carpetLen;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(floor,0,numCarpets);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n,l;\\nint numCarpets;\\nint dp[1000+1][1000+1];\\n    int solve(string &floor, int ind, int rem){\\n        if(ind>=n) return 0;\\n        if(dp[ind][rem] != -1) return dp[ind][rem];\\n\\n        if(floor[ind]==\\'1\\'){\\n           int pick=INT_MAX,not_pick=INT_MAX;\\n\\n            if(rem) pick=solve(floor,ind+l,rem-1);\\n            not_pick=1+solve(floor,ind+1,rem);\\n            return dp[ind][rem]=min(op1,op2);\\n        }\\n        return dp[ind][rem]=solve(floor,ind+1,rem);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        n=floor.size(), l=carpetLen;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(floor,0,numCarpets);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776595,
                "title": "dp-solution-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int i,string &s,int k,int len,vector<int> &pre,vector<vector<int>> &dp){\\n        int n = s.size();\\n        if(i>=n) return 0;\\n        \\n        if(dp[i][k]!=-1) return dp[i][k];\\n        \\n        int tk=-1e9,ksum=0;\\n        ksum=(i+len<=n)?(pre[i+len]-pre[i]):(pre[n]-pre[i]);\\n        \\n        if(k>0 and s[i]==\\'1\\') tk = ksum+solve(i+len,s,k-1,len,pre,dp);\\n        int nottk = 0+solve(i+1,s,k,len,pre,dp);\\n        \\n        return dp[i][k]=max(tk,nottk);\\n    }\\n    int minimumWhiteTiles(string s, int numCarpets, int carpetLen) {\\n        int n = s.size();\\n        vector<int> pre(n+1,0);\\n        vector<vector<int>> dp(n+1,vector<int>(numCarpets+1,-1));\\n        for(int i=1;i<=n;i++) {\\n            pre[i]=pre[i-1];\\n            if(s[i-1]==\\'1\\') pre[i]+=1;\\n        }\\n        \\n        return pre[n]-solve(0,s,numCarpets,carpetLen,pre,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,string &s,int k,int len,vector<int> &pre,vector<vector<int>> &dp){\\n        int n = s.size();\\n        if(i>=n) return 0;\\n        \\n        if(dp[i][k]!=-1) return dp[i][k];\\n        \\n        int tk=-1e9,ksum=0;\\n        ksum=(i+len<=n)?(pre[i+len]-pre[i]):(pre[n]-pre[i]);\\n        \\n        if(k>0 and s[i]==\\'1\\') tk = ksum+solve(i+len,s,k-1,len,pre,dp);\\n        int nottk = 0+solve(i+1,s,k,len,pre,dp);\\n        \\n        return dp[i][k]=max(tk,nottk);\\n    }\\n    int minimumWhiteTiles(string s, int numCarpets, int carpetLen) {\\n        int n = s.size();\\n        vector<int> pre(n+1,0);\\n        vector<vector<int>> dp(n+1,vector<int>(numCarpets+1,-1));\\n        for(int i=1;i<=n;i++) {\\n            pre[i]=pre[i-1];\\n            if(s[i-1]==\\'1\\') pre[i]+=1;\\n        }\\n        \\n        return pre[n]-solve(0,s,numCarpets,carpetLen,pre,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763375,
                "title": "my-solution",
                "content": "```\\n/**\\n * the dynamic programming solution is employed.\\n *\\n * `dp[carpets][tiles]` stands for the minimum number of while tiles\\n * when `carpets` carpets have been covered in the tile range [0, tiles),\\n * 0 inclusive, `tiles` exclusive.\\n * where `carpets` is in the range [0, `numCarpets`], both inclusive\\n *       `tiles` is in the range [0, `floor.size()`], both inclusive\\n *\\n * initial:\\n * if `carpets` == 0\\n * 1. if tiles == 0,\\n *    dp[carpets][tiles] = 0\\n * 2. if tiles > 0,\\n *    dp[carpets][tiles] = dp[carpets][tiles - 1] + (floor[tiles - 1] == \\'1\\' ? 1 : 0)\\n *\\n * induction:\\n * 1. if tiles == 0\\n *    dp[carpets][tiles] = 0\\n * 2. otherwise\\n * 2.1. let `covered` stand for the minimum number of while tiles\\n *      if the `tiles - 1`\\'th tile is covered by a carpet\\n *      covered = dp[carpets - 1][max(0, tiles - carpetLen)]\\n * 2.2. let `uncovered` stand for the minimum number of while tiles\\n *      if the `tiles - 1`\\'th tile is not covered by a carpet,\\n *      uncovered = dp[carpets][tiles - 1] + (floor[tiles - 1] == \\'1\\' ? 1 : 0)\\n * dp[carpets][tiles] = min(covered, uncovered)\\n *\\n * target:\\n * dp[numCarpets][floor.size()]\\n *\\n * Time Complexity: O(numCarpets * n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `floor`\\n */\\nclass Solution {\\n public:\\n  int minimumWhiteTiles(const string &floor, const int numCarpets, const int carpetLen) {\\n    constexpr int range = 2;\\n    constexpr char white = \\'1\\';\\n    const int n = static_cast<int>(floor.size());\\n    int dp[range][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    for (int tiles = 1; tiles < n + 1; ++tiles) {\\n      dp[previous][tiles] = dp[previous][tiles - 1] + (floor[tiles - 1] == white ? 1 : 0);\\n    }\\n    \\n    for (int carpets = 1; carpets < numCarpets + 1; ++carpets) {\\n      for (int tiles = 1; tiles < n + 1; ++tiles) {\\n        const int covered = dp[previous][max(0, tiles - carpetLen)];\\n        const int uncovered = dp[current][tiles - 1] + (floor[tiles - 1] == white ? 1 : 0);\\n        dp[current][tiles] = min(covered, uncovered);\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], 0, sizeof(dp[current]));\\n    }\\n    \\n    return dp[previous][n];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * the dynamic programming solution is employed.\\n *\\n * `dp[carpets][tiles]` stands for the minimum number of while tiles\\n * when `carpets` carpets have been covered in the tile range [0, tiles),\\n * 0 inclusive, `tiles` exclusive.\\n * where `carpets` is in the range [0, `numCarpets`], both inclusive\\n *       `tiles` is in the range [0, `floor.size()`], both inclusive\\n *\\n * initial:\\n * if `carpets` == 0\\n * 1. if tiles == 0,\\n *    dp[carpets][tiles] = 0\\n * 2. if tiles > 0,\\n *    dp[carpets][tiles] = dp[carpets][tiles - 1] + (floor[tiles - 1] == \\'1\\' ? 1 : 0)\\n *\\n * induction:\\n * 1. if tiles == 0\\n *    dp[carpets][tiles] = 0\\n * 2. otherwise\\n * 2.1. let `covered` stand for the minimum number of while tiles\\n *      if the `tiles - 1`\\'th tile is covered by a carpet\\n *      covered = dp[carpets - 1][max(0, tiles - carpetLen)]\\n * 2.2. let `uncovered` stand for the minimum number of while tiles\\n *      if the `tiles - 1`\\'th tile is not covered by a carpet,\\n *      uncovered = dp[carpets][tiles - 1] + (floor[tiles - 1] == \\'1\\' ? 1 : 0)\\n * dp[carpets][tiles] = min(covered, uncovered)\\n *\\n * target:\\n * dp[numCarpets][floor.size()]\\n *\\n * Time Complexity: O(numCarpets * n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `floor`\\n */\\nclass Solution {\\n public:\\n  int minimumWhiteTiles(const string &floor, const int numCarpets, const int carpetLen) {\\n    constexpr int range = 2;\\n    constexpr char white = \\'1\\';\\n    const int n = static_cast<int>(floor.size());\\n    int dp[range][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    for (int tiles = 1; tiles < n + 1; ++tiles) {\\n      dp[previous][tiles] = dp[previous][tiles - 1] + (floor[tiles - 1] == white ? 1 : 0);\\n    }\\n    \\n    for (int carpets = 1; carpets < numCarpets + 1; ++carpets) {\\n      for (int tiles = 1; tiles < n + 1; ++tiles) {\\n        const int covered = dp[previous][max(0, tiles - carpetLen)];\\n        const int uncovered = dp[current][tiles - 1] + (floor[tiles - 1] == white ? 1 : 0);\\n        dp[current][tiles] = min(covered, uncovered);\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], 0, sizeof(dp[current]));\\n    }\\n    \\n    return dp[previous][n];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729027,
                "title": "c-java-memoization-commented",
                "content": "## Code\\n```C++ []\\nclass Solution {\\npublic:\\n\\n    #define WHITE \\'1\\'\\n    \\n    vector<vector<int>> dp;\\n    int n, c;\\n    \\n    int solve(string &floor, int ind, int rem){\\n\\n        // Reached end - No white tiles visible\\n        if(ind >= n) return 0;\\n\\n        // Checking cache\\n        if(dp[ind][rem] != -1) return dp[ind][rem];\\n\\n        int res = 1e8;\\n\\n        // We have 2 options -> Cover this tile or don\\'t\\n        \\n        // Don\\'t cover this tile \\n        // If its a white tile, one white tile is visible already\\n        res = (floor[ind] == WHITE) + solve(floor, ind + 1, rem);\\n        \\n        // Cover this tile if its a white tile and carpets are still remaining\\n        if(floor[ind] == WHITE and rem) res = min(res, solve(floor, ind + c, rem - 1));\\n        \\n        // Caching\\n        return dp[ind][rem] = res;\\n        \\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        n = floor.length(), c = carpetLen;\\n\\n        // 2D DP {index, carpetsRemaining}\\n        dp = vector<vector<int>> (n + 1, vector<int> (numCarpets + 1, -1));\\n\\n        return solve(floor, 0, numCarpets);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n\\n    private static final char WHITE = \\'1\\';\\n    private int[][] dp;\\n    private int n, c;\\n\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        n = floor.length();\\n        c = carpetLen;\\n\\n        // 2D DP {index, carpetsRemaining}\\n        dp = new int[n + 1][numCarpets + 1];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n\\n        return solve(floor, 0, numCarpets);\\n    }\\n\\n    private int solve(String floor, int ind, int rem) {\\n        // Reached end - No white tiles visible\\n        if (ind >= n) {\\n            return 0;\\n        }\\n\\n        // Checking cache\\n        if (dp[ind][rem] != -1) {\\n            return dp[ind][rem];\\n        }\\n\\n        int res = (int) 1e8;\\n\\n        // We have 2 options -> Cover this tile or don\\'t\\n\\n        // Don\\'t cover this tile\\n        // If it\\'s a white tile, one white tile is visible already\\n        res = (floor.charAt(ind) == WHITE ? 1 : 0) + solve(floor, ind + 1, rem);\\n\\n        // Cover this tile if it\\'s a white tile and carpets are still remaining\\n        if (floor.charAt(ind) == WHITE && rem > 0) {\\n            res = Math.min(res, solve(floor, ind + c, rem - 1));\\n        }\\n\\n        // Caching\\n        dp[ind][rem] = res;\\n        return res;\\n    }\\n}\\n\\n```\\n\\n## Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Memoization"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n\\n    #define WHITE \\'1\\'\\n    \\n    vector<vector<int>> dp;\\n    int n, c;\\n    \\n    int solve(string &floor, int ind, int rem){\\n\\n        // Reached end - No white tiles visible\\n        if(ind >= n) return 0;\\n\\n        // Checking cache\\n        if(dp[ind][rem] != -1) return dp[ind][rem];\\n\\n        int res = 1e8;\\n\\n        // We have 2 options -> Cover this tile or don\\'t\\n        \\n        // Don\\'t cover this tile \\n        // If its a white tile, one white tile is visible already\\n        res = (floor[ind] == WHITE) + solve(floor, ind + 1, rem);\\n        \\n        // Cover this tile if its a white tile and carpets are still remaining\\n        if(floor[ind] == WHITE and rem) res = min(res, solve(floor, ind + c, rem - 1));\\n        \\n        // Caching\\n        return dp[ind][rem] = res;\\n        \\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        n = floor.length(), c = carpetLen;\\n\\n        // 2D DP {index, carpetsRemaining}\\n        dp = vector<vector<int>> (n + 1, vector<int> (numCarpets + 1, -1));\\n\\n        return solve(floor, 0, numCarpets);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n\\n    private static final char WHITE = \\'1\\';\\n    private int[][] dp;\\n    private int n, c;\\n\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        n = floor.length();\\n        c = carpetLen;\\n\\n        // 2D DP {index, carpetsRemaining}\\n        dp = new int[n + 1][numCarpets + 1];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n\\n        return solve(floor, 0, numCarpets);\\n    }\\n\\n    private int solve(String floor, int ind, int rem) {\\n        // Reached end - No white tiles visible\\n        if (ind >= n) {\\n            return 0;\\n        }\\n\\n        // Checking cache\\n        if (dp[ind][rem] != -1) {\\n            return dp[ind][rem];\\n        }\\n\\n        int res = (int) 1e8;\\n\\n        // We have 2 options -> Cover this tile or don\\'t\\n\\n        // Don\\'t cover this tile\\n        // If it\\'s a white tile, one white tile is visible already\\n        res = (floor.charAt(ind) == WHITE ? 1 : 0) + solve(floor, ind + 1, rem);\\n\\n        // Cover this tile if it\\'s a white tile and carpets are still remaining\\n        if (floor.charAt(ind) == WHITE && rem > 0) {\\n            res = Math.min(res, solve(floor, ind + c, rem - 1));\\n        }\\n\\n        // Caching\\n        dp[ind][rem] = res;\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727529,
                "title": "c-python-dynamic-programming-solution-with-explanation",
                "content": "```dp[i][j]``` is minimum number of visible white tiles in the first ```i``` tiles ([0, i]) which are coverd by ```j``` carpets.\\nIf the tile is black, ```dp[i][j] = dp[i][j-1] + 1```.\\nIf the tile is white, we have 2 choices,\\none is using a carpet to to cover it, ```dp[i][j] = dp[i-1][j-carpetLen]```.\\nAnother is not to cover it, ```dp[i][j] = dp[i][j-1] + 1```.\\nWe select minimum choice, ```dp[i][j] = min(dp[i][j-1] + (\\'1\\' == floor[j]), dp[i-1][j-carpetLen])```.\\n\\nAt first, there is no carpet, so ```dp[0][j]``` is number of white tiles in the first ```j``` tiles.\\n\\ntc and sc are O(numCarpets * len(floor))\\n\\n### python\\n```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        size = len(floor)\\n\\t\\t\\n\\t\\t# floor are covered by carpets entirely\\n        if numCarpets * carpetLen >= size: return 0\\n\\t\\t\\n        dp  = [[0] * size for _ in range(numCarpets+1)]\\n\\t\\t\\n\\t\\t# At first, there is no carpet\\n\\t\\t# dp[0][j] is number of white tiles in the first j tiles\\n        dp[0][0] = \\'1\\' == floor[0]\\n        for i in range(1, size):\\n            dp[0][i] = dp[0][i-1] + (\\'1\\' == floor[i])\\n        \\n        for i in range(1, numCarpets+1):\\n\\t\\t\\t# there have i carpets, it can covered i * carpetLen tiles, \\n\\t\\t\\t# so dp[i][0...i * carpetLen-1] are 0\\n\\t\\t\\t\\n            for j in range(i * carpetLen, size):\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# min(not to cover, use a carpet to cover j-th tile)\\n                dp[i][j] = min(dp[i][j-1] + (\\'1\\' == floor[j]), dp[i-1][j-carpetLen])\\n        return dp[numCarpets][-1]\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int size = floor.size();\\n        if (numCarpets * carpetLen >= size) return 0;\\n        vector<vector<int>> dp (numCarpets+1, vector<int>(size));\\n        dp[0][0] = (\\'1\\' == floor[0]);\\n        for (int i = 1; i < size; i+=1) \\n            dp[0][i] = dp[0][i-1] + (\\'1\\' == floor[i]); \\n        for (int i = 1; i <= numCarpets; i+=1) {\\n            for (int j = i * carpetLen; j < size; j+=1) {\\n                dp[i][j] = min(dp[i][j-1] + (\\'1\\' == floor[j]), dp[i-1][j-carpetLen]); \\n            }\\n        }\\n        return dp[numCarpets][size-1];\\n    }\\n};\\n```\\n### space optimization\\nuse scrolling array.\\n### python\\n```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        size = len(floor)\\n        if numCarpets * carpetLen >= size: return 0\\n        dp  = [0] * size\\n        dp[0] = \\'1\\' == floor[0]\\n        for i in range(1, size):\\n            dp[i] = dp[i-1] + (\\'1\\' == floor[i])\\n        for i in range(1, numCarpets+1):\\n            tmp = dp[:] # dp[i-1][j-carpetLen]\\n            dp[i * carpetLen - 1] = 0 # notice that dp[j-1]\\n            for j in range(i * carpetLen, size):\\n                dp[j] = min(dp[j-1] + (\\'1\\' == floor[j]), tmp[j-carpetLen])\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```dp[i][j]```\n```i```\n```j```\n```dp[i][j] = dp[i][j-1] + 1```\n```dp[i][j] = dp[i-1][j-carpetLen]```\n```dp[i][j] = dp[i][j-1] + 1```\n```dp[i][j] = min(dp[i][j-1] + (\\'1\\' == floor[j]), dp[i-1][j-carpetLen])```\n```dp[0][j]```\n```j```\n```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        size = len(floor)\\n\\t\\t\\n\\t\\t# floor are covered by carpets entirely\\n        if numCarpets * carpetLen >= size: return 0\\n\\t\\t\\n        dp  = [[0] * size for _ in range(numCarpets+1)]\\n\\t\\t\\n\\t\\t# At first, there is no carpet\\n\\t\\t# dp[0][j] is number of white tiles in the first j tiles\\n        dp[0][0] = \\'1\\' == floor[0]\\n        for i in range(1, size):\\n            dp[0][i] = dp[0][i-1] + (\\'1\\' == floor[i])\\n        \\n        for i in range(1, numCarpets+1):\\n\\t\\t\\t# there have i carpets, it can covered i * carpetLen tiles, \\n\\t\\t\\t# so dp[i][0...i * carpetLen-1] are 0\\n\\t\\t\\t\\n            for j in range(i * carpetLen, size):\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# min(not to cover, use a carpet to cover j-th tile)\\n                dp[i][j] = min(dp[i][j-1] + (\\'1\\' == floor[j]), dp[i-1][j-carpetLen])\\n        return dp[numCarpets][-1]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int size = floor.size();\\n        if (numCarpets * carpetLen >= size) return 0;\\n        vector<vector<int>> dp (numCarpets+1, vector<int>(size));\\n        dp[0][0] = (\\'1\\' == floor[0]);\\n        for (int i = 1; i < size; i+=1) \\n            dp[0][i] = dp[0][i-1] + (\\'1\\' == floor[i]); \\n        for (int i = 1; i <= numCarpets; i+=1) {\\n            for (int j = i * carpetLen; j < size; j+=1) {\\n                dp[i][j] = min(dp[i][j-1] + (\\'1\\' == floor[j]), dp[i-1][j-carpetLen]); \\n            }\\n        }\\n        return dp[numCarpets][size-1];\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        size = len(floor)\\n        if numCarpets * carpetLen >= size: return 0\\n        dp  = [0] * size\\n        dp[0] = \\'1\\' == floor[0]\\n        for i in range(1, size):\\n            dp[i] = dp[i-1] + (\\'1\\' == floor[i])\\n        for i in range(1, numCarpets+1):\\n            tmp = dp[:] # dp[i-1][j-carpetLen]\\n            dp[i * carpetLen - 1] = 0 # notice that dp[j-1]\\n            for j in range(i * carpetLen, size):\\n                dp[j] = min(dp[j-1] + (\\'1\\' == floor[j]), tmp[j-carpetLen])\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697042,
                "title": "easy-to-understand-c-recursive-memoization-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDynamic Programming take and not take simple intuition.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSolved using Dynamic Programming approach.\\nThere are 3 case , starting from the first tile \\n1. Black tile : skip and move to next tile\\n2. White tile not Take : skip and move to next tile\\n3. White tile take : use the carpet to cover and move to (curr tile + carpetLen - 1 )th tile\\nthen take the max of all.\\nWe are taking max because we have to find min uncovered tile, so max covered tile. \\n\\n# Complexity\\n- Time complexity:\\nO(floor.length() * numCarpets)\\n\\n- Space complexity:\\nO(floor.length() * numCarpets)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int f(int i, int num, int &len, vector<int> &prefix_floor, string &floor,int &n,vector<vector<int>> &dp){\\n        if(i>=n || num==0) return 0;\\n        if(dp[i][num]!=-1) return dp[i][num];\\n        if(floor[i]==\\'0\\') return dp[i][num] = f(i+1,num,len,prefix_floor,floor,n,dp);\\n        int notTake =  f(i+1,num,len,prefix_floor,floor,n,dp);\\n        int bnd = min(i+len-1,n-1);\\n        int white = prefix_floor[bnd];\\n        if(i!=0) white = white - prefix_floor[i-1];\\n        int take = white + f(i+len,num-1,len,prefix_floor,floor,n,dp);\\n        return dp[i][num] = max(take,notTake);\\n    }\\n\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        vector<int> prefix_floor;\\n        int count = 0;\\n        if(floor[0]==\\'1\\'){\\n            prefix_floor.push_back(1);\\n            count++;\\n        }\\n        else prefix_floor.push_back(1);\\n        for(int i=1; i<n; i++){\\n            if(floor[i]==\\'1\\'){\\n                prefix_floor.push_back(1 + prefix_floor[i-1]);\\n                count++;\\n            }\\n            else{\\n                prefix_floor.push_back(prefix_floor[i-1]);\\n            }\\n        }\\n        vector<vector<int>> dp(n,vector<int>(numCarpets+1,-1));\\n        return count-f(0,numCarpets,carpetLen,prefix_floor,floor,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int f(int i, int num, int &len, vector<int> &prefix_floor, string &floor,int &n,vector<vector<int>> &dp){\\n        if(i>=n || num==0) return 0;\\n        if(dp[i][num]!=-1) return dp[i][num];\\n        if(floor[i]==\\'0\\') return dp[i][num] = f(i+1,num,len,prefix_floor,floor,n,dp);\\n        int notTake =  f(i+1,num,len,prefix_floor,floor,n,dp);\\n        int bnd = min(i+len-1,n-1);\\n        int white = prefix_floor[bnd];\\n        if(i!=0) white = white - prefix_floor[i-1];\\n        int take = white + f(i+len,num-1,len,prefix_floor,floor,n,dp);\\n        return dp[i][num] = max(take,notTake);\\n    }\\n\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        vector<int> prefix_floor;\\n        int count = 0;\\n        if(floor[0]==\\'1\\'){\\n            prefix_floor.push_back(1);\\n            count++;\\n        }\\n        else prefix_floor.push_back(1);\\n        for(int i=1; i<n; i++){\\n            if(floor[i]==\\'1\\'){\\n                prefix_floor.push_back(1 + prefix_floor[i-1]);\\n                count++;\\n            }\\n            else{\\n                prefix_floor.push_back(prefix_floor[i-1]);\\n            }\\n        }\\n        vector<vector<int>> dp(n,vector<int>(numCarpets+1,-1));\\n        return count-f(0,numCarpets,carpetLen,prefix_floor,floor,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560127,
                "title": "python-readable-and-easy-understand-dp-solution-commented-86-faster",
                "content": "# Intuition\\nIf the tile is white, put there a carpet or not.\\n\\n# Complexity\\n- Time complexity: O(n*numCarpets)\\n\\n- Space complexity: O(n*numCarpets)\\n\\n# Code\\n```\\nclass Solution(object):\\n    \\n    def minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n        dp = [[0]*(numCarpets+1) for i in range(len(floor))]\\n\\n        for i in range(len(floor)):\\n            for j in range(numCarpets+1):\\n                if j == 0:              # no carpets\\n                    dp[i][j] = floor.count(\\'1\\', 0, i+1)\\n                elif floor[i] == \\'0\\':   # black tail\\n                    dp[i][j] = dp[i-1][j]\\n                elif carpetLen > i:     # the carpet is longer than the tails\\n                    dp[i][j] = 0\\n                else:                   # put a carpet or leave it visible\\n                    dp[i][j] = min(dp[i-1][j] + 1,\\n                                   dp[i-carpetLen][j-1])\\n        \\n        return dp[len(floor)-1][numCarpets]\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    \\n    def minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n        dp = [[0]*(numCarpets+1) for i in range(len(floor))]\\n\\n        for i in range(len(floor)):\\n            for j in range(numCarpets+1):\\n                if j == 0:              # no carpets\\n                    dp[i][j] = floor.count(\\'1\\', 0, i+1)\\n                elif floor[i] == \\'0\\':   # black tail\\n                    dp[i][j] = dp[i-1][j]\\n                elif carpetLen > i:     # the carpet is longer than the tails\\n                    dp[i][j] = 0\\n                else:                   # put a carpet or leave it visible\\n                    dp[i][j] = min(dp[i-1][j] + 1,\\n                                   dp[i-carpetLen][j-1])\\n        \\n        return dp[len(floor)-1][numCarpets]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544325,
                "title": "python3-clean-and-concise-dp",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, nc: int, cl: int) -> int:\\n        \\n        n=len(floor)\\n        total=sum(int(ch) for ch in floor)\\n        \\n        @cache\\n        def f(ind,count):\\n            if ind<0 or count==0:\\n                return 0\\n            \\n            ans=floor[max(0,ind-cl+1):ind+1].count(\"1\") + f(ind-cl,count-1)\\n            ans=max(ans,f(ind-1,count))\\n            \\n            return ans\\n        \\n        return total-f(n-1,nc)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, nc: int, cl: int) -> int:\\n        \\n        n=len(floor)\\n        total=sum(int(ch) for ch in floor)\\n        \\n        @cache\\n        def f(ind,count):\\n            if ind<0 or count==0:\\n                return 0\\n            \\n            ans=floor[max(0,ind-cl+1):ind+1].count(\"1\") + f(ind-cl,count-1)\\n            ans=max(ans,f(ind-1,count))\\n            \\n            return ans\\n        \\n        return total-f(n-1,nc)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542793,
                "title": "python-simple-dp-solution-with-simple-explanation-in-comments",
                "content": "\\n- Space complexity:\\nO(n^2) time and space\\n# Code\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        # first thought is dp[i][j] = min white covering floor[i:] with j carpets of carpetLen\\n        # dp[i-1][j] = dp[i][j] if floor[i-1] is black\\n        # if floor[i-1] is white, then either we can cover it with a carpet or not\\n            # either its dp[i][j]+1 (an extra white that is uncovered) or\\n            # dp[i+carpetLen][j-1] whichever is smaller. \\n         \\n        # last row will be covering nothing on the floor with j carpets, so all 0\\n        # first column will be covering floor[i:] with 0 carpets\\n        dp = []\\n        for i in range(len(floor)): dp.append([1000]*(numCarpets+1))\\n        dp.append([0]*(numCarpets+1))\\n        for i in range(len(floor)-1, -1, -1): \\n            for j in range(numCarpets, -1, -1):\\n                if floor[i] == \"0\": #black\\n                    dp[i][j] = dp[i+1][j]\\n                else: #white\\n                    uncover = dp[i+1][j] +1\\n                    upper_bound = min(i+carpetLen, len(floor)) \\n                    cover = 9999\\n                    if j-1>=0:\\n                        cover = dp[upper_bound][j-1]\\n                    dp[i][j] = min(uncover, cover)\\n        return dp[0][numCarpets]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        # first thought is dp[i][j] = min white covering floor[i:] with j carpets of carpetLen\\n        # dp[i-1][j] = dp[i][j] if floor[i-1] is black\\n        # if floor[i-1] is white, then either we can cover it with a carpet or not\\n            # either its dp[i][j]+1 (an extra white that is uncovered) or\\n            # dp[i+carpetLen][j-1] whichever is smaller. \\n         \\n        # last row will be covering nothing on the floor with j carpets, so all 0\\n        # first column will be covering floor[i:] with 0 carpets\\n        dp = []\\n        for i in range(len(floor)): dp.append([1000]*(numCarpets+1))\\n        dp.append([0]*(numCarpets+1))\\n        for i in range(len(floor)-1, -1, -1): \\n            for j in range(numCarpets, -1, -1):\\n                if floor[i] == \"0\": #black\\n                    dp[i][j] = dp[i+1][j]\\n                else: #white\\n                    uncover = dp[i+1][j] +1\\n                    upper_bound = min(i+carpetLen, len(floor)) \\n                    cover = 9999\\n                    if j-1>=0:\\n                        cover = dp[upper_bound][j-1]\\n                    dp[i][j] = min(uncover, cover)\\n        return dp[0][numCarpets]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534474,
                "title": "dp-recursion-memoisation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(string &floor, int numCarpets, int carpetLen,int index,vector<vector<int>>&dp )\\n    {\\n        int n =floor.size();\\n        if(index>=n)return 0;\\n        if(dp[index][numCarpets]!=-1)return dp[index][numCarpets];\\n        int o1=INT_MAX;\\n        int o2=INT_MAX;\\n        if(floor[index]==\\'1\\')\\n        {\\n            o1=1+dfs(floor,numCarpets,carpetLen,index+1,dp);\\n            if(numCarpets>0)\\n            {\\n                o2=dfs(floor,numCarpets-1,carpetLen,index+carpetLen,dp);\\n            }\\n        }\\n        else\\n        {\\n           return dp[index][numCarpets]=dfs(floor,numCarpets,carpetLen,index+1,dp); \\n        }\\n        return dp[index][numCarpets]=min(o1,o2);\\n\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>>dp(floor.size()+1,vector<int>(numCarpets+1,-1));\\n        return dfs(floor,numCarpets,carpetLen,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(string &floor, int numCarpets, int carpetLen,int index,vector<vector<int>>&dp )\\n    {\\n        int n =floor.size();\\n        if(index>=n)return 0;\\n        if(dp[index][numCarpets]!=-1)return dp[index][numCarpets];\\n        int o1=INT_MAX;\\n        int o2=INT_MAX;\\n        if(floor[index]==\\'1\\')\\n        {\\n            o1=1+dfs(floor,numCarpets,carpetLen,index+1,dp);\\n            if(numCarpets>0)\\n            {\\n                o2=dfs(floor,numCarpets-1,carpetLen,index+carpetLen,dp);\\n            }\\n        }\\n        else\\n        {\\n           return dp[index][numCarpets]=dfs(floor,numCarpets,carpetLen,index+1,dp); \\n        }\\n        return dp[index][numCarpets]=min(o1,o2);\\n\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>>dp(floor.size()+1,vector<int>(numCarpets+1,-1));\\n        return dfs(floor,numCarpets,carpetLen,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528393,
                "title": "ruby-100",
                "content": "\\n# Code\\n```\\ndef minimum_white_tiles(floor, num_carpets, carpet_len)\\n  n = floor.length\\n  return 0 if carpet_len * num_carpets >= n\\n\\n  floor_list = floor.chars.map { |c| c == \\'1\\' ? 1 : 0 }\\n  dp = Array.new(num_carpets) { Array.new(n, 0) }\\n\\n  (carpet_len...n).each do |i|\\n    dp[0][i] = [floor_list[i] + dp[0][i - 1], floor_list[0..(i - carpet_len)].sum].min\\n  end\\n\\n  (1...num_carpets).each do |j|\\n    (carpet_len * j...n).each do |i|\\n      dp[j][i] = [floor_list[i] + dp[j][i - 1], dp[j - 1][i - carpet_len]].min\\n    end\\n  end\\n\\n  dp[-1][-1]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef minimum_white_tiles(floor, num_carpets, carpet_len)\\n  n = floor.length\\n  return 0 if carpet_len * num_carpets >= n\\n\\n  floor_list = floor.chars.map { |c| c == \\'1\\' ? 1 : 0 }\\n  dp = Array.new(num_carpets) { Array.new(n, 0) }\\n\\n  (carpet_len...n).each do |i|\\n    dp[0][i] = [floor_list[i] + dp[0][i - 1], floor_list[0..(i - carpet_len)].sum].min\\n  end\\n\\n  (1...num_carpets).each do |j|\\n    (carpet_len * j...n).each do |i|\\n      dp[j][i] = [floor_list[i] + dp[j][i - 1], dp[j - 1][i - carpet_len]].min\\n    end\\n  end\\n\\n  dp[-1][-1]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3484473,
                "title": "c-dynamic-programming-pick-not-pick",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int fun(string &floor, int i){\\n        int count = 0;\\n        for(int j=i;j<floor.size();j++)\\n            count += floor[j] == \\'1\\';\\n        return count;\\n    }\\n    \\n    \\n    int solve(string &floor, int num, int len, int i, vector<vector<int>> &dp){\\n        if(i >= floor.size())\\n            return 0;\\n        if(num == 0)\\n            return fun(floor,i);\\n        if(dp[i][num] != -1)\\n            return dp[i][num];\\n        int take = solve(floor,num-1,len,i+len,dp);\\n        int nottake = solve(floor,num,len,i+1,dp);\\n        if(floor[i] == \\'1\\')\\n            nottake++;\\n        return dp[i][num] = min(take,nottake);\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>> dp(floor.size()+1,vector<int> (numCarpets+1,-1));\\n        return solve(floor,numCarpets,carpetLen,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(string &floor, int i){\\n        int count = 0;\\n        for(int j=i;j<floor.size();j++)\\n            count += floor[j] == \\'1\\';\\n        return count;\\n    }\\n    \\n    \\n    int solve(string &floor, int num, int len, int i, vector<vector<int>> &dp){\\n        if(i >= floor.size())\\n            return 0;\\n        if(num == 0)\\n            return fun(floor,i);\\n        if(dp[i][num] != -1)\\n            return dp[i][num];\\n        int take = solve(floor,num-1,len,i+len,dp);\\n        int nottake = solve(floor,num,len,i+1,dp);\\n        if(floor[i] == \\'1\\')\\n            nottake++;\\n        return dp[i][num] = min(take,nottake);\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>> dp(floor.size()+1,vector<int> (numCarpets+1,-1));\\n        return solve(floor,numCarpets,carpetLen,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407430,
                "title": "simple-memoization-based-solution",
                "content": "# Approach\\nThree choices\\n1. Use carpet if available and necessary. In this can case jump to index + carpet length\\n2. Do not use carpet even if available and necessary. Increase count by 1 and move to next index. Here we save carpt to be used later. \\n3. Handle scenarios like no carpet available or carpet not necessary because tile is lready black. \\n\\n\\n# Complexity\\n- Time complexity: $$O(floorLength * numberOfCarpets)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(floorLength * numberOfCarpets)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int[][] memo = new int[floor.length()][numCarpets+1];\\n        for(int[] arr : memo) {\\n            Arrays.fill(arr, -1);\\n        }\\n        return solve(floor, numCarpets, carpetLen, 0, memo);\\n    }\\n\\n    int solve(String floor, int numCarpets, int carpetLen, int index, int[][] memo) {\\n        if(index >= floor.length()) {\\n            return 0;\\n        }\\n        if(memo[index][numCarpets] != -1) {\\n            return memo[index][numCarpets];\\n        }\\n        if(numCarpets > 0) {\\n            if(floor.charAt(index) == \\'0\\') {\\n                return memo[index][numCarpets] = solve(floor, numCarpets, carpetLen, index+1, memo);\\n            }\\n            else {\\n                int coveredWhite = solve(floor, numCarpets-1, carpetLen, index+carpetLen, memo);\\n                int unCoveredWhite = 1 + solve(floor, numCarpets, carpetLen, index+1, memo);\\n                return memo[index][numCarpets] = Math.min(coveredWhite, unCoveredWhite);\\n            }\\n        }\\n        else {\\n            int count = 0;\\n            for(int i = index; i < floor.length(); i++) {\\n                count = floor.charAt(i) == \\'1\\' ? count + 1 : count;\\n            }\\n            return memo[index][numCarpets] = count;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int[][] memo = new int[floor.length()][numCarpets+1];\\n        for(int[] arr : memo) {\\n            Arrays.fill(arr, -1);\\n        }\\n        return solve(floor, numCarpets, carpetLen, 0, memo);\\n    }\\n\\n    int solve(String floor, int numCarpets, int carpetLen, int index, int[][] memo) {\\n        if(index >= floor.length()) {\\n            return 0;\\n        }\\n        if(memo[index][numCarpets] != -1) {\\n            return memo[index][numCarpets];\\n        }\\n        if(numCarpets > 0) {\\n            if(floor.charAt(index) == \\'0\\') {\\n                return memo[index][numCarpets] = solve(floor, numCarpets, carpetLen, index+1, memo);\\n            }\\n            else {\\n                int coveredWhite = solve(floor, numCarpets-1, carpetLen, index+carpetLen, memo);\\n                int unCoveredWhite = 1 + solve(floor, numCarpets, carpetLen, index+1, memo);\\n                return memo[index][numCarpets] = Math.min(coveredWhite, unCoveredWhite);\\n            }\\n        }\\n        else {\\n            int count = 0;\\n            for(int i = index; i < floor.length(); i++) {\\n                count = floor.charAt(i) == \\'1\\' ? count + 1 : count;\\n            }\\n            return memo[index][numCarpets] = count;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356674,
                "title": "c-golang-dp",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        vector<vector<int>> DP(2, vector<int>(n + carpetLen));\\n        for(int i = n - 1; i >= 0; i--) DP[0][i] += DP[0][i + 1] + floor[i] - \\'0\\';\\n        for(int i = 0; i < numCarpets; i++) {\\n            for(int j = n - 1; j >= 0; j--) {\\n                DP[(i + 1) % 2][j] = min(DP[i % 2][j + carpetLen], DP[(i + 1) % 2][j + 1] + (floor[j] - \\'0\\')); \\n            }\\n        }\\n        return DP[numCarpets % 2][0];\\n    }\\n};\\n\\n\\n// Golang\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n    var n int = len(floor)\\n    DP := make([][]int, 2)\\n    DP[0] = make([]int, n + carpetLen)\\n    DP[1] = make([]int, n + carpetLen)\\n    for i := n - 1; i >= 0; i-- {\\n        DP[0][i] += DP[0][i + 1] + int(floor[i] - \\'0\\')\\n    } \\n    for i := 0; i < numCarpets; i++ {\\n        for j := n - 1; j >= 0; j-- {\\n            DP[(i + 1) % 2][j] = DP[(i + 1) % 2][j + 1] + int(floor[j] - \\'0\\')\\n            if DP[i % 2][j + carpetLen] < DP[(i + 1) % 2][j] {\\n                DP[(i + 1) % 2][j] = DP[i % 2][j + carpetLen]\\n            }\\n        }\\n    }\\n    return DP[numCarpets % 2][0]\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        vector<vector<int>> DP(2, vector<int>(n + carpetLen));\\n        for(int i = n - 1; i >= 0; i--) DP[0][i] += DP[0][i + 1] + floor[i] - \\'0\\';\\n        for(int i = 0; i < numCarpets; i++) {\\n            for(int j = n - 1; j >= 0; j--) {\\n                DP[(i + 1) % 2][j] = min(DP[i % 2][j + carpetLen], DP[(i + 1) % 2][j + 1] + (floor[j] - \\'0\\')); \\n            }\\n        }\\n        return DP[numCarpets % 2][0];\\n    }\\n};\\n\\n\\n// Golang\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n    var n int = len(floor)\\n    DP := make([][]int, 2)\\n    DP[0] = make([]int, n + carpetLen)\\n    DP[1] = make([]int, n + carpetLen)\\n    for i := n - 1; i >= 0; i-- {\\n        DP[0][i] += DP[0][i + 1] + int(floor[i] - \\'0\\')\\n    } \\n    for i := 0; i < numCarpets; i++ {\\n        for j := n - 1; j >= 0; j-- {\\n            DP[(i + 1) % 2][j] = DP[(i + 1) % 2][j + 1] + int(floor[j] - \\'0\\')\\n            if DP[i % 2][j + carpetLen] < DP[(i + 1) % 2][j] {\\n                DP[(i + 1) % 2][j] = DP[i % 2][j + carpetLen]\\n            }\\n        }\\n    }\\n    return DP[numCarpets % 2][0]\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262511,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimum_white_tiles(floor: String, num_carpets: i32, carpet_len: i32) -> i32 {\\n        let floor = floor.as_bytes();\\n        let n = floor.len();\\n        let mut dp = vec![vec![0; num_carpets as usize + 1]; n + 1];\\n        for i in 1..=n {\\n            for k in 0..=num_carpets as usize {\\n                let jump = dp[i - 1][k] + (floor[i - 1] - b\\'0\\') as i32;\\n                let cover = if k > 0 {\\n                    dp[i.saturating_sub(carpet_len as usize)][k - 1]\\n                } else {\\n                    1000\\n                };\\n                dp[i][k] = jump.min(cover);\\n            }\\n        }\\n        dp[n][num_carpets as usize]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_white_tiles(floor: String, num_carpets: i32, carpet_len: i32) -> i32 {\\n        let floor = floor.as_bytes();\\n        let n = floor.len();\\n        let mut dp = vec![vec![0; num_carpets as usize + 1]; n + 1];\\n        for i in 1..=n {\\n            for k in 0..=num_carpets as usize {\\n                let jump = dp[i - 1][k] + (floor[i - 1] - b\\'0\\') as i32;\\n                let cover = if k > 0 {\\n                    dp[i.saturating_sub(carpet_len as usize)][k - 1]\\n                } else {\\n                    1000\\n                };\\n                dp[i][k] = jump.min(cover);\\n            }\\n        }\\n        dp[n][num_carpets as usize]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3238008,
                "title": "python-memo-recursion",
                "content": "Here I collect number of covered `1` and then return the difference between the total number of `1` and number of covered, trying to minimize the coverage which in turn minimize the difference.\\n\\n```\\nimport heapq\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        \\n        memo = [[None] * numCarpets for _ in range(len(floor))]\\n        prefix = [0] * (len(floor) + 1)\\n        for i, val in enumerate(floor):\\n            prefix[i + 1] = int(val) + prefix[i]\\n        \\n        def helper(i, k):\\n            nonlocal floor, numCarpets, carpetLen, prefix, memo\\n            \\n            if i == len(floor) or k == -1:\\n                return 0\\n            if memo[i][k] is not None:\\n                return memo[i][k]\\n            \\n            right = min(i + carpetLen, len(floor))\\n            covered = prefix[right] - prefix[i] + helper(right, k - 1)\\n            not_covered = helper(i + 1, k)\\n            memo[i][k] = max(covered,  not_covered)\\n            \\n            return memo[i][k]\\n        \\n        return prefix[-1] - helper(0, numCarpets - 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        \\n        memo = [[None] * numCarpets for _ in range(len(floor))]\\n        prefix = [0] * (len(floor) + 1)\\n        for i, val in enumerate(floor):\\n            prefix[i + 1] = int(val) + prefix[i]\\n        \\n        def helper(i, k):\\n            nonlocal floor, numCarpets, carpetLen, prefix, memo\\n            \\n            if i == len(floor) or k == -1:\\n                return 0\\n            if memo[i][k] is not None:\\n                return memo[i][k]\\n            \\n            right = min(i + carpetLen, len(floor))\\n            covered = prefix[right] - prefix[i] + helper(right, k - 1)\\n            not_covered = helper(i + 1, k)\\n            memo[i][k] = max(covered,  not_covered)\\n            \\n            return memo[i][k]\\n        \\n        return prefix[-1] - helper(0, numCarpets - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214130,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n        n, k = len(floor), numCarpets\\n\\n        @lru_cache(None)\\n        def dfs(i,k):\\n            if k < 0:\\n                return float(\"inf\")\\n\\n            if i >= n:\\n                return 0\\n\\n            if floor[i] == \"1\": return min(1+dfs(i+1,k),dfs(i+carpetLen,k-1))\\n\\n            return dfs(i+1,k)\\n\\n        return dfs(0,k)\\n\\n            \\n\\n            \\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n        n, k = len(floor), numCarpets\\n\\n        @lru_cache(None)\\n        def dfs(i,k):\\n            if k < 0:\\n                return float(\"inf\")\\n\\n            if i >= n:\\n                return 0\\n\\n            if floor[i] == \"1\": return min(1+dfs(i+1,k),dfs(i+carpetLen,k-1))\\n\\n            return dfs(i+1,k)\\n\\n        return dfs(0,k)\\n\\n            \\n\\n            \\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191098,
                "title": "python-dp-how-to-avoid-tle",
                "content": "The thing I did to avoid TLE was, if you come to a point where the last carpetLen tiles are all 1s, you can \\'break\\' and greedily stop looking to place this next carpet after, as you won\\'t get a better result than if you place it here (or before here).\\n\\nThat\\'s in this line: \\'                if pres[min(N,i+carpetLen)]-pres[i] == carpetLen:\\n                    break\\'\\n\\n\\'\\'\\'\\nmemo={}\\n        floor = [int(floor[i]) for i in range(len(floor))]\\n        pres = [0]\\n        for i in floor:\\n            pres.append(pres[-1] + i)\\n        \\n            \\n        N=len(floor)\\n        \\n        def dp(ind,carpetsleft):\\n            nonlocal memo\\n            nonlocal pres\\n            nonlocal N\\n            \\n            if ind>=len(floor):\\n                return 0\\n            if (ind,carpetsleft) in memo:\\n                return memo[(ind,carpetsleft)]\\n            if carpetsleft ==0:\\n                return pres[-1] - pres[ind]\\n            \\n            cur = float(\\'inf\\')\\n            uncovered = 0\\n            for i in range(ind,N):\\n                \\n                cur = min(cur, uncovered + dp(i+carpetLen,carpetsleft-1))\\n                \\n                if pres[min(N,i+carpetLen)]-pres[i] == carpetLen:\\n                    break\\n                    \\n                uncovered += floor[i]\\n            \\n            memo[(ind,carpetsleft)] = cur\\n            return cur\\n\\n        return dp(0,numCarpets)\\n\\t\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "The thing I did to avoid TLE was, if you come to a point where the last carpetLen tiles are all 1s, you can \\'break\\' and greedily stop looking to place this next carpet after, as you won\\'t get a better result than if you place it here (or before here).\\n\\nThat\\'s in this line: \\'                if pres[min(N,i+carpetLen)]-pres[i] == carpetLen:\\n                    break\\'\\n\\n\\'\\'\\'\\nmemo={}\\n        floor = [int(floor[i]) for i in range(len(floor))]\\n        pres = [0]\\n        for i in floor:\\n            pres.append(pres[-1] + i)\\n        \\n            \\n        N=len(floor)\\n        \\n        def dp(ind,carpetsleft):\\n            nonlocal memo\\n            nonlocal pres\\n            nonlocal N\\n            \\n            if ind>=len(floor):\\n                return 0\\n            if (ind,carpetsleft) in memo:\\n                return memo[(ind,carpetsleft)]\\n            if carpetsleft ==0:\\n                return pres[-1] - pres[ind]\\n            \\n            cur = float(\\'inf\\')\\n            uncovered = 0\\n            for i in range(ind,N):\\n                \\n                cur = min(cur, uncovered + dp(i+carpetLen,carpetsleft-1))\\n                \\n                if pres[min(N,i+carpetLen)]-pres[i] == carpetLen:\\n                    break\\n                    \\n                uncovered += floor[i]\\n            \\n            memo[(ind,carpetsleft)] = cur\\n            return cur\\n\\n        return dp(0,numCarpets)\\n\\t\\t\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 3156969,
                "title": "tc-o-n-number-of-carpet",
                "content": "```\\nclass Solution\\n{\\n    public:\\n      vector<int> pre;\\n        int solve(string &floor, int pos,int num, int len,vector<vector<int>> &dp)\\n        {\\n            if(pos<0)return 0;\\n            if(num==0)return pre[pos];\\n            if(dp[pos][num]!=-1)return dp[pos][num];\\n            int ans=1e9;\\n            if(floor[pos]==\\'0\\')\\n            {\\n                ans=min(ans,solve(floor,pos-1,num,len,dp));\\n            }\\n            else\\n            {\\n                ans=min(ans,min(solve(floor,pos-len,num-1,len,dp),1+solve(floor,pos-1,num,len,dp)));\\n            }\\n            return dp[pos][num]=ans;\\n            \\n        }\\n        int minimumWhiteTiles(string floor, int num, int len)\\n        {\\n            int n=floor.size();\\n            int o=0;\\n            pre.resize(n+1,0);\\n            for(int i=0;i<n;i++)\\n            {\\n                if(floor[i]==\\'1\\')o++;\\n                pre[i]=o;\\n            }\\n            vector<vector<int>> dp(n+1,vector<int>(num+1,-1));\\n            return solve(floor,n-1,num,len,dp);\\n        }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n      vector<int> pre;\\n        int solve(string &floor, int pos,int num, int len,vector<vector<int>> &dp)\\n        {\\n            if(pos<0)return 0;\\n            if(num==0)return pre[pos];\\n            if(dp[pos][num]!=-1)return dp[pos][num];\\n            int ans=1e9;\\n            if(floor[pos]==\\'0\\')\\n            {\\n                ans=min(ans,solve(floor,pos-1,num,len,dp));\\n            }\\n            else\\n            {\\n                ans=min(ans,min(solve(floor,pos-len,num-1,len,dp),1+solve(floor,pos-1,num,len,dp)));\\n            }\\n            return dp[pos][num]=ans;\\n            \\n        }\\n        int minimumWhiteTiles(string floor, int num, int len)\\n        {\\n            int n=floor.size();\\n            int o=0;\\n            pre.resize(n+1,0);\\n            for(int i=0;i<n;i++)\\n            {\\n                if(floor[i]==\\'1\\')o++;\\n                pre[i]=o;\\n            }\\n            vector<vector<int>> dp(n+1,vector<int>(num+1,-1));\\n            return solve(floor,n-1,num,len,dp);\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148659,
                "title": "dp-python-clean",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, n: int, carpetLen: int) -> int:\\n        m = len(floor)\\n        dp = [[0 for _ in range(m)] for _ in range(n + 1)]\\n        for i in range(len(dp[0])):\\n            dp[0][i] = floor[:i + 1].count(\\'1\\')\\n        for i in range(1, n + 1):\\n            for j in range(i * carpetLen, m):\\n                dp[i][j] = min(dp[i][j - 1] + (floor[j] == \\'1\\'), dp[i - 1][j - carpetLen])\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, n: int, carpetLen: int) -> int:\\n        m = len(floor)\\n        dp = [[0 for _ in range(m)] for _ in range(n + 1)]\\n        for i in range(len(dp[0])):\\n            dp[0][i] = floor[:i + 1].count(\\'1\\')\\n        for i in range(1, n + 1):\\n            for j in range(i * carpetLen, m):\\n                dp[i][j] = min(dp[i][j - 1] + (floor[j] == \\'1\\'), dp[i - 1][j - carpetLen])\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086449,
                "title": "scala-top-down-dp",
                "content": "```scala\\nimport scala.collection.mutable.HashMap\\nobject Solution {\\n    def minimumWhiteTiles(floor: String, numCarpets: Int, carpetLen: Int): Int = {\\n        def mem[I, O](f: I => O) = new HashMap[I, O]() {\\n            override def apply(key: I) = getOrElseUpdate(key, f(key))\\n        }\\n        \\n        lazy val dp: ((Int, Int)) => Int = mem {\\n            case (i, _) if (i < 0) => 0\\n            case (i, 0) => floor.take(i + 1).count(_ == \\'1\\')\\n            case (i, j) => dp(i - carpetLen, j - 1) min dp(i - 1, j) + floor(i) - \\'0\\'\\n        }\\n        \\n        dp(floor.size - 1, numCarpets)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```scala\\nimport scala.collection.mutable.HashMap\\nobject Solution {\\n    def minimumWhiteTiles(floor: String, numCarpets: Int, carpetLen: Int): Int = {\\n        def mem[I, O](f: I => O) = new HashMap[I, O]() {\\n            override def apply(key: I) = getOrElseUpdate(key, f(key))\\n        }\\n        \\n        lazy val dp: ((Int, Int)) => Int = mem {\\n            case (i, _) if (i < 0) => 0\\n            case (i, 0) => floor.take(i + 1).count(_ == \\'1\\')\\n            case (i, j) => dp(i - carpetLen, j - 1) min dp(i - 1, j) + floor(i) - \\'0\\'\\n        }\\n        \\n        dp(floor.size - 1, numCarpets)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3076052,
                "title": "3-lines-prefix-sum-python-3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, nc: int, cpl: int) -> int:\\n        acc = [0] + list(accumulate(map(int, floor))) + [floor.count(\"1\")] * cpl\\n        @lru_cache(None)\\n        def dp(i, c): return 0 if c==0 or i>=len(floor) else max(dp(i+1,c), acc[i+cpl]-acc[i]+dp(i+cpl,c-1))\\n        return acc[-1] - dp(0, nc)\\n\\n\\n       \\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, nc: int, cpl: int) -> int:\\n        acc = [0] + list(accumulate(map(int, floor))) + [floor.count(\"1\")] * cpl\\n        @lru_cache(None)\\n        def dp(i, c): return 0 if c==0 or i>=len(floor) else max(dp(i+1,c), acc[i+cpl]-acc[i]+dp(i+cpl,c-1))\\n        return acc[-1] - dp(0, nc)\\n\\n\\n       \\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040120,
                "title": "easy-top-down-dp-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n//returns the min no. of white carpets ;\\n    int f(int i, int k, int kl, string &s, vector<vector<int>> & dp){\\n        //base cases\\n        if(i < 0)return 0;\\n        if(k == 0){\\n            //return all the white tiles in the string s[0...i];\\n            int ones = 0;\\n            for(int ii=0; ii<=i; ii++){\\n                ones += (s[ii]==\\'1\\');\\n            }\\n            return ones;\\n        }\\n        if(dp[i][k] != -1)return dp[i][k];\\n        int ans = INT_MAX;;\\n        //we ignore;\\n        ans = f(i-1, k, kl, s, dp) + (s[i] == \\'1\\');\\n        //we cover it;\\n        ans = min(ans, f(i-kl, k-1, kl, s, dp));\\n\\n        return dp[i][k] = ans;\\n    }\\n\\n    int minimumWhiteTiles(string s, int k, int kl) {\\n        int n = s.length();\\n        vector<vector<int>> dp(n+1,vector<int>(k+1, -1));\\n        return f(n-1, k, kl, s, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//returns the min no. of white carpets ;\\n    int f(int i, int k, int kl, string &s, vector<vector<int>> & dp){\\n        //base cases\\n        if(i < 0)return 0;\\n        if(k == 0){\\n            //return all the white tiles in the string s[0...i];\\n            int ones = 0;\\n            for(int ii=0; ii<=i; ii++){\\n                ones += (s[ii]==\\'1\\');\\n            }\\n            return ones;\\n        }\\n        if(dp[i][k] != -1)return dp[i][k];\\n        int ans = INT_MAX;;\\n        //we ignore;\\n        ans = f(i-1, k, kl, s, dp) + (s[i] == \\'1\\');\\n        //we cover it;\\n        ans = min(ans, f(i-kl, k-1, kl, s, dp));\\n\\n        return dp[i][k] = ans;\\n    }\\n\\n    int minimumWhiteTiles(string s, int k, int kl) {\\n        int n = s.length();\\n        vector<vector<int>> dp(n+1,vector<int>(k+1, -1));\\n        return f(n-1, k, kl, s, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971453,
                "title": "c-simple-recursion-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ninclude | exclude dp problems\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreate a prefix array to save the loop over carplen \\nand apply DP and recusion over the prefix array\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int solve(int idx,vector<int> &arr,int k,int n,vector<vector<int>> &dp){\\n        if(n==0 || idx>=arr.size()){\\n            return 0;\\n        }\\n\\n        if(dp[idx][n]!=-1)return dp[idx][n];\\n\\n        // use \\n        int use;\\n        if(idx==0)use=arr[idx+(k-1)] + solve(idx+k,arr,k,n-1,dp);\\n        else if(idx+k>=arr.size()) use=arr.back()-arr[idx-1] + solve(idx+k,arr,k,n-1,dp);\\n        else use = use=arr[idx+(k-1)]-arr[idx-1] + solve(idx+k,arr,k,n-1,dp);\\n\\n        // skip\\n        int skip=solve(idx+1,arr,k,n,dp);\\n\\n        return dp[idx][n]=max(use,skip);\\n\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int n, int k) {\\n        int cnt=0;\\n        vector<int> arr;\\n        int sz=floor.length();\\n        vector<vector<int>> dp(sz+1,vector<int>(n+1,-1));\\n        for(auto i:floor){\\n            if(i==\\'1\\')cnt++;\\n        arr.push_back(cnt);\\n        }\\n\\n        return cnt-solve(0,arr,k,n,dp);\\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    int solve(int idx,vector<int> &arr,int k,int n,vector<vector<int>> &dp){\\n        if(n==0 || idx>=arr.size()){\\n            return 0;\\n        }\\n\\n        if(dp[idx][n]!=-1)return dp[idx][n];\\n\\n        // use \\n        int use;\\n        if(idx==0)use=arr[idx+(k-1)] + solve(idx+k,arr,k,n-1,dp);\\n        else if(idx+k>=arr.size()) use=arr.back()-arr[idx-1] + solve(idx+k,arr,k,n-1,dp);\\n        else use = use=arr[idx+(k-1)]-arr[idx-1] + solve(idx+k,arr,k,n-1,dp);\\n\\n        // skip\\n        int skip=solve(idx+1,arr,k,n,dp);\\n\\n        return dp[idx][n]=max(use,skip);\\n\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int n, int k) {\\n        int cnt=0;\\n        vector<int> arr;\\n        int sz=floor.length();\\n        vector<vector<int>> dp(sz+1,vector<int>(n+1,-1));\\n        for(auto i:floor){\\n            if(i==\\'1\\')cnt++;\\n        arr.push_back(cnt);\\n        }\\n\\n        return cnt-solve(0,arr,k,n,dp);\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961259,
                "title": "java-o-numofcarpets-floorlength",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(numOfCarpets * floorLength)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(numOfCarpets * floorLength)\\n# Code\\n```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if(numCarpets * carpetLen >= floor.length()) return 0;\\n        int[][] dp = new int[numCarpets+1][floor.length()];\\n        dp[0][0] = floor.charAt(0) == \\'0\\' ? 0 : 1;\\n        for(int i=1;i<floor.length();i++) dp[0][i] = dp[0][i-1] + (floor.charAt(i) == \\'0\\' ? 0 : 1);\\n\\n        for(int i=1;i<=numCarpets;i++) {\\n            for(int j=carpetLen;j<floor.length();j++) {\\n                if(floor.charAt(j) == \\'0\\') {\\n                    dp[i][j] = dp[i][j-1];\\n                } else {\\n                    dp[i][j] = Math.min(1 + dp[i][j-1], dp[i-1][j-carpetLen]);\\n                }\\n            }\\n        }\\n        return dp[numCarpets][floor.length()-1];\\n    }\\n    // 1 1 2 3 3 4 4 5\\n    // 0 0 1 1 1 2 2 3\\n    // 0 0 0 0 0 1 1 2\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if(numCarpets * carpetLen >= floor.length()) return 0;\\n        int[][] dp = new int[numCarpets+1][floor.length()];\\n        dp[0][0] = floor.charAt(0) == \\'0\\' ? 0 : 1;\\n        for(int i=1;i<floor.length();i++) dp[0][i] = dp[0][i-1] + (floor.charAt(i) == \\'0\\' ? 0 : 1);\\n\\n        for(int i=1;i<=numCarpets;i++) {\\n            for(int j=carpetLen;j<floor.length();j++) {\\n                if(floor.charAt(j) == \\'0\\') {\\n                    dp[i][j] = dp[i][j-1];\\n                } else {\\n                    dp[i][j] = Math.min(1 + dp[i][j-1], dp[i-1][j-carpetLen]);\\n                }\\n            }\\n        }\\n        return dp[numCarpets][floor.length()-1];\\n    }\\n    // 1 1 2 3 3 4 4 5\\n    // 0 0 1 1 1 2 2 3\\n    // 0 0 0 0 0 1 1 2\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961258,
                "title": "java-o-numofcarpets-floorlength",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(numOfCarpets * floorLength)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(numOfCarpets * floorLength)\\n# Code\\n```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if(numCarpets * carpetLen >= floor.length()) return 0;\\n        int[][] dp = new int[numCarpets+1][floor.length()];\\n        dp[0][0] = floor.charAt(0) == \\'0\\' ? 0 : 1;\\n        for(int i=1;i<floor.length();i++) dp[0][i] = dp[0][i-1] + (floor.charAt(i) == \\'0\\' ? 0 : 1);\\n\\n        for(int i=1;i<=numCarpets;i++) {\\n            for(int j=carpetLen;j<floor.length();j++) {\\n                if(floor.charAt(j) == \\'0\\') {\\n                    dp[i][j] = dp[i][j-1];\\n                } else {\\n                    dp[i][j] = Math.min(1 + dp[i][j-1], dp[i-1][j-carpetLen]);\\n                }\\n            }\\n        }\\n        return dp[numCarpets][floor.length()-1];\\n    }\\n    // 1 1 2 3 3 4 4 5\\n    // 0 0 1 1 1 2 2 3\\n    // 0 0 0 0 0 1 1 2\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if(numCarpets * carpetLen >= floor.length()) return 0;\\n        int[][] dp = new int[numCarpets+1][floor.length()];\\n        dp[0][0] = floor.charAt(0) == \\'0\\' ? 0 : 1;\\n        for(int i=1;i<floor.length();i++) dp[0][i] = dp[0][i-1] + (floor.charAt(i) == \\'0\\' ? 0 : 1);\\n\\n        for(int i=1;i<=numCarpets;i++) {\\n            for(int j=carpetLen;j<floor.length();j++) {\\n                if(floor.charAt(j) == \\'0\\') {\\n                    dp[i][j] = dp[i][j-1];\\n                } else {\\n                    dp[i][j] = Math.min(1 + dp[i][j-1], dp[i-1][j-carpetLen]);\\n                }\\n            }\\n        }\\n        return dp[numCarpets][floor.length()-1];\\n    }\\n    // 1 1 2 3 3 4 4 5\\n    // 0 0 1 1 1 2 2 3\\n    // 0 0 0 0 0 1 1 2\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941866,
                "title": "c-simple-dp-fast-recursion-memoization",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &dp, string &s,int idx, int k, int len)\\n    {\\n        int n = s.size(), ans = 0;\\n        if(idx >= n)return 0;\\n        if(dp[idx][k]!=-1)return dp[idx][k];\\n        if(s[idx] == \\'0\\')\\n        {\\n            ans = max(ans, 1 + solve(dp, s,idx+1,k,len));\\n            if(k>0)ans = max(ans , min(len, n-idx) + solve(dp, s, idx+len,k-1,len));\\n        }\\n        else\\n        {\\n            ans = max(ans, solve(dp, s,idx+1,k,len));\\n            if(k>0)ans = max(ans , min(len, n-idx) + solve(dp, s, idx+len,k-1,len));\\n        }\\n        return dp[idx][k] = ans;\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen){\\n        vector<vector<int>> dp(floor.size()+1, vector<int> (numCarpets + 1, -1));\\n        int max_cnt = solve(dp, floor, 0, numCarpets, carpetLen);\\n        return floor.size()-max_cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &dp, string &s,int idx, int k, int len)\\n    {\\n        int n = s.size(), ans = 0;\\n        if(idx >= n)return 0;\\n        if(dp[idx][k]!=-1)return dp[idx][k];\\n        if(s[idx] == \\'0\\')\\n        {\\n            ans = max(ans, 1 + solve(dp, s,idx+1,k,len));\\n            if(k>0)ans = max(ans , min(len, n-idx) + solve(dp, s, idx+len,k-1,len));\\n        }\\n        else\\n        {\\n            ans = max(ans, solve(dp, s,idx+1,k,len));\\n            if(k>0)ans = max(ans , min(len, n-idx) + solve(dp, s, idx+len,k-1,len));\\n        }\\n        return dp[idx][k] = ans;\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen){\\n        vector<vector<int>> dp(floor.size()+1, vector<int> (numCarpets + 1, -1));\\n        int max_cnt = solve(dp, floor, 0, numCarpets, carpetLen);\\n        return floor.size()-max_cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927625,
                "title": "golang-dp-prefix-sum",
                "content": "```\\nfunc minimumWhiteTiles(s string, nc int, cl int) int {\\n\\tps := make([]int, 0, len(s))\\n\\tc := 0\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] == 49 {\\n\\t\\t\\tc++\\n\\t\\t}\\n\\t\\tps = append(ps, c)\\n\\t}\\n\\n\\tmem := make([][]int, len(s))\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tmem[i] = make([]int, nc+1)\\n\\t\\tfor j := 0; j < nc+1; j++ {\\n\\t\\t\\tmem[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\n\\tvar dp func(p, oc int) int\\n\\tdp = func(p, oc int) int {\\n\\t\\tif p >= len(s) {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif oc <= 0 {\\n\\t\\t\\treturn ps[len(ps)-1] - ps[p-1]\\n\\t\\t}\\n\\t\\tif mem[p][oc] != -1 {\\n\\t\\t\\treturn mem[p][oc]\\n\\t\\t}\\n\\t\\tmem[p][oc] = 0\\n\\t\\tif s[p] == 49 {\\n\\t\\t\\tmem[p][oc] += 1 + dp(p+1, oc)\\n\\t\\t} else {\\n\\t\\t\\tmem[p][oc] += dp(p+1, oc)\\n\\t\\t}\\n\\t\\tk := dp(p+cl, oc-1)\\n\\t\\tif k < mem[p][oc] {\\n\\t\\t\\tmem[p][oc] = k\\n\\t\\t}\\n\\t\\treturn mem[p][oc]\\n\\t}\\n\\treturn dp(0, nc)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minimumWhiteTiles(s string, nc int, cl int) int {\\n\\tps := make([]int, 0, len(s))\\n\\tc := 0\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] == 49 {\\n\\t\\t\\tc++\\n\\t\\t}\\n\\t\\tps = append(ps, c)\\n\\t}\\n\\n\\tmem := make([][]int, len(s))\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tmem[i] = make([]int, nc+1)\\n\\t\\tfor j := 0; j < nc+1; j++ {\\n\\t\\t\\tmem[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\n\\tvar dp func(p, oc int) int\\n\\tdp = func(p, oc int) int {\\n\\t\\tif p >= len(s) {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif oc <= 0 {\\n\\t\\t\\treturn ps[len(ps)-1] - ps[p-1]\\n\\t\\t}\\n\\t\\tif mem[p][oc] != -1 {\\n\\t\\t\\treturn mem[p][oc]\\n\\t\\t}\\n\\t\\tmem[p][oc] = 0\\n\\t\\tif s[p] == 49 {\\n\\t\\t\\tmem[p][oc] += 1 + dp(p+1, oc)\\n\\t\\t} else {\\n\\t\\t\\tmem[p][oc] += dp(p+1, oc)\\n\\t\\t}\\n\\t\\tk := dp(p+cl, oc-1)\\n\\t\\tif k < mem[p][oc] {\\n\\t\\t\\tmem[p][oc] = k\\n\\t\\t}\\n\\t\\treturn mem[p][oc]\\n\\t}\\n\\treturn dp(0, nc)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2903745,
                "title": "javascript-dynamicprogramming-time-o-floor-numcarpets",
                "content": "# Complexity\\n- Time complexity:\\n$$O(floor * numCarpets)$$\\n\\n- Space complexity:\\n$$O(floor)$$\\n\\n# Code\\n```\\nvar minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\\n    let prev = Array(floor.length + 1).fill(0);\\n\\n    for (let i = 1; i <= floor.length; i++)\\n        prev[i] = prev[i - 1] + (floor[i - 1] == \"1\");\\n\\n    for (let j = 1; j <= numCarpets; j++) {\\n        const cur = Array(floor.length + 1).fill(0);\\n\\n        for (let i = 1; i <= floor.length; i++)\\n            cur[i] = Math.min(cur[i - 1] + (floor[i - 1] == \"1\"), \\n                i >= carpetLen ? prev[i - carpetLen] : 0);\\n\\n        prev = cur;\\n    }\\n    return prev.at(-1);\\n};\\n```\\n```\\nvar minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\\n    const dp = Array.from({ length: floor.length }, \\n        () => Array(numCarpets + 1).fill(Infinity));\\n\\n    for (let i = floor.length - 1; i >= 0; i--)\\n        dp[i][0] = (i + 1 < floor.length && dp[i + 1][0]) + (floor[i] == \"1\");\\n\\n    const recursion = (index, numCarpets) => {\\n        if (index >= floor.length) return 0;\\n        if (dp[index][numCarpets] < Infinity) return dp[index][numCarpets];\\n\\n        return dp[index][numCarpets] = Math.min(\\n            (floor[index] == \"1\") + recursion(index + 1, numCarpets), \\n            recursion(index + carpetLen, numCarpets - 1)\\n        );\\n    };\\n\\n    return recursion(0, numCarpets);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\\n    let prev = Array(floor.length + 1).fill(0);\\n\\n    for (let i = 1; i <= floor.length; i++)\\n        prev[i] = prev[i - 1] + (floor[i - 1] == \"1\");\\n\\n    for (let j = 1; j <= numCarpets; j++) {\\n        const cur = Array(floor.length + 1).fill(0);\\n\\n        for (let i = 1; i <= floor.length; i++)\\n            cur[i] = Math.min(cur[i - 1] + (floor[i - 1] == \"1\"), \\n                i >= carpetLen ? prev[i - carpetLen] : 0);\\n\\n        prev = cur;\\n    }\\n    return prev.at(-1);\\n};\\n```\n```\\nvar minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\\n    const dp = Array.from({ length: floor.length }, \\n        () => Array(numCarpets + 1).fill(Infinity));\\n\\n    for (let i = floor.length - 1; i >= 0; i--)\\n        dp[i][0] = (i + 1 < floor.length && dp[i + 1][0]) + (floor[i] == \"1\");\\n\\n    const recursion = (index, numCarpets) => {\\n        if (index >= floor.length) return 0;\\n        if (dp[index][numCarpets] < Infinity) return dp[index][numCarpets];\\n\\n        return dp[index][numCarpets] = Math.min(\\n            (floor[index] == \"1\") + recursion(index + 1, numCarpets), \\n            recursion(index + carpetLen, numCarpets - 1)\\n        );\\n    };\\n\\n    return recursion(0, numCarpets);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2886735,
                "title": "dp-memoisation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n \\n    int helper(int i,string &f,int j,int cl,vector<vector<int>>&dp){\\n        if( i>=f.size() ){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        if(f[i]==\\'0\\'){\\n           return dp[i][j]= helper(i+1,f,j,cl,dp);\\n        }\\n        else{\\n            int ans=INT_MAX;\\n            ans=1+helper(i+1, f,j,cl,dp);\\n            if(j>0) ans= min(ans,helper(i+cl, f,j-1,cl,dp));\\n            return dp[i][j]=ans;\\n        }\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.size();\\n        vector<vector<int>>dp(n,vector<int>(numCarpets+1,-1));\\n        return helper(0,floor,numCarpets,carpetLen,dp);\\n    }\\n    \\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n    int helper(int i,string &f,int j,int cl,vector<vector<int>>&dp){\\n        if( i>=f.size() ){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        if(f[i]==\\'0\\'){\\n           return dp[i][j]= helper(i+1,f,j,cl,dp);\\n        }\\n        else{\\n            int ans=INT_MAX;\\n            ans=1+helper(i+1, f,j,cl,dp);\\n            if(j>0) ans= min(ans,helper(i+cl, f,j-1,cl,dp));\\n            return dp[i][j]=ans;\\n        }\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.size();\\n        vector<vector<int>>dp(n,vector<int>(numCarpets+1,-1));\\n        return helper(0,floor,numCarpets,carpetLen,dp);\\n    }\\n    \\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842581,
                "title": "python-dp-pruning-o-n-2-faster-than-94",
                "content": "<code>\\n        import sys\\n        sys.setrecursionlimit(2000000)\\n\\n        n = len(floor)\\n        pre_sums = [0] * (n + 1)\\n        for i, c in enumerate(floor):\\n            pre_sums[i + 1] = pre_sums[i] + (c == \"1\")\\n\\n        @lru_cache(maxsize=None)\\n        def dp(n, k):\\n            \"\"\"\\n            dp[n,k]: \\u524Dn\\u4E2A\\u7528k\\u4E2A\\u5730\\u6BEF\\u8986\\u76D6\\uFF0C\\u6700\\u591A\\u80FD\\u8986\\u76D6\\u591A\\u5C11\\u4E2Awhite floor(1). maximum number of white floor in floor[:n] could be coverd by k carpet\\n            dp[n,k] = max(dp[n - carpetLen][k - 1] + sum(1 in floor[n - carpetLen:n]), dp[n - 1,k])\\n            \"\"\"\\n            if k == 0 or n <= 0:\\n                return 0\\n\\n            # full cover, the most import optimization. TLE -> runtime_percentile: 94%\\n            if k >= pre_sums[n] or k * carpetLen >= n:\\n                return pre_sums[n]\\n\\n            i = max(n - carpetLen, 0)\\n            return max(\\n                dp(i, k - 1) + pre_sums[n] - pre_sums[i],\\n                dp(n - 1, k)\\n            )\\n        return pre_sums[-1] - dp(len(floor), numCarpets)\\n</code>",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "<code>\\n        import sys\\n        sys.setrecursionlimit(2000000)\\n\\n        n = len(floor)\\n        pre_sums = [0] * (n + 1)\\n        for i, c in enumerate(floor):\\n            pre_sums[i + 1] = pre_sums[i] + (c == \"1\")\\n\\n        @lru_cache(maxsize=None)\\n        def dp(n, k):\\n            \"\"\"\\n            dp[n,k]: \\u524Dn\\u4E2A\\u7528k\\u4E2A\\u5730\\u6BEF\\u8986\\u76D6\\uFF0C\\u6700\\u591A\\u80FD\\u8986\\u76D6\\u591A\\u5C11\\u4E2Awhite floor(1). maximum number of white floor in floor[:n] could be coverd by k carpet\\n            dp[n,k] = max(dp[n - carpetLen][k - 1] + sum(1 in floor[n - carpetLen:n]), dp[n - 1,k])\\n            \"\"\"\\n            if k == 0 or n <= 0:\\n                return 0\\n\\n            # full cover, the most import optimization. TLE -> runtime_percentile: 94%\\n            if k >= pre_sums[n] or k * carpetLen >= n:\\n                return pre_sums[n]\\n\\n            i = max(n - carpetLen, 0)\\n            return max(\\n                dp(i, k - 1) + pre_sums[n] - pre_sums[i],\\n                dp(n - 1, k)\\n            )\\n        return pre_sums[-1] - dp(len(floor), numCarpets)\\n</code>",
                "codeTag": "Python3"
            },
            {
                "id": 2839251,
                "title": "dp-c-coin-change-problem-variant",
                "content": "\\n\\n# Approach\\ncoin change problem\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      \\n    int minimumWhiteTiles(string floor, int num, int len) {\\n          \\n          int w=0;\\n          int n=floor.size();\\n          vector<int>v(n+1,0);\\n          vector<vector<int>>dp(num+1,vector<int>(n+1,0));\\n          for(int i=1;i<=n;i++)\\n          {\\n              if(floor[i-1]==\\'1\\')w++;\\n              v[i]=v[i-1]+(floor[i-1]==\\'1\\');\\n              \\n          }\\n                for(int i=1;i<=num;i++)\\n                {\\n                    for(int j=1;j<=n;j++)\\n                    {\\n                        if(j<len)\\n                        {\\n                            dp[i][j]=v[j];\\n                            continue;\\n                        }\\n                    int use=v[j]-v[j-len]+dp[i-1][j-len];\\n                          \\n                    int not_use=dp[i][j-1];\\n                       dp[i][j]=max(use,not_use);\\n                    }\\n                }\\n           int maxi=0;\\n      \\n           for(int i=1;i<=n;i++)\\n           {\\n               maxi=max(maxi,dp[num][i]);\\n             \\n           }\\n    \\n           return w-maxi;\\n          \\n         //return max(0,w-rec(Len-1,floor,num,Len,v,dp));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      \\n    int minimumWhiteTiles(string floor, int num, int len) {\\n          \\n          int w=0;\\n          int n=floor.size();\\n          vector<int>v(n+1,0);\\n          vector<vector<int>>dp(num+1,vector<int>(n+1,0));\\n          for(int i=1;i<=n;i++)\\n          {\\n              if(floor[i-1]==\\'1\\')w++;\\n              v[i]=v[i-1]+(floor[i-1]==\\'1\\');\\n              \\n          }\\n                for(int i=1;i<=num;i++)\\n                {\\n                    for(int j=1;j<=n;j++)\\n                    {\\n                        if(j<len)\\n                        {\\n                            dp[i][j]=v[j];\\n                            continue;\\n                        }\\n                    int use=v[j]-v[j-len]+dp[i-1][j-len];\\n                          \\n                    int not_use=dp[i][j-1];\\n                       dp[i][j]=max(use,not_use);\\n                    }\\n                }\\n           int maxi=0;\\n      \\n           for(int i=1;i<=n;i++)\\n           {\\n               maxi=max(maxi,dp[num][i]);\\n             \\n           }\\n    \\n           return w-maxi;\\n          \\n         //return max(0,w-rec(Len-1,floor,num,Len,v,dp));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797559,
                "title": "c-easy-understanding-dynamic-programming",
                "content": "```\\nclass Solution {\\n    int dp[1001][1001];\\n    vector<int> suffix;\\n    int utilfunc(int i,int j,string &floor,int len)\\n    {\\n        if(i >= floor.length())\\n        {\\n            return 0;\\n        }\\n        \\n        if(j == 0)\\n        {\\n            return suffix[i];\\n        }\\n        \\n        if(dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n        \\n        int ans1 = utilfunc(i+1,j,floor,len) + (floor[i] == \\'1\\');\\n        int ans2 = utilfunc(i+len,j-1,floor,len);\\n        return dp[i][j] = min(ans1,ans2);\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int num, int len) {\\n        memset(dp,-1,sizeof(dp));\\n        int n  = floor.size();\\n        suffix.resize(n,0);\\n        suffix[n-1] = floor[n-1] == \\'1\\';\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            suffix[i] += suffix[i+1] + (floor[i] == \\'1\\');\\n        }\\n        \\n        return utilfunc(0,num,floor,len);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\n    int dp[1001][1001];\\n    vector<int> suffix;\\n    int utilfunc(int i,int j,string &floor,int len)\\n    {\\n        if(i >= floor.length())\\n        {\\n            return 0;\\n        }\\n        \\n        if(j == 0)\\n        {\\n            return suffix[i];\\n        }\\n        \\n        if(dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n        \\n        int ans1 = utilfunc(i+1,j,floor,len) + (floor[i] == \\'1\\');\\n        int ans2 = utilfunc(i+len,j-1,floor,len);\\n        return dp[i][j] = min(ans1,ans2);\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int num, int len) {\\n        memset(dp,-1,sizeof(dp));\\n        int n  = floor.size();\\n        suffix.resize(n,0);\\n        suffix[n-1] = floor[n-1] == \\'1\\';\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            suffix[i] += suffix[i+1] + (floor[i] == \\'1\\');\\n        }\\n        \\n        return utilfunc(0,num,floor,len);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563262,
                "title": "memoization-explained-all-possible-ways-c",
                "content": "* Let\\'s think about all possible ways...\\n\\t* we skip the \\u2B1B Black Box  ( `memo(s,num,len,i+1)` )\\n\\t* now we have \\uD83D\\uDD32 White Box -\\n\\t\\t* we choose to cover it ( `memo(s,num-1,len,i+len)` ) thus covering next **i+len-1** boxes\\n\\t\\t* we skip this box too and let\\'s add 1 to **uncovered white box collection** ( `1 + memo(s,num,len,i+1)` )\\n\\nthe minimum uncovered white boxes among all possible ways is our desired answer....\\n`UPVOTE IF YOU LIKE \\uD83D\\uDE0E\\uD83D\\uDE4C`\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        dp.resize(floor.size()+1,vector<int>(numCarpets+1,-1));\\n        return memo(floor,numCarpets,carpetLen,0);\\n    }\\n    int memo(string& s, int num, int len, int i){\\n        int n = s.size();\\n        if(i > n-1) return 0;\\n        if(num == 0){\\n            int cnt = 0;\\n            for(int j = i; j < n; ++j){\\n                if(s[j] == \\'1\\') cnt++;\\n            }\\n            return cnt;\\n        }\\n        if(dp[i][num] != -1) return dp[i][num];\\n        if(s[i] == \\'0\\') return dp[i][num] = memo(s,num,len,i+1);\\n        int cover = memo(s,num-1,len,i+len);\\n        int skip = 1 + memo(s,num,len,i+1);\\n        return dp[i][num] = min(cover,skip);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        dp.resize(floor.size()+1,vector<int>(numCarpets+1,-1));\\n        return memo(floor,numCarpets,carpetLen,0);\\n    }\\n    int memo(string& s, int num, int len, int i){\\n        int n = s.size();\\n        if(i > n-1) return 0;\\n        if(num == 0){\\n            int cnt = 0;\\n            for(int j = i; j < n; ++j){\\n                if(s[j] == \\'1\\') cnt++;\\n            }\\n            return cnt;\\n        }\\n        if(dp[i][num] != -1) return dp[i][num];\\n        if(s[i] == \\'0\\') return dp[i][num] = memo(s,num,len,i+1);\\n        int cover = memo(s,num-1,len,i+len);\\n        int skip = 1 + memo(s,num,len,i+1);\\n        return dp[i][num] = min(cover,skip);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544757,
                "title": "c-dp-memoization",
                "content": "```\\nint tiles(int i, string &floor, int numCarpets, int carpetLen,vector<vector<int>>&dp)\\n    {\\n        if(i>=floor.size()) return 0;\\n        if(numCarpets==0)\\n        {\\n            int c=0;\\n            for(;i<floor.size();i++)\\n            {\\n                if(floor[i]==\\'1\\')   c++;\\n            }\\n            return c;\\n        }\\n        if(dp[i][numCarpets]!=-1)   return dp[i][numCarpets];\\n        int ans=INT_MAX;\\n        if(floor[i]==\\'1\\')   //here if current floor index has value \\'1\\' we can  use carpet to cover 1\\'s  or we can just move forward by 1 index\\n        ans= min(tiles(i+carpetLen,floor,numCarpets-1,carpetLen,dp),1+tiles(i+1,floor,numCarpets,carpetLen,dp));\\n        else ans= tiles(i+1,floor,numCarpets,carpetLen,dp); // and if current index has value \\'0\\' we will move forward by 1 index\\n        return dp[i][numCarpets]=ans;\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) \\n    {\\n        int n=floor.size();\\n        vector<vector<int>>dp(n+1,vector<int>(numCarpets+1,-1));\\n        return tiles(0,floor,numCarpets,carpetLen,dp);\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint tiles(int i, string &floor, int numCarpets, int carpetLen,vector<vector<int>>&dp)\\n    {\\n        if(i>=floor.size()) return 0;\\n        if(numCarpets==0)\\n        {\\n            int c=0;\\n            for(;i<floor.size();i++)\\n            {\\n                if(floor[i]==\\'1\\')   c++;\\n            }\\n            return c;\\n        }\\n        if(dp[i][numCarpets]!=-1)   return dp[i][numCarpets];\\n        int ans=INT_MAX;\\n        if(floor[i]==\\'1\\')   //here if current floor index has value \\'1\\' we can  use carpet to cover 1\\'s  or we can just move forward by 1 index\\n        ans= min(tiles(i+carpetLen,floor,numCarpets-1,carpetLen,dp),1+tiles(i+1,floor,numCarpets,carpetLen,dp));\\n        else ans= tiles(i+1,floor,numCarpets,carpetLen,dp); // and if current index has value \\'0\\' we will move forward by 1 index\\n        return dp[i][numCarpets]=ans;\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) \\n    {\\n        int n=floor.size();\\n        vector<vector<int>>dp(n+1,vector<int>(numCarpets+1,-1));\\n        return tiles(0,floor,numCarpets,carpetLen,dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2542978,
                "title": "python-go-c-top-down-vs-bottom-up-2d-vs-1d-dp-o-mn",
                "content": "*Python* top-down 2D-DP w/ built-in memo\\n\\n```python\\ndef minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n    dp = functools.cache(\\n        lambda i, j: 1000 if i < 0 else 0 if j < 0\\n        else min(dp(i - 1, j - carpetLen), dp(i, j - 1) + int(floor[j]))\\n    )\\n    return dp(numCarpets, len(floor) - 1)\\n```\\n\\n*Python* bottom-up 2D-DP\\n\\n```python\\ndef minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n    m, n = numCarpets + 2, len(floor) + carpetLen\\n    dp, A = [[[0, 1000][not i]] * n for i in range(m)], list(map(int, floor))\\n    for i in range(1, m):\\n        for j in range(carpetLen, n):\\n            dp[i][j] = min(dp[i - 1][j - carpetLen], dp[i][j - 1] + A[j - carpetLen])\\n    return dp[-1][-1]\\n```\\n\\n*Python* bottom-up 1D-DP\\n\\n```python\\ndef minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n    n = len(floor) + carpetLen\\n    X, Y = [0] * carpetLen + list(itertools.accumulate(map(int, floor))), [0] * n\\n    A = list(map(int, floor))\\n    for _ in range(numCarpets):\\n        for i in range(carpetLen, n):\\n            Y[i] = min(X[i - carpetLen], Y[i - 1] + A[i - carpetLen])\\n        X, Y = Y, X\\n    return X[-1]\\n```\\n\\n*Go* bottom-up 1D-DP in 94ms\\n\\n```go\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n\\tn := len(floor)\\n\\tA := make([]int, n)\\n\\tfor i, c := range floor {\\n\\t\\tif c == \\'1\\' {\\n\\t\\t\\tA[i] = 1\\n\\t\\t}\\n\\t}\\n\\tX := make([]int, carpetLen)\\n\\tn += carpetLen\\n\\tfor i := carpetLen; i < n; i++ {\\n\\t\\tX = append(X, X[i-1]+A[i-carpetLen])\\n\\t}\\n\\tY := make([]int, n)\\n\\tfor __ := 0; __ < numCarpets; __++ {\\n\\t\\tfor i := carpetLen; i < n; i++ {\\n\\t\\t\\tY[i] = min(X[i-carpetLen], Y[i-1]+A[i-carpetLen])\\n\\t\\t}\\n\\t\\tX, Y = Y, X\\n\\t}\\n\\treturn X[n-1]\\n}\\n```\\n\\n*C++* bottom-up 1D-DP\\n\\n```c++\\nint minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n    int n = floor.size();\\n    vector<int> A(n); for (int i = 0; i < n; ++i) if (floor[i] == \\'1\\') A[i] = 1;\\n    n += carpetLen;\\n    vector<int> X(carpetLen); for (int i = carpetLen; i < n; ++i) X.push_back(X[i - 1] + A[i - carpetLen]);\\n    vector<int> Y(n);\\n    for (int _ = 0; _ < numCarpets; ++_) {\\n        for (int i = carpetLen; i < n; ++i) Y[i] = min(X[i - carpetLen], Y[i - 1] + A[i - carpetLen]);\\n        swap(X, Y);\\n    }\\n    return X[n - 1];\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n    dp = functools.cache(\\n        lambda i, j: 1000 if i < 0 else 0 if j < 0\\n        else min(dp(i - 1, j - carpetLen), dp(i, j - 1) + int(floor[j]))\\n    )\\n    return dp(numCarpets, len(floor) - 1)\\n```\n```python\\ndef minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n    m, n = numCarpets + 2, len(floor) + carpetLen\\n    dp, A = [[[0, 1000][not i]] * n for i in range(m)], list(map(int, floor))\\n    for i in range(1, m):\\n        for j in range(carpetLen, n):\\n            dp[i][j] = min(dp[i - 1][j - carpetLen], dp[i][j - 1] + A[j - carpetLen])\\n    return dp[-1][-1]\\n```\n```python\\ndef minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n    n = len(floor) + carpetLen\\n    X, Y = [0] * carpetLen + list(itertools.accumulate(map(int, floor))), [0] * n\\n    A = list(map(int, floor))\\n    for _ in range(numCarpets):\\n        for i in range(carpetLen, n):\\n            Y[i] = min(X[i - carpetLen], Y[i - 1] + A[i - carpetLen])\\n        X, Y = Y, X\\n    return X[-1]\\n```\n```go\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n\\tn := len(floor)\\n\\tA := make([]int, n)\\n\\tfor i, c := range floor {\\n\\t\\tif c == \\'1\\' {\\n\\t\\t\\tA[i] = 1\\n\\t\\t}\\n\\t}\\n\\tX := make([]int, carpetLen)\\n\\tn += carpetLen\\n\\tfor i := carpetLen; i < n; i++ {\\n\\t\\tX = append(X, X[i-1]+A[i-carpetLen])\\n\\t}\\n\\tY := make([]int, n)\\n\\tfor __ := 0; __ < numCarpets; __++ {\\n\\t\\tfor i := carpetLen; i < n; i++ {\\n\\t\\t\\tY[i] = min(X[i-carpetLen], Y[i-1]+A[i-carpetLen])\\n\\t\\t}\\n\\t\\tX, Y = Y, X\\n\\t}\\n\\treturn X[n-1]\\n}\\n```\n```c++\\nint minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n    int n = floor.size();\\n    vector<int> A(n); for (int i = 0; i < n; ++i) if (floor[i] == \\'1\\') A[i] = 1;\\n    n += carpetLen;\\n    vector<int> X(carpetLen); for (int i = carpetLen; i < n; ++i) X.push_back(X[i - 1] + A[i - carpetLen]);\\n    vector<int> Y(n);\\n    for (int _ = 0; _ < numCarpets; ++_) {\\n        for (int i = carpetLen; i < n; ++i) Y[i] = min(X[i - carpetLen], Y[i - 1] + A[i - carpetLen]);\\n        swap(X, Y);\\n    }\\n    return X[n - 1];\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2515048,
                "title": "c-dp-o-n-m-with-prefix-sum-with-detailed-explanation",
                "content": "The first step is to clarify this sentence: \"Carpets may overlap one another.\" Of course carpets could overlap, however if there is an optimal solution where carpets overlap, there is also an optimal solution where carpets don\\'t. As the result we can disregard solutions where carpets overlap. The only exception to this is when the cumulated size of the carpets in longer than the floor, but in that case there is no visible white tile.\\n\\nSecond step is to define dp[c][i], and in the present case it\\'s the maximum number of white tiles covered by any arrangement of c carpets in between tile 1 and tile i. As the order of the carpets doesn\\'t matter (they are all the same), we can say that the first carpet is before the second carpet and so on. Which leads to the following:\\n- First carpet: k1 is the number of white tiles covered with the first carpet at position i (covering tiles from i - len + 1 to i) thus dp[1][i] = max(dp[1][i - 1], k1) as we consider the best solution so far.\\n- Second carpet: k2 is  the number of white tiles covered with the second carpet at position i, then we add the best possible number of white tiles covered with the first carpet which is dp[1][i - len] as there is no overlap. As the result dp[2][i] = max(dp[2][i - 1], k2 + dp[1][i - len].\\n\\nBy extension we obtain this definition: dp[c][i] = max(dp[c][i - 1], kc + dp[c - 1][i - len], with kc the number of white tiles covered with carpet kc.\\n\\nFine, we now have a DP algorithm, however to make it O(n * m) we need to compute kc in O(1), and this is what the prefix sum is for. Instead of iterating through the tiles within each interval [i - len + 1, i], we just need to make the difference between the prefix sum of the last tile and the prefix sum of the tile just before the considered interval.\\n\\n**O(n * m) time, O(n * m) space solution:**\\n```\\nclass Solution {\\npublic:\\n\\tint minimumWhiteTiles(string floor, int carpets, int len) {\\n\\t\\tint n = (int)floor.size();\\n\\t\\tif (carpets * len >= n) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tvector<int> pre(n + 1, 0); // number of white tiles\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tpre[i] = pre[i - 1] + (int)(floor[i - 1] == \\'1\\');\\n\\t\\t}\\n\\n\\t\\tvector<vector<int>> dp(carpets + 1, vector<int>(n + 1, 0));\\n\\t\\tfor (int c = 1; c <= carpets; c++) {\\n\\t\\t\\tfor (int i = c * len; i <= n - (carpets - c) * len; i++) {\\n\\t\\t\\t\\tdp[c][i] = max(dp[c][i - 1],\\n\\t\\t\\t\\t\\tpre[i] - pre[i - len] + dp[c - 1][i - len]);\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\treturn pre[n] - dp[carpets][n];\\n\\t}\\n};\\n```\\n\\n**O(n * m) time, O(n) space solution:**\\n```\\nclass Solution {\\npublic:\\n\\tint minimumWhiteTiles(string floor, int carpets, int len) {\\n\\t\\tint n = (int)floor.size();\\n\\t\\tif (carpets * len >= n) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tvector<int> pre(n + 1, 0); // number of white tiles\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tpre[i] = pre[i - 1] + (int)(floor[i - 1] == \\'1\\');\\n\\t\\t}\\n\\n\\t\\tvector<vector<int>> vec(2, vector<int>(n + 1, 0));\\n\\t\\tvector<int>& dp = vec[0];\\n\\t\\tvector<int>& dx = vec[1];\\n\\t\\tfor (int c = 1; c <= carpets; swap(dp, dx), c++) {\\n\\t\\t\\tfor (int i = c * len; i <= n - (carpets - c) * len; i++) {\\n\\t\\t\\t\\tdp[i] = max(dp[i - 1],\\n\\t\\t\\t\\t\\tpre[i] - pre[i - len] + dx[i - len]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn pre[n] - dx[n];\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint minimumWhiteTiles(string floor, int carpets, int len) {\\n\\t\\tint n = (int)floor.size();\\n\\t\\tif (carpets * len >= n) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tvector<int> pre(n + 1, 0); // number of white tiles\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tpre[i] = pre[i - 1] + (int)(floor[i - 1] == \\'1\\');\\n\\t\\t}\\n\\n\\t\\tvector<vector<int>> dp(carpets + 1, vector<int>(n + 1, 0));\\n\\t\\tfor (int c = 1; c <= carpets; c++) {\\n\\t\\t\\tfor (int i = c * len; i <= n - (carpets - c) * len; i++) {\\n\\t\\t\\t\\tdp[c][i] = max(dp[c][i - 1],\\n\\t\\t\\t\\t\\tpre[i] - pre[i - len] + dp[c - 1][i - len]);\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\treturn pre[n] - dp[carpets][n];\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tint minimumWhiteTiles(string floor, int carpets, int len) {\\n\\t\\tint n = (int)floor.size();\\n\\t\\tif (carpets * len >= n) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tvector<int> pre(n + 1, 0); // number of white tiles\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tpre[i] = pre[i - 1] + (int)(floor[i - 1] == \\'1\\');\\n\\t\\t}\\n\\n\\t\\tvector<vector<int>> vec(2, vector<int>(n + 1, 0));\\n\\t\\tvector<int>& dp = vec[0];\\n\\t\\tvector<int>& dx = vec[1];\\n\\t\\tfor (int c = 1; c <= carpets; swap(dp, dx), c++) {\\n\\t\\t\\tfor (int i = c * len; i <= n - (carpets - c) * len; i++) {\\n\\t\\t\\t\\tdp[i] = max(dp[i - 1],\\n\\t\\t\\t\\t\\tpre[i] - pre[i - len] + dx[i - len]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn pre[n] - dx[n];\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498730,
                "title": "dp-recursion-simple",
                "content": "class Solution {\\n    int n,m,l;\\n     vector<vector<int>>dp;\\n    int sol(int i, int j, vector<int>&v ,string& f)\\n    {\\n          if(i>= n) return 0;\\n          if(j>=m)\\n          {\\n              if(i==0) return v.back();\\n              return v.back()- v[i-1];\\n          }\\n           \\n        if(dp[i][j]!= -1) return dp[i][j];\\n        int x= sol(i+l, j+1,v,f);\\n        int y= sol(i+1,j, v,f );\\n        if(f[i]==\\'1\\') y++;\\n   //     cout<<i<<\" \"<<j<<\" \"<<x<<\" \"<<y<<\"\\\\n\";\\n        return dp[i][j]= min(x,y);\\n    }\\npublic:\\n    int minimumWhiteTiles(string f, int numCarpets, int carpetLen) {\\n        n=f.size();\\n        m=numCarpets;\\n        l=carpetLen;\\n     //   cout<<n<<\" \"<<m<<\"\\\\n\";\\n        dp.resize(n, vector<int>(m+1,-1));\\n        vector<int> v;\\n        int b=0;\\n        for(auto i:f)\\n        {\\n           b+= i-\\'0\\';\\n            v.push_back(b);\\n        }\\n        return  sol(0,0,v,f);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n    int n,m,l;\\n     vector<vector<int>>dp;\\n    int sol(int i, int j, vector<int>&v ,string& f)\\n    {\\n          if(i>= n) return 0;\\n          if(j>=m)\\n          {\\n              if(i==0) return v.back();\\n              return v.back()- v[i-1];\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2342212,
                "title": "java-easy-solution-explained",
                "content": "```\\nclass Solution {\\n    public int f(char[] arr,int i,int n,int len,int[] whites,int dp[][])\\n    {\\n        if(i>=arr.length||n==0)//outofbounds\\n        {\\n            return 0;\\n        }\\n        if(dp[i][n]!=-1)\\n        {\\n            return dp[i][n];\\n        }\\n        if(arr[i]==\\'0\\')//black\\n        {\\n            return dp[i][n]=f(arr,i+1,n,len,whites,dp);//skip\\n        }\\n        //boundary check\\n        int l=Math.min(i+len,arr.length)-1;//if white,get the min index after add carpte\\'s len\\n        int white=whites[l];\\n        if(i!=0)\\n        {\\n            white-=whites[i-1];//if i==0 no need to diff for white tiles\\n        }\\n        int pick=white+f(arr,i+len,n-1,len,whites,dp);// either pick ->white tile+after effect of putting carpet\\n        int nopick=f(arr,i+1,n,len,whites,dp);// not picking skipping\\n        return dp[i][n]=Math.max(pick,nopick);//getting max of both\\n    }\\n    public int minimumWhiteTiles(String floor, int n, int len) {\\n        int whites[]=new int[floor.length()];//prefix sum of whites\\n        int dp[][]=new int[floor.length()+1][n+1];\\n        for(int i=0;i<dp.length;i++)\\n        {\\n            for(int j=0;j<dp[0].length;j++)\\n            {\\n                dp[i][j]=-1;   \\n            }\\n        }\\n        char arr[]=floor.toCharArray();\\n        whites[0]=(arr[0]==\\'1\\'?1:0);// prefix sum of whites 0th ele may or maynot be white in case..\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            whites[i]=whites[i-1]+(arr[i]==\\'1\\'?1:0);//prefix sum\\n        }\\n        if(whites[floor.length()-1]==0)// after prefix sum the last ele is 0 then no whites at all return 0 simply\\n        {\\n            return 0;\\n        }\\n        return whites[floor.length()-1]-f(arr,0,n,len,whites,dp);// no.of whites required-> so total whites-used white tiles\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int f(char[] arr,int i,int n,int len,int[] whites,int dp[][])\\n    {\\n        if(i>=arr.length||n==0)//outofbounds\\n        {\\n            return 0;\\n        }\\n        if(dp[i][n]!=-1)\\n        {\\n            return dp[i][n];\\n        }\\n        if(arr[i]==\\'0\\')//black\\n        {\\n            return dp[i][n]=f(arr,i+1,n,len,whites,dp);//skip\\n        }\\n        //boundary check\\n        int l=Math.min(i+len,arr.length)-1;//if white,get the min index after add carpte\\'s len\\n        int white=whites[l];\\n        if(i!=0)\\n        {\\n            white-=whites[i-1];//if i==0 no need to diff for white tiles\\n        }\\n        int pick=white+f(arr,i+len,n-1,len,whites,dp);// either pick ->white tile+after effect of putting carpet\\n        int nopick=f(arr,i+1,n,len,whites,dp);// not picking skipping\\n        return dp[i][n]=Math.max(pick,nopick);//getting max of both\\n    }\\n    public int minimumWhiteTiles(String floor, int n, int len) {\\n        int whites[]=new int[floor.length()];//prefix sum of whites\\n        int dp[][]=new int[floor.length()+1][n+1];\\n        for(int i=0;i<dp.length;i++)\\n        {\\n            for(int j=0;j<dp[0].length;j++)\\n            {\\n                dp[i][j]=-1;   \\n            }\\n        }\\n        char arr[]=floor.toCharArray();\\n        whites[0]=(arr[0]==\\'1\\'?1:0);// prefix sum of whites 0th ele may or maynot be white in case..\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            whites[i]=whites[i-1]+(arr[i]==\\'1\\'?1:0);//prefix sum\\n        }\\n        if(whites[floor.length()-1]==0)// after prefix sum the last ele is 0 then no whites at all return 0 simply\\n        {\\n            return 0;\\n        }\\n        return whites[floor.length()-1]-f(arr,0,n,len,whites,dp);// no.of whites required-> so total whites-used white tiles\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291254,
                "title": "java-from-tle-to-ac-both-dp",
                "content": "First up, the naive DP solution. \\n\\nThe idea is simple - let `dp[i][j] be the min white tiles if we use i carpet for subarray 0...j.` \\nFor each carpet, we try to place it at all the location, then we have the transitional state: \\n`dp[i][j] = min(dp[i-1][k-carpetLen]+count) where carpetLen <= k <= j` and count = the number of white tiles between the gap.\\n\\nNeedless to say, it got TLE.\\n```Java\\n// TLE\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if (numCarpets*carpetLen>=floor.length()){\\n            return 0;\\n        }\\n        int[] dp = new int[floor.length()];\\n        for (int i = 0; i < floor.length(); i++){\\n            dp[i]=(i==0?0:dp[i-1])+floor.charAt(i)-\\'0\\';\\n        }\\n        for (int i = 1; i <= numCarpets; i++){\\n            for (int j = floor.length()-1; j >= 0; j--){\\n                for (int k = j,cnt=0; k >= carpetLen; k--){\\n                    dp[j]=Math.min(dp[k-carpetLen]+cnt,dp[j]);\\n                    cnt+=floor.charAt(k)-\\'0\\';\\n                }\\n                if (j<carpetLen){\\n                    dp[j]=0;\\n                }\\n            }\\n        }\\n\\n        return dp[floor.length()-1];\\n    }\\n}\\n```\\nso we have to come up with something better...\\nThis time we will consider `dp[i][j] = the min white tiles for subarray 0 ... i with j carpets used`\\nthen we should have `dp[i][j] = min(dp[i-1][j]+(1 or 0), dp[i-carpetLen][j-1])`\\nThis works.\\n\\n```Java\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if (numCarpets*carpetLen>=floor.length()){\\n            return 0;\\n        }\\n        int[][] dp = new int[floor.length()][numCarpets+1];\\n        for (int i = 0; i < floor.length(); i++){\\n            for (int j = 0; j <= numCarpets; j++){\\n                dp[i][j]=Math.min((i==0?0:dp[i-1][j])+floor.charAt(i)-\\'0\\',j==0?1000:i<carpetLen?0:dp[i-carpetLen][j-1]);\\n            }\\n        }\\n        return dp[floor.length()-1][numCarpets];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```Java\\n// TLE\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if (numCarpets*carpetLen>=floor.length()){\\n            return 0;\\n        }\\n        int[] dp = new int[floor.length()];\\n        for (int i = 0; i < floor.length(); i++){\\n            dp[i]=(i==0?0:dp[i-1])+floor.charAt(i)-\\'0\\';\\n        }\\n        for (int i = 1; i <= numCarpets; i++){\\n            for (int j = floor.length()-1; j >= 0; j--){\\n                for (int k = j,cnt=0; k >= carpetLen; k--){\\n                    dp[j]=Math.min(dp[k-carpetLen]+cnt,dp[j]);\\n                    cnt+=floor.charAt(k)-\\'0\\';\\n                }\\n                if (j<carpetLen){\\n                    dp[j]=0;\\n                }\\n            }\\n        }\\n\\n        return dp[floor.length()-1];\\n    }\\n}\\n```\n```Java\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if (numCarpets*carpetLen>=floor.length()){\\n            return 0;\\n        }\\n        int[][] dp = new int[floor.length()][numCarpets+1];\\n        for (int i = 0; i < floor.length(); i++){\\n            for (int j = 0; j <= numCarpets; j++){\\n                dp[i][j]=Math.min((i==0?0:dp[i-1][j])+floor.charAt(i)-\\'0\\',j==0?1000:i<carpetLen?0:dp[i-carpetLen][j-1]);\\n            }\\n        }\\n        return dp[floor.length()-1][numCarpets];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247732,
                "title": "java-solution-40ms-o-n-space",
                "content": "```\\nclass Solution {\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        char [] tiles = floor.toCharArray();\\n        int n = tiles.length;\\n        \\n        int [] dp = new int[n+1];\\n        \\n        int whiteTiles = 0;\\n        for(int i = 1; i<=n; i++){\\n            if(tiles[i-1]==\\'1\\') whiteTiles++;\\n            dp[i] = whiteTiles;\\n        }\\n        \\n        for(int i = 1; i<=numCarpets; i++){\\n            int [] temp = new int[n+1];\\n            for(int j = 1; j<=n; j++){\\n                temp[j] = tiles[j-1]==\\'0\\' ? temp[j-1] : Math.min(dp[Math.max(j-carpetLen, 0)], 1+temp[j-1]);\\n            }\\n            dp = temp;\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        char [] tiles = floor.toCharArray();\\n        int n = tiles.length;\\n        \\n        int [] dp = new int[n+1];\\n        \\n        int whiteTiles = 0;\\n        for(int i = 1; i<=n; i++){\\n            if(tiles[i-1]==\\'1\\') whiteTiles++;\\n            dp[i] = whiteTiles;\\n        }\\n        \\n        for(int i = 1; i<=numCarpets; i++){\\n            int [] temp = new int[n+1];\\n            for(int j = 1; j<=n; j++){\\n                temp[j] = tiles[j-1]==\\'0\\' ? temp[j-1] : Math.min(dp[Math.max(j-carpetLen, 0)], 1+temp[j-1]);\\n            }\\n            dp = temp;\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240116,
                "title": "linear-time-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        vector<int> dp(n,  0), ndp(n, 0);\\n        for(int i = 0; i < n; i++) {\\n            dp[i] = (i ? dp[i-1] : 0) + floor[i] - \\'0\\';\\n        }\\n        for(int i = 1; i <= numCarpets; i++) {\\n            for(int j = 0; j < n; j++) {\\n                ndp[j] =  (j ? ndp[j-1]: 0) + floor[j] - \\'0\\';\\n                ndp[j] = (j < carpetLen) ? 0 : min(ndp[j], dp[j - carpetLen]);\\n            }\\n            dp = ndp;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        vector<int> dp(n,  0), ndp(n, 0);\\n        for(int i = 0; i < n; i++) {\\n            dp[i] = (i ? dp[i-1] : 0) + floor[i] - \\'0\\';\\n        }\\n        for(int i = 1; i <= numCarpets; i++) {\\n            for(int j = 0; j < n; j++) {\\n                ndp[j] =  (j ? ndp[j-1]: 0) + floor[j] - \\'0\\';\\n                ndp[j] = (j < carpetLen) ? 0 : min(ndp[j], dp[j - carpetLen]);\\n            }\\n            dp = ndp;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172666,
                "title": "python-dp-prefix-sum-with-thought-process-on-optimization-when-being-asked-during-interviews",
                "content": "### Dynamic Programming + Prefix Sum\\nNote this problem is not greedy, so you get wrong answer if you get the interval for consective `1`, sort them and greedly put carpets from the longest interval. \\nBesides, this one is not a sliding window problem either. Try with this example `111010111` with `2` carpets with length of `3`. \\nThen we need iterate every possible layout with each floor, which denotes to dynamic programming.\\nFirst, let\\'s simplify the solution without optimzation. We use `dp[f][c]` represent the number of white tiles visible, and for each floor `f`, we have 2 options, put one carpet or not, which recall you the backpack problems. If we decide to put one carpet, then the result is `dp[f + length][c - 1]`, otherwise `dp[f + 1][c]`. Then we return the minimum one.\\n\\nSecondly, let\\'s observe the base case.\\n```\\n* f == n: no more floor to cover, return 0\\n* c == 0: no more tiles to use, return the number of white tiles remaining \\n```\\nFinally, let\\'s put `memoziation` on the recursive function. It looks working, but we got `TLE`. \\n\\nAlright, let\\'s optimize it. \\nFirst of all, if current `f` is black tile, we don\\'t need to cover with carpet, so we can just return `dp[f + 1][c]` if `floor[f] == \\'0\\'`.\\nSecondly, if the total length of carpet is longer than the floor, we can cover the entire floor, then the answer is `0`.\\nThridly, the time we count the remaining white tiles is linear, can we quickly get the number of white tiles given a range? prefix sum is the answer.\\n\\nLet\\'s put it all together!\\n\\n```python\\ndef minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n\\tn = len(floor)\\n\\tpre = [0]\\n\\tfor c in floor:\\n\\t\\tpre.append(pre[-1] + int(c))\\n        \\n\\t@cache\\n\\tdef helper(f, c):\\n\\t\\tif f >= n or c * carpetLen >= n - f:\\n\\t\\t\\treturn 0\\n\\t\\tif c == 0:\\n\\t\\t\\treturn pre[-1] - pre[f]\\n\\t\\tif floor[f] == \\'0\\':\\n\\t\\t\\treturn helper(f + 1, c)\\n\\t\\treturn min(1 + helper(f + 1, c), helper(f + carpetLen, c - 1))\\n\\treturn helper(0, numCarpets)\\n```\\n\\n*Time Complexity*= **O(NC)**, N means the length of floor, the C means the number of tiles.\\n*Space Complexity* = **O(NC)**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\n* f == n: no more floor to cover, return 0\\n* c == 0: no more tiles to use, return the number of white tiles remaining \\n```\n```python\\ndef minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n\\tn = len(floor)\\n\\tpre = [0]\\n\\tfor c in floor:\\n\\t\\tpre.append(pre[-1] + int(c))\\n        \\n\\t@cache\\n\\tdef helper(f, c):\\n\\t\\tif f >= n or c * carpetLen >= n - f:\\n\\t\\t\\treturn 0\\n\\t\\tif c == 0:\\n\\t\\t\\treturn pre[-1] - pre[f]\\n\\t\\tif floor[f] == \\'0\\':\\n\\t\\t\\treturn helper(f + 1, c)\\n\\t\\treturn min(1 + helper(f + 1, c), helper(f + carpetLen, c - 1))\\n\\treturn helper(0, numCarpets)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2146064,
                "title": "java-o-m-n-dp",
                "content": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        int[][] dp = new int[floor.length()+1][numCarpets+1]; // minium while tile at ith position using j carpets\\n        int num = 0;\\n        \\n        for (int i = 0; i < dp.length; i++) {\\n            \\n            for (int j = 0; j < dp[i].length; j++) {\\n                if (i == 0) dp[i][j] = 0;\\n                else dp[i][j] = Integer.MAX_VALUE/2;\\n            }\\n            \\n            if (i >= 1 && floor.charAt(i-1) == \\'1\\') num++;\\n            dp[i][0] = num;\\n        }\\n        \\n        \\n        \\n      \\n        for (int i = 1; i < dp.length; i++) {\\n            for (int j = 1; j<= numCarpets; j++) {\\n              \\n                dp[i][j] = Math.min(dp[i][j], dp[i-1][j] + (floor.charAt(i-1) ==\\'1\\'?1:0)); //carpet not cover ith tile\\n                \\n                dp[i][j] = Math.min(dp[i][j], (i >= carpetLen)? dp[i-carpetLen][j-1]:0); // carpet cover ith tile\\n                \\n                \\n\\n                \\n            }\\n        }\\n        \\n        return dp[dp.length-1][numCarpets];\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        int[][] dp = new int[floor.length()+1][numCarpets+1]; // minium while tile at ith position using j carpets\\n        int num = 0;\\n        \\n        for (int i = 0; i < dp.length; i++) {\\n            \\n            for (int j = 0; j < dp[i].length; j++) {\\n                if (i == 0) dp[i][j] = 0;\\n                else dp[i][j] = Integer.MAX_VALUE/2;\\n            }\\n            \\n            if (i >= 1 && floor.charAt(i-1) == \\'1\\') num++;\\n            dp[i][0] = num;\\n        }\\n        \\n        \\n        \\n      \\n        for (int i = 1; i < dp.length; i++) {\\n            for (int j = 1; j<= numCarpets; j++) {\\n              \\n                dp[i][j] = Math.min(dp[i][j], dp[i-1][j] + (floor.charAt(i-1) ==\\'1\\'?1:0)); //carpet not cover ith tile\\n                \\n                dp[i][j] = Math.min(dp[i][j], (i >= carpetLen)? dp[i-carpetLen][j-1]:0); // carpet cover ith tile\\n                \\n                \\n\\n                \\n            }\\n        }\\n        \\n        return dp[dp.length-1][numCarpets];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077907,
                "title": "python-top-down-approach-dp-with-prefix-sum",
                "content": "We can approach this problem using dynamic programming. Before we dive into the details of the implementation, however, let us try and grasp the intution underlying this method.\\n\\nIf we scan the string from left to right, we can make a few observations:\\n1. At each index of the string, `idx`, if we only consider the first `idx` indices, we can maintain a count of the minimum number of ones in the string if we only tile that \"window\" or substring of the original floor.\\n2. At each index, we have a choice to make -- we can either place a tile (ending at `idx` and starting at index `idx - carpetLen + 1`) or not place a tile\\n\\nIn the second case, consider each path we can take. If we do not place a tile, then we simply have more tiles left to tile the remaining floor (i.e. indices preceding `idx` from `0` to `idx - 1`, inclusive), but we may fail to cover an available tile if `floor[idx] == \\'1\\'`. If we do place a tile, then we have less tiles left to tile the remaining floor, but we are guaranteed to cover everything from `idx - carpetLen + 1` to `idx`. \\n\\nFrom here, we arrive at our dynamic programming relation, where `dp(idx, n)` represents the minimum number of remaining available tiles from indices `0` to `idx` using `n` pieces of carpet. \\n- if we the carpet we have remaining `n * carpetLen` is at least the number of available tiles, then we will not have any tiles remaining, since we can cover all tiles\\n- if we have no more carpet remaining, (i.e. `n == 0`), then we cannot tile any more pieces of the floor, so we simply return the number of available tiles preceding and including `idx`\\n- otherwise, we consider the optimal choice out of our two aforementioned cases (i.e. `dp(idx, n) = min(dp(idx - carpetLen, n - 1), dp(idx - 1, n) + floor[idx])`\\n\\nNow that we have set up this recurrence, we can use a top down dynamic programming approach to maintain intermediate results and assist in our final computation of `dp(len(floor) - 1, numCarpets)`. To calculate the number of available tiles in a given range of `floor` in constant time, a prefix sum array was built and used.\\n\\nThis method runs in `O(numCarpets * len(floor))` time, since we are able to cache intermediate results and uses `O(numCarpets * len(floor))` space.\\n\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        prefix = [0] * (len(floor) + 1)\\n        for i in range(1, len(prefix)):\\n            prefix[i] = 1 + prefix[i - 1] if floor[i - 1] == \\'1\\' else prefix[i - 1]\\n        def ones(i, j):\\n            return prefix[j + 1] - prefix[i]\\n        @cache\\n        def dp(idx, n):\\n            if n * carpetLen >= idx + 1:\\n                return 0\\n            if idx == 0:\\n                return ones(0, 0)\\n            if n == 0:\\n                return ones(0, idx)\\n            return min(dp(idx - carpetLen, n - 1), \\n                           dp(idx - 1, n) + ones(idx, idx))\\n        return dp(len(floor) - 1, numCarpets)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        prefix = [0] * (len(floor) + 1)\\n        for i in range(1, len(prefix)):\\n            prefix[i] = 1 + prefix[i - 1] if floor[i - 1] == \\'1\\' else prefix[i - 1]\\n        def ones(i, j):\\n            return prefix[j + 1] - prefix[i]\\n        @cache\\n        def dp(idx, n):\\n            if n * carpetLen >= idx + 1:\\n                return 0\\n            if idx == 0:\\n                return ones(0, 0)\\n            if n == 0:\\n                return ones(0, idx)\\n            return min(dp(idx - carpetLen, n - 1), \\n                           dp(idx - 1, n) + ones(idx, idx))\\n        return dp(len(floor) - 1, numCarpets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2055688,
                "title": "c-2d-dp-few-lines-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = (int)floor.length();\\n        if(numCarpets * carpetLen >= n) return 0;\\n        vector<vector<int>> dp(n + 1, vector<int>(numCarpets + 1));\\n        for(int i = 0; i <= n; ++i)\\n        {\\n            for(int j = 0; j <= numCarpets; j++)\\n            {\\n                if(i == 0 and j == 0){\\n                    dp[i][j] = 0;\\n                }else if(i == 0){\\n                    dp[i][j] = 0;\\n                }else if(j == 0){\\n                    dp[i][j] = dp[i-1][j] + ((floor[i-1] == \\'1\\') ? 1 : 0);\\n                }else{\\n                    if(floor[i-1] == \\'0\\'){\\n                        dp[i][j] = dp[i-1][j];\\n                    }else{\\n                        dp[i][j] = (i - carpetLen < 0) ? 0 : dp[i-carpetLen][j-1];\\n                        dp[i][j] = min(dp[i][j], 1 + dp[i-1][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][numCarpets];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = (int)floor.length();\\n        if(numCarpets * carpetLen >= n) return 0;\\n        vector<vector<int>> dp(n + 1, vector<int>(numCarpets + 1));\\n        for(int i = 0; i <= n; ++i)\\n        {\\n            for(int j = 0; j <= numCarpets; j++)\\n            {\\n                if(i == 0 and j == 0){\\n                    dp[i][j] = 0;\\n                }else if(i == 0){\\n                    dp[i][j] = 0;\\n                }else if(j == 0){\\n                    dp[i][j] = dp[i-1][j] + ((floor[i-1] == \\'1\\') ? 1 : 0);\\n                }else{\\n                    if(floor[i-1] == \\'0\\'){\\n                        dp[i][j] = dp[i-1][j];\\n                    }else{\\n                        dp[i][j] = (i - carpetLen < 0) ? 0 : dp[i-carpetLen][j-1];\\n                        dp[i][j] = min(dp[i][j], 1 + dp[i-1][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][numCarpets];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053240,
                "title": "top-down-approach-c-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1005][1005];\\n    int solve(string &s,int k,int l,int idx){\\n        if(idx>=s.size()&&k>=0)return 0;\\n        if(k<0)return INT_MAX;\\n        if(dp[k][idx]!=-1)return dp[k][idx];\\n        if(s[idx]==\\'1\\'){\\n            return dp[k][idx]=min(1+solve(s,k,l,idx+1),solve(s,k-1,l,idx+l));\\n        }\\n        else return dp[k][idx]=solve(s,k,l,idx+1);\\n        return dp[k][idx]=INT_MAX;\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(floor,numCarpets,carpetLen,0);\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[1005][1005];\\n    int solve(string &s,int k,int l,int idx){\\n        if(idx>=s.size()&&k>=0)return 0;\\n        if(k<0)return INT_MAX;\\n        if(dp[k][idx]!=-1)return dp[k][idx];\\n        if(s[idx]==\\'1\\'){\\n            return dp[k][idx]=min(1+solve(s,k,l,idx+1),solve(s,k-1,l,idx+l));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2028180,
                "title": "c-easy-bottom-up-2d-dp",
                "content": "Approach / Ideas:\\n2D DP:\\nLet f[i][j] represent the min # of while tiles remaining in floor[0..i]\\nafter applying j carpets.\\nlet z be the carpet length, and c be numCarpets.\\nThen we have:\\nf[i][j] is the min of:\\n (a) f[i-1][j], if floor[i] is not white.\\n otherwise:\\n (b) f[i-z][j-1], when use 1 carpet to cover floor[i-z+1...i]\\n (c) 1 + f[i-1][j],  when we deliberately don\\'t cover [i].\\n\\n```\\n// 2D DP:\\n// Let f[i][j] represent the min # of while tiles remaining in floor[0..i]\\n// after applying j carpets.\\n// let z be the carpet length, and c be numCarpets.\\n// Then we have:\\n// f[i][j] is the min of:\\n//  (a) f[i-1][j], if floor[i] is not white.\\n//  otherwise:\\n//  (b) f[i-z][j-1], when use 1 carpet to cover floor[i-z+1...i]\\n//  (c) 1 + f[i-1][j],  when we deliberately don\\'t cover [i].\\n//\\n// TODO: Use two rolling dp-rows to reduce space complexity to O(n) from O(n*c).\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(const string& floor, int numCarpets, int carpetLen) {\\n        const int n = floor.size();\\n        const int c = numCarpets;\\n        const int z = carpetLen;\\n\\n        // enough carpets to cover all tiles?\\n        if (c * z >= n) {\\n            return 0; // all tiles, including white tiles, are covered by carpets.\\n        }\\n\\n        // prefix sum for counting the white tiles in O(1) time by using O(n) space.\\n        vector<int> prefixSum(n);\\n        {\\n            prefixSum[0] = floor[0] == \\'1\\' ? 1 : 0;\\n            for (int i = 1; i < n; ++i) {\\n                prefixSum[i] = prefixSum[i - 1] + (floor[i] == \\'1\\' ? 1 : 0);\\n            }\\n        }\\n\\n        // enough carpets for all white tiles?\\n        if (prefixSum.back() <= c) {\\n            return 0;\\n        }\\n        // Let f[i][j] represent the min # of while tiles remaining in floor[0..i]\\n        // after applying j carpets.\\n        // let z be the carpet length, and c be numCarpets.\\n        vector<vector<int>> f(n, vector<int>(c + 1, n + 1));\\n        // initialize f[0][...]\\n        f[0][0] = prefixSum[0];\\n        for (int j = 1; j <= c; ++j) {\\n            f[0][j] = 0; // one carpet is enough to cover the first tile\\n        }\\n\\n        // General case\\n        // f[i][j] is the min of:\\n        //  (a) f[i-1][j], if floor[i] is not white.\\n        //  otherwise:\\n        //  (b) f[i-z][j-1], when use 1 carpet to cover floor[i-z+1...i]\\n        //  (c) 1 + f[i-1][j],  when we deliberately don\\'t cover [i].\\n        for (int i = 1; i < n; ++i) {\\n            f[i][0] = prefixSum[i];\\n            for (int j = 1; j <= c; ++j) {\\n                if (IsWhiteTile(floor, i)) {\\n                    // (i-z) is the pos before the carpet whose right-side is at [i].\\n                    f[i][j] =\\n                            min(i - z >= 0 ? f[i - z][j - 1] : 0, //\\n                                1 + f[i - 1][j]);\\n                } else { // black tile --> no need to cover with carpet\\n                    f[i][j] = f[i - 1][j];\\n                }\\n            }\\n        }\\n        return f[n - 1][c];\\n    }\\n\\nprivate:\\n    static inline bool IsWhiteTile(const string& floor, int i) {\\n        return floor[i] == \\'1\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n// 2D DP:\\n// Let f[i][j] represent the min # of while tiles remaining in floor[0..i]\\n// after applying j carpets.\\n// let z be the carpet length, and c be numCarpets.\\n// Then we have:\\n// f[i][j] is the min of:\\n//  (a) f[i-1][j], if floor[i] is not white.\\n//  otherwise:\\n//  (b) f[i-z][j-1], when use 1 carpet to cover floor[i-z+1...i]\\n//  (c) 1 + f[i-1][j],  when we deliberately don\\'t cover [i].\\n//\\n// TODO: Use two rolling dp-rows to reduce space complexity to O(n) from O(n*c).\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(const string& floor, int numCarpets, int carpetLen) {\\n        const int n = floor.size();\\n        const int c = numCarpets;\\n        const int z = carpetLen;\\n\\n        // enough carpets to cover all tiles?\\n        if (c * z >= n) {\\n            return 0; // all tiles, including white tiles, are covered by carpets.\\n        }\\n\\n        // prefix sum for counting the white tiles in O(1) time by using O(n) space.\\n        vector<int> prefixSum(n);\\n        {\\n            prefixSum[0] = floor[0] == \\'1\\' ? 1 : 0;\\n            for (int i = 1; i < n; ++i) {\\n                prefixSum[i] = prefixSum[i - 1] + (floor[i] == \\'1\\' ? 1 : 0);\\n            }\\n        }\\n\\n        // enough carpets for all white tiles?\\n        if (prefixSum.back() <= c) {\\n            return 0;\\n        }\\n        // Let f[i][j] represent the min # of while tiles remaining in floor[0..i]\\n        // after applying j carpets.\\n        // let z be the carpet length, and c be numCarpets.\\n        vector<vector<int>> f(n, vector<int>(c + 1, n + 1));\\n        // initialize f[0][...]\\n        f[0][0] = prefixSum[0];\\n        for (int j = 1; j <= c; ++j) {\\n            f[0][j] = 0; // one carpet is enough to cover the first tile\\n        }\\n\\n        // General case\\n        // f[i][j] is the min of:\\n        //  (a) f[i-1][j], if floor[i] is not white.\\n        //  otherwise:\\n        //  (b) f[i-z][j-1], when use 1 carpet to cover floor[i-z+1...i]\\n        //  (c) 1 + f[i-1][j],  when we deliberately don\\'t cover [i].\\n        for (int i = 1; i < n; ++i) {\\n            f[i][0] = prefixSum[i];\\n            for (int j = 1; j <= c; ++j) {\\n                if (IsWhiteTile(floor, i)) {\\n                    // (i-z) is the pos before the carpet whose right-side is at [i].\\n                    f[i][j] =\\n                            min(i - z >= 0 ? f[i - z][j - 1] : 0, //\\n                                1 + f[i - 1][j]);\\n                } else { // black tile --> no need to cover with carpet\\n                    f[i][j] = f[i - 1][j];\\n                }\\n            }\\n        }\\n        return f[n - 1][c];\\n    }\\n\\nprivate:\\n    static inline bool IsWhiteTile(const string& floor, int i) {\\n        return floor[i] == \\'1\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013213,
                "title": "c-90-dp-time-o-mn-space-o-m",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(\\n        string floor, \\n        int n,\\n        int k\\n    ) {\\n        int m = floor.size();\\n        if (n * k >= m) return 0;\\n        \\n        vector<int> ps(m+1);\\n        for (int i = 1; i <= m; ++i)\\n            ps[i] = ps[i-1] + (floor[i-1] == \\'1\\');\\n        \\n        vector<int> dp, dq;\\n        dp = ps;\\n        for (int i = 1; i <= n; ++i) {\\n            dq.assign(m+1, 0);\\n            for (int j = i*k+1; j <= m; ++j) {\\n                dq[j] = min(\\n                    dq[j-1]+(floor[j-1]==\\'1\\'),\\n                    dp[j-k]\\n                );\\n            }\\n            dp = dq;\\n        }\\n        \\n        return dp[m];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(\\n        string floor, \\n        int n,\\n        int k\\n    ) {\\n        int m = floor.size();\\n        if (n * k >= m) return 0;\\n        \\n        vector<int> ps(m+1);\\n        for (int i = 1; i <= m; ++i)\\n            ps[i] = ps[i-1] + (floor[i-1] == \\'1\\');\\n        \\n        vector<int> dp, dq;\\n        dp = ps;\\n        for (int i = 1; i <= n; ++i) {\\n            dq.assign(m+1, 0);\\n            for (int j = i*k+1; j <= m; ++j) {\\n                dq[j] = min(\\n                    dq[j-1]+(floor[j-1]==\\'1\\'),\\n                    dp[j-k]\\n                );\\n            }\\n            dp = dq;\\n        }\\n        \\n        return dp[m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007330,
                "title": "c-dp-bottom-up-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int i, j;\\n        const int inf = 1001;\\n        int len = floor.length();\\n        vector<vector<int>> dp(len + 1, vector<int> (numCarpets + 1, inf));\\n        \\n        // Base Cases\\n        for(i = 0; i <= numCarpets; i++){\\n            dp[0][i] = 0;\\n        }\\n        \\n        for(i = 1; i <= len; i++){\\n            dp[i][0] = dp[i - 1][0] + (floor[i - 1] == \\'1\\' ? 1 : 0);\\n        }\\n        \\n        for(i = 1; i <= len; i++){\\n            for(j = 1; j <= numCarpets; j++){\\n                int isWhiteTile = floor[i - 1] == \\'1\\' ? 1 : 0;\\n                \\n                dp[i][j] = dp[i - 1][j] + isWhiteTile;\\n                \\n                if(i - carpetLen >= 0){\\n                    dp[i][j] = min(dp[i][j], dp[i - carpetLen][j - 1]);\\n                }\\n                else{\\n                    dp[i][j] = min(dp[i][j], dp[0][j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[len][numCarpets];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int i, j;\\n        const int inf = 1001;\\n        int len = floor.length();\\n        vector<vector<int>> dp(len + 1, vector<int> (numCarpets + 1, inf));\\n        \\n        // Base Cases\\n        for(i = 0; i <= numCarpets; i++){\\n            dp[0][i] = 0;\\n        }\\n        \\n        for(i = 1; i <= len; i++){\\n            dp[i][0] = dp[i - 1][0] + (floor[i - 1] == \\'1\\' ? 1 : 0);\\n        }\\n        \\n        for(i = 1; i <= len; i++){\\n            for(j = 1; j <= numCarpets; j++){\\n                int isWhiteTile = floor[i - 1] == \\'1\\' ? 1 : 0;\\n                \\n                dp[i][j] = dp[i - 1][j] + isWhiteTile;\\n                \\n                if(i - carpetLen >= 0){\\n                    dp[i][j] = min(dp[i][j], dp[i - carpetLen][j - 1]);\\n                }\\n                else{\\n                    dp[i][j] = min(dp[i][j], dp[0][j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[len][numCarpets];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986971,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n\\t\\t\\n\\t\\t#prefix sum of white tiles till now\\n        f = [0] * (n+1)\\n        for i in range(1, n+1):\\n            f[i] += f[i-1]\\n            if floor[i-1] == \\'1\\':\\n                f[i] += 1\\n\\t\\t\\n\\t\\t#dp over each index for different no. of tiles\\n        dp = [[0]*(numCarpets+1) for _ in range(n+1)]\\n        for i in range(1, n+1):\\n            for j in range(1,numCarpets+1):\\n                prevIdx = max(0, i-carpetLen)\\n                newCoverage = f[i]-f[prevIdx] + dp[prevIdx][j-1]\\n                dp[i][j] = max(dp[i-1][j], newCoverage)\\n\\t\\t\\t\\t\\n        return f[n] - dp[n][numCarpets]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n\\t\\t\\n\\t\\t#prefix sum of white tiles till now\\n        f = [0] * (n+1)\\n        for i in range(1, n+1):\\n            f[i] += f[i-1]\\n            if floor[i-1] == \\'1\\':\\n                f[i] += 1\\n\\t\\t\\n\\t\\t#dp over each index for different no. of tiles\\n        dp = [[0]*(numCarpets+1) for _ in range(n+1)]\\n        for i in range(1, n+1):\\n            for j in range(1,numCarpets+1):\\n                prevIdx = max(0, i-carpetLen)\\n                newCoverage = f[i]-f[prevIdx] + dp[prevIdx][j-1]\\n                dp[i][j] = max(dp[i-1][j], newCoverage)\\n\\t\\t\\t\\t\\n        return f[n] - dp[n][numCarpets]",
                "codeTag": "Java"
            },
            {
                "id": 1972034,
                "title": "java-bottom-up-dp-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int len = floor.length();\\n        int[][] dp = new int[numCarpets + 1][len+1];\\n        int[] prefix = new int[len];\\n        int tiles = 0, total = 0;\\n        \\n        for(int i = 0; i < len; i++)\\n        {\\n            tiles += floor.charAt(i) - \\'0\\'; // calculate total no of Tiles within the Carpet Length Window\\n            if(i - carpetLen >= 0) // start excluding tiles which are not in the Range anymore of the Carpet Length given\\n                tiles -= floor.charAt(i - carpetLen) - \\'0\\'; \\n            prefix[i] = tiles; // the total no of tiles covered within the Carpet Length range for current index\\n            total += floor.charAt(i) - \\'0\\';\\n        }\\n            \\n        for(int i = 1; i <= numCarpets; i++)\\n        { \\n            for(int j = 0; j < len; j++)\\n            {\\n                int doNot = dp[i][j]; // if we do not wish to cover current Tile\\n                int doTake = dp[i-1][Math.max(0, j - carpetLen + 1)] + prefix[j]; // if we do wish to cover current tile\\n                // we should go back the Carpet length & check for tiles not covered before j - carpet Length distance\\n                dp[i][j + 1] = Math.max(doTake, doNot);\\n            }\\n        }\\n        \\n        return total - dp[numCarpets][len];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int len = floor.length();\\n        int[][] dp = new int[numCarpets + 1][len+1];\\n        int[] prefix = new int[len];\\n        int tiles = 0, total = 0;\\n        \\n        for(int i = 0; i < len; i++)\\n        {\\n            tiles += floor.charAt(i) - \\'0\\'; // calculate total no of Tiles within the Carpet Length Window\\n            if(i - carpetLen >= 0) // start excluding tiles which are not in the Range anymore of the Carpet Length given\\n                tiles -= floor.charAt(i - carpetLen) - \\'0\\'; \\n            prefix[i] = tiles; // the total no of tiles covered within the Carpet Length range for current index\\n            total += floor.charAt(i) - \\'0\\';\\n        }\\n            \\n        for(int i = 1; i <= numCarpets; i++)\\n        { \\n            for(int j = 0; j < len; j++)\\n            {\\n                int doNot = dp[i][j]; // if we do not wish to cover current Tile\\n                int doTake = dp[i-1][Math.max(0, j - carpetLen + 1)] + prefix[j]; // if we do wish to cover current tile\\n                // we should go back the Carpet length & check for tiles not covered before j - carpet Length distance\\n                dp[i][j + 1] = Math.max(doTake, doNot);\\n            }\\n        }\\n        \\n        return total - dp[numCarpets][len];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940507,
                "title": "python3-dp-beats-100",
                "content": "Standard DP solution with a few optimizations:\\n* We will never lay a carpet starting on a black tile. We could defer laying the carpet and cover the same or more white tiles.\\n* If the next carpetLen tiles are all white, we will always lay a carpet.\\n\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        whiteTileSegment = \\'1\\' * carpetLen\\n        \\n        # Minimum white tiles shown on tile i..len(tiles)-1 with n carpets.\\n\\t\\t@cache\\n        def dp(i, n):\\n\\t\\t    # No tiles remain.\\n            if i >= len(floor):\\n                return 0\\n            # No carpets remain, return the count of remaining white tiles.\\n            if n == 0:\\n                return floor[i:].count(\\'1\\')\\n            # Tile i is black, we will never lay a carpet starting on a black tile.\\n            if floor[i] == \\'0\\':\\n                return dp(i + 1, n)\\n            # There is enough carpet left to cover all remaining tiles.\\n            if len(floor) - i < n * carpetLen:\\n                return 0\\n            # The next carpetLen tiles are all white, we will always lay a carpet here.\\n            if floor[i:i + carpetLen] == whiteTileSegment:\\n                return dp(i + carpetLen, n - 1)\\n            \\n            dontLayCarpet = 1 + dp(i + 1, n)\\n            layCarpet = dp(i + carpetLen, n - 1)\\n            return min(dontLayCarpet, layCarpet)\\n                  \\n        return dp(0, numCarpets)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        whiteTileSegment = \\'1\\' * carpetLen\\n        \\n        # Minimum white tiles shown on tile i..len(tiles)-1 with n carpets.\\n\\t\\t@cache\\n        def dp(i, n):\\n\\t\\t    # No tiles remain.\\n            if i >= len(floor):\\n                return 0\\n            # No carpets remain, return the count of remaining white tiles.\\n            if n == 0:\\n                return floor[i:].count(\\'1\\')\\n            # Tile i is black, we will never lay a carpet starting on a black tile.\\n            if floor[i] == \\'0\\':\\n                return dp(i + 1, n)\\n            # There is enough carpet left to cover all remaining tiles.\\n            if len(floor) - i < n * carpetLen:\\n                return 0\\n            # The next carpetLen tiles are all white, we will always lay a carpet here.\\n            if floor[i:i + carpetLen] == whiteTileSegment:\\n                return dp(i + carpetLen, n - 1)\\n            \\n            dontLayCarpet = 1 + dp(i + 1, n)\\n            layCarpet = dp(i + carpetLen, n - 1)\\n            return min(dontLayCarpet, layCarpet)\\n                  \\n        return dp(0, numCarpets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916981,
                "title": "very-simple-dp-solution",
                "content": "```\\n\\nclass Solution {\\n    \\n    \\n    private int[] suffix=new int[1002];\\n    \\n    private void generateSuffixArray(String floor){\\n        int c=0;\\n        for(int i=0;i<floor.length();i++){\\n            if(floor.charAt(i) == \\'1\\')\\n                c++;\\n            suffix[i]=c;\\n        }\\n    }\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        generateSuffixArray(floor);\\n        int arr[][]=new int[numCarpets+1][floor.length()];\\n        \\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<arr[i].length;j++){\\n                if(i==0)\\n                    arr[i][j]=0;\\n                else{\\n                    arr[i][j]=suffix[j];\\n                    if(j-carpetLen >=0)\\n                        arr[i][j]=arr[i][j]-suffix[j-carpetLen]+arr[i-1][j-carpetLen];\\n                    if(j-1>=0)\\n                        arr[i][j]=Math.max(arr[i][j-1],arr[i][j]);\\n                }\\n\\n            }\\n\\n        }\\n        \\n        return suffix[floor.length()-1]-arr[numCarpets][floor.length()-1];\\n    }\\n}\\n\\n```\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\n    \\n    \\n    private int[] suffix=new int[1002];\\n    \\n    private void generateSuffixArray(String floor){\\n        int c=0;\\n        for(int i=0;i<floor.length();i++){\\n            if(floor.charAt(i) == \\'1\\')\\n                c++;\\n            suffix[i]=c;\\n        }\\n    }\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        generateSuffixArray(floor);\\n        int arr[][]=new int[numCarpets+1][floor.length()];\\n        \\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<arr[i].length;j++){\\n                if(i==0)\\n                    arr[i][j]=0;\\n                else{\\n                    arr[i][j]=suffix[j];\\n                    if(j-carpetLen >=0)\\n                        arr[i][j]=arr[i][j]-suffix[j-carpetLen]+arr[i-1][j-carpetLen];\\n                    if(j-1>=0)\\n                        arr[i][j]=Math.max(arr[i][j-1],arr[i][j]);\\n                }\\n\\n            }\\n\\n        }\\n        \\n        return suffix[floor.length()-1]-arr[numCarpets][floor.length()-1];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914589,
                "title": "easy-to-understand-dp",
                "content": "The idea is simple to use DP and memoization to maintain the number of covered tiles at an index i with k remaining carpets.\\n\\n```\\nvar minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\\n    let answer = Number.MAX_SAFE_INTEGER, dp = {};\\n    \\n    floor = floor.split(\\'\\');\\n    \\n    function findMaxCoveredTiles(index, carpetsLeft) {\\n        if(index >= floor.length) {\\n            return 0;\\n        }\\n        if(dp[index]) {\\n            if(dp[index][carpetsLeft] != undefined) {\\n                return dp[index][carpetsLeft];\\n            }\\n        }\\n        else {\\n            dp[index] = {};\\n        }\\n        \\n        dp[index][carpetsLeft] = Number.MIN_SAFE_INTEGER;\\n        if(carpetsLeft) {\\n            dp[index][carpetsLeft] = Math.min(carpetLen, floor.length - index) + findMaxCoveredTiles(index + carpetLen, carpetsLeft - 1);\\n        }\\n\\n        dp[index][carpetsLeft] = Math.max(dp[index][carpetsLeft], !+floor[index] + findMaxCoveredTiles(index + 1, carpetsLeft));\\n        \\n        return dp[index][carpetsLeft];\\n    }\\n    \\n    return floor.length - findMaxCoveredTiles(0, numCarpets);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\\n    let answer = Number.MAX_SAFE_INTEGER, dp = {};\\n    \\n    floor = floor.split(\\'\\');\\n    \\n    function findMaxCoveredTiles(index, carpetsLeft) {\\n        if(index >= floor.length) {\\n            return 0;\\n        }\\n        if(dp[index]) {\\n            if(dp[index][carpetsLeft] != undefined) {\\n                return dp[index][carpetsLeft];\\n            }\\n        }\\n        else {\\n            dp[index] = {};\\n        }\\n        \\n        dp[index][carpetsLeft] = Number.MIN_SAFE_INTEGER;\\n        if(carpetsLeft) {\\n            dp[index][carpetsLeft] = Math.min(carpetLen, floor.length - index) + findMaxCoveredTiles(index + carpetLen, carpetsLeft - 1);\\n        }\\n\\n        dp[index][carpetsLeft] = Math.max(dp[index][carpetsLeft], !+floor[index] + findMaxCoveredTiles(index + 1, carpetsLeft));\\n        \\n        return dp[index][carpetsLeft];\\n    }\\n    \\n    return floor.length - findMaxCoveredTiles(0, numCarpets);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907291,
                "title": "golang-search-with-memoization",
                "content": "```\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n    memo := make([][]int, len(floor))\\n    for i := 0; i < len(memo); i++ {\\n        memo[i] = make([]int, numCarpets + 1)\\n        for j := 0; j < len(memo[i]); j++ {\\n            memo[i][j] = -1\\n        }\\n    }\\n    return dfs(floor, numCarpets, carpetLen, 0, memo)\\n}\\n\\nfunc dfs(floor string, carp int, size int, pos int, memo [][]int) int {\\n    if pos >= len(floor) {\\n        return 0\\n    }\\n    \\n    if memo[pos][carp] != -1 {\\n        return memo[pos][carp]\\n    }\\n    \\n    res := 0\\n    if floor[pos] == \\'0\\' {\\n        res = dfs(floor, carp, size, pos + 1, memo)\\n    } else {\\n        res = 1 + dfs(floor, carp, size, pos + 1, memo)\\n        if carp > 0 {\\n            res = min(res, dfs(floor, carp - 1, size, pos + size, memo))\\n        }\\n    }  \\n    \\n    memo[pos][carp] = res\\n    \\n    return res\\n}\\n\\nfunc min(a int, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n    memo := make([][]int, len(floor))\\n    for i := 0; i < len(memo); i++ {\\n        memo[i] = make([]int, numCarpets + 1)\\n        for j := 0; j < len(memo[i]); j++ {\\n            memo[i][j] = -1\\n        }\\n    }\\n    return dfs(floor, numCarpets, carpetLen, 0, memo)\\n}\\n\\nfunc dfs(floor string, carp int, size int, pos int, memo [][]int) int {\\n    if pos >= len(floor) {\\n        return 0\\n    }\\n    \\n    if memo[pos][carp] != -1 {\\n        return memo[pos][carp]\\n    }\\n    \\n    res := 0\\n    if floor[pos] == \\'0\\' {\\n        res = dfs(floor, carp, size, pos + 1, memo)\\n    } else {\\n        res = 1 + dfs(floor, carp, size, pos + 1, memo)\\n        if carp > 0 {\\n            res = min(res, dfs(floor, carp - 1, size, pos + size, memo))\\n        }\\n    }  \\n    \\n    memo[pos][carp] = res\\n    \\n    return res\\n}\\n\\nfunc min(a int, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906286,
                "title": "java-top-down-dp-with-greedy-beats-91-43",
                "content": "```\\n    /*\\n    TLE without the \"allWhite\" check. Otherwise,\\n\\n    Runtime: 89 ms, faster than 91.43% of Java online submissions for Minimum White Tiles After Covering With Carpets.\\n    Memory Usage: 48.9 MB, less than 89.69% of Java online submissions for Minimum White Tiles After Covering With Carpets.\\n     */\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int[][] cache = new int[floor.length()][numCarpets + 1];\\n        for (int[] row : cache) {\\n            Arrays.fill(row, -1);\\n        }\\n\\n        char[] colors = floor.toCharArray();\\n        return minimumWhiteTiles(colors, numCarpets, carpetLen, 0, cache);\\n    }\\n\\n    private int minimumWhiteTiles(char[] colors, int numCarpets, int carpetLen, int ind, int[][] cache) {\\n        if (numCarpets * carpetLen >= colors.length - ind) {\\n            return 0;\\n        }\\n\\n        if (cache[ind][numCarpets] != -1) {\\n            return cache[ind][numCarpets];\\n        }\\n\\n        if (numCarpets == 0) {\\n            int remainingWhite = 0;\\n            for (int i = ind; i < colors.length; i++) {\\n                if (colors[i] == \\'1\\') {\\n                    remainingWhite++;\\n                }\\n            }\\n            cache[ind][numCarpets] = remainingWhite;\\n            return remainingWhite;\\n        }\\n\\n        int white = 0;\\n        int min = Integer.MAX_VALUE;\\n        for (int i = ind; i < colors.length; i++) {\\n            if (colors[i] == \\'1\\') { // Greedy\\n                min = Math.min(min, white + minimumWhiteTiles(colors, numCarpets - 1, carpetLen, i + carpetLen, cache));\\n                white++;\\n\\n                // Greedy\\n                if (allWhite(colors, i, carpetLen)) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        min = min == Integer.MAX_VALUE ? 0 : min;\\n        cache[ind][numCarpets] = min;\\n\\n        return min;\\n    }\\n\\n    private boolean allWhite(char[] colors, int ind, int carpetLen) {\\n        for (int j = 0; j < carpetLen && ind + j < colors.length; j++) {\\n            if (colors[ind + j] == \\'0\\') {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Greedy"
                ],
                "code": "```\\n    /*\\n    TLE without the \"allWhite\" check. Otherwise,\\n\\n    Runtime: 89 ms, faster than 91.43% of Java online submissions for Minimum White Tiles After Covering With Carpets.\\n    Memory Usage: 48.9 MB, less than 89.69% of Java online submissions for Minimum White Tiles After Covering With Carpets.\\n     */\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int[][] cache = new int[floor.length()][numCarpets + 1];\\n        for (int[] row : cache) {\\n            Arrays.fill(row, -1);\\n        }\\n\\n        char[] colors = floor.toCharArray();\\n        return minimumWhiteTiles(colors, numCarpets, carpetLen, 0, cache);\\n    }\\n\\n    private int minimumWhiteTiles(char[] colors, int numCarpets, int carpetLen, int ind, int[][] cache) {\\n        if (numCarpets * carpetLen >= colors.length - ind) {\\n            return 0;\\n        }\\n\\n        if (cache[ind][numCarpets] != -1) {\\n            return cache[ind][numCarpets];\\n        }\\n\\n        if (numCarpets == 0) {\\n            int remainingWhite = 0;\\n            for (int i = ind; i < colors.length; i++) {\\n                if (colors[i] == \\'1\\') {\\n                    remainingWhite++;\\n                }\\n            }\\n            cache[ind][numCarpets] = remainingWhite;\\n            return remainingWhite;\\n        }\\n\\n        int white = 0;\\n        int min = Integer.MAX_VALUE;\\n        for (int i = ind; i < colors.length; i++) {\\n            if (colors[i] == \\'1\\') { // Greedy\\n                min = Math.min(min, white + minimumWhiteTiles(colors, numCarpets - 1, carpetLen, i + carpetLen, cache));\\n                white++;\\n\\n                // Greedy\\n                if (allWhite(colors, i, carpetLen)) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        min = min == Integer.MAX_VALUE ? 0 : min;\\n        cache[ind][numCarpets] = min;\\n\\n        return min;\\n    }\\n\\n    private boolean allWhite(char[] colors, int ind, int carpetLen) {\\n        for (int j = 0; j < carpetLen && ind + j < colors.length; j++) {\\n            if (colors[ind + j] == \\'0\\') {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1903622,
                "title": "golang-dp-solution",
                "content": "```go\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n\\tblack, white := byte(\\'0\\'), byte(\\'1\\')\\n\\t_ = black\\n\\t_ = white\\n\\tif numCarpets*carpetLen >= len(floor) {\\n\\t\\treturn 0\\n\\t}\\n\\tdpMask := make([][]int, len(floor))\\n\\tfor i := range dpMask {\\n\\t\\tdpMask[i] = make([]int, numCarpets+1)\\n\\t}\\n\\tif floor[0] == white {\\n\\t\\tfor i := 1; i < len(dpMask[0]); i++ {\\n\\t\\t\\tdpMask[0][i] = 1\\n\\t\\t}\\n\\t}\\n\\twhiteHelper := make([]int, len(floor)+1)\\n\\tfor i := range floor {\\n\\t\\twhiteHelper[i+1] = whiteHelper[i]\\n\\t\\tif floor[i] == white {\\n\\t\\t\\twhiteHelper[i+1]++\\n\\t\\t}\\n\\t}\\n\\tfor i := 1; i < len(floor); i++ {\\n\\t\\tfor carpets := 1; carpets <= numCarpets; carpets++ {\\n\\t\\t\\tdpMask[i][carpets] = dpMask[i-1][carpets]\\n\\t\\t\\tif i < carpetLen {\\n\\t\\t\\t\\tdpMask[i][carpets] = whiteHelper[i+1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttempWhiteMask := whiteHelper[i+1] - whiteHelper[i+1-carpetLen] + dpMask[i-carpetLen][carpets-1]\\n\\t\\t\\t\\tif tempWhiteMask > dpMask[i][carpets] {\\n\\t\\t\\t\\t\\tdpMask[i][carpets] = tempWhiteMask\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn whiteHelper[len(whiteHelper)-1] - dpMask[len(dpMask)-1][numCarpets]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```go\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n\\tblack, white := byte(\\'0\\'), byte(\\'1\\')\\n\\t_ = black\\n\\t_ = white\\n\\tif numCarpets*carpetLen >= len(floor) {\\n\\t\\treturn 0\\n\\t}\\n\\tdpMask := make([][]int, len(floor))\\n\\tfor i := range dpMask {\\n\\t\\tdpMask[i] = make([]int, numCarpets+1)\\n\\t}\\n\\tif floor[0] == white {\\n\\t\\tfor i := 1; i < len(dpMask[0]); i++ {\\n\\t\\t\\tdpMask[0][i] = 1\\n\\t\\t}\\n\\t}\\n\\twhiteHelper := make([]int, len(floor)+1)\\n\\tfor i := range floor {\\n\\t\\twhiteHelper[i+1] = whiteHelper[i]\\n\\t\\tif floor[i] == white {\\n\\t\\t\\twhiteHelper[i+1]++\\n\\t\\t}\\n\\t}\\n\\tfor i := 1; i < len(floor); i++ {\\n\\t\\tfor carpets := 1; carpets <= numCarpets; carpets++ {\\n\\t\\t\\tdpMask[i][carpets] = dpMask[i-1][carpets]\\n\\t\\t\\tif i < carpetLen {\\n\\t\\t\\t\\tdpMask[i][carpets] = whiteHelper[i+1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttempWhiteMask := whiteHelper[i+1] - whiteHelper[i+1-carpetLen] + dpMask[i-carpetLen][carpets-1]\\n\\t\\t\\t\\tif tempWhiteMask > dpMask[i][carpets] {\\n\\t\\t\\t\\t\\tdpMask[i][carpets] = tempWhiteMask\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn whiteHelper[len(whiteHelper)-1] - dpMask[len(dpMask)-1][numCarpets]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1901600,
                "title": "python3-clear-top-down-greedy-dp-solution",
                "content": "The greedy strategy is that we always want to make the decision whether or not to start tiling at an indice with an element \\'1\\'. Then, we can apply memoization.\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, n: int, l: int) -> int:\\n        m = len(floor)\\n        \\n        @lru_cache(None)\\n        def dp(i, used):\\n            if i >= m:\\n                return 0\\n            if used < 1:\\n                return dp(i + 1, used) + (1 if floor[i] == \\'1\\' else 0)\\n            if used * l >= m - i:\\n                return 0\\n            if floor[i] == \\'0\\':\\n                return dp(i + 1, used)\\n            return min(dp(i + l, used - 1), dp(i + 1, used) + 1)\\n        \\n        res = dp(0, n)\\n        dp.cache_clear()\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, n: int, l: int) -> int:\\n        m = len(floor)\\n        \\n        @lru_cache(None)\\n        def dp(i, used):\\n            if i >= m:\\n                return 0\\n            if used < 1:\\n                return dp(i + 1, used) + (1 if floor[i] == \\'1\\' else 0)\\n            if used * l >= m - i:\\n                return 0\\n            if floor[i] == \\'0\\':\\n                return dp(i + 1, used)\\n            return min(dp(i + l, used - 1), dp(i + 1, used) + 1)\\n        \\n        res = dp(0, n)\\n        dp.cache_clear()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899559,
                "title": "dp-prefix-sum-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int clen;\\n    \\n    vector<int> prefix;\\n    \\n    int dp[1001][1001];\\n    \\n    int helper(string floor, int idx, int numc){\\n        \\n        //cout << idx << \" \" << numc << endl;\\n        \\n        int n = floor.size();\\n        \\n        if(numc == 0 || idx >= n) return 0;\\n        \\n        if(dp[idx][numc] != -1) return dp[idx][numc];\\n        \\n        if(floor[idx] == \\'0\\') return dp[idx][numc] = helper(floor, idx+1, numc);\\n        \\n        int res = INT_MIN;\\n    \\n        int tillIdxCover = min(n, idx+clen);\\n        int tilesCovered = prefix[tillIdxCover-1] - prefix[idx]+1;\\n        \\n        res = max(res, tilesCovered +helper(floor, tillIdxCover, numc-1));\\n        \\n        if(tilesCovered == clen) return dp[idx][numc] = res;\\n        \\n        res = max(res, helper(floor, idx+1, numc));\\n            \\n        return dp[idx][numc] = res;\\n \\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n        int n = floor.size();\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        clen = carpetLen;\\n        \\n        int cnt = 0;\\n        \\n        for(int i=0;i<floor.size();i++){\\n            if(floor[i] == \\'1\\') cnt++;\\n            prefix.push_back(cnt);\\n        }\\n        \\n        if(cnt == 0) return 0;\\n        \\n        return cnt-helper(floor, 0, numCarpets);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int clen;\\n    \\n    vector<int> prefix;\\n    \\n    int dp[1001][1001];\\n    \\n    int helper(string floor, int idx, int numc){\\n        \\n        //cout << idx << \" \" << numc << endl;\\n        \\n        int n = floor.size();\\n        \\n        if(numc == 0 || idx >= n) return 0;\\n        \\n        if(dp[idx][numc] != -1) return dp[idx][numc];\\n        \\n        if(floor[idx] == \\'0\\') return dp[idx][numc] = helper(floor, idx+1, numc);\\n        \\n        int res = INT_MIN;\\n    \\n        int tillIdxCover = min(n, idx+clen);\\n        int tilesCovered = prefix[tillIdxCover-1] - prefix[idx]+1;\\n        \\n        res = max(res, tilesCovered +helper(floor, tillIdxCover, numc-1));\\n        \\n        if(tilesCovered == clen) return dp[idx][numc] = res;\\n        \\n        res = max(res, helper(floor, idx+1, numc));\\n            \\n        return dp[idx][numc] = res;\\n \\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n        int n = floor.size();\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        clen = carpetLen;\\n        \\n        int cnt = 0;\\n        \\n        for(int i=0;i<floor.size();i++){\\n            if(floor[i] == \\'1\\') cnt++;\\n            prefix.push_back(cnt);\\n        }\\n        \\n        if(cnt == 0) return 0;\\n        \\n        return cnt-helper(floor, 0, numCarpets);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1897112,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        if (numCarpets * carpetLen >= n) return 0;\\n        vector<vector<int>> dp(n + 1, vector<int> (numCarpets + 1, INF));\\n        int white = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (floor[i] == \\'1\\') {\\n                ++white;\\n            }\\n            dp[i + 1][0] = white;\\n        }\\n        dp[0][0] = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int k = 0; k <= numCarpets; k++) {\\n                if (floor[i] == \\'0\\') {\\n                    dp[i + 1][k] = min(dp[i + 1][k], dp[i][k]);\\n                }\\n                else {\\n                    dp[i + 1][k] = min(dp[i + 1][k], dp[i][k] + 1);\\n                }\\n                if (i + carpetLen <= n && k + 1 <= numCarpets) {\\n                    dp[i + carpetLen][k + 1] = min(dp[i + carpetLen][k + 1], dp[i][k]);\\n                }\\n            }\\n        }\\n        return dp[n][numCarpets];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        if (numCarpets * carpetLen >= n) return 0;\\n        vector<vector<int>> dp(n + 1, vector<int> (numCarpets + 1, INF));\\n        int white = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (floor[i] == \\'1\\') {\\n                ++white;\\n            }\\n            dp[i + 1][0] = white;\\n        }\\n        dp[0][0] = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int k = 0; k <= numCarpets; k++) {\\n                if (floor[i] == \\'0\\') {\\n                    dp[i + 1][k] = min(dp[i + 1][k], dp[i][k]);\\n                }\\n                else {\\n                    dp[i + 1][k] = min(dp[i + 1][k], dp[i][k] + 1);\\n                }\\n                if (i + carpetLen <= n && k + 1 <= numCarpets) {\\n                    dp[i + carpetLen][k + 1] = min(dp[i + carpetLen][k + 1], dp[i][k]);\\n                }\\n            }\\n        }\\n        return dp[n][numCarpets];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896751,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n        int minimumWhiteTiles(string s, int numCarpets, int carpetLen) {\\n        vector<int> floor(carpetLen * (s.size() / carpetLen + (s.size() % carpetLen != 0)) + 1);\\n        for (int i = 1; i < floor.size(); ++i) {\\n            floor[i] = floor[i - 1] + (i <= s.size() ? s[i - 1] - \\'0\\' : 0);\\n        }\\n        \\n        int res = 0;\\n        vector<vector<int>> maxWhite(numCarpets + 1, vector<int>(floor.size()));\\n        for (int i = 1; i <= numCarpets; ++i) {\\n            for (int j = carpetLen * i; j < floor.size(); ++j) {\\n                maxWhite[i][j] = maxWhite[i][j - 1];\\n                maxWhite[i][j] = max(maxWhite[i][j], maxWhite[i - 1][j - carpetLen] + floor[j] - floor[j - carpetLen]);\\n                res = max(res, maxWhite[i][j]);\\n            }\\n        }\\n\\n        return floor.back() - res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n        int minimumWhiteTiles(string s, int numCarpets, int carpetLen) {\\n        vector<int> floor(carpetLen * (s.size() / carpetLen + (s.size() % carpetLen != 0)) + 1);\\n        for (int i = 1; i < floor.size(); ++i) {\\n            floor[i] = floor[i - 1] + (i <= s.size() ? s[i - 1] - \\'0\\' : 0);\\n        }\\n        \\n        int res = 0;\\n        vector<vector<int>> maxWhite(numCarpets + 1, vector<int>(floor.size()));\\n        for (int i = 1; i <= numCarpets; ++i) {\\n            for (int j = carpetLen * i; j < floor.size(); ++j) {\\n                maxWhite[i][j] = maxWhite[i][j - 1];\\n                maxWhite[i][j] = max(maxWhite[i][j], maxWhite[i - 1][j - carpetLen] + floor[j] - floor[j - carpetLen]);\\n                res = max(res, maxWhite[i][j]);\\n            }\\n        }\\n\\n        return floor.back() - res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896494,
                "title": "c-very-simple-solution",
                "content": "ON EVERY TIILE WE HAVE TO CHOICES \\nEITHER TO PUT THE CARPET OR MOVE AHEAD\\nWRITE THIS IN RECURRSION\\n```\\nclass Solution {\\npublic:\\n    \\n    int solver(string & floor,int nc,int cl,int i,int n,int dis[],vector<vector<int>>&dp)\\n    {\\n        \\n        \\n        if(i==0|| nc==0)\\n            return 0;\\n      \\n        if(dp[i][nc]!=-1)\\n            return dp[i][nc];\\n        \\n        int k=dis[i]-dis[max(0,i-cl)];\\n        \\n        int ans=0;\\n        ans=max(ans,solver(floor,nc-1,cl,max(0,i-cl),n,dis,dp)+k);\\n        ans=max(ans,solver(floor,nc,cl,i-1,n,dis,dp));\\n        \\n        \\n        \\n        return dp[i][nc]=ans;\\n        \\n        \\n    }\\n    int minimumWhiteTiles(string floor, int nc, int cl) {\\n        \\n        int n=floor.length();\\n        int dis[n+1];\\n        vector<vector<int>>dp(n+1,vector<int>(nc+1,-1));\\n        int total=0;\\n      \\n        dis[0]=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(floor[i-1]==\\'1\\')\\n            {\\n                total++;\\n                dis[i]=dis[i-1]+1;\\n            }\\n            else\\n                dis[i]=dis[i-1];\\n        }\\n        \\n        \\n      \\n        return total-solver(floor,nc,cl,n,n,dis,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solver(string & floor,int nc,int cl,int i,int n,int dis[],vector<vector<int>>&dp)\\n    {\\n        \\n        \\n        if(i==0|| nc==0)\\n            return 0;\\n      \\n        if(dp[i][nc]!=-1)\\n            return dp[i][nc];\\n        \\n        int k=dis[i]-dis[max(0,i-cl)];\\n        \\n        int ans=0;\\n        ans=max(ans,solver(floor,nc-1,cl,max(0,i-cl),n,dis,dp)+k);\\n        ans=max(ans,solver(floor,nc,cl,i-1,n,dis,dp));\\n        \\n        \\n        \\n        return dp[i][nc]=ans;\\n        \\n        \\n    }\\n    int minimumWhiteTiles(string floor, int nc, int cl) {\\n        \\n        int n=floor.length();\\n        int dis[n+1];\\n        vector<vector<int>>dp(n+1,vector<int>(nc+1,-1));\\n        int total=0;\\n      \\n        dis[0]=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(floor[i-1]==\\'1\\')\\n            {\\n                total++;\\n                dis[i]=dis[i-1]+1;\\n            }\\n            else\\n                dis[i]=dis[i-1];\\n        }\\n        \\n        \\n      \\n        return total-solver(floor,nc,cl,n,n,dis,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894976,
                "title": "c-dp-memo-prefix-sum",
                "content": "\\tclass Solution {\\n    \\n    void fillPrefix(vector<int> &pre, string &s, int n) {\\n        \\n        int p = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'1\\')\\n                p++;\\n            \\n            pre[i] = p;\\n        }\\n    }\\n    \\n    int memo(int i, int used, string &s, int n, int nc, int l, vector<vector<int>> &dp, vector<int> &pre) {\\n        \\n        if(i >= n || nc == used)\\n            return 0;\\n        \\n        if(dp[i][used] != -1)\\n            return dp[i][used];\\n        \\n        if(s[i] == \\'0\\')\\n            dp[i][used] = memo(i + 1, used, s, n, nc, l, dp, pre);\\n        else {\\n            int ind = min(i + l - 1, n - 1);\\n            int ans = pre[ind];\\n            if(i > 0)\\n                ans -= pre[i - 1];\\n        \\n            int include = memo(i + l, used + 1, s, n, nc, l, dp, pre);\\n            int exclude = memo(i + 1, used, s, n, nc, l, dp, pre);\\n        \\n            dp[i][used] = max(include + ans, exclude);\\n        }\\n        \\n        return dp[i][used];\\n    }\\n    \\n\\tpublic:\\n    int minimumWhiteTiles(string s, int nc, int l) {\\n        \\n        int n = s.length();\\n        vector<int> pre(n, 0);\\n        fillPrefix(pre, s, n);\\n        \\n        if(pre[n - 1] == 0)\\n            return 0;\\n        \\n        vector<vector<int>> dp(n, vector<int> (nc, -1));\\n        return pre[n - 1] - memo(0, 0, s, n, nc, l, dp, pre);\\n    }\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    \\n    void fillPrefix(vector<int> &pre, string &s, int n) {\\n        \\n        int p = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'1\\')\\n                p++;\\n            \\n            pre[i] = p;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1889341,
                "title": "c-dp-solution-bottom-up",
                "content": "```\\n        public class Solution\\n        {\\n            public int MinimumWhiteTiles(string floor, int numCarpets, int carpetLen)\\n            {\\n                int[,] m = new int[floor.Length + 1, numCarpets + 1];\\n                int count = 0;\\n\\n                //Setup first column when there is no carpets available.  \\n                for (int r = floor.Length - 1; r >= 0; r--)\\n                {\\n                    if (floor[r] == \\'1\\')\\n                    {\\n                        count++;\\n                        m[r, 0] = count;\\n                    }\\n                    else\\n                    {\\n                        m[r, 0] = m[r + 1, 0];\\n                    }\\n                }\\n\\n\\t\\t\\t\\t//Looping through each column.  Each column represents the num of available carpets.\\n                for (int c = 1; c <= numCarpets; c++)\\n                {\\n                    for (int r = floor.Length - 1; r >= 0; r--)\\n                    {\\n                        if (floor[r] == \\'0\\')\\n                        {\\n                            m[r, c] = m[r + 1, c];\\n                        }\\n                        else\\n                        {\\n                            //current tile of the floor, the cost of using the carpet.\\n\\t\\t\\t\\t\\t\\t\\t//cost means the minimum num of white tiles visible.\\n                            var a = r + carpetLen <= floor.Length ? m[r + carpetLen, c - 1] : 0;\\n\\n                            //compare it with no carpet at the current tile, Take the smaller one.\\n                            m[r, c] = Math.Min(a, m[r + 1, c] + 1);\\n                        }\\n                    }\\n                };\\n                return m[0, numCarpets];\\n\\n            }\\n        }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n        public class Solution\\n        {\\n            public int MinimumWhiteTiles(string floor, int numCarpets, int carpetLen)\\n            {\\n                int[,] m = new int[floor.Length + 1, numCarpets + 1];\\n                int count = 0;\\n\\n                //Setup first column when there is no carpets available.  \\n                for (int r = floor.Length - 1; r >= 0; r--)\\n                {\\n                    if (floor[r] == \\'1\\')\\n                    {\\n                        count++;\\n                        m[r, 0] = count;\\n                    }\\n                    else\\n                    {\\n                        m[r, 0] = m[r + 1, 0];\\n                    }\\n                }\\n\\n\\t\\t\\t\\t//Looping through each column.  Each column represents the num of available carpets.\\n                for (int c = 1; c <= numCarpets; c++)\\n                {\\n                    for (int r = floor.Length - 1; r >= 0; r--)\\n                    {\\n                        if (floor[r] == \\'0\\')\\n                        {\\n                            m[r, c] = m[r + 1, c];\\n                        }\\n                        else\\n                        {\\n                            //current tile of the floor, the cost of using the carpet.\\n\\t\\t\\t\\t\\t\\t\\t//cost means the minimum num of white tiles visible.\\n                            var a = r + carpetLen <= floor.Length ? m[r + carpetLen, c - 1] : 0;\\n\\n                            //compare it with no carpet at the current tile, Take the smaller one.\\n                            m[r, c] = Math.Min(a, m[r + 1, c] + 1);\\n                        }\\n                    }\\n                };\\n                return m[0, numCarpets];\\n\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888435,
                "title": "c-easy-dp-solution",
                "content": "here when ever we incounter a white tiles then only we have to make sure have to cover it else we can continue moving over string moreover we have to insure once we incounter white tiles and used carpet to cover it then wee could easely move length of carpet step ahead as it would cover both white and black tiles \\n\\nint f(int i,string& s, int n, int l,vector<vector<int>>& dp)\\n    {\\n        if(i<0 )\\n            return 0;\\n        if(dp[i][n] != -1)\\n            return dp[i][n];\\n        int t=1e8,nt=0;\\n        nt = s[i]-\\'0\\' + f(i-1,s,n,l,dp);\\n        if(n>0 && s[i] == \\'1\\')\\n        t = f(i-l,s,n-1,l,dp);\\n        return dp[i][n] = min(t,nt);\\n    }\\n    \\n    int minimumWhiteTiles(string s, int n, int l) {\\n        \\n        int n1 = s.size();\\n        vector<vector<int>> dp(n1,vector<int>(n+1,-1));\\n        return f(n1-1,s,n,l,dp);\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "here when ever we incounter a white tiles then only we have to make sure have to cover it else we can continue moving over string moreover we have to insure once we incounter white tiles and used carpet to cover it then wee could easely move length of carpet step ahead as it would cover both white and black tiles \\n\\nint f(int i,string& s, int n, int l,vector<vector<int>>& dp)\\n    {\\n        if(i<0 )\\n            return 0;\\n        if(dp[i][n] != -1)\\n            return dp[i][n];\\n        int t=1e8,nt=0;\\n        nt = s[i]-\\'0\\' + f(i-1,s,n,l,dp);\\n        if(n>0 && s[i] == \\'1\\')\\n        t = f(i-l,s,n-1,l,dp);\\n        return dp[i][n] = min(t,nt);\\n    }\\n    \\n    int minimumWhiteTiles(string s, int n, int l) {\\n        \\n        int n1 = s.size();\\n        vector<vector<int>> dp(n1,vector<int>(n+1,-1));\\n        return f(n1-1,s,n,l,dp);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1888259,
                "title": "presum-dp",
                "content": "My thought is very similar to the solution of this problem https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/.\\n\\nDefine dp state:\\n\\n`dp[i][j]: when use i carpet, starting from j-th floor, the maximum covered white tiles.`\\n\\nThe relation between dp states:\\n\\n`dp[i][j] = dp[i-1][j-k] + # of covered white tiles by i-th carpet.`\\n`i-1` is the number of carpet used \\n`j-k` is the maximum possible starting floor for `i-1` floors. (The best strategy is not to overlap the carpets).\\n\\nTo quickly get the # of covered white tiles by i-th carpet, we need to calculate the prefix sum of white tiles.\\n\\n\\nRemember we want to find the maximum covered white tiles.\\nIf after the i-th carpet covered tile starting from position j,\\nthe overall covered white tiles are not better than previous result,\\nprevious result should be used. So we have the following relation:\\n        \\n`dp[i][j] = max(dp[i][j], dp[i][j-1]);`\\n        \\n        \\nExample:\\n```\\nfloor:\\n1 1 0 0 0 1 0 1 0\\n        \\ncarpet len: 2, num carpets: 1\\n        \\ndp[1] = [2 2 2 2 2 2 2 2 2]\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int m = numCarpets, n = floor.length(), k = carpetLen;\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        vector<int> presum(n+1, 0);\\n        floor = \"#\" + floor;\\n        int count = 0;\\n        for(int i=1; i<=n; i++) {\\n            count += (floor[i]-\\'0\\');\\n            presum[i] = presum[i-1]+(floor[i]-\\'0\\');\\n        }\\n        \\n        int ret = count;\\n        for(int i=1; i<=m && ret>0; i++) {\\n            for(int j=(i-1)*k+1; j<=n && ret>0; j++) {\\n                dp[i][j] = (i==1?0:dp[i-1][j-k]) + presum[min(n,j+k-1)] - presum[j-1];\\n                dp[i][j] = max(dp[i][j], dp[i][j-1]);\\n                ret = min(ret, count - dp[i][j]);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfloor:\\n1 1 0 0 0 1 0 1 0\\n        \\ncarpet len: 2, num carpets: 1\\n        \\ndp[1] = [2 2 2 2 2 2 2 2 2]\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int m = numCarpets, n = floor.length(), k = carpetLen;\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        vector<int> presum(n+1, 0);\\n        floor = \"#\" + floor;\\n        int count = 0;\\n        for(int i=1; i<=n; i++) {\\n            count += (floor[i]-\\'0\\');\\n            presum[i] = presum[i-1]+(floor[i]-\\'0\\');\\n        }\\n        \\n        int ret = count;\\n        for(int i=1; i<=m && ret>0; i++) {\\n            for(int j=(i-1)*k+1; j<=n && ret>0; j++) {\\n                dp[i][j] = (i==1?0:dp[i-1][j-k]) + presum[min(n,j+k-1)] - presum[j-1];\\n                dp[i][j] = max(dp[i][j], dp[i][j-1]);\\n                ret = min(ret, count - dp[i][j]);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886286,
                "title": "easy-top-down-knapsack-solution-c",
                "content": "```\\nint minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.size();\\n        vector<vector<int>> dp(n+1,vector<int>(numCarpets+1,0));\\n        //Initialising\\n        for(int i=0;i<n;i++){\\n            if(i!=0)\\n            dp[i][0]=dp[i-1][0];\\n            if(floor[i]==\\'1\\'){\\n                dp[i][0]+=1;\\n            }\\n        }\\n        for (int j=1; j<=numCarpets;j++){ \\n            for(int i=0;i<n;i++){\\n                int skipcarpet;\\n                if(i==0)\\n                    skipcarpet=floor[i]==\\'1\\' ? 1 :0;\\n                else\\n                skipcarpet=floor[i]==\\'1\\' ? dp[i-1][j]+1 :dp[i-1][j];\\n                if(i-carpetLen>=0)\\n                dp[i][j]=min(dp[i-carpetLen][j-1], skipcarpet);  // min(usecarpet,skipcarpet)\\n                else \\n                 dp[i][j]=min(0,skipcarpet);\\n            }\\n        }\\n        \\n        return dp[n-1][numCarpets];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.size();\\n        vector<vector<int>> dp(n+1,vector<int>(numCarpets+1,0));\\n        //Initialising\\n        for(int i=0;i<n;i++){\\n            if(i!=0)\\n            dp[i][0]=dp[i-1][0];\\n            if(floor[i]==\\'1\\'){\\n                dp[i][0]+=1;\\n            }\\n        }\\n        for (int j=1; j<=numCarpets;j++){ \\n            for(int i=0;i<n;i++){\\n                int skipcarpet;\\n                if(i==0)\\n                    skipcarpet=floor[i]==\\'1\\' ? 1 :0;\\n                else\\n                skipcarpet=floor[i]==\\'1\\' ? dp[i-1][j]+1 :dp[i-1][j];\\n                if(i-carpetLen>=0)\\n                dp[i][j]=min(dp[i-carpetLen][j-1], skipcarpet);  // min(usecarpet,skipcarpet)\\n                else \\n                 dp[i][j]=min(0,skipcarpet);\\n            }\\n        }\\n        \\n        return dp[n-1][numCarpets];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1886192,
                "title": "python-top-down-passing-no-tle",
                "content": "Simple thing to speed up the code is keep a cached sum of number of white tiles remaining after index `i` so that once we have 0 carpets left it\\'s easy to figure out how many white tiles remain.\\n\\n```python\\nfrom functools import cache\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        @cache\\n        def nums(i):\\n            if i == len(floor):\\n                return 0\\n            return (floor[i] == \\'1\\') + nums(i+1)\\n        @cache\\n        def dfs(i, n):\\n            if i >= len(floor):\\n                return 0\\n            if n == 0:\\n                return nums(i)\\n            if floor[i] == \\'0\\':\\n                return dfs(i+1, n)\\n            return min(1+dfs(i+1, n), dfs(i+carpetLen, n-1))\\n        return dfs(0, numCarpets)\\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```python\\nfrom functools import cache\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        @cache\\n        def nums(i):\\n            if i == len(floor):\\n                return 0\\n            return (floor[i] == \\'1\\') + nums(i+1)\\n        @cache\\n        def dfs(i, n):\\n            if i >= len(floor):\\n                return 0\\n            if n == 0:\\n                return nums(i)\\n            if floor[i] == \\'0\\':\\n                return dfs(i+1, n)\\n            return min(1+dfs(i+1, n), dfs(i+carpetLen, n-1))\\n        return dfs(0, numCarpets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885527,
                "title": "python-c-dp-solution",
                "content": "Step1 :\\nCalcualte the number of white tiles can be cover if we put a carpet at each position\\nStep2:\\n\\tCalculte the maximum number of tiles can be covered at each postion for carpet count = 1\\n\\tCalculte the maximum number of tiles can be covered at each postion for carpet count = 2\\n\\t....\\n\\tCalculte the maximum number of tiles can be covered at each postion for carpet count = carpetLen\\nStep3:\\n\\tTotal while tiles minus maximum tiles can be convered is the final answer\\nC++\\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<int> dp(floor.size());\\n        vector<int> cover;\\n        int cnt = 0;\\n        for (int i = 0;i< floor.size();i++){\\n            if (floor[i] == \\'1\\'){\\n                cnt +=1;\\n            }\\n            if (i >= carpetLen && floor[i-carpetLen] == \\'1\\'){\\n                cnt -=1;\\n            }\\n            cover.push_back(cnt);\\n        }\\n        while (numCarpets){\\n            numCarpets--;\\n            vector<int> dp2;\\n            int max_cover = 0;\\n            for (int j = 0;j<floor.size();j++){\\n                if (j >= carpetLen){\\n                    max_cover = max(max_cover,dp[j-carpetLen]);\\n                }\\n                dp2.push_back(max_cover + cover[j]);\\n            }\\n            dp = dp2;\\n        }\\n        int res = 0;\\n        for (auto &c:floor){\\n            res += ( c ==\\'1\\');\\n        }\\n        res -= *max_element(dp.begin(),dp.end());\\n        return res;\\n    }\\n};\\n```\\n\\n\\nPython\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        white = sum(c == \\'1\\' for c in floor)\\n        #dp[i] -> the maximum white tiles can be covered at position i\\n        dp = [0]*len(floor)\\n        #cover[i] -> the number of tiles can be covered if put a carpet at position i\\n        cover = []\\n        cnt = 0\\n        #calculate cover[i] (prefix)\\n        for i in range(len(floor)):\\n            if floor[i] == \\'1\\':\\n                cnt += 1\\n            if i >= carpetLen and floor[i-carpetLen] == \\'1\\':\\n                cnt -= 1\\n            cover.append(cnt)\\n        for i in range(numCarpets):\\n            max_cover = 0\\n            dp2 = []\\n            for j in range(len(floor)):\\n                #since (j-carpetLen+1)th ~ (j)th tiles can be cover if a carpet is put a postion j , \\n                #we only need to find the maximum tiles can be cover before positon (j-carpetLen) at the last round\\n                if j >= carpetLen:\\n                    max_cover = max(max_cover,dp[j-carpetLen])\\n                dp2.append(cover[j] + max_cover)\\n            dp = dp2 \\n        return white - max(dp)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<int> dp(floor.size());\\n        vector<int> cover;\\n        int cnt = 0;\\n        for (int i = 0;i< floor.size();i++){\\n            if (floor[i] == \\'1\\'){\\n                cnt +=1;\\n            }\\n            if (i >= carpetLen && floor[i-carpetLen] == \\'1\\'){\\n                cnt -=1;\\n            }\\n            cover.push_back(cnt);\\n        }\\n        while (numCarpets){\\n            numCarpets--;\\n            vector<int> dp2;\\n            int max_cover = 0;\\n            for (int j = 0;j<floor.size();j++){\\n                if (j >= carpetLen){\\n                    max_cover = max(max_cover,dp[j-carpetLen]);\\n                }\\n                dp2.push_back(max_cover + cover[j]);\\n            }\\n            dp = dp2;\\n        }\\n        int res = 0;\\n        for (auto &c:floor){\\n            res += ( c ==\\'1\\');\\n        }\\n        res -= *max_element(dp.begin(),dp.end());\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        white = sum(c == \\'1\\' for c in floor)\\n        #dp[i] -> the maximum white tiles can be covered at position i\\n        dp = [0]*len(floor)\\n        #cover[i] -> the number of tiles can be covered if put a carpet at position i\\n        cover = []\\n        cnt = 0\\n        #calculate cover[i] (prefix)\\n        for i in range(len(floor)):\\n            if floor[i] == \\'1\\':\\n                cnt += 1\\n            if i >= carpetLen and floor[i-carpetLen] == \\'1\\':\\n                cnt -= 1\\n            cover.append(cnt)\\n        for i in range(numCarpets):\\n            max_cover = 0\\n            dp2 = []\\n            for j in range(len(floor)):\\n                #since (j-carpetLen+1)th ~ (j)th tiles can be cover if a carpet is put a postion j , \\n                #we only need to find the maximum tiles can be cover before positon (j-carpetLen) at the last round\\n                if j >= carpetLen:\\n                    max_cover = max(max_cover,dp[j-carpetLen])\\n                dp2.append(cover[j] + max_cover)\\n            dp = dp2 \\n        return white - max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885460,
                "title": "why-my-swift-code-runs-out-as-tle",
                "content": "```swft\\nclass Solution {\\n  func minimumWhiteTiles(_ floor: String, _ numCarpets: Int, _ carpetLen: Int) -> Int {\\n    let arr = Array(floor)\\n    var memo: [String: Int] = [:]\\n    func aux(_ index: Int, _ remains: Int) -> Int {\\n      let key = \"\\\\(index)-\\\\(remains)\"\\n      if memo[key] != nil {\\n        return memo[key]!\\n      }\\n      if remains < 0 {\\n        return Int.max\\n      }\\n      if index >= floor.count || remains * carpetLen >= floor.count - index {\\n        return 0\\n      }\\n      if arr[index] == \"0\" {\\n        memo[key] = aux(index + 1, remains)\\n        return memo[key]!\\n      }\\n      memo[key] = min(\\n        aux(index + carpetLen, remains - 1),\\n        1 + aux(index + 1, remains)\\n      )\\n      return memo[key]!\\n    }\\n     return aux(0, numCarpets)\\n  }\\n}\\n```\\n\\nI chaned the code to JS and used the same solution, all test cases were passed.",
                "solutionTags": [],
                "code": "```swft\\nclass Solution {\\n  func minimumWhiteTiles(_ floor: String, _ numCarpets: Int, _ carpetLen: Int) -> Int {\\n    let arr = Array(floor)\\n    var memo: [String: Int] = [:]\\n    func aux(_ index: Int, _ remains: Int) -> Int {\\n      let key = \"\\\\(index)-\\\\(remains)\"\\n      if memo[key] != nil {\\n        return memo[key]!\\n      }\\n      if remains < 0 {\\n        return Int.max\\n      }\\n      if index >= floor.count || remains * carpetLen >= floor.count - index {\\n        return 0\\n      }\\n      if arr[index] == \"0\" {\\n        memo[key] = aux(index + 1, remains)\\n        return memo[key]!\\n      }\\n      memo[key] = min(\\n        aux(index + carpetLen, remains - 1),\\n        1 + aux(index + 1, remains)\\n      )\\n      return memo[key]!\\n    }\\n     return aux(0, numCarpets)\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885216,
                "title": "python-top-down",
                "content": "n = len(floor)\\n        dp = [[0]*(numCarpets+1) for _ in range(n+1)]\\n        for i in range(1, n+1):\\n            dp[i][0] = dp[i-1][0] + (floor[i-1] == \\'1\\')\\n        \\n        for i in range(1, n + 1):\\n            for k in range(1, numCarpets+1):\\n                dp[i][k] = min(dp[max(0, i-carpetLen)][k-1], dp[i-1][k]+(floor[i-1] == \\'1\\'))\\n\\n        return dp[n][numCarpets]",
                "solutionTags": [],
                "code": "n = len(floor)\\n        dp = [[0]*(numCarpets+1) for _ in range(n+1)]\\n        for i in range(1, n+1):\\n            dp[i][0] = dp[i-1][0] + (floor[i-1] == \\'1\\')\\n        \\n        for i in range(1, n + 1):\\n            for k in range(1, numCarpets+1):\\n                dp[i][k] = min(dp[max(0, i-carpetLen)][k-1], dp[i-1][k]+(floor[i-1] == \\'1\\'))\\n\\n        return dp[n][numCarpets]",
                "codeTag": "Unknown"
            },
            {
                "id": 1877990,
                "title": "java-top-down-dynamic-programming-with-comments",
                "content": "```\\nclass Solution {\\n    \\n    private String floor;\\n    private int[] presum;\\n    /**\\n    1. define state\\n    dp[i][k]\\n    max number of white floor covered starting at index i, with k carpets left\\n    \\n    2. state transition\\n    dp[i][k] = max(\\n                dp[j][k - 1] + coveredWhiteTiles from this used carpet, \\n                the used carpet covers index (j - 1 - carpetLen) to (j - 1), (j - 1 - carpetLen) >= i\\n                  )\\n                  \\n    3. base state\\n    k = 0: dp[i][0] = 0\\n    i >= n: dp[i][k] = 0\\n    \\n    */\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        this.floor = floor;\\n        this.presum = new int[n];\\n        int whiteTiles = 0;\\n        for (int i = 0; i < floor.length(); i++) {\\n            char c = floor.charAt(i);\\n            if (c == \\'1\\') {\\n                whiteTiles++;\\n            }\\n            presum[i] = whiteTiles;\\n        }\\n        int maxCovered = dp(0, numCarpets, new int[n][numCarpets + 1], carpetLen);\\n        return whiteTiles - maxCovered;\\n    }\\n    \\n    private int dp(int index, int k, int[][] memo, int len) {\\n        int n = memo.length;\\n        if (index >= n || k <= 0) {\\n            return 0;\\n        }\\n        if (memo[index][k] > 0) {\\n            return memo[index][k];\\n        }\\n        int maxCovered = 0;\\n        for (int j = index; j < n; j++) {\\n            if (floor.charAt(j) == \\'1\\') {\\n                int right = Math.min(n, j + len);\\n                int coveredWhiteTiles = presum[right - 1] - (j - 1 >= 0 ? presum[j - 1] : 0);\\n                if (coveredWhiteTiles > maxCovered) {\\n                    maxCovered = coveredWhiteTiles;\\n                    memo[index][k] = Math.max(memo[index][k], \\n                                          coveredWhiteTiles + \\n                                          dp(right, k - 1, memo, len));\\n                }\\n            }\\n        }\\n        return memo[index][k];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private String floor;\\n    private int[] presum;\\n    /**\\n    1. define state\\n    dp[i][k]\\n    max number of white floor covered starting at index i, with k carpets left\\n    \\n    2. state transition\\n    dp[i][k] = max(\\n                dp[j][k - 1] + coveredWhiteTiles from this used carpet, \\n                the used carpet covers index (j - 1 - carpetLen) to (j - 1), (j - 1 - carpetLen) >= i\\n                  )\\n                  \\n    3. base state\\n    k = 0: dp[i][0] = 0\\n    i >= n: dp[i][k] = 0\\n    \\n    */\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        this.floor = floor;\\n        this.presum = new int[n];\\n        int whiteTiles = 0;\\n        for (int i = 0; i < floor.length(); i++) {\\n            char c = floor.charAt(i);\\n            if (c == \\'1\\') {\\n                whiteTiles++;\\n            }\\n            presum[i] = whiteTiles;\\n        }\\n        int maxCovered = dp(0, numCarpets, new int[n][numCarpets + 1], carpetLen);\\n        return whiteTiles - maxCovered;\\n    }\\n    \\n    private int dp(int index, int k, int[][] memo, int len) {\\n        int n = memo.length;\\n        if (index >= n || k <= 0) {\\n            return 0;\\n        }\\n        if (memo[index][k] > 0) {\\n            return memo[index][k];\\n        }\\n        int maxCovered = 0;\\n        for (int j = index; j < n; j++) {\\n            if (floor.charAt(j) == \\'1\\') {\\n                int right = Math.min(n, j + len);\\n                int coveredWhiteTiles = presum[right - 1] - (j - 1 >= 0 ? presum[j - 1] : 0);\\n                if (coveredWhiteTiles > maxCovered) {\\n                    maxCovered = coveredWhiteTiles;\\n                    memo[index][k] = Math.max(memo[index][k], \\n                                          coveredWhiteTiles + \\n                                          dp(right, k - 1, memo, len));\\n                }\\n            }\\n        }\\n        return memo[index][k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1872004,
                "title": "c-simple-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int get(int i,int k,string &s,int l)\\n    {\\n        if(i>=s.size())\\n            return 0;\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        int res=s[i]-\\'0\\'+get(i+1,k,s,l);\\n        if(s[i]==\\'1\\' && k>0)\\n            res=min(res,get(i+l,k-1,s,l));\\n        return dp[i][k]=res;\\n    }\\n    int minimumWhiteTiles(string &s, int k, int l) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return get(0,k,s,l);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int get(int i,int k,string &s,int l)\\n    {\\n        if(i>=s.size())\\n            return 0;\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        int res=s[i]-\\'0\\'+get(i+1,k,s,l);\\n        if(s[i]==\\'1\\' && k>0)\\n            res=min(res,get(i+l,k-1,s,l));\\n        return dp[i][k]=res;\\n    }\\n    int minimumWhiteTiles(string &s, int k, int l) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return get(0,k,s,l);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871574,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\nLet `M` be the amount of carpets we are given, each of length `K`.  Then we can use prefix sums `S` to count the amount of `\\'1\\'` within the window `A[i..i + K)`, ie. from `i` inclusive to `i + K` non-inclusive to simulate carpet placements in O(1) time.  Then we have 2 possibilites to consider for each `i`<sup>th</sup> index candidate carpet placement:\\n\\n1. \\u2705 include\\n2. \\uD83D\\uDEAB exclude\\n\\nThus, we try all possibilities, keeping track the `i`<sup>th</sup> index candidate carpet placement and how many carpets we `have` (initially `M`) to formulate the optimal solution as the recursive stack unwinds.\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun minimumWhiteTiles(A: String, M: Int, K: Int): Int {\\n        var N = A.length\\n        var S = IntArray(N + 1) { 0 }\\n        for (i in N - 1 downTo 0)\\n            S[i] = (if (A[i] == \\'1\\') 1 else 0) + S[i + 1]\\n        fun go(i: Int = 0, have: Int = M): Int {\\n            if (i == N || have == 0)\\n                return 0\\n            var j = Math.min(i + K, N)\\n            var include = S[i] - S[j] + go(j, have - 1)\\n            var exclude = go(i + 1, have)\\n            return Math.max(include, exclude)\\n        }\\n        return S[0] - S[N] - go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun minimumWhiteTiles(A: String, M: Int, K: Int): Int {\\n        var N = A.length\\n        var S = IntArray(N + 1) { 0 }\\n        for (i in N - 1 downTo 0)\\n            S[i] = (if (A[i] == \\'1\\') 1 else 0) + S[i + 1]\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, have: Int = M): Int {\\n            if (i == N || have == 0)\\n                return 0\\n            var k = \"$i,$have\"\\n            if (!m.contains(k)) {\\n                var j = Math.min(i + K, N)\\n                var include = S[i] - S[j] + go(j, have - 1)\\n                var exclude = go(i + 1, have)\\n                m[k] = Math.max(include, exclude)\\n            }\\n            return m[k]!!\\n        }\\n        return S[0] - S[N] - go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun minimumWhiteTiles(A: String, M: Int, K: Int): Int {\\n        var N = A.length\\n        var S = IntArray(N + 1) { 0 }\\n        for (i in N - 1 downTo 0)\\n            S[i] = (if (A[i] == \\'1\\') 1 else 0) + S[i + 1]\\n        var dp = Array(N + 1) { IntArray(M + 1) { 0 } }\\n        for (have in 1..M) {\\n            for (i in N - 1 downTo 0) {\\n                var j = Math.min(i + K, N)\\n                var include = S[i] - S[j] + dp[j][have - 1]\\n                var exclude = dp[i + 1][have]\\n                dp[i][have] = Math.max(include, exclude)\\n            }\\n        }\\n        return S[0] - S[N] - dp[0][M]\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet minimumWhiteTiles = (A, M, K) => {\\n    let N = A.length;\\n    let S = Array(N + 1).fill(0);\\n    for (let i = N - 1; 0 <= i; --i)\\n        S[i] = Number(A[i] == \\'1\\') + S[i + 1];\\n    let go = (i = 0, have = M) => {\\n        if (i == N || !have)\\n            return 0;\\n        let j = Math.min(i + K, N);\\n        let include = S[i] - S[j] + go(j, have - 1),\\n            exclude = go(i + 1, have);\\n        return Math.max(include, exclude);\\n    };\\n    return S[0] - S[N] - go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet minimumWhiteTiles = (A, M, K, m = new Map()) => {\\n    let N = A.length;\\n    let S = Array(N + 1).fill(0);\\n    for (let i = N - 1; 0 <= i; --i)\\n        S[i] = Number(A[i] == \\'1\\') + S[i + 1];\\n    let go = (i = 0, have = M) => {\\n        if (i == N || !have)\\n            return 0;\\n        let k = `${i},${have}`;\\n        if (!m.has(k)) {\\n            let j = Math.min(i + K, N);\\n            let include = S[i] - S[j] + go(j, have - 1),\\n                exclude = go(i + 1, have);\\n            m.set(k, Math.max(include, exclude));\\n        }\\n        return m.get(k);\\n    };\\n    return S[0] - S[N] - go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet minimumWhiteTiles = (A, M, K, m = new Map()) => {\\n    let N = A.length;\\n    let S = Array(N + 1).fill(0);\\n    for (let i = N - 1; 0 <= i; --i)\\n        S[i] = Number(A[i] == \\'1\\') + S[i + 1];\\n    let dp = [...Array(N + 1)].map(_ => Array(M + 1).fill(0));\\n    for (let have = 1; have <= M; ++have) {\\n        for (let i = N - 1; 0 <= i; --i) {\\n            let j = Math.min(i + K, N);\\n            let include = S[i] - S[j] + dp[j][have - 1],\\n                exclude = dp[i + 1][have];\\n            dp[i][have] = Math.max(include, exclude);\\n        }\\n    }\\n    return S[0] - S[N] - dp[0][M];\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, A: str, M: int, K: int) -> int:\\n        N = len(A)\\n        S = [0] * (N + 1)\\n        for i in range(N - 1, -1, -1):\\n            S[i] = int(A[i] == \\'1\\') + S[i + 1]\\n        def go(i = 0, have = M):\\n            if i == N or not have:\\n                return 0\\n            j = min(i + K, N)\\n            include = S[i] - S[j] + go(j, have - 1)\\n            exclude = go(i + 1, have)\\n            return max(include, exclude)\\n        return S[0] - S[N] - go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, A: str, M: int, K: int) -> int:\\n        N = len(A)\\n        S = [0] * (N + 1)\\n        for i in range(N - 1, -1, -1):\\n            S[i] = int(A[i] == \\'1\\') + S[i + 1]\\n        @cache\\n        def go(i = 0, have = M):\\n            if i == N or not have:\\n                return 0\\n            j = min(i + K, N)\\n            include = S[i] - S[j] + go(j, have - 1)\\n            exclude = go(i + 1, have)\\n            return max(include, exclude)\\n        return S[0] - S[N] - go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, A: str, M: int, K: int) -> int:\\n        N = len(A)\\n        S = [0] * (N + 1)\\n        for i in range(N - 1, -1, -1):\\n            S[i] = int(A[i] == \\'1\\') + S[i + 1]\\n        dp = [[0] * (M + 1) for _ in range(N + 1)]\\n        for have in range(1, M + 1):\\n            for i in range(N - 1, -1, -1):\\n                j = min(i + K, N)\\n                include = S[i] - S[j] + dp[j][have - 1]\\n                exclude = dp[i + 1][have]\\n                dp[i][have] = max(include, exclude)\\n        return S[0] - S[N] - dp[0][M]\\n```\\n\\n---\\n\\n**Rust Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nuse std::cmp::min;\\nuse std::cmp::max;\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn minimum_white_tiles(A: String, M: i32, K: i32) -> i32 {\\n        let N = A.len();\\n        let mut S = vec![0; N + 1];\\n        for i in (0..N).rev() {\\n            S[i] = if A.chars().nth(i).unwrap() == \\'1\\' { 1 } else { 0 } + S[i + 1];\\n        }\\n        struct Go<\\'a> { f: &\\'a dyn Fn(&Go, usize, i32) -> i32 }\\n        let go = Go {\\n            f: &|go, i, have| {\\n                if i == N || have == 0 {\\n                    return 0;\\n                }\\n                let j = min(i + K as usize, N);\\n                let include = S[i] - S[j] + (go.f)(go, j, have - 1);\\n                let exclude = (go.f)(go, i + 1, have);\\n                return max(include, exclude);\\n            }\\n        };\\n        return S[0] - S[N] - (go.f)(&go, 0, M);\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\n//\\n// TODO: question -- how do capture the mutable map m within a recursive closure?\\n//\\nuse std::cmp::min;\\nuse std::cmp::max;\\nuse std::collections::HashMap;\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn minimum_white_tiles(A: String, M: i32, K: i32) -> i32 {\\n        let N = A.len();\\n        let mut S = vec![0; N + 1];\\n        for i in (0..N).rev() {\\n            S[i] = if A.chars().nth(i).unwrap() == \\'1\\' { 1 } else { 0 } + S[i + 1];\\n        }\\n        let mut m = HashMap::new();\\n        struct Go<\\'a> { f: &\\'a dyn Fn(&Go, usize, i32) -> i32 }\\n        let go = Go {\\n            f: &|go, i, have| {\\n                if i == N || have == 0 {\\n                    return 0;\\n                }\\n                let k = format!(\"{},{}\", i, have);\\n                if !m.contains_key(&k) {\\n                    let j = min(i + K as usize, N);\\n                    let include = S[i] - S[j] + (go.f)(go, j, have - 1);\\n                    let exclude = (go.f)(go, i + 1, have);\\n                    m.insert(&k, max(include, exclude));\\n                }\\n                return *m.get(&k).unwrap();\\n            }\\n        };\\n        return S[0] - S[N] - (go.f)(&go, 0, M);\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nuse std::cmp::min;\\nuse std::cmp::max;\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nimpl Solution {\\n    pub fn minimum_white_tiles(A: String, M: i32, K: i32) -> i32 {\\n        let N = A.len();\\n        let mut S = vec![0; N + 1];\\n        for i in (0..N).rev() {\\n            S[i] = if A.chars().nth(i).unwrap() == \\'1\\' { 1 } else { 0 } + S[i + 1];\\n        }\\n        let mut dp = vec![vec![0; M as usize + 1]; N + 1];\\n        for have in 1..=M as usize {\\n            for i in (0..N).rev() {\\n                let j = min(i + K as usize, N);\\n                let include = S[i] - S[j] + dp[j][have - 1];\\n                let exclude = dp[i + 1][have];\\n                dp[i][have] = max(include, exclude);\\n            }\\n        }\\n        return S[0] - S[N] - dp[0][M as usize];\\n    }\\n}\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int minimumWhiteTiles(string A, int M, int K) {\\n        int N = A.size();\\n        VI S(N + 1);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            S[i] = A[i] - \\'0\\' + S[i + 1];\\n        fun go = [&](auto i, auto have) {\\n            if (A.size() <= i || !have)\\n                return 0;\\n            auto j = min(i + K, N);\\n            auto include = S[i] - S[j] + go(j, have - 1),\\n                 exclude = go(i + 1, have);\\n            return max(include, exclude);\\n        };\\n        return S[0] - S[N] - go(0, M);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minimumWhiteTiles(string A, int M, int K, Map m = {}) {\\n        int N = A.size();\\n        VI S(N + 1);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            S[i] = A[i] - \\'0\\' + S[i + 1];\\n        auto key = [](auto a, auto b) {\\n            stringstream ss; ss << a << \",\" << b;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto have) {\\n            if (A.size() <= i || !have)\\n                return 0;\\n            auto k = key(i, have);\\n            if (m.find(k) == m.end()) {\\n                auto j = min(i + K, N);\\n                auto include = S[i] - S[j] + go(j, have - 1),\\n                     exclude = go(i + 1, have);\\n                m[k] = max(include, exclude);\\n            }\\n            return m[k];\\n        };\\n        return S[0] - S[N] - go(0, M);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minimumWhiteTiles(string A, int M, int K) {\\n        int N = A.size();\\n        VI S(N + 1);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            S[i] = A[i] - \\'0\\' + S[i + 1];\\n        VVI dp(N + 1, VI(M + 1, 0));\\n        for (auto have{ 1 }; have <= M; ++have) {\\n            for (auto i{ N - 1 }; 0 <= i; --i) {\\n                auto j = min(i + K, N);\\n                auto include = S[i] - S[j] + dp[j][have - 1],\\n                     exclude = dp[i + 1][have];\\n                dp[i][have] = max(include, exclude);\\n            }\\n        }\\n        return S[0] - S[N] - dp[0][M];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minimumWhiteTiles(A: String, M: Int, K: Int): Int {\\n        var N = A.length\\n        var S = IntArray(N + 1) { 0 }\\n        for (i in N - 1 downTo 0)\\n            S[i] = (if (A[i] == \\'1\\') 1 else 0) + S[i + 1]\\n        fun go(i: Int = 0, have: Int = M): Int {\\n            if (i == N || have == 0)\\n                return 0\\n            var j = Math.min(i + K, N)\\n            var include = S[i] - S[j] + go(j, have - 1)\\n            var exclude = go(i + 1, have)\\n            return Math.max(include, exclude)\\n        }\\n        return S[0] - S[N] - go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minimumWhiteTiles(A: String, M: Int, K: Int): Int {\\n        var N = A.length\\n        var S = IntArray(N + 1) { 0 }\\n        for (i in N - 1 downTo 0)\\n            S[i] = (if (A[i] == \\'1\\') 1 else 0) + S[i + 1]\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, have: Int = M): Int {\\n            if (i == N || have == 0)\\n                return 0\\n            var k = \"$i,$have\"\\n            if (!m.contains(k)) {\\n                var j = Math.min(i + K, N)\\n                var include = S[i] - S[j] + go(j, have - 1)\\n                var exclude = go(i + 1, have)\\n                m[k] = Math.max(include, exclude)\\n            }\\n            return m[k]!!\\n        }\\n        return S[0] - S[N] - go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minimumWhiteTiles(A: String, M: Int, K: Int): Int {\\n        var N = A.length\\n        var S = IntArray(N + 1) { 0 }\\n        for (i in N - 1 downTo 0)\\n            S[i] = (if (A[i] == \\'1\\') 1 else 0) + S[i + 1]\\n        var dp = Array(N + 1) { IntArray(M + 1) { 0 } }\\n        for (have in 1..M) {\\n            for (i in N - 1 downTo 0) {\\n                var j = Math.min(i + K, N)\\n                var include = S[i] - S[j] + dp[j][have - 1]\\n                var exclude = dp[i + 1][have]\\n                dp[i][have] = Math.max(include, exclude)\\n            }\\n        }\\n        return S[0] - S[N] - dp[0][M]\\n    }\\n}\\n```\n```\\nlet minimumWhiteTiles = (A, M, K) => {\\n    let N = A.length;\\n    let S = Array(N + 1).fill(0);\\n    for (let i = N - 1; 0 <= i; --i)\\n        S[i] = Number(A[i] == \\'1\\') + S[i + 1];\\n    let go = (i = 0, have = M) => {\\n        if (i == N || !have)\\n            return 0;\\n        let j = Math.min(i + K, N);\\n        let include = S[i] - S[j] + go(j, have - 1),\\n            exclude = go(i + 1, have);\\n        return Math.max(include, exclude);\\n    };\\n    return S[0] - S[N] - go();\\n};\\n```\n```\\nlet minimumWhiteTiles = (A, M, K, m = new Map()) => {\\n    let N = A.length;\\n    let S = Array(N + 1).fill(0);\\n    for (let i = N - 1; 0 <= i; --i)\\n        S[i] = Number(A[i] == \\'1\\') + S[i + 1];\\n    let go = (i = 0, have = M) => {\\n        if (i == N || !have)\\n            return 0;\\n        let k = `${i},${have}`;\\n        if (!m.has(k)) {\\n            let j = Math.min(i + K, N);\\n            let include = S[i] - S[j] + go(j, have - 1),\\n                exclude = go(i + 1, have);\\n            m.set(k, Math.max(include, exclude));\\n        }\\n        return m.get(k);\\n    };\\n    return S[0] - S[N] - go();\\n};\\n```\n```\\nlet minimumWhiteTiles = (A, M, K, m = new Map()) => {\\n    let N = A.length;\\n    let S = Array(N + 1).fill(0);\\n    for (let i = N - 1; 0 <= i; --i)\\n        S[i] = Number(A[i] == \\'1\\') + S[i + 1];\\n    let dp = [...Array(N + 1)].map(_ => Array(M + 1).fill(0));\\n    for (let have = 1; have <= M; ++have) {\\n        for (let i = N - 1; 0 <= i; --i) {\\n            let j = Math.min(i + K, N);\\n            let include = S[i] - S[j] + dp[j][have - 1],\\n                exclude = dp[i + 1][have];\\n            dp[i][have] = Math.max(include, exclude);\\n        }\\n    }\\n    return S[0] - S[N] - dp[0][M];\\n};\\n```\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, A: str, M: int, K: int) -> int:\\n        N = len(A)\\n        S = [0] * (N + 1)\\n        for i in range(N - 1, -1, -1):\\n            S[i] = int(A[i] == \\'1\\') + S[i + 1]\\n        def go(i = 0, have = M):\\n            if i == N or not have:\\n                return 0\\n            j = min(i + K, N)\\n            include = S[i] - S[j] + go(j, have - 1)\\n            exclude = go(i + 1, have)\\n            return max(include, exclude)\\n        return S[0] - S[N] - go()\\n```\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, A: str, M: int, K: int) -> int:\\n        N = len(A)\\n        S = [0] * (N + 1)\\n        for i in range(N - 1, -1, -1):\\n            S[i] = int(A[i] == \\'1\\') + S[i + 1]\\n        @cache\\n        def go(i = 0, have = M):\\n            if i == N or not have:\\n                return 0\\n            j = min(i + K, N)\\n            include = S[i] - S[j] + go(j, have - 1)\\n            exclude = go(i + 1, have)\\n            return max(include, exclude)\\n        return S[0] - S[N] - go()\\n```\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, A: str, M: int, K: int) -> int:\\n        N = len(A)\\n        S = [0] * (N + 1)\\n        for i in range(N - 1, -1, -1):\\n            S[i] = int(A[i] == \\'1\\') + S[i + 1]\\n        dp = [[0] * (M + 1) for _ in range(N + 1)]\\n        for have in range(1, M + 1):\\n            for i in range(N - 1, -1, -1):\\n                j = min(i + K, N)\\n                include = S[i] - S[j] + dp[j][have - 1]\\n                exclude = dp[i + 1][have]\\n                dp[i][have] = max(include, exclude)\\n        return S[0] - S[N] - dp[0][M]\\n```\n```\\nuse std::cmp::min;\\nuse std::cmp::max;\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn minimum_white_tiles(A: String, M: i32, K: i32) -> i32 {\\n        let N = A.len();\\n        let mut S = vec![0; N + 1];\\n        for i in (0..N).rev() {\\n            S[i] = if A.chars().nth(i).unwrap() == \\'1\\' { 1 } else { 0 } + S[i + 1];\\n        }\\n        struct Go<\\'a> { f: &\\'a dyn Fn(&Go, usize, i32) -> i32 }\\n        let go = Go {\\n            f: &|go, i, have| {\\n                if i == N || have == 0 {\\n                    return 0;\\n                }\\n                let j = min(i + K as usize, N);\\n                let include = S[i] - S[j] + (go.f)(go, j, have - 1);\\n                let exclude = (go.f)(go, i + 1, have);\\n                return max(include, exclude);\\n            }\\n        };\\n        return S[0] - S[N] - (go.f)(&go, 0, M);\\n    }\\n}\\n```\n```\\n//\\n// TODO: question -- how do capture the mutable map m within a recursive closure?\\n//\\nuse std::cmp::min;\\nuse std::cmp::max;\\nuse std::collections::HashMap;\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn minimum_white_tiles(A: String, M: i32, K: i32) -> i32 {\\n        let N = A.len();\\n        let mut S = vec![0; N + 1];\\n        for i in (0..N).rev() {\\n            S[i] = if A.chars().nth(i).unwrap() == \\'1\\' { 1 } else { 0 } + S[i + 1];\\n        }\\n        let mut m = HashMap::new();\\n        struct Go<\\'a> { f: &\\'a dyn Fn(&Go, usize, i32) -> i32 }\\n        let go = Go {\\n            f: &|go, i, have| {\\n                if i == N || have == 0 {\\n                    return 0;\\n                }\\n                let k = format!(\"{},{}\", i, have);\\n                if !m.contains_key(&k) {\\n                    let j = min(i + K as usize, N);\\n                    let include = S[i] - S[j] + (go.f)(go, j, have - 1);\\n                    let exclude = (go.f)(go, i + 1, have);\\n                    m.insert(&k, max(include, exclude));\\n                }\\n                return *m.get(&k).unwrap();\\n            }\\n        };\\n        return S[0] - S[N] - (go.f)(&go, 0, M);\\n    }\\n}\\n```\n```\\nuse std::cmp::min;\\nuse std::cmp::max;\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nimpl Solution {\\n    pub fn minimum_white_tiles(A: String, M: i32, K: i32) -> i32 {\\n        let N = A.len();\\n        let mut S = vec![0; N + 1];\\n        for i in (0..N).rev() {\\n            S[i] = if A.chars().nth(i).unwrap() == \\'1\\' { 1 } else { 0 } + S[i + 1];\\n        }\\n        let mut dp = vec![vec![0; M as usize + 1]; N + 1];\\n        for have in 1..=M as usize {\\n            for i in (0..N).rev() {\\n                let j = min(i + K as usize, N);\\n                let include = S[i] - S[j] + dp[j][have - 1];\\n                let exclude = dp[i + 1][have];\\n                dp[i][have] = max(include, exclude);\\n            }\\n        }\\n        return S[0] - S[N] - dp[0][M as usize];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int minimumWhiteTiles(string A, int M, int K) {\\n        int N = A.size();\\n        VI S(N + 1);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            S[i] = A[i] - \\'0\\' + S[i + 1];\\n        fun go = [&](auto i, auto have) {\\n            if (A.size() <= i || !have)\\n                return 0;\\n            auto j = min(i + K, N);\\n            auto include = S[i] - S[j] + go(j, have - 1),\\n                 exclude = go(i + 1, have);\\n            return max(include, exclude);\\n        };\\n        return S[0] - S[N] - go(0, M);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minimumWhiteTiles(string A, int M, int K, Map m = {}) {\\n        int N = A.size();\\n        VI S(N + 1);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            S[i] = A[i] - \\'0\\' + S[i + 1];\\n        auto key = [](auto a, auto b) {\\n            stringstream ss; ss << a << \",\" << b;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto have) {\\n            if (A.size() <= i || !have)\\n                return 0;\\n            auto k = key(i, have);\\n            if (m.find(k) == m.end()) {\\n                auto j = min(i + K, N);\\n                auto include = S[i] - S[j] + go(j, have - 1),\\n                     exclude = go(i + 1, have);\\n                m[k] = max(include, exclude);\\n            }\\n            return m[k];\\n        };\\n        return S[0] - S[N] - go(0, M);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minimumWhiteTiles(string A, int M, int K) {\\n        int N = A.size();\\n        VI S(N + 1);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            S[i] = A[i] - \\'0\\' + S[i + 1];\\n        VVI dp(N + 1, VI(M + 1, 0));\\n        for (auto have{ 1 }; have <= M; ++have) {\\n            for (auto i{ N - 1 }; 0 <= i; --i) {\\n                auto j = min(i + K, N);\\n                auto include = S[i] - S[j] + dp[j][have - 1],\\n                     exclude = dp[i + 1][have];\\n                dp[i][have] = max(include, exclude);\\n            }\\n        }\\n        return S[0] - S[N] - dp[0][M];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870731,
                "title": "c-iterative-dp-knsapsack",
                "content": "```class Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int num, int carpetlen) {\\n      //knapsack type problem\\n      int n = floor.length() ;\\n      int dp[n+1][num+1] ;\\n      memset(dp,0,sizeof(dp)) ;\\n      for(int i=n-1;i>=0;i--)\\n      {\\n          for(int j=0;j<=num;j++)\\n          {\\n             if(j==0) dp[i][j] = (floor[i]==\\'1\\')?dp[i+1][j]+1:dp[i+1][j] ;\\n             else if(i+carpetlen >= n) dp[i][j] = 0 ;\\n             else{\\n                 if(floor[i]==\\'0\\'){\\n                     dp[i][j] = dp[i+1][j] ;\\n                 }\\n                 else{\\n                     dp[i][j] = min(1+dp[i+1][j],dp[i+carpetlen][j-1]) ;\\n                 }\\n             }\\n          }\\n      }\\n     return dp[0][num] ;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int num, int carpetlen) {\\n      //knapsack type problem\\n      int n = floor.length() ;\\n      int dp[n+1][num+1] ;\\n      memset(dp,0,sizeof(dp)) ;\\n      for(int i=n-1;i>=0;i--)\\n      {\\n          for(int j=0;j<=num;j++)\\n          {\\n             if(j==0) dp[i][j] = (floor[i]==\\'1\\')?dp[i+1][j]+1:dp[i+1][j] ;\\n             else if(i+carpetlen >= n) dp[i][j] = 0 ;\\n             else{\\n                 if(floor[i]==\\'0\\'){\\n                     dp[i][j] = dp[i+1][j] ;\\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 1870132,
                "title": "dp-solution",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        dp=[[0 for i in range(numCarpets+1)] for j in range(len(floor)+1)]\\n\\n        for i in range(1,len(floor)+1):\\n            if floor[i-1]==\\'1\\':\\n                dp[i][0]=dp[i-1][0]+1\\n            else:\\n                dp[i][0]=dp[i-1][0]\\n\\n        for j in range(1,numCarpets+1):\\n            for i in range(1,len(floor)+1):\\n                dp[i][j]=min(dp[max(0,i-carpetLen)][j-1],dp[i-1][j]+(floor[i-1]==\\'1\\'))\\n        return dp[-1][numCarpets]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        dp=[[0 for i in range(numCarpets+1)] for j in range(len(floor)+1)]\\n\\n        for i in range(1,len(floor)+1):\\n            if floor[i-1]==\\'1\\':\\n                dp[i][0]=dp[i-1][0]+1\\n            else:\\n                dp[i][0]=dp[i-1][0]\\n\\n        for j in range(1,numCarpets+1):\\n            for i in range(1,len(floor)+1):\\n                dp[i][j]=min(dp[max(0,i-carpetLen)][j-1],dp[i-1][j]+(floor[i-1]==\\'1\\'))\\n        return dp[-1][numCarpets]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870008,
                "title": "top-down-dynamic-programming-knapsack-approach",
                "content": "Time Complexity : O(n*m) where m is num of carpets\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n    \\n    int solve(string &str, int n, int pos, int carpetLen, vector<int> &cnt)\\n    {\\n        if(pos >= str.length())\\n            return 0;\\n        \\n        if(n == 0)\\n            return cnt[pos];\\n        \\n        \\n        if(dp[pos][n] != -1)\\n            return dp[pos][n];\\n        \\n        int op1 = 0, op2 = 0;\\n        \\n        while(str[pos] == \\'0\\')\\n            pos++;\\n        \\n        if(pos >= str.length())\\n        {\\n            return 0;\\n        }\\n        \\n        // if(str[pos] == \\'0\\')\\n        // {\\n        //     return dp[pos][n] = solve(str, n, pos + 1, carpetLen, cnt);\\n        // }\\n        \\n        if(str[pos] == \\'1\\')\\n        {\\n            op1 = solve(str, n - 1, pos + carpetLen, carpetLen, cnt); // place the carpet\\n            \\n            op2 = 1 + solve(str, n, pos + 1, carpetLen, cnt); // did not place the carpet, so the white tile is still visisble\\n        }\\n        \\n        //cout<<op1<<\" \"<<op2<<endl;\\n        return dp[pos][n] = min(op1, op2);\\n            \\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n        \\n        int sz = floor.length();\\n        \\n        vector<int> cnt(sz + 1, 0);\\n        \\n        cnt[sz - 1] = (floor[sz - 1] == \\'1\\') ? 1 : 0;\\n        \\n        for(int i = sz - 2; i >= 0; i--)\\n        {\\n            cnt[i] =  cnt[i + 1] + (floor[i] == \\'1\\'); \\n        }\\n        \\n        \\n        // for(int x : cnt)\\n        //     cout<<x<<\" \";\\n        \\n        //cout<<endl;\\n        \\n        dp.resize(sz + 1, vector<int>(numCarpets + 1, -1));\\n        \\n        return solve(floor, numCarpets, 0, carpetLen, cnt);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n    \\n    int solve(string &str, int n, int pos, int carpetLen, vector<int> &cnt)\\n    {\\n        if(pos >= str.length())\\n            return 0;\\n        \\n        if(n == 0)\\n            return cnt[pos];\\n        \\n        \\n        if(dp[pos][n] != -1)\\n            return dp[pos][n];\\n        \\n        int op1 = 0, op2 = 0;\\n        \\n        while(str[pos] == \\'0\\')\\n            pos++;\\n        \\n        if(pos >= str.length())\\n        {\\n            return 0;\\n        }\\n        \\n        // if(str[pos] == \\'0\\')\\n        // {\\n        //     return dp[pos][n] = solve(str, n, pos + 1, carpetLen, cnt);\\n        // }\\n        \\n        if(str[pos] == \\'1\\')\\n        {\\n            op1 = solve(str, n - 1, pos + carpetLen, carpetLen, cnt); // place the carpet\\n            \\n            op2 = 1 + solve(str, n, pos + 1, carpetLen, cnt); // did not place the carpet, so the white tile is still visisble\\n        }\\n        \\n        //cout<<op1<<\" \"<<op2<<endl;\\n        return dp[pos][n] = min(op1, op2);\\n            \\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n        \\n        int sz = floor.length();\\n        \\n        vector<int> cnt(sz + 1, 0);\\n        \\n        cnt[sz - 1] = (floor[sz - 1] == \\'1\\') ? 1 : 0;\\n        \\n        for(int i = sz - 2; i >= 0; i--)\\n        {\\n            cnt[i] =  cnt[i + 1] + (floor[i] == \\'1\\'); \\n        }\\n        \\n        \\n        // for(int x : cnt)\\n        //     cout<<x<<\" \";\\n        \\n        //cout<<endl;\\n        \\n        dp.resize(sz + 1, vector<int>(numCarpets + 1, -1));\\n        \\n        return solve(floor, numCarpets, 0, carpetLen, cnt);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1869875,
                "title": "java-easy-to-understand-solution-dp-recursive-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int ded = 0;\\n        int[][] dp = new int[numCarpets+1][floor.length()];\\n        for(int i = 0; i < floor.length(); i++) {\\n            if(floor.charAt(i) == \\'1\\') ded++;\\n        }\\n        if(ded == floor.length()){\\n            return ded - numCarpets*carpetLen>=0?ded-numCarpets*carpetLen:0;\\n        }\\n        \\n        if(ded == 0){\\n            return 0;\\n        }\\n        \\n        return ded - helper(floor, numCarpets, carpetLen, 0, dp);\\n    }\\n    \\n    private int helper(String floor, int numCarpets, int carpetLen, int start, int[][] dp){\\n        if(start >= floor.length() || numCarpets==0) return 0;\\n        \\n        if(dp[numCarpets][start]!=0) return dp[numCarpets][start];\\n        \\n        int take= calc(floor, start,  start + carpetLen);\\n        if(floor.charAt(start) == \\'1\\') {\\n            return dp[numCarpets][start] = Math.max((take + helper(floor, numCarpets-1, carpetLen, start+carpetLen, dp)),\\n                           helper(floor, numCarpets, carpetLen, start+1, dp));\\n        }else if(floor.charAt(start) == \\'0\\'){\\n            return dp[numCarpets][start] = helper(floor, numCarpets, carpetLen, start+1, dp);\\n        }\\n        return dp[numCarpets][start];\\n    }\\n    \\n    private int calc(String floor, int start, int end) {\\n        int answer = 0;\\n        for(int i = start; i < end && i < floor.length() ; i++) {\\n            if(floor.charAt(i) == \\'1\\') answer++;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int ded = 0;\\n        int[][] dp = new int[numCarpets+1][floor.length()];\\n        for(int i = 0; i < floor.length(); i++) {\\n            if(floor.charAt(i) == \\'1\\') ded++;\\n        }\\n        if(ded == floor.length()){\\n            return ded - numCarpets*carpetLen>=0?ded-numCarpets*carpetLen:0;\\n        }\\n        \\n        if(ded == 0){\\n            return 0;\\n        }\\n        \\n        return ded - helper(floor, numCarpets, carpetLen, 0, dp);\\n    }\\n    \\n    private int helper(String floor, int numCarpets, int carpetLen, int start, int[][] dp){\\n        if(start >= floor.length() || numCarpets==0) return 0;\\n        \\n        if(dp[numCarpets][start]!=0) return dp[numCarpets][start];\\n        \\n        int take= calc(floor, start,  start + carpetLen);\\n        if(floor.charAt(start) == \\'1\\') {\\n            return dp[numCarpets][start] = Math.max((take + helper(floor, numCarpets-1, carpetLen, start+carpetLen, dp)),\\n                           helper(floor, numCarpets, carpetLen, start+1, dp));\\n        }else if(floor.charAt(start) == \\'0\\'){\\n            return dp[numCarpets][start] = helper(floor, numCarpets, carpetLen, start+1, dp);\\n        }\\n        return dp[numCarpets][start];\\n    }\\n    \\n    private int calc(String floor, int start, int end) {\\n        int answer = 0;\\n        for(int i = start; i < end && i < floor.length() ; i++) {\\n            if(floor.charAt(i) == \\'1\\') answer++;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869157,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        char [] arr = floor.toCharArray();\\n        int [] pre = new int[arr.length];\\n        pre[0] = (arr[0]==\\'1\\'?1:0);\\n        for(int i = 1;i<arr.length;i++){\\n            if(arr[i]==\\'1\\'){\\n                pre[i] = (pre[i-1]+1);\\n            }else{\\n                pre[i] = pre[i-1];\\n            }\\n        }\\n        int [][] dp = new int[pre.length+1][numCarpets+1];\\n        for(int [] row : dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return pre[pre.length-1]-solve(pre,0,numCarpets,carpetLen,dp);\\n    }\\n    private int solve(int [] pre,int idx,int num,int carpetLen,int[][] dp){\\n        if(idx>=pre.length){\\n            return 0;\\n        }\\n        if(num<=0){\\n            return 0;\\n        }\\n        if(dp[idx][num]!=-1){\\n            return dp[idx][num];\\n        }\\n        int end = (idx+carpetLen-1>=pre.length)?pre.length-1:(idx+carpetLen-1);\\n        // place carpet at idx.\\n        int best = getSum(pre,idx,end) + solve(pre,end+1,num-1,carpetLen,dp);\\n        //dont place carpet at idx.\\n        best = Math.max(solve(pre,idx+1,num,carpetLen,dp),best);\\n        \\n        return dp[idx][num]=best;\\n    }\\n    \\n    private int getSum(int [] pre,int start,int end){\\n        if(start>0){\\n            return pre[end] - pre[start-1];\\n        }\\n        return pre[end];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        char [] arr = floor.toCharArray();\\n        int [] pre = new int[arr.length];\\n        pre[0] = (arr[0]==\\'1\\'?1:0);\\n        for(int i = 1;i<arr.length;i++){\\n            if(arr[i]==\\'1\\'){\\n                pre[i] = (pre[i-1]+1);\\n            }else{\\n                pre[i] = pre[i-1];\\n            }\\n        }\\n        int [][] dp = new int[pre.length+1][numCarpets+1];\\n        for(int [] row : dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return pre[pre.length-1]-solve(pre,0,numCarpets,carpetLen,dp);\\n    }\\n    private int solve(int [] pre,int idx,int num,int carpetLen,int[][] dp){\\n        if(idx>=pre.length){\\n            return 0;\\n        }\\n        if(num<=0){\\n            return 0;\\n        }\\n        if(dp[idx][num]!=-1){\\n            return dp[idx][num];\\n        }\\n        int end = (idx+carpetLen-1>=pre.length)?pre.length-1:(idx+carpetLen-1);\\n        // place carpet at idx.\\n        int best = getSum(pre,idx,end) + solve(pre,end+1,num-1,carpetLen,dp);\\n        //dont place carpet at idx.\\n        best = Math.max(solve(pre,idx+1,num,carpetLen,dp),best);\\n        \\n        return dp[idx][num]=best;\\n    }\\n    \\n    private int getSum(int [] pre,int start,int end){\\n        if(start>0){\\n            return pre[end] - pre[start-1];\\n        }\\n        return pre[end];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867874,
                "title": "debug",
                "content": "I am doing anything wrong?\\n```\\nclass Solution {\\npublic:\\n    int cl;\\n    vector<vector<int>> mp;\\n    int hideTile(vector<int> &arr, int rem, int i, int w) {\\n        if (rem == 0) return w;\\n        if (i >= arr.size()) return w;\\n        if (w <= 0) return 0;\\n        \\n        if (mp[i][rem]!=0) {\\n            return mp[i][rem];\\n        }\\n        int ind = i+cl;\\n        if (ind >= arr.size()) {\\n            ind = arr.size()-1;\\n        }\\n        \\n        int ans = hideTile(arr, rem-1, i+cl, w-(arr[ind]-arr[i]));\\n        int skipCurr = hideTile(arr, rem, i+1, w);\\n        \\n        mp[i][rem] = min(ans, skipCurr);\\n        return mp[i][rem];\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<int> pf(floor.length()+1, 0);\\n        \\n        mp = vector<vector<int>> (1002, vector<int> (1002, 0));\\n        for (int i = 0; i < floor.length(); i++) {\\n            if (floor[i] == \\'1\\') {\\n                pf[i+1] += pf[i] + 1;\\n            } else {\\n                pf[i+1] = pf[i];\\n            }\\n        }\\n        cl = carpetLen;\\n        \\n        return hideTile(pf, numCarpets , 0, pf[floor.length()]);\\n    }\\n};",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int cl;\\n    vector<vector<int>> mp;\\n    int hideTile(vector<int> &arr, int rem, int i, int w) {\\n        if (rem == 0) return w;\\n        if (i >= arr.size()) return w;\\n        if (w <= 0) return 0;\\n        \\n        if (mp[i][rem]!=0) {\\n            return mp[i][rem];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1867834,
                "title": "python-dp-solution-optimized",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n\\t\\t# number of white tiles up in the first i tiles\\n        c_sums=[]\\n        cur=0\\n        for x in floor:\\n            cur+=int(x)\\n            c_sums.append(cur)\\n\\n        if carpetLen == 1:\\n            return max(0,c_sums[-1]-numCarpets)\\n\\t\\t\\n\\t\\t# the minimum number of white tiles still visible when using k tiles to cover the first i tiles \\n        @cache\\n        def dp(i,k):\\n\\t\\t\\t# no tiles left\\n            if  k <= 0:\\n                return c_sums[i-1]\\n\\t\\t\\t\\t\\n            # cover all white tiles\\n            if i <= k*carpetLen:\\n                return 0\\n\\t\\t\\t\\t\\n\\t\\t\\t# everytile is white\\n            if i == c_sums[i-1]:\\n                return i-k*carpetLen\\n\\t\\t\\t\\n\\t\\t\\t# either not cover the ith(last) tile or cover it \\n            return min(dp(i-1,k) + int(floor[i-1]), dp(i-carpetLen,k-1)) \\n        \\n        return dp(len(floor),numCarpets)\\n```\\nNote: without writing special cases it gives TLE which is:\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        @cache\\n        def dp(i,k):            \\n            if i<=k*carpetLen:\\n                return 0\\n\\n            return min(dp(i-1,k) + int(floor[i-1]), dp(i-carpetLen,k-1) if k>0 else float(\"inf\")) \\n        \\n        return dp(len(floor),numCarpets)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n\\t\\t# number of white tiles up in the first i tiles\\n        c_sums=[]\\n        cur=0\\n        for x in floor:\\n            cur+=int(x)\\n            c_sums.append(cur)\\n\\n        if carpetLen == 1:\\n            return max(0,c_sums[-1]-numCarpets)\\n\\t\\t\\n\\t\\t# the minimum number of white tiles still visible when using k tiles to cover the first i tiles \\n        @cache\\n        def dp(i,k):\\n\\t\\t\\t# no tiles left\\n            if  k <= 0:\\n                return c_sums[i-1]\\n\\t\\t\\t\\t\\n            # cover all white tiles\\n            if i <= k*carpetLen:\\n                return 0\\n\\t\\t\\t\\t\\n\\t\\t\\t# everytile is white\\n            if i == c_sums[i-1]:\\n                return i-k*carpetLen\\n\\t\\t\\t\\n\\t\\t\\t# either not cover the ith(last) tile or cover it \\n            return min(dp(i-1,k) + int(floor[i-1]), dp(i-carpetLen,k-1)) \\n        \\n        return dp(len(floor),numCarpets)\\n```\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        @cache\\n        def dp(i,k):            \\n            if i<=k*carpetLen:\\n                return 0\\n\\n            return min(dp(i-1,k) + int(floor[i-1]), dp(i-carpetLen,k-1) if k>0 else float(\"inf\")) \\n        \\n        return dp(len(floor),numCarpets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867643,
                "title": "java-top-down-tle-then-optimized-to-bottom-up",
                "content": "I have top-down solution with memoization but TLE\\n\\nThe requirement is find minimum number of white after covered by carpets\\nIdea: Ahh, If we able to find maximum white we could cover by carpets then the rest of white are minimum\\nImplement: top-down approach TLE but they show us that programming depending on 2 parameter: number of floor and number of carpet so far\\nBottom-up: call dp[i][k] is maximum white we could cover at first ith floor(include ith floor) with k carpet.\\ndp[floor.length()][numOfCarpet] is our solution, but final solution is maxWhite - dp[floor.length()][numOfCarpet]\\n\\n```\\n\\nclass Solution {\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int countWhite = 0;\\n        char[] floorArr = floor.toCharArray();\\n        for(char c : floorArr) {\\n            if (c == \\'1\\') countWhite++;\\n        }\\n        \\n        int numOfWhiteSoFar = 0;\\n        int[] rangeWhite = new int[floorArr.length];\\n        for(int i = 0; i < floorArr.length; i++) {\\n            if (floorArr[i] == \\'1\\') numOfWhiteSoFar++;\\n            rangeWhite[i] = numOfWhiteSoFar;\\n        }\\n        \\n        Integer[][] cache = new Integer[numCarpets + 1][floorArr.length + 1];\\n        int max= maximumWhiteTiles(floorArr, numCarpets, carpetLen, 0, cache, rangeWhite);\\n        return countWhite - max;\\n    }\\n    \\n    private int maximumWhiteTiles(char[] floorArr, int numCarpets, int carpetLen, int start\\n                                 , Integer[][] cache, int[] rangeWhite) {\\n        \\n        // start from a index what is maximum white tiles you could cover;\\n        if (numCarpets == 0) return 0;\\n        if (start >= floorArr.length) return 0;\\n        \\n        if (cache[numCarpets][start] != null) return cache[numCarpets][start];\\n        int max = 0;\\n        for(int i = start; i < floorArr.length; i++) {\\n            int end = floorArr.length - 1 <= i + carpetLen - 1 ? floorArr.length - 1 : i + carpetLen - 1;\\n            int rangeWhileFromIToEnd = rangeWhite[end] - (i - 1 >= 0 ? rangeWhite[i - 1] : 0);\\n            int val = rangeWhileFromIToEnd + maximumWhiteTiles(floorArr, numCarpets - 1, carpetLen, i + carpetLen, cache, rangeWhite);\\n            max = Math.max(max, val);\\n        }\\n        \\n        cache[numCarpets][start] = max;\\n        return max;\\n        \\n    }\\n    \\n}\\n```\\n\\nThen I have optimized to bottom-up\\n```\\n\\tpublic int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n           int numOfWhite = 0;\\n           int[] prefix = new int[floor.length()];\\n           for(int i = 0; i < floor.length(); i++) {\\n               if (floor.charAt(i) == \\'1\\') {\\n                   numOfWhite++;\\n               }\\n               prefix[i] = numOfWhite;\\n           }\\n           \\n           int[][] dp = new int[floor.length() + 1][numCarpets + 1];\\n           for(int i = 1; i <= floor.length(); i++) { /// number of floor \\n               for(int j = 1; j <= numCarpets; j++) {\\n                   dp[i][j] = (i - carpetLen >= 0 ? dp[i - carpetLen][j - 1] : 0) + \\n                       prefix[i - 1] - (i - 1 - carpetLen >= 0 ? prefix[i - 1 - carpetLen] : 0);\\n                   dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);\\n               }\\n           }\\n           \\n           return numOfWhite - dp[floor.length()][numCarpets];\\n       }\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int countWhite = 0;\\n        char[] floorArr = floor.toCharArray();\\n        for(char c : floorArr) {\\n            if (c == \\'1\\') countWhite++;\\n        }\\n        \\n        int numOfWhiteSoFar = 0;\\n        int[] rangeWhite = new int[floorArr.length];\\n        for(int i = 0; i < floorArr.length; i++) {\\n            if (floorArr[i] == \\'1\\') numOfWhiteSoFar++;\\n            rangeWhite[i] = numOfWhiteSoFar;\\n        }\\n        \\n        Integer[][] cache = new Integer[numCarpets + 1][floorArr.length + 1];\\n        int max= maximumWhiteTiles(floorArr, numCarpets, carpetLen, 0, cache, rangeWhite);\\n        return countWhite - max;\\n    }\\n    \\n    private int maximumWhiteTiles(char[] floorArr, int numCarpets, int carpetLen, int start\\n                                 , Integer[][] cache, int[] rangeWhite) {\\n        \\n        // start from a index what is maximum white tiles you could cover;\\n        if (numCarpets == 0) return 0;\\n        if (start >= floorArr.length) return 0;\\n        \\n        if (cache[numCarpets][start] != null) return cache[numCarpets][start];\\n        int max = 0;\\n        for(int i = start; i < floorArr.length; i++) {\\n            int end = floorArr.length - 1 <= i + carpetLen - 1 ? floorArr.length - 1 : i + carpetLen - 1;\\n            int rangeWhileFromIToEnd = rangeWhite[end] - (i - 1 >= 0 ? rangeWhite[i - 1] : 0);\\n            int val = rangeWhileFromIToEnd + maximumWhiteTiles(floorArr, numCarpets - 1, carpetLen, i + carpetLen, cache, rangeWhite);\\n            max = Math.max(max, val);\\n        }\\n        \\n        cache[numCarpets][start] = max;\\n        return max;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867595,
                "title": "c-simple-easy-explanation-with-code-easy-to-understand",
                "content": "The most basic intuition we can get after seeing the problem is that , **for every index i ( 0 <= i < n )** in the array there are **2 possibilites** - \\n\\n**1. You put a carpet** \\n\\n    So if you decide to put carpet on ith block , then you don\\'t have to worry about the indices i , i + 1 , i + 2 ... i + len - 1. (len -> is carpet length)\\n\\t\\n   This will cost you one carpet and now you have to do the same thing from index **i + len** with **numCarpet - 1** .\\n   \\n2. **You do not put a carpet**\\n      \\n\\tNow , if the ith tile is white this will increase the **white tile count by 1**.\\n\\tAnd now you have to do the same thing from index **i + 1** with **numCarpet**.\\n\\t\\n**Your answer will be the minimum of 2 cases.**\\n\\n**Code - **\\n\\n...\\nint dp[1001][1001] ; \\n\\n  int fun(string &s , int &k , int c , int i) { \\n\\n  \\t     int n = s.length() ; \\n\\n  \\t     if (c == 0) {\\n               \\n              int x = 0 ; \\n  \\t     \\t    for (int j = i ; j < n ; j ++ ) {\\n\\n  \\t     \\t    \\t     if (s[j] == \\'1\\') x ++; \\n  \\t     \\t    }\\n\\n  \\t     \\t    return x ; \\n  \\t     }\\n\\n  \\t     if ((n - i) <= k || i >= n ) return 0 ;  \\n\\n  \\t     if (dp[c][i] != -1 ) return dp[c][i] ; \\n\\n  \\t     int q1 = fun(s , k , c - 1 , i + k) ; \\n  \\t     int q2 = ((s[i] == \\'1\\') ? 1 : 0) + fun(s , k , c , i + 1) ;\\n\\n  \\t     return dp[c][i] = min(q1,q2) ; \\n  }\\n \\n  int minimumWhiteTiles(string s, int c, int k) {\\n\\n         memset(dp , -1 , sizeof(dp)) ; \\n         return fun(s , k , c , 0); \\n    }\\n\\t...",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "The most basic intuition we can get after seeing the problem is that , **for every index i ( 0 <= i < n )** in the array there are **2 possibilites** - \\n\\n**1. You put a carpet** \\n\\n    So if you decide to put carpet on ith block , then you don\\'t have to worry about the indices i , i + 1 , i + 2 ... i + len - 1. (len -> is carpet length)\\n\\t\\n   This will cost you one carpet and now you have to do the same thing from index **i + len** with **numCarpet - 1** .\\n   \\n2. **You do not put a carpet**\\n      \\n\\tNow , if the ith tile is white this will increase the **white tile count by 1**.\\n\\tAnd now you have to do the same thing from index **i + 1** with **numCarpet**.\\n\\t\\n**Your answer will be the minimum of 2 cases.**\\n\\n**Code - **\\n\\n...\\nint dp[1001][1001] ; \\n\\n  int fun(string &s , int &k , int c , int i) { \\n\\n  \\t     int n = s.length() ; \\n\\n  \\t     if (c == 0) {\\n               \\n              int x = 0 ; \\n  \\t     \\t    for (int j = i ; j < n ; j ++ ) {\\n\\n  \\t     \\t    \\t     if (s[j] == \\'1\\') x ++; \\n  \\t     \\t    }\\n\\n  \\t     \\t    return x ; \\n  \\t     }\\n\\n  \\t     if ((n - i) <= k || i >= n ) return 0 ;  \\n\\n  \\t     if (dp[c][i] != -1 ) return dp[c][i] ; \\n\\n  \\t     int q1 = fun(s , k , c - 1 , i + k) ; \\n  \\t     int q2 = ((s[i] == \\'1\\') ? 1 : 0) + fun(s , k , c , i + 1) ;\\n\\n  \\t     return dp[c][i] = min(q1,q2) ; \\n  }\\n \\n  int minimumWhiteTiles(string s, int c, int k) {\\n\\n         memset(dp , -1 , sizeof(dp)) ; \\n         return fun(s , k , c , 0); \\n    }\\n\\t...",
                "codeTag": "Unknown"
            },
            {
                "id": 1867528,
                "title": "python-straight-forward-dp-solution-with-explanations",
                "content": "We can divide the problem into sub problems - where each sub problem is \\n**\"How many white tiles do you leave uncovered at most with n carpets starting from tile i\"**\\n\\nwe can use the array `dp[tile][carpets]` to store the results \\n\\nGiven the floor 10110101 with 2 carpets of length 2 we can start from the back (tile 7).\\n\\n0  1  2  3  4  5  6  7\\n[ ][#][ ][  ][#][ ][#][ ]  \\n\\nWith 0 carpets we would leave tile 7 uncovered => 1 white tile\\nWith 1 or 2 carpets we would cover tile 7 => 0 white tiles\\n\\nMoving backwards we can then find the minimum number of white tiles uncovered which is\\n\\n1. If the number of carpets * their length cover the whole rest of the floor - we leave 0 tiles uncovered\\n2. We have the choice of\\n\\ta. covering the current tile - then our answer is min tiles for the floor a carpets length away covered by carpet - 1 carpets **or**\\n\\tb. don\\'t cover the current tile - then our answer is the min tile for starting at the next tile with the same number of carpets + 1 if our tile is white (as this is now uncovered)\\n\\t\\nAt the end - the answer is dp[tile=0][carpets=numCarpets]\\n\\n```python\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n        dp= [[0 for _ in range(numCarpets + 1)] for _ in range(n)]\\n\\n        dp[n - 1][0] = int(floor[-1])\\n\\n        for tile in range(n - 2, -1, -1):\\n            for carpets in range(numCarpets, -1, -1):\\n                if carpets == 0:\\n                    dp[tile][0] = dp[tile + 1][0] + int(floor[tile])\\n                elif tile + (carpets * carpetLen) >= n:\\n                    continue   # number is 0 by default\\n                else:\\n                    dp[tile][carpets] = min(dp[tile + carpetLen][carpets - 1], int(floor[tile]) + dp[tile + 1][carpets])\\n\\n        return dp[0][numCarpets]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n        dp= [[0 for _ in range(numCarpets + 1)] for _ in range(n)]\\n\\n        dp[n - 1][0] = int(floor[-1])\\n\\n        for tile in range(n - 2, -1, -1):\\n            for carpets in range(numCarpets, -1, -1):\\n                if carpets == 0:\\n                    dp[tile][0] = dp[tile + 1][0] + int(floor[tile])\\n                elif tile + (carpets * carpetLen) >= n:\\n                    continue   # number is 0 by default\\n                else:\\n                    dp[tile][carpets] = min(dp[tile + carpetLen][carpets - 1], int(floor[tile]) + dp[tile + 1][carpets])\\n\\n        return dp[0][numCarpets]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1867148,
                "title": "fast-dp-considering-special-test-cases-and-pruning-some-branches",
                "content": "There are shorter implementations, but in order to improve the efficiency, we\\'d better consider treatments for special test cases and pruning some branches.\\n# DP with recursion\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        ps = [0] * (1 + len(floor))\\n        for i, c in enumerate(floor):\\n            ps[i] = ps[i - 1] + 1 if c == \"1\" else ps[i - 1]\\n\\n        if carpetLen == 1:     # special treatments to improve the efficiency\\n            return max(ps[-2] - numCarpets, 0)\\n\\n        if ps[-2] == len(floor):\\n            return max(len(floor) - numCarpets * carpetLen, 0)\\n\\n        @lru_cache(None)\\n        def dp(start, n) -> int:\\n            \"\"\" start of index, number of remaining carpets \"\"\"\\n            if n * carpetLen >= len(floor) - start:  # enough to cover all in this region\\n                return ps[start-1]\\n\\n            if n == 0:  # no tile is used\\n                return ps[-2]\\n\\n            k = min(start + carpetLen, len(floor))\\n            return min(dp(start+1, n), dp(k, n-1)-ps[k-1]+ps[start-1])\\n\\n        return dp(0, numCarpets)\\n```\\n\\n# DP with array\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        ps = [0] * (1 + len(floor))\\n        for i, c in enumerate(floor):\\n            ps[i] = ps[i - 1] + 1 if c == \"1\" else ps[i - 1]\\n\\n        if carpetLen == 1:     # special treatments to improve the efficiency\\n            return max(ps[-2] - numCarpets, 0)\\n\\n        if ps[-2] == len(floor):\\n            return max(len(floor) - numCarpets * carpetLen, 0)\\n\\n        dp = [[ps[-2]] * (1+len(floor)) for _ in range(numCarpets+1)]  # row[len(floor)] means using no carpets\\n\\n        for n in range(1, numCarpets+1):                               # start with 1 carpet\\n            row = dp[n]\\n            for i in range(len(floor)-1, -1, -1):                      # place another carpet at \"i\"\\n                k = min(i+carpetLen, len(floor))                       # the first position that \"i\" does not cover\\n                row[i] = min(dp[n][i+1], dp[n-1][k]-ps[k-1]+ps[i-1])\\n        return dp[numCarpets][0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        ps = [0] * (1 + len(floor))\\n        for i, c in enumerate(floor):\\n            ps[i] = ps[i - 1] + 1 if c == \"1\" else ps[i - 1]\\n\\n        if carpetLen == 1:     # special treatments to improve the efficiency\\n            return max(ps[-2] - numCarpets, 0)\\n\\n        if ps[-2] == len(floor):\\n            return max(len(floor) - numCarpets * carpetLen, 0)\\n\\n        @lru_cache(None)\\n        def dp(start, n) -> int:\\n            \"\"\" start of index, number of remaining carpets \"\"\"\\n            if n * carpetLen >= len(floor) - start:  # enough to cover all in this region\\n                return ps[start-1]\\n\\n            if n == 0:  # no tile is used\\n                return ps[-2]\\n\\n            k = min(start + carpetLen, len(floor))\\n            return min(dp(start+1, n), dp(k, n-1)-ps[k-1]+ps[start-1])\\n\\n        return dp(0, numCarpets)\\n```\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        ps = [0] * (1 + len(floor))\\n        for i, c in enumerate(floor):\\n            ps[i] = ps[i - 1] + 1 if c == \"1\" else ps[i - 1]\\n\\n        if carpetLen == 1:     # special treatments to improve the efficiency\\n            return max(ps[-2] - numCarpets, 0)\\n\\n        if ps[-2] == len(floor):\\n            return max(len(floor) - numCarpets * carpetLen, 0)\\n\\n        dp = [[ps[-2]] * (1+len(floor)) for _ in range(numCarpets+1)]  # row[len(floor)] means using no carpets\\n\\n        for n in range(1, numCarpets+1):                               # start with 1 carpet\\n            row = dp[n]\\n            for i in range(len(floor)-1, -1, -1):                      # place another carpet at \"i\"\\n                k = min(i+carpetLen, len(floor))                       # the first position that \"i\" does not cover\\n                row[i] = min(dp[n][i+1], dp[n-1][k]-ps[k-1]+ps[i-1])\\n        return dp[numCarpets][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866920,
                "title": "c-o-n2",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> dp;\\n    int fun(int l,int num,string &s,int &ln){\\n        \\n        while(l<s.length() and s[l]==\\'0\\') l++;\\n        \\n        if(l>=s.length()) return 0;\\n        if(dp[l][num]!=-1) return dp[l][num];\\n        int ans=INT_MAX;\\n        if(num>0) ans=min(ans,fun(l+ln,num-1,s,ln));\\n        ans=min(ans,fun(l+1,num,s,ln)+1);\\n        \\n        return dp[l][num]=ans;\\n        \\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        dp.resize(floor.length()+1,vector<int>(numCarpets+1,-1));\\n        return fun(0,numCarpets,floor,carpetLen);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> dp;\\n    int fun(int l,int num,string &s,int &ln){\\n        \\n        while(l<s.length() and s[l]==\\'0\\') l++;\\n        \\n        if(l>=s.length()) return 0;\\n        if(dp[l][num]!=-1) return dp[l][num];\\n        int ans=INT_MAX;\\n        if(num>0) ans=min(ans,fun(l+ln,num-1,s,ln));\\n        ans=min(ans,fun(l+1,num,s,ln)+1);\\n        \\n        return dp[l][num]=ans;\\n        \\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        dp.resize(floor.length()+1,vector<int>(numCarpets+1,-1));\\n        return fun(0,numCarpets,floor,carpetLen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866555,
                "title": "java-dp-memoization",
                "content": "1. Do Binary Search and store indices of whites tiles.\\n2. We can use DP here now where:\\ndp(floorLength, numCarpets) = max(dp(floorLength - carpetLen, numCarpets - 1) + numOfWhiteTilesInRange(floorLength - carpetLen, floorLength), dp(floorLength - carpetLen, numCarpets - 1)) -> number of white tiles covered from index 0 to floorLength using numCarpets number of carpets.\\n3. Base Conditions:\\nif (floorLength < 0 || numCarpets <= 0) return 0;\\n4. ans = whiteTiles.size() - dp(floorLength, numCarpets)\\n```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int floorLength = floor.length();\\n        List<Integer> whiteTiles = new ArrayList<>();\\n        for (int tile = 0; tile < floorLength; tile += 1) {\\n            if (floor.charAt(tile) == \\'1\\') {\\n                whiteTiles.add(tile);\\n            }\\n        }\\n        Integer[][] dp = new Integer[floorLength][numCarpets + 1];\\n        System.out.println(minimumWhiteTiles(floorLength - 1, numCarpets, carpetLen, dp, whiteTiles) + \"-\" + whiteTiles.size());\\n        return whiteTiles.size() - minimumWhiteTiles(floorLength - 1, numCarpets, carpetLen, dp, whiteTiles);\\n    }\\n    \\n    private int minimumWhiteTiles(int floorLength, int numCarpets, int carpetLen, Integer[][] dp, List<Integer> whiteTiles) {\\n        if (floorLength < 0 || numCarpets <= 0) {\\n            return 0;\\n        }\\n        if (dp[floorLength][numCarpets] != null) {\\n            return dp[floorLength][numCarpets];\\n        }\\n        return dp[floorLength][numCarpets] = Math.max(minimumWhiteTiles(floorLength - carpetLen, numCarpets - 1, carpetLen, dp, whiteTiles) + numOfWhiteTilesInRange(floorLength - carpetLen, floorLength, whiteTiles), minimumWhiteTiles(floorLength - 1, numCarpets, carpetLen, dp, whiteTiles));\\n    }\\n    \\n    private int numOfWhiteTilesInRange(int start, int end, List<Integer> whiteTiles) {\\n        int maxIndex = ceil(end, whiteTiles);\\n        int minIndex = ceil(start, whiteTiles);\\n        return maxIndex - minIndex;\\n    }\\n    \\n    int ceil(int idx, List<Integer> whiteTiles) {\\n        int ans = -1;\\n        int start = 0;\\n        int end = whiteTiles.size() - 1;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(whiteTiles.get(mid) <= idx) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return ans + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int floorLength = floor.length();\\n        List<Integer> whiteTiles = new ArrayList<>();\\n        for (int tile = 0; tile < floorLength; tile += 1) {\\n            if (floor.charAt(tile) == \\'1\\') {\\n                whiteTiles.add(tile);\\n            }\\n        }\\n        Integer[][] dp = new Integer[floorLength][numCarpets + 1];\\n        System.out.println(minimumWhiteTiles(floorLength - 1, numCarpets, carpetLen, dp, whiteTiles) + \"-\" + whiteTiles.size());\\n        return whiteTiles.size() - minimumWhiteTiles(floorLength - 1, numCarpets, carpetLen, dp, whiteTiles);\\n    }\\n    \\n    private int minimumWhiteTiles(int floorLength, int numCarpets, int carpetLen, Integer[][] dp, List<Integer> whiteTiles) {\\n        if (floorLength < 0 || numCarpets <= 0) {\\n            return 0;\\n        }\\n        if (dp[floorLength][numCarpets] != null) {\\n            return dp[floorLength][numCarpets];\\n        }\\n        return dp[floorLength][numCarpets] = Math.max(minimumWhiteTiles(floorLength - carpetLen, numCarpets - 1, carpetLen, dp, whiteTiles) + numOfWhiteTilesInRange(floorLength - carpetLen, floorLength, whiteTiles), minimumWhiteTiles(floorLength - 1, numCarpets, carpetLen, dp, whiteTiles));\\n    }\\n    \\n    private int numOfWhiteTilesInRange(int start, int end, List<Integer> whiteTiles) {\\n        int maxIndex = ceil(end, whiteTiles);\\n        int minIndex = ceil(start, whiteTiles);\\n        return maxIndex - minIndex;\\n    }\\n    \\n    int ceil(int idx, List<Integer> whiteTiles) {\\n        int ans = -1;\\n        int start = 0;\\n        int end = whiteTiles.size() - 1;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(whiteTiles.get(mid) <= idx) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return ans + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866430,
                "title": "c-dp-pick-nonpick-technique",
                "content": "* Solve function will return the maximum number of white tiles that can be covered with carpets \\n* Therefore , Minimum Visible white tiles = Total white tiles - Value returned by Solve function\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    //returns the max number of white tiles that can be covered\\n    int solve(string &floor , int i , int carpets ,int len,vector<int>&suff ){\\n        if(i >= floor.size() || !carpets ) return 0 ;\\n        if(dp[i][carpets] != -1) return dp[i][carpets] ;\\n        \\n\\t\\t//at every index i we have two options -> lay the carpet(if tile is white) , or dont lay and move ahead\\n        int Laid = 0 , notLaid = 0 , covered = 0 ;\\n        //if the current tile is white only then lay the carpet\\n        if(floor[i] == \\'1\\'){\\n          covered = (i+len-1 >= floor.size() ? suff[suff.size()-1] : suff[i+len-1]) - (i-1>=0 ? suff[i-1] : 0 ) ;\\n          Laid = covered + solve(floor,i+len,carpets-1,len,suff) ;  \\n        } \\n        notLaid = solve(floor,i+1,carpets,len,suff) ;\\n        return dp[i][carpets] = max(Laid,notLaid) ;\\n    }\\n    int minimumWhiteTiles(string &floor, int carpets, int len ) {\\n\\n        vector<int>suff(floor.size(),0) ;\\n        //make suffix array  for O(1) access to number of white tiles between given range \\n        for(int i = 0 ; i < floor.size() ; ++i ){\\n            if(floor[i] == \\'1\\') ++suff[i];\\n            if(i!=0) suff[i] += suff[i-1] ;\\n        }\\n        \\n        memset(dp,-1,sizeof(dp)) ;\\n        return suff[suff.size()-1] - solve(floor,0,carpets,len,suff) ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    //returns the max number of white tiles that can be covered\\n    int solve(string &floor , int i , int carpets ,int len,vector<int>&suff ){\\n        if(i >= floor.size() || !carpets ) return 0 ;\\n        if(dp[i][carpets] != -1) return dp[i][carpets] ;\\n        \\n\\t\\t//at every index i we have two options -> lay the carpet(if tile is white) , or dont lay and move ahead\\n        int Laid = 0 , notLaid = 0 , covered = 0 ;\\n        //if the current tile is white only then lay the carpet\\n        if(floor[i] == \\'1\\'){\\n          covered = (i+len-1 >= floor.size() ? suff[suff.size()-1] : suff[i+len-1]) - (i-1>=0 ? suff[i-1] : 0 ) ;\\n          Laid = covered + solve(floor,i+len,carpets-1,len,suff) ;  \\n        } \\n        notLaid = solve(floor,i+1,carpets,len,suff) ;\\n        return dp[i][carpets] = max(Laid,notLaid) ;\\n    }\\n    int minimumWhiteTiles(string &floor, int carpets, int len ) {\\n\\n        vector<int>suff(floor.size(),0) ;\\n        //make suffix array  for O(1) access to number of white tiles between given range \\n        for(int i = 0 ; i < floor.size() ; ++i ){\\n            if(floor[i] == \\'1\\') ++suff[i];\\n            if(i!=0) suff[i] += suff[i-1] ;\\n        }\\n        \\n        memset(dp,-1,sizeof(dp)) ;\\n        return suff[suff.size()-1] - solve(floor,0,carpets,len,suff) ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866262,
                "title": "c-memoization-o-length-numberofcarpets",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(string &floor,int i,int n,int k,int nc,int cl,vector<vector<int>>&memo){\\n        \\n        if(i>=n)return 0;\\n        int ans1=INT_MAX;\\n        int ans2=INT_MAX;\\n        if(memo[i][k]!=-1)return memo[i][k];\\n     \\n        if(k<nc){\\n           \\n            ans1=helper(floor,i+cl,n,k+1,nc,cl,memo);\\n        }\\n       \\n        ans2=helper(floor,i+1,n,k,nc,cl,memo)+floor[i]-\\'0\\';\\n        \\n        return memo[i][k]=min(ans1,ans2);\\n        \\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>>memo(floor.size(),vector<int>(numCarpets+1,-1));\\n        return helper(floor,0,floor.size(),0,numCarpets,carpetLen,memo);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(string &floor,int i,int n,int k,int nc,int cl,vector<vector<int>>&memo){\\n        \\n        if(i>=n)return 0;\\n        int ans1=INT_MAX;\\n        int ans2=INT_MAX;\\n        if(memo[i][k]!=-1)return memo[i][k];\\n     \\n        if(k<nc){\\n           \\n            ans1=helper(floor,i+cl,n,k+1,nc,cl,memo);\\n        }\\n       \\n        ans2=helper(floor,i+1,n,k,nc,cl,memo)+floor[i]-\\'0\\';\\n        \\n        return memo[i][k]=min(ans1,ans2);\\n        \\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>>memo(floor.size(),vector<int>(numCarpets+1,-1));\\n        return helper(floor,0,floor.size(),0,numCarpets,carpetLen,memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866143,
                "title": "simple-c-dp-memoization-top-down-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    \\n    int answer(string& nums , int black , int& len , int index){\\n        if(index >= nums.size())return 0;\\n        \\n        if(dp[index][black] != -1)return dp[index][black];\\n        \\n        int a = 3000 , b = 3000;\\n        \\n        if(black > 0){\\n            a = answer(nums , black - 1 , len , index + len);\\n        }\\n        b = answer(nums , black , len , index + 1);\\n        b += (nums[index] == \\'1\\');\\n        \\n        return dp[index][black] = min(a , b);\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        ios::sync_with_stdio(0);\\n        cin.tie(0);\\n        memset(dp , -1 , sizeof(dp));\\n        return answer(floor , numCarpets , carpetLen , 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    \\n    int answer(string& nums , int black , int& len , int index){\\n        if(index >= nums.size())return 0;\\n        \\n        if(dp[index][black] != -1)return dp[index][black];\\n        \\n        int a = 3000 , b = 3000;\\n        \\n        if(black > 0){\\n            a = answer(nums , black - 1 , len , index + len);\\n        }\\n        b = answer(nums , black , len , index + 1);\\n        b += (nums[index] == \\'1\\');\\n        \\n        return dp[index][black] = min(a , b);\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        ios::sync_with_stdio(0);\\n        cin.tie(0);\\n        memset(dp , -1 , sizeof(dp));\\n        return answer(floor , numCarpets , carpetLen , 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576522,
                "content": [
                    {
                        "username": "larachicharo",
                        "content": "I was trying a greedy solution where you cover the max number of whites for every new carpet. You do this iteratively one carpet at a time. I got a Wrong Anwser, not a TLE. I can\\'t find a counter example that breaks this solution. Please help me find one.\\n\\nThanks."
                    },
                    {
                        "username": "joefreedman24",
                        "content": "Counter example set up:\\nfloor = 10111101\\nlength = 4\\nrugs = 2\\n\\nGreedy round 1: Take the rug placement that covers 4 white tiles\\nresulting floor = 10000001\\nrugs left = 1\\n\\nYou can now only cover one of the two remaining white tiles with your last rug.\\nThis leaves one white tile exposed no matter what.\\n\\nAlternatively, an ideal solution would place one rug at indices 0-3 and the other on indices 4-7.\\nThese placements only cover three each but result in a full covering of all white tiles."
                    },
                    {
                        "username": "prince3244",
                        "content": "2699/2706 test cases passed. I wanna know those 7 test cases really bad. Is there any way?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I tried doing it with recursion , but got MLE :((. \n\nEDIT: Solved it using recursion + memoization , initially i was taking a 3D dp array but solved it using 2D dp array only , you also try."
                    }
                ]
            },
            {
                "id": 1981361,
                "content": [
                    {
                        "username": "larachicharo",
                        "content": "I was trying a greedy solution where you cover the max number of whites for every new carpet. You do this iteratively one carpet at a time. I got a Wrong Anwser, not a TLE. I can\\'t find a counter example that breaks this solution. Please help me find one.\\n\\nThanks."
                    },
                    {
                        "username": "joefreedman24",
                        "content": "Counter example set up:\\nfloor = 10111101\\nlength = 4\\nrugs = 2\\n\\nGreedy round 1: Take the rug placement that covers 4 white tiles\\nresulting floor = 10000001\\nrugs left = 1\\n\\nYou can now only cover one of the two remaining white tiles with your last rug.\\nThis leaves one white tile exposed no matter what.\\n\\nAlternatively, an ideal solution would place one rug at indices 0-3 and the other on indices 4-7.\\nThese placements only cover three each but result in a full covering of all white tiles."
                    },
                    {
                        "username": "prince3244",
                        "content": "2699/2706 test cases passed. I wanna know those 7 test cases really bad. Is there any way?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I tried doing it with recursion , but got MLE :((. \n\nEDIT: Solved it using recursion + memoization , initially i was taking a 3D dp array but solved it using 2D dp array only , you also try."
                    }
                ]
            },
            {
                "id": 1968246,
                "content": [
                    {
                        "username": "larachicharo",
                        "content": "I was trying a greedy solution where you cover the max number of whites for every new carpet. You do this iteratively one carpet at a time. I got a Wrong Anwser, not a TLE. I can\\'t find a counter example that breaks this solution. Please help me find one.\\n\\nThanks."
                    },
                    {
                        "username": "joefreedman24",
                        "content": "Counter example set up:\\nfloor = 10111101\\nlength = 4\\nrugs = 2\\n\\nGreedy round 1: Take the rug placement that covers 4 white tiles\\nresulting floor = 10000001\\nrugs left = 1\\n\\nYou can now only cover one of the two remaining white tiles with your last rug.\\nThis leaves one white tile exposed no matter what.\\n\\nAlternatively, an ideal solution would place one rug at indices 0-3 and the other on indices 4-7.\\nThese placements only cover three each but result in a full covering of all white tiles."
                    },
                    {
                        "username": "prince3244",
                        "content": "2699/2706 test cases passed. I wanna know those 7 test cases really bad. Is there any way?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I tried doing it with recursion , but got MLE :((. \n\nEDIT: Solved it using recursion + memoization , initially i was taking a 3D dp array but solved it using 2D dp array only , you also try."
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Sum Score of Array",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1998980,
                "content": [
                    {
                        "username": "mxquint",
                        "content": "This should be classified as an Easy problem. The complexity is not enough to be considered a medium difficulty problem."
                    },
                    {
                        "username": "vishnuvt",
                        "content": "Exactly"
                    },
                    {
                        "username": "Saurav_NITH",
                        "content": "This needs to be classified as Easy problem. "
                    }
                ]
            },
            {
                "id": 1915791,
                "content": [
                    {
                        "username": "mxquint",
                        "content": "This should be classified as an Easy problem. The complexity is not enough to be considered a medium difficulty problem."
                    },
                    {
                        "username": "vishnuvt",
                        "content": "Exactly"
                    },
                    {
                        "username": "Saurav_NITH",
                        "content": "This needs to be classified as Easy problem. "
                    }
                ]
            },
            {
                "id": 1813850,
                "content": [
                    {
                        "username": "mxquint",
                        "content": "This should be classified as an Easy problem. The complexity is not enough to be considered a medium difficulty problem."
                    },
                    {
                        "username": "vishnuvt",
                        "content": "Exactly"
                    },
                    {
                        "username": "Saurav_NITH",
                        "content": "This needs to be classified as Easy problem. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Check if an Array Is Consecutive",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Find Closest Number to Zero",
        "question_content": "<p>Given an integer array <code>nums</code> of size <code>n</code>, return <em>the number with the value <strong>closest</strong> to </em><code>0</code><em> in </em><code>nums</code>. If there are multiple answers, return <em>the number with the <strong>largest</strong> value</em>.</p>\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-4,-2,1,4,8]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong>\nThe distance from -4 to 0 is |-4| = 4.\nThe distance from -2 to 0 is |-2| = 2.\nThe distance from 1 to 0 is |1| = 1.\nThe distance from 4 to 0 is |4| = 4.\nThe distance from 8 to 0 is |8| = 8.\nThus, the closest number to 0 in the array is 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,-1,1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> 1 and -1 are both the closest numbers to 0, so 1 being larger is returned.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1953778,
                "title": "one-liner",
                "content": "**C++**\\n```cpp\\nint findClosestNumber(vector<int>& nums) {\\n    return *min_element(begin(nums), end(nums), [](int a, int b) {\\n        return abs(a) < abs(b) || (abs(a) == abs(b) && a > b);\\n    });\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint findClosestNumber(vector<int>& nums) {\\n    return *min_element(begin(nums), end(nums), [](int a, int b) {\\n        return abs(a) < abs(b) || (abs(a) == abs(b) && a > b);\\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1953923,
                "title": "one-liner",
                "content": "# **Explanation**\\nFine the max pair of `(-abs(a), a)`,\\nwhere `a` is the elements in input array.\\n\\nIt compare firstly `-abs(a)`, where it finds the minimum absolute value.\\nIf multiple result, then it compares secondely `a`, where it finds the maximum value.\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Python**\\n```py\\n    def findClosestNumber(self, A):\\n        return max([-abs(a), a] for a in A)[1] \\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\n    def findClosestNumber(self, A):\\n        return max([-abs(a), a] for a in A)[1] \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1954364,
                "title": "proper-benchmarks-3-4-ms-python",
                "content": "When submitting the normal way, LeetCode reports times around 150 ms and varying quite a bit even when submitting the same solution multiple times. And by now I hope it\\'s well-known that these times usually reflect mostly the judge overhead, barely the actual solution time at all, so they\\'re pretty much useless and just misleading. In this problem, actual solution times seem to be around 4 to 16 ms, and when measured properly, the times are impressively stable. Here are my benchmark results of a few solutions (for each solution I show the best three total times out of ten):\\n```\\nfindClosestNumberB   3.40 ms   3.42 ms   3.42 ms\\nfindClosestNumberC   3.44 ms   3.44 ms   3.44 ms\\nfindClosestNumberD   3.78 ms   3.78 ms   3.78 ms\\nfindClosestNumber7   3.93 ms   3.95 ms   3.95 ms\\nfindClosestNumberA   4.03 ms   4.04 ms   4.04 ms\\nfindClosestNumber6   4.19 ms   4.20 ms   4.20 ms\\nfindClosestNumber5   4.42 ms   4.42 ms   4.44 ms\\nfindClosestNumber9   5.74 ms   5.74 ms   5.75 ms\\nfindClosestNumber4   9.64 ms   9.65 ms   9.66 ms\\nfindClosestNumber8  10.27 ms  10.31 ms  10.32 ms\\nfindClosestNumber2  11.15 ms  11.17 ms  11.17 ms\\nfindClosestNumber3  13.00 ms  13.00 ms  13.01 ms\\nfindClosestNumber1  15.04 ms  15.06 ms  15.08 ms\\n```\\nYou see I tried quite a few methods and optimizations. The fastest ones don\\'t call `abs`/`min`/`max` or any other functions but do it on their own, by keeping track of the smallest positive and largest negative number. And they try to minimize the number of comparisons/assignments, ideally just one comparison per element. If you find something even faster, I\\'m very interested.\\n\\nThe full code, which when submitted, runs every solution on every test case. And after all 224 test cases, it shows the benchmark results in stdout:\\n```\\nclass Solution:\\n    \\n    def findClosestNumber1(self, nums: List[int]) -> int:\\n        return min(nums, key=lambda x: (abs(x), -x))\\n    \\n    def findClosestNumber2(self, nums: List[int]) -> int:\\n        return min(nums, key=lambda x: abs(x - .1))\\n    \\n    def findClosestNumber3(self, nums: List[int]) -> int:\\n        return max((-abs(x), x) for x in nums)[1]\\n    \\n    def findClosestNumber4(self, nums: List[int]) -> int:\\n        return -min(zip(map(abs, nums), map(neg, nums)))[1]\\n\\n    def findClosestNumber5(self, nums: List[int]) -> int:\\n        a = min(map(abs, nums))\\n        return a if a in nums else -a\\n\\n    def findClosestNumber6(self, nums: List[int]) -> int:\\n        a = abs(min(nums, key=abs))\\n        return a if a in nums else -a\\n\\n    def findClosestNumber7(self, nums: List[int]) -> int:\\n        x = min(nums, key=abs)\\n        return x if x >= 0 or -x not in nums else -x\\n    \\n    def findClosestNumber8(self, nums: List[int]) -> int:\\n        return min(sorted(nums, reverse=True), key=abs)\\n    \\n    def findClosestNumber9(self, nums: List[int]) -> int:        \\n        a = abs(nums[0])\\n        for x in nums:\\n            if x < 0:\\n                x = -x\\n            if x < a:\\n                a = x\\n        return a if a in nums else -a\\n        \\n    def findClosestNumberA(self, nums: List[int]) -> int:        \\n        pos = 999999\\n        neg = -pos\\n        for x in nums:\\n            if x < 0:\\n                if x > neg:\\n                    neg = x\\n            elif x < pos:\\n                pos = x\\n        return pos if pos <= -neg else neg\\n        \\n    def findClosestNumberB(self, nums: List[int]) -> int:        \\n        pos = 999999\\n        neg = -pos\\n        for x in nums:\\n            if x < pos and neg < x:\\n                if x < 0:\\n                    neg = x\\n                else:\\n                    pos = x\\n        return pos if pos <= -neg else neg\\n        \\n    def findClosestNumberC(self, nums: List[int]) -> int:        \\n        pos = 999999\\n        neg = -pos\\n        for x in nums:\\n            if neg < x and x < pos:\\n                if x < 0:\\n                    neg = x\\n                else:\\n                    pos = x\\n        return pos if pos <= -neg else neg\\n        \\n    def findClosestNumberD(self, nums: List[int]) -> int:        \\n        pos = 999999\\n        neg = -pos\\n        for x in nums:\\n            if neg < x < pos:\\n                if x < 0:\\n                    neg = x\\n                else:\\n                    pos = x\\n        return pos if pos <= -neg else neg\\n        \\n    def findClosestNumber(self, nums: List[int], timess=defaultdict(lambda: [0] * 10), testcase=[0]) -> int:\\n        name = \\'findClosestNumber\\'\\n        solutions = [getattr(self, s)\\n                     for s in dir(self)\\n                     if s.startswith(name)\\n                     and s != name]\\n        expect = dummy = object()\\n        from time import perf_counter as time\\n        for i in range(10):\\n            shuffle(solutions)\\n            for solution in solutions:\\n                start = time()\\n                result = solution(nums)\\n                end = time()\\n                if expect is dummy:\\n                    expect = result\\n                assert result == expect\\n                timess[solution.__name__][i] += end - start\\n        testcase[0] += 1\\n        if testcase[0] == 224:\\n            for name, times in sorted(timess.items(), key=lambda nt: sorted(nt[1])):\\n                print(name, *(f\\'{t*1e3:6.2f} ms\\' for t in sorted(times)[:3]))\\n            return\\n        return result\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfindClosestNumberB   3.40 ms   3.42 ms   3.42 ms\\nfindClosestNumberC   3.44 ms   3.44 ms   3.44 ms\\nfindClosestNumberD   3.78 ms   3.78 ms   3.78 ms\\nfindClosestNumber7   3.93 ms   3.95 ms   3.95 ms\\nfindClosestNumberA   4.03 ms   4.04 ms   4.04 ms\\nfindClosestNumber6   4.19 ms   4.20 ms   4.20 ms\\nfindClosestNumber5   4.42 ms   4.42 ms   4.44 ms\\nfindClosestNumber9   5.74 ms   5.74 ms   5.75 ms\\nfindClosestNumber4   9.64 ms   9.65 ms   9.66 ms\\nfindClosestNumber8  10.27 ms  10.31 ms  10.32 ms\\nfindClosestNumber2  11.15 ms  11.17 ms  11.17 ms\\nfindClosestNumber3  13.00 ms  13.00 ms  13.01 ms\\nfindClosestNumber1  15.04 ms  15.06 ms  15.08 ms\\n```\n```\\nclass Solution:\\n    \\n    def findClosestNumber1(self, nums: List[int]) -> int:\\n        return min(nums, key=lambda x: (abs(x), -x))\\n    \\n    def findClosestNumber2(self, nums: List[int]) -> int:\\n        return min(nums, key=lambda x: abs(x - .1))\\n    \\n    def findClosestNumber3(self, nums: List[int]) -> int:\\n        return max((-abs(x), x) for x in nums)[1]\\n    \\n    def findClosestNumber4(self, nums: List[int]) -> int:\\n        return -min(zip(map(abs, nums), map(neg, nums)))[1]\\n\\n    def findClosestNumber5(self, nums: List[int]) -> int:\\n        a = min(map(abs, nums))\\n        return a if a in nums else -a\\n\\n    def findClosestNumber6(self, nums: List[int]) -> int:\\n        a = abs(min(nums, key=abs))\\n        return a if a in nums else -a\\n\\n    def findClosestNumber7(self, nums: List[int]) -> int:\\n        x = min(nums, key=abs)\\n        return x if x >= 0 or -x not in nums else -x\\n    \\n    def findClosestNumber8(self, nums: List[int]) -> int:\\n        return min(sorted(nums, reverse=True), key=abs)\\n    \\n    def findClosestNumber9(self, nums: List[int]) -> int:        \\n        a = abs(nums[0])\\n        for x in nums:\\n            if x < 0:\\n                x = -x\\n            if x < a:\\n                a = x\\n        return a if a in nums else -a\\n        \\n    def findClosestNumberA(self, nums: List[int]) -> int:        \\n        pos = 999999\\n        neg = -pos\\n        for x in nums:\\n            if x < 0:\\n                if x > neg:\\n                    neg = x\\n            elif x < pos:\\n                pos = x\\n        return pos if pos <= -neg else neg\\n        \\n    def findClosestNumberB(self, nums: List[int]) -> int:        \\n        pos = 999999\\n        neg = -pos\\n        for x in nums:\\n            if x < pos and neg < x:\\n                if x < 0:\\n                    neg = x\\n                else:\\n                    pos = x\\n        return pos if pos <= -neg else neg\\n        \\n    def findClosestNumberC(self, nums: List[int]) -> int:        \\n        pos = 999999\\n        neg = -pos\\n        for x in nums:\\n            if neg < x and x < pos:\\n                if x < 0:\\n                    neg = x\\n                else:\\n                    pos = x\\n        return pos if pos <= -neg else neg\\n        \\n    def findClosestNumberD(self, nums: List[int]) -> int:        \\n        pos = 999999\\n        neg = -pos\\n        for x in nums:\\n            if neg < x < pos:\\n                if x < 0:\\n                    neg = x\\n                else:\\n                    pos = x\\n        return pos if pos <= -neg else neg\\n        \\n    def findClosestNumber(self, nums: List[int], timess=defaultdict(lambda: [0] * 10), testcase=[0]) -> int:\\n        name = \\'findClosestNumber\\'\\n        solutions = [getattr(self, s)\\n                     for s in dir(self)\\n                     if s.startswith(name)\\n                     and s != name]\\n        expect = dummy = object()\\n        from time import perf_counter as time\\n        for i in range(10):\\n            shuffle(solutions)\\n            for solution in solutions:\\n                start = time()\\n                result = solution(nums)\\n                end = time()\\n                if expect is dummy:\\n                    expect = result\\n                assert result == expect\\n                timess[solution.__name__][i] += end - start\\n        testcase[0] += 1\\n        if testcase[0] == 224:\\n            for name, times in sorted(timess.items(), key=lambda nt: sorted(nt[1])):\\n                print(name, *(f\\'{t*1e3:6.2f} ms\\' for t in sorted(times)[:3]))\\n            return\\n        return result\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956110,
                "title": "c-solution-explained",
                "content": "*  First compare each element with INT_MAX . If lesser then update the ans variable with the element in the nums . For exapmle , in case of [-4,-2,1,4,8]\\n     *  abs(4) < abs(INT_MAX) --> so mark ans = 4 \\n     *  In next iteration abs(2) < abs(4) --> so mark ans = 2 \\n     *  iterating through the nums will finnaly give 1 as ans .\\n     \\n*  For another case when there are two possible answers  --> e.g. --> -1 , 1 \\n     *  Check for max in this case so -->  max(-1,1) --> gives 1 , which is our answer .\\n\\n\\n> Code \\n```cpp\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n//         setting the ans to maximum value of int\\n        int ans = INT_MAX ;\\n        for(int i :  nums){\\n        // checking if each value of nums is less than the max value\\n            if(abs(i) < abs(ans)){\\n                ans =  i ; //check for the lesser value\\n            }\\n            else if(abs(i) == abs(ans)){\\n                ans = max (ans,i) ; // return the maximum in cases there are multiple answers\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```\\n\\n**First Post**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n//         setting the ans to maximum value of int\\n        int ans = INT_MAX ;\\n        for(int i :  nums){\\n        // checking if each value of nums is less than the max value\\n            if(abs(i) < abs(ans)){\\n                ans =  i ; //check for the lesser value\\n            }\\n            else if(abs(i) == abs(ans)){\\n                ans = max (ans,i) ; // return the maximum in cases there are multiple answers\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953639,
                "title": "java",
                "content": "Understanding : At max there can be two numbers with least difference, one positive and one negative.\\nIn this case, the positive number has to be considered as the answer.\\n    \\n```\\nclass Solution\\n{\\n    public int findClosestNumber(int[] nums)\\n    {\\n        int res = Integer.MAX_VALUE;\\n        for(int i: nums)\\n            if(Math.abs(i) < Math.abs(res) || i == Math.abs(res))\\n                res = i;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int findClosestNumber(int[] nums)\\n    {\\n        int res = Integer.MAX_VALUE;\\n        for(int i: nums)\\n            if(Math.abs(i) < Math.abs(res) || i == Math.abs(res))\\n                res = i;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953682,
                "title": "time-o-n-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int mini=INT_MAX;\\n        int number=INT_MIN;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(abs(nums[i])<mini)\\n            {   mini=abs(nums[i]);\\n                number=nums[i];\\n            }\\n            else if(abs(nums[i])==mini)\\n            {\\n                if(number<nums[i])\\n                    number=nums[i];\\n            }\\n        }\\n        return number;\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int mini=INT_MAX;\\n        int number=INT_MIN;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(abs(nums[i])<mini)\\n            {   mini=abs(nums[i]);\\n                number=nums[i];\\n            }\\n            else if(abs(nums[i])==mini)\\n            {\\n                if(number<nums[i])\\n                    number=nums[i];\\n            }\\n        }\\n        return number;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953643,
                "title": "java-solution",
                "content": "```\\n// If absolute of n is less than min, update the closest_num \\n// If absolute of n is same of as min, update the bigger closest_num\\n\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min = Integer.MAX_VALUE, closest_num = 0;\\n        for(int n : nums) {\\n            if(min > Math.abs(n)) {\\n                min = Math.abs(n);\\n                closest_num = n;\\n            } else if(min == Math.abs(n) && closest_num < n) {\\n                closest_num = n;\\n            }\\n        }\\n        return closest_num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// If absolute of n is less than min, update the closest_num \\n// If absolute of n is same of as min, update the bigger closest_num\\n\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min = Integer.MAX_VALUE, closest_num = 0;\\n        for(int n : nums) {\\n            if(min > Math.abs(n)) {\\n                min = Math.abs(n);\\n                closest_num = n;\\n            } else if(min == Math.abs(n) && closest_num < n) {\\n                closest_num = n;\\n            }\\n        }\\n        return closest_num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977609,
                "title": "java-c-python-javascript-kotlin-1line-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Java***\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n       int smallestDis = nums[0];\\n        \\n            for (int j = 1; j < nums.length; j++) {\\n\\n                if (Math.abs(smallestDis) == (nums[j])){\\n                    smallestDis = nums[j];\\n                }\\n                if(Math.abs(nums[j]) < Math.abs(smallestDis)){\\n                    smallestDis = nums[j];\\n                }\\n            }\\n        return smallestDis;\\n    }\\n}\\n```\\n\\n***Python***\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        m = 10 ** 6\\n        for i in nums:\\n            x = abs(i-0)\\n            if x < m:\\n                m = x\\n                val = i\\n            elif x == m and val < i:\\n                val = i\\n        return val\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n    return *min_element(begin(nums), end(nums), [](int a, int b) {\\n        return abs(a) < abs(b) || (abs(a) == abs(b) && a > b);\\n    });\\n}\\n};\\n```\\n\\n***JavaScript***\\n```\\nvar findClosestNumber = function(nums) {\\n  let closest = Infinity;\\n\\n  for (let num of nums) {\\n    if (Math.abs(num) < Math.abs(closest)) {\\n      closest = num\\n    } else if (Math.abs(num) === Math.abs(closest)) {\\n      closest = Math.max(num, closest)\\n    }\\n  }\\n\\n  return closest;\\n};\\n```\\n\\n***Kotlin***\\n```\\nimport kotlin.math.abs\\n\\nclass Solution {\\n    fun findClosestNumber(nums: IntArray): Int {\\n        var closest: Int? = null\\n        for (num in nums) {\\n            if (closest == null) {\\n                closest = num\\n            } else {\\n                if (abs(num) < abs(closest)) {\\n                    closest = num\\n                } else if (abs(num) == abs(closest)) {\\n                    if (num > closest) {\\n                        closest = num\\n                    }\\n                }\\n            }\\n        }\\n        return closest!!\\n    }\\n}\\n```\\n\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Kotlin",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n       int smallestDis = nums[0];\\n        \\n            for (int j = 1; j < nums.length; j++) {\\n\\n                if (Math.abs(smallestDis) == (nums[j])){\\n                    smallestDis = nums[j];\\n                }\\n                if(Math.abs(nums[j]) < Math.abs(smallestDis)){\\n                    smallestDis = nums[j];\\n                }\\n            }\\n        return smallestDis;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        m = 10 ** 6\\n        for i in nums:\\n            x = abs(i-0)\\n            if x < m:\\n                m = x\\n                val = i\\n            elif x == m and val < i:\\n                val = i\\n        return val\\n```\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n    return *min_element(begin(nums), end(nums), [](int a, int b) {\\n        return abs(a) < abs(b) || (abs(a) == abs(b) && a > b);\\n    });\\n}\\n};\\n```\n```\\nvar findClosestNumber = function(nums) {\\n  let closest = Infinity;\\n\\n  for (let num of nums) {\\n    if (Math.abs(num) < Math.abs(closest)) {\\n      closest = num\\n    } else if (Math.abs(num) === Math.abs(closest)) {\\n      closest = Math.max(num, closest)\\n    }\\n  }\\n\\n  return closest;\\n};\\n```\n```\\nimport kotlin.math.abs\\n\\nclass Solution {\\n    fun findClosestNumber(nums: IntArray): Int {\\n        var closest: Int? = null\\n        for (num in nums) {\\n            if (closest == null) {\\n                closest = num\\n            } else {\\n                if (abs(num) < abs(closest)) {\\n                    closest = num\\n                } else if (abs(num) == abs(closest)) {\\n                    if (num > closest) {\\n                        closest = num\\n                    }\\n                }\\n            }\\n        }\\n        return closest!!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637617,
                "title": "my-clean-solution-in-java",
                "content": "### ***Please Upvote !!!*** **(\\u25E0\\u203F\\u25E0)**\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        int ans = Integer.MIN_VALUE;\\n        \\n        for (int n : nums) {\\n            if (Math.abs(n) < min) {\\n                min = Math.abs(n);\\n                ans = n;\\n            }\\n            else if (Math.abs(n) == min) {\\n                ans = Math.max(ans, n);\\n            }\\n        }\\n        \\n        return ans;      \\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        int ans = Integer.MIN_VALUE;\\n        \\n        for (int n : nums) {\\n            if (Math.abs(n) < min) {\\n                min = Math.abs(n);\\n                ans = n;\\n            }\\n            else if (Math.abs(n) == min) {\\n                ans = Math.max(ans, n);\\n            }\\n        }\\n        \\n        return ans;      \\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953644,
                "title": "simple-java-solution-with-comments-o-n-o-1",
                "content": "\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int ans=nums[0]; //assume first is nearest to zero\\n        for(int i=1;i<nums.length;i++){\\n            if(Math.abs(nums[i])<=Math.abs(ans)){ //to check other number is nearest or equal to diffrence of ans and zero\\n                if(Math.abs(nums[i])==Math.abs(ans)){ //if this number is equal nearer compare to ans then we update the answer with max value as said in question\\n                    ans=Math.max(ans,nums[i]);\\n                }else{ //if this number is nearer than ans then we update the answer\\n                    ans=nums[i];    \\n                }                \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Concised Way: Thanks to @aaveshk\\n\\n  public int findClosestNumber(int[] nums) {\\n        int ans=nums[0]; //assume first is nearest to zero\\n        for(int i=1;i<nums.length;i++)\\n\\t\\t\\tif(Math.abs(nums[i]) < Math.abs(ans) || nums[i] == Math.abs(ans))\\n\\t\\t\\t\\tans = nums[i];\\n\\t\\treturn ans;\\n  }\\n\\t\\t\\t\\t\\n\\n```\\nUpvote if it\\'s helpful",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int ans=nums[0]; //assume first is nearest to zero\\n        for(int i=1;i<nums.length;i++){\\n            if(Math.abs(nums[i])<=Math.abs(ans)){ //to check other number is nearest or equal to diffrence of ans and zero\\n                if(Math.abs(nums[i])==Math.abs(ans)){ //if this number is equal nearer compare to ans then we update the answer with max value as said in question\\n                    ans=Math.max(ans,nums[i]);\\n                }else{ //if this number is nearer than ans then we update the answer\\n                    ans=nums[i];    \\n                }                \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Concised Way: Thanks to @aaveshk\\n\\n  public int findClosestNumber(int[] nums) {\\n        int ans=nums[0]; //assume first is nearest to zero\\n        for(int i=1;i<nums.length;i++)\\n\\t\\t\\tif(Math.abs(nums[i]) < Math.abs(ans) || nums[i] == Math.abs(ans))\\n\\t\\t\\t\\tans = nums[i];\\n\\t\\treturn ans;\\n  }\\n\\t\\t\\t\\t\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135483,
                "title": "python-easy-solution",
                "content": "# Code\\u2705\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int: #// nums = [-4, -2, 1, 4, 8]\\n        pos, neg = [], []\\n        for item in nums:\\n            if item < 0:\\n                neg.append(item)\\n            elif item > 0:\\n                pos.append(item)\\n            else:\\n                return 0\\n                                            #// neg = [-4, -2]     pos = [1, 4, 8]       \\n        if not neg:\\n            return sorted(pos)[0]\\n        if not pos:\\n            return sorted(neg)[-1]\\n        \\n        if abs(sorted(neg)[-1]) <  sorted(pos)[0]:\\n            return sorted(neg)[-1]\\n        return sorted(pos)[0]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int: #// nums = [-4, -2, 1, 4, 8]\\n        pos, neg = [], []\\n        for item in nums:\\n            if item < 0:\\n                neg.append(item)\\n            elif item > 0:\\n                pos.append(item)\\n            else:\\n                return 0\\n                                            #// neg = [-4, -2]     pos = [1, 4, 8]       \\n        if not neg:\\n            return sorted(pos)[0]\\n        if not pos:\\n            return sorted(neg)[-1]\\n        \\n        if abs(sorted(neg)[-1]) <  sorted(pos)[0]:\\n            return sorted(neg)[-1]\\n        return sorted(pos)[0]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448995,
                "title": "java-2ms-beats-98-simple-and-easy-code",
                "content": "```\\n int ans = 0  ; int closest = Integer.MAX_VALUE ; int diff = 0 ;\\n       \\n        //we used a for loop to check difference of each number from 0 ;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            int temp = nums[i];//storing value in temp ;\\n            \\n            //if number is negative then this\\n            if(temp < 0 ){\\n                 diff = 0 -temp ;\\n            }else{//else this because we want the mod value of the difference; \\n                 diff = temp - 0 ;\\n            }\\n            \\n            if(diff < closest ){\\n                closest = diff ;\\n                ans = temp ;\\n            }else if(diff == closest){//this is for checking for max value ;\\n                if(ans < temp){\\n                    ans = temp ;\\n                }\\n            }\\n            \\n        }\\n        return ans ;",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n int ans = 0  ; int closest = Integer.MAX_VALUE ; int diff = 0 ;\\n       \\n        //we used a for loop to check difference of each number from 0 ;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            int temp = nums[i];//storing value in temp ;\\n            \\n            //if number is negative then this\\n            if(temp < 0 ){\\n                 diff = 0 -temp ;\\n            }else{//else this because we want the mod value of the difference; \\n                 diff = temp - 0 ;\\n            }\\n            \\n            if(diff < closest ){\\n                closest = diff ;\\n                ans = temp ;\\n            }else if(diff == closest){//this is for checking for max value ;\\n                if(ans < temp){\\n                    ans = temp ;\\n                }\\n            }\\n            \\n        }\\n        return ans ;",
                "codeTag": "Unknown"
            },
            {
                "id": 2146990,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        t = nums[0]\\n        for num in nums:\\n            if abs(num) == abs(t):\\n                t = max(t,num)\\n            elif abs(num) < abs(t):\\n                t= num\\n        return t\\n          \\n        \\n            \\n```\\nSolution",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        t = nums[0]\\n        for num in nums:\\n            if abs(num) == abs(t):\\n                t = max(t,num)\\n            elif abs(num) < abs(t):\\n                t= num\\n        return t\\n          \\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953786,
                "title": "c-o-n-greedy",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/find-closest-number-to-zero/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& A) {\\n        int diff = INT_MAX, ans = INT_MAX;\\n        for (int n : A) {\\n            if (abs(n) < diff || (abs(n) == diff && n > ans)) {\\n                diff = abs(n);\\n                ans = n;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/find-closest-number-to-zero/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& A) {\\n        int diff = INT_MAX, ans = INT_MAX;\\n        for (int n : A) {\\n            if (abs(n) < diff || (abs(n) == diff && n > ans)) {\\n                diff = abs(n);\\n                ans = n;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953733,
                "title": "simple-python-solution",
                "content": "```\\ndef findClosestNumber(self, nums: List[int]) -> int:\\n\\tclosest = nums[0]\\n\\tfor a in nums: \\n\\t  if abs(closest) > abs(a):\\n\\t\\tclosest = a\\n\\t  elif abs(closest) == abs(a):\\n\\t\\tclosest = max(closest, a)\\n\\treturn closest \\n```",
                "solutionTags": [],
                "code": "```\\ndef findClosestNumber(self, nums: List[int]) -> int:\\n\\tclosest = nums[0]\\n\\tfor a in nums: \\n\\t  if abs(closest) > abs(a):\\n\\t\\tclosest = a\\n\\t  elif abs(closest) == abs(a):\\n\\t\\tclosest = max(closest, a)\\n\\treturn closest \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1953739,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int x=INT_MAX,ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(abs(nums[i])<x)\\n            {\\n                x=abs(nums[i]);\\n                ans=nums[i];\\n            }\\n            else if(abs(nums[i])==x)\\n            {\\n                ans=max(ans,nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int x=INT_MAX,ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(abs(nums[i])<x)\\n            {\\n                x=abs(nums[i]);\\n                ans=nums[i];\\n            }\\n            else if(abs(nums[i])==x)\\n            {\\n                ans=max(ans,nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953649,
                "title": "java-explained-iterative-binary-search-easiest",
                "content": "The solution is **simple** to **binary search** the array and check at max the **low low+1 and low -1** due to the constraints given \\nIn case if constraints were not given then returning of arr[low] itself would have done the job\\n\\nUPVOTE coders it takes a lot of confidence to post this solution after being able to solve only one in the contest \\uD83D\\uDE12\\uD83D\\uDE12\\u2764\\n\\n```\\npublic static int findClosestNumber(int[] nums) {\\n\\tArrays.sort(nums);\\n\\tint low=0,high=nums.length-1;\\n\\twhile(low<high){\\n\\t\\tint mid =low+(high-low)/2;\\n\\t\\tif(nums[mid]==0)return nums[mid];\\n\\t\\tif(nums[mid]>0)high=mid-1;\\n\\t\\tif(nums[mid]<0)low=mid+1;\\n\\t}\\n\\tif((low+1)<=nums.length-1\\n\\t\\t\\t&& -nums[low] == nums[low + 1])\\n\\t\\treturn nums[low+1];\\n\\n\\tif((low+1)<=nums.length-1 &&\\n\\t\\t\\t-nums[low] >= nums[low + 1])\\n\\t\\treturn nums[low+1];\\n\\n\\tif((low-1)>=0\\n\\t\\t\\t&& -nums[low-1] < nums[low] || nums[low] > nums[low] )\\n\\t\\treturn nums[low-1];\\n\\n\\treturn nums[low];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\npublic static int findClosestNumber(int[] nums) {\\n\\tArrays.sort(nums);\\n\\tint low=0,high=nums.length-1;\\n\\twhile(low<high){\\n\\t\\tint mid =low+(high-low)/2;\\n\\t\\tif(nums[mid]==0)return nums[mid];\\n\\t\\tif(nums[mid]>0)high=mid-1;\\n\\t\\tif(nums[mid]<0)low=mid+1;\\n\\t}\\n\\tif((low+1)<=nums.length-1\\n\\t\\t\\t&& -nums[low] == nums[low + 1])\\n\\t\\treturn nums[low+1];\\n\\n\\tif((low+1)<=nums.length-1 &&\\n\\t\\t\\t-nums[low] >= nums[low + 1])\\n\\t\\treturn nums[low+1];\\n\\n\\tif((low-1)>=0\\n\\t\\t\\t&& -nums[low-1] < nums[low] || nums[low] > nums[low] )\\n\\t\\treturn nums[low-1];\\n\\n\\treturn nums[low];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420858,
                "title": "2ms-using-java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=Integer.MAX_VALUE;\\n        int res=0;\\n        for(int i=0;i<nums.length;i++) \\n        {\\n            if(Math.abs(nums[i])<min) \\n            {\\n                min=Math.abs(nums[i]);\\n                res=nums[i];\\n            }\\n            else if(min==Math.abs(nums[i]) && res<nums[i]) \\n            {\\n                res=nums[i];\\n            }\\n        }\\n        return res;\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=Integer.MAX_VALUE;\\n        int res=0;\\n        for(int i=0;i<nums.length;i++) \\n        {\\n            if(Math.abs(nums[i])<min) \\n            {\\n                min=Math.abs(nums[i]);\\n                res=nums[i];\\n            }\\n            else if(min==Math.abs(nums[i]) && res<nums[i]) \\n            {\\n                res=nums[i];\\n            }\\n        }\\n        return res;\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932978,
                "title": "c-int-max-easy-solution",
                "content": "# Using INT_MAX function\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n       int mn=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(abs(nums[i])<=abs(mn))\\n                mn=nums[i];\\n        }\\n        return mn;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n       int mn=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(abs(nums[i])<=abs(mn))\\n                mn=nums[i];\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494424,
                "title": "simple-js-solution-using-sort",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst findClosestNumber = function(nums) {\\n    nums.sort((a, b) => Math.abs(a) - Math.abs(b));\\n    if (nums.includes(Math.abs(nums[0]))) return Math.abs(nums[0]);\\n    return nums[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst findClosestNumber = function(nums) {\\n    nums.sort((a, b) => Math.abs(a) - Math.abs(b));\\n    if (nums.includes(Math.abs(nums[0]))) return Math.abs(nums[0]);\\n    return nums[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2032739,
                "title": "beginners-friendly-solution-using-heap-c",
                "content": "We are making a max heap and inserting all the elements of the array in pair. The first contains the absolute vale, second contains the true value of the element. We pop the top element when the size gets more than 1. We are doing this because the problem statement requires us to return only the closest one, not top 2 closest or top k closest.\\n\\nWe add an additional condition for in case we get a negative element on top. We see if the positive num of same magnitute is available in the array, if yes, then we return that, else we return whatever we got on top of our max heap.\\n\\n```\\nint findClosestNumber(vector<int>& nums) {\\n        \\n        priority_queue<pair<int,int> > pq;\\n        int n=nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            pq.push({abs(nums[i]),nums[i]});\\n            if(pq.size()>1) pq.pop();\\n        }\\n        \\n        if(pq.top().second<0 && find(nums.begin(), nums.end(), pq.top().first)==nums.end())\\n        return pq.top().second;\\n        else{\\n            return pq.top().first;\\n        }\\n    }",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "We are making a max heap and inserting all the elements of the array in pair. The first contains the absolute vale, second contains the true value of the element. We pop the top element when the size gets more than 1. We are doing this because the problem statement requires us to return only the closest one, not top 2 closest or top k closest.\\n\\nWe add an additional condition for in case we get a negative element on top. We see if the positive num of same magnitute is available in the array, if yes, then we return that, else we return whatever we got on top of our max heap.\\n\\n```\\nint findClosestNumber(vector<int>& nums) {\\n        \\n        priority_queue<pair<int,int> > pq;\\n        int n=nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            pq.push({abs(nums[i]),nums[i]});\\n            if(pq.size()>1) pq.pop();\\n        }\\n        \\n        if(pq.top().second<0 && find(nums.begin(), nums.end(), pq.top().first)==nums.end())\\n        return pq.top().second;\\n        else{\\n            return pq.top().first;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1959624,
                "title": "python-olution",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        m = 10 ** 6\\n        for i in nums:\\n            x = abs(i-0)\\n            if x < m:\\n                m = x\\n                val = i\\n            elif x == m and val < i:\\n                val = i\\n        return val\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        m = 10 ** 6\\n        for i in nums:\\n            x = abs(i-0)\\n            if x < m:\\n                m = x\\n                val = i\\n            elif x == m and val < i:\\n                val = i\\n        return val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953765,
                "title": "just-linear-search-on-time-and-o-1-space-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int ans = 1e9;\\n        for(auto &it : nums){\\n            if(abs(it) == abs(ans)){\\n                ans = max(it,ans);\\n            }\\n            else if(abs(it) < abs(ans)){\\n                ans = it;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int ans = 1e9;\\n        for(auto &it : nums){\\n            if(abs(it) == abs(ans)){\\n                ans = max(it,ans);\\n            }\\n            else if(abs(it) < abs(ans)){\\n                ans = it;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656179,
                "title": "easy-python-solution",
                "content": "\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        min=1000000\\n        for i in nums:\\n            if min>abs(i):\\n                min=abs(i)\\n        if min in nums:\\n            return min\\n        else:\\n            return -1*min\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        min=1000000\\n        for i in nums:\\n            if min>abs(i):\\n                min=abs(i)\\n        if min in nums:\\n            return min\\n        else:\\n            return -1*min\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478630,
                "title": "find-closest-number-to-zero-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int i, ans=INT_MIN, min=INT_MAX;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(abs(nums[i]-0)<min || (abs(nums[i]-0)==min && nums[i]>ans))\\n            {\\n                min = abs(nums[i]);\\n                ans = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/ae95e3ea-6c2d-4afc-b01e-eaf270bb59cc_1683046840.8975687.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int i, ans=INT_MIN, min=INT_MAX;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(abs(nums[i]-0)<min || (abs(nums[i]-0)==min && nums[i]>ans))\\n            {\\n                min = abs(nums[i]);\\n                ans = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457646,
                "title": "c-solution-simple-approach",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n\\n    int ans = 0;\\n    int min_dist = INT_MAX;\\n    int n=nums.size();\\n    for (int i = 0; i < n; i++)\\n    {\\n        min_dist = min(min_dist, abs(nums[i]));\\n        if (min_dist == abs(nums[i]))\\n        {\\n            if(nums[i]<0 && ans!=min_dist)\\n                    ans = nums[i];\\n            else\\n                ans = min_dist;\\n        }\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n\\n    int ans = 0;\\n    int min_dist = INT_MAX;\\n    int n=nums.size();\\n    for (int i = 0; i < n; i++)\\n    {\\n        min_dist = min(min_dist, abs(nums[i]));\\n        if (min_dist == abs(nums[i]))\\n        {\\n            if(nums[i]<0 && ans!=min_dist)\\n                    ans = nums[i];\\n            else\\n                ans = min_dist;\\n        }\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061835,
                "title": "c-track-closest-negative-and-positive-o-n-102ms-96",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int FindClosestNumber(int[] nums) \\n    {\\n        var closestPositive = int.MaxValue;    \\n        var closestNegative = int.MinValue;    \\n\\n        foreach(var n in nums)\\n        {\\n            if(n >= 0)\\n                closestPositive = Math.Min(closestPositive, n);\\n            else\\n                closestNegative = Math.Max(closestNegative, n);\\n        }\\n\\n        return -closestPositive >= closestNegative ? closestPositive : closestNegative;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindClosestNumber(int[] nums) \\n    {\\n        var closestPositive = int.MaxValue;    \\n        var closestNegative = int.MinValue;    \\n\\n        foreach(var n in nums)\\n        {\\n            if(n >= 0)\\n                closestPositive = Math.Min(closestPositive, n);\\n            else\\n                closestNegative = Math.Max(closestNegative, n);\\n        }\\n\\n        return -closestPositive >= closestNegative ? closestPositive : closestNegative;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996124,
                "title": "java-3-ms-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        for (int n : nums) {\\n            if (min + n == 0) {\\n                min = min > 0 ? min : n;\\n            } else if (Math.abs(min) > Math.abs(n)) {\\n                min = n;\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        for (int n : nums) {\\n            if (min + n == 0) {\\n                min = min > 0 ? min : n;\\n            } else if (Math.abs(min) > Math.abs(n)) {\\n                min = n;\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640106,
                "title": "c-priority-queue-simple-approach",
                "content": "```\\n//Firstly we make a min heap and store all the elements of array with their absolute value as a key and array element itself as the value of key.Then the value at top is the closest number to zero.\\n//if there is are multiple same keys in heap then we search the availability of its greater value in array if it is not present then we print second value otherwise first.\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push({abs(nums[i]),nums[i]});\\n        }\\nif(pq.top().second<0 && find(nums.begin(),nums.end(),pq.top().first)==nums.end())\\n        return pq.top().second;\\n        else\\n            return pq.top().first;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n//Firstly we make a min heap and store all the elements of array with their absolute value as a key and array element itself as the value of key.Then the value at top is the closest number to zero.\\n//if there is are multiple same keys in heap then we search the availability of its greater value in array if it is not present then we print second value otherwise first.\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push({abs(nums[i]),nums[i]});\\n        }\\nif(pq.top().second<0 && find(nums.begin(),nums.end(),pq.top().first)==nums.end())\\n        return pq.top().second;\\n        else\\n            return pq.top().first;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637734,
                "title": "easy-java-solution-o-n-beginner-friendly",
                "content": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n       int distance=Integer.MAX_VALUE;\\n        int max_distance=Integer.MAX_VALUE;\\nint min_no=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n                  distance=Math.abs(nums[i]);\\n                  if(distance<max_distance)\\n                  {\\n                       max_distance=distance;\\n                       min_no=nums[i];\\n                  }\\n                \\n                if(distance==max_distance)\\n                {\\n                   max_distance=distance;\\n                  min_no=Math.max(nums[i],min_no);\\n                }\\n                \\n        }\\n       return min_no;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n       int distance=Integer.MAX_VALUE;\\n        int max_distance=Integer.MAX_VALUE;\\nint min_no=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n                  distance=Math.abs(nums[i]);\\n                  if(distance<max_distance)\\n                  {\\n                       max_distance=distance;\\n                       min_no=nums[i];\\n                  }\\n                \\n                if(distance==max_distance)\\n                {\\n                   max_distance=distance;\\n                  min_no=Math.max(nums[i],min_no);\\n                }\\n                \\n        }\\n       return min_no;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530720,
                "title": "beginner-friendly-java-code",
                "content": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=Integer.MAX_VALUE,dist=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n           if(Math.abs(nums[i])<min){  //Math.abs is a func to convert neg into pos no.\\n               min=Math.abs(nums[i]);\\n               dist=nums[i];\\n           }else if(Math.abs(nums[i])==min){\\n               if(nums[i] > dist){\\n                   dist=nums[i];\\n               }\\n               \\n           }\\n        }\\n        return dist;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=Integer.MAX_VALUE,dist=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n           if(Math.abs(nums[i])<min){  //Math.abs is a func to convert neg into pos no.\\n               min=Math.abs(nums[i]);\\n               dist=nums[i];\\n           }else if(Math.abs(nums[i])==min){\\n               if(nums[i] > dist){\\n                   dist=nums[i];\\n               }\\n               \\n           }\\n        }\\n        return dist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433173,
                "title": "find-closest-number-to-zero-solution-java",
                "content": "class Solution {\\n  public int findClosestNumber(int[] nums) {\\n    int ans = 0;\\n    int min = Integer.MAX_VALUE;\\n\\n    for (final int num : nums)\\n      if (Math.abs(num) < min) {\\n        min = Math.abs(num);\\n        ans = num;\\n      } else if (Math.abs(num) == min && num > ans) {\\n        ans = num;\\n      }\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n  public int findClosestNumber(int[] nums) {\\n    int ans = 0;\\n    int min = Integer.MAX_VALUE;\\n\\n    for (final int num : nums)\\n      if (Math.abs(num) < min) {\\n        min = Math.abs(num);\\n        ans = num;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2378044,
                "title": "easy-c-solution-using-pair",
                "content": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        \\n      pair<int,int> p;\\n        int mini= abs(nums[0]);\\n        p.first = mini;\\n        p.second = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n           if(p.first>abs(nums[i])){\\n              p.first = abs(nums[i]);\\n               p.second = nums[i];\\n           }\\n            else if(p.first == abs(nums[i])){\\n                 if(p.second<nums[i]){\\n                     p.second = nums[i];\\n                 }\\n            }\\n        }\\n        \\n        return p.second;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        \\n      pair<int,int> p;\\n        int mini= abs(nums[0]);\\n        p.first = mini;\\n        p.second = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n           if(p.first>abs(nums[i])){\\n              p.first = abs(nums[i]);\\n               p.second = nums[i];\\n           }\\n            else if(p.first == abs(nums[i])){\\n                 if(p.second<nums[i]){\\n                     p.second = nums[i];\\n                 }\\n            }\\n        }\\n        \\n        return p.second;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335663,
                "title": "with-explanation-comments-time-20-ms-97-79-space-19-6-mb-90-92",
                "content": "**Like it? ->Upvote please!**\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n\\t\\n        //initialize two variables, one for the number of steps from 0 & one to store the minimum value reached\\n        int step=0,min=INT_MAX,num=0;\\n        \\n        //loop over the whole array elements\\n        for(int n:nums){\\n            //get the number of steps from 0 to the current number\\n            step=abs(n);\\n            \\n            //store the min possible value\\n            if(step<min){\\n                min=step;\\n                num=n;\\n            }\\n            //if there\\'s two elements with the same number of steps-> return the max one bewteen the two numbers\\n            else if(step==min)\\n                num=max(n,num);\\n        }\\n        \\n        //return the minimum value\\n        return num;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n\\t\\n        //initialize two variables, one for the number of steps from 0 & one to store the minimum value reached\\n        int step=0,min=INT_MAX,num=0;\\n        \\n        //loop over the whole array elements\\n        for(int n:nums){\\n            //get the number of steps from 0 to the current number\\n            step=abs(n);\\n            \\n            //store the min possible value\\n            if(step<min){\\n                min=step;\\n                num=n;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2123218,
                "title": "python-easy-solution",
                "content": "Here I used the concept of Dictionary, since this only came to my mind during the contest.\\nFor better understanding remove the comments before the print statements and then run ur code, u will understand the ques and approach in much better way.\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        d={}\\n        for i in nums:\\n            d[i]=abs(i)\\n        \\n        dic = sorted(d.items(), key = lambda item: item[1])\\n        #print(dic)\\n        \\n        x=dic[0][1]\\n        for i in dic:\\n            #print(i[0],x)\\n            if i[0]>=0 and i[0]==x:\\n                return i[0]\\n        \\n        return dic[0][0]\\n```\\nIf u understood the code then plz.......UPVOTE...........Thnx in adv",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        d={}\\n        for i in nums:\\n            d[i]=abs(i)\\n        \\n        dic = sorted(d.items(), key = lambda item: item[1])\\n        #print(dic)\\n        \\n        x=dic[0][1]\\n        for i in dic:\\n            #print(i[0],x)\\n            if i[0]>=0 and i[0]==x:\\n                return i[0]\\n        \\n        return dic[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011991,
                "title": "easy-c-solution",
                "content": "```\\npublic class Solution {\\n    public int FindClosestNumber(int[] nums) {\\n        int result = nums[0];\\n        \\n        for(int i = 1; i<nums.Length;i++)\\n            if(Math.Abs(nums[i]) < Math.Abs(result))\\n                result = nums[i];\\n            else if(Math.Abs(nums[i]) == Math.Abs(result))\\n                result = Math.Max(result,nums[i]);\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int FindClosestNumber(int[] nums) {\\n        int result = nums[0];\\n        \\n        for(int i = 1; i<nums.Length;i++)\\n            if(Math.Abs(nums[i]) < Math.Abs(result))\\n                result = nums[i];\\n            else if(Math.Abs(nums[i]) == Math.Abs(result))\\n                result = Math.Max(result,nums[i]);\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004964,
                "title": "easy-to-understand-c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int ans=INT_MAX;\\n        for(auto x:nums)\\n        {\\n            if(abs(x)==abs(ans))\\n                ans=max(x,ans);\\n            \\n\\t\\t\\telse if(abs(x)<abs(ans))\\n                ans=x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int ans=INT_MAX;\\n        for(auto x:nums)\\n        {\\n            if(abs(x)==abs(ans))\\n                ans=max(x,ans);\\n            \\n\\t\\t\\telse if(abs(x)<abs(ans))\\n                ans=x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967408,
                "title": "uisng-vector-pair-alternate-way-in-cpp",
                "content": "bool cmp(const pair<int,int> &a,const pair<int,int> &b)\\n    {\\n        return (a.second < b.second);\\n    }\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        vector<pair<int,int>> vc;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n            vc.push_back({abs(nums[i]),nums[i]});\\n        \\n        sort(vc.begin(), vc.end(), cmp);\\n        int prevn=INT_MIN;\\n        int prevl=INT_MAX;\\n        for(auto i:vc)\\n        {\\n            if(i.first<=prevl)\\n            {\\n                prevl=i.first;\\n                if(prevn<i.second)\\n                {\\n                    prevn=i.second;\\n                }\\n            }\\n        }\\n        return prevn;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        vector<pair<int,int>> vc;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n            vc.push_back({abs(nums[i]),nums[i]}",
                "codeTag": "Java"
            },
            {
                "id": 1960467,
                "title": "c-easy-to-understand-approach-0-1-space-without-sorting",
                "content": "class Solution {\\npublic:\\n    int findClosestNumber(vector<int>& a) {\\n       int res1,res=INT_MIN,dif=INT_MAX;\\n       for(int i=0;i<a.size();i++)\\n       {\\n           if(abs(a[i]-0)<=dif)\\n           {\\n               //here we are checking if the present difference is equal to the previous one                    //then we will select the maximum one else we will jiust update it\\n               if(dif==abs(a[i])-0)\\n                   res=max(res,a[i]);\\n               else \\n                  res=a[i];\\n               \\n               dif=abs(a[i]-0);\\n               \\n               \\n           }\\n       }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findClosestNumber(vector<int>& a) {\\n       int res1,res=INT_MIN,dif=INT_MAX;\\n       for(int i=0;i<a.size();i++)\\n       {\\n           if(abs(a[i]-0)<=dif)\\n           {\\n               //here we are checking if the present difference is equal to the previous one                    //then we will select the maximum one else we will jiust update it\\n               if(dif==abs(a[i])-0)\\n                   res=max(res,a[i]);\\n               else \\n                  res=a[i];\\n               \\n               dif=abs(a[i]-0);\\n               \\n               \\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1956822,
                "title": "rust-solution",
                "content": "1. One-liner with ```fold```.\\n```\\nimpl Solution {\\n    pub fn find_closest_number(nums: Vec<i32>) -> i32 {\\n        use std::cmp::Ordering;\\n        nums.iter()\\n            .fold((i32::MIN, i32::MAX), |(val, dist), &x| {\\n                match dist.cmp(&(x.abs())) {\\n                    Ordering::Greater => (x, x.abs()),\\n                    Ordering::Equal => (x.max(val), dist),\\n                    Ordering::Less => (val, dist),\\n                }\\n            })\\n            .0\\n    }\\n}\\n```\\n\\n2. One-liner with ```max_by```.\\n```\\nimpl Solution {\\n    pub fn find_closest_number(nums: Vec<i32>) -> i32 {\\n        use std::cmp::Ordering;\\n        nums.into_iter()\\n            .max_by(|x, y| match y.abs().cmp(&(x.abs())) {\\n                Ordering::Equal => x.cmp(y),\\n                abs_cmp => abs_cmp,\\n            })\\n            .unwrap()\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```fold```\n```\\nimpl Solution {\\n    pub fn find_closest_number(nums: Vec<i32>) -> i32 {\\n        use std::cmp::Ordering;\\n        nums.iter()\\n            .fold((i32::MIN, i32::MAX), |(val, dist), &x| {\\n                match dist.cmp(&(x.abs())) {\\n                    Ordering::Greater => (x, x.abs()),\\n                    Ordering::Equal => (x.max(val), dist),\\n                    Ordering::Less => (val, dist),\\n                }\\n            })\\n            .0\\n    }\\n}\\n```\n```max_by```\n```\\nimpl Solution {\\n    pub fn find_closest_number(nums: Vec<i32>) -> i32 {\\n        use std::cmp::Ordering;\\n        nums.into_iter()\\n            .max_by(|x, y| match y.abs().cmp(&(x.abs())) {\\n                Ordering::Equal => x.cmp(y),\\n                abs_cmp => abs_cmp,\\n            })\\n            .unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1956593,
                "title": "c-simple-approach-greedy-easy-to-understand",
                "content": "```\\n// for more understanding please dry run the [-1000,-1000] case;\\n\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int mini=INT_MAX;\\n       \\n        for(int i=0;i<n;i++){\\n            \\n            int ans=abs(nums[i])-0;\\n            mini=min(ans,mini);\\n        }\\n        if(count(nums.begin(),nums.end(),mini)){\\n            return mini;\\n        }\\n        return -mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// for more understanding please dry run the [-1000,-1000] case;\\n\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int mini=INT_MAX;\\n       \\n        for(int i=0;i<n;i++){\\n            \\n            int ans=abs(nums[i])-0;\\n            mini=min(ans,mini);\\n        }\\n        if(count(nums.begin(),nums.end(),mini)){\\n            return mini;\\n        }\\n        return -mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954994,
                "title": "rust-solution-one-pass-0ms",
                "content": "```rust\\nimpl Solution {\\n    pub fn find_closest_number(nums: Vec<i32>) -> i32 {\\n        nums.iter()\\n            .fold((-100001, 100001), |(res, min), &x| {\\n                if x.abs() < min {\\n                    (x, x.abs())\\n                } else if x.abs() == min {\\n                    (res.max(x), min)\\n                } else {\\n                    (res, min)\\n                }\\n            })\\n            .0\\n    }\\n}\\n```\\n\\nThe following (original) post will fail on `[2, -1, 1]`. Thanks to [@BigMih](https://leetcode.com/BigMih/) for pointing out the error in the code.\\n```\\nimpl Solution {\\n    pub fn find_closest_number(nums: Vec<i32>) -> i32 {\\n        nums.iter()\\n            .fold((-100001, 100001), |(res, min), &x| {\\n                if x.abs() <= min {\\n                    (res.max(x), x.abs())\\n                } else {\\n                    (res, min)\\n                }\\n            })\\n            .0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn find_closest_number(nums: Vec<i32>) -> i32 {\\n        nums.iter()\\n            .fold((-100001, 100001), |(res, min), &x| {\\n                if x.abs() < min {\\n                    (x, x.abs())\\n                } else if x.abs() == min {\\n                    (res.max(x), min)\\n                } else {\\n                    (res, min)\\n                }\\n            })\\n            .0\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn find_closest_number(nums: Vec<i32>) -> i32 {\\n        nums.iter()\\n            .fold((-100001, 100001), |(res, min), &x| {\\n                if x.abs() <= min {\\n                    (res.max(x), x.abs())\\n                } else {\\n                    (res, min)\\n                }\\n            })\\n            .0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1953810,
                "title": "c-100-short-easy-o-n",
                "content": "```\\nint findClosestNumber(int* nums, int numsSize)\\n{\\n    int min = INT_MAX;\\n    int val = INT_MAX;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (abs(nums[i]) <= min) {\\n            min = abs(nums[i]);\\n            if (abs(val) == abs(nums[i]))\\n                val = val > nums[i] ? val : nums[i];\\n            else\\n                val = nums[i];\\n            printf(\"%d \", val);\\n        }\\n    }\\n    return val;\\n}\\n```\\n\\n**If this was helpful, don\\'t hesitate to upvote! :)**\\nHave a nice day!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findClosestNumber(int* nums, int numsSize)\\n{\\n    int min = INT_MAX;\\n    int val = INT_MAX;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (abs(nums[i]) <= min) {\\n            min = abs(nums[i]);\\n            if (abs(val) == abs(nums[i]))\\n                val = val > nums[i] ? val : nums[i];\\n            else\\n                val = nums[i];\\n            printf(\"%d \", val);\\n        }\\n    }\\n    return val;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055052,
                "title": "optimized-solutions-in-c-and-java-with-clear-explanation",
                "content": "# Explaination\\n1) Initialize $$closest$$ with the first element of the array.\\n\\n2) Iterate through the array, comparing the absolute values of each element with the absolute value of $$closest$$.\\n\\n- Calculate the absolute value of $$current$$ using the $$abs()$$ function.\\n\\n- If the absolute value of the $$current$$ element is smaller than the absolute value of $$closest$$, update $$closest$$ to the current element.\\n\\n- If the absolute values are equal, compare the actual values of the $$current$$ element and $$closest$$. If the $$current$$ element is greater, update $$closest$$ to the $$current$$ element.\\n\\n3. After iterating through all elements, $$closest$$ holds the number closest to zero in terms of its absolute value.\\n\\n4. Return $$closest$$ as the result.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Cpp Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(std::vector<int>& nums) {\\n        int closest = nums[0]; \\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            int current = nums[i];\\n\\n            if (abs(current) < abs(closest) || (abs(current) == abs(closest) && current > closest)) {\\n                closest = current;\\n            }\\n        }\\n\\n        return closest;\\n    }\\n};\\n\\n```\\n# Java Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(std::vector<int>& nums) {\\n        int closest = nums[0]; \\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            int current = nums[i];\\n\\n            if (abs(current) < abs(closest) || (abs(current) == abs(closest) && current > closest)) {\\n                closest = current;\\n            }\\n        }\\n\\n        return closest;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(std::vector<int>& nums) {\\n        int closest = nums[0]; \\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            int current = nums[i];\\n\\n            if (abs(current) < abs(closest) || (abs(current) == abs(closest) && current > closest)) {\\n                closest = current;\\n            }\\n        }\\n\\n        return closest;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(std::vector<int>& nums) {\\n        int closest = nums[0]; \\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            int current = nums[i];\\n\\n            if (abs(current) < abs(closest) || (abs(current) == abs(closest) && current > closest)) {\\n                closest = current;\\n            }\\n        }\\n\\n        return closest;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681783,
                "title": "easy-c-solution-beginner-friendly-approach-beats-90",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int ans=INT_MAX;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            int dist = abs(nums[i]), val = nums[i];\\n            if(dist<abs(ans))\\n                ans = val;\\n            else if(dist==abs(ans))\\n                ans = ans>val ? ans : val;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int ans=INT_MAX;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            int dist = abs(nums[i]), val = nums[i];\\n            if(dist<abs(ans))\\n                ans = val;\\n            else if(dist==abs(ans))\\n                ans = ans>val ? ans : val;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561280,
                "title": "beginners-friendly-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=Integer.MAX_VALUE;\\n        int res=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(Math.abs(nums[i])< min || nums[i]== Math.abs(min) ){\\n                min=Math.abs(nums[i]);\\n                res=nums[i];\\n\\n            } \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=Integer.MAX_VALUE;\\n        int res=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(Math.abs(nums[i])< min || nums[i]== Math.abs(min) ){\\n                min=Math.abs(nums[i]);\\n                res=nums[i];\\n\\n            } \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405983,
                "title": "self-explanatory-code",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        diff = 99999999\\n        ans = 999999999\\n        for i in nums:\\n            if abs(0-i) < diff:\\n                diff = abs(0-i)\\n                ans = i\\n            if diff == abs(0-i):\\n                diff = abs(0-i)\\n                ans = max(ans, i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        diff = 99999999\\n        ans = 999999999\\n        for i in nums:\\n            if abs(0-i) < diff:\\n                diff = abs(0-i)\\n                ans = i\\n            if diff == abs(0-i):\\n                diff = abs(0-i)\\n                ans = max(ans, i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382827,
                "title": "easy-and-beginners-friendly-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntaking the positive elements and negative elements in seperate vectors\\nand sorting them...taking the last element of the negtive vector and the first element of the positive vector... finaly checking for the smallest number of those two...\\n\\nadd a comment if you have better solution\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        vector<int> pos;\\n        vector<int> neg;\\n        for(auto x: nums){\\n            if(x>0){\\n                pos.push_back(x);\\n            }\\n            else{\\n                neg.push_back(x);\\n            }\\n            if(x==0){\\n                return 0;\\n            }\\n        }\\n        if(pos.size()!=0){\\n            sort(pos.begin(),pos.end());\\n        }\\n        if(neg.size()!=0){\\n            sort(neg.begin(),neg.end());\\n        }\\n        int n=neg.size();\\n        if(pos.size()==0){\\n            return neg[n-1]; \\n        }\\n        if(neg.size()==0){\\n            return pos[0];\\n        }\\n        return abs(neg[n-1])<pos[0] ? neg[n-1]:pos[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        vector<int> pos;\\n        vector<int> neg;\\n        for(auto x: nums){\\n            if(x>0){\\n                pos.push_back(x);\\n            }\\n            else{\\n                neg.push_back(x);\\n            }\\n            if(x==0){\\n                return 0;\\n            }\\n        }\\n        if(pos.size()!=0){\\n            sort(pos.begin(),pos.end());\\n        }\\n        if(neg.size()!=0){\\n            sort(neg.begin(),neg.end());\\n        }\\n        int n=neg.size();\\n        if(pos.size()==0){\\n            return neg[n-1]; \\n        }\\n        if(neg.size()==0){\\n            return pos[0];\\n        }\\n        return abs(neg[n-1])<pos[0] ? neg[n-1]:pos[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296518,
                "title": "reduce-ternary-operators-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findClosestNumber = function(nums) {\\n    return nums.reduce((acc, num) => Math.abs(num) < Math.abs(acc)\\n        ? num\\n        : Math.abs(num) === Math.abs(acc)\\n            ? Math.max(num, acc)\\n            : acc,\\n    );\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findClosestNumber = function(nums) {\\n    return nums.reduce((acc, num) => Math.abs(num) < Math.abs(acc)\\n        ? num\\n        : Math.abs(num) === Math.abs(acc)\\n            ? Math.max(num, acc)\\n            : acc,\\n    );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3291925,
                "title": "c-one-line-solution-using-linq",
                "content": "# Intuition\\nC# is the most handy language to write any piece of code using built in functions.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSmart LINQ Techniques\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindClosestNumber(int[] nums) {\\n        int t=0;\\n        int m=nums.OrderBy(x=> Math.Abs((long)x-t)).ThenByDescending(x=>x).First();\\n        return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindClosestNumber(int[] nums) {\\n        int t=0;\\n        int m=nums.OrderBy(x=> Math.Abs((long)x-t)).ThenByDescending(x=>x).First();\\n        return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281248,
                "title": "java-javascript-solution-jw",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nJava:\\n```\\npublic int findClosestNumber(int[] nums) {\\n    int res = Integer.MAX_VALUE;\\n    for (int i: nums) {\\n        if (Math.abs(i) < Math.abs(res) || i == Math.abs(res)) {\\n            res = i;\\n        }\\n    }\\n    return res;\\n}\\n```\\nJavascript:\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findClosestNumber = function(nums) {\\n    let res = Number.MAX_VALUE;\\n    for (let i of nums) {\\n        if (Math.abs(i) < Math.abs(res) || i === Math.abs(res)) {\\n            res = i;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\npublic int findClosestNumber(int[] nums) {\\n    int res = Integer.MAX_VALUE;\\n    for (int i: nums) {\\n        if (Math.abs(i) < Math.abs(res) || i == Math.abs(res)) {\\n            res = i;\\n        }\\n    }\\n    return res;\\n}\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findClosestNumber = function(nums) {\\n    let res = Number.MAX_VALUE;\\n    for (let i of nums) {\\n        if (Math.abs(i) < Math.abs(res) || i === Math.abs(res)) {\\n            res = i;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3268168,
                "title": "simple-python-beats-93",
                "content": "# Code\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        h=min([abs(i) for i in nums])\\n        return h if h in nums else -h\\n            \\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        h=min([abs(i) for i in nums])\\n        return h if h in nums else -h\\n            \\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154753,
                "title": "go",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\n\\n\\nfunc findClosestNumber(nums []int) int {\\n    closestNumber := -math.MaxInt\\n    closestAbsNumber := math.MaxInt\\n\\n    for _, num := range nums {\\n        diff := int(math.Abs(float64(num)))\\n\\n        if diff < closestAbsNumber {\\n            closestAbsNumber = diff\\n            closestNumber = num\\n        } else if diff == closestAbsNumber {\\n            closestNumber = max(closestNumber, num)\\n        }\\n    }\\n\\n    return closestNumber\\n}\\n\\n\\n// max returns larger digit\\nfunc max(num1, num2 int) int {\\n    if num1 < num2 {\\n        return num2\\n    }\\n\\n    return num1\\n} \\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\n\\nfunc findClosestNumber(nums []int) int {\\n    closestNumber := -math.MaxInt\\n    closestAbsNumber := math.MaxInt\\n\\n    for _, num := range nums {\\n        diff := int(math.Abs(float64(num)))\\n\\n        if diff < closestAbsNumber {\\n            closestAbsNumber = diff\\n            closestNumber = num\\n        } else if diff == closestAbsNumber {\\n            closestNumber = max(closestNumber, num)\\n        }\\n    }\\n\\n    return closestNumber\\n}\\n\\n\\n// max returns larger digit\\nfunc max(num1, num2 int) int {\\n    if num1 < num2 {\\n        return num2\\n    }\\n\\n    return num1\\n} \\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3075368,
                "title": "python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        a=[abs(i) for i in nums]\\n        b=[]\\n        for j in nums:\\n            if abs(j)==min(a):\\n                b.append(j)\\n        return max(b)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        a=[abs(i) for i in nums]\\n        b=[]\\n        for j in nums:\\n            if abs(j)==min(a):\\n                b.append(j)\\n        return max(b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827111,
                "title": "java-find-closest-number-to-zero",
                "content": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans=0;\\n        int val=nums[0];\\n        for(int i:nums){\\n            if(i==0)return 0;\\n            if(i>0){\\n                ans=i;break;\\n            }\\n            val=i;\\n        }\\n        \\n        if(ans==0)return nums[nums.length-1];\\n        if(Math.abs(val)<ans)return val;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans=0;\\n        int val=nums[0];\\n        for(int i:nums){\\n            if(i==0)return 0;\\n            if(i>0){\\n                ans=i;break;\\n            }\\n            val=i;\\n        }\\n        \\n        if(ans==0)return nums[nums.length-1];\\n        if(Math.abs(val)<ans)return val;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746354,
                "title": "python-easy-solution-in-o-n-tc-without-using-extra-space",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        m=100000000\\n        for i in nums:\\n            if abs(m)>=abs(i):\\n                if abs(m)==abs(i):\\n                    if i>m:\\n                        m=i\\n                else:\\n                    m=i\\n        return m\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        m=100000000\\n        for i in nums:\\n            if abs(m)>=abs(i):\\n                if abs(m)==abs(i):\\n                    if i>m:\\n                        m=i\\n                else:\\n                    m=i\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744784,
                "title": "python-easy",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        val=[] \\n        for i in nums:\\n            val.append([i,abs(i)])\\n        val=sorted(val,key=lambda x:(x[1],-x[0])) \\n        return val[0][0]\\n        \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        val=[] \\n        for i in nums:\\n            val.append([i,abs(i)])\\n        val=sorted(val,key=lambda x:(x[1],-x[0])) \\n        return val[0][0]\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 2731715,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int findClosestNumber(vector<int>& nums) \\n    {\\n        int a = INT_MAX;\\n        int b = INT_MIN;\\n        for(int i:nums)\\n        {\\n            if(i>0)\\n                a = min(a,i);\\n            else if(0>i)\\n                b = max(b,i);\\n            else\\n                return 0;\\n        }\\n        if(b == INT_MIN)\\n            return a;\\n        else if(a == INT_MAX)\\n            return b;\\n        else if(abs(b) < a)\\n            return b;\\n        else\\n            return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int findClosestNumber(vector<int>& nums) \\n    {\\n        int a = INT_MAX;\\n        int b = INT_MIN;\\n        for(int i:nums)\\n        {\\n            if(i>0)\\n                a = min(a,i);\\n            else if(0>i)\\n                b = max(b,i);\\n            else\\n                return 0;\\n        }\\n        if(b == INT_MIN)\\n            return a;\\n        else if(a == INT_MAX)\\n            return b;\\n        else if(abs(b) < a)\\n            return b;\\n        else\\n            return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692024,
                "title": "javascript-92-faster",
                "content": "```\\nvar findClosestNumber = function(nums) {\\n    \\n    let closest = nums[0];\\n    let closestAbs = Math.abs(nums[0]);\\n    \\n    for (let i = 1; i < nums.length; i++) {\\n        \\n        let number = nums[i];\\n        let absNumber = Math.abs(number);\\n        \\n        if (number == 0)\\n            return 0;\\n        \\n        if (absNumber <= closestAbs) {\\n            \\n            if (absNumber < closestAbs) {\\n                \\n                closest = number;\\n                closestAbs = absNumber\\n                \\n            } else {\\n                \\n                if (closest < number) {\\n                    \\n                    closest = number;\\n                    closestAbs = absNumber\\n                    \\n                }\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    return closest;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findClosestNumber = function(nums) {\\n    \\n    let closest = nums[0];\\n    let closestAbs = Math.abs(nums[0]);\\n    \\n    for (let i = 1; i < nums.length; i++) {\\n        \\n        let number = nums[i];\\n        let absNumber = Math.abs(number);\\n        \\n        if (number == 0)\\n            return 0;\\n        \\n        if (absNumber <= closestAbs) {\\n            \\n            if (absNumber < closestAbs) {\\n                \\n                closest = number;\\n                closestAbs = absNumber\\n                \\n            } else {\\n                \\n                if (closest < number) {\\n                    \\n                    closest = number;\\n                    closestAbs = absNumber\\n                    \\n                }\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    return closest;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2669874,
                "title": "c-solution-for-bignner",
                "content": "Easy To Understand For Bignner \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        \\n        int ans=nums[0];\\n\\n        int diff=abs(nums[0]);\\n\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(abs(nums[i]) < diff)\\n            {\\n                ans=nums[i];\\n                diff=abs(nums[i]);\\n            }\\n\\n            if(diff==abs(nums[i]) && nums[i]>ans)\\n            {\\n                ans=nums[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        \\n        int ans=nums[0];\\n\\n        int diff=abs(nums[0]);\\n\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(abs(nums[i]) < diff)\\n            {\\n                ans=nums[i];\\n                diff=abs(nums[i]);\\n            }\\n\\n            if(diff==abs(nums[i]) && nums[i]>ans)\\n            {\\n                ans=nums[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661091,
                "title": "c-easy-solution-tc-o-n-sc-o-1",
                "content": "```\\nint findClosestNumber(vector<int>& nums) \\n    {\\n        /* answer can be two optiion\\n        if positive then minimum; a\\n        if negative then maximum; b\\n        jo minimum hoga wo return kardo;\\n        */\\n        int a = INT_MAX;\\n        int b = INT_MIN;\\n        for(int i:nums)\\n        {\\n            if(i>0)\\n                a = min(a,i);\\n            else if(0>i)\\n                b = max(b,i);\\n            else\\n                return 0;\\n        }\\n        if(b == INT_MIN)\\n            return a;\\n        else if(a == INT_MAX)\\n            return b;\\n        else if(abs(b) < a)\\n            return b;\\n        else\\n            return a;\\n    }",
                "solutionTags": [],
                "code": "```\\nint findClosestNumber(vector<int>& nums) \\n    {\\n        /* answer can be two optiion\\n        if positive then minimum; a\\n        if negative then maximum; b\\n        jo minimum hoga wo return kardo;\\n        */\\n        int a = INT_MAX;\\n        int b = INT_MIN;\\n        for(int i:nums)\\n        {\\n            if(i>0)\\n                a = min(a,i);\\n            else if(0>i)\\n                b = max(b,i);\\n            else\\n                return 0;\\n        }\\n        if(b == INT_MIN)\\n            return a;\\n        else if(a == INT_MAX)\\n            return b;\\n        else if(abs(b) < a)\\n            return b;\\n        else\\n            return a;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2638928,
                "title": "c-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& arr) {\\n        int temp=INT_MAX;\\n\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==0)\\n                return 0;\\n            if(abs(temp)>abs(arr[i])){\\n                temp=arr[i];\\n            }\\n           else if(abs(temp)==abs(arr[i]) && arr[i]>0)\\n                temp=arr[i];\\n        }\\n        return temp;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findClosestNumber(vector<int>& arr) {\\n        int temp=INT_MAX;\\n\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==0)\\n                return 0;\\n            if(abs(temp)>abs(arr[i])){\\n                temp=arr[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2440992,
                "title": "easily-understandable-c",
                "content": "```\\nTime: O(n)  Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int res=INT_MAX;\\n        for(auto& x: nums){\\n            if(abs(x)<abs(res))\\n                res=x;\\n            else if(abs(x)==abs(res))\\n                res=max(res,x);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nTime: O(n)  Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int res=INT_MAX;\\n        for(auto& x: nums){\\n            if(abs(x)<abs(res))\\n                res=x;\\n            else if(abs(x)==abs(res))\\n                res=max(res,x);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402377,
                "title": "easy-and-clear-python-3-solution",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        close=nums[0]\\n        for r in range(1,len(nums)):\\n            if abs(nums[r])<abs(close):\\n                close=nums[r]\\n            if abs(nums[r])==abs(close) and nums[r]>0:\\n                close=nums[r]\\n        return close\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        close=nums[0]\\n        for r in range(1,len(nums)):\\n            if abs(nums[r])<abs(close):\\n                close=nums[r]\\n            if abs(nums[r])==abs(close) and nums[r]>0:\\n                close=nums[r]\\n        return close\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349670,
                "title": "o-n-2ms-t-c",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n        int max = -100000;\\n        int dist = 100000;\\n        for (int i: nums) {\\n            if (dist > Math.abs(i)){\\n                dist = Math.abs(i);\\n                max = i;\\n            }\\n            else if (dist == Math.abs(i)){\\n                dist = Math.abs(i);\\n                max = Math.max(max, i);\\n            }\\n        }\\n        return max;",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2247852,
                "title": "simplest-solution-closest-to-zero-in-c",
                "content": "int findClosestNumber(int* nums, int numsSize){\\n    int i=0;\\n    int min=nums[i];\\n    \\n    for( i=1;i<numsSize;i++)\\n    {\\n        if(abs(nums[i])<abs(min)||nums[i]==abs(min))\\n        {\\n            min=nums[i];\\n        }\\n    }\\n    return min;\\n    \\n    \\n\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "int findClosestNumber(int* nums, int numsSize){\\n    int i=0;\\n    int min=nums[i];\\n    \\n    for( i=1;i<numsSize;i++)\\n    {\\n        if(abs(nums[i])<abs(min)||nums[i]==abs(min))\\n        {\\n            min=nums[i];\\n        }\\n    }\\n    return min;\\n    \\n    \\n\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2241418,
                "title": "3-liner-java",
                "content": "```\\npublic int findClosestNumber(int[] nums) {\\n        PriorityQueue<Integer> heap = new PriorityQueue<>(new Comparator<Integer>(){\\n            public int compare(Integer a,Integer b){\\n                if(Math.abs(a)==Math.abs(b)) return b-a;\\n                return Integer.compare(Math.abs(a),Math.abs(b));\\n            }\\n        });\\n        for(int i:nums) heap.add(i);\\n        return heap.remove();\\n    }",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic int findClosestNumber(int[] nums) {\\n        PriorityQueue<Integer> heap = new PriorityQueue<>(new Comparator<Integer>(){\\n            public int compare(Integer a,Integer b){\\n                if(Math.abs(a)==Math.abs(b)) return b-a;\\n                return Integer.compare(Math.abs(a),Math.abs(b));\\n            }\\n        });\\n        for(int i:nums) heap.add(i);\\n        return heap.remove();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2192384,
                "title": "python-solution-2-solutions",
                "content": "Approach 1:\\n\\n\\t\\tclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        num=float(\\'inf\\')\\n        nums.sort()\\n        for i in nums:\\n            if abs(i)<=num:\\n                num=abs(i)\\n                c=i\\n        return c\\n\\t\\t\\n\\t\\t\\nApproach 2:\\n\\n\\t\\tclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n            res=[abs(ele) for ele in nums]\\n            a=(min(res))\\n            if a in nums:\\n                return a\\n            else:\\n                return a*-1\\n            \\n        \\n",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "Approach 1:\\n\\n\\t\\tclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        num=float(\\'inf\\')\\n        nums.sort()\\n        for i in nums:\\n            if abs(i)<=num:\\n                num=abs(i)\\n                c=i\\n        return c\\n\\t\\t\\n\\t\\t\\nApproach 2:\\n\\n\\t\\tclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n            res=[abs(ele) for ele in nums]\\n            a=(min(res))\\n            if a in nums:\\n                return a\\n            else:\\n                return a*-1\\n            \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 2186118,
                "title": "easy-understanding-c",
                "content": "\\n\\n\\n int findClosestNumber(vector<int>& nums) {\\n\\n        priority_queue<pair<int,int> > pq;\\n        int n=nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            pq.push({abs(nums[i]),nums[i]});\\n            if(pq.size()>1) pq.pop();\\n        }\\n        \\n        if(pq.top().second<0 && find(nums.begin(), nums.end(), pq.top().first)==nums.end())\\n        return pq.top().second;\\n        else{\\n            return pq.top().first;\\n        }\\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "\\n\\n\\n int findClosestNumber(vector<int>& nums) {\\n\\n        priority_queue<pair<int,int> > pq;\\n        int n=nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            pq.push({abs(nums[i]),nums[i]});\\n            if(pq.size()>1) pq.pop();\\n        }\\n        \\n        if(pq.top().second<0 && find(nums.begin(), nums.end(), pq.top().first)==nums.end())\\n        return pq.top().second;\\n        else{\\n            return pq.top().first;\\n        }\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2175965,
                "title": "js-javascript-75-faster-easy-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst findClosestNumber = function(nums) {\\n\\n  let negative = nums.filter(i => i < 0)\\n  let positives = nums.filter(i => 0 <= i)\\n\\n  let max = !negative.length ? Number.MIN_SAFE_INTEGER : negative.reduce((r, i) => Math.max(r, i))\\n  let min = !positives.length ? Number.MAX_SAFE_INTEGER : positives.reduce((r, i) => Math.min(r, i))\\n\\n  return Math.abs(min) <= Math.abs(max) ? min : max\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst findClosestNumber = function(nums) {\\n\\n  let negative = nums.filter(i => i < 0)\\n  let positives = nums.filter(i => 0 <= i)\\n\\n  let max = !negative.length ? Number.MIN_SAFE_INTEGER : negative.reduce((r, i) => Math.max(r, i))\\n  let min = !positives.length ? Number.MAX_SAFE_INTEGER : positives.reduce((r, i) => Math.min(r, i))\\n\\n  return Math.abs(min) <= Math.abs(max) ? min : max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2137831,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n      int minDis=0;\\n      int check=Integer.MAX_VALUE;\\n      for(int i=0;i<nums.length;i++){\\n         \\n          int dis=Math.abs(nums[i]);\\n          \\n          if(nums[i]>=0 && dis<=check){\\n              check=nums[i];\\n              minDis=nums[i];\\n          }\\n          else if(nums[i]<0 && dis<check){\\n              check=-nums[i];\\n              minDis=nums[i];\\n          }\\n      }\\n        return minDis;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n      int minDis=0;\\n      int check=Integer.MAX_VALUE;\\n      for(int i=0;i<nums.length;i++){\\n         \\n          int dis=Math.abs(nums[i]);\\n          \\n          if(nums[i]>=0 && dis<=check){\\n              check=nums[i];\\n              minDis=nums[i];\\n          }\\n          else if(nums[i]<0 && dis<check){\\n              check=-nums[i];\\n              minDis=nums[i];\\n          }\\n      }\\n        return minDis;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2129378,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, x: List[int]) -> int:\\n        return -min((abs(i),-i) for i in x)[1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, x: List[int]) -> int:\\n        return -min((abs(i),-i) for i in x)[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109818,
                "title": "easy-python-solution-for-beginners",
                "content": "```\\ndef findClosestNumber(self, nums: List[int]) -> int:\\n        m=nums[0]\\n        for i in nums:\\n            if abs(m)>=abs(i):\\n                if abs(m)==abs(i):\\n                    m=max(m,i)\\n                else:\\n                    m=i\\n        return m\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef findClosestNumber(self, nums: List[int]) -> int:\\n        m=nums[0]\\n        for i in nums:\\n            if abs(m)>=abs(i):\\n                if abs(m)==abs(i):\\n                    m=max(m,i)\\n                else:\\n                    m=i\\n        return m\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2108429,
                "title": "simple-approach-in-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int x=INT_MAX;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n                if(abs(x)>abs(nums[i]))\\n                x=nums[i];\\n                else if(abs(x)==abs(nums[i])){\\n                    x=max(x,nums[i]);\\n                }\\n            \\n          \\n            \\n        }return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int x=INT_MAX;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n                if(abs(x)>abs(nums[i]))\\n                x=nums[i];\\n                else if(abs(x)==abs(nums[i])){\\n                    x=max(x,nums[i]);\\n                }\\n            \\n          \\n            \\n        }return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107640,
                "title": "c-21-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(const vector<int>& nums) {\\n        int neg=-100001,pos=100001;\\n        for(auto i:nums) {\\n            if(!i) return 0;\\n            if(i<0) neg=max(neg,i);\\n            else    pos=min(pos,i);\\n        }\\n        return -neg==pos?pos:-neg<pos?neg:pos;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(const vector<int>& nums) {\\n        int neg=-100001,pos=100001;\\n        for(auto i:nums) {\\n            if(!i) return 0;\\n            if(i<0) neg=max(neg,i);\\n            else    pos=min(pos,i);\\n        }\\n        return -neg==pos?pos:-neg<pos?neg:pos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105517,
                "title": "c-o-n-pairs",
                "content": "int findClosestNumber(vector<int>& nums) {\\n        pair<int,int>p={100000000,1000000000};\\n        for(int i=0;i<nums.size();i++){\\n            if(abs(nums[i])<p.second){//this line for checking weather there exist lesser value then pair hold which closest to 0\\n                p={nums[i],abs(nums[i])};\\n            }\\n            if((abs(nums[i])==p.second)&&nums[i]>p.first)p={nums[i],abs(nums[i])}; this line for if there exist -2 , 2 which one to pick\\n        }\\n        return p.first;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "int findClosestNumber(vector<int>& nums) {\\n        pair<int,int>p={100000000,1000000000};\\n        for(int i=0;i<nums.size();i++){\\n            if(abs(nums[i])<p.second){//this line for checking weather there exist lesser value then pair hold which closest to 0\\n                p={nums[i],abs(nums[i])};\\n            }\\n            if((abs(nums[i])==p.second)&&nums[i]>p.first)p={nums[i],abs(nums[i])}; this line for if there exist -2 , 2 which one to pick\\n        }\\n        return p.first;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2085061,
                "title": "easy-js-solution",
                "content": "```\\n//Solution 1\\nvar findClosestNumber = function(nums) {\\n    \\n    let pos = Infinity;\\n    let neg = -Infinity;\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        \\n        if( nums[i] > 0 ){\\n           if( pos > nums[i] ) \\n               pos = nums[i];               \\n        } else {\\n            if( neg < nums[i] )\\n                neg = nums[i];\\n        } \\n    }\\n    \\n    if( -neg < pos ) {\\n       return neg;\\n    }\\n    \\n    return pos;   \\n};\\n\\n//Solution 2\\nvar findClosestNumber = function(nums) {\\n    \\n    let result = nums[0];\\n    \\n    for(let i=1; i<nums.length; i++) {\\n        \\n        let mod = Math.abs(nums[i]);\\n        \\n        if( Math.abs(result)>mod ) {            \\n            result = nums[i]\\n        }\\n        \\n        if( Math.abs(result) == mod ) {\\n            if( result<nums[i] ) {\\n                result = nums[i];\\n            }\\n        }\\n    }\\n    \\n    return result;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n//Solution 1\\nvar findClosestNumber = function(nums) {\\n    \\n    let pos = Infinity;\\n    let neg = -Infinity;\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        \\n        if( nums[i] > 0 ){\\n           if( pos > nums[i] ) \\n               pos = nums[i];               \\n        } else {\\n            if( neg < nums[i] )\\n                neg = nums[i];\\n        } \\n    }\\n    \\n    if( -neg < pos ) {\\n       return neg;\\n    }\\n    \\n    return pos;   \\n};\\n\\n//Solution 2\\nvar findClosestNumber = function(nums) {\\n    \\n    let result = nums[0];\\n    \\n    for(let i=1; i<nums.length; i++) {\\n        \\n        let mod = Math.abs(nums[i]);\\n        \\n        if( Math.abs(result)>mod ) {            \\n            result = nums[i]\\n        }\\n        \\n        if( Math.abs(result) == mod ) {\\n            if( result<nums[i] ) {\\n                result = nums[i];\\n            }\\n        }\\n    }\\n    \\n    return result;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2042096,
                "title": "python-one-line-functional-approach",
                "content": "We need to find value with the minimum module, the biggest number of those. \\nWe could take advantage of using ``min()`` function which returns minimal value from an iterator. Also taking advantage of tuple comparison we could build tuple like ``(abs(value), -value, value)`` - so that we first compare absolute values, then negated value. The third element of the tuple is the original value, which we would like to return. \\nSo, we do the following:\\n1. Transform the array to an iterator of tuples described above\\n2. Find minimum value for this sequence. Note that for same absolute value (first tuple element) we compare the second, which is negated value of the original array element, thus we would have minimal value here for the maximum value of the array with the same absolute value.\\n3. Return the oriiginal value which is the third item of the tuple.\\n\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return min([(abs(n), -n, n) for n in nums])[2]\\n```\\n\\nOr, simplifying that we could remove third tuple element, returning the second one negated:\\n\\n\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return -min([(abs(n), -n) for n in nums])[1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return min([(abs(n), -n, n) for n in nums])[2]\\n```\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return -min([(abs(n), -n) for n in nums])[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976510,
                "title": "c-linq-one-line",
                "content": "```\\n    public int FindClosestNumber(int[] nums) \\n    {        \\n        return nums.Select(x => x).OrderBy(x => Math.Abs(x)).ThenByDescending(x=>x).First();\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int FindClosestNumber(int[] nums) \\n    {        \\n        return nums.Select(x => x).OrderBy(x => Math.Abs(x)).ThenByDescending(x=>x).First();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1970777,
                "title": "easy-java-solution-faster-than-70",
                "content": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n       int smallestDis = nums[0];\\n        \\n            for (int j = 1; j < nums.length; j++) {\\n\\n                if (Math.abs(smallestDis) == (nums[j])){\\n                    smallestDis = nums[j];\\n                }\\n                if(Math.abs(nums[j]) < Math.abs(smallestDis)){\\n                    smallestDis = nums[j];\\n                }\\n            }\\n        return smallestDis;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n       int smallestDis = nums[0];\\n        \\n            for (int j = 1; j < nums.length; j++) {\\n\\n                if (Math.abs(smallestDis) == (nums[j])){\\n                    smallestDis = nums[j];\\n                }\\n                if(Math.abs(nums[j]) < Math.abs(smallestDis)){\\n                    smallestDis = nums[j];\\n                }\\n            }\\n        return smallestDis;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966803,
                "title": "ruby-one-liner-rust-port",
                "content": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_closest_number(nums)\\n  nums.min_by { [_1.abs, -_1] }  \\nend\\n```\\n\\n```\\nimpl Solution {\\n    pub fn find_closest_number(nums: Vec<i32>) -> i32 {\\n        *nums.iter().min_by_key(|&x| (x.abs(), -x)).unwrap()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_closest_number(nums)\\n  nums.min_by { [_1.abs, -_1] }  \\nend\\n```\n```\\nimpl Solution {\\n    pub fn find_closest_number(nums: Vec<i32>) -> i32 {\\n        *nums.iter().min_by_key(|&x| (x.abs(), -x)).unwrap()\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1966166,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        Min=nums[0]\\n        for i in range(len(nums)):\\n            if abs(Min)>abs(nums[i]):\\n                Min=nums[i]\\n            elif abs(Min)==abs(nums[i]):\\n                Min=max(Min,nums[i])\\n        return Min\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        Min=nums[0]\\n        for i in range(len(nums)):\\n            if abs(Min)>abs(nums[i]):\\n                Min=nums[i]\\n            elif abs(Min)==abs(nums[i]):\\n                Min=max(Min,nums[i])\\n        return Min\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963093,
                "title": "kotlin",
                "content": "```kotlin\\n  fun findClosestNumber(numbers: IntArray): Int {\\n    var closest = numbers[0]\\n    \\n    for (number in numbers) {\\n      val distance = abs(closest) -  abs(number)\\n      \\n      when {\\n        distance == 0 -> closest = maxOf(closest, number)\\n        distance > 0 -> closest = number\\n      }\\n    }\\n    \\n    return closest\\n  }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\n  fun findClosestNumber(numbers: IntArray): Int {\\n    var closest = numbers[0]\\n    \\n    for (number in numbers) {\\n      val distance = abs(closest) -  abs(number)\\n      \\n      when {\\n        distance == 0 -> closest = maxOf(closest, number)\\n        distance > 0 -> closest = number\\n      }\\n    }\\n    \\n    return closest\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1960009,
                "title": "c-easy-to-understand-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        map<int, vector<int>> m;\\n        for(auto& i : nums){\\n            m[abs(i)].push_back(i);\\n        }\\n        auto itr = m.begin();\\n        vector<int> v;\\n        v = itr->second;\\n        int l = v.size();\\n        sort(v.begin(), v.end());\\n        return v[l-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        map<int, vector<int>> m;\\n        for(auto& i : nums){\\n            m[abs(i)].push_back(i);\\n        }\\n        auto itr = m.begin();\\n        vector<int> v;\\n        v = itr->second;\\n        int l = v.size();\\n        sort(v.begin(), v.end());\\n        return v[l-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958501,
                "title": "c-simple-o-n-solution",
                "content": "```\\n\\tpublic int FindClosestNumber(int[] nums) {\\n        var maxNegative = int.MinValue + 1; // to prevent overflow exception\\n        var minPositive = int.MaxValue;\\n        for (int i=0; i<nums.Length; i++) {\\n            if (nums[i] < 0)\\n                maxNegative = Math.Max(nums[i], maxNegative);\\n            else\\n                minPositive = Math.Min(nums[i], minPositive);\\n        }\\n        return minPositive <= Math.Abs(maxNegative) ? minPositive : maxNegative;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int FindClosestNumber(int[] nums) {\\n        var maxNegative = int.MinValue + 1; // to prevent overflow exception\\n        var minPositive = int.MaxValue;\\n        for (int i=0; i<nums.Length; i++) {\\n            if (nums[i] < 0)\\n                maxNegative = Math.Max(nums[i], maxNegative);\\n            else\\n                minPositive = Math.Min(nums[i], minPositive);\\n        }\\n        return minPositive <= Math.Abs(maxNegative) ? minPositive : maxNegative;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955518,
                "title": "easy-python-solution-using-sorting",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        mn=float(\"inf\")\\n        for val in nums:\\n            mn=min(mn,abs(val-0))\\n        \\n        for val in nums:\\n            if abs(val-0)==mn:\\n                ans=val\\n        \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        mn=float(\"inf\")\\n        for val in nums:\\n            mn=min(mn,abs(val-0))\\n        \\n        for val in nums:\\n            if abs(val-0)==mn:\\n                ans=val\\n        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955476,
                "title": "java-solution-easy-understanding",
                "content": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int ans[]=new int[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            ans[i]=Math.abs(nums[i]);\\n        }\\n        Arrays.sort(ans);\\n        int j=0;\\n        \\n        for( int i=0;i<nums.length;i++){   \\n            if(ans[0]==Math.abs(nums[i])){\\n                if(nums[i]>0){\\n                    return nums[i];\\n                }\\n                j=i;\\n            }         \\n        }\\n        return nums[j];\\n               \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int ans[]=new int[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            ans[i]=Math.abs(nums[i]);\\n        }\\n        Arrays.sort(ans);\\n        int j=0;\\n        \\n        for( int i=0;i<nums.length;i++){   \\n            if(ans[0]==Math.abs(nums[i])){\\n                if(nums[i]>0){\\n                    return nums[i];\\n                }\\n                j=i;\\n            }         \\n        }\\n        return nums[j];\\n               \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954944,
                "title": "swift-o-n-solution",
                "content": "```\\nfinal class Solution {\\n    // O(n) time | O(1) space\\n    func findClosestNumber(_ nums: [Int]) -> Int {\\n        var closest = (0, Int.max) // (actualNumber, difference)\\n        \\n        for num in nums {\\n            let abs = abs(num)\\n        \\n            if abs < closest.1 {\\n                closest = (num, abs)\\n            } else if abs == closest.1 {\\n                closest = (max(num, closest.0), abs)\\n            }\\n        }\\n        \\n        return closest.0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfinal class Solution {\\n    // O(n) time | O(1) space\\n    func findClosestNumber(_ nums: [Int]) -> Int {\\n        var closest = (0, Int.max) // (actualNumber, difference)\\n        \\n        for num in nums {\\n            let abs = abs(num)\\n        \\n            if abs < closest.1 {\\n                closest = (num, abs)\\n            } else if abs == closest.1 {\\n                closest = (max(num, closest.0), abs)\\n            }\\n        }\\n        \\n        return closest.0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954796,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int m=INT_MAX,ind=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(abs(0-nums[i])<m){\\n                m=abs(0-nums[i]);\\n                ind=nums[i];\\n            }\\n            if(abs(0-nums[i])==m)\\n                ind=max(nums[i],ind);\\n        }\\n        return ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int m=INT_MAX,ind=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(abs(0-nums[i])<m){\\n                m=abs(0-nums[i]);\\n                ind=nums[i];\\n            }\\n            if(abs(0-nums[i])==m)\\n                ind=max(nums[i],ind);\\n        }\\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954377,
                "title": "c-faster-than-100-sol-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/f0a83dd7-5a57-41a0-a624-e9507c75102a_1650133193.4666235.png)\\n\\n\\n```\\n#define ll long long\\n#define inf ((ll)(2e18))\\n\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        ll mn = inf, mx = -inf;\\n        for (int i=0; i<n; i++) {\\n            if (nums[i] > 0) mn = min(mn, (ll)nums[i]);\\n            else mx = max(mx, (ll)nums[i]);\\n        }\\n        if (abs(mn) <= abs(mx)) return (int)mn;\\n        else return (int)mx;\\n    }\\n};\\n```\\n\\nPlease **Upvote** if you like my solution/approach",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long long\\n#define inf ((ll)(2e18))\\n\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        ll mn = inf, mx = -inf;\\n        for (int i=0; i<n; i++) {\\n            if (nums[i] > 0) mn = min(mn, (ll)nums[i]);\\n            else mx = max(mx, (ll)nums[i]);\\n        }\\n        if (abs(mn) <= abs(mx)) return (int)mn;\\n        else return (int)mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954261,
                "title": "simple-python-solution",
                "content": "class Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        l=[]\\n        for i in range(len(nums)):\\n            l.append(abs(nums[i]-0))\\n        t=min(l)\\n        if t not in nums:\\n            t=-1*t\\n                 \\n        return t\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        l=[]\\n        for i in range(len(nums)):\\n            l.append(abs(nums[i]-0))\\n        t=min(l)\\n        if t not in nums:\\n            t=-1*t\\n                 \\n        return t\\n",
                "codeTag": "Java"
            },
            {
                "id": 1954208,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int max_val = 0;\\n        \\n        int min_close = INT_MAX;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int ans = abs(nums[i]);\\n            \\n            if(ans < min_close)\\n            {\\n                min_close = ans;\\n                \\n                max_val = nums[i];\\n            }\\n            \\n            else if(ans == min_close)\\n            {\\n                max_val = max(max_val, nums[i]);\\n            }\\n        }\\n        \\n        return max_val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int max_val = 0;\\n        \\n        int min_close = INT_MAX;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int ans = abs(nums[i]);\\n            \\n            if(ans < min_close)\\n            {\\n                min_close = ans;\\n                \\n                max_val = nums[i];\\n            }\\n            \\n            else if(ans == min_close)\\n            {\\n                max_val = max(max_val, nums[i]);\\n            }\\n        }\\n        \\n        return max_val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954191,
                "title": "o-n-time-and-o-1-space-complexity-easy-solution",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n       \\n        closest = 0\\n        if 0 in nums:\\n            return 0\\n      \\n        for i in range(len(nums)):\\n                       \\n            if closest == 0 : \\n                closest = nums[i]\\n            elif nums[i] > 0 and nums[i] <= abs(closest):\\n                closest = nums[i]\\n            elif nums[i] < 0 and nums[i] < abs(closest) and abs(nums[i]) < abs(closest):\\n                closest = nums[i]\\n\\n        return closest\\n    \\n    \\n   \\n    ```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n       \\n        closest = 0\\n        if 0 in nums:\\n            return 0\\n      \\n        for i in range(len(nums)):\\n                       \\n            if closest == 0 : \\n                closest = nums[i]\\n            elif nums[i] > 0 and nums[i] <= abs(closest):\\n                closest = nums[i]\\n            elif nums[i] < 0 and nums[i] < abs(closest) and abs(nums[i]) < abs(closest):\\n                closest = nums[i]\\n\\n        return closest\\n    \\n    \\n   \\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 1954160,
                "title": "find-closest-number-to-zero-java-solution",
                "content": "```\\nclass Solution \\n{\\n    public int findClosestNumber(int[] nums) \\n    {\\n        int minDistance=Math.abs(nums[0]);\\n        int value=nums[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            int dist=Math.abs(nums[i]);\\n            if(dist < minDistance)\\n            {\\n                minDistance=dist;\\n                value=nums[i];\\n            }\\n            else if(dist == minDistance)\\n            {\\n                if(nums[i] > value)\\n                {\\n                    minDistance=dist;\\n                    value=nums[i];\\n                }\\n            }\\n        }\\n        return value;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int findClosestNumber(int[] nums) \\n    {\\n        int minDistance=Math.abs(nums[0]);\\n        int value=nums[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            int dist=Math.abs(nums[i]);\\n            if(dist < minDistance)\\n            {\\n                minDistance=dist;\\n                value=nums[i];\\n            }\\n            else if(dist == minDistance)\\n            {\\n                if(nums[i] > value)\\n                {\\n                    minDistance=dist;\\n                    value=nums[i];\\n                }\\n            }\\n        }\\n        return value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954023,
                "title": "2ms-easy-13-lines-step-by-step-dry-run",
                "content": "If you like it, pls **Upvote** :)\\n\\n## Approach:\\n\\t1. Use 2 variables: \"min\" to store minimum difference (absolute), and \"closest\" to store number closest to 0\\n\\t2. For each \"num\" in arrays nums:\\n\\t\\t- keep updating values of min and closest. \\n\\t\\t- Note: as mentioned in question; if min == diff, in that case update \"closest\" with the number which is bigger (num v/s closest).\\n## Code:\\n    public int findClosestNumber(int[] nums) {\\n        int min = Integer.MAX_VALUE, closest = 0;\\n        for(int num : nums){\\n            if(num == 0){ return 0; }\\n            int diff = Math.abs(num);\\n            if(min > diff){\\n                min = diff;\\n                closest = num;   \\n            }else if(min == diff){\\n                closest = Math.max(num, closest); \\n            }\\n        }\\n        return closest;\\n    }\\n//\\n//\\n//\\n//\\n\\n## Dry Run:\\n\\tBelow are step-by-step dry run on few examples.\\n\\t--------\\n\\tinput nums = [-4, -2, 1, 4, 8]\\n\\t min: 4 > diff: 4  => closest = -4\\n\\t min: 2 > diff: 2  => closest = -2\\n\\t min: 1 > diff: 1  => closest = 1\\n\\t--------\\n\\tinput nums = [2, -1, 1]\\n\\t min: 2 > diff: 2  => closest = 2\\n\\t min: 1 > diff: 1  => closest = -1\\n\\t min: 1 == diff: 1  => closest = 1\\n\\t--------\\n\\tinput nums = [2, 1, -1]\\n\\t min: 2 > diff: 2  => closest = 2\\n\\t min: 1 > diff: 1  => closest = 1\\n\\t min: 1 == diff: 1  => closest = 1\\n\\t--------\\n\\tinput nums = [-4, -2, 1, 0, 8]\\n\\t min: 4 > diff: 4  => closest = -4\\n\\t min: 2 > diff: 2  => closest = -2\\n\\t min: 1 > diff: 1  => closest = 1\\n\\tnum = 0, => closest = 0\\n\\n\\n\\nIf any questions/suggestions, comment down below.\\nIf you liked the explanation/dry run, pls **Upvote** :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "If you like it, pls **Upvote** :)\\n\\n## Approach:\\n\\t1. Use 2 variables: \"min\" to store minimum difference (absolute), and \"closest\" to store number closest to 0\\n\\t2. For each \"num\" in arrays nums:\\n\\t\\t- keep updating values of min and closest. \\n\\t\\t- Note: as mentioned in question; if min == diff, in that case update \"closest\" with the number which is bigger (num v/s closest).\\n## Code:\\n    public int findClosestNumber(int[] nums) {\\n        int min = Integer.MAX_VALUE, closest = 0;\\n        for(int num : nums){\\n            if(num == 0){ return 0; }\\n            int diff = Math.abs(num);\\n            if(min > diff){\\n                min = diff;\\n                closest = num;   \\n            }else if(min == diff){\\n                closest = Math.max(num, closest); \\n            }\\n        }\\n        return closest;\\n    }\\n//\\n//\\n//\\n//\\n\\n## Dry Run:\\n\\tBelow are step-by-step dry run on few examples.\\n\\t--------\\n\\tinput nums = [-4, -2, 1, 4, 8]\\n\\t min: 4 > diff: 4  => closest = -4\\n\\t min: 2 > diff: 2  => closest = -2\\n\\t min: 1 > diff: 1  => closest = 1\\n\\t--------\\n\\tinput nums = [2, -1, 1]\\n\\t min: 2 > diff: 2  => closest = 2\\n\\t min: 1 > diff: 1  => closest = -1\\n\\t min: 1 == diff: 1  => closest = 1\\n\\t--------\\n\\tinput nums = [2, 1, -1]\\n\\t min: 2 > diff: 2  => closest = 2\\n\\t min: 1 > diff: 1  => closest = 1\\n\\t min: 1 == diff: 1  => closest = 1\\n\\t--------\\n\\tinput nums = [-4, -2, 1, 0, 8]\\n\\t min: 4 > diff: 4  => closest = -4\\n\\t min: 2 > diff: 2  => closest = -2\\n\\t min: 1 > diff: 1  => closest = 1\\n\\tnum = 0, => closest = 0\\n\\n\\n\\nIf any questions/suggestions, comment down below.\\nIf you liked the explanation/dry run, pls **Upvote** :)",
                "codeTag": "Unknown"
            },
            {
                "id": 1953982,
                "title": "python3-this-feels-dirty",
                "content": "\\n```\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        from bisect import bisect, bisect_left\\n        l_n = len(nums)\\n        if l_n == 0:\\n            return 0\\n        if l_n == 1:\\n            return nums[0]\\n        nums.sort()\\n        pos_low = bisect_left(nums, 0)\\n        pos_high = bisect(nums, 0)\\n        # print(pos_low, pos_high, nums)\\n        if pos_low == pos_high:\\n            pos_low -= 1\\n        if pos_high >= l_n or pos_low > l_n:\\n            return nums[-1]\\n        if abs(nums[pos_low]) < abs(nums[pos_high]):\\n            res = nums[pos_low]\\n        else:\\n            res = nums[pos_high]\\n        # res = min(nums[pos_low], nums[pos_high])\\n        return res\\n```\\n\\nToo many distractions at the start with children needing attention. Single mom life.. sigh not liking how this one unfolded.",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        from bisect import bisect, bisect_left\\n        l_n = len(nums)\\n        if l_n == 0:\\n            return 0\\n        if l_n == 1:\\n            return nums[0]\\n        nums.sort()\\n        pos_low = bisect_left(nums, 0)\\n        pos_high = bisect(nums, 0)\\n        # print(pos_low, pos_high, nums)\\n        if pos_low == pos_high:\\n            pos_low -= 1\\n        if pos_high >= l_n or pos_low > l_n:\\n            return nums[-1]\\n        if abs(nums[pos_low]) < abs(nums[pos_high]):\\n            res = nums[pos_low]\\n        else:\\n            res = nums[pos_high]\\n        # res = min(nums[pos_low], nums[pos_high])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1953960,
                "title": "hashmap-python",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        dic={}\\n        \\n        for i in nums:\\n            try:\\n                dic[abs(i)].append(i)\\n            except:\\n                dic[abs(i)]=[i]\\n                \\n        nums=dict(sorted(dic.items()))\\n        \\n        for i in nums:\\n            return max(nums[i])\\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        dic={}\\n        \\n        for i in nums:\\n            try:\\n                dic[abs(i)].append(i)\\n            except:\\n                dic[abs(i)]=[i]\\n                \\n        nums=dict(sorted(dic.items()))\\n        \\n        for i in nums:\\n            return max(nums[i])\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953913,
                "title": "simple-easy-to-understand-brief-python-solution-o-n-time-o-1-space",
                "content": "```\\n# Time:  O(n)\\n# Space: O(1)\\n\\ndef findClosestNumber(nums):\\n    \"\"\"\\n    :type nums: List[int]\\n    :rtype: int\\n    \"\"\"\\n    closest_num, closest_dist = float(\\'-inf\\'), float(\\'inf\\')\\n    for n in nums:\\n        if abs(n) < closest_dist:\\n            closest_dist = abs(n)\\n            closest_num = n\\n        if abs(n) == closest_dist:\\n            if n > closest_num:\\n                closest_num = n\\n            \\n    return closest_num\\n```",
                "solutionTags": [],
                "code": "```\\n# Time:  O(n)\\n# Space: O(1)\\n\\ndef findClosestNumber(nums):\\n    \"\"\"\\n    :type nums: List[int]\\n    :rtype: int\\n    \"\"\"\\n    closest_num, closest_dist = float(\\'-inf\\'), float(\\'inf\\')\\n    for n in nums:\\n        if abs(n) < closest_dist:\\n            closest_dist = abs(n)\\n            closest_num = n\\n        if abs(n) == closest_dist:\\n            if n > closest_num:\\n                closest_num = n\\n            \\n    return closest_num\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1953903,
                "title": "golang-o-n-100",
                "content": "```\\nimport \"math\"\\n\\nfunc findClosestNumber(nums []int) int {\\n    min := nums[0]\\n    \\n    for i := 1; i < len(nums); i++ {\\n        if math.Abs(float64(nums[i])) < math.Abs(float64(min)) {\\n            min = nums[i]\\n        } else if math.Abs(float64(nums[i])) == math.Abs(float64(min)) && nums[i] > min {\\n            min = nums[i]\\n        }\\n    }\\n    \\n    return min\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nimport \"math\"\\n\\nfunc findClosestNumber(nums []int) int {\\n    min := nums[0]\\n    \\n    for i := 1; i < len(nums); i++ {\\n        if math.Abs(float64(nums[i])) < math.Abs(float64(min)) {\\n            min = nums[i]\\n        } else if math.Abs(float64(nums[i])) == math.Abs(float64(min)) && nums[i] > min {\\n            min = nums[i]\\n        }\\n    }\\n    \\n    return min\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1953746,
                "title": "python-3-150ms-dictionary-solution-o-n-o-n",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        d={}\\n        for i in range(len(nums)):\\n            if abs(nums[i]) in d:\\n                d[abs(nums[i])]=max(d[abs(nums[i])],nums[i])\\n            else:\\n                d[abs(nums[i])]=nums[i]\\n        return d[min(d.keys())]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        d={}\\n        for i in range(len(nums)):\\n            if abs(nums[i]) in d:\\n                d[abs(nums[i])]=max(d[abs(nums[i])],nums[i])\\n            else:\\n                d[abs(nums[i])]=nums[i]\\n        return d[min(d.keys())]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953659,
                "title": "python-1-line",
                "content": "```python\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return sorted(nums, key=lambda v: (abs(v), -v))[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return sorted(nums, key=lambda v: (abs(v), -v))[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094073,
                "title": "java-easy-to-understand-anyone-can-do-leetcode-2ms-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=Integer.MAX_VALUE;\\n       \\n        int close=0;\\n        for(int e: nums)\\n        {\\n            if(min>Math.abs(e))\\n            {\\n                min=Math.abs(e);\\n                close=e;\\n            }\\n\\n            else if(min == Math.abs(e) && close <e)\\n            {\\n                close = e;\\n            }\\n        }\\n        return close;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=Integer.MAX_VALUE;\\n       \\n        int close=0;\\n        for(int e: nums)\\n        {\\n            if(min>Math.abs(e))\\n            {\\n                min=Math.abs(e);\\n                close=e;\\n            }\\n\\n            else if(min == Math.abs(e) && close <e)\\n            {\\n                close = e;\\n            }\\n        }\\n        return close;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093852,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def findClosestNumber(self, nums):\\n        nums.sort(reverse=True)\\n        l=[abs(i) for i in nums]\\n        i=l.index(min(l))\\n        return nums[i]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findClosestNumber(self, nums):\\n        nums.sort(reverse=True)\\n        l=[abs(i) for i in nums]\\n        i=l.index(min(l))\\n        return nums[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085844,
                "title": "short-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindClosestNumber(int[] nums) {\\n        int n=nums.Select(x=>Math.Abs(x)).Min();\\t\\t\\n        return Array.IndexOf(nums,n)<0?n*-1:n;         \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindClosestNumber(int[] nums) {\\n        int n=nums.Select(x=>Math.Abs(x)).Min();\\t\\t\\n        return Array.IndexOf(nums,n)<0?n*-1:n;         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084522,
                "title": "java-solution-with-helper-function-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public static int findClosestNumber(int[] nums) {\\n    int distance = Math.abs(nums[0]);\\n    int res = nums[0];\\n    for (int i = 1; i < nums.length; i++) {\\n        if (distanceFromZero(nums[i]) < distance) {\\n          distance = distanceFromZero(nums[i]);\\n          res = nums[i];\\n        } else if (distanceFromZero(nums[i]) == distance && nums[i] > res) {\\n          res = nums[i];\\n        }\\n    }\\n    return res;\\n  }\\n\\n  public static int distanceFromZero(int a) {\\n    return Math.abs(a-0);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public static int findClosestNumber(int[] nums) {\\n    int distance = Math.abs(nums[0]);\\n    int res = nums[0];\\n    for (int i = 1; i < nums.length; i++) {\\n        if (distanceFromZero(nums[i]) < distance) {\\n          distance = distanceFromZero(nums[i]);\\n          res = nums[i];\\n        } else if (distanceFromZero(nums[i]) == distance && nums[i] > res) {\\n          res = nums[i];\\n        }\\n    }\\n    return res;\\n  }\\n\\n  public static int distanceFromZero(int a) {\\n    return Math.abs(a-0);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078122,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda ans, n: n if abs(n) < abs(ans) or n == abs(ans) else ans, nums, inf)      \\n```\\n> More readable\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        ans = inf\\n        for num in nums:\\n            if abs(num) < abs(ans) or num == abs(ans):\\n                ans = num\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda ans, n: n if abs(n) < abs(ans) or n == abs(ans) else ans, nums, inf)      \\n```\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        ans = inf\\n        for num in nums:\\n            if abs(num) < abs(ans) or num == abs(ans):\\n                ans = num\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077567,
                "title": "c-too-easy-fully-explained-without-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere\\'s a step-by-step explanation of how the code works with an example:\\n\\nLet\\'s say we have the following vector `nums`:\\n```\\nnums = [-4, 2, -7, 5, -1]\\n```\\n\\n1. Initialize `ans` to `INT_MAX`. This is done to ensure that the initial value of `ans` is greater than any possible absolute value in the vector.\\n\\n2. Start iterating through the elements of `nums` using a range-based for loop.\\n   \\n   - For the first element, `it` is set to `-4`. The absolute value of `-4` is `4`, which is less than the current value of `ans` (which is initially `INT_MAX`). So, `ans` is updated to `-4`.\\n   \\n   - For the second element, `it` is set to `2`. The absolute value of `2` is `2`, which is less than the current value of `ans` (which is now `-4`). So, `ans` is updated to `2`.\\n\\n   - For the third element, `it` is set to `-7`. The absolute value of `-7` is `7`, which is greater than the current value of `ans` (which is `2`). So, `ans` remains `2`.\\n\\n   - For the fourth element, `it` is set to `5`. The absolute value of `5` is `5`, which is greater than the current value of `ans` (which is `2`). So, `ans` remains `2`.\\n\\n   - For the fifth element, `it` is set to `-1`. The absolute value of `-1` is `1`, which is less than the current value of `ans` (which is `2`). So, `ans` is updated to `-1`.\\n\\n3. Continue looping through the remaining elements of `nums`, but no further updates are made to `ans` since none of the absolute values are closer to zero than `-1`.\\n\\n4. Finally, the loop ends, and the function returns the value of `ans`, which is `-1`. This is the closest number to zero in the given vector.\\n\\nThere\\'s a typo in the code: `return and;` should be replaced with `return ans;` to correctly return the closest number found.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int ans = INT_MAX;\\n        for(auto it:nums)\\n        {\\n            if(abs(it) < abs(ans)){\\n                ans = it;\\n            }\\n            else if(abs(it) == abs(ans)){\\n                ans = max(it,ans);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nnums = [-4, 2, -7, 5, -1]\\n```\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int ans = INT_MAX;\\n        for(auto it:nums)\\n        {\\n            if(abs(it) < abs(ans)){\\n                ans = it;\\n            }\\n            else if(abs(it) == abs(ans)){\\n                ans = max(it,ans);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059870,
                "title": "python-simple-solution-find-close-number-to-0",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbeginner friendly Easiest python salution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nbeats 90% python users O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nbeats 94% python users O(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findClosestNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        smallest=nums[0]\\n        for i in nums:\\n            if abs(i) < abs(smallest):\\n                smallest=i\\n        \\n        if abs(smallest) in nums:\\n            smallest=abs(smallest)\\n\\n        return smallest\\n       \\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findClosestNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        smallest=nums[0]\\n        for i in nums:\\n            if abs(i) < abs(smallest):\\n                smallest=i\\n        \\n        if abs(smallest) in nums:\\n            smallest=abs(smallest)\\n\\n        return smallest\\n       \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044402,
                "title": "o-n-time-o-1-space-simple",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n# Second and Better Solution O(n)\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_closest_number(nums)\\n    \\n    gt_zero = 100001\\n    lt_zero = -100001\\n    nums.each do |num|\\n        if num == 0\\n            return 0\\n        elsif num > 0\\n            if num < gt_zero\\n                gt_zero = num\\n            end\\n        elsif num < 0\\n            if num > lt_zero\\n                lt_zero = num\\n            end\\n        end\\n    end\\n\\n    if -gt_zero >= lt_zero\\n        return gt_zero\\n    else\\n        lt_zero\\n    end \\nend\\n\\n# First Solution O(log n)\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_closest_number_old(nums)\\n   \\n    # Sort in ascending order.\\n    # O(log n)\\n    nums.sort!\\n\\n    gt_zero = nil\\n    lt_zero = nil\\n    # Binary search to find closet numbers above 0 and get its index.\\n    gt_zero_index = nums.bsearch_index{|n| n > 0}\\n    # if we have a non-nil for gt_zero_index, we can check for 0\\n    if gt_zero_index \\n        gt_zero = nums[gt_zero_index]\\n        if gt_zero_index == 0\\n            return gt_zero\\n        elsif gt_zero_index > 0\\n            lt_zero = nums[gt_zero_index - 1]\\n            if lt_zero == 0\\n                return 0\\n            end\\n        end\\n    else\\n        return nums[-1]\\n    end\\n\\n    if gt_zero and lt_zero\\n        if -gt_zero >= lt_zero\\n            return gt_zero\\n        else\\n            lt_zero\\n        end\\n    end\\nend\\n\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# Second and Better Solution O(n)\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_closest_number(nums)\\n    \\n    gt_zero = 100001\\n    lt_zero = -100001\\n    nums.each do |num|\\n        if num == 0\\n            return 0\\n        elsif num > 0\\n            if num < gt_zero\\n                gt_zero = num\\n            end\\n        elsif num < 0\\n            if num > lt_zero\\n                lt_zero = num\\n            end\\n        end\\n    end\\n\\n    if -gt_zero >= lt_zero\\n        return gt_zero\\n    else\\n        lt_zero\\n    end \\nend\\n\\n# First Solution O(log n)\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_closest_number_old(nums)\\n   \\n    # Sort in ascending order.\\n    # O(log n)\\n    nums.sort!\\n\\n    gt_zero = nil\\n    lt_zero = nil\\n    # Binary search to find closet numbers above 0 and get its index.\\n    gt_zero_index = nums.bsearch_index{|n| n > 0}\\n    # if we have a non-nil for gt_zero_index, we can check for 0\\n    if gt_zero_index \\n        gt_zero = nums[gt_zero_index]\\n        if gt_zero_index == 0\\n            return gt_zero\\n        elsif gt_zero_index > 0\\n            lt_zero = nums[gt_zero_index - 1]\\n            if lt_zero == 0\\n                return 0\\n            end\\n        end\\n    else\\n        return nums[-1]\\n    end\\n\\n    if gt_zero and lt_zero\\n        if -gt_zero >= lt_zero\\n            return gt_zero\\n        else\\n            lt_zero\\n        end\\n    end\\nend\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4041621,
                "title": "easy-c-findclosestnumber",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int num=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(abs(num)==abs(nums[i]))\\n                num=max(num,nums[i]);\\n            else if(abs(num)>abs(nums[i]))\\n                num=nums[i];\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int num=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(abs(num)==abs(nums[i]))\\n                num=max(num,nums[i]);\\n            else if(abs(num)>abs(nums[i]))\\n                num=nums[i];\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041502,
                "title": "easy-solution-c-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int num=nums[0];\\n        int diff=abs(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(diff==abs(nums[i]))\\n            {\\n                num=max(num,nums[i]);\\n            }\\n            else if(diff>abs(nums[i]))\\n            {\\n                num=nums[i];\\n                diff=abs(nums[i]);\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int num=nums[0];\\n        int diff=abs(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(diff==abs(nums[i]))\\n            {\\n                num=max(num,nums[i]);\\n            }\\n            else if(diff>abs(nums[i]))\\n            {\\n                num=nums[i];\\n                diff=abs(nums[i]);\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032763,
                "title": "easy-using-iterative-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        \\n       int diff=INT_MAX;\\n       int ans;\\n       \\n       for(int i=0;i<nums.size();i++){\\n\\n            if(abs(nums[i])<diff){\\n                 ans=nums[i];\\n                  diff=abs(nums[i]);\\n                  \\n            }\\n            if(diff==abs(nums[i]) && nums[i]>ans){\\n                ans=nums[i];\\n            }\\n\\n       }\\n      return ans;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        \\n       int diff=INT_MAX;\\n       int ans;\\n       \\n       for(int i=0;i<nums.size();i++){\\n\\n            if(abs(nums[i])<diff){\\n                 ans=nums[i];\\n                  diff=abs(nums[i]);\\n                  \\n            }\\n            if(diff==abs(nums[i]) && nums[i]>ans){\\n                ans=nums[i];\\n            }\\n\\n       }\\n      return ans;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030854,
                "title": "c-o-n-solution-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int closest=10e5;\\n        int index=-1;\\n        for(int i=0;i<nums.size();i++){\\n            if(abs(nums[i])<closest){\\n//find the element closest to zero in terms of absolute and store index\\n                closest=abs(nums[i]);\\n                index=i;\\n            }\\n//if absolute value of that element is equivalent to the absolute value\\n//of another element, choose the index of the greater one\\n            if(abs(nums[i])==abs(nums[index])){\\n                if(nums[i]>nums[index]){\\n                    index=i;\\n                }\\n            }\\n        }\\n        return nums[index];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int closest=10e5;\\n        int index=-1;\\n        for(int i=0;i<nums.size();i++){\\n            if(abs(nums[i])<closest){\\n//find the element closest to zero in terms of absolute and store index\\n                closest=abs(nums[i]);\\n                index=i;\\n            }\\n//if absolute value of that element is equivalent to the absolute value\\n//of another element, choose the index of the greater one\\n            if(abs(nums[i])==abs(nums[index])){\\n                if(nums[i]>nums[index]){\\n                    index=i;\\n                }\\n            }\\n        }\\n        return nums[index];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024038,
                "title": "typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype NumWithDistanceEntry = [number, number];\\n\\nfunction findClosestNumber(nums: number[]): number {\\n  const numsWithDistances: { [key: string | number]: number } = {};\\n\\n  nums.forEach((num) => {\\n    numsWithDistances[num] = Math.abs(0 - num);\\n  });\\n\\n  const entriesOfNumsWithDistances: NumWithDistanceEntry[] = Object.entries(\\n    numsWithDistances\\n  ).map((numWithDistance) => [Number(numWithDistance[0]), numWithDistance[1]]);\\n\\n  const sortedEntries = entriesOfNumsWithDistances.sort(\\n    (a: NumWithDistanceEntry, b: NumWithDistanceEntry) => {\\n      if (a[1] === b[1]) {\\n        if (a[0] < b[0]) return 1;\\n        if (a[0] > b[0]) return -1;\\n        return 0;\\n      } else {\\n        return a[1] - b[1];\\n      }\\n    }\\n  );\\n\\n  return sortedEntries[0][0];\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype NumWithDistanceEntry = [number, number];\\n\\nfunction findClosestNumber(nums: number[]): number {\\n  const numsWithDistances: { [key: string | number]: number } = {};\\n\\n  nums.forEach((num) => {\\n    numsWithDistances[num] = Math.abs(0 - num);\\n  });\\n\\n  const entriesOfNumsWithDistances: NumWithDistanceEntry[] = Object.entries(\\n    numsWithDistances\\n  ).map((numWithDistance) => [Number(numWithDistance[0]), numWithDistance[1]]);\\n\\n  const sortedEntries = entriesOfNumsWithDistances.sort(\\n    (a: NumWithDistanceEntry, b: NumWithDistanceEntry) => {\\n      if (a[1] === b[1]) {\\n        if (a[0] < b[0]) return 1;\\n        if (a[0] > b[0]) return -1;\\n        return 0;\\n      } else {\\n        return a[1] - b[1];\\n      }\\n    }\\n  );\\n\\n  return sortedEntries[0][0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4023940,
                "title": "c-basic-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int mn=INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            mn=min(mn, abs(nums[i]));\\n        }\\n        vector<int> closest;\\n        for(int i=0; i<nums.size(); i++){\\n            if(mn==abs(nums[i])){\\n                closest.push_back(nums[i]);\\n            }\\n        }\\n        int mx=INT_MIN;\\n        for(int i=0; i<closest.size(); i++){\\n            mx=max(mx, closest[i]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int mn=INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            mn=min(mn, abs(nums[i]));\\n        }\\n        vector<int> closest;\\n        for(int i=0; i<nums.size(); i++){\\n            if(mn==abs(nums[i])){\\n                closest.push_back(nums[i]);\\n            }\\n        }\\n        int mx=INT_MIN;\\n        for(int i=0; i<closest.size(); i++){\\n            mx=max(mx, closest[i]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014359,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 145 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.6 mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        small=nums[0]\\n        ind=0\\n        for i in range(1,len(nums)):\\n            if(abs(0-small)==abs(0-nums[i])):\\n                if(nums[ind]<nums[i]):\\n                    small=nums[i]\\n                    ind=i\\n            elif(abs(0-small)>abs(0-nums[i])):\\n                small=nums[i]\\n                ind=i\\n        return (nums[ind])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        small=nums[0]\\n        ind=0\\n        for i in range(1,len(nums)):\\n            if(abs(0-small)==abs(0-nums[i])):\\n                if(nums[ind]<nums[i]):\\n                    small=nums[i]\\n                    ind=i\\n            elif(abs(0-small)>abs(0-nums[i])):\\n                small=nums[i]\\n                ind=i\\n        return (nums[ind])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009930,
                "title": "easy-c-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int dist=INT_MAX;\\n        int closest;\\n        for(int i=0; i<nums.size();i++){\\n            if(dist==abs(nums[i])){\\n                closest=max(closest,nums[i]);\\n            }\\n            if(dist>abs(nums[i])) {\\n                dist=min(dist,abs(nums[i]));\\n                closest=nums[i];\\n            }\\n        }\\n        return closest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int dist=INT_MAX;\\n        int closest;\\n        for(int i=0; i<nums.size();i++){\\n            if(dist==abs(nums[i])){\\n                closest=max(closest,nums[i]);\\n            }\\n            if(dist>abs(nums[i])) {\\n                dist=min(dist,abs(nums[i]));\\n                closest=nums[i];\\n            }\\n        }\\n        return closest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990033,
                "title": "easy-to-understand-python3-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        minval = float(\\'inf\\')\\n        resultval = None\\n        \\n        for i in nums:\\n           if abs(i-0) <= minval:\\n               minval = abs(i-0)\\n               resultval = i\\n        \\n        if resultval < 0 and resultval * -1 in nums:\\n            return resultval * -1\\n        return resultval\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        minval = float(\\'inf\\')\\n        resultval = None\\n        \\n        for i in nums:\\n           if abs(i-0) <= minval:\\n               minval = abs(i-0)\\n               resultval = i\\n        \\n        if resultval < 0 and resultval * -1 in nums:\\n            return resultval * -1\\n        return resultval\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985399,
                "title": "easiest-approach-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int miny = nums[0];\\n        for(int i = 0 ; i < nums.size() ;i++){\\n           if(abs(miny) > abs(nums[i])){\\n                miny = nums[i];\\n                \\n                cout<<miny<<endl;\\n           }\\n            else if(abs(miny) == abs(nums[i])){\\n                    miny = max(miny,nums[i]);\\n                }\\n        }\\n        return miny;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int miny = nums[0];\\n        for(int i = 0 ; i < nums.size() ;i++){\\n           if(abs(miny) > abs(nums[i])){\\n                miny = nums[i];\\n                \\n                cout<<miny<<endl;\\n           }\\n            else if(abs(miny) == abs(nums[i])){\\n                    miny = max(miny,nums[i]);\\n                }\\n        }\\n        return miny;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3985397,
                "title": "easy-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        //sort(nums.begin(),nums.end());\\n        int close=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(abs(nums[i])<abs(close)){\\n            close=nums[i];\\n            }\\n            else if(abs(nums[i])==abs(close)){\\n                close=max(nums[i],close);\\n            }\\n        }\\n        return close;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        //sort(nums.begin(),nums.end());\\n        int close=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(abs(nums[i])<abs(close)){\\n            close=nums[i];\\n            }\\n            else if(abs(nums[i])==abs(close)){\\n                close=max(nums[i],close);\\n            }\\n        }\\n        return close;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984552,
                "title": "super-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int numberToReturn = nums[0];\\n        int closestDistance = Math.abs(nums[0]);\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            int absoluteValue = Math.abs(nums[i]);\\n            if (absoluteValue < closestDistance || (absoluteValue == closestDistance && nums[i] > 0)) {\\n                closestDistance = absoluteValue;\\n                numberToReturn = nums[i];\\n            }\\n        }\\n\\n        return numberToReturn;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int numberToReturn = nums[0];\\n        int closestDistance = Math.abs(nums[0]);\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            int absoluteValue = Math.abs(nums[i]);\\n            if (absoluteValue < closestDistance || (absoluteValue == closestDistance && nums[i] > 0)) {\\n                closestDistance = absoluteValue;\\n                numberToReturn = nums[i];\\n            }\\n        }\\n\\n        return numberToReturn;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984173,
                "title": "c-easy-and-readable-solution-faster-than-79",
                "content": "![image.png](https://assets.leetcode.com/users/images/06cf7501-17b7-4496-99ce-563dc75270b3_1693480501.790987.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int FindClosestNumber(int[] nums) {\\n        int pos = int.MaxValue;\\n        int neg = int.MinValue;\\n        foreach (int n in nums)\\n        {\\n            if (n >= 0)\\n                pos = Math.Min(pos, n);\\n            else\\n                neg = Math.Max(neg, n);\\n        }\\n        return -pos >= neg ? pos : neg;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindClosestNumber(int[] nums) {\\n        int pos = int.MaxValue;\\n        int neg = int.MinValue;\\n        foreach (int n in nums)\\n        {\\n            if (n >= 0)\\n                pos = Math.Min(pos, n);\\n            else\\n                neg = Math.Max(neg, n);\\n        }\\n        return -pos >= neg ? pos : neg;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981113,
                "title": "solved-using-simple-iteration",
                "content": "# Intuition\\nThe problem ask to find the largest number with minimum distance to 0. It means we need to find largest negative or smallest positive number.\\n\\n# Approach\\nIdea is to iterate to find min number and also checking if there is positive number at the same distance from 0. If it is, then always return positive number.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int result = Integer.MAX_VALUE;\\n        for(int num: nums)\\n            if(Math.abs(num) < Math.abs(result) || num == Math.abs(result))\\n                result = num;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int result = Integer.MAX_VALUE;\\n        for(int num: nums)\\n            if(Math.abs(num) < Math.abs(result) || num == Math.abs(result))\\n                result = num;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975681,
                "title": "another-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar findClosestNumber = function(nums) {\\n  let plus = [];\\n  let minus = [];\\n  let sP = [];\\n  let sM = [];\\n\\n  if (nums == 0) {\\n    return 0;\\n  } else {\\n    for (let i = 0; i < nums.length; i++) {\\n      if (nums[i] > 0) {\\n        plus.push(nums[i]);\\n      } else {\\n        minus.push(nums[i]);\\n      }\\n    }\\n\\n    sP = plus.sort((a, b) => a - b);\\n    sM = minus.sort((a, b) => b - a);\\n\\n    if (sP.length === 0) {\\n      return sM[0];\\n    } else if (sM.length === 0) {\\n      return sP[0];\\n    } else if (Math.abs(sP[0]) > Math.abs(sM[0])) {\\n      return sM[0];\\n    } else {\\n      return sP[0];\\n    }\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar findClosestNumber = function(nums) {\\n  let plus = [];\\n  let minus = [];\\n  let sP = [];\\n  let sM = [];\\n\\n  if (nums == 0) {\\n    return 0;\\n  } else {\\n    for (let i = 0; i < nums.length; i++) {\\n      if (nums[i] > 0) {\\n        plus.push(nums[i]);\\n      } else {\\n        minus.push(nums[i]);\\n      }\\n    }\\n\\n    sP = plus.sort((a, b) => a - b);\\n    sM = minus.sort((a, b) => b - a);\\n\\n    if (sP.length === 0) {\\n      return sM[0];\\n    } else if (sM.length === 0) {\\n      return sP[0];\\n    } else if (Math.abs(sP[0]) > Math.abs(sM[0])) {\\n      return sM[0];\\n    } else {\\n      return sP[0];\\n    }\\n  }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3970639,
                "title": "solution-using-set-o-n-fast-runtime-127ms",
                "content": "![\\u0438\\u0437\\u043E\\u0431\\u0440\\u0430\\u0436\\u0435\\u043D\\u0438\\u0435_2023-08-28_102818728.png](https://assets.leetcode.com/users/images/b7992d70-f31d-4da5-bbff-d93b15a5ba83_1693207742.3729894.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        closest = set()\\n        cur_min = 10 ** 5 + 1\\n        for num in nums:\\n            if num < 0:\\n                tmp = -num\\n            else:\\n                tmp = num\\n            if tmp < cur_min:\\n                closest.clear()\\n                closest.add(num)\\n                cur_min = tmp\\n            elif tmp == cur_min:\\n                closest.add(num)\\n        return max(closest)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        closest = set()\\n        cur_min = 10 ** 5 + 1\\n        for num in nums:\\n            if num < 0:\\n                tmp = -num\\n            else:\\n                tmp = num\\n            if tmp < cur_min:\\n                closest.clear()\\n                closest.add(num)\\n                cur_min = tmp\\n            elif tmp == cur_min:\\n                closest.add(num)\\n        return max(closest)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969770,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int x = Integer.MAX_VALUE;\\n        int y = 0;\\n        Arrays.sort(nums);\\n        int curr = 0;\\n        for(int i:nums){\\n            curr = Math.abs(0-i);\\n            if(curr<=x){\\n                x = curr;\\n                y = i;\\n            }\\n        }\\n        // if(x==Integer.MAX_VALUE){\\n        //     x = nums[nums.length-1];\\n        // }\\n        return y;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int x = Integer.MAX_VALUE;\\n        int y = 0;\\n        Arrays.sort(nums);\\n        int curr = 0;\\n        for(int i:nums){\\n            curr = Math.abs(0-i);\\n            if(curr<=x){\\n                x = curr;\\n                y = i;\\n            }\\n        }\\n        // if(x==Integer.MAX_VALUE){\\n        //     x = nums[nums.length-1];\\n        // }\\n        return y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961128,
                "title": "easy-and-simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]>0:\\n                idx=i\\n                break\\n        else:\\n            idx=-1\\n        if idx<=0:\\n            return nums[idx]\\n        else:\\n            a=nums[idx]-0\\n            b=0-nums[idx-1]\\n            if b<a:\\n                return nums[idx-1]\\n            else:\\n                return nums[idx]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]>0:\\n                idx=i\\n                break\\n        else:\\n            idx=-1\\n        if idx<=0:\\n            return nums[idx]\\n        else:\\n            a=nums[idx]-0\\n            b=0-nums[idx-1]\\n            if b<a:\\n                return nums[idx-1]\\n            else:\\n                return nums[idx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960567,
                "title": "find-closest-number-to-zero",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nlet findClosestNumber = function(nums) {\\n  let a = 0;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] == 0) {\\n      return 0;\\n    } else if (a === 0) {\\n      a = nums[i];\\n    } else if (nums[i] > 0 && nums[i] <= Math.abs(a)) {\\n      a = nums[i];\\n    } else if (nums[i] < 0 && -nums[i] < Math.abs(a)) {\\n      a = nums[i];\\n    }\\n  }\\n  return a;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nlet findClosestNumber = function(nums) {\\n  let a = 0;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] == 0) {\\n      return 0;\\n    } else if (a === 0) {\\n      a = nums[i];\\n    } else if (nums[i] > 0 && nums[i] <= Math.abs(a)) {\\n      a = nums[i];\\n    } else if (nums[i] < 0 && -nums[i] < Math.abs(a)) {\\n      a = nums[i];\\n    }\\n  }\\n  return a;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3958001,
                "title": "find-closest-number",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n Arrays.sort(nums);\\n int des_indx=0;\\n int des_val=nums[0];\\n for(int i:nums){\\n  if(i==0) return 0;\\n  if(i>0){\\n   des_indx=i;\\n   break;   \\n  }\\n  des_val=i;\\n   }\\n   if(des_indx==0) return nums[nums.length-1];\\n   if(Math.abs(des_val)<des_indx)return des_val;\\n   return des_indx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n Arrays.sort(nums);\\n int des_indx=0;\\n int des_val=nums[0];\\n for(int i:nums){\\n  if(i==0) return 0;\\n  if(i>0){\\n   des_indx=i;\\n   break;   \\n  }\\n  des_val=i;\\n   }\\n   if(des_indx==0) return nums[nums.length-1];\\n   if(Math.abs(des_val)<des_indx)return des_val;\\n   return des_indx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956300,
                "title": "simple-js-solution-with-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findClosestNumber = function(nums) {\\n    if(!nums || nums.length === 0) {\\n        return 0;\\n    }\\n\\n    let maxVal = Infinity;\\n    let result = Infinity;\\n    nums.forEach((item) => {\\n        if(Math.abs(item) < maxVal) {\\n            maxVal = Math.abs(item);\\n            result = item;\\n        } else if (item === maxVal && item >= 0) {\\n            maxVal = item;\\n            result = item;\\n        }\\n    }); \\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findClosestNumber = function(nums) {\\n    if(!nums || nums.length === 0) {\\n        return 0;\\n    }\\n\\n    let maxVal = Infinity;\\n    let result = Infinity;\\n    nums.forEach((item) => {\\n        if(Math.abs(item) < maxVal) {\\n            maxVal = Math.abs(item);\\n            result = item;\\n        } else if (item === maxVal && item >= 0) {\\n            maxVal = item;\\n            result = item;\\n        }\\n    }); \\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3954431,
                "title": "python-easyyyyyyyyy",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        destance = nums[0]\\n        for i in range(1, len(nums)):\\n            destance = min(abs(destance), abs(0 - nums[i]))\\n        if destance in nums:\\n            return destance\\n        \\n        return -destance\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        destance = nums[0]\\n        for i in range(1, len(nums)):\\n            destance = min(abs(destance), abs(0 - nums[i]))\\n        if destance in nums:\\n            return destance\\n        \\n        return -destance\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952503,
                "title": "1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return min(nums, key = lambda x: (abs(x), -x))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return min(nums, key = lambda x: (abs(x), -x))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944051,
                "title": "java-easy-to-understand-linear",
                "content": "```\\nclass Solution {\\n    \\n    public int findClosestNumber(int[] nums) {\\n        \\n        Pair pair = new Pair(Integer.MAX_VALUE, Integer.MAX_VALUE);\\n        \\n        for (int i=0; i<nums.length; i++) {\\n            \\n            int currDistance = Math.abs(nums[i]) - 0;\\n            \\n            if (pair.distance > currDistance) {\\n                \\n                pair.num = nums[i];\\n                pair.distance = currDistance;\\n                \\n            } else if (pair.distance == currDistance) {\\n                \\n                if (pair.num < nums[i]) {\\n                    pair.num = nums[i];\\n                }\\n            }\\n        }\\n        \\n        return pair.num;\\n    }\\n    \\n    private class Pair {\\n        \\n        int num;\\n        int distance;\\n        \\n        public Pair(int num, int distance) {\\n            \\n            this.distance = distance;\\n            this.num = num;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int findClosestNumber(int[] nums) {\\n        \\n        Pair pair = new Pair(Integer.MAX_VALUE, Integer.MAX_VALUE);\\n        \\n        for (int i=0; i<nums.length; i++) {\\n            \\n            int currDistance = Math.abs(nums[i]) - 0;\\n            \\n            if (pair.distance > currDistance) {\\n                \\n                pair.num = nums[i];\\n                pair.distance = currDistance;\\n                \\n            } else if (pair.distance == currDistance) {\\n                \\n                if (pair.num < nums[i]) {\\n                    pair.num = nums[i];\\n                }\\n            }\\n        }\\n        \\n        return pair.num;\\n    }\\n    \\n    private class Pair {\\n        \\n        int num;\\n        int distance;\\n        \\n        public Pair(int num, int distance) {\\n            \\n            this.distance = distance;\\n            this.num = num;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939522,
                "title": "c-code-easy-to-understand-and-implement-beats-in-runtime-and-memory",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Try out this way\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int findClosestNumber(vector<int>& nums) {\\n    return *min_element(nums.begin(), nums.end(), [](const int a, const int b) {\\n      return abs(a) == abs(b) ? a > b : abs(a) < abs(b);\\n    });\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int findClosestNumber(vector<int>& nums) {\\n    return *min_element(nums.begin(), nums.end(), [](const int a, const int b) {\\n      return abs(a) == abs(b) ? a > b : abs(a) < abs(b);\\n    });\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939331,
                "title": "one-liner-js-for-the-smallest-bundle-size",
                "content": "Only 100 characters needed.\\n# Code\\n```\\nvar findClosestNumber=a=>a.sort(((a,s)=>Math.abs(a)===Math.abs(s)?s-a:Math.abs(a)-Math.abs(s)))[0];\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findClosestNumber=a=>a.sort(((a,s)=>Math.abs(a)===Math.abs(s)?s-a:Math.abs(a)-Math.abs(s)))[0];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3939120,
                "title": "absolute-minimal-typescript-solution",
                "content": "```\\n// based on https://leetcode.com/problems/find-closest-number-to-zero/solutions/2163415/simple-javascript-typescript-solution/\\n\\nfunction findClosestNumber(nums: number[]): number {\\n    // you don\\'t have to use Number.MAX_VALUE in JS\\n    let belowZero = -Infinity;\\n    let aboveZero = Infinity;\\n    for (const num of nums) {\\n        if (num < 0) {\\n            // keep track of negative value closest to zero\\n            belowZero = Math.max(belowZero, num);\\n        } else {\\n            // keep track of positive value closest to zero\\n            aboveZero = Math.min(aboveZero, num);\\n        }\\n    }\\n    // compare which value is closest to zero, if they are equal use positive\\n    return aboveZero <= -belowZero ? aboveZero : belowZero;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n// based on https://leetcode.com/problems/find-closest-number-to-zero/solutions/2163415/simple-javascript-typescript-solution/\\n\\nfunction findClosestNumber(nums: number[]): number {\\n    // you don\\'t have to use Number.MAX_VALUE in JS\\n    let belowZero = -Infinity;\\n    let aboveZero = Infinity;\\n    for (const num of nums) {\\n        if (num < 0) {\\n            // keep track of negative value closest to zero\\n            belowZero = Math.max(belowZero, num);\\n        } else {\\n            // keep track of positive value closest to zero\\n            aboveZero = Math.min(aboveZero, num);\\n        }\\n    }\\n    // compare which value is closest to zero, if they are equal use positive\\n    return aboveZero <= -belowZero ? aboveZero : belowZero;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938380,
                "title": "easy-to-understand-c-better",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution { //\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int mini=INT_MAX;\\n        int dis;\\n        int sign;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            dis=abs(nums[i]);\\n            mini=min(dis,mini);\\n            if(dis>mini) break;\\n            sign=nums[i];\\n        }\\n        if(w<0){\\n            mini= mini*(-1);\\n        }\\n        else if(sign>=0){\\n            mini=abs(mini);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution { //\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int mini=INT_MAX;\\n        int dis;\\n        int sign;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            dis=abs(nums[i]);\\n            mini=min(dis,mini);\\n            if(dis>mini) break;\\n            sign=nums[i];\\n        }\\n        if(w<0){\\n            mini= mini*(-1);\\n        }\\n        else if(sign>=0){\\n            mini=abs(mini);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930755,
                "title": "beats-100-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int close=9999999;\\n        int ans=0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int diff= 0-nums[i];\\n            if(diff<0){\\n                diff=-diff;\\n            }\\n            if(diff<close){\\n                ans=nums[i];\\n                close=diff;\\n            }\\n            if((diff==close)&& nums[i]>ans){\\n                ans=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int close=9999999;\\n        int ans=0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int diff= 0-nums[i];\\n            if(diff<0){\\n                diff=-diff;\\n            }\\n            if(diff<close){\\n                ans=nums[i];\\n                close=diff;\\n            }\\n            if((diff==close)&& nums[i]>ans){\\n                ans=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915792,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind maximum of absolute value of element and if same then replace based on value\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        dis = nums[0]\\n        for i in nums[1:]:\\n            if abs(dis)>abs(i) or (abs(dis)==abs(i) and dis<i):\\n                dis = i\\n        return dis\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        dis = nums[0]\\n        for i in nums[1:]:\\n            if abs(dis)>abs(i) or (abs(dis)==abs(i) and dis<i):\\n                dis = i\\n        return dis\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915182,
                "title": "one-liner-beats-93-81",
                "content": "# Code\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return min(nums, key = lambda x: (abs(x), -x))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return min(nums, key = lambda x: (abs(x), -x))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898231,
                "title": "simple-sol-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n       int closestNo=nums[0];\\n      for(int i=1; i<nums.length; i++){\\n        if(Math.abs(closestNo)==(nums[i])){\\n            closestNo=nums[i];\\n        }\\n        if(Math.abs(nums[i])<Math.abs(closestNo)){\\n            closestNo=nums[i];\\n        }\\n      }\\n      return closestNo;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n       int closestNo=nums[0];\\n      for(int i=1; i<nums.length; i++){\\n        if(Math.abs(closestNo)==(nums[i])){\\n            closestNo=nums[i];\\n        }\\n        if(Math.abs(nums[i])<Math.abs(closestNo)){\\n            closestNo=nums[i];\\n        }\\n      }\\n      return closestNo;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893045,
                "title": "simple-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findClosestNumber = function(nums) {\\n    nums.push(0);\\n    nums.sort((a,b)=>a-b);\\n    var ind=0;\\n    for(var i=0;i<nums.length;i++)\\n    {\\n        if(nums[i]==0)\\n        {\\n            ind=i;\\n            break;\\n        }\\n    }\\n    var ld=Math.abs(nums[ind-1]);\\n    var rd=Math.abs(nums[ind+1]);\\n    if(ind==0)\\n    {\\n        return nums[ind+1];\\n    }\\n    if(ind==nums.length-1)\\n    {\\n        return nums[ind-1];\\n    }\\n    return ld<rd ? nums[ind-1]:nums[ind+1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findClosestNumber = function(nums) {\\n    nums.push(0);\\n    nums.sort((a,b)=>a-b);\\n    var ind=0;\\n    for(var i=0;i<nums.length;i++)\\n    {\\n        if(nums[i]==0)\\n        {\\n            ind=i;\\n            break;\\n        }\\n    }\\n    var ld=Math.abs(nums[ind-1]);\\n    var rd=Math.abs(nums[ind+1]);\\n    if(ind==0)\\n    {\\n        return nums[ind+1];\\n    }\\n    if(ind==nums.length-1)\\n    {\\n        return nums[ind-1];\\n    }\\n    return ld<rd ? nums[ind-1]:nums[ind+1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3892061,
                "title": "c-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int min=INT_MAX,ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int diff=nums[i]-0;\\n            if(abs(diff)<=min){\\n                min=abs(diff);\\n                ans=diff;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int min=INT_MAX,ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int diff=nums[i]-0;\\n            if(abs(diff)<=min){\\n                min=abs(diff);\\n                ans=diff;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889512,
                "title": "easy-cpp-solution-beats-90-70-in-runtime-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/29d91988-02b6-4856-97f7-43294ae6d22b_1691654044.1386578.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int ans = INT_MAX;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(abs(nums[i]) == abs(ans))\\n                ans = ans > nums[i] ? ans : nums[i];\\n            else\\n                ans = abs(ans) < abs(nums[i]) ? ans : nums[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int ans = INT_MAX;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(abs(nums[i]) == abs(ans))\\n                ans = ans > nums[i] ? ans : nums[i];\\n            else\\n                ans = abs(ans) < abs(nums[i]) ? ans : nums[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886935,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int close = 0;\\n        int afterMin = false;\\n        int negatif= true;\\n        for(int i = 0; i<nums.size()-1; i++){\\n           if(nums[i]<0){\\n               close = nums[i];\\n                if(abs(nums[i]) >= nums[i+1]){\\n                    close = nums[i+1];\\n                    negatif = false;\\n                }\\n                 afterMin = true;\\n           }else{\\n               if(afterMin){\\n                   if(negatif){\\n                       return -close;\\n                   }\\n                   return close;\\n               }\\n               return nums[i];\\n           }\\n        }\\n        return close;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int close = 0;\\n        int afterMin = false;\\n        int negatif= true;\\n        for(int i = 0; i<nums.size()-1; i++){\\n           if(nums[i]<0){\\n               close = nums[i];\\n                if(abs(nums[i]) >= nums[i+1]){\\n                    close = nums[i+1];\\n                    negatif = false;\\n                }\\n                 afterMin = true;\\n           }else{\\n               if(afterMin){\\n                   if(negatif){\\n                       return -close;\\n                   }\\n                   return close;\\n               }\\n               return nums[i];\\n           }\\n        }\\n        return close;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886829,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=99999999,s=0;\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                s=0-nums[i];\\n            }\\n            else{\\n                s=nums[i]-0;\\n            }\\n            if(min>s){\\n                min=s;}\\n        }\\n       for(int i=0;i<nums.length;i++){\\n           if(min!=nums[i]){\\n               c++;\\n           }\\n       }\\n       if(c==nums.length){\\n           return -min;\\n       }\\n       else{\\n           return  min;\\n       }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=99999999,s=0;\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                s=0-nums[i];\\n            }\\n            else{\\n                s=nums[i]-0;\\n            }\\n            if(min>s){\\n                min=s;}\\n        }\\n       for(int i=0;i<nums.length;i++){\\n           if(min!=nums[i]){\\n               c++;\\n           }\\n       }\\n       if(c==nums.length){\\n           return -min;\\n       }\\n       else{\\n           return  min;\\n       }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886828,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=99999999,s=0;\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                s=0-nums[i];\\n            }\\n            else{\\n                s=nums[i]-0;\\n            }\\n            if(min>s){\\n                min=s;}\\n        }\\n       for(int i=0;i<nums.length;i++){\\n           if(min!=nums[i]){\\n               c++;\\n           }\\n       }\\n       if(c==nums.length){\\n           return -min;\\n       }\\n       else{\\n           return  min;\\n       }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=99999999,s=0;\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                s=0-nums[i];\\n            }\\n            else{\\n                s=nums[i]-0;\\n            }\\n            if(min>s){\\n                min=s;}\\n        }\\n       for(int i=0;i<nums.length;i++){\\n           if(min!=nums[i]){\\n               c++;\\n           }\\n       }\\n       if(c==nums.length){\\n           return -min;\\n       }\\n       else{\\n           return  min;\\n       }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879509,
                "title": "easy-to-understand",
                "content": "# Intuition\\nTheir are two condition to get the result.\\n1. Idea is to get the lowest value.\\n2. To get the max value if we find numbers with same lowest values.\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n    }\\n    int findClosestNumber(vector<int>& nums) \\n    {\\n        int diff=INT_MAX,temp,res;\\n        for(auto num:nums)\\n        {\\n            temp=abs(num);\\n            if(temp<diff)\\n            {\\n                res=num;\\n                diff=temp;\\n            }\\n            else if(temp==diff)\\n            {\\n                if(num>0) res=num;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n    }\\n    int findClosestNumber(vector<int>& nums) \\n    {\\n        int diff=INT_MAX,temp,res;\\n        for(auto num:nums)\\n        {\\n            temp=abs(num);\\n            if(temp<diff)\\n            {\\n                res=num;\\n                diff=temp;\\n            }\\n            else if(temp==diff)\\n            {\\n                if(num>0) res=num;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873892,
                "title": "simple-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        //Find the \"closest\" distance to zero\\n        int mini= INT_MAX;\\n        for (int i = 0; i<nums.size(); i++){\\n            mini = min(abs(nums[i]), mini);\\n        }\\n    int ans = INT_MIN;\\n        //Finding the largest value with the min distance\\n        for(int i=0; i<nums.size();i++){\\n            if(abs(nums[i])==mini){\\n                ans = max(nums[i], ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        //Find the \"closest\" distance to zero\\n        int mini= INT_MAX;\\n        for (int i = 0; i<nums.size(); i++){\\n            mini = min(abs(nums[i]), mini);\\n        }\\n    int ans = INT_MIN;\\n        //Finding the largest value with the min distance\\n        for(int i=0; i<nums.size();i++){\\n            if(abs(nums[i])==mini){\\n                ans = max(nums[i], ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871201,
                "title": "simplest-approach-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction findClosestNumber(nums: number[]): number {\\n    let closest = nums[0]\\n    let closestDistance = Math.abs(nums[0] - 0)\\n\\n    let closestPositive = null\\n    let closestNegative = null\\n\\n    for(let i = 1; i <= nums.length; i++){\\n        // returns distance in positive to caluclate closest\\n        let distance = Math.abs(nums[i] - 0)\\n        \\n        // calculate the distance\\n        if(distance < closestDistance){\\n            closestDistance = distance\\n            closest = nums[i]\\n        }\\n\\n        if(nums[i] < 0 && (nums[i] < closestNegative) || closestNegative === null ){ // negative number\\n            closestNegative = nums[i]\\n        }else if (nums[i] > 0 && (nums[i] < closestPositive || closestPositive === null)){ // positive number\\n            closestPositive = nums[i]\\n        }\\n\\n    }\\n\\n    // check if positive and negative number is same\\n    if(closestPositive && closestNegative){\\n        if(Math.abs(closestNegative) === closestPositive){\\n            return closest = closestPositive\\n        }\\n    }\\n\\n    return closest\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction findClosestNumber(nums: number[]): number {\\n    let closest = nums[0]\\n    let closestDistance = Math.abs(nums[0] - 0)\\n\\n    let closestPositive = null\\n    let closestNegative = null\\n\\n    for(let i = 1; i <= nums.length; i++){\\n        // returns distance in positive to caluclate closest\\n        let distance = Math.abs(nums[i] - 0)\\n        \\n        // calculate the distance\\n        if(distance < closestDistance){\\n            closestDistance = distance\\n            closest = nums[i]\\n        }\\n\\n        if(nums[i] < 0 && (nums[i] < closestNegative) || closestNegative === null ){ // negative number\\n            closestNegative = nums[i]\\n        }else if (nums[i] > 0 && (nums[i] < closestPositive || closestPositive === null)){ // positive number\\n            closestPositive = nums[i]\\n        }\\n\\n    }\\n\\n    // check if positive and negative number is same\\n    if(closestPositive && closestNegative){\\n        if(Math.abs(closestNegative) === closestPositive){\\n            return closest = closestPositive\\n        }\\n    }\\n\\n    return closest\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1794074,
                "content": [
                    {
                        "username": "pranavk2208",
                        "content": "My output:\\n1321\\n\\nExpected Output:\\n-1321\\n\\nCan someone please explain why?"
                    },
                    {
                        "username": "raj20012017",
                        "content": "can you share your test case of your given problem?"
                    },
                    {
                        "username": "HNcodes",
                        "content": "because u might be storing only the magnitude of -1321 as ur ans"
                    },
                    {
                        "username": "Smania",
                        "content": "you should share your code, it\\'s difficult to know what your error is without knowing what is your process (probably an error while assigning an absolute value)"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `\\n\\n       class Solution {\\n             public int findClosestNumber(int[] nums) {\\n                   ArrayList<Integer> p = new ArrayList<>();\\n                   ArrayList<Integer> n = new ArrayList<>();\\n\\n                  int k = nums.length;\\n                  for(int i=0; i<k; i++){\\n                     if(nums[i] < 0){\\n                         nums[i] = nums[i]*-1;\\n                         n.add(nums[i]);\\n                    } else {\\n                        p.add(nums[i]);\\n                   }\\n               }\\n              Collections.sort(p);  \\n              Collections.sort(n);  \\n\\n             int res = 0;\\n            if(p.get(0) < n.get(0) || p.get(0) == n.get(0) ) {\\n                      res = p.get(0);\\n            } else {\\n                    res = -1*n.get(0);\\n            }\\n\\n           return res;\\n\\n            }\\n          }\\n\\n\\n`\\nCan anyone tell What\\'s wrong in this code ?   \\n\\nI am getting this error : \\njava.lang.IndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 64, java.base/jdk.internal.util.Preconditions.outOfBounds\\n  at line 70, java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex\\n  at line 266, java.base/jdk.internal.util.Preconditions.checkIndex\\n  at line 361, java.base/java.util.Objects.checkIndex\\n  at line 427, java.base/java.util.ArrayList.get\\n  at line 19, Solution.findClosestNumber\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI have run this code in online compiler it runs fine but getting error on leetcode, why?\\n"
                    },
                    {
                        "username": "momen_alshouha",
                        "content": "input :\\nnums = [61488,18221,-1321,90249,-62158,55128,-93476,53905,57644,24630,89599,-95795,-14891,-60298,17690,99022,-24006,-89156,80135,-46303,18812,59924,32024,82924,-47519,-77086,1763,68618,53629,-56957,95485,99630,-7977,31164,94481,-80239,-57749,-3319,-58231,-94841,-19292,33200,-31446,-3528,2229,74241,-19992,-91852,-28073,31453,-74484,35491,38870,-9499,39838,87369,21123,-38616,-89277,-14541,-81586,-18569,-58242,-71216,10816,15086,-10519,51080,53257,-4912,-37142,-16723,-69795,54937,-24920,68970,-10010,-81717,36203,-67939,73877,-58258,-57183,36637,91518,-8492,-57476,50523,62462,73152,-9511,-66761,28333,-87163,5187]\\n\\noutput : 1321\\n\\nexpected: -1321\\n\\nCan anyone explain this test case ? i think valid output returned"
                    },
                    {
                        "username": "Aritra_9",
                        "content": " If there are multiple answers, return the number with the largest value."
                    },
                    {
                        "username": "ravi18kumar",
                        "content": "there is no such value as 1321 is  present in the array . check if you are returning the answer correctly or you are just returning the positive part of count by mistake."
                    }
                ]
            },
            {
                "id": 1976894,
                "content": [
                    {
                        "username": "pranavk2208",
                        "content": "My output:\\n1321\\n\\nExpected Output:\\n-1321\\n\\nCan someone please explain why?"
                    },
                    {
                        "username": "raj20012017",
                        "content": "can you share your test case of your given problem?"
                    },
                    {
                        "username": "HNcodes",
                        "content": "because u might be storing only the magnitude of -1321 as ur ans"
                    },
                    {
                        "username": "Smania",
                        "content": "you should share your code, it\\'s difficult to know what your error is without knowing what is your process (probably an error while assigning an absolute value)"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `\\n\\n       class Solution {\\n             public int findClosestNumber(int[] nums) {\\n                   ArrayList<Integer> p = new ArrayList<>();\\n                   ArrayList<Integer> n = new ArrayList<>();\\n\\n                  int k = nums.length;\\n                  for(int i=0; i<k; i++){\\n                     if(nums[i] < 0){\\n                         nums[i] = nums[i]*-1;\\n                         n.add(nums[i]);\\n                    } else {\\n                        p.add(nums[i]);\\n                   }\\n               }\\n              Collections.sort(p);  \\n              Collections.sort(n);  \\n\\n             int res = 0;\\n            if(p.get(0) < n.get(0) || p.get(0) == n.get(0) ) {\\n                      res = p.get(0);\\n            } else {\\n                    res = -1*n.get(0);\\n            }\\n\\n           return res;\\n\\n            }\\n          }\\n\\n\\n`\\nCan anyone tell What\\'s wrong in this code ?   \\n\\nI am getting this error : \\njava.lang.IndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 64, java.base/jdk.internal.util.Preconditions.outOfBounds\\n  at line 70, java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex\\n  at line 266, java.base/jdk.internal.util.Preconditions.checkIndex\\n  at line 361, java.base/java.util.Objects.checkIndex\\n  at line 427, java.base/java.util.ArrayList.get\\n  at line 19, Solution.findClosestNumber\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI have run this code in online compiler it runs fine but getting error on leetcode, why?\\n"
                    },
                    {
                        "username": "momen_alshouha",
                        "content": "input :\\nnums = [61488,18221,-1321,90249,-62158,55128,-93476,53905,57644,24630,89599,-95795,-14891,-60298,17690,99022,-24006,-89156,80135,-46303,18812,59924,32024,82924,-47519,-77086,1763,68618,53629,-56957,95485,99630,-7977,31164,94481,-80239,-57749,-3319,-58231,-94841,-19292,33200,-31446,-3528,2229,74241,-19992,-91852,-28073,31453,-74484,35491,38870,-9499,39838,87369,21123,-38616,-89277,-14541,-81586,-18569,-58242,-71216,10816,15086,-10519,51080,53257,-4912,-37142,-16723,-69795,54937,-24920,68970,-10010,-81717,36203,-67939,73877,-58258,-57183,36637,91518,-8492,-57476,50523,62462,73152,-9511,-66761,28333,-87163,5187]\\n\\noutput : 1321\\n\\nexpected: -1321\\n\\nCan anyone explain this test case ? i think valid output returned"
                    },
                    {
                        "username": "Aritra_9",
                        "content": " If there are multiple answers, return the number with the largest value."
                    },
                    {
                        "username": "ravi18kumar",
                        "content": "there is no such value as 1321 is  present in the array . check if you are returning the answer correctly or you are just returning the positive part of count by mistake."
                    }
                ]
            },
            {
                "id": 1849770,
                "content": [
                    {
                        "username": "pranavk2208",
                        "content": "My output:\\n1321\\n\\nExpected Output:\\n-1321\\n\\nCan someone please explain why?"
                    },
                    {
                        "username": "raj20012017",
                        "content": "can you share your test case of your given problem?"
                    },
                    {
                        "username": "HNcodes",
                        "content": "because u might be storing only the magnitude of -1321 as ur ans"
                    },
                    {
                        "username": "Smania",
                        "content": "you should share your code, it\\'s difficult to know what your error is without knowing what is your process (probably an error while assigning an absolute value)"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `\\n\\n       class Solution {\\n             public int findClosestNumber(int[] nums) {\\n                   ArrayList<Integer> p = new ArrayList<>();\\n                   ArrayList<Integer> n = new ArrayList<>();\\n\\n                  int k = nums.length;\\n                  for(int i=0; i<k; i++){\\n                     if(nums[i] < 0){\\n                         nums[i] = nums[i]*-1;\\n                         n.add(nums[i]);\\n                    } else {\\n                        p.add(nums[i]);\\n                   }\\n               }\\n              Collections.sort(p);  \\n              Collections.sort(n);  \\n\\n             int res = 0;\\n            if(p.get(0) < n.get(0) || p.get(0) == n.get(0) ) {\\n                      res = p.get(0);\\n            } else {\\n                    res = -1*n.get(0);\\n            }\\n\\n           return res;\\n\\n            }\\n          }\\n\\n\\n`\\nCan anyone tell What\\'s wrong in this code ?   \\n\\nI am getting this error : \\njava.lang.IndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 64, java.base/jdk.internal.util.Preconditions.outOfBounds\\n  at line 70, java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex\\n  at line 266, java.base/jdk.internal.util.Preconditions.checkIndex\\n  at line 361, java.base/java.util.Objects.checkIndex\\n  at line 427, java.base/java.util.ArrayList.get\\n  at line 19, Solution.findClosestNumber\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI have run this code in online compiler it runs fine but getting error on leetcode, why?\\n"
                    },
                    {
                        "username": "momen_alshouha",
                        "content": "input :\\nnums = [61488,18221,-1321,90249,-62158,55128,-93476,53905,57644,24630,89599,-95795,-14891,-60298,17690,99022,-24006,-89156,80135,-46303,18812,59924,32024,82924,-47519,-77086,1763,68618,53629,-56957,95485,99630,-7977,31164,94481,-80239,-57749,-3319,-58231,-94841,-19292,33200,-31446,-3528,2229,74241,-19992,-91852,-28073,31453,-74484,35491,38870,-9499,39838,87369,21123,-38616,-89277,-14541,-81586,-18569,-58242,-71216,10816,15086,-10519,51080,53257,-4912,-37142,-16723,-69795,54937,-24920,68970,-10010,-81717,36203,-67939,73877,-58258,-57183,36637,91518,-8492,-57476,50523,62462,73152,-9511,-66761,28333,-87163,5187]\\n\\noutput : 1321\\n\\nexpected: -1321\\n\\nCan anyone explain this test case ? i think valid output returned"
                    },
                    {
                        "username": "Aritra_9",
                        "content": " If there are multiple answers, return the number with the largest value."
                    },
                    {
                        "username": "ravi18kumar",
                        "content": "there is no such value as 1321 is  present in the array . check if you are returning the answer correctly or you are just returning the positive part of count by mistake."
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Lattice Points Inside a Circle",
        "question_content": "<p>Given a 2D integer array <code>circles</code> where <code>circles[i] = [x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub>]</code> represents the center <code>(x<sub>i</sub>, y<sub>i</sub>)</code> and radius <code>r<sub>i</sub></code> of the <code>i<sup>th</sup></code> circle drawn on a grid, return <em>the <strong>number of lattice points</strong> </em><em>that are present inside <strong>at least one</strong> circle</em>.</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>A <strong>lattice point</strong> is a point with integer coordinates.</li>\n\t<li>Points that lie <strong>on the circumference of a circle</strong> are also considered to be inside it.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/exa-11.png\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> circles = [[2,2,1]]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong>\nThe figure above shows the given circle.\nThe lattice points present inside the circle are (1, 2), (2, 1), (2, 2), (2, 3), and (3, 2) and are shown in green.\nOther points such as (1, 1) and (1, 3), which are shown in red, are not considered inside the circle.\nHence, the number of lattice points present inside at least one circle is 5.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/exa-22.png\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> circles = [[2,2,2],[3,4,1]]\n<strong>Output:</strong> 16\n<strong>Explanation:</strong>\nThe figure above shows the given circles.\nThere are exactly 16 lattice points which are present inside at least one circle. \nSome of them are (0, 2), (2, 0), (2, 4), (3, 2), and (4, 4).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= circles.length &lt;= 200</code></li>\n\t<li><code>circles[i].length == 3</code></li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 100</code></li>\n\t<li><code>1 &lt;= r<sub>i</sub> &lt;= min(x<sub>i</sub>, y<sub>i</sub>)</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1976815,
                "title": "easy-c-code",
                "content": "Let r be the radius of the circle.\\nWe iterate from -r to +r in x-direction and y-direction. So we iterate over entire integer co-ordinates of the boundary square and find if it is inside a circle or not using Euclidean distance.\\nWe insert all the co-ordinates in a set to avoid duplicates and return the size of set.\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& v) { // v is vector of circles.\\n        int n = v.size();\\n        set<pair<int,int>> s;\\n        for(int i=0;i<n;i++){\\n            int a=v[i][0],b=v[i][1],r=v[i][2];\\n            for(int x=-r;x<=r;x++){\\n                for(int y=-r;y<=r;y++){\\n                    if((x*x)+(y*y)<=(r*r)){\\n                        s.insert({x+a,y+b});\\n                    }\\n                }\\n            }\\n        }\\n        int ans = s.size();\\n        return ans;\\n    }\\n};\\n```\\n\\n**Approach in O(1) space**\\nFrom the given constraints we can notice that the lattice points lie in a certain range, where the co-ordinates are as:\\n*0<=x<=200  and 0<=y<=200*\\nSo we iterate over every point from the range and check whether, it is present in any of the circle or not.\\nSo this way, we can reduce the space complexity just by counting every point once.\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& v) { // v is vector of circles.\\n        int n = v.size();\\n        int ans = 0;\\n        for(int x=0;x<=200;x++){\\n            for(int y=0;y<=200;y++){\\n                for(int i=0;i<n;i++){\\n                    int a=v[i][0],b=v[i][1],r=v[i][2];\\n                    if((a-x)*(a-x) + (b-y)*(b-y) <= r*r){\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Upvote if it helps !**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& v) { // v is vector of circles.\\n        int n = v.size();\\n        set<pair<int,int>> s;\\n        for(int i=0;i<n;i++){\\n            int a=v[i][0],b=v[i][1],r=v[i][2];\\n            for(int x=-r;x<=r;x++){\\n                for(int y=-r;y<=r;y++){\\n                    if((x*x)+(y*y)<=(r*r)){\\n                        s.insert({x+a,y+b});\\n                    }\\n                }\\n            }\\n        }\\n        int ans = s.size();\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& v) { // v is vector of circles.\\n        int n = v.size();\\n        int ans = 0;\\n        for(int x=0;x<=200;x++){\\n            for(int y=0;y<=200;y++){\\n                for(int i=0;i<n;i++){\\n                    int a=v[i][0],b=v[i][1],r=v[i][2];\\n                    if((a-x)*(a-x) + (b-y)*(b-y) <= r*r){\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976808,
                "title": "distance-formula-java",
                "content": "\\n    public int countLatticePoints(int[][] circles) {\\n        HashSet<String> res = new HashSet<String>();\\n        for(int[] arr : circles){\\n            int x = arr[0], y = arr[1], r = arr[2];\\n            for(int i=x-r; i<=x+r; i++)\\n                for(int j=y-r; j<=y+r; j++)\\n                    if((x-i)*(x-i) + (y-j)*(y-j) <= r*r)\\n                        res.add(i+\",\"+j);\\n        }\\n        return res.size();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public int countLatticePoints(int[][] circles) {\\n        HashSet<String> res = new HashSet<String>();\\n        for(int[] arr : circles){\\n            int x = arr[0], y = arr[1], r = arr[2];\\n            for(int i=x-r; i<=x+r; i++)\\n                for(int j=y-r; j<=y+r; j++)\\n                    if((x-i)*(x-i) + (y-j)*(y-j) <= r*r)\\n                        res.add(i+\",\"+j);\\n        }\\n        return res.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1980902,
                "title": "java-c-python-o-1-space",
                "content": "Updated this post, \\nsince I noticed almost every solutions will use `set`,\\nwith extra space complexity.\\n<br>\\n# **Solution 1: Set**\\n## **Explanation**\\nFor each circle `(x, y)`,\\nenumerate `i` from `x - r` to `x + r`\\nenumerate `j` from `y - r` to `y + r`\\nCheck if `(i, j)` in this circle.\\n\\nIf so, add the point to a set `res` to de-duplicate.\\n<br>\\n\\n## **Complexity**\\nTime `O(NRR)`\\nSpace `O(XY)`\\nwhere `R = 100` is maximum radius of circles.\\n\\nActual run time depends on circles area in test cases.\\n<br>\\n\\n**Java**\\n```java\\n    public int countLatticePoints(int[][] circles) {\\n        Set<Integer> res = new HashSet<>();\\n        for (int[] c : circles)\\n            for (int i = -c[2]; i <= c[2]; i++)\\n                for (int j = -c[2]; j <= c[2]; j++)\\n                    if (i * i + j * j <= c[2] * c[2])\\n                        res.add((c[0] + i) * 1000 + c[1] + j);\\n        return res.size();\\n    }\\n```\\n**C++**\\n```cpp\\n    int countLatticePoints(vector<vector<int>> circles) {\\n        unordered_set<int> res;\\n        for (auto& c : circles)\\n            for (int i = -c[2]; i <= c[2]; i++)\\n                for (int j = -c[2]; j <= c[2]; j++)\\n                    if (i * i + j * j <= c[2] * c[2])\\n                        res.insert((c[0] + i) * 1000 + c[1] + j);\\n        return res.size();\\n    }\\n```\\n**Python3**\\n```py\\n    def countLatticePoints(self, A: List[List[int]]) -> int:\\n        res = set()\\n        for x,y,r in A:\\n            for i in range(x - r,x + r + 1):\\n                for j in range(y - r, y + r + 1):\\n                    if (x - i) ** 2 + (y - j) ** 2 <= r * r:\\n                        res.add((i,j))\\n        return len(res)\\n```\\n\\n# **Solution 2: Check all points, O(1) space**\\n## **Explanation**\\nFor each point `(i, j)` in the plan,\\nenumerate `i` from `0` to `200`\\nenumerate `j` from `0` to `200`\\nCheck if `(i, j)` in any circle.\\n<br>\\n\\n## **Complexity**\\nSame time complexity, `O(1)` space.\\n\\nTime `O(NXY)`\\nSpace `O(1)`\\nwhere `X = 100` is the range of `xi`\\nwhere `Y = 100` is the range of `yi`\\n<br>\\n\\n**Java**\\n```java\\n    public int countLatticePoints(int[][] circles) {\\n        int res = 0;\\n        for (int i = 0; i <= 200; i++) {\\n            for (int j = 0; j <= 200; j++) {\\n                for (int[] c : circles) {\\n                    if ((c[0] - i) * (c[0] - i) + (c[1] - j) * (c[1] - j) <= c[2] * c[2]) {\\n                        res++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int res = 0;\\n        for (int i = 0; i <= 200; i++)\\n            for (int j = 0; j <= 200; j++) {\\n                for (auto& c : circles) {\\n                    if ((c[0] - i) * (c[0] - i) + (c[1] - j) * (c[1] - j) <= c[2] * c[2]) {\\n                        res++;\\n                        break;\\n                    }\\n                }\\n            }\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```java\\n    public int countLatticePoints(int[][] circles) {\\n        Set<Integer> res = new HashSet<>();\\n        for (int[] c : circles)\\n            for (int i = -c[2]; i <= c[2]; i++)\\n                for (int j = -c[2]; j <= c[2]; j++)\\n                    if (i * i + j * j <= c[2] * c[2])\\n                        res.add((c[0] + i) * 1000 + c[1] + j);\\n        return res.size();\\n    }\\n```\n```cpp\\n    int countLatticePoints(vector<vector<int>> circles) {\\n        unordered_set<int> res;\\n        for (auto& c : circles)\\n            for (int i = -c[2]; i <= c[2]; i++)\\n                for (int j = -c[2]; j <= c[2]; j++)\\n                    if (i * i + j * j <= c[2] * c[2])\\n                        res.insert((c[0] + i) * 1000 + c[1] + j);\\n        return res.size();\\n    }\\n```\n```py\\n    def countLatticePoints(self, A: List[List[int]]) -> int:\\n        res = set()\\n        for x,y,r in A:\\n            for i in range(x - r,x + r + 1):\\n                for j in range(y - r, y + r + 1):\\n                    if (x - i) ** 2 + (y - j) ** 2 <= r * r:\\n                        res.add((i,j))\\n        return len(res)\\n```\n```java\\n    public int countLatticePoints(int[][] circles) {\\n        int res = 0;\\n        for (int i = 0; i <= 200; i++) {\\n            for (int j = 0; j <= 200; j++) {\\n                for (int[] c : circles) {\\n                    if ((c[0] - i) * (c[0] - i) + (c[1] - j) * (c[1] - j) <= c[2] * c[2]) {\\n                        res++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int res = 0;\\n        for (int i = 0; i <= 200; i++)\\n            for (int j = 0; j <= 200; j++) {\\n                for (auto& c : circles) {\\n                    if ((c[0] - i) * (c[0] - i) + (c[1] - j) * (c[1] - j) <= c[2] * c[2]) {\\n                        res++;\\n                        break;\\n                    }\\n                }\\n            }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1976978,
                "title": "python-explanation-with-pictures-set",
                "content": "We only need to search lattice points within one quater circle.\\n\\n![image](https://assets.leetcode.com/users/images/b80fa9e6-d4d7-41dd-8888-fcf545791969_1650773344.8191261.png)\\n\\n**code**\\n\\n```\\ndef countLatticePoints(self, A: List[List[int]]) -> int:\\n\\tans = set()\\n\\tfor x,y,r in A:\\n\\t\\tfor cx in range(x + 1, x + r + 1):\\n\\t\\t\\tfor cy in range(y + 1, y + r + 1):\\n\\t\\t\\t\\tif (cx - x) ** 2 + (cy - y) ** 2 <= r ** 2:\\n\\t\\t\\t\\t\\tans.add((cx, cy))\\n\\t\\t\\t\\t\\tans.add((2 * x - cx, cy))\\n\\t\\t\\t\\t\\tans.add((2 * x - cx, 2 * y - cy))\\n\\t\\t\\t\\t\\tans.add((cx, 2 * y - cy))\\n\\t\\tfor cy in range(y - r, y + r + 1): ans.add((x, cy))\\n\\t\\tfor cx in range(x - r, x + r + 1): ans.add((cx, y))\\n\\treturn len(ans)\\n```",
                "solutionTags": [],
                "code": "```\\ndef countLatticePoints(self, A: List[List[int]]) -> int:\\n\\tans = set()\\n\\tfor x,y,r in A:\\n\\t\\tfor cx in range(x + 1, x + r + 1):\\n\\t\\t\\tfor cy in range(y + 1, y + r + 1):\\n\\t\\t\\t\\tif (cx - x) ** 2 + (cy - y) ** 2 <= r ** 2:\\n\\t\\t\\t\\t\\tans.add((cx, cy))\\n\\t\\t\\t\\t\\tans.add((2 * x - cx, cy))\\n\\t\\t\\t\\t\\tans.add((2 * x - cx, 2 * y - cy))\\n\\t\\t\\t\\t\\tans.add((cx, 2 * y - cy))\\n\\t\\tfor cy in range(y - r, y + r + 1): ans.add((x, cy))\\n\\t\\tfor cx in range(x - r, x + r + 1): ans.add((cx, y))\\n\\treturn len(ans)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1976865,
                "title": "c-easy-to-understand-set-pair",
                "content": "***Please upvote if you find it useful in any way to keep me motivated. : )***\\n```\\nclass Solution {\\npublic:\\n    void find(set<pair<int,int>>&s,vector<int>v)\\n    {\\n        int x=v[0], y=v[1], r=v[2];\\n        \\n        for(int i=x-r;i<=x+r;i++)\\n            for(int j=y-r;j<=y+r;j++)\\n                if(sqrt((x-i)*(x-i) + (y-j)*(y-j)) <= r)      //checks if distance of point from center is les than or equal to radius\\n                    s.insert({i,j});\\n    }\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>s;     //used set to store valid points as it does not store same points again(if there are in different circles) \\n        \\n        for(int i=0;i<circles.size();i++)\\n            find(s,circles[i]);\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void find(set<pair<int,int>>&s,vector<int>v)\\n    {\\n        int x=v[0], y=v[1], r=v[2];\\n        \\n        for(int i=x-r;i<=x+r;i++)\\n            for(int j=y-r;j<=y+r;j++)\\n                if(sqrt((x-i)*(x-i) + (y-j)*(y-j)) <= r)      //checks if distance of point from center is les than or equal to radius\\n                    s.insert({i,j});\\n    }\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>s;     //used set to store valid points as it does not store same points again(if there are in different circles) \\n        \\n        for(int i=0;i<circles.size();i++)\\n            find(s,circles[i]);\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977167,
                "title": "python-128-ms-beat-100",
                "content": "Given the constraint, all points are witnin the first quadrant with `x <= 200, y<= 200`. Therefore, we\\'ll just record the intervals on each `x` coordinate. Then we\\'ll just merge the intervals for each `x` coordinate.\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        intervals = [[] for _ in range(201)]\\n        for x, y, r in circles:\\n            for i in range(-r, r + 1):\\n                d = math.floor(math.sqrt(r**2 - i**2))\\n\\t\\t\\t\\t# Add [start, 0] and [end, 1] to the list of intervals.\\n                intervals[x + i].append([y - d, 0])\\n                intervals[x + i].append([y + d, 1])\\n        res = 0\\n\\n        for l in intervals:\\n            if l:\\n                l.sort()\\n\\t\\t\\t\\t# count of open intervals.\\n                count = 0\\n                for i, ind in l:\\n                    if count == 0:\\n                        s = i\\n                    if ind == 0:\\n                        count += 1\\n                    else:\\n                        count -= 1\\n                        if count == 0:\\n                            res += i - s + 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        intervals = [[] for _ in range(201)]\\n        for x, y, r in circles:\\n            for i in range(-r, r + 1):\\n                d = math.floor(math.sqrt(r**2 - i**2))\\n\\t\\t\\t\\t# Add [start, 0] and [end, 1] to the list of intervals.\\n                intervals[x + i].append([y - d, 0])\\n                intervals[x + i].append([y + d, 1])\\n        res = 0\\n\\n        for l in intervals:\\n            if l:\\n                l.sort()\\n\\t\\t\\t\\t# count of open intervals.\\n                count = 0\\n                for i, ind in l:\\n                    if count == 0:\\n                        s = i\\n                    if ind == 0:\\n                        count += 1\\n                    else:\\n                        count -= 1\\n                        if count == 0:\\n                            res += i - s + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984072,
                "title": "square-region",
                "content": "For each circle, we enumerate all lattice points of the square region. If that point is within the radius, we increase the number of points.\\n\\nWe use 2-d array (`g`) to make sure we count \"shared\" lattice points once.\\n\\n**C++**\\n```cpp\\nint countLatticePoints(vector<vector<int>>& circles) {\\n    int res = 0, g[201][201] = {};\\n    for (const auto &c : circles)\\n        for (int dx = -c[2]; dx <= c[2]; ++dx)\\n            for (int dy = -c[2]; dy <= c[2]; ++dy)\\n                if (dx * dx + dy * dy <= c[2] * c[2])\\n                    res += ++g[c[0] + dx][c[1] + dy] == 1;\\n    return res;\\n}  \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint countLatticePoints(vector<vector<int>>& circles) {\\n    int res = 0, g[201][201] = {};\\n    for (const auto &c : circles)\\n        for (int dx = -c[2]; dx <= c[2]; ++dx)\\n            for (int dy = -c[2]; dy <= c[2]; ++dy)\\n                if (dx * dx + dy * dy <= c[2] * c[2])\\n                    res += ++g[c[0] + dx][c[1] + dy] == 1;\\n    return res;\\n}  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977060,
                "title": "c-easy-solution-0ms-faster",
                "content": "\\'\\'\\'\\npoints will range from \\n    x-r to x+r\\n    y-r to y+r \\n    if set already contains the points it means point are already counted and cannot be             \\n    counted   again\\n\\telse if distance of points from center is <=r insert it in set\\n\\t\\nclass Solution {\\npublic:\\n\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> se;\\n        int n=circles.size();\\n        for(int i=0;i<n;i++){\\n            for(int x1=circles[i][0]-r;x1<=circles[i][0]+r;x1++){\\n                for(int y1=circles[i][1]-r;y1<=circles[i][1]+r;y1++){\\n                    if(se.count({x1,y1}))  continue;\\n                    else if(sqrt((x-x1)*(x-x1) + (y-y1)*(y-y1))<=(double)circles[i][2]){\\n                        se.insert({x1,y1});\\n                    }\\n                }\\n            }\\n        }\\n        return se.size();\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> se;\\n        int n=circles.size();\\n        for(int i=0;i<n;i++){\\n            for(int x1=circles[i][0]-r;x1<=circles[i][0]+r;x1++){\\n                for(int y1=circles[i][1]-r;y1<=circles[i][1]+r;y1++){\\n                    if(se.count({x1,y1}",
                "codeTag": "Java"
            },
            {
                "id": 1977036,
                "title": "why-search-in-2r-2r-square-why-not-2r-2-sqrt-r-r-x-x",
                "content": "When `r = 100` and `dx = -100`, are you still going to search `dy` from `-100` to `100`??\\nNearly all of solutions are doing\\n```\\nfor (int dx = -r; dx <= r; dx++)\\n\\tfor (int dy = -r; dy <= r; dy++) if (dx*dx+dy*dy <= r)\\n\\t{ ... }\\n```\\nWhy not\\n```\\nfor (int dx = -r; dx <= r; dx++)\\n{\\n\\tint mxdy = sqrt(r*r-dx*dx)\\n\\tfor (int dy = -mxdy; dy <= mxdy; dy++)\\n\\t{ ... }\\n}\\n```\\nFor a specific `dx`, since `dx*dx+dy*dy <= r*r`, then `dy*dy <= r*r-dx*dx`. So we just need to search `dy` from `-sqrt(r*r-dx*dx)` to `sqrt(r*r-dx*dx)`",
                "solutionTags": [],
                "code": "```\\nfor (int dx = -r; dx <= r; dx++)\\n\\tfor (int dy = -r; dy <= r; dy++) if (dx*dx+dy*dy <= r)\\n\\t{ ... }\\n```\n```\\nfor (int dx = -r; dx <= r; dx++)\\n{\\n\\tint mxdy = sqrt(r*r-dx*dx)\\n\\tfor (int dy = -mxdy; dy <= mxdy; dy++)\\n\\t{ ... }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976883,
                "title": "simple-brute-force-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        \\n        int n=circles.size(),count=0;\\n        for(int i=0;i<=200;i++)\\n        {\\n            for(int j=0;j<=200;j++)\\n            {\\n                for(int p=0;p<n;p++)\\n                {\\n                    int x=circles[p][0];\\n                    int y=circles[p][1];\\n                    int r=circles[p][2];\\n                    \\n                    if(((x-i)*(x-i)+(y-j)*(y-j))<=r*r) \\n                    {\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n        \\n       \\n    }\\n};\\nGuys,plz upvote,if found helpful",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        \\n        int n=circles.size(),count=0;\\n        for(int i=0;i<=200;i++)\\n        {\\n            for(int j=0;j<=200;j++)\\n            {\\n                for(int p=0;p<n;p++)\\n                {\\n                    int x=circles[p][0];\\n                    int y=circles[p][1];\\n                    int r=circles[p][2];\\n                    \\n                    if(((x-i)*(x-i)+(y-j)*(y-j))<=r*r) \\n                    {\\n                        count++;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1986669,
                "title": "easy-cpp-solution-store-all-points-in-set",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>st;\\n        for(int i=0;i<circles.size();i++){\\n            int x=circles[i][0];\\n            int y=circles[i][1];\\n            int r=circles[i][2];\\n            int xl=x-r;\\n            int xr=x+r;\\n            int yl=y-r;\\n            int yr=y+r;\\n            for(int j=xl;j<=xr;j++){\\n                for(int k=yl;k<=yr;k++){\\n                    if(((j-x)*(j-x)+(k-y)*(k-y))<=(r*r))\\n                    st.insert({j,k});\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>st;\\n        for(int i=0;i<circles.size();i++){\\n            int x=circles[i][0];\\n            int y=circles[i][1];\\n            int r=circles[i][2];\\n            int xl=x-r;\\n            int xr=x+r;\\n            int yl=y-r;\\n            int yr=y+r;\\n            for(int j=xl;j<=xr;j++){\\n                for(int k=yl;k<=yr;k++){\\n                    if(((j-x)*(j-x)+(k-y)*(k-y))<=(r*r))\\n                    st.insert({j,k}",
                "codeTag": "Java"
            },
            {
                "id": 1977054,
                "title": "c-brute-force-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& nums) {\\n       set<pair<int,int>> s;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int x=nums[i][0];\\n            int y=nums[i][1];\\n            int r=nums[i][2];\\n            for(int xp=x-r;xp<=x+r;xp++)\\n            {\\n                for(int yp=y-r;yp<=y+r;yp++){\\n                // cout<<xp<<\" \"<<yp<<endl;\\n                   if( sqrt((x-xp)*(x-xp)+(y-yp)*(y-yp))<=r)\\n                        s.insert({xp,yp}); \\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& nums) {\\n       set<pair<int,int>> s;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int x=nums[i][0];\\n            int y=nums[i][1];\\n            int r=nums[i][2];\\n            for(int xp=x-r;xp<=x+r;xp++)\\n            {\\n                for(int yp=y-r;yp<=y+r;yp++){\\n                // cout<<xp<<\" \"<<yp<<endl;\\n                   if( sqrt((x-xp)*(x-xp)+(y-yp)*(y-yp))<=r)\\n                        s.insert({xp,yp}); \\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1976828,
                "title": "python-set-solution-easy",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        \\n        res = set()\\n        \\n        def point(x, y, r):\\n            nonlocal res\\n            \\n            for a in range(x-r, x+r+1):\\n                for b in range(y-r, y+r+1):\\n                    if (a-x)*(a-x) + (b-y)*(b-y) <= r*r:\\n                        res.add((a,b))\\n\\n            return res\\n            \\n        for x in circles:\\n            \\n            point(x[0],x[1],x[2])\\n            \\n        return len(res)\\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        \\n        res = set()\\n        \\n        def point(x, y, r):\\n            nonlocal res\\n            \\n            for a in range(x-r, x+r+1):\\n                for b in range(y-r, y+r+1):\\n                    if (a-x)*(a-x) + (b-y)*(b-y) <= r*r:\\n                        res.add((a,b))\\n\\n            return res\\n            \\n        for x in circles:\\n            \\n            point(x[0],x[1],x[2])\\n            \\n        return len(res)\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2034508,
                "title": "count-lattice-points-inside-a-circle-c",
                "content": "```\\n# Points lie from i=(x-r to x+r) to j=(y-r to y+r)\\n# Any point that lies in the circle should follow the equation (i-x)^2+(j-y)^2<=r^2\\n# [x=2,y=2,r=1]\\n# (i : x should lie from (1,3))\\n# (j : y should lie from (1,3))\\n# ((i-x)^2+(j-y)^2<=r^2)=>add in set\\n```\\n```\\nclass Solution \\n{\\n  public:\\n    int countLatticePoints(vector<vector<int>>& circles) \\n    {\\n        set<pair<int,int>>st;\\n        for(auto circle:circles)\\n        {\\n            int x=circle[0];\\n            int y=circle[1];\\n            int r=circle[2];\\n            for(int i=x-r;i<=r+x;i++)\\n            {\\n                for(int j=y-r;j<=r+y;j++)\\n                {\\n                    if((i-x)*(i-x)+(j-y)*(j-y)<=r*r)\\n                        st.insert({i,j});\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\n# Points lie from i=(x-r to x+r) to j=(y-r to y+r)\\n# Any point that lies in the circle should follow the equation (i-x)^2+(j-y)^2<=r^2\\n# [x=2,y=2,r=1]\\n# (i : x should lie from (1,3))\\n# (j : y should lie from (1,3))\\n# ((i-x)^2+(j-y)^2<=r^2)=>add in set\\n```\n```\\nclass Solution \\n{\\n  public:\\n    int countLatticePoints(vector<vector<int>>& circles) \\n    {\\n        set<pair<int,int>>st;\\n        for(auto circle:circles)\\n        {\\n            int x=circle[0];\\n            int y=circle[1];\\n            int r=circle[2];\\n            for(int i=x-r;i<=r+x;i++)\\n            {\\n                for(int j=y-r;j<=r+y;j++)\\n                {\\n                    if((i-x)*(i-x)+(j-y)*(j-y)<=r*r)\\n                        st.insert({i,j});\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001127,
                "title": "c-solution-with-set",
                "content": "\\n   \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>s;\\n        int n = circles.size();\\n        for(int i=0;i<n;i++){\\n            int a = circles[i][0],b = circles[i][1],c = circles[i][2];\\n            for(int j=c-a;j<=c+a;j++){\\n                for(int k=c-b;k<=c+b;k++){\\n                   if((j-a)*(j-a) + (k-b)*(k-b) <= c*c){\\n                       s.insert({j,k});\\n                   }\\n                }\\n            }\\n        }\\n        return s.size();\\n\\t}",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "\\n   \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>s;\\n        int n = circles.size();\\n        for(int i=0;i<n;i++){\\n            int a = circles[i][0],b = circles[i][1],c = circles[i][2];\\n            for(int j=c-a;j<=c+a;j++){\\n                for(int k=c-b;k<=c+b;k++){\\n                   if((j-a)*(j-a) + (k-b)*(k-b) <= c*c){\\n                       s.insert({j,k});\\n                   }\\n                }\\n            }\\n        }\\n        return s.size();\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1978460,
                "title": "easiest-c-brute-force-approach",
                "content": "Check for all the points inside the circle\\n```\\nint countLatticePoints(vector<vector<int>>& c) {\\n        set <pair<int,int>> st;\\n        int n = c.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=c[i][0],y=c[i][1],r=c[i][2];\\n            for(int x1=-r;x1<=r;x1++)\\n            {\\n                for(int y1=-r;y1<=r;y1++)\\n                {\\n                    if(((x1*x1)+(y1*y1))<=(r*r))\\n                    {\\n                        st.insert({x+x1,y+y1});\\n                    }\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint countLatticePoints(vector<vector<int>>& c) {\\n        set <pair<int,int>> st;\\n        int n = c.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=c[i][0],y=c[i][1],r=c[i][2];\\n            for(int x1=-r;x1<=r;x1++)\\n            {\\n                for(int y1=-r;y1<=r;y1++)\\n                {\\n                    if(((x1*x1)+(y1*y1))<=(r*r))\\n                    {\\n                        st.insert({x+x1,y+y1});\\n                    }\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976953,
                "title": "using-the-right-data-structure-is-important",
                "content": "I initially used a vector in set to store the output instead of pair. That gave me TLE the whole time and I was not able to submit the code on time.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) \\n    {\\n        set<vector<int>> s;\\n        sort(circles.begin(),circles.end());\\n        for(int i=circles.size()-1;i>=0;i--)\\n        {\\n            int xc=circles[i][0];\\n            int yc=circles[i][1];\\n            int rad=circles[i][2];\\n            \\n            for(int x=xc-rad;x<=xc+rad;x++)\\n            {\\n                for(int y=yc-rad;y<=yc+rad;y++)\\n                {\\n                    int equation= pow(x-xc,2)+pow(y-yc,2)-rad*rad;\\n                    if(equation<=0)\\n                    {\\n                        vector<int> temp{x,y};\\n                        s.insert(temp);\\n                        \\n                    }\\n                }\\n            }\\n            \\n            \\n        }\\n        return s.size();\\n        \\n    }\\n};\\n```\\n\\n\\nThen, after the contest I used pair, and it submits perfectly fine. Important lesson learnt today.\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) \\n    {\\n        set<pair<int,int>> s;\\n        sort(circles.begin(),circles.end());\\n        for(int i=circles.size()-1;i>=0;i--)\\n        {\\n            int xc=circles[i][0];\\n            int yc=circles[i][1];\\n            int rad=circles[i][2];\\n            \\n            for(int x=xc-rad;x<=xc+rad;x++)\\n            {\\n                for(int y=yc-rad;y<=yc+rad;y++)\\n                {\\n                    int equation= pow(x-xc,2)+pow(y-yc,2)-rad*rad;\\n                    if(equation<=0)\\n                    {\\n                        s.insert({x,y});\\n                        \\n                    }\\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        return s.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) \\n    {\\n        set<vector<int>> s;\\n        sort(circles.begin(),circles.end());\\n        for(int i=circles.size()-1;i>=0;i--)\\n        {\\n            int xc=circles[i][0];\\n            int yc=circles[i][1];\\n            int rad=circles[i][2];\\n            \\n            for(int x=xc-rad;x<=xc+rad;x++)\\n            {\\n                for(int y=yc-rad;y<=yc+rad;y++)\\n                {\\n                    int equation= pow(x-xc,2)+pow(y-yc,2)-rad*rad;\\n                    if(equation<=0)\\n                    {\\n                        vector<int> temp{x,y};\\n                        s.insert(temp);\\n                        \\n                    }\\n                }\\n            }\\n            \\n            \\n        }\\n        return s.size();\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) \\n    {\\n        set<pair<int,int>> s;\\n        sort(circles.begin(),circles.end());\\n        for(int i=circles.size()-1;i>=0;i--)\\n        {\\n            int xc=circles[i][0];\\n            int yc=circles[i][1];\\n            int rad=circles[i][2];\\n            \\n            for(int x=xc-rad;x<=xc+rad;x++)\\n            {\\n                for(int y=yc-rad;y<=yc+rad;y++)\\n                {\\n                    int equation= pow(x-xc,2)+pow(y-yc,2)-rad*rad;\\n                    if(equation<=0)\\n                    {\\n                        s.insert({x,y});\\n                        \\n                    }\\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        return s.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976908,
                "title": "c-set-brute-force-compute-all-possible-points",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void help(set<pair<int,int>> &st,vector<int> &arr){\\n        for(int i=arr[0]-arr[2];i<=arr[0]+arr[2];i++){\\n            for(int j=arr[1]-arr[2];j<=arr[1]+arr[2];j++){\\n                int dis = ((i-arr[0])*(i-arr[0]))+((j-arr[1])*(j-arr[1]));\\n                if(dis<=(arr[2]*arr[2])){\\n                    st.insert({i,j});\\n                }\\n            }\\n        }\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& nums) {\\n        set<pair<int,int>> st;\\n        for(int i=0;i<nums.size();i++){\\n            help(st,nums[i]);\\n        }\\n        // for(auto it : st){\\n        //     cout<<it.first<<\" \"<<it.second<<\"\\\\n\";\\n        // }\\n        // cout<<\"\\\\n\";\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void help(set<pair<int,int>> &st,vector<int> &arr){\\n        for(int i=arr[0]-arr[2];i<=arr[0]+arr[2];i++){\\n            for(int j=arr[1]-arr[2];j<=arr[1]+arr[2];j++){\\n                int dis = ((i-arr[0])*(i-arr[0]))+((j-arr[1])*(j-arr[1]));\\n                if(dis<=(arr[2]*arr[2])){\\n                    st.insert({i,j});\\n                }\\n            }\\n        }\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& nums) {\\n        set<pair<int,int>> st;\\n        for(int i=0;i<nums.size();i++){\\n            help(st,nums[i]);\\n        }\\n        // for(auto it : st){\\n        //     cout<<it.first<<\" \"<<it.second<<\"\\\\n\";\\n        // }\\n        // cout<<\"\\\\n\";\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1976871,
                "title": "whats-wrong-in-this-code",
                "content": "```\\n// class Solution {\\n// public:\\n//     int countLatticePoints(vector<vector<int>>& circles) {\\n//         map<pair<int,int>,int> s;\\n//         int n=circles.size();\\n//         for(int i=0;i<n;i++){\\n//             int x=circles[i][0];\\n//             int y=circles[i][1];\\n//             int r=circles[i][2];\\n//             int q=y+r;\\n//             for(int p=x;p<=x+r;p++){\\n//                 int u=q;\\n//                 while(u>=y){\\n//                     //cout<<p<<\" \"<<u<<endl;\\n//                     s[{p,u}]=1;\\n//                     u--;\\n//                 }\\n//                 q--;\\n//             }\\n//             q=y-r;\\n//             for(int p=x;p<=x+r;p++){\\n//                 int v=q;\\n//                 while(v<=y){\\n//                     //cout<<p<<\" \"<<v<<endl;\\n//                      s[{p,v}]=1;\\n//                     v++;\\n//                 }\\n//                 q++;\\n//             }\\n//             q=y+r;\\n//             for(int p=x;p>=(x-r);p--){\\n//                 int w=q;\\n//                 while(w>=y){\\n//                     //cout<<p<<\" \"<<w<<endl;\\n//                      s[{p,w}]=1;\\n//                     w--;\\n//                 }\\n//                 q--;\\n//             }\\n//             q=y-r;\\n//             for(int p=x;p>=(x-r);p--){\\n//                 int z=q;\\n//                 while(z<=y){\\n//                     //ut<<p<<\" \"<<z<<endl;\\n//                      s[{p,z}]=1;\\n//                     z++;\\n//                 }\\n//                 q++;\\n//             }\\n            \\n//         }\\n//         return s.size();\\n//     }\\n// };\\n```",
                "solutionTags": [],
                "code": "```\\n// class Solution {\\n// public:\\n//     int countLatticePoints(vector<vector<int>>& circles) {\\n//         map<pair<int,int>,int> s;\\n//         int n=circles.size();\\n//         for(int i=0;i<n;i++){\\n//             int x=circles[i][0];\\n//             int y=circles[i][1];\\n//             int r=circles[i][2];\\n//             int q=y+r;\\n//             for(int p=x;p<=x+r;p++){\\n//                 int u=q;\\n//                 while(u>=y){\\n//                     //cout<<p<<\" \"<<u<<endl;\\n//                     s[{p,u}]=1;\\n//                     u--;\\n//                 }\\n//                 q--;\\n//             }\\n//             q=y-r;\\n//             for(int p=x;p<=x+r;p++){\\n//                 int v=q;\\n//                 while(v<=y){\\n//                     //cout<<p<<\" \"<<v<<endl;\\n//                      s[{p,v}]=1;\\n//                     v++;\\n//                 }\\n//                 q++;\\n//             }\\n//             q=y+r;\\n//             for(int p=x;p>=(x-r);p--){\\n//                 int w=q;\\n//                 while(w>=y){\\n//                     //cout<<p<<\" \"<<w<<endl;\\n//                      s[{p,w}]=1;\\n//                     w--;\\n//                 }\\n//                 q--;\\n//             }\\n//             q=y-r;\\n//             for(int p=x;p>=(x-r);p--){\\n//                 int z=q;\\n//                 while(z<=y){\\n//                     //ut<<p<<\" \"<<z<<endl;\\n//                      s[{p,z}]=1;\\n//                     z++;\\n//                 }\\n//                 q++;\\n//             }\\n            \\n//         }\\n//         return s.size();\\n//     }\\n// };\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3377736,
                "title": "worst-memory-solution-recursion-approach-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI guess you already know the question , its quite understandable .\\nI don\\'t know why i am obsessed with recursion , the first approach came to my mind after seeing most question is if i can somehow use memoization. So here is result of that.\\n# This solution uses 56.2MB of space \\nDon\\'t ask me how just see the solution you will get why.\\n![image.png](https://assets.leetcode.com/users/images/52b50289-814f-4e2c-a5bc-9ca839224059_1680589074.305046.png)\\n\\nIt\\'s okay with run time i guess beats 55%.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We start from the center and move in all four directions\\n2. If we already visited the point for current circle , we return 0\\n3. If we have already encountered the point in any other circle , we don\\'t count it\\n4. and if point is out of circle , we return 0\\n\\nPlease Suggest any methods to optimise the code.\\nThanks\\n# Code\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        circle=[]\\n        for i in circles:\\n            if i not in circle:\\n                circle.append(i)\\n        dic={}\\n        visited={}\\n        def fun(i,x,y):\\n            if (x,y) in visited:\\n                return 0\\n            if (i[0]-x)**2+(i[1]-y)**2<=i[2]**2 and (x,y) not in dic:\\n                dic[x,y]=1\\n                visited[x,y]=1\\n                return 1+fun(i,x+1,y)+fun(i,x-1,y)+fun(i,x,y+1)+fun(i,x,y-1)\\n            if (i[0]-x)**2+(i[1]-y)**2<=i[2]**2 and (x,y) not in visited:\\n                visited[x,y]=1\\n                return fun(i,x+1,y)+fun(i,x-1,y)+fun(i,x,y+1)+fun(i,x,y-1)\\n            return 0\\n        ans=0\\n        for i in (circle):\\n            ans+=fun(i,i[0],i[1])\\n            visited={}\\n        return ans\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        circle=[]\\n        for i in circles:\\n            if i not in circle:\\n                circle.append(i)\\n        dic={}\\n        visited={}\\n        def fun(i,x,y):\\n            if (x,y) in visited:\\n                return 0\\n            if (i[0]-x)**2+(i[1]-y)**2<=i[2]**2 and (x,y) not in dic:\\n                dic[x,y]=1\\n                visited[x,y]=1\\n                return 1+fun(i,x+1,y)+fun(i,x-1,y)+fun(i,x,y+1)+fun(i,x,y-1)\\n            if (i[0]-x)**2+(i[1]-y)**2<=i[2]**2 and (x,y) not in visited:\\n                visited[x,y]=1\\n                return fun(i,x+1,y)+fun(i,x-1,y)+fun(i,x,y+1)+fun(i,x,y-1)\\n            return 0\\n        ans=0\\n        for i in (circle):\\n            ans+=fun(i,i[0],i[1])\\n            visited={}\\n        return ans\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700250,
                "title": "python-simple-solution-distance-calculation",
                "content": "\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        res=[]\\n        for cirlcle in circles:\\n            x=cirlcle[0]\\n            y= cirlcle[1]\\n            rad = cirlcle[2]\\n            for x1 in range(x-rad,x+rad+1):\\n                for y1 in range(y-rad,y+rad+1):\\n                    if((x-x1)*(x-x1)+(y-y1)*(y-y1))<=rad*rad:\\n                            res.append((x1,y1))\\n        mylist=list(set(res))\\n        return len(mylist)\\n    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        res=[]\\n        for cirlcle in circles:\\n            x=cirlcle[0]\\n            y= cirlcle[1]\\n            rad = cirlcle[2]\\n            for x1 in range(x-rad,x+rad+1):\\n                for y1 in range(y-rad,y+rad+1):\\n                    if((x-x1)*(x-x1)+(y-y1)*(y-y1))<=rad*rad:\\n                            res.append((x1,y1))\\n        mylist=list(set(res))\\n        return len(mylist)\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342533,
                "title": "fastest-python-solution-100-100ms",
                "content": "```\\nclass Solution:\\n    def countLatticePoints(self, c: List[List[int]]) -> int:\\n        ans,m=0,[0]*40401\\n        c=set(((x,y,r) for x,y,r in c))\\n        for x, y, r in c:\\n            for i in range(x-r, x+r+1):\\n                d=int(sqrt(r*r-(x-i)*(x-i)))\\n                m[i*201+y-d:i*201+y+d+1]=[1]*(d+d+1)\\n        return sum(m)\\n```\\n![image](https://assets.leetcode.com/users/images/ce8aed83-6815-4777-aa6c-d430cc4e5877_1658949289.3704836.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, c: List[List[int]]) -> int:\\n        ans,m=0,[0]*40401\\n        c=set(((x,y,r) for x,y,r in c))\\n        for x, y, r in c:\\n            for i in range(x-r, x+r+1):\\n                d=int(sqrt(r*r-(x-i)*(x-i)))\\n                m[i*201+y-d:i*201+y+d+1]=[1]*(d+d+1)\\n        return sum(m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114598,
                "title": "c-convert-into-matrix-and-use-set-for-duplicate-points-easy",
                "content": "# \\tCONVERT INTO MATRIX THEN CALCULATE ONLY DISTANCE FROM CENTER\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\n\\t\\t\\tint countLatticePoints(vector<vector<int>>& circles) {\\n\\t\\t\\t\\tset<pair<int,int>> s;\\n\\t\\t\\t\\tfor(int k=0; k<circles.size(); k++){\\n\\t\\t\\t\\t\\tint x = circles[k][0];\\n\\t\\t\\t\\t\\tint y = circles[k][1];\\n\\t\\t\\t\\t\\tint r = circles[k][2];\\n\\n\\t\\t\\t\\t\\tfor(int i=x-r; i<=x+r; i++){\\n\\t\\t\\t\\t\\t\\tfor(int j=y-r; j<=y+r; j++){\\n\\t\\t\\t\\t\\t\\t\\tif((i-x)*(i-x) + (j-y)*(j-y) <= r*r){\\n\\t\\t\\t\\t\\t\\t\\t\\ts.insert({i,j});\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn s.size();\\n\\n\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\n\\t\\t\\tint countLatticePoints(vector<vector<int>>& circles) {\\n\\t\\t\\t\\tset<pair<int,int>> s;\\n\\t\\t\\t\\tfor(int k=0; k<circles.size(); k++){\\n\\t\\t\\t\\t\\tint x = circles[k][0];\\n\\t\\t\\t\\t\\tint y = circles[k][1];\\n\\t\\t\\t\\t\\tint r = circles[k][2];\\n\\n\\t\\t\\t\\t\\tfor(int i=x-r; i<=x+r; i++){\\n\\t\\t\\t\\t\\t\\tfor(int j=y-r; j<=y+r; j++){\\n\\t\\t\\t\\t\\t\\t\\tif((i-x)*(i-x) + (j-y)*(j-y) <= r*r){\\n\\t\\t\\t\\t\\t\\t\\t\\ts.insert({i,j}",
                "codeTag": "Java"
            },
            {
                "id": 2071611,
                "title": "java-easiest-solution-for-newbies-beats-40-percent",
                "content": "```\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        \\n        Set<String> hashSet = new HashSet<>();\\n        \\n        for(int i=0; i<=circles.length-1;i++){\\n            int xCenter = circles[i][0];\\n            int yCenter = circles[i][1];\\n            int r  = circles[i][2];\\n            \\n            for(int x=xCenter-r; x<=xCenter+r; x++){\\n                for(int y=yCenter-r; y<=yCenter+r; y++){\\n                    if(isPointInsideCircle(x, y, xCenter, yCenter, r)){\\n                        hashSet.add(x+\",\"+y);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return hashSet.size();\\n        \\n    }\\n    \\n    public boolean isPointInsideCircle(int x, int y, int xc, int yc, int r){\\n        int distance = (x - xc) * (x - xc) + (y - yc) * (y - yc);\\n        return distance <= r * r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        \\n        Set<String> hashSet = new HashSet<>();\\n        \\n        for(int i=0; i<=circles.length-1;i++){\\n            int xCenter = circles[i][0];\\n            int yCenter = circles[i][1];\\n            int r  = circles[i][2];\\n            \\n            for(int x=xCenter-r; x<=xCenter+r; x++){\\n                for(int y=yCenter-r; y<=yCenter+r; y++){\\n                    if(isPointInsideCircle(x, y, xCenter, yCenter, r)){\\n                        hashSet.add(x+\",\"+y);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return hashSet.size();\\n        \\n    }\\n    \\n    public boolean isPointInsideCircle(int x, int y, int xc, int yc, int r){\\n        int distance = (x - xc) * (x - xc) + (y - yc) * (y - yc);\\n        return distance <= r * r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053545,
                "title": "a-simple-and-intuitive-java-solution-using-the-distance-formula",
                "content": "The idea is to iterate over all the points that lie within and on the smallest square containing a given circle.\\n\\n```\\nLet [x] and [y] be the x and y coordinates of the center of a circle and [r] be its radius.\\nThen the smallest square capable of containing the whole circle will have the following coordinates.\\n\\n(x - r, y + r)      (x + r, y + r)\\n      +-------------------+\\n\\t  |         |         |\\n\\t  |         |         |\\n\\t  |---------O---------|\\n\\t  |         |         |\\n\\t  |         |         |\\n      +-------------------+\\n(x - r, y - r)  (x + r, y - r)\\n\\nHere, [O] is the center of the circle.\\n```\\n\\nJava Solution\\n```java\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        Set<String> answer = new HashSet<String>();\\n        \\n        for (int[] c : circles) {\\n            int x = c[0], y = c[1], r = c[2];\\n            \\n            // traversing over all the points that lie inside the smallest square capable of containing the whole circle\\n            for (int xx = x - r; xx <= x + r; xx++)\\n                for (int yy = y - r; yy <= y + r; yy++)\\n                    if ((r * r) >= ((x - xx) * (x - xx)) + ((y - yy) * (y - yy)))\\n                        answer.add(xx + \":\" + yy);\\n        }\\n        \\n        return answer.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nLet [x] and [y] be the x and y coordinates of the center of a circle and [r] be its radius.\\nThen the smallest square capable of containing the whole circle will have the following coordinates.\\n\\n(x - r, y + r)      (x + r, y + r)\\n      +-------------------+\\n\\t  |         |         |\\n\\t  |         |         |\\n\\t  |---------O---------|\\n\\t  |         |         |\\n\\t  |         |         |\\n      +-------------------+\\n(x - r, y - r)  (x + r, y - r)\\n\\nHere, [O] is the center of the circle.\\n```\n```java\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        Set<String> answer = new HashSet<String>();\\n        \\n        for (int[] c : circles) {\\n            int x = c[0], y = c[1], r = c[2];\\n            \\n            // traversing over all the points that lie inside the smallest square capable of containing the whole circle\\n            for (int xx = x - r; xx <= x + r; xx++)\\n                for (int yy = y - r; yy <= y + r; yy++)\\n                    if ((r * r) >= ((x - xx) * (x - xx)) + ((y - yy) * (y - yy)))\\n                        answer.add(xx + \":\" + yy);\\n        }\\n        \\n        return answer.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051452,
                "title": "javascript-smallest-rectangle-that-all-circles-cover-without-set-200-points",
                "content": "> If you\\'re finding something special, never miss this!\\n\\nMy solution uses neither set nor 200-points. \\n\\nInstead, I find the `minX/maxX`&`minY/maxY` first. These 4 points determine the **MINIMUM AREA that all circles may cover**.\\nWe just have to count lattice points **within that rectangle**!\\n\\nThis method saves both time and space :)\\n```\\nvar countLatticePoints = function(circles) {\\n    let minX=minY=Infinity, maxX=maxY=-Infinity;\\n    for(let i=0; i<circles.length; i++){\\n        minX=Math.min(minX, circles[i][0]-circles[i][2]); maxX=Math.max(maxX, circles[i][0]+circles[i][2]);\\n        minY=Math.min(minY, circles[i][1]-circles[i][2]); maxY=Math.max(maxY, circles[i][1]+circles[i][2]);\\n    }\\n\\t\\n    let count=0;\\n    for(let i=minX; i<=maxX; i++){\\n        for(let j=minY; j<=maxY; j++){\\n            let find=false;\\n            for(let k=0; k<circles.length; k++){\\n                if(((i-circles[k][0])**2+(j-circles[k][1])**2)<=circles[k][2]**2){\\n                    find=true; break;\\n                }\\n            }\\n            if(find){count++};\\n        }\\n    }\\n    return count;\\n};\\n```\\n\\nThanks for your reading and **up-voting** :)\\n\\n**\\u2B50 Check [HERE](https://github.com/Lynn19950915/LeetCode_King) for my full Leetcode Notes ~**\\n",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nvar countLatticePoints = function(circles) {\\n    let minX=minY=Infinity, maxX=maxY=-Infinity;\\n    for(let i=0; i<circles.length; i++){\\n        minX=Math.min(minX, circles[i][0]-circles[i][2]); maxX=Math.max(maxX, circles[i][0]+circles[i][2]);\\n        minY=Math.min(minY, circles[i][1]-circles[i][2]); maxY=Math.max(maxY, circles[i][1]+circles[i][2]);\\n    }\\n\\t\\n    let count=0;\\n    for(let i=minX; i<=maxX; i++){\\n        for(let j=minY; j<=maxY; j++){\\n            let find=false;\\n            for(let k=0; k<circles.length; k++){\\n                if(((i-circles[k][0])**2+(j-circles[k][1])**2)<=circles[k][2]**2){\\n                    find=true; break;\\n                }\\n            }\\n            if(find){count++};\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2015989,
                "title": "python-simple-maths",
                "content": "\\n    def valid_points(self, circles):\\n        ans, radius = set(), circles[2]\\n    \\n        for r1 in range(-radius,radius+1):\\n            for r2 in range(-radius,radius+1):\\n                x, y = circles[0] + r1, circles[1] + r2\\n                if (x - circles[0])**2 + (y - circles[1])**2 <= radius**2:\\n                    ans.add((x,y))\\n                        \\n        return ans\\n        \\n    def countLatticePoints(self, circles):\\n        arr, circles = [], list(set([tuple(i) for i in circles]))\\n        \\n        for i in circles:\\n            arr += self.valid_points(i)\\n            \\n        return len(set(arr))",
                "solutionTags": [],
                "code": "\\n    def valid_points(self, circles):\\n        ans, radius = set(), circles[2]\\n    \\n        for r1 in range(-radius,radius+1):\\n            for r2 in range(-radius,radius+1):\\n                x, y = circles[0] + r1, circles[1] + r2\\n                if (x - circles[0])**2 + (y - circles[1])**2 <= radius**2:\\n                    ans.add((x,y))\\n                        \\n        return ans\\n        \\n    def countLatticePoints(self, circles):\\n        arr, circles = [], list(set([tuple(i) for i in circles]))\\n        \\n        for i in circles:\\n            arr += self.valid_points(i)\\n            \\n        return len(set(arr))",
                "codeTag": "Python3"
            },
            {
                "id": 2004579,
                "title": "cpp-code-using-circle-properties-explained-and-hashset",
                "content": "Given the center of the circle as (a,b) and it\\'s radius as r , the equation of the circle can be written as \\n(x-a)^2 + (y-b)^2 = r^2\\nNow if another point say (x1,y1) \\n1) Is on the circumfrence of the circle then it must satisfy :\\n\\t (x1-r)^2 + (x2-r)^2 = r^2\\n2) Is inside the circumfrence of the circle then it must satisfy :\\n\\t (x1-r)^2 + (x2-r)^2 < r^2 \\n3) Is outside the circumfrence of the circle then it must satisfy :\\n\\t (x1-r)^2 + (x2-r)^2 > r^2 \\n\\nHence our answer should be the number of distinct integer points satisfying the condition 1 and 2.\\n\\nTo implement this we create a function for the equation of the circle which return true if a point lies inside or on the circumfrence of the circle. \\nThe points are stored in a hashSet to only count the distinct points in case of overlapping circles.\\n\\n```\\nclass Solution {\\npublic:\\n    bool circle(int x , int y , int c1 , int c2, int r){\\n        if((x-c1)*(x-c1) + (y-c2)*(y-c2) <= r*r) \\n            return true ;\\n        return false ;\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int n = circles.size() , ans = 0 ;\\n        set<pair<int,int>> set ;\\n        for(auto v : circles){\\n            int r = v[2] , x = v[0] , y = v[1]; \\n            for(int i = x-r ; i <= x+r ; i++)\\n                for(int j = y-r ; j <= y+r ; j++)\\n                    if(circle(i,j,x,y,r)){\\n                        pair<int,int> p(i,j) ;\\n                        set.insert(p) ;\\n                    }\\n        }\\n        return set.size() ;\\n    }\\n};\\n```\\n\\n*Keep solving !!*",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool circle(int x , int y , int c1 , int c2, int r){\\n        if((x-c1)*(x-c1) + (y-c2)*(y-c2) <= r*r) \\n            return true ;\\n        return false ;\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int n = circles.size() , ans = 0 ;\\n        set<pair<int,int>> set ;\\n        for(auto v : circles){\\n            int r = v[2] , x = v[0] , y = v[1]; \\n            for(int i = x-r ; i <= x+r ; i++)\\n                for(int j = y-r ; j <= y+r ; j++)\\n                    if(circle(i,j,x,y,r)){\\n                        pair<int,int> p(i,j) ;\\n                        set.insert(p) ;\\n                    }\\n        }\\n        return set.size() ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989485,
                "title": "c-track-used-points-w-grid",
                "content": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        \\n        vector<vector<int>> grid(401, vector<int>(401, 0));\\n        int center_r = 200;\\n        int center_c = 200;\\n        int count = 0;\\n        for(int i = 0; i < circles.size(); i++){\\n            circles[i][0] += center_r;\\n            circles[i][1] += center_c;\\n            for(int j = circles[i][0]-circles[i][2]; j <= circles[i][0]+ circles[i][2]; j++){\\n                for(int k = circles[i][1] - circles[i][2]; k <= circles[i][1]+ circles[i][2]; k++){\\n                    if(j < 0 || k < 0 || j >= grid.size() || k >= grid[0].size()) continue;\\n                    if(grid[j][k] == 1) continue;\\n                    if(inCircle(circles[i], {j, k})){\\n                        grid[j][k]++;\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\nprivate:\\n        bool inCircle(vector<int>& circle, vector<int> point){\\n            double distance = sqrt((circle[0]-point[0]) * (circle[0]-point[0]) + (circle[1]-point[1]) * (circle[1]-point[1]));\\n            if(distance <= (circle[2] + 0.00001)) return true;\\n            return false;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        \\n        vector<vector<int>> grid(401, vector<int>(401, 0));\\n        int center_r = 200;\\n        int center_c = 200;\\n        int count = 0;\\n        for(int i = 0; i < circles.size(); i++){\\n            circles[i][0] += center_r;\\n            circles[i][1] += center_c;\\n            for(int j = circles[i][0]-circles[i][2]; j <= circles[i][0]+ circles[i][2]; j++){\\n                for(int k = circles[i][1] - circles[i][2]; k <= circles[i][1]+ circles[i][2]; k++){\\n                    if(j < 0 || k < 0 || j >= grid.size() || k >= grid[0].size()) continue;\\n                    if(grid[j][k] == 1) continue;\\n                    if(inCircle(circles[i], {j, k})){\\n                        grid[j][k]++;\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\nprivate:\\n        bool inCircle(vector<int>& circle, vector<int> point){\\n            double distance = sqrt((circle[0]-point[0]) * (circle[0]-point[0]) + (circle[1]-point[1]) * (circle[1]-point[1]));\\n            if(distance <= (circle[2] + 0.00001)) return true;\\n            return false;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1983850,
                "title": "simple-c-solution-100-better",
                "content": "Solution: \\n\\nTime Complexity : O(N^3)\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint countLatticePoints(vector<vector<int>>& circles) {\\n\\t\\t\\t\\tint res = 0;\\n\\t\\t\\t\\tset<pair<int,int>> points;\\n\\t\\t\\t\\tfor(auto circle : circles){\\n\\t\\t\\t\\t\\tint x = circle[0],y = circle[1],r = circle[2];\\n\\t\\t\\t\\t\\tint ly = y-r,hy = y+r;\\n\\t\\t\\t\\t\\tfor(int i = ly; i <= hy ; i++){\\n\\t\\t\\t\\t\\t\\tdouble d = sqrt(-y*y+2*i*y+r*r-i*i);\\n\\t\\t\\t\\t\\t\\tint lx = ceil(x-d);\\n\\t\\t\\t\\t\\t\\tint hx = floor(x+d);\\n\\t\\t\\t\\t\\t\\t// cout<<i<<\" \"<<lx<<\" \"<<hx<<\\'\\\\n\\';\\n\\t\\t\\t\\t\\t\\tfor(int j = lx ; j <= hx ; j++){\\n\\t\\t\\t\\t\\t\\t\\tpoints.insert({i,j});\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn points.size();\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint countLatticePoints(vector<vector<int>>& circles) {\\n\\t\\t\\t\\tint res = 0;\\n\\t\\t\\t\\tset<pair<int,int>> points;\\n\\t\\t\\t\\tfor(auto circle : circles){\\n\\t\\t\\t\\t\\tint x = circle[0],y = circle[1],r = circle[2];\\n\\t\\t\\t\\t\\tint ly = y-r,hy = y+r;\\n\\t\\t\\t\\t\\tfor(int i = ly; i <= hy ; i++){\\n\\t\\t\\t\\t\\t\\tdouble d = sqrt(-y*y+2*i*y+r*r-i*i);\\n\\t\\t\\t\\t\\t\\tint lx = ceil(x-d);\\n\\t\\t\\t\\t\\t\\tint hx = floor(x+d);\\n\\t\\t\\t\\t\\t\\t// cout<<i<<\" \"<<lx<<\" \"<<hx<<\\'\\\\n\\';\\n\\t\\t\\t\\t\\t\\tfor(int j = lx ; j <= hx ; j++){\\n\\t\\t\\t\\t\\t\\t\\tpoints.insert({i,j}",
                "codeTag": "C++"
            },
            {
                "id": 1983694,
                "title": "8-lines-of-code-easy-cpp-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& C) {\\n      set<pair<int,int>> S;\\n        for(int i=0;i<C.size();i++){\\n            int a=C[i][0],b=C[i][1],x=C[i][2],l=a-x,d=b-x;\\n            for(int j=l;j<=x+a;j++)\\n            for(int k=d;k<=x+b;k++)\\n                if(pow(a-j,2)+pow(b-k,2)<=x*x) \\n                S.insert({j,k}); \\n        }\\n        return S.size();  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& C) {\\n      set<pair<int,int>> S;\\n        for(int i=0;i<C.size();i++){\\n            int a=C[i][0],b=C[i][1],x=C[i][2],l=a-x,d=b-x;\\n            for(int j=l;j<=x+a;j++)\\n            for(int k=d;k<=x+b;k++)\\n                if(pow(a-j,2)+pow(b-k,2)<=x*x) \\n                S.insert({j,k}); \\n        }\\n        return S.size();  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982893,
                "title": "simple-java-solution-50-ms-using-bounding-box",
                "content": "\\n```\\npublic int countLatticePoints(int[][] circles) {\\n       \\n        // Bounding box for overall search space\\n        // (i.e. smallest rectangle that covers all the circles)\\n        int xMin=200,xMax=-1,yMin=200,yMax=-1;\\n\\n        for(int[] c:circles){\\n            xMin = Math.min(xMin,c[0]-c[2]);\\n            xMax = Math.max(xMax,c[0]+c[2]);\\n            \\n            yMin = Math.min(yMin,c[1]-c[2]);\\n            yMax = Math.max(yMax,c[1]+c[2]);\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int x=xMin; x<=xMax; x++){\\n            for(int y=yMin; y<=yMax; y++){\\n                for(int[] c:circles){\\n                    if((c[0]-x)*(c[0]-x)+(c[1]-y)*(c[1]-y)<= c[2]*c[2]){ // Inside circle or not?\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countLatticePoints(int[][] circles) {\\n       \\n        // Bounding box for overall search space\\n        // (i.e. smallest rectangle that covers all the circles)\\n        int xMin=200,xMax=-1,yMin=200,yMax=-1;\\n\\n        for(int[] c:circles){\\n            xMin = Math.min(xMin,c[0]-c[2]);\\n            xMax = Math.max(xMax,c[0]+c[2]);\\n            \\n            yMin = Math.min(yMin,c[1]-c[2]);\\n            yMax = Math.max(yMax,c[1]+c[2]);\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int x=xMin; x<=xMax; x++){\\n            for(int y=yMin; y<=yMax; y++){\\n                for(int[] c:circles){\\n                    if((c[0]-x)*(c[0]-x)+(c[1]-y)*(c[1]-y)<= c[2]*c[2]){ // Inside circle or not?\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1982427,
                "title": "rust-using-boring-for-loops-calculate-circle-intersections-by-row-395ms-3mb",
                "content": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn count_lattice_points(circles: Vec<Vec<i32>>) -> i32 {\\n        let mut lattice_points: HashSet<(i32, i32)> = HashSet::new();\\n      \\n        //let mut exclusive_max: i32 = 0;\\n        \\n        for circle in circles.iter() {\\n          let radius: i32 = circle[2];\\n          let center: (i32, i32) = (circle[0], circle[1]);\\n          \\n          // For each integer row in the top half of the circle,\\n          // excluding the top row which will always be a single point\\n          lattice_points.insert((center.0, center.1+radius));\\n          \\n          //println!(\"circle: {:?}\", circle);\\n          //println!(\"  top point: {:?}\", (center.0, center.1+radius));\\n          \\n          // and the center row which has no \"bottom reflection\",\\n          for height_from_center in (0..radius).rev() {\\n            \\n            //top row\\n            let y1: i32 = center.1 + height_from_center;\\n            //bottom reflection\\n            let y2: i32 = center.1 - height_from_center;\\n            \\n\\n            // Calculate where the arc of the circle crosses that row:\\n            // distance ^2 = delta_x ^2 + delta_y ^2\\n            // distance here is radius (the circle arc)\\n            // delta_y is the row we\\'re on minus the radius\\n            // delta_x will likely be a non-integer value, \\n            // so we take the floor to get the x-distance from the\\n            // center to the furthest interior integer coordinate on that row\\n\\n            let x_distance: i32 = ((radius * radius - height_from_center * height_from_center) as f64).sqrt() as i32;\\n            // and this distance can be used to calculate \\n            // the inclusive boundary lattice points at either end\\n            \\n            //print!(\"    d_x: {} ... adding: \", x_distance);\\n            \\n            for x in (center.0-x_distance..=center.0+x_distance) {\\n              lattice_points.insert((x, y1));\\n              lattice_points.insert((x, y2));\\n              //print!(\" top {:?} bot {:?} \", (x, y1), (x, y2));\\n            }\\n            \\n          }\\n          //println!(\"\");\\n          //print!(\"   adding center: \");\\n          //Add the center row\\n          for center_row_x in (center.0-radius..=center.0+radius) {\\n            lattice_points.insert((center_row_x, center.1));\\n            //print!(\" {:?}\", (center_row_x, center.1));\\n          }\\n          //println!(\"\");\\n          //Add the bottom lattice point\\n          \\n          lattice_points.insert((center.0, center.1-radius));\\n          //println!(\"  adding bottom point: {:?}\", (center.0, center.1-radius));\\n          \\n          //println!(\"--circle complete: now total {} unique lattice points\", lattice_points.len());\\n      }\\n            \\n      lattice_points.len() as i32\\n          \\n  }\\n}\\n\\n/* Testcases:\\n\\n[[2,2,1]]\\n[[2,2,2],[3,4,1]]\\n[[8,9,6]]\\n[[8,9,6],[9,8,4],[4,1,1],[8,5,1],[7,1,1],[6,7,5],[7,1,1],[7,1,1],[5,5,3]]\\n[[9,8,4],[4,1,1],[8,5,1],[7,1,1],[6,7,5],[7,1,1],[7,1,1],[5,5,3]]\\n[[9,8,4]]\\n\\n*/\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn count_lattice_points(circles: Vec<Vec<i32>>) -> i32 {\\n        let mut lattice_points: HashSet<(i32, i32)> = HashSet::new();\\n      \\n        //let mut exclusive_max: i32 = 0;\\n        \\n        for circle in circles.iter() {\\n          let radius: i32 = circle[2];\\n          let center: (i32, i32) = (circle[0], circle[1]);\\n          \\n          // For each integer row in the top half of the circle,\\n          // excluding the top row which will always be a single point\\n          lattice_points.insert((center.0, center.1+radius));\\n          \\n          //println!(\"circle: {:?}\", circle);\\n          //println!(\"  top point: {:?}\", (center.0, center.1+radius));\\n          \\n          // and the center row which has no \"bottom reflection\",\\n          for height_from_center in (0..radius).rev() {\\n            \\n            //top row\\n            let y1: i32 = center.1 + height_from_center;\\n            //bottom reflection\\n            let y2: i32 = center.1 - height_from_center;\\n            \\n\\n            // Calculate where the arc of the circle crosses that row:\\n            // distance ^2 = delta_x ^2 + delta_y ^2\\n            // distance here is radius (the circle arc)\\n            // delta_y is the row we\\'re on minus the radius\\n            // delta_x will likely be a non-integer value, \\n            // so we take the floor to get the x-distance from the\\n            // center to the furthest interior integer coordinate on that row\\n\\n            let x_distance: i32 = ((radius * radius - height_from_center * height_from_center) as f64).sqrt() as i32;\\n            // and this distance can be used to calculate \\n            // the inclusive boundary lattice points at either end\\n            \\n            //print!(\"    d_x: {} ... adding: \", x_distance);\\n            \\n            for x in (center.0-x_distance..=center.0+x_distance) {\\n              lattice_points.insert((x, y1));\\n              lattice_points.insert((x, y2));\\n              //print!(\" top {:?} bot {:?} \", (x, y1), (x, y2));\\n            }\\n            \\n          }\\n          //println!(\"\");\\n          //print!(\"   adding center: \");\\n          //Add the center row\\n          for center_row_x in (center.0-radius..=center.0+radius) {\\n            lattice_points.insert((center_row_x, center.1));\\n            //print!(\" {:?}\", (center_row_x, center.1));\\n          }\\n          //println!(\"\");\\n          //Add the bottom lattice point\\n          \\n          lattice_points.insert((center.0, center.1-radius));\\n          //println!(\"  adding bottom point: {:?}\", (center.0, center.1-radius));\\n          \\n          //println!(\"--circle complete: now total {} unique lattice points\", lattice_points.len());\\n      }\\n            \\n      lattice_points.len() as i32\\n          \\n  }\\n}\\n\\n/* Testcases:\\n\\n[[2,2,1]]\\n[[2,2,2],[3,4,1]]\\n[[8,9,6]]\\n[[8,9,6],[9,8,4],[4,1,1],[8,5,1],[7,1,1],[6,7,5],[7,1,1],[7,1,1],[5,5,3]]\\n[[9,8,4],[4,1,1],[8,5,1],[7,1,1],[6,7,5],[7,1,1],[7,1,1],[5,5,3]]\\n[[9,8,4]]\\n\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1980592,
                "title": "brute-force-java-solution",
                "content": "```\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) \\n    {\\n        var count=0;\\n        for(int i=0;i<=200;i++)\\n        {\\n            for(int j=0;j<=200;j++)\\n            {\\n                boolean flag=false;\\n                for(int circle[]:circles)\\n                {\\n                    if((int)(Math.pow(i-circle[0],2)+Math.pow(j-circle[1],2))<=Math.pow(circle[2],2))\\n                    {\\n                        flag=true;\\n                        break;\\n                    }\\n                }\\n                if(flag)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int countLatticePoints(int[][] circles) \\n    {\\n        var count=0;\\n        for(int i=0;i<=200;i++)\\n        {\\n            for(int j=0;j<=200;j++)\\n            {\\n                boolean flag=false;\\n                for(int circle[]:circles)\\n                {\\n                    if((int)(Math.pow(i-circle[0],2)+Math.pow(j-circle[1],2))<=Math.pow(circle[2],2))\\n                    {\\n                        flag=true;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1980347,
                "title": "python3-interval-merging",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/c2730559a4a05cfc912d81e5d7a3d4d607079401) for solutions of weekly 290.\\n\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        intervals = [[] for _ in range(201)]\\n        for x, y, r in circles: \\n            intervals[x].append((y-r, y+r))\\n            for dx in range(1, r+1): \\n                dy = int(sqrt(r**2 - dx**2))\\n                intervals[x+dx].append((y-dy, y+dy))\\n                intervals[x-dx].append((y-dy, y+dy))\\n        \\n        ans = 0 \\n        for interval in intervals: \\n            if interval: \\n                end = -inf\\n                for i, (lo, hi) in enumerate(sorted(interval)): \\n                    if end < lo: \\n                        if i: ans += end - start + 1\\n                        start, end = lo, hi \\n                    else: end = max(end, hi)\\n                ans += end - start + 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        intervals = [[] for _ in range(201)]\\n        for x, y, r in circles: \\n            intervals[x].append((y-r, y+r))\\n            for dx in range(1, r+1): \\n                dy = int(sqrt(r**2 - dx**2))\\n                intervals[x+dx].append((y-dy, y+dy))\\n                intervals[x-dx].append((y-dy, y+dy))\\n        \\n        ans = 0 \\n        for interval in intervals: \\n            if interval: \\n                end = -inf\\n                for i, (lo, hi) in enumerate(sorted(interval)): \\n                    if end < lo: \\n                        if i: ans += end - start + 1\\n                        start, end = lo, hi \\n                    else: end = max(end, hi)\\n                ans += end - start + 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979552,
                "title": "python-clean-simple-iterator",
                "content": "```py\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        def allLattices(x: int, y: int, r: int) -> Iterator[Tuple[int, int]]:\\n            for dx in range(-r, r+1):\\n                yRange = isqrt(r*r - dx*dx)\\n                for dy in range(-yRange, yRange+1):\\n                    yield (x + dx, y + dy)\\n        \\n        s = set()\\n        for x, y, r in circles:\\n            s.update(allLattices(x, y, r))\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        def allLattices(x: int, y: int, r: int) -> Iterator[Tuple[int, int]]:\\n            for dx in range(-r, r+1):\\n                yRange = isqrt(r*r - dx*dx)\\n                for dy in range(-yRange, yRange+1):\\n                    yield (x + dx, y + dy)\\n        \\n        s = set()\\n        for x, y, r in circles:\\n            s.update(allLattices(x, y, r))\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979096,
                "title": "rust-check-every-possible-points-o-n",
                "content": "traverse every possible points.\\n\\nPoint(x, y)\\nx in -100..=200;\\ny in -100..= 200;\\n\\n```\\nimpl Solution {\\n    pub fn count_lattice_points(circles: Vec<Vec<i32>>) -> i32 {\\n        let mut ans = 0;\\n        for x in -100..=200 {\\n            for y in -100..= 200 {\\n                for circle in &circles {\\n                    if let [cx, cy, r, ..] = circle[..] {\\n                        if (x-cx).pow(2) + (y-cy).pow(2) <= r.pow(2) {\\n                            ans += 1;\\n                            break;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_lattice_points(circles: Vec<Vec<i32>>) -> i32 {\\n        let mut ans = 0;\\n        for x in -100..=200 {\\n            for y in -100..= 200 {\\n                for circle in &circles {\\n                    if let [cx, cy, r, ..] = circle[..] {\\n                        if (x-cx).pow(2) + (y-cy).pow(2) <= r.pow(2) {\\n                            ans += 1;\\n                            break;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1978769,
                "title": "c-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    set<pair<int,int>>st;\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n  \\n        for(int i=0;i<circles.size();i++){\\n            solve(circles[i]);\\n        }\\n        \\n        return st.size();\\n    }\\n    void solve(vector<int>&cir){\\n        int x=cir[0],y=cir[1],r=cir[2];\\n        \\n        for(int i=-r;i<=r;i++){                 //here we are considering (0,0) as origin and checking for -r to +r range \\n            for(int j=-r;j<=r;j++){             \\n                if((i*i)+(j*j)<=(r*r))               //mathematical formula\\n                    st.insert({i+x,j+y});           //as we considered (0,0) as origin first,so we need to correct it while storing \\n            }                                              //so we add x and y to get back the original values\\n        }\\n    }\\n};\\n\\n\\uD83D\\uDE4C\\uD83D\\uDC40 Please upvote if it helped !!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    set<pair<int,int>>st;\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n  \\n        for(int i=0;i<circles.size();i++){\\n            solve(circles[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1978656,
                "title": "a-few-solutions",
                "content": "Return the cardinality of the set of `seen` coordinates within each circle.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun countLatticePoints(A: Array<IntArray>): Int {\\n        var seen = mutableSetOf<String>()\\n        fun dist(i: Int, j: Int, u: Int, v: Int): Double {\\n            var x = Math.abs(i - u).toDouble()\\n            var y = Math.abs(j - v).toDouble()\\n            return Math.sqrt(x * x + y * y)\\n        }\\n        for ((i, j, r) in A)\\n            for (u in i - r..i + r)\\n                for (v in j - r..j + r)\\n                    if (dist(i, j, u, v) <= r)\\n                        seen.add(\"$u,$v\")\\n        return seen.size\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countLatticePoints = (A, seen = new Set()) => {\\n    let dist = (i, j, u, v) => {\\n        let x = Math.abs(i - u),\\n            y = Math.abs(j - v);\\n        return Math.sqrt(x * x + y * y);\\n    };\\n    for (let [i, j, r] of A)\\n        for (let u = i - r; u <= i + r; ++u)\\n            for (let v = j - r; v <= j + r; ++v)\\n                if (dist(i, j, u, v) <= r)\\n                    seen.add(`${u},${v}`);\\n    return seen.size;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countLatticePoints(self, A: List[List[int]]) -> int:\\n        seen = set()\\n        def dist(i, j, u, v):\\n            x = abs(i - u)\\n            y = abs(j - v)\\n            return sqrt(x * x + y * y)\\n        for i, j, r in A:\\n            for u in range(i - r, i + r + 1):\\n                for v in range(j - r, j + r + 1):\\n                    if dist(i, j, u, v) <= r:\\n                        seen.add(f\\'{u},{v}\\')\\n        return len(seen)\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn count_lattice_points(A: VVI) -> i32 {\\n        let mut seen = HashSet::new();\\n        fn dist(i: i32, j: i32, u: i32, v: i32) -> f32 {\\n            let x = (i - u).abs() as f32;\\n            let y = (j - v).abs() as f32;\\n            return (x * x + y * y).sqrt();\\n        }\\n        for row in A {\\n            let (i, j, r) = (row[0], row[1], row[2]);\\n            for u in i - r..=i + r {\\n                for v in j - r..=j + r {\\n                    if dist(i, j, u, v) <= r as f32 {\\n                        seen.insert(format!(\"{}, {}\", u, v));\\n                    }\\n                }\\n            }\\n        }\\n        return seen.len() as i32;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Set = unordered_set<string>;\\n    int countLatticePoints(VVI& A, Set seen = {}) {\\n        auto dist = [](auto i, auto j, auto u, auto v) {\\n            auto x = abs(i - u),\\n                 y = abs(j - v);\\n            return sqrt(x * x + y * y);\\n        };\\n        auto key = [](auto u, auto v) {\\n            stringstream ss; ss << u << \",\" << v;\\n            return ss.str();\\n        };\\n        for (auto& row: A) {\\n            auto [i, j, r] = tie(row[0], row[1], row[2]);\\n            for (auto u{ i - r }; u <= i + r; ++u)\\n                for (auto v{ j - r }; v <= j + r; ++v)\\n                    if (dist(i, j, u, v) <= r)\\n                        seen.insert(key(u, v));\\n        }\\n        return seen.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun countLatticePoints(A: Array<IntArray>): Int {\\n        var seen = mutableSetOf<String>()\\n        fun dist(i: Int, j: Int, u: Int, v: Int): Double {\\n            var x = Math.abs(i - u).toDouble()\\n            var y = Math.abs(j - v).toDouble()\\n            return Math.sqrt(x * x + y * y)\\n        }\\n        for ((i, j, r) in A)\\n            for (u in i - r..i + r)\\n                for (v in j - r..j + r)\\n                    if (dist(i, j, u, v) <= r)\\n                        seen.add(\"$u,$v\")\\n        return seen.size\\n    }\\n}\\n```\n```\\nlet countLatticePoints = (A, seen = new Set()) => {\\n    let dist = (i, j, u, v) => {\\n        let x = Math.abs(i - u),\\n            y = Math.abs(j - v);\\n        return Math.sqrt(x * x + y * y);\\n    };\\n    for (let [i, j, r] of A)\\n        for (let u = i - r; u <= i + r; ++u)\\n            for (let v = j - r; v <= j + r; ++v)\\n                if (dist(i, j, u, v) <= r)\\n                    seen.add(`${u},${v}`);\\n    return seen.size;\\n};\\n```\n```\\nclass Solution:\\n    def countLatticePoints(self, A: List[List[int]]) -> int:\\n        seen = set()\\n        def dist(i, j, u, v):\\n            x = abs(i - u)\\n            y = abs(j - v)\\n            return sqrt(x * x + y * y)\\n        for i, j, r in A:\\n            for u in range(i - r, i + r + 1):\\n                for v in range(j - r, j + r + 1):\\n                    if dist(i, j, u, v) <= r:\\n                        seen.add(f\\'{u},{v}\\')\\n        return len(seen)\\n```\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn count_lattice_points(A: VVI) -> i32 {\\n        let mut seen = HashSet::new();\\n        fn dist(i: i32, j: i32, u: i32, v: i32) -> f32 {\\n            let x = (i - u).abs() as f32;\\n            let y = (j - v).abs() as f32;\\n            return (x * x + y * y).sqrt();\\n        }\\n        for row in A {\\n            let (i, j, r) = (row[0], row[1], row[2]);\\n            for u in i - r..=i + r {\\n                for v in j - r..=j + r {\\n                    if dist(i, j, u, v) <= r as f32 {\\n                        seen.insert(format!(\"{}, {}\", u, v));\\n                    }\\n                }\\n            }\\n        }\\n        return seen.len() as i32;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Set = unordered_set<string>;\\n    int countLatticePoints(VVI& A, Set seen = {}) {\\n        auto dist = [](auto i, auto j, auto u, auto v) {\\n            auto x = abs(i - u),\\n                 y = abs(j - v);\\n            return sqrt(x * x + y * y);\\n        };\\n        auto key = [](auto u, auto v) {\\n            stringstream ss; ss << u << \",\" << v;\\n            return ss.str();\\n        };\\n        for (auto& row: A) {\\n            auto [i, j, r] = tie(row[0], row[1], row[2]);\\n            for (auto u{ i - r }; u <= i + r; ++u)\\n                for (auto v{ j - r }; v <= j + r; ++v)\\n                    if (dist(i, j, u, v) <= r)\\n                        seen.insert(key(u, v));\\n        }\\n        return seen.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977304,
                "title": "easy-c-solution-fully-explained",
                "content": "**FOR A POINT TO LIE INSIDE A CIRCLE, IT SHOULD FOLLOW A CERTAIN CONDITION**\\n\\nTHE CONDITION IS\\n\\n**(X-X1)^2 + (Y-Y1)^2 <= (R * R)**\\n\\nHERE X AND Y IS THE CENTER POINT OF THE CIRCLE,  X1 AND Y1 ARE ANY RANDOM POINTS\\n\\nNOW, **THE QUESTION COMES HOW TO FIND ALL X1 AND Y1 POINTS** \\n\\nNOW LET US ASSUME THAT WE ARE GIVEN A CIRCLE WITH **CENTER (2,2) AND RADIUS 2**\\n\\nNOW IF WE THINK , WHAT CAN BE THE EXTREME LEFT AND RIGHT POINTS, IT MEANS THAT THE EXTREME LEFT POINT LYING INSIDE THE CIRCLE WILL BE \\n\\nTHIS CAN BE SIMPLY CALCULATED AS **(CENTER X COORDINATE - RADIUS)**\\n(2-2) = 0       \\nTHE EXTREME RIGHT POINT WILL BE **( CENTER X COORDINATE + RADIUS)**\\n(2+2) = 4\\n\\nIT MEANS THAT X1 COORDINATE WILL LIE IN THE RANGE (0<=X1<=4)\\n\\nNOW, SIMILARLY WHAT CAN BE THE EXTREME UPWARDS AND DOWNWARDS POINTS\\n\\nEXTREME DOWNWARD POINT =  **( CENTER Y COORDINATE - RADIUS )**\\n(2-2) = 0\\nEXTREME UPWARD POINT  = **(CENTER Y COORDINATE + RADIUS)**\\n(2+2) = 4\\nIT MEANS THAT Y1 COORDINATE WILL LIE IN THE RANGE (0<=Y1<=4)\\n\\nTHE ABOVE MENTIONED THINGS CAN BE SIMPLY UNDERSTOOD WITH THE HELP OF DIAGRAM\\n\\n![image](https://assets.leetcode.com/users/images/0f3bff1a-6772-458c-93d6-ba83b37a1de7_1650777372.220716.jpeg)\\n\\nNOW, WE KNOW THAT **X1 WILL RANGE FROM 0 TO 4** AND **Y1 WILL RANGE FROM 0 TO 4**\\n\\nSO NOW WE HAVE TO TRY EVERY COMBINATION OF THE TWO RANGES AND FOR EVERY COMBINATION WE HAVE TO APPLY THIS FORMULA\\n\\n**(X-X1)^2 + (Y-Y1)^2 <= (R * R)**\\n\\nAND IF IT IS TRUE THEN WE HAVE TO JUST INSERT THE COORDINATES IN OUR SET.\\n\\nWE WILL BE CHOOSING A SET BECAUSE WE DON\\'T WANT OUR COORDINATES TO BE REPEATED FOR SOME OTHER CIRCLE\\n\\n**OUR ANS WILL BE THE SIZE OF THE SET**\\nTHE CODE IS AS FOLLOWS \\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(int x,int y,int r, set<pair<int,int>>&jd )\\n    {\\n        \\n        int a = x-r;\\n        int b = x+r;\\n        \\n        int c = y-r;\\n        int d = y+r;\\n        \\n        for(int i=a; i<=b; i++)\\n        {\\n            for(int j=c; j<=d; j++)\\n            {\\n                int z = (x-i)*(x-i);\\n                int t = (y-j)*(y-j);\\n                int m = r*r;\\n                if(z+t<=m)\\n                {\\n               //     cout<<x-i<<\" \"<<y-j<<\" \"<<endl;\\n                    jd.insert(make_pair(i,j));\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n    }\\n    \\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n      \\n        set<pair<int,int>>jd;\\n        \\n        for(int i=0; i<circles.size(); i++)\\n        {\\n            \\n            int x = circles[i][0];\\n            int y = circles[i][1];\\n            int r = circles[i][2];\\n            solve(x,y,r,jd);\\n            \\n            \\n        }\\n        int ans = jd.size();\\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(int x,int y,int r, set<pair<int,int>>&jd )\\n    {\\n        \\n        int a = x-r;\\n        int b = x+r;\\n        \\n        int c = y-r;\\n        int d = y+r;\\n        \\n        for(int i=a; i<=b; i++)\\n        {\\n            for(int j=c; j<=d; j++)\\n            {\\n                int z = (x-i)*(x-i);\\n                int t = (y-j)*(y-j);\\n                int m = r*r;\\n                if(z+t<=m)\\n                {\\n               //     cout<<x-i<<\" \"<<y-j<<\" \"<<endl;\\n                    jd.insert(make_pair(i,j));\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n    }\\n    \\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n      \\n        set<pair<int,int>>jd;\\n        \\n        for(int i=0; i<circles.size(); i++)\\n        {\\n            \\n            int x = circles[i][0];\\n            int y = circles[i][1];\\n            int r = circles[i][2];\\n            solve(x,y,r,jd);\\n            \\n            \\n        }\\n        int ans = jd.size();\\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1977094,
                "title": "python-math-geometry-and-set-solution-no-brute-force",
                "content": "**Intuition**\\nInstead of checking each point in the 2-D grid, we loop through each `circle` be calculating the `x-/y-axis` boundaries using Pythagoras Theorem, and add valid lattice points into the set (to avoid duplicate counting). The final output is the number of element in the resulting set.\\n\\n\\n**Complexity**\\nTime: `O(n * 4 * max(r)^2)`, where `n=circles.length` and `max(r) <= 100`\\nSpace: `O(201 * 201)` where `201` is the largest possible size of a valid lattice point in the 2-D grid\\n\\nBelow is my slightly-modified in-contest solution. Please upvote if you find this solution helpful. Thanks!\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        points = set()\\n        for x, y, r in circles:\\n            for dx in range(-r, r + 1, 1):\\n                temp = math.floor(math.sqrt(r ** 2 - dx ** 2))\\n                for dy in range(-temp, temp + 1):\\n                    points.add((x + dx, y + dy))\\n        return len(points)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Geometry"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        points = set()\\n        for x, y, r in circles:\\n            for dx in range(-r, r + 1, 1):\\n                temp = math.floor(math.sqrt(r ** 2 - dx ** 2))\\n                for dy in range(-temp, temp + 1):\\n                    points.add((x + dx, y + dy))\\n        return len(points)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977046,
                "title": "java-don-t-overthink-it-bruteforce",
                "content": "The trick to this question is Don\\'t Overthink it, just check all points. Due to the low constraint, the worst it could be is about (200)^3, which should still be accepted.\\n\\n```Java\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        int ans = 0;\\n        for (int i = 0; i < 201; i++){\\n            for (int j = 0; j < 201; j++){\\n                for (int[] c : circles){\\n                    int x = Math.abs(c[0] - i);\\n                    int y = Math.abs(c[1] - j);\\n                    if (c[2] * c[2] >= x * x + y * y){\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        int ans = 0;\\n        for (int i = 0; i < 201; i++){\\n            for (int j = 0; j < 201; j++){\\n                for (int[] c : circles){\\n                    int x = Math.abs(c[0] - i);\\n                    int y = Math.abs(c[1] - j);\\n                    if (c[2] * c[2] >= x * x + y * y){\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976987,
                "title": "c-maths",
                "content": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n         int ans = 0; \\n        for (int x = 0; x <=200;x++) \\n            for (int y = 0; y <=200; y++) {\\n                bool found = false; \\n                for (auto& c : circles) \\n                    if (pow(x-c[0], 2) + pow(y-c[1], 2) <= pow(c[2], 2)) \\n                        found = true; \\n                if (found) ans++; \\n            }\\n        return ans; \\n    }\\n};\\n```\\n**If Helpful PLease Like And Upvoke**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n         int ans = 0; \\n        for (int x = 0; x <=200;x++) \\n            for (int y = 0; y <=200; y++) {\\n                bool found = false; \\n                for (auto& c : circles) \\n                    if (pow(x-c[0], 2) + pow(y-c[1], 2) <= pow(c[2], 2)) \\n                        found = true; \\n                if (found) ans++; \\n            }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976986,
                "title": "modified-easiest-to-imagine-100-faster",
                "content": "\\n\\nNow, corrected and modified\\n\\n```#define ll long long\\n#define pi (3.141592653589)\\n#define mod 1000000007\\n#define float double\\n#define pb push_back\\n#define mp make_pair\\n#define ff first\\n#define ss second\\n#define all(c) c.begin(), c.end()\\n#define min3(a, b, c) min(c, min(a, b))\\n#define min4(a, b, c, d) min(d, min(c, min(a, b)))\\n#define rrep(i, n) for(int i=n-1;i>=0;i--)\\n#define rep(i,n) for(int i=0;i<n;i++)\\n\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n         \\n        bool g[1000][1000];\\n        memset(g, false, sizeof g);\\n        \\n       \\n        \\n        rep(i , circles.size()){\\n          \\n              for(int p= 0; p<=  circles[i][2] ; p++ )  { \\n\\t\\t\\t  \\n\\t\\t\\t  //// x^2  + y^2 <= radius^2 , Equation of circle \\n\\t\\t\\t  \\n                for(int k=0;   (p*p)+(k*k)<= (circles[i][2]* circles[i][2]) ; k++ ){\\n\\t\\t\\t\\t\\n                    g[circles[i][0]+p] [circles[i][1]+k]=true;\\n                    \\n                     g[circles[i][0]-p] [circles[i][1]+k]=true;\\n                        \\n                     g[circles[i][0]+p] [circles[i][1]-k]=true;\\n                        \\n                     g[circles[i][0]-p] [circles[i][1]-k]=true;\\n                    \\n                      g[circles[i][0]+k] [circles[i][1]-p]=true;\\n                    \\n                     g[circles[i][0]-k] [circles[i][1]+p]=true;\\n                        \\n                     g[circles[i][0]+k] [circles[i][1]-p]=true;\\n                        \\n                     g[circles[i][0]-k] [circles[i][1]-p]=true;\\n                }\\n                    \\n                }\\n               \\n           \\n        }   \\n              ll count=0;         \\n       \\n        rep(i, 1000){\\n            rep(j, 1000){\\n                if(g[i][j]) count++;\\n            }\\n        }\\n        return count;\\n        \\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n         \\n        bool g[1000][1000];\\n        memset(g, false, sizeof g);\\n        \\n       \\n        \\n        rep(i , circles.size()){\\n          \\n              for(int p= 0; p<=  circles[i][2] ; p++ )  { \\n\\t\\t\\t  \\n\\t\\t\\t  //// x^2  + y^2 <= radius^2 , Equation of circle \\n\\t\\t\\t  \\n                for(int k=0;   (p*p)+(k*k)<= (circles[i][2]* circles[i][2]) ; k++ ){\\n\\t\\t\\t\\t\\n                    g[circles[i][0]+p] [circles[i][1]+k]=true;\\n                    \\n                     g[circles[i][0]-p] [circles[i][1]+k]=true;\\n                        \\n                     g[circles[i][0]+p] [circles[i][1]-k]=true;\\n                        \\n                     g[circles[i][0]-p] [circles[i][1]-k]=true;\\n                    \\n                      g[circles[i][0]+k] [circles[i][1]-p]=true;\\n                    \\n                     g[circles[i][0]-k] [circles[i][1]+p]=true;\\n                        \\n                     g[circles[i][0]+k] [circles[i][1]-p]=true;\\n                        \\n                     g[circles[i][0]-k] [circles[i][1]-p]=true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1976974,
                "title": "java-bfs",
                "content": "Guess only I did the complex way.\\n\\n\\tclass Solution {\\n\\t\\tpublic int countLatticePoints(int[][] circles) {\\n\\t\\t\\tint[] dx = {1,-1,0,0};\\n\\t\\t\\tint[] dy = {0,0,1,-1};\\n\\t\\t\\tSet<Pair<Integer, Integer>> points = new HashSet<>();\\n\\t\\t\\tQueue<Pair<Integer, Integer>> q = new ArrayDeque<>();\\n\\t\\t\\tfor(int[] circle: circles){\\n\\t\\t\\t\\tq.offer(new Pair<>(circle[0], circle[1]));\\n\\t\\t\\t\\tpoints.add(new Pair<>(circle[0], circle[1]));\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile(!q.isEmpty()){\\n\\t\\t\\t\\tPair<Integer, Integer> cur = q.poll();\\n\\t\\t\\t\\tfor(int i = 0; i < 4; i++){\\n\\t\\t\\t\\t\\tPair<Integer, Integer> next = new Pair<Integer, Integer>(cur.getKey() + dx[i], cur.getValue() + dy[i]);\\n\\t\\t\\t\\t\\tif(!points.contains(next) && isValid(circles, next)){\\n\\t\\t\\t\\t\\t\\tq.offer(next);\\n\\t\\t\\t\\t\\t\\tpoints.add(next);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn points.size();\\n\\t\\t}\\n\\n\\n\\t\\tprivate boolean isValid(int[][] circles, Pair<Integer, Integer> point){\\n\\t\\t\\tfor(int[] circle: circles){\\n\\t\\t\\t\\tint ox = circle[0], oy = circle[1], r = circle[2], x = point.getKey(), y = point.getValue();\\n\\t\\t\\t\\tif(Math.pow(x - ox, 2) + Math.pow(y - oy, 2) <= Math.pow(r, 2)){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int countLatticePoints(int[][] circles) {\\n\\t\\t\\tint[] dx = {1,-1,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 1976962,
                "title": "java-simple-solution-pythagoras-theorem",
                "content": "```\\npublic int countLatticePoints(int[][] circles) {\\n        HashSet<String> answer = new HashSet<>();\\n        for (int[] circle : circles) {\\n            int pX = circle[0];\\n            int pY = circle[1];\\n            int r = circle[2];\\n\\t\\t\\t// Try all possible integer co-oridnates\\n            for (int x = pX - r; x <= pX + r; x++) {\\n                for (int y = pY - r ; y <= pY + r; y++) {\\n\\t\\t\\t\\t   // Check validity, whether it is lattice point using Pythagoras Theorem\\n                    if (isLatticePoint(pX, pY, x, y, r)) {\\n                        answer.add(x + \",\" + y);\\n                    }\\n                }\\n            }\\n        }\\n        return answer.size();\\n    }\\n    \\n     private boolean isLatticePoint(int x1, int y1, int x2, int y2, int r) {\\n        return (x1 - x2)* (x1 - x2) + (y1 - y2) * (y1 - y2) <= r*r;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countLatticePoints(int[][] circles) {\\n        HashSet<String> answer = new HashSet<>();\\n        for (int[] circle : circles) {\\n            int pX = circle[0];\\n            int pY = circle[1];\\n            int r = circle[2];\\n\\t\\t\\t// Try all possible integer co-oridnates\\n            for (int x = pX - r; x <= pX + r; x++) {\\n                for (int y = pY - r ; y <= pY + r; y++) {\\n\\t\\t\\t\\t   // Check validity, whether it is lattice point using Pythagoras Theorem\\n                    if (isLatticePoint(pX, pY, x, y, r)) {\\n                        answer.add(x + \",\" + y);\\n                    }\\n                }\\n            }\\n        }\\n        return answer.size();\\n    }\\n    \\n     private boolean isLatticePoint(int x1, int y1, int x2, int y2, int r) {\\n        return (x1 - x2)* (x1 - x2) + (y1 - y2) * (y1 - y2) <= r*r;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976958,
                "title": "javascript-easy-solution-distance-formula-hash",
                "content": "```\\n/**\\n * @param {number[][]} circles\\n * @return {number}\\n */\\nvar countLatticePoints = function(circles) {\\n    let hash = {};\\n    for (let i = 0; i < circles.length; i++) {\\n        let circle = circles[i];\\n        let [x, y, r] = circle;\\n        \\n        for (let p = -r; p <= r; p++) {\\n            for (let q = -r; q <= r; q++) {\\n                if ((Math.pow(p, 2) + Math.pow(q, 2)) <= (Math.pow(r, 2))) {\\n                        hash[[p+x,q+y]]  = 1;\\n                }\\n            }    \\n        }\\n    }\\n    \\n    return Object.keys(hash).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * @param {number[][]} circles\\n * @return {number}\\n */\\nvar countLatticePoints = function(circles) {\\n    let hash = {};\\n    for (let i = 0; i < circles.length; i++) {\\n        let circle = circles[i];\\n        let [x, y, r] = circle;\\n        \\n        for (let p = -r; p <= r; p++) {\\n            for (let q = -r; q <= r; q++) {\\n                if ((Math.pow(p, 2) + Math.pow(q, 2)) <= (Math.pow(r, 2))) {\\n                        hash[[p+x,q+y]]  = 1;\\n                }\\n            }    \\n        }\\n    }\\n    \\n    return Object.keys(hash).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976948,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int ans=0;\\n        set<pair<int,int>>mp;\\n        for(int i=0;i<circles.size();i++){\\n                int x=circles[i][0];            \\n                int y=circles[i][1];\\n                int r=circles[i][2];\\n            for(int o=x-r;o<=x+r;o++){\\n                for(int v=y-r;v<=y+r;v++){\\n                    int a=((x-o)*(x-o))+((y-v)*(y-v));\\n                    if(a<=r*r){\\n                        mp.insert(make_pair(o,v));\\n                    }\\n                }\\n            }\\n        }\\n        return mp.size();\\n    }\\n};\\n```\\nPlease Upvote if you found this helpful!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int ans=0;\\n        set<pair<int,int>>mp;\\n        for(int i=0;i<circles.size();i++){\\n                int x=circles[i][0];            \\n                int y=circles[i][1];\\n                int r=circles[i][2];\\n            for(int o=x-r;o<=x+r;o++){\\n                for(int v=y-r;v<=y+r;v++){\\n                    int a=((x-o)*(x-o))+((y-v)*(y-v));\\n                    if(a<=r*r){\\n                        mp.insert(make_pair(o,v));\\n                    }\\n                }\\n            }\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976841,
                "title": "c-2249-count-lattice-points-inside-a-circle",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int ans = 0; \\n        for (int x = 0; x <= 200; ++x) \\n            for (int y = 0; y <= 200; ++y) {\\n                bool found = false; \\n                for (auto& c : circles) \\n                    if (pow(x-c[0], 2) + pow(y-c[1], 2) <= pow(c[2], 2)) \\n                        found = true; \\n                if (found) ++ans; \\n            }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int ans = 0; \\n        for (int x = 0; x <= 200; ++x) \\n            for (int y = 0; y <= 200; ++y) {\\n                bool found = false; \\n                for (auto& c : circles) \\n                    if (pow(x-c[0], 2) + pow(y-c[1], 2) <= pow(c[2], 2)) \\n                        found = true; \\n                if (found) ++ans; \\n            }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976806,
                "title": "c-easy-approch-fixing-the-points-which-are-possible",
                "content": "class Solution {\\npublic:\\n    \\n    int findDistance(int i, int j, int x, int y){                // find distance of i and j from center of circle\\n        int a = (x-i)*(x-i);\\n        int b = (y-j)*(y-j);\\n        return ceil(sqrt(a+b));\\n    }\\n    \\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int count = 0;\\n        \\n            for(int x = 0; x <= 200; x++){                 // moving x from 0 -> 200\\n                for(int y = 0; y <= 200; y++){             // moving y from 0 -> 200\\n                    for(auto &p: circles){                 // iterating over circles\\n                    if(findDistance(x,y,p[0],p[1]) <= p[2]){   // find Diatance of x,y from the center of ith circle\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int findDistance(int i, int j, int x, int y){                // find distance of i and j from center of circle\\n        int a = (x-i)*(x-i);\\n        int b = (y-j)*(y-j);\\n        return ceil(sqrt(a+b));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 4093338,
                "title": "c-better-than-98-in-time",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) \\n    {\\n        int ans=0;\\n        vector<vector<int>> lattice(201, vector<int>(201, 0));\\n\\n        for(int i=0; i<circles.size(); i++)\\n        {\\n            int x = circles[i][0], y = circles[i][1], r = circles[i][2];\\n            for(int j=x-r; j<=x+r; j++)\\n            {\\n                for(int k=y-r; k<=y+r; k++)\\n                {\\n                    float dist = sqrt((x-j)*(x-j) + (y-k)*(y-k));\\n                    if(dist <= (float)r and lattice[j][k]++ == 0) ++ans;\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) \\n    {\\n        int ans=0;\\n        vector<vector<int>> lattice(201, vector<int>(201, 0));\\n\\n        for(int i=0; i<circles.size(); i++)\\n        {\\n            int x = circles[i][0], y = circles[i][1], r = circles[i][2];\\n            for(int j=x-r; j<=x+r; j++)\\n            {\\n                for(int k=y-r; k<=y+r; k++)\\n                {\\n                    float dist = sqrt((x-j)*(x-j) + (y-k)*(y-k));\\n                    if(dist <= (float)r and lattice[j][k]++ == 0) ++ans;\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090358,
                "title": "simple-distance",
                "content": "# Approach\\nMake sure you call #uniq on circles, or it will trigger a TLE error.\\n\\n\\n# Code\\n```\\ndef count_lattice_points(circles)\\n  lattice_points = Set.new\\n  circles.uniq.each do |x,y,rad|\\n    row_range = x-rad .. x+rad+1\\n    col_range = y-rad .. y+rad+1\\n\\n    row_range.each do |row|\\n      col_range.each do |col|\\n        coords = [row, col]\\n\\n        if (x-row)**2 + (y-col)**2 <= rad**2\\n          lattice_points << coords\\n        end\\n      end\\n    end\\n  end\\n  lattice_points.size\\nend\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef count_lattice_points(circles)\\n  lattice_points = Set.new\\n  circles.uniq.each do |x,y,rad|\\n    row_range = x-rad .. x+rad+1\\n    col_range = y-rad .. y+rad+1\\n\\n    row_range.each do |row|\\n      col_range.each do |col|\\n        coords = [row, col]\\n\\n        if (x-row)**2 + (y-col)**2 <= rad**2\\n          lattice_points << coords\\n        end\\n      end\\n    end\\n  end\\n  lattice_points.size\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4086140,
                "title": "just-a-crude-solution-without-optimizations",
                "content": "Just going through all the integer points in the square that describes the circle each circle in circles. And check through the Pythagorean theorem whether this point is inscribed in the circle. Then I add it to the HashSet, which will not add it if such a point has already been added. And return the number of elements.\\n\\n# Code\\n```\\nusing System.Drawing;\\n\\npublic class Solution\\n{\\n    private const int X = 0;\\n    private const int Y = 1;\\n    private const int RADIUS = 2;\\n\\n    public int CountLatticePoints(int[][] circles)\\n    {\\n        var points = new HashSet<Point>();\\n\\n        foreach (var circle in circles)\\n            for (int dx = -circle[RADIUS]; dx <= circle[RADIUS]; dx++)\\n                for (int dy = -circle[RADIUS]; dy <= circle[RADIUS]; dy++)\\n                    if ((dx * dx) + (dy * dy) <= circle[RADIUS] * circle[RADIUS])\\n                        points.Add(new Point(dx + circle[X], dy + circle[Y]));\\n        \\n        return points.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nusing System.Drawing;\\n\\npublic class Solution\\n{\\n    private const int X = 0;\\n    private const int Y = 1;\\n    private const int RADIUS = 2;\\n\\n    public int CountLatticePoints(int[][] circles)\\n    {\\n        var points = new HashSet<Point>();\\n\\n        foreach (var circle in circles)\\n            for (int dx = -circle[RADIUS]; dx <= circle[RADIUS]; dx++)\\n                for (int dy = -circle[RADIUS]; dy <= circle[RADIUS]; dy++)\\n                    if ((dx * dx) + (dy * dy) <= circle[RADIUS] * circle[RADIUS])\\n                        points.Add(new Point(dx + circle[X], dy + circle[Y]));\\n        \\n        return points.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939044,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int countLatticePoints(int[][] circles) {\\n    int ans = 0;\\n\\n    for (int x = 0; x < 201; ++x)\\n      for (int y = 0; y < 201; ++y)\\n        for (int[] c : circles)\\n          if ((c[0] - x) * (c[0] - x) + (c[1] - y) * (c[1] - y) <= c[2] * c[2]) {\\n            ++ans;\\n            break;\\n          }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int countLatticePoints(int[][] circles) {\\n    int ans = 0;\\n\\n    for (int x = 0; x < 201; ++x)\\n      for (int y = 0; y < 201; ++y)\\n        for (int[] c : circles)\\n          if ((c[0] - x) * (c[0] - x) + (c[1] - y) * (c[1] - y) <= c[2] * c[2]) {\\n            ++ans;\\n            break;\\n          }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939043,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int countLatticePoints(int[][] circles) {\\n    int ans = 0;\\n\\n    for (int x = 0; x < 201; ++x)\\n      for (int y = 0; y < 201; ++y)\\n        for (int[] c : circles)\\n          if ((c[0] - x) * (c[0] - x) + (c[1] - y) * (c[1] - y) <= c[2] * c[2]) {\\n            ++ans;\\n            break;\\n          }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int countLatticePoints(int[][] circles) {\\n    int ans = 0;\\n\\n    for (int x = 0; x < 201; ++x)\\n      for (int y = 0; y < 201; ++y)\\n        for (int[] c : circles)\\n          if ((c[0] - x) * (c[0] - x) + (c[1] - y) * (c[1] - y) <= c[2] * c[2]) {\\n            ++ans;\\n            break;\\n          }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923953,
                "title": "easy-with-set-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int, int>> st;\\n\\n        for (const vector<int>& circle : circles) {\\n            int xi = circle[0];\\n            int yi = circle[1];\\n            int r = circle[2];\\n\\n            for (int x = xi - r; x <= xi + r; ++x) {\\n                for (int y = yi - r; y <= yi + r; ++y) {\\n                    if ((x - xi) * (x - xi) + (y - yi) * (y - yi) <= r * r) {\\n                        st.insert({x, y});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return st.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int, int>> st;\\n\\n        for (const vector<int>& circle : circles) {\\n            int xi = circle[0];\\n            int yi = circle[1];\\n            int r = circle[2];\\n\\n            for (int x = xi - r; x <= xi + r; ++x) {\\n                for (int y = yi - r; y <= yi + r; ++y) {\\n                    if ((x - xi) * (x - xi) + (y - yi) * (y - yi) <= r * r) {\\n                        st.insert({x, y});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return st.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911113,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int calculateDistance(int x2,int y2,int x1,int y1){\\n        return (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);\\n    }\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>s;\\n        for(int i = 0;i < circles.size();i++){\\n            float rad = (float)circles[i][2];\\n            int rx = circles[i][0];\\n            int ry = circles[i][1];\\n            for(int x = rx-rad;x <= rx + rad;x++){\\n                for(int y = ry - rad;y <= ry + rad;y++){\\n                    if(rad*rad >= calculateDistance(rx,ry,x,y)){\\n                        s.insert({x,y});\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateDistance(int x2,int y2,int x1,int y1){\\n        return (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);\\n    }\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>s;\\n        for(int i = 0;i < circles.size();i++){\\n            float rad = (float)circles[i][2];\\n            int rx = circles[i][0];\\n            int ry = circles[i][1];\\n            for(int x = rx-rad;x <= rx + rad;x++){\\n                for(int y = ry - rad;y <= ry + rad;y++){\\n                    if(rad*rad >= calculateDistance(rx,ry,x,y)){\\n                        s.insert({x,y});\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911111,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int calculateDistance(int x2,int y2,int x1,int y1){\\n        return (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);\\n    }\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>s;\\n        for(int i = 0;i < circles.size();i++){\\n            float rad = (float)circles[i][2];\\n            int rx = circles[i][0];\\n            int ry = circles[i][1];\\n            for(int x = rx-rad;x <= rx + rad;x++){\\n                for(int y = ry - rad;y <= ry + rad;y++){\\n                    if(rad*rad >= calculateDistance(rx,ry,x,y)){\\n                        s.insert({x,y});\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateDistance(int x2,int y2,int x1,int y1){\\n        return (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);\\n    }\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>s;\\n        for(int i = 0;i < circles.size();i++){\\n            float rad = (float)circles[i][2];\\n            int rx = circles[i][0];\\n            int ry = circles[i][1];\\n            for(int x = rx-rad;x <= rx + rad;x++){\\n                for(int y = ry - rad;y <= ry + rad;y++){\\n                    if(rad*rad >= calculateDistance(rx,ry,x,y)){\\n                        s.insert({x,y});\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767780,
                "title": "numpy-is-all-you-needed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nJust use numpy. np.mgrid\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nO(n * 500 * 500)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        import numpy as np\\n        xx, yy = np.mgrid[-200:300,-200:300]\\n        arr = np.full(shape=(500,500),fill_value=False,dtype=bool)\\n        for x,y,r in circles:\\n            arr |= (xx - x) ** 2 + (yy - y) ** 2 <= r ** 2\\n        return arr.sum()\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        import numpy as np\\n        xx, yy = np.mgrid[-200:300,-200:300]\\n        arr = np.full(shape=(500,500),fill_value=False,dtype=bool)\\n        for x,y,r in circles:\\n            arr |= (xx - x) ** 2 + (yy - y) ** 2 <= r ** 2\\n        return arr.sum()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664909,
                "title": "c-simple-grid-iteration-with-lots-of-inline-comments",
                "content": "Please upvote if helpful; thank you!\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountLatticePoints(int[][] circles) \\n    {\\n        int ret = 0; \\n\\n        // store candidate points in a manner that allows fast search afterwards,\\n        // to avoid counting the same point twice\\n        // KEY = the X coordinate and VALUE = all Y coordinates of the points\\n        // having the same X coordinate\\n        var points = new Dictionary<int, HashSet<int>>();\\n        \\n        var n = circles.Length;\\n\\n        // iterate all circles\\n        for(int c = 0; c < n; c++)\\n        {\\n            // extract the center (cx, cy) and radius (r) values\\n            var cx = circles[c][0];\\n            var cy = circles[c][1];\\n            var r = circles[c][2];\\n            var rr = r * r;\\n\\n            // iterate the 2D grid with a 1 unit step (ensures lattice points)\\n            // limited to the circumscribed square of the circle  \\n            var startX = cx - r;\\n            var endX = cx + r;\\n            var startY = cy - r;\\n            var endY = cy + r;\\n\\n            for(int x = startX; x <= endX; x++)\\n                for(int y = startY; y <= endY; y++)\\n                    // check whether the current (x, y) point is inside the circle\\n                    // meaning that the distance from the circle\\'s center to that point\\n                    // is less or equal to that circle\\'s radius\\n                    if (Math.Pow(cx -x, 2) + Math.Pow(cy - y, 2) <= rr)\\n                    {            \\n                        // if the current (x, y) point is a valid candidate,\\n                        // check whether it wasn\\'t already stored/counted\\n                        // if not, store it and increment the result    \\n                        if (!points.ContainsKey(x))\\n                        {\\n                            // add a brand new (x, y) point\\n                            points[x] = new HashSet<int> { y };\\n                            ret++;\\n                        }\\n                        else\\n                            if (!points[x].Contains(y))\\n                            {\\n                                // add a new Y coordinate to the list of points \\n                                // having the same X coordinate   \\n                                points[x].Add(y);\\n                                ret++;\\n                            }\\n                    }\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountLatticePoints(int[][] circles) \\n    {\\n        int ret = 0; \\n\\n        // store candidate points in a manner that allows fast search afterwards,\\n        // to avoid counting the same point twice\\n        // KEY = the X coordinate and VALUE = all Y coordinates of the points\\n        // having the same X coordinate\\n        var points = new Dictionary<int, HashSet<int>>();\\n        \\n        var n = circles.Length;\\n\\n        // iterate all circles\\n        for(int c = 0; c < n; c++)\\n        {\\n            // extract the center (cx, cy) and radius (r) values\\n            var cx = circles[c][0];\\n            var cy = circles[c][1];\\n            var r = circles[c][2];\\n            var rr = r * r;\\n\\n            // iterate the 2D grid with a 1 unit step (ensures lattice points)\\n            // limited to the circumscribed square of the circle  \\n            var startX = cx - r;\\n            var endX = cx + r;\\n            var startY = cy - r;\\n            var endY = cy + r;\\n\\n            for(int x = startX; x <= endX; x++)\\n                for(int y = startY; y <= endY; y++)\\n                    // check whether the current (x, y) point is inside the circle\\n                    // meaning that the distance from the circle\\'s center to that point\\n                    // is less or equal to that circle\\'s radius\\n                    if (Math.Pow(cx -x, 2) + Math.Pow(cy - y, 2) <= rr)\\n                    {            \\n                        // if the current (x, y) point is a valid candidate,\\n                        // check whether it wasn\\'t already stored/counted\\n                        // if not, store it and increment the result    \\n                        if (!points.ContainsKey(x))\\n                        {\\n                            // add a brand new (x, y) point\\n                            points[x] = new HashSet<int> { y };\\n                            ret++;\\n                        }\\n                        else\\n                            if (!points[x].Contains(y))\\n                            {\\n                                // add a new Y coordinate to the list of points \\n                                // having the same X coordinate   \\n                                points[x].Add(y);\\n                                ret++;\\n                            }\\n                    }\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597693,
                "title": "rust-circle-and-boundingbox-structs-with-iterators",
                "content": "# Intuition\\nIt\\'s faster to consider each lattice point, and see if it fits in any circle, than it is to consider each circle, generate points inside it, and then try to dedup.\\n\\nOtherwise, we\\'re just drawing a bounding box that covers the maximum range of points that circles could encompass, and checking each point against each circle until we find one it fits in.\\n\\n# Approach\\nSince we\\'re just comparing against r squared every time, we can save on multiplication costs by storing r_sq along with the Circle object.\\n\\nCreating a BoundingBox type gives us a more ergonomic way to find that largest bounding box using reduce() and iterate over all interior lattice points.\\n\\n# Complexity\\n- Time complexity: O(m * n), for the m x n bounding box containing all the circles. We have to check each point against at least one circle.\\n\\n- Space complexity: O(circles.len()). Technically this could be done in O(1) space if we didn\\'t \\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn count_lattice_points(circles: Vec<Vec<i32>>) -> i32 {\\n        let circles = circles\\n        .into_iter()\\n        .map(|v| Circle::new(v[0], v[1], v[2]))\\n        .collect::<Vec<Circle>>();\\n\\n        let bounding_box = circles\\n        .iter()\\n        .map(|circle| circle.bounding_box())\\n        .reduce(|a, b| a.merge(b))\\n        .unwrap_or_default();\\n\\n        bounding_box\\n        .into_lattice_iter()\\n        .filter(|&(i, j)| {\\n            circles.iter().any(|circle| circle.contains(i, j))\\n        })\\n        .count() as i32\\n    }\\n}\\n\\nstruct Circle {\\n    pub x: i32,\\n    pub y: i32,\\n    pub r: i32,\\n    pub r_sq: i64,\\n}\\n\\nimpl Circle {\\n    fn new(x: i32, y: i32, r: i32) -> Self {\\n        let r_sq = i64::from(r) * i64::from(r);\\n        Self { x, y, r, r_sq}\\n    }\\n\\n    fn bounding_box(&self) -> BoundingBox {\\n        BoundingBox {\\n            min_x: self.x - self.r,\\n            max_x: self.x + self.r,\\n            min_y: self.y - self.r,\\n            max_y: self.y + self.r,\\n        }\\n    }\\n\\n    fn contains(&self, i: i32, j: i32) -> bool {\\n        let x_distance: i64 = (i - self.x).into();\\n        let y_distance: i64 = (j - self.y).into();\\n        x_distance * x_distance + y_distance * y_distance <= self.r_sq\\n    }\\n}\\n\\n#[derive(Default, Clone, Copy)]\\nstruct BoundingBox {\\n    min_x: i32,\\n    max_x: i32,\\n    min_y: i32,\\n    max_y: i32,\\n}\\n\\nimpl BoundingBox {\\n    pub fn merge(self, other: Self) -> Self {\\n        Self {\\n            min_x: self.min_x.min(other.min_x),\\n            max_x: self.max_x.max(other.max_x),\\n            min_y: self.min_y.min(other.min_y),\\n            max_y: self.max_y.max(other.max_y),\\n        }\\n    }\\n\\n    pub fn into_lattice_iter(self) -> impl Iterator<Item = (i32, i32)> {\\n        (self.min_x..=self.max_x)\\n        .flat_map(move |i| (self.min_y..=self.max_y).map(move |j| (i, j)))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_lattice_points(circles: Vec<Vec<i32>>) -> i32 {\\n        let circles = circles\\n        .into_iter()\\n        .map(|v| Circle::new(v[0], v[1], v[2]))\\n        .collect::<Vec<Circle>>();\\n\\n        let bounding_box = circles\\n        .iter()\\n        .map(|circle| circle.bounding_box())\\n        .reduce(|a, b| a.merge(b))\\n        .unwrap_or_default();\\n\\n        bounding_box\\n        .into_lattice_iter()\\n        .filter(|&(i, j)| {\\n            circles.iter().any(|circle| circle.contains(i, j))\\n        })\\n        .count() as i32\\n    }\\n}\\n\\nstruct Circle {\\n    pub x: i32,\\n    pub y: i32,\\n    pub r: i32,\\n    pub r_sq: i64,\\n}\\n\\nimpl Circle {\\n    fn new(x: i32, y: i32, r: i32) -> Self {\\n        let r_sq = i64::from(r) * i64::from(r);\\n        Self { x, y, r, r_sq}\\n    }\\n\\n    fn bounding_box(&self) -> BoundingBox {\\n        BoundingBox {\\n            min_x: self.x - self.r,\\n            max_x: self.x + self.r,\\n            min_y: self.y - self.r,\\n            max_y: self.y + self.r,\\n        }\\n    }\\n\\n    fn contains(&self, i: i32, j: i32) -> bool {\\n        let x_distance: i64 = (i - self.x).into();\\n        let y_distance: i64 = (j - self.y).into();\\n        x_distance * x_distance + y_distance * y_distance <= self.r_sq\\n    }\\n}\\n\\n#[derive(Default, Clone, Copy)]\\nstruct BoundingBox {\\n    min_x: i32,\\n    max_x: i32,\\n    min_y: i32,\\n    max_y: i32,\\n}\\n\\nimpl BoundingBox {\\n    pub fn merge(self, other: Self) -> Self {\\n        Self {\\n            min_x: self.min_x.min(other.min_x),\\n            max_x: self.max_x.max(other.max_x),\\n            min_y: self.min_y.min(other.min_y),\\n            max_y: self.max_y.max(other.max_y),\\n        }\\n    }\\n\\n    pub fn into_lattice_iter(self) -> impl Iterator<Item = (i32, i32)> {\\n        (self.min_x..=self.max_x)\\n        .flat_map(move |i| (self.min_y..=self.max_y).map(move |j| (i, j)))\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591932,
                "title": "java-geometry",
                "content": "class Solution {\\n\\n    public class Pair{\\n        int x;\\n        int y;\\n        public Pair(int xi,int yi){\\n            x=xi;\\n            y=yi;\\n        }\\n    }\\n    \\n    public boolean checkDistance(Pair point,Pair origin,int r){\\n        double dist = Math.sqrt(Math.pow(point.x-origin.x,2) + Math.pow(point.y-origin.y,2));\\n        return dist <= (double)r;\\n    }\\n    \\n    public int countLatticePoints(int[][] circles) {\\n        Set<String> lpoints=new HashSet<String>();\\n        int n=circles.length;\\n        for(int k=0;k<n;k++){\\n            Pair origin = new Pair(circles[k][0],circles[k][1]);\\n            int r=circles[k][2];\\n            Pair lbound = new Pair(origin.x-r,origin.y-r);\\n            Pair ubound = new Pair(origin.x+r,origin.y+r);\\n            for(int i=lbound.x;i<=ubound.x;i++){\\n                for(int j=lbound.y;j<=ubound.y;j++){\\n                    if(checkDistance(new Pair(i,j),origin,r)){\\n                        lpoints.add(i+\" \"+j);\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return lpoints.size();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public class Pair{\\n        int x;\\n        int y;\\n        public Pair(int xi,int yi){\\n            x=xi;\\n            y=yi;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3519848,
                "title": "recursive-solution-c-very-hard-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nDont Know\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   unordered_set<int> uniquePoints;\\n   bool isPointInsideTheCircle(int xCircle,int xPoint,int yCircle ,int yPoint,int circleRadius) {\\n        int xDiff = xCircle - xPoint;\\n        int yDiff = yCircle - yPoint;\\n        int distanceSqr = xDiff * xDiff + yDiff * yDiff;\\n        return distanceSqr <= circleRadius * circleRadius;\\n   }\\n   void helper(const vector<int> &circleCordinates,int tempXPoint,int tempYPoint,int downLimit,int upLimit) {\\n       //base condition out of bounds up and down\\n       if ( (tempYPoint >= downLimit && tempYPoint<= upLimit) == false) {\\n           return ;\\n       }\\n       if (isPointInsideTheCircle(circleCordinates[0],tempXPoint,circleCordinates[1],tempYPoint,circleCordinates[2]) == false) {\\n           return ;\\n       }\\n       int centerXPoint = circleCordinates[0];\\n       int tempLeftPoint = tempXPoint-1;\\n       int tempRightPoint = tempXPoint;\\n       int centerYPoint = circleCordinates[1];\\n       int radius = circleCordinates[2];\\n       //for left\\n       while(isPointInsideTheCircle(centerXPoint,tempLeftPoint,centerYPoint,tempYPoint,radius)) {\\n           int key = tempLeftPoint * 1000000 + tempYPoint;\\n           uniquePoints.insert(key);\\n           tempLeftPoint --;\\n       }\\n       //for right\\n       while(isPointInsideTheCircle(centerXPoint,tempRightPoint,centerYPoint,tempYPoint,radius)) {\\n            int key = tempRightPoint * 1000000 + tempYPoint;\\n           uniquePoints.insert(key);\\n           tempRightPoint ++;\\n       }\\n       //for up\\n       helper(circleCordinates,tempXPoint,tempYPoint+1, tempYPoint+1,upLimit);\\n       //for down\\n       helper(circleCordinates,tempXPoint,tempYPoint-1,downLimit,upLimit-1);\\n   }\\n\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        unordered_set<int> dp;\\n        for(const auto& circle:circles) {\\n            int tempXPoint = circle[0];\\n            int tempYPoint = circle[1];\\n            int key = tempXPoint * 10000 + 1000 * tempYPoint + 100* circle[2];\\n             if (dp.find(key) == dp.end()) {\\n                 helper(circle,tempXPoint,tempYPoint,tempYPoint-circle[2],tempYPoint+circle[2]);\\n                 dp.insert(key);\\n            }\\n             //helper(circle,tempXPoint,tempYPoint,tempYPoint-circle[2],tempYPoint+circle[2]);\\n           \\n        }\\n         return uniquePoints.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   unordered_set<int> uniquePoints;\\n   bool isPointInsideTheCircle(int xCircle,int xPoint,int yCircle ,int yPoint,int circleRadius) {\\n        int xDiff = xCircle - xPoint;\\n        int yDiff = yCircle - yPoint;\\n        int distanceSqr = xDiff * xDiff + yDiff * yDiff;\\n        return distanceSqr <= circleRadius * circleRadius;\\n   }\\n   void helper(const vector<int> &circleCordinates,int tempXPoint,int tempYPoint,int downLimit,int upLimit) {\\n       //base condition out of bounds up and down\\n       if ( (tempYPoint >= downLimit && tempYPoint<= upLimit) == false) {\\n           return ;\\n       }\\n       if (isPointInsideTheCircle(circleCordinates[0],tempXPoint,circleCordinates[1],tempYPoint,circleCordinates[2]) == false) {\\n           return ;\\n       }\\n       int centerXPoint = circleCordinates[0];\\n       int tempLeftPoint = tempXPoint-1;\\n       int tempRightPoint = tempXPoint;\\n       int centerYPoint = circleCordinates[1];\\n       int radius = circleCordinates[2];\\n       //for left\\n       while(isPointInsideTheCircle(centerXPoint,tempLeftPoint,centerYPoint,tempYPoint,radius)) {\\n           int key = tempLeftPoint * 1000000 + tempYPoint;\\n           uniquePoints.insert(key);\\n           tempLeftPoint --;\\n       }\\n       //for right\\n       while(isPointInsideTheCircle(centerXPoint,tempRightPoint,centerYPoint,tempYPoint,radius)) {\\n            int key = tempRightPoint * 1000000 + tempYPoint;\\n           uniquePoints.insert(key);\\n           tempRightPoint ++;\\n       }\\n       //for up\\n       helper(circleCordinates,tempXPoint,tempYPoint+1, tempYPoint+1,upLimit);\\n       //for down\\n       helper(circleCordinates,tempXPoint,tempYPoint-1,downLimit,upLimit-1);\\n   }\\n\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        unordered_set<int> dp;\\n        for(const auto& circle:circles) {\\n            int tempXPoint = circle[0];\\n            int tempYPoint = circle[1];\\n            int key = tempXPoint * 10000 + 1000 * tempYPoint + 100* circle[2];\\n             if (dp.find(key) == dp.end()) {\\n                 helper(circle,tempXPoint,tempYPoint,tempYPoint-circle[2],tempYPoint+circle[2]);\\n                 dp.insert(key);\\n            }\\n             //helper(circle,tempXPoint,tempYPoint,tempYPoint-circle[2],tempYPoint+circle[2]);\\n           \\n        }\\n         return uniquePoints.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515114,
                "title": "javascript-solution-pythagorean-theorem",
                "content": "I totally forgot Pythagorean theorem and got very confused after studied others solution and thought: why every one know how to see if the point is in the circle???\\nTurns out, I return all of them to my school teacher\\n\\nFor every one like me don\\'t know or forgot this,\\n![image](https://assets.leetcode.com/users/images/e45744bd-f030-42b7-814e-7ace20904582_1683874111.6473796.png)\\n(ref to wiki)\\n\\nSo that we will know if a^2 + b^2 <= r^2, the point is in the circle.\\n\\n```\\n/**\\n * @param {number[][]} circles\\n * @return {number}\\n */\\nvar countLatticePoints = function(circles) {\\n    let res = 0\\n    \\n    for(let i = 0; i <= 200; i++) {\\n        for(let j = 0; j <= 200; j++) {\\n            for(let [x,y,r] of circles) {\\n                if(Math.pow(Math.abs(x-i), 2) + Math.pow(Math.abs(y-j), 2) <= r * r) {\\n                    res++\\n                    break // no need to check for other circle\\n                }\\n            }\\n        }\\n    }\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {number[][]} circles\\n * @return {number}\\n */\\nvar countLatticePoints = function(circles) {\\n    let res = 0\\n    \\n    for(let i = 0; i <= 200; i++) {\\n        for(let j = 0; j <= 200; j++) {\\n            for(let [x,y,r] of circles) {\\n                if(Math.pow(Math.abs(x-i), 2) + Math.pow(Math.abs(y-j), 2) <= r * r) {\\n                    res++\\n                    break // no need to check for other circle\\n                }\\n            }\\n        }\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3490694,
                "title": "basic-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif the distance between a point and the centre is less than or equal to the radius then the point is in the circle.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\neach circle would be boxed in a square of length 2*r.\\nNumber of points in the square = (2*r+1)^2.\\nCalculate the distance between each point and the centre if its less than the length of the radius then the point is inside the circle.\\nWe push the points in a set to as to eliminate repetitions. \\nIn the end we return the size of the set.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& nums) {\\n        int dis=0;\\n        set<pair<int,int>> v;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int x=nums[i][0]-nums[i][2],y=nums[i][1]-nums[i][2];\\n            int x1=nums[i][0]+nums[i][2],y1=nums[i][1]+nums[i][2];\\n            for(int k=x;k<=x1;k++)\\n            {\\n                for(int j=y;j<=y1;j++)\\n                {\\n                    if( (j-nums[i][1])*(j-nums[i][1]) + (k-nums[i][0])*(k-nums[i][0]) <= nums[i][2] * nums[i][2] ) \\n                    {\\n                        pair<int,int> m=make_pair(k,j);\\n                        v.insert(m);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return v.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& nums) {\\n        int dis=0;\\n        set<pair<int,int>> v;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int x=nums[i][0]-nums[i][2],y=nums[i][1]-nums[i][2];\\n            int x1=nums[i][0]+nums[i][2],y1=nums[i][1]+nums[i][2];\\n            for(int k=x;k<=x1;k++)\\n            {\\n                for(int j=y;j<=y1;j++)\\n                {\\n                    if( (j-nums[i][1])*(j-nums[i][1]) + (k-nums[i][0])*(k-nums[i][0]) <= nums[i][2] * nums[i][2] ) \\n                    {\\n                        pair<int,int> m=make_pair(k,j);\\n                        v.insert(m);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return v.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321917,
                "title": "83-ms",
                "content": "Proof: https://leetcode.com/submissions/detail/919140993/\\n```ruby\\n@m = {}\\n\\ndef count_lattice_points a\\n    g = Hash.new { _1[_2] = [] }\\n    for x, y, r in a\\n        t = (x << 8) | x\\n        g[y - r] << t\\n        g[y + r] << t\\n        g[y].push (x - r << 8) | x + r\\n        v = @m[r] ||= begin\\n            r2 = r * r\\n            (1...r).map do\\n                Integer.sqrt(r2 - _1 * _1)\\n            end\\n        end\\n        yt = yb = y\\n        v.each do | d |\\n            t = (x - d << 8) | x + d\\n            g[yt -= 1] << t\\n            g[yb += 1] << t\\n        end\\n    end\\n    g.each_value.sum do | a |\\n        a.sort!\\n        s = 0\\n        until a.empty?\\n            b, e = (k = a.shift) >> 8, k & 255\\n            while k = a.first\\n                break if (k >> 8) > e\\n                a.shift\\n                e = k if (k &= 255) > e\\n            end\\n            s += e - b + 1\\n        end\\n        s\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n@m = {}\\n\\ndef count_lattice_points a\\n    g = Hash.new { _1[_2] = [] }\\n    for x, y, r in a\\n        t = (x << 8) | x\\n        g[y - r] << t\\n        g[y + r] << t\\n        g[y].push (x - r << 8) | x + r\\n        v = @m[r] ||= begin\\n            r2 = r * r\\n            (1...r).map do\\n                Integer.sqrt(r2 - _1 * _1)\\n            end\\n        end\\n        yt = yb = y\\n        v.each do | d |\\n            t = (x - d << 8) | x + d\\n            g[yt -= 1] << t\\n            g[yb += 1] << t\\n        end\\n    end\\n    g.each_value.sum do | a |\\n        a.sort!\\n        s = 0\\n        until a.empty?\\n            b, e = (k = a.shift) >> 8, k & 255\\n            while k = a.first\\n                break if (k >> 8) > e\\n                a.shift\\n                e = k if (k &= 255) > e\\n            end\\n            s += e - b + 1\\n        end\\n        s\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3300469,
                "title": "python-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\nenumerate all of the point in the square whose left lower coner is at (xc-r, yc-r) and right upper corner is at (xc+r, yc+r)\\nand check the distance between the point and center is not greater than radius\\n\\n\\'\\'\\'\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        ans = set()\\n        for xc, yc, r in circles:\\n            for y in range(yc-r, yc+r+1):\\n                for x in range(xc-r, xc+r+1):\\n                    if (x, y) not in ans and self.distanceSquare(x, y, xc, yc) <= r * r:\\n                        ans.add((x,y))\\n        return len(ans)\\n\\n    def distanceSquare(self, x1, y1, x2, y2):\\n        return (x1-x2)**2 + (y1-y2)**2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n\\'\\'\\'\\nenumerate all of the point in the square whose left lower coner is at (xc-r, yc-r) and right upper corner is at (xc+r, yc+r)\\nand check the distance between the point and center is not greater than radius\\n\\n\\'\\'\\'\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        ans = set()\\n        for xc, yc, r in circles:\\n            for y in range(yc-r, yc+r+1):\\n                for x in range(xc-r, xc+r+1):\\n                    if (x, y) not in ans and self.distanceSquare(x, y, xc, yc) <= r * r:\\n                        ans.add((x,y))\\n        return len(ans)\\n\\n    def distanceSquare(self, x1, y1, x2, y2):\\n        return (x1-x2)**2 + (y1-y2)**2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242674,
                "title": "simple-neat-explanation-clean-c-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo count the number of lattice points present inside the circles, we can iterate through each circle, consider all points within the radius of the circle, and add them to a set. In the end, the size of the set will give us the count of unique lattice points that are present inside at least one circle.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a set of pairs to store all unique lattice points present inside the circles.\\n1. For each circle in the given array of circles:\\n    1. Iterate through all points within the radius of the circle.\\n    1. If the distance between the current point and the center of the circle is less than or equal to the radius of the circle, add the point to the set.\\n1. The size of the set will give us the count of unique lattice points present inside the circles.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, For each circle, we iterate through all points within its radius. Therefore, the time complexity is O(nr^2), where n is the number of circles and r is the maximum radius among all circles. Since r <= 5000, the time complexity is effectively O(n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(nr^2)$$, We use a set to store all unique lattice points present inside the circles. The worst-case size of the set is when all lattice points are present inside the circles. In that case, the size of the set is O(nr^2). Therefore, the space complexity is O(nr^2).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int, int>> set1;\\n        for(const auto &circle: circles) {\\n            int x = circle[0], y = circle[1], r = circle[2];\\n            for(int i = -r; i <= r; i++) {\\n                for(int j = -r; j <= r; j++) {\\n                    if(i*i + j*j <= r*r) {\\n                        set1.insert({i + x, j + y});\\n                    }\\n                }\\n            }\\n        }\\n        int res = set1.size();\\n        return res;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        Set<Pair<Integer, Integer>> set = new HashSet<>();\\n        for(int[] circle: circles) {\\n            int x = circle[0], y = circle[1], r = circle[2];\\n            for(int i = -r; i <= r; i++) {\\n                for(int j = -r; j <= r; j++) {\\n                    if(i*i + j*j <= r*r) {\\n                        set.add(new Pair<>(i + x, j + y));\\n                    }\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int, int>> set1;\\n        for(const auto &circle: circles) {\\n            int x = circle[0], y = circle[1], r = circle[2];\\n            for(int i = -r; i <= r; i++) {\\n                for(int j = -r; j <= r; j++) {\\n                    if(i*i + j*j <= r*r) {\\n                        set1.insert({i + x, j + y});\\n                    }\\n                }\\n            }\\n        }\\n        int res = set1.size();\\n        return res;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        Set<Pair<Integer, Integer>> set = new HashSet<>();\\n        for(int[] circle: circles) {\\n            int x = circle[0], y = circle[1], r = circle[2];\\n            for(int i = -r; i <= r; i++) {\\n                for(int j = -r; j <= r; j++) {\\n                    if(i*i + j*j <= r*r) {\\n                        set.add(new Pair<>(i + x, j + y));\\n                    }\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200008,
                "title": "c",
                "content": "```\\nbool check(int** circles, int circlesSize, int x,  int y){\\n    \\n    for(int i = 0; i < circlesSize; i++){\\n        int R = circles[i][2] * circles[i][2] ;\\n        int a = circles[i][0] ;\\n        int b = circles[i][1] ;\\n        if( ((x-a)*(x-a) + (y-b)*(y-b)) <= R )\\n            return true ;\\n    }    \\n    return false ;\\n}\\nint countLatticePoints(int** circles, int circlesSize, int* circlesColSize){\\n    int ans = 0; \\n    for(int i = 0; i < 201; i++){\\n        for(int j = 0; j < 201; j++)\\n            ans += check(circles, circlesSize, i, j) ;\\n    }\\n    return ans ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool check(int** circles, int circlesSize, int x,  int y){\\n    \\n    for(int i = 0; i < circlesSize; i++){\\n        int R = circles[i][2] * circles[i][2] ;\\n        int a = circles[i][0] ;\\n        int b = circles[i][1] ;\\n        if( ((x-a)*(x-a) + (y-b)*(y-b)) <= R )\\n            return true ;\\n    }    \\n    return false ;\\n}\\nint countLatticePoints(int** circles, int circlesSize, int* circlesColSize){\\n    int ans = 0; \\n    for(int i = 0; i < 201; i++){\\n        for(int j = 0; j < 201; j++)\\n            ans += check(circles, circlesSize, i, j) ;\\n    }\\n    return ans ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3191959,
                "title": "c-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int n=circles.size();\\n        set<pair<int,int>> s;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=circles[i][0],y=circles[i][1],r=circles[i][2];\\n            \\n            for(int a=x-r;a<=x+r;a++)\\n            {\\n                for(int b=y-r;b<=y+r;b++)\\n                {\\n                    if((a-x)*(a-x)+(b-y)*(b-y)<=r*r)\\n                    {\\n                        s.insert({a,b});\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int n=circles.size();\\n        set<pair<int,int>> s;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=circles[i][0],y=circles[i][1],r=circles[i][2];\\n            \\n            for(int a=x-r;a<=x+r;a++)\\n            {\\n                for(int b=y-r;b<=y+r;b++)\\n                {\\n                    if((a-x)*(a-x)+(b-y)*(b-y)<=r*r)\\n                    {\\n                        s.insert({a,b});\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160661,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) \\n    {\\n        Set<List<Integer>> set=new HashSet<>();\\n        \\n        for(int[] row:circles)\\n        {\\n            int x=row[0];\\n            int y=row[1];\\n            int r=row[2];\\n            \\n            for(int i=x-r;i<=x+r;i++)\\n            {\\n                for(int j=y-r;j<=y+r;j++)\\n                {\\n                    double dist=Math.sqrt(Math.pow(i-x,2)+Math.pow(j-y,2));\\n                    if(dist<=r)\\n                    {\\n                        List<Integer> list=new ArrayList<>();\\n                        list.add(i);\\n                        list.add(j);\\n                        set.add(list);\\n                    }\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n    \\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) \\n    {\\n        Set<List<Integer>> set=new HashSet<>();\\n        \\n        for(int[] row:circles)\\n        {\\n            int x=row[0];\\n            int y=row[1];\\n            int r=row[2];\\n            \\n            for(int i=x-r;i<=x+r;i++)\\n            {\\n                for(int j=y-r;j<=y+r;j++)\\n                {\\n                    double dist=Math.sqrt(Math.pow(i-x,2)+Math.pow(j-y,2));\\n                    if(dist<=r)\\n                    {\\n                        List<Integer> list=new ArrayList<>();\\n                        list.add(i);\\n                        list.add(j);\\n                        set.add(list);\\n                    }\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n    \\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147922,
                "title": "c-solution-with-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConsider the square bounding the circle at 4 points, like a tangent. We know that, no points outside the square will ever belong to the circles. So, consider all points inside the circle and check if they lie in the circles or outside the circle, for each of the circles in the given vector.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheck for the point:\\nLet point = (x1,y1)\\nCentre = (x0,y0)\\nRadius = r\\n\\nIf (x1-x0)^2 + (y1-y0)^2 < r^2, then point lies inside, else outside.\\nStore all the inside points in a set. In the end, return the size of the set.\\n\\n# Complexity\\nFor each circle, with:\\ncentre = (x,y)\\nradius = r\\nR is the maximum radius of all\\n- Time complexity: O(NRR)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(Number of lattice points), which is upper bounded by NRR\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> s;\\n        int n = circles.size();\\n        for(int i=0;i<n;i++){\\n            int cx = circles[i][0], cy = circles[i][1], r = circles[i][2];\\n            int x0 = cx-r;\\n            int x1 = cx+r;\\n            int y0 = cy-r;\\n            int y1 = cy+r;\\n\\n            for(int a = x0; a<= x1; a++){\\n                for(int b = y0;b<=y1;b++){\\n                    if( (a-circles[i][0])*(a-circles[i][0]) + (b-circles[i][1])*(b-circles[i][1]) <= circles[i][2]*circles[i][2])\\n                    s.insert({a,b});\\n                }\\n            }\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> s;\\n        int n = circles.size();\\n        for(int i=0;i<n;i++){\\n            int cx = circles[i][0], cy = circles[i][1], r = circles[i][2];\\n            int x0 = cx-r;\\n            int x1 = cx+r;\\n            int y0 = cy-r;\\n            int y1 = cy+r;\\n\\n            for(int a = x0; a<= x1; a++){\\n                for(int b = y0;b<=y1;b++){\\n                    if( (a-circles[i][0])*(a-circles[i][0]) + (b-circles[i][1])*(b-circles[i][1]) <= circles[i][2]*circles[i][2])\\n                    s.insert({a,b});\\n                }\\n            }\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145996,
                "title": "c-trade-space-for-runtime",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncan[][] is used to record the points\\' status, that is,\\ncan[i][j] = true if (i,j) is in one of circles.\\n\\nUnder the conditions of problem,\\nWe only need to check 0( r<= min(i, j) ) <= i,j <= 100+min(100,100).\\nBesides, we don\\'t need to check (i,j) again if (i,j) is already in previous circle.\\n\\n# Complexity\\n- Time complexity:\\nn = circles.size()\\nO(n * 200 * 200) = O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### This is my Hundredth problem that is Accepted, Yeah. :100:\\n\\n# Code\\n```\\nbool inCircle(int x,int y,int cx,int cy,int r){\\n    if((x-cx)*(x-cx) + (y-cy)*(y-cy) <= r*r) return true;\\n    return false;\\n}\\nclass Solution {\\npublic:\\n   \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int len = circles.size();\\n        bool can[205][205]={false};\\n        \\n        int ans=0;\\n        for(int w=0;w<len;w++){\\n            int cx = circles[w][0];\\n            int cy = circles[w][1];\\n            int r = circles[w][2];\\n            \\n            for(int i=0;i<=200;i++){\\n                for(int j=0;j<=200;j++){\\n                    if(!can[i][j] && inCircle(i,j,cx,cy,r)){\\n                        can[i][j] = true;\\n                        ans ++;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool inCircle(int x,int y,int cx,int cy,int r){\\n    if((x-cx)*(x-cx) + (y-cy)*(y-cy) <= r*r) return true;\\n    return false;\\n}\\nclass Solution {\\npublic:\\n   \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int len = circles.size();\\n        bool can[205][205]={false};\\n        \\n        int ans=0;\\n        for(int w=0;w<len;w++){\\n            int cx = circles[w][0];\\n            int cy = circles[w][1];\\n            int r = circles[w][2];\\n            \\n            for(int i=0;i<=200;i++){\\n                for(int j=0;j<=200;j++){\\n                    if(!can[i][j] && inCircle(i,j,cx,cy,r)){\\n                        can[i][j] = true;\\n                        ans ++;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139817,
                "title": "java-solution-easy-understanding",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        Set<List<Integer>> points = new HashSet<>();\\n        for (int[] circle : circles) {\\n            int x = circle[0];\\n            int y = circle[1];\\n            int r = circle[2];\\n            for (int i = x - r; i <= x + r; i++) {\\n                for (int j = y - r; j <= y + r; j++) {\\n                    double distanceFromCenter = Math.sqrt(Math.pow(i - x, 2) + Math.pow(j - y, 2));\\n                    if (distanceFromCenter <= r) {\\n                        List<Integer> point = new ArrayList<>();\\n                        point.add(i);\\n                        point.add(j);\\n                        points.add(point);\\n                    }\\n                }\\n            }\\n        }\\n        return points.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        Set<List<Integer>> points = new HashSet<>();\\n        for (int[] circle : circles) {\\n            int x = circle[0];\\n            int y = circle[1];\\n            int r = circle[2];\\n            for (int i = x - r; i <= x + r; i++) {\\n                for (int j = y - r; j <= y + r; j++) {\\n                    double distanceFromCenter = Math.sqrt(Math.pow(i - x, 2) + Math.pow(j - y, 2));\\n                    if (distanceFromCenter <= r) {\\n                        List<Integer> point = new ArrayList<>();\\n                        point.add(i);\\n                        point.add(j);\\n                        points.add(point);\\n                    }\\n                }\\n            }\\n        }\\n        return points.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117321,
                "title": "scala-oneliner",
                "content": "# Code\\n```\\nobject Solution {\\n  def countLatticePoints(circles: Array[Array[Int]]): Int = {\\n    circles.map{case Array(a,b,r) => (a,b,r)}.to(Set).asInstanceOf[Set[(Int,Int,Int)]]\\n    .flatMap{case (a:Int,b:Int,r:Int) =>\\n      ((a-r) to (a+r)).flatMap{x=>\\n        ((b-r) to (b+r)).filter{y=>((x-a)*(x-a)+(y-b)*(y-b)<=r*r)}.map(x -> _)\\n      }\\n    }.size\\n  }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Scala",
                    "Geometry"
                ],
                "code": "```\\nobject Solution {\\n  def countLatticePoints(circles: Array[Array[Int]]): Int = {\\n    circles.map{case Array(a,b,r) => (a,b,r)}.to(Set).asInstanceOf[Set[(Int,Int,Int)]]\\n    .flatMap{case (a:Int,b:Int,r:Int) =>\\n      ((a-r) to (a+r)).flatMap{x=>\\n        ((b-r) to (b+r)).filter{y=>((x-a)*(x-a)+(y-b)*(y-b)<=r*r)}.map(x -> _)\\n      }\\n    }.size\\n  }\\n}\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3086750,
                "title": "c-using-set",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> Set;\\n        int xi,yi,ri;\\n        for(auto circle : circles){\\n            xi = circle[0];\\n            yi = circle[1];\\n            ri = circle[2];\\n            for(int x = xi-ri; x <= xi+ri; x++){\\n                for(int y = yi-ri; y <= yi+ri; y++){\\n                    if((y-yi)*(y-yi) + (x-xi)*(x-xi) <= ri*ri){\\n                        Set.insert(make_pair(x,y));\\n                    }\\n                }\\n            }\\n        }\\n        return Set.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> Set;\\n        int xi,yi,ri;\\n        for(auto circle : circles){\\n            xi = circle[0];\\n            yi = circle[1];\\n            ri = circle[2];\\n            for(int x = xi-ri; x <= xi+ri; x++){\\n                for(int y = yi-ri; y <= yi+ri; y++){\\n                    if((y-yi)*(y-yi) + (x-xi)*(x-xi) <= ri*ri){\\n                        Set.insert(make_pair(x,y));\\n                    }\\n                }\\n            }\\n        }\\n        return Set.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058906,
                "title": "easy-maths-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& arr) \\n    {\\n        set<pair<int,int>>st;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int x1 = arr[i][0];\\n            int y1 = arr[i][1];\\n            int r =  arr[i][2];\\n\\n            for(int j=0;j<=200;j++)\\n            {\\n                int x2 = j;\\n                for(int k=0;k<=200;k++)\\n                {\\n                    int y2 = k;\\n                    \\n                    double dis = sqrt(pow((x2-x1),2) + pow((y2-y1),2));\\n                       \\n                    if(dis <= r)\\n                    {\\n                        st.insert(make_pair(x2,y2));\\n                    }\\n\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& arr) \\n    {\\n        set<pair<int,int>>st;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int x1 = arr[i][0];\\n            int y1 = arr[i][1];\\n            int r =  arr[i][2];\\n\\n            for(int j=0;j<=200;j++)\\n            {\\n                int x2 = j;\\n                for(int k=0;k<=200;k++)\\n                {\\n                    int y2 = k;\\n                    \\n                    double dis = sqrt(pow((x2-x1),2) + pow((y2-y1),2));\\n                       \\n                    if(dis <= r)\\n                    {\\n                        st.insert(make_pair(x2,y2));\\n                    }\\n\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052923,
                "title": "c-solution-beats-92-runtime",
                "content": "# Intuition\\nUse the distance formula to check if the point is within a cirlce.\\n\\n# Approach\\nI will create a rectangle that bounds every circle to create a search space, then test every point in that search space. To deal with overlapping, I will break the for loop once a point has been found to be inside at least one circle.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int square(int a){\\n        return a*a;\\n    }\\n    double dist(int x, int y, int a, int b){\\n        double distance = sqrt((square(x - a)) + (square(y - b)));\\n        return distance;\\n    }\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int comp = 0;\\n        int lowerX = circles[0][0] - circles[0][2];\\n        int lowerY = circles[0][1] - circles[0][2];\\n        int upperX = circles[0][0] + circles[0][2];\\n        int upperY = circles[0][1] + circles[0][2];\\n        //Construct the bounds of the bounding rectangle\\n\\n        //Lower X Bound\\n        for (int i = 0; i < circles.size(); i++){\\n            if (circles[i][0] - circles[i][2] < lowerX){\\n                lowerX = circles[i][0] - circles[i][2];\\n            }\\n        }\\n        //Lower Y Bound\\n        for (int i = 0; i < circles.size(); i++){\\n            if (circles[i][1] - circles[i][2] < lowerY){\\n                lowerY = circles[i][1] - circles[i][2];\\n            }\\n        }\\n        //Upper X Bound\\n        for (int i = 0; i < circles.size(); i++){\\n            if (circles[i][0] + circles[i][2] > upperX){\\n                upperX = circles[i][0] + circles[i][2];\\n            }\\n        }\\n        //Upper Y Bound\\n        for (int i = 0; i < circles.size(); i++){\\n            if (circles[i][1] + circles[i][2] > upperY){\\n                upperY = circles[i][1] + circles[i][2];\\n            }\\n        }\\n        for (int x = lowerX; x <= upperX; x++){\\n            for (int y = lowerY; y <= upperY; y++){\\n                for (int i = 0; i < circles.size(); i++){\\n                    if (dist(x, y, circles[i][0], circles[i][1]) <= circles[i][2]){\\n                        comp++;\\n                        break;\\n                    }\\n             }\\n            }\\n        }\\n        return comp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int square(int a){\\n        return a*a;\\n    }\\n    double dist(int x, int y, int a, int b){\\n        double distance = sqrt((square(x - a)) + (square(y - b)));\\n        return distance;\\n    }\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int comp = 0;\\n        int lowerX = circles[0][0] - circles[0][2];\\n        int lowerY = circles[0][1] - circles[0][2];\\n        int upperX = circles[0][0] + circles[0][2];\\n        int upperY = circles[0][1] + circles[0][2];\\n        //Construct the bounds of the bounding rectangle\\n\\n        //Lower X Bound\\n        for (int i = 0; i < circles.size(); i++){\\n            if (circles[i][0] - circles[i][2] < lowerX){\\n                lowerX = circles[i][0] - circles[i][2];\\n            }\\n        }\\n        //Lower Y Bound\\n        for (int i = 0; i < circles.size(); i++){\\n            if (circles[i][1] - circles[i][2] < lowerY){\\n                lowerY = circles[i][1] - circles[i][2];\\n            }\\n        }\\n        //Upper X Bound\\n        for (int i = 0; i < circles.size(); i++){\\n            if (circles[i][0] + circles[i][2] > upperX){\\n                upperX = circles[i][0] + circles[i][2];\\n            }\\n        }\\n        //Upper Y Bound\\n        for (int i = 0; i < circles.size(); i++){\\n            if (circles[i][1] + circles[i][2] > upperY){\\n                upperY = circles[i][1] + circles[i][2];\\n            }\\n        }\\n        for (int x = lowerX; x <= upperX; x++){\\n            for (int y = lowerY; y <= upperY; y++){\\n                for (int i = 0; i < circles.size(); i++){\\n                    if (dist(x, y, circles[i][0], circles[i][1]) <= circles[i][2]){\\n                        comp++;\\n                        break;\\n                    }\\n             }\\n            }\\n        }\\n        return comp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977008,
                "title": "faster-than-fastest-65ms-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOverlapping points?\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMerge intervals\\n\\n# Code\\n```\\ndef countLatticePoints(self, circles: List[List[int]]) -> int:\\n    ivals = [[] for x in range(201)]\\n    for cx,cy,cr in circles:\\n            for k in range(-cr,cr+1):\\n                d = math.floor(math.sqrt(cr*cr - k*k)) # lil bit of geometry\\n                ivals[cx+k].append((cy-d,cy+d)) # add the y interval \\n    res = 0\\n    for x in ivals:\\n        x.sort() # common merge subroutine\\n        last = -1 \\n        for ival in x:\\n            if(ival[1]<=last): continue # will not contribute to ans\\n            res +=(ival[1]-max(ival[0],last+1) + 1)\\n            last = max(ival[1],last)\\n    return res        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef countLatticePoints(self, circles: List[List[int]]) -> int:\\n    ivals = [[] for x in range(201)]\\n    for cx,cy,cr in circles:\\n            for k in range(-cr,cr+1):\\n                d = math.floor(math.sqrt(cr*cr - k*k)) # lil bit of geometry\\n                ivals[cx+k].append((cy-d,cy+d)) # add the y interval \\n    res = 0\\n    for x in ivals:\\n        x.sort() # common merge subroutine\\n        last = -1 \\n        for ival in x:\\n            if(ival[1]<=last): continue # will not contribute to ans\\n            res +=(ival[1]-max(ival[0],last+1) + 1)\\n            last = max(ival[1],last)\\n    return res        \\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2955287,
                "title": "c-beats-100-easy-to-parallelize-o-crlogr-for-max-radius-r-and-c-circles",
                "content": "```\\n#include <iostream>\\n#include <vector>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    inline pair<int, int> get_interval(int x, int y, int rad, int row) {\\n        assert(abs(y - row) <= rad); // We do not support doing rows in which no circle elements are present\\n\\n        // Can be improved by knowing which row you are in specifically, which should narrow down\\n        // your compute to O(1) here instead of O(log(r))\\n        int x_lo = min(x - rad - 1, -1); // You can prove this point is NEVER in the circle\\n        int x_hi = x;                    // You can prove this point is ALWAYS in the circle\\n        int rad2 = rad * rad;\\n        while (x_lo + 1 < x_hi) {\\n            assert(0 <= x_hi && x_hi <= 100);\\n\\n            // This is an x_hi-inclusive BS\\n            int x_mid = x_hi - (x_hi - x_lo) / 2;\\n            assert(0 <= x_mid && x_mid <= 100);\\n\\n            // Distance displacements\\n            int dx = x_mid - x;\\n            int dy = row - y;\\n            if (dx * dx + dy * dy > rad2) x_lo = x_mid; // x_mid Definately NOT in the circle\\n            else x_hi = x_mid;                          // x_mid Definately in the circle\\n        }\\n        assert(0 <= x_hi && x_hi <= 100);\\n\\n        int x_start = x_hi;\\n        int x_end = x + (x - x_hi);\\n        // DEBUG\\n        // cout << \"interval in row \" << row << \" for circle \" << x << \" \" << y << \" \" << rad << \" is \" << x_start << \" \" << x_end << \"\\\\n\"; \\n        return pair<int, int>(x_start, x_end);\\n    }\\n    inline void insert_interval(unordered_map<int, vector<pair<int, int>>>& intervals_rows, int row, pair<int, int> interval) {\\n        // You could use BS here but I got a little lazy and I\\'m also not sure it matters asymptotically unless\\n        // you have some sort of faster way to insert/move around inside the array (i.e. a linkedlist type structure)\\n        assert(intervals_rows[row].size() >= 1);\\n        vector<pair<int, int>>& old_intervals = intervals_rows[row];\\n        vector<pair<int, int>>  new_intervals;\\n        int i = 0;\\n        while (i < old_intervals.size() && old_intervals[i].first < interval.first) { new_intervals.push_back(old_intervals[i]); i++; }\\n\\n        assert(i == new_intervals.size());\\n        if (i > 0 && interval.first <= new_intervals[new_intervals.size() - 1].second) {\\n            int prev_second = new_intervals[new_intervals.size() - 1].second;\\n            new_intervals[new_intervals.size() - 1].second = max(prev_second, interval.second);\\n        } else new_intervals.push_back(interval);\\n\\n        while (i < old_intervals.size() && old_intervals[i].first <= new_intervals[new_intervals.size() - 1].second) {\\n            int prev_second = new_intervals[new_intervals.size() - 1].second;\\n            new_intervals[new_intervals.size() - 1].second = max(prev_second, old_intervals[i].second);\\n            i++;\\n        }\\n        while (i < old_intervals.size()) { new_intervals.push_back(old_intervals[i]); i++; }\\n\\n        intervals_rows[row] = new_intervals;\\n    }\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        unordered_map<int, vector<pair<int, int>>> intervals;\\n        // O(crlog(r)), possible with some high school math to turn into O(cr) if\\n        // there are c circles and each has max radius r\\n        for (vector<int>& circle: circles) {\\n            int x = circle[0]; int y = circle[1]; int rad = circle[2];\\n            for (int row = y - rad; row <= y + rad; row++) {\\n                pair<int, int> interval = get_interval(x, y, rad, row);\\n                if (intervals.find(row) == intervals.end()) {\\n                    intervals[row] = vector<pair<int, int>>(1, interval);\\n                } else {\\n                    // DEBUG\\n                    // cout << \"circle \" << x << \" \" << y << \" \" << rad << \" and row \" << row << \"\\\\n\";\\n                    insert_interval(intervals, row, interval);\\n                }\\n            }\\n        }\\n\\n        // Parallalizeable and good for cache\\n        // Inclusive intervals of all the points inside a circle\\n        int count = 0;\\n        for (auto& _ir : intervals) {\\n            vector<pair<int, int>>& interval_row = _ir.second;\\n            for (pair<int, int>& interval : interval_row) {\\n                assert(interval.first <= interval.second);\\n\\n                int x1 = interval.first; int x2 = interval.second;\\n                count += x2 - x1 + 1; // It\\'s inclusive on both sides\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <iostream>\\n#include <vector>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    inline pair<int, int> get_interval(int x, int y, int rad, int row) {\\n        assert(abs(y - row) <= rad); // We do not support doing rows in which no circle elements are present\\n\\n        // Can be improved by knowing which row you are in specifically, which should narrow down\\n        // your compute to O(1) here instead of O(log(r))\\n        int x_lo = min(x - rad - 1, -1); // You can prove this point is NEVER in the circle\\n        int x_hi = x;                    // You can prove this point is ALWAYS in the circle\\n        int rad2 = rad * rad;\\n        while (x_lo + 1 < x_hi) {\\n            assert(0 <= x_hi && x_hi <= 100);\\n\\n            // This is an x_hi-inclusive BS\\n            int x_mid = x_hi - (x_hi - x_lo) / 2;\\n            assert(0 <= x_mid && x_mid <= 100);\\n\\n            // Distance displacements\\n            int dx = x_mid - x;\\n            int dy = row - y;\\n            if (dx * dx + dy * dy > rad2) x_lo = x_mid; // x_mid Definately NOT in the circle\\n            else x_hi = x_mid;                          // x_mid Definately in the circle\\n        }\\n        assert(0 <= x_hi && x_hi <= 100);\\n\\n        int x_start = x_hi;\\n        int x_end = x + (x - x_hi);\\n        // DEBUG\\n        // cout << \"interval in row \" << row << \" for circle \" << x << \" \" << y << \" \" << rad << \" is \" << x_start << \" \" << x_end << \"\\\\n\"; \\n        return pair<int, int>(x_start, x_end);\\n    }\\n    inline void insert_interval(unordered_map<int, vector<pair<int, int>>>& intervals_rows, int row, pair<int, int> interval) {\\n        // You could use BS here but I got a little lazy and I\\'m also not sure it matters asymptotically unless\\n        // you have some sort of faster way to insert/move around inside the array (i.e. a linkedlist type structure)\\n        assert(intervals_rows[row].size() >= 1);\\n        vector<pair<int, int>>& old_intervals = intervals_rows[row];\\n        vector<pair<int, int>>  new_intervals;\\n        int i = 0;\\n        while (i < old_intervals.size() && old_intervals[i].first < interval.first) { new_intervals.push_back(old_intervals[i]); i++; }\\n\\n        assert(i == new_intervals.size());\\n        if (i > 0 && interval.first <= new_intervals[new_intervals.size() - 1].second) {\\n            int prev_second = new_intervals[new_intervals.size() - 1].second;\\n            new_intervals[new_intervals.size() - 1].second = max(prev_second, interval.second);\\n        } else new_intervals.push_back(interval);\\n\\n        while (i < old_intervals.size() && old_intervals[i].first <= new_intervals[new_intervals.size() - 1].second) {\\n            int prev_second = new_intervals[new_intervals.size() - 1].second;\\n            new_intervals[new_intervals.size() - 1].second = max(prev_second, old_intervals[i].second);\\n            i++;\\n        }\\n        while (i < old_intervals.size()) { new_intervals.push_back(old_intervals[i]); i++; }\\n\\n        intervals_rows[row] = new_intervals;\\n    }\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        unordered_map<int, vector<pair<int, int>>> intervals;\\n        // O(crlog(r)), possible with some high school math to turn into O(cr) if\\n        // there are c circles and each has max radius r\\n        for (vector<int>& circle: circles) {\\n            int x = circle[0]; int y = circle[1]; int rad = circle[2];\\n            for (int row = y - rad; row <= y + rad; row++) {\\n                pair<int, int> interval = get_interval(x, y, rad, row);\\n                if (intervals.find(row) == intervals.end()) {\\n                    intervals[row] = vector<pair<int, int>>(1, interval);\\n                } else {\\n                    // DEBUG\\n                    // cout << \"circle \" << x << \" \" << y << \" \" << rad << \" and row \" << row << \"\\\\n\";\\n                    insert_interval(intervals, row, interval);\\n                }\\n            }\\n        }\\n\\n        // Parallalizeable and good for cache\\n        // Inclusive intervals of all the points inside a circle\\n        int count = 0;\\n        for (auto& _ir : intervals) {\\n            vector<pair<int, int>>& interval_row = _ir.second;\\n            for (pair<int, int>& interval : interval_row) {\\n                assert(interval.first <= interval.second);\\n\\n                int x1 = interval.first; int x2 = interval.second;\\n                count += x2 - x1 + 1; // It\\'s inclusive on both sides\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2906935,
                "title": "c-simple-some-geometry",
                "content": "```\\nclass Solution {\\n    bool inCircle(const vector<int> &circ, int x, int y) {\\n        int dx = (x - circ[0]) * (x - circ[0]); \\n        int dy = (y - circ[1]) * (y - circ[1]);\\n        return dx + dy <= circ[2] * circ[2];\\n    }\\n    unordered_set<int> counted;\\n    inline int index(int x, int y) {\\n        return (x << 8) | y;\\n    }\\n    vector<pair<int,int>> getMinMax(const vector<int>& circ) {\\n        pair<int,int> p1{circ[0] - circ[2], circ[1] - circ[2]};\\n        pair<int,int> p2{circ[0] + circ[2], circ[1] + circ[2]};\\n        return {p1, p2};\\n    }\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int ans = 0;\\n        for(const auto &c : circles) {\\n            auto limits = getMinMax(c);\\n            for(int x = limits[0].first; x <= limits[1].first; ++x) {\\n                for(int y = limits[0].second; y <= limits[1].second; ++y) {\\n                    if(inCircle(c, x, y)) {\\n                        if(counted.count(index(x, y)))\\n                            continue;\\n                        counted.insert(index(x, y));\\n                        ++ans;\\n                    }\\n                }\\n            }            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool inCircle(const vector<int> &circ, int x, int y) {\\n        int dx = (x - circ[0]) * (x - circ[0]); \\n        int dy = (y - circ[1]) * (y - circ[1]);\\n        return dx + dy <= circ[2] * circ[2];\\n    }\\n    unordered_set<int> counted;\\n    inline int index(int x, int y) {\\n        return (x << 8) | y;\\n    }\\n    vector<pair<int,int>> getMinMax(const vector<int>& circ) {\\n        pair<int,int> p1{circ[0] - circ[2], circ[1] - circ[2]};\\n        pair<int,int> p2{circ[0] + circ[2], circ[1] + circ[2]};\\n        return {p1, p2};\\n    }\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int ans = 0;\\n        for(const auto &c : circles) {\\n            auto limits = getMinMax(c);\\n            for(int x = limits[0].first; x <= limits[1].first; ++x) {\\n                for(int y = limits[0].second; y <= limits[1].second; ++y) {\\n                    if(inCircle(c, x, y)) {\\n                        if(counted.count(index(x, y)))\\n                            continue;\\n                        counted.insert(index(x, y));\\n                        ++ans;\\n                    }\\n                }\\n            }            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886441,
                "title": "simple-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) \\n    {\\n       \\n        int n=circles.size();\\n\\n        int i=0;\\n        int cnt=0;\\n        \\n       map<pair<int,int>,bool> mp;\\n        for(i=0; i<n; i++)\\n        {\\n            int x=circles[i][0];\\n            int y=circles[i][1];\\n            int r=circles[i][2];\\n\\n            int j,k;\\n\\n            for(j=x-r; j<=x+r; j++)\\n            {\\n                for(k=y-r; k<=y+r; k++)\\n                {\\n                   if(mp.find({j,k})==mp.end())\\n                   {\\n\\n                   \\n                    if(((j-x)*(j-x)+(k-y)*(k-y))<=r*r)\\n                        {\\n                              mp[{j,k}]=true;\\n                              cnt++;\\n                        }\\n                   }\\n                }\\n            }\\n        }\\n\\n\\n\\n         return cnt;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) \\n    {\\n       \\n        int n=circles.size();\\n\\n        int i=0;\\n        int cnt=0;\\n        \\n       map<pair<int,int>,bool> mp;\\n        for(i=0; i<n; i++)\\n        {\\n            int x=circles[i][0];\\n            int y=circles[i][1];\\n            int r=circles[i][2];\\n\\n            int j,k;\\n\\n            for(j=x-r; j<=x+r; j++)\\n            {\\n                for(k=y-r; k<=y+r; k++)\\n                {\\n                   if(mp.find({j,k})==mp.end())\\n                   {\\n\\n                   \\n                    if(((j-x)*(j-x)+(k-y)*(k-y))<=r*r)\\n                        {\\n                              mp[{j,k}]=true;\\n                              cnt++;\\n                        }\\n                   }\\n                }\\n            }\\n        }\\n\\n\\n\\n         return cnt;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782418,
                "title": "c-solution",
                "content": "Here is my C++ solution. I don\\'t use any hash map, etc. The logic is built on geometry and I introduce a bool matrix to keep track of points I have already counted inside a circle inorder to avoid repetead countings.\\n\\nThe idea is simple - For each circle, using the center and radius, you get a 2d grid that one needs to iterate over. Use the classic distance from center to determine if inside the circle. \\n\\nNow comes the interesting part, you maintain a gird of points that capture all the circles. When a point is marked visited for any circle, you mark it in this boolean array.\\n\\nFollowing is the code - \\n\\nNote - A bit long but good to break down your code into helper functions for better readability! \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> circles;\\n    vector<vector<bool>> counted;\\n    int x_max, x_min, y_max, y_min;\\n        \\n    bool isInside(int x, int y, int x_c, int y_c, int r){\\n        r = r*r;\\n        int dist = (x-x_c)*(x-x_c) + (y-y_c)*(y-y_c);\\n        if(r >= dist)\\n            return true;\\n        return false;\\n    }\\n    \\n    bool isPointConsidered(int x, int y){\\n        int i = x - x_min;\\n        int j = y - y_min;\\n        return counted[i][j];\\n    }\\n    \\n    void markCounted(int x, int y){\\n        int i = x - x_min;\\n        int j = y - y_min;\\n        counted[i][j] = true;\\n        return;\\n    }\\n    \\n    void getPointsInsideCircle(vector<int>& c, vector<pair<int,int>>& points){\\n        int x_min = INT_MAX;\\n        int x_max = INT_MIN;\\n        int y_max = INT_MIN;\\n        int y_min = INT_MAX;\\n\\n        x_max = max(x_max, c[0] + c[2]);\\n        x_min = min(x_min, c[0] - c[2]);\\n        y_max = max(y_max, c[1] + c[2]);\\n        y_min = min(y_min, c[1] - c[2]);\\n\\n        for(int x = x_min ; x <= x_max ; x++){\\n            for(int y = y_min; y <= y_max ; y++){\\n                if(isPointConsidered(x,y))\\n                    continue;\\n                if(isInside(x, y, c[0], c[1], c[2])){\\n                    points.push_back({x,y});\\n                    markCounted(x,y);\\n                }\\n            }\\n        }\\n\\n        return;\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& CIRCLES) {\\n        circles = CIRCLES;\\n        vector<pair<int,int>> points;\\n        \\n        x_min = INT_MAX;\\n        x_max = INT_MIN;\\n        y_max = INT_MIN;\\n        y_min = INT_MAX;\\n        \\n        for(auto c : circles){\\n            x_max = max(x_max, c[0] + c[2]);\\n            x_min = min(x_min, c[0] - c[2]);\\n            y_max = max(y_max, c[1] + c[2]);\\n            y_min = min(y_min, c[1] - c[2]);\\n        }\\n        \\n        counted = vector<vector<bool>> (x_max-x_min+1, vector<bool> (y_max-y_min+1, false));\\n        \\n        for(vector<int> circle : circles){\\n            getPointsInsideCircle(circle, points);\\n        }\\n        \\n        return points.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> circles;\\n    vector<vector<bool>> counted;\\n    int x_max, x_min, y_max, y_min;\\n        \\n    bool isInside(int x, int y, int x_c, int y_c, int r){\\n        r = r*r;\\n        int dist = (x-x_c)*(x-x_c) + (y-y_c)*(y-y_c);\\n        if(r >= dist)\\n            return true;\\n        return false;\\n    }\\n    \\n    bool isPointConsidered(int x, int y){\\n        int i = x - x_min;\\n        int j = y - y_min;\\n        return counted[i][j];\\n    }\\n    \\n    void markCounted(int x, int y){\\n        int i = x - x_min;\\n        int j = y - y_min;\\n        counted[i][j] = true;\\n        return;\\n    }\\n    \\n    void getPointsInsideCircle(vector<int>& c, vector<pair<int,int>>& points){\\n        int x_min = INT_MAX;\\n        int x_max = INT_MIN;\\n        int y_max = INT_MIN;\\n        int y_min = INT_MAX;\\n\\n        x_max = max(x_max, c[0] + c[2]);\\n        x_min = min(x_min, c[0] - c[2]);\\n        y_max = max(y_max, c[1] + c[2]);\\n        y_min = min(y_min, c[1] - c[2]);\\n\\n        for(int x = x_min ; x <= x_max ; x++){\\n            for(int y = y_min; y <= y_max ; y++){\\n                if(isPointConsidered(x,y))\\n                    continue;\\n                if(isInside(x, y, c[0], c[1], c[2])){\\n                    points.push_back({x,y});\\n                    markCounted(x,y);\\n                }\\n            }\\n        }\\n\\n        return;\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& CIRCLES) {\\n        circles = CIRCLES;\\n        vector<pair<int,int>> points;\\n        \\n        x_min = INT_MAX;\\n        x_max = INT_MIN;\\n        y_max = INT_MIN;\\n        y_min = INT_MAX;\\n        \\n        for(auto c : circles){\\n            x_max = max(x_max, c[0] + c[2]);\\n            x_min = min(x_min, c[0] - c[2]);\\n            y_max = max(y_max, c[1] + c[2]);\\n            y_min = min(y_min, c[1] - c[2]);\\n        }\\n        \\n        counted = vector<vector<bool>> (x_max-x_min+1, vector<bool> (y_max-y_min+1, false));\\n        \\n        for(vector<int> circle : circles){\\n            getPointsInsideCircle(circle, points);\\n        }\\n        \\n        return points.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771921,
                "title": "python-save-time-by-removing-duplication",
                "content": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        st = set()\\n        for x, y, r in list(map(list, set(map(tuple, circles)))):\\n            lst_x = range(x - r, x + r + 1)\\n            lst_y = range(y - r, y + r + 1)\\n            st |= set([(nx, ny) for nx in lst_x for ny in lst_y if\\n                       (nx - x) ** 2 + (ny - y) ** 2 <= r ** 2])\\n        return len(st)\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        st = set()\\n        for x, y, r in list(map(list, set(map(tuple, circles)))):\\n            lst_x = range(x - r, x + r + 1)\\n            lst_y = range(y - r, y + r + 1)\\n            st |= set([(nx, ny) for nx in lst_x for ny in lst_y if\\n                       (nx - x) ** 2 + (ny - y) ** 2 <= r ** 2])\\n        return len(st)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726984,
                "title": "easy-python-code",
                "content": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        \\n        cords = set()\\n        for circle in circles:\\n            x, y, r = circle[0], circle[1], circle[2]\\n            for valX in range(x-r, x+r+1):\\n                for valY in range(y-r, y+r+1):\\n                    if ((valX,valY) not in cords) and (pow(valX-x,2) + pow(valY-y, 2) <= pow(r, 2)):\\n                        cords.add((valX,valY))\\n        return len(cords)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        \\n        cords = set()\\n        for circle in circles:\\n            x, y, r = circle[0], circle[1], circle[2]\\n            for valX in range(x-r, x+r+1):\\n                for valY in range(y-r, y+r+1):\\n                    if ((valX,valY) not in cords) and (pow(valX-x,2) + pow(valY-y, 2) <= pow(r, 2)):\\n                        cords.add((valX,valY))\\n        return len(cords)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666555,
                "title": "interview-followup-optimize-for-the-case-when-there-are-many-large-circles",
                "content": "Most people are using the cubic method of explicitly enumerating all points in each circle. That\\'s \"cubic\" in the sense of O(number of circles * area of circle) (area is approximately quadratic in radius). This is a fine approach when the number of circles times their area is small compared to the size of the grid.\\n\\nWhen the grid is mostly occupied, another approach comes into play.\\n\\nInstead of lattice points, imagine vertical lattice \"segments\" connecting highest and lowest lattice point with the same X coordinate in a given circle. Record the length of each segment. After doing all circle, scan each column of the array and accumulate the segment lengths, taking care to not double-count overlapping segments.\\n\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        grid = [[0]*202 for i in range(202)]\\n        for x,y,r in circles:\\n            for j in range(-r,r+1):\\n                k = int(sqrt(r*r-j*j))\\n                grid[x+j][y-k] = max(grid[x+j][y-k], 2*k+1)\\n        ans = 0\\n        for i in range(202):\\n            n = 0\\n            for j in range(202):\\n                n = max(n, grid[i][j])\\n                ans += (n>0)\\n                n = max(0,n-1)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        grid = [[0]*202 for i in range(202)]\\n        for x,y,r in circles:\\n            for j in range(-r,r+1):\\n                k = int(sqrt(r*r-j*j))\\n                grid[x+j][y-k] = max(grid[x+j][y-k], 2*k+1)\\n        ans = 0\\n        for i in range(202):\\n            n = 0\\n            for j in range(202):\\n                n = max(n, grid[i][j])\\n                ans += (n>0)\\n                n = max(0,n-1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643604,
                "title": "loop-on-the-circles-points",
                "content": "# Code\\n```\\n/**\\n * @param {number[][]} circles\\n * @return {number}\\n */\\nvar countLatticePoints = function(circles) {\\n      const points = [];\\n      const usedCircles = [];\\n      circles.forEach(c => {\\n          const [xc,yc,rc] = c;\\n          if(usedCircles.includes(`(${xc},${yc},${rc})`)) return;\\n          usedCircles.push(`(${xc},${yc},${rc})`)\\n          for(let x=xc-rc;x<=xc+rc;x++){\\n             for(let y = yc-rc;y<=yc+rc;y++){\\n              const cdata = Math.pow((x-xc),2)+Math.pow((y-yc),2);\\n              const rp = Math.pow(rc,2);\\n              if(cdata <= rp) points.push(`(${x},${y})`)\\n            } \\n          }\\n      })\\n      return [...new Set(points)].length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} circles\\n * @return {number}\\n */\\nvar countLatticePoints = function(circles) {\\n      const points = [];\\n      const usedCircles = [];\\n      circles.forEach(c => {\\n          const [xc,yc,rc] = c;\\n          if(usedCircles.includes(`(${xc},${yc},${rc})`)) return;\\n          usedCircles.push(`(${xc},${yc},${rc})`)\\n          for(let x=xc-rc;x<=xc+rc;x++){\\n             for(let y = yc-rc;y<=yc+rc;y++){\\n              const cdata = Math.pow((x-xc),2)+Math.pow((y-yc),2);\\n              const rp = Math.pow(rc,2);\\n              if(cdata <= rp) points.push(`(${x},${y})`)\\n            } \\n          }\\n      })\\n      return [...new Set(points)].length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2632221,
                "title": "c-easy-to-understand-maths",
                "content": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> s;\\n        for(auto circle : circles)\\n        {\\n            int x = circle[0];\\n            int y = circle[1];\\n            int r = circle[2];\\n            int count = 0;\\n            for(int i = x-r;i<=r+x;i++)\\n            {\\n                for(int j = y-r;j<=r+y;j++)\\n                {\\n                    if((i-x)*(i-x)+(j-y)*(j-y)<=r*r)\\n                        s.insert({i,j});\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> s;\\n        for(auto circle : circles)\\n        {\\n            int x = circle[0];\\n            int y = circle[1];\\n            int r = circle[2];\\n            int count = 0;\\n            for(int i = x-r;i<=r+x;i++)\\n            {\\n                for(int j = y-r;j<=r+y;j++)\\n                {\\n                    if((i-x)*(i-x)+(j-y)*(j-y)<=r*r)\\n                        s.insert({i,j});\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572032,
                "title": "python-geometry",
                "content": "```\\ndef countLatticePoints(self, circles: List[List[int]]) -> int:\\n      \\n        out = set()\\n        for i in range(len(circles)):\\n            i_center = circles[i][0]\\n            j_center = circles[i][1]\\n            radius = circles[i][2]\\n            for ii in range(i_center-radius, i_center+radius+1):\\n                for jj in range(j_center-radius, j_center+radius+1):\\n                    if (ii,jj) not in out:\\n                        if sqrt((ii-i_center)**2 + (jj-j_center)**2) <= radius:\\n                            out.add((ii, jj))\\n                        \\n\\n        return len(out)\\n",
                "solutionTags": [],
                "code": "```\\ndef countLatticePoints(self, circles: List[List[int]]) -> int:\\n      \\n        out = set()\\n        for i in range(len(circles)):\\n            i_center = circles[i][0]\\n            j_center = circles[i][1]\\n            radius = circles[i][2]\\n            for ii in range(i_center-radius, i_center+radius+1):\\n                for jj in range(j_center-radius, j_center+radius+1):\\n                    if (ii,jj) not in out:\\n                        if sqrt((ii-i_center)**2 + (jj-j_center)**2) <= radius:\\n                            out.add((ii, jj))\\n                        \\n\\n        return len(out)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2536396,
                "title": "c-93-ms",
                "content": "```\\nint countLatticePoints(vector<vector<int>>& circles) {\\n        \\n        vector<vector<bool>> pp(201, vector<bool>(201, false));\\n        int ans = 0;\\n        \\n        for(auto &circle : circles)\\n        {\\n\\t\\t\\t// circle centers\\n            int x = circle[0];\\n            int y = circle[1];\\n            int r = circle[2];\\n\\n\\t\\t\\t// iterating through all integer points\\n            for(int i = x - r; i<= x+r; i++)\\n            {\\n\\t\\t\\t\\t// finding the range for y cordinates\\n                int l = r*r - (x - i)*(x - i);\\n                l = sqrt(l);\\n\\n                for(int j = y - l; j<= y+l; j++)\\n                {\\n                    if(!pp[i][j]) ans++;\\n                    pp[i][j] = true;\\n                    \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countLatticePoints(vector<vector<int>>& circles) {\\n        \\n        vector<vector<bool>> pp(201, vector<bool>(201, false));\\n        int ans = 0;\\n        \\n        for(auto &circle : circles)\\n        {\\n\\t\\t\\t// circle centers\\n            int x = circle[0];\\n            int y = circle[1];\\n            int r = circle[2];\\n\\n\\t\\t\\t// iterating through all integer points\\n            for(int i = x - r; i<= x+r; i++)\\n            {\\n\\t\\t\\t\\t// finding the range for y cordinates\\n                int l = r*r - (x - i)*(x - i);\\n                l = sqrt(l);\\n\\n                for(int j = y - l; j<= y+l; j++)\\n                {\\n                    if(!pp[i][j]) ans++;\\n                    pp[i][j] = true;\\n                    \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2509383,
                "title": "faster-than-98-solution-non-brute-force",
                "content": "Actually you only need to record the change of value in the graph for each circle\\n\\n```\\n public int countLatticePoints(int[][] circles) {\\n        int graphSize=200;\\n        int[][]graph=new int[graphSize][graphSize];\\n        // add to difference\\n        for (int i [] :circles){\\n            // scan from top to down\\n            // y value\\n            for (int j=i[1]-i[2],delta;j<=i[1]+i[2];j++){\\n                // x value\\n                delta=(int) Math.sqrt(Math.pow(i[2], 2)-Math.pow(j-i[1], 2))+1;\\n                graph[j][i[0]-delta+1]+=1;\\n                graph[j][i[0]+delta]-=1;\\n            }\\n        }\\n        int latticeCount=0;\\n        //printArray(graph);\\n        // count value\\n        for(int i =0;i<graphSize;i++){\\n            for (int j=0,value=0;j<graphSize;j++){\\n                value+=graph[i][j];\\n                if(value>0){\\n                    latticeCount++;\\n                }\\n            }\\n        }\\n        return latticeCount;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int countLatticePoints(int[][] circles) {\\n        int graphSize=200;\\n        int[][]graph=new int[graphSize][graphSize];\\n        // add to difference\\n        for (int i [] :circles){\\n            // scan from top to down\\n            // y value\\n            for (int j=i[1]-i[2],delta;j<=i[1]+i[2];j++){\\n                // x value\\n                delta=(int) Math.sqrt(Math.pow(i[2], 2)-Math.pow(j-i[1], 2))+1;\\n                graph[j][i[0]-delta+1]+=1;\\n                graph[j][i[0]+delta]-=1;\\n            }\\n        }\\n        int latticeCount=0;\\n        //printArray(graph);\\n        // count value\\n        for(int i =0;i<graphSize;i++){\\n            for (int j=0,value=0;j<graphSize;j++){\\n                value+=graph[i][j];\\n                if(value>0){\\n                    latticeCount++;\\n                }\\n            }\\n        }\\n        return latticeCount;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2467854,
                "title": "c-solution-count-lattice-points-inside-a-circle",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        \\n    int a,b,r;\\n        \\n    int x0, x1;\\n    int y0, y1;\\n    int value;\\n    vector<pair<int,int>> v;\\n    int r2;\\n    int matrix[305][305] = {0};\\n    int count = 0;\\n        \\n        \\n    for (int i = 0; i < circles.size(); i++)\\n    {\\n        a = circles[i][0];\\n        b = circles[i][1];\\n        r = circles[i][2];\\n          \\n        x0 = a - r;\\n        x1 = a + r;\\n        y0 = b - r;\\n        y1 = b + r;\\n        \\n        for (int j = x0; j <= x1; j++)   \\n            for (int k = y0; k <= y1; k++)\\n            {\\n                value = (j - a)*(j - a) + (k - b)*(k - b);\\n                r2 = r*r;\\n                if (value <= r*r)\\n                    matrix[j][k] = 1;\\n            }\\n        \\n    }\\n      \\n    for (int i = 0; i < 305; i++)\\n        for (int j = 0; j < 305; j++)\\n            if (matrix[i][j] == 1)\\n                count++;\\n\\n        \\n     return(count); \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        \\n    int a,b,r;\\n        \\n    int x0, x1;\\n    int y0, y1;\\n    int value;\\n    vector<pair<int,int>> v;\\n    int r2;\\n    int matrix[305][305] = {0};\\n    int count = 0;\\n        \\n        \\n    for (int i = 0; i < circles.size(); i++)\\n    {\\n        a = circles[i][0];\\n        b = circles[i][1];\\n        r = circles[i][2];\\n          \\n        x0 = a - r;\\n        x1 = a + r;\\n        y0 = b - r;\\n        y1 = b + r;\\n        \\n        for (int j = x0; j <= x1; j++)   \\n            for (int k = y0; k <= y1; k++)\\n            {\\n                value = (j - a)*(j - a) + (k - b)*(k - b);\\n                r2 = r*r;\\n                if (value <= r*r)\\n                    matrix[j][k] = 1;\\n            }\\n        \\n    }\\n      \\n    for (int i = 0; i < 305; i++)\\n        for (int j = 0; j < 305; j++)\\n            if (matrix[i][j] == 1)\\n                count++;\\n\\n        \\n     return(count); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441165,
                "title": "python3-using-set-and-dictionary",
                "content": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        \\n        #remove the duplicated circles:\\n        circles = list(set(tuple(i) for i in circles))\\n        \\n        points={}\\n        for circle in circles:\\n            xc, yc, r = circle[0], circle[1], circle[2]\\n            for x in range(xc-r, xc+r+1):\\n                for y in range(yc-r, yc+r+1):\\n                    if((xc-x)**2+(yc-y)**2)<=r**2:\\n                        if (x,y) not in points.keys():\\n                            points[(x,y)]=1\\n        return len(points)\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        \\n        #remove the duplicated circles:\\n        circles = list(set(tuple(i) for i in circles))\\n        \\n        points={}\\n        for circle in circles:\\n            xc, yc, r = circle[0], circle[1], circle[2]\\n            for x in range(xc-r, xc+r+1):\\n                for y in range(yc-r, yc+r+1):\\n                    if((xc-x)**2+(yc-y)**2)<=r**2:\\n                        if (x,y) not in points.keys():\\n                            points[(x,y)]=1\\n        return len(points)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435347,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int n = circles.size();\\n        set<pair<int,int> > st;\\n        for(int i=0;i<n;i++){\\n            int xi = circles[i][0];\\n            int yi = circles[i][1];\\n            int ri = circles[i][2];\\n            \\n            for(int x = (- ri) ; x <= ( ri) ; x++){\\n                for(int y = ( -ri) ; y <= (ri) ; y++){\\n                    if( (x) * (x) + (y) * (y) <= ri*ri){\\n                        st.insert({xi+x,yi+y});\\n                    }\\n                }\\n            }\\n\\n        }\\n        int size = st.size();\\n        return size;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int n = circles.size();\\n        set<pair<int,int> > st;\\n        for(int i=0;i<n;i++){\\n            int xi = circles[i][0];\\n            int yi = circles[i][1];\\n            int ri = circles[i][2];\\n            \\n            for(int x = (- ri) ; x <= ( ri) ; x++){\\n                for(int y = ( -ri) ; y <= (ri) ; y++){\\n                    if( (x) * (x) + (y) * (y) <= ri*ri){\\n                        st.insert({xi+x,yi+y});\\n                    }\\n                }\\n            }\\n\\n        }\\n        int size = st.size();\\n        return size;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377921,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>s;\\n        int n=circles.size();\\n        for(int k=0;k<n;k++){\\n            int x=circles[k][0];\\n            int y=circles[k][1];\\n            int r=circles[k][2];\\n            \\n            for(int i=x-r;i<=x+r;i++){\\n                for(int j=y-r;j<=y+r;j++){\\n                    if((i-x)*(i-x)+(j-y)*(j-y)<=r*r){\\n                        s.insert({i,j});\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>s;\\n        int n=circles.size();\\n        for(int k=0;k<n;k++){\\n            int x=circles[k][0];\\n            int y=circles[k][1];\\n            int r=circles[k][2];\\n            \\n            for(int i=x-r;i<=x+r;i++){\\n                for(int j=y-r;j<=y+r;j++){\\n                    if((i-x)*(i-x)+(j-y)*(j-y)<=r*r){\\n                        s.insert({i,j});\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342739,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn count_lattice_points(c: Vec<Vec<i32>>) -> i32 {\\n        let mut m=[0;40401];\\n        for v in c.into_iter() {\\n            let (x,y,r) = (v[0],v[1],v[2]);\\n            for i in x-r..x+r+1 {\\n                let d=((r*r-(x-i)*(x-i)) as f64).sqrt() as i32; \\n                for j in i*201+y-d..i*201+y+d+1 {m[j as usize]=1;}\\n            }    \\n        }\\n        m.iter().sum::<i32>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_lattice_points(c: Vec<Vec<i32>>) -> i32 {\\n        let mut m=[0;40401];\\n        for v in c.into_iter() {\\n            let (x,y,r) = (v[0],v[1],v[2]);\\n            for i in x-r..x+r+1 {\\n                let d=((r*r-(x-i)*(x-i)) as f64).sqrt() as i32; \\n                for j in i*201+y-d..i*201+y+d+1 {m[j as usize]=1;}\\n            }    \\n        }\\n        m.iter().sum::<i32>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2283104,
                "title": "brute-force-question-but-optimized-greatly-using-binary-search",
                "content": "```\\n    int count(int rad,int i){\\n        int l=0,r=rad,res=0;\\n        rad*=rad;\\n        \\n        while(l<=r){\\n            int m=(l+r)/2;\\n            int v=i*i+m*m;\\n            \\n            if(v>rad)\\n                r=m-1;\\n            else{\\n                res=m;\\n                l=m+1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        vector<vector<bool>> dp(201,vector<bool>(201,false));\\n        \\n        for(auto v:circles){\\n            int a=v[0],b=v[1],r=v[2];\\n            \\n            dp[a][b]=true;\\n            //traversing all line segments first\\n            for(int i=1;i<=r;i++){\\n                dp[a][b+i]=dp[a][b-i]=true;\\n                dp[a-i][b]=dp[a+i][b]=true;\\n            }\\n            \\n            for(int j=1;j<r;j++){\\n                int cnt=count(r,j);\\n                for(int i=1;i<=cnt;i++){\\n                    dp[a+i][b+j]=dp[a+i][b-j]=true;\\n                    dp[a-i][b+j]=dp[a-i][b-j]=true;\\n                }\\n            }\\n        }\\n        \\n        int res=0;\\n        for(int i=0;i<201;i++){\\n            for(int j=0;j<201;j++)\\n                if(dp[i][j])\\n                    res++;\\n        }\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int count(int rad,int i){\\n        int l=0,r=rad,res=0;\\n        rad*=rad;\\n        \\n        while(l<=r){\\n            int m=(l+r)/2;\\n            int v=i*i+m*m;\\n            \\n            if(v>rad)\\n                r=m-1;\\n            else{\\n                res=m;\\n                l=m+1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        vector<vector<bool>> dp(201,vector<bool>(201,false));\\n        \\n        for(auto v:circles){\\n            int a=v[0],b=v[1],r=v[2];\\n            \\n            dp[a][b]=true;\\n            //traversing all line segments first\\n            for(int i=1;i<=r;i++){\\n                dp[a][b+i]=dp[a][b-i]=true;\\n                dp[a-i][b]=dp[a+i][b]=true;\\n            }\\n            \\n            for(int j=1;j<r;j++){\\n                int cnt=count(r,j);\\n                for(int i=1;i<=cnt;i++){\\n                    dp[a+i][b+j]=dp[a+i][b-j]=true;\\n                    dp[a-i][b+j]=dp[a-i][b-j]=true;\\n                }\\n            }\\n        }\\n        \\n        int res=0;\\n        for(int i=0;i<201;i++){\\n            for(int j=0;j<201;j++)\\n                if(dp[i][j])\\n                    res++;\\n        }\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2282355,
                "title": "easy-c-optimum-solution-beats-85-in-o-1-space",
                "content": "First we need to find what can be possible values of x and y basically range then just simpily check that it is in the range or not by circle equation\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int ans=0;\\n        int min_x=200;\\n        int max_x=0;\\n        int min_y=200;\\n        int max_y=0;\\n        for(int k=0;k<circles.size();k++){\\n            min_x=min(min_x,circles[k][0]-circles[k][2]);\\n            max_x=max(max_x,circles[k][0]+circles[k][2]);\\n            min_y=min(min_y,circles[k][1]-circles[k][2]);\\n            max_y=max(max_y,circles[k][1]+circles[k][2]);\\n        }\\n        for(int i=min_x;i<=max_x;i++){\\n            for(int j=min_y;j<=max_y;j++){\\n                bool flag=false;\\n                for(int k=0;k<circles.size();k++){\\n                    int l1=(circles[k][0]-i)*(circles[k][0]-i) +(circles[k][1]-j)*(circles[k][1]-j);\\n                    if(l1<=((circles[k][2])*(circles[k][2]))){\\n                        flag=true;\\n                        break;\\n                    }\\n                }\\n                if(flag){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int ans=0;\\n        int min_x=200;\\n        int max_x=0;\\n        int min_y=200;\\n        int max_y=0;\\n        for(int k=0;k<circles.size();k++){\\n            min_x=min(min_x,circles[k][0]-circles[k][2]);\\n            max_x=max(max_x,circles[k][0]+circles[k][2]);\\n            min_y=min(min_y,circles[k][1]-circles[k][2]);\\n            max_y=max(max_y,circles[k][1]+circles[k][2]);\\n        }\\n        for(int i=min_x;i<=max_x;i++){\\n            for(int j=min_y;j<=max_y;j++){\\n                bool flag=false;\\n                for(int k=0;k<circles.size();k++){\\n                    int l1=(circles[k][0]-i)*(circles[k][0]-i) +(circles[k][1]-j)*(circles[k][1]-j);\\n                    if(l1<=((circles[k][2])*(circles[k][2]))){\\n                        flag=true;\\n                        break;\\n                    }\\n                }\\n                if(flag){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271592,
                "title": "intuitive-geo",
                "content": "```\\nclass Solution {\\n    \\n    set<pair<int, int>> points_;\\n    \\n    bool in_circle(int x, int y, int cx, int cy, int r) {\\n        return pow(x - cx, 2) + pow(y - cy, 2) <= pow(r, 2);\\n    }\\n    \\n    void add_points(const vector<int>& c) {\\n        auto x = c[0];\\n        auto y = c[1];\\n        auto r = c[2];\\n        \\n        for (int i = x - r; i <= x + r; ++i) {\\n            for (int j = y - r; j <= y + r; ++j) {\\n                if (in_circle(i, j, x, y, r))\\n                    points_.insert({i, j});\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        for (auto c : circles) {\\n            add_points(c);\\n        }\\n        \\n        return points_.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    set<pair<int, int>> points_;\\n    \\n    bool in_circle(int x, int y, int cx, int cy, int r) {\\n        return pow(x - cx, 2) + pow(y - cy, 2) <= pow(r, 2);\\n    }\\n    \\n    void add_points(const vector<int>& c) {\\n        auto x = c[0];\\n        auto y = c[1];\\n        auto r = c[2];\\n        \\n        for (int i = x - r; i <= x + r; ++i) {\\n            for (int j = y - r; j <= y + r; ++j) {\\n                if (in_circle(i, j, x, y, r))\\n                    points_.insert({i, j});\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        for (auto c : circles) {\\n            add_points(c);\\n        }\\n        \\n        return points_.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266951,
                "title": "python3",
                "content": "target_sum={}\\n        for i in numbers:\\n            target_sum[i]=target-i\\n        for i in range(len(numbers)):\\n            try:\\n                j=numbers.index(target_sum[numbers[i]],i+1)\\n                return [i+1,j+1]\\n            except:\\n                pass",
                "solutionTags": [],
                "code": "target_sum={}\\n        for i in numbers:\\n            target_sum[i]=target-i\\n        for i in range(len(numbers)):\\n            try:\\n                j=numbers.index(target_sum[numbers[i]],i+1)\\n                return [i+1,j+1]\\n            except:\\n                pass",
                "codeTag": "Unknown"
            },
            {
                "id": 2250196,
                "title": "simple-math",
                "content": "* Max (x,y) =100, hence max diameter of any circle is 200, and hence max grid size will 200*200.\\n* choose any point in the grid and check wether it lies in any circle or not. if found in any circle just break there, no need to find the same point in another circle.\\n* code for the same is given below\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int n=circles.size();\\n        int ans=0;\\n        for(int i=0;i<=200;i++){\\n            for(int j=0;j<=200;j++){\\n                for(int k=0;k<n;k++){\\n                    int a=circles[k][0],b=circles[k][1],r=circles[k][2];\\n                    if((i-a)*(i-a)+(j-b)*(j-b)<=r*r){\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int n=circles.size();\\n        int ans=0;\\n        for(int i=0;i<=200;i++){\\n            for(int j=0;j<=200;j++){\\n                for(int k=0;k<n;k++){\\n                    int a=circles[k][0],b=circles[k][1],r=circles[k][2];\\n                    if((i-a)*(i-a)+(j-b)*(j-b)<=r*r){\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246173,
                "title": "python-o-m-n",
                "content": "```python\\ndef countLatticePoints(self, circles: List[List[int]]) -> int:\\n        res= 0 \\n        for i in range(0, 201):\\n            a = [0] * 203\\n            for x,y,r in circles:\\n                k = r ** 2 - (i-x) ** 2\\n                if k >= 0:\\n                    r = int(k ** .5) + y \\n                    l = max(0, math.ceil(-int(k ** .5) + y))\\n                    a[l] += 1\\n                    a[r+1] -=1 \\n            for i in range(0, 201):\\n                a[i] += a[i-1]\\n                res += a[i] > 0 \\n        return res \\n\\t\\t```",
                "solutionTags": [],
                "code": "```python\\ndef countLatticePoints(self, circles: List[List[int]]) -> int:\\n        res= 0 \\n        for i in range(0, 201):\\n            a = [0] * 203\\n            for x,y,r in circles:\\n                k = r ** 2 - (i-x) ** 2\\n                if k >= 0:\\n                    r = int(k ** .5) + y \\n                    l = max(0, math.ceil(-int(k ** .5) + y))\\n                    a[l] += 1\\n                    a[r+1] -=1 \\n            for i in range(0, 201):\\n                a[i] += a[i-1]\\n                res += a[i] > 0 \\n        return res \\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 2236378,
                "title": "python-speedy-but-greedy-solution",
                "content": "import itertools\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        result=set()\\n        circles1=set()\\n        for i in circles:\\n            circles1.add((i[0],i[1],i[2]))\\n        for circle in circles1:\\n            for i in range(circle[0]-circle[2],circle[0]+circle[2]+1):\\n                for j in range(circle[1]-circle[2],circle[1]+circle[2]+1):\\n                    if ((circle[0]-i)**2+(circle[1]-j)**2) <=circle[2]**2: result.add((i,j))\\n        print(result)\\n        return len(result)",
                "solutionTags": [],
                "code": "import itertools\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        result=set()\\n        circles1=set()\\n        for i in circles:\\n            circles1.add((i[0],i[1],i[2]))\\n        for circle in circles1:\\n            for i in range(circle[0]-circle[2],circle[0]+circle[2]+1):\\n                for j in range(circle[1]-circle[2],circle[1]+circle[2]+1):\\n                    if ((circle[0]-i)**2+(circle[1]-j)**2) <=circle[2]**2: result.add((i,j))\\n        print(result)\\n        return len(result)",
                "codeTag": "Java"
            },
            {
                "id": 2178731,
                "title": "easy-brute-force-with-small-changes",
                "content": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> m;\\n    int countLatticePoints(vector<vector<int>>& c) {\\n        for(int k=0;k<c.size();k++){\\n        int x=c[k][0];\\n        int y=c[k][1];\\n        int r=c[k][2];\\n        for(int i=0;i<=r;i++){\\n            for(int j=0;j<=r;j++){\\n                if(i*i+j*j>r*r) break;\\n\\t\\t\\t\\t#check for one quarter of circle and we can store mirror image of that point in four quarters of that circle\\n                m[{x-i,y-j}]++;\\n                m[{x-i,y+j}]++;\\n                m[{x+i,y-j}]++;\\n                m[{x+i,y+j}]++;\\n            }\\n        }\\n    }\\n    int ans=0;\\n        for(auto i:m) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> m;\\n    int countLatticePoints(vector<vector<int>>& c) {\\n        for(int k=0;k<c.size();k++){\\n        int x=c[k][0];\\n        int y=c[k][1];\\n        int r=c[k][2];\\n        for(int i=0;i<=r;i++){\\n            for(int j=0;j<=r;j++){\\n                if(i*i+j*j>r*r) break;\\n\\t\\t\\t\\t#check for one quarter of circle and we can store mirror image of that point in four quarters of that circle\\n                m[{x-i,y-j}]++;\\n                m[{x-i,y+j}]++;\\n                m[{x+i,y-j}]++;\\n                m[{x+i,y+j}]++;\\n            }\\n        }\\n    }\\n    int ans=0;\\n        for(auto i:m) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124590,
                "title": "javascript-solution-brute-force-euclidean-distance",
                "content": "```\\nvar countLatticePoints = function(circles) {\\n    const set = new Set();\\n    \\n    for (const [x, y, radius] of circles) {\\n        const startX = x - radius;\\n        const startY = y - radius;\\n        \\n        const endX = x + radius;\\n        const endY = y + radius;\\n        \\n        for (let currX = startX; currX <= endX; ++currX) {\\n            for (let currY = startY; currY <= endY; ++currY) {\\n                const dist = getEuclideanDist(currX, currY, x, y);\\n                \\n                if (dist <= radius) set.add(`${currX}#${currY}`);\\n            }\\n        }\\n    }\\n    \\n    return set.size;\\n    \\n    \\n    function getEuclideanDist(x1, y1, x2, y2) {\\n        return Math.sqrt((x1 - x2)**2 + (y1 - y2)**2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countLatticePoints = function(circles) {\\n    const set = new Set();\\n    \\n    for (const [x, y, radius] of circles) {\\n        const startX = x - radius;\\n        const startY = y - radius;\\n        \\n        const endX = x + radius;\\n        const endY = y + radius;\\n        \\n        for (let currX = startX; currX <= endX; ++currX) {\\n            for (let currY = startY; currY <= endY; ++currY) {\\n                const dist = getEuclideanDist(currX, currY, x, y);\\n                \\n                if (dist <= radius) set.add(`${currX}#${currY}`);\\n            }\\n        }\\n    }\\n    \\n    return set.size;\\n    \\n    \\n    function getEuclideanDist(x1, y1, x2, y2) {\\n        return Math.sqrt((x1 - x2)**2 + (y1 - y2)**2);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2103370,
                "title": "doubt",
                "content": "class Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& c) \\n    {\\n        int cnt=0;\\n        for(int i=0;i<=200;i++)\\n        {\\n            for(int j=0;j<=200;j++)\\n            {\\n                for(int k=0;k<c.size();k++)\\n                {\\n                    int dis1=(i-c[k][0])*(i-c[k][0])+(j-c[k][1])*(j-c[k][1]);\\n                    if(dis1<=c[k][2]*c[k][2])\\n                    {\\n                        ++cnt;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& c) \\n    {\\n        int cnt=0;\\n        for(int i=0;i<=200;i++)\\n        {\\n            for(int j=0;j<=200;j++)\\n            {\\n                for(int k=0;k<c.size();k++)\\n                {\\n                    int dis1=(i-c[k][0])*(i-c[k][0])+(j-c[k][1])*(j-c[k][1]);\\n                    if(dis1<=c[k][2]*c[k][2])\\n                    {\\n                        ++cnt;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2056064,
                "title": "python-set",
                "content": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        s=set()\\n        for c in set([tuple(c) for c in circles]):\\n            for x in range(c[0]-c[2],c[0]+c[2]+1):\\n                for y in range(c[1]-c[2],c[1]+c[2]+1):\\n                     if (x-c[0])**2+(y-c[1])**2<=c[2]**2:\\n                            s.add((x,y))\\n        return len(s)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        s=set()\\n        for c in set([tuple(c) for c in circles]):\\n            for x in range(c[0]-c[2],c[0]+c[2]+1):\\n                for y in range(c[1]-c[2],c[1]+c[2]+1):\\n                     if (x-c[0])**2+(y-c[1])**2<=c[2]**2:\\n                            s.add((x,y))\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036917,
                "title": "easy-solution-based-on-circle-equations",
                "content": "```\\nclass Solution {\\n    static int pow (int a){\\n        return a*a;\\n    }\\n    public int countLatticePoints(int[][] circles) {\\n        int count=0;\\n        for(int i=0;i<=200;i++){\\n            for(int j=0;j<=200;j++){\\n                boolean b=false;\\n                for(int k=0;k<circles.length;k++){\\n                    if(pow(i-circles[k][0])+pow(j-circles[k][1])-pow(circles[k][2])<=0){\\n                        b=true;\\n                        break;\\n                    }\\n                }\\n                if(b)count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    static int pow (int a){\\n        return a*a;\\n    }\\n    public int countLatticePoints(int[][] circles) {\\n        int count=0;\\n        for(int i=0;i<=200;i++){\\n            for(int j=0;j<=200;j++){\\n                boolean b=false;\\n                for(int k=0;k<circles.length;k++){\\n                    if(pow(i-circles[k][0])+pow(j-circles[k][1])-pow(circles[k][2])<=0){\\n                        b=true;\\n                        break;\\n                    }\\n                }\\n                if(b)count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026539,
                "title": "c-beat-87",
                "content": "By the way, this problem is really meaningless...\\n```\\n#include <algorithm>  \\n#include <iostream>  \\n#include <cstring>\\n#include <string>  \\n#include <vector>  \\n#include <stack>  \\n#include <set>  \\n#include <list>  \\n#include <deque>  \\n#include <map>  \\n#include <queue> \\n#include <unordered_map>  \\n#include <unordered_set> \\n#define inf 0x3f3f3f3f\\n#define ff first\\n#define ss second\\n#define ll long long\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n\\tint A[201][201];\\n\\tinline bool in_circle(int& x, int& y, int& x_o, int& y_o, int& r_sq) {\\n\\t\\treturn (x - x_o) * (x - x_o) + (y - y_o) * (y - y_o) <= r_sq;\\n\\t}\\n    int countLatticePoints(vector<vector<int> >& circles) {\\n        memset(A, 0, sizeof(A));\\n\\t\\tfor (int i = 0; i < circles.size(); i++) {\\n\\t\\t\\tint r_sq = circles[i][2] * circles[i][2];\\n\\t\\t\\tfor (int x = circles[i][0] - circles[i][2]; x <= circles[i][0] + circles[i][2]; x++) {\\n\\t\\t\\t\\tfor (int y = circles[i][1] - circles[i][2]; y <= circles[i][1] + circles[i][2]; y++) {\\n\\t\\t\\t\\t\\tif (in_circle(x, y, circles[i][0], circles[i][1], r_sq)) {\\n\\t\\t\\t\\t\\t\\tA[x][y] = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint res = 0;\\n\\t\\tfor (int i = 0; i < 201; i++) {\\n\\t\\t\\tfor (int j = 0; j < 201; j++) {\\n\\t\\t\\t\\tres += A[i][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <algorithm>  \\n#include <iostream>  \\n#include <cstring>\\n#include <string>  \\n#include <vector>  \\n#include <stack>  \\n#include <set>  \\n#include <list>  \\n#include <deque>  \\n#include <map>  \\n#include <queue> \\n#include <unordered_map>  \\n#include <unordered_set> \\n#define inf 0x3f3f3f3f\\n#define ff first\\n#define ss second\\n#define ll long long\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n\\tint A[201][201];\\n\\tinline bool in_circle(int& x, int& y, int& x_o, int& y_o, int& r_sq) {\\n\\t\\treturn (x - x_o) * (x - x_o) + (y - y_o) * (y - y_o) <= r_sq;\\n\\t}\\n    int countLatticePoints(vector<vector<int> >& circles) {\\n        memset(A, 0, sizeof(A));\\n\\t\\tfor (int i = 0; i < circles.size(); i++) {\\n\\t\\t\\tint r_sq = circles[i][2] * circles[i][2];\\n\\t\\t\\tfor (int x = circles[i][0] - circles[i][2]; x <= circles[i][0] + circles[i][2]; x++) {\\n\\t\\t\\t\\tfor (int y = circles[i][1] - circles[i][2]; y <= circles[i][1] + circles[i][2]; y++) {\\n\\t\\t\\t\\t\\tif (in_circle(x, y, circles[i][0], circles[i][1], r_sq)) {\\n\\t\\t\\t\\t\\t\\tA[x][y] = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint res = 0;\\n\\t\\tfor (int i = 0; i < 201; i++) {\\n\\t\\t\\tfor (int j = 0; j < 201; j++) {\\n\\t\\t\\t\\tres += A[i][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2017611,
                "title": "python-use-set-clear-beat-86",
                "content": "class Solution:\\n\\n    def countLatticePoints(self, circles) -> int:\\n        points=set()\\n        for circle in circles:\\n            for x in range(circle[2]+1):\\n                for y in range(circle[2],-1,-1):\\n                    if x ** 2 + y ** 2 <= circle[2] ** 2:\\n                        # for i in range(x+1):\\n                        for j in range(y+1):\\n                            points.add((circle[0]+x, circle[1]+j))\\n                            points.add((circle[0]-x, circle[1]+j))\\n                            points.add((circle[0]+x, circle[1]-j))\\n                            points.add((circle[0]-x, circle[1]-j))\\n                        break\\n        return(len(points))",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def countLatticePoints(self, circles) -> int:\\n        points=set()\\n        for circle in circles:\\n            for x in range(circle[2]+1):\\n                for y in range(circle[2],-1,-1):\\n                    if x ** 2 + y ** 2 <= circle[2] ** 2:\\n                        # for i in range(x+1):\\n                        for j in range(y+1):\\n                            points.add((circle[0]+x, circle[1]+j))\\n                            points.add((circle[0]-x, circle[1]+j))\\n                            points.add((circle[0]+x, circle[1]-j))\\n                            points.add((circle[0]-x, circle[1]-j))\\n                        break\\n        return(len(points))",
                "codeTag": "Java"
            },
            {
                "id": 2011108,
                "title": "easy-to-understand",
                "content": "Hope this will be useful to you. Explanation is in the code. Have a great rest of the day/night ahead.\\n    \\n\\tdef countLatticePoints(self, circles: List[List[int]]) -> int:\\n        \\n        pt={} #to keep track of the points; we can also use set \\n        check=[] # a list to work with all unique circle datas\\n        ret = 0 # returns the count \\n        for circle in circles: # we go through every points\\n            if circle not in check: # checking that if we have never faced the data before\\n                check.append(circle) # adding the data as we checked the point now\\n                x,y,r = circle[0],circle[1],circle[2] \\n                for i in range(x-r,x+r+1):\\n                    for j in range(y-r,y+r+1):\\n                        if ((x-i)**2+(y-j)**2)<=r*r: # using circle formula to check a point is inside of a given circle\\n\\t\\t\\t\\t\\t\\t# formula: A point (h,k) is on or inside of a circle if (x-h)^2+(y-k)^2 <= r^2\\n                            key  = \\'(\\' + str(i) + \\'+\\' + str(j) + \\')\\' # we add the point in our hashtable as key \\'(i+j)\\' and increment the countvalue i.e. ret\\n                            if key not in pt:\\n                                pt[key] = 1\\n                                ret += 1\\n                            else: pt[key] += 1\\n                \\n        #print(pt)\\n        return ret",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "Hope this will be useful to you. Explanation is in the code. Have a great rest of the day/night ahead.\\n    \\n\\tdef countLatticePoints(self, circles: List[List[int]]) -> int:\\n        \\n        pt={} #to keep track of the points; we can also use set \\n        check=[] # a list to work with all unique circle datas\\n        ret = 0 # returns the count \\n        for circle in circles: # we go through every points\\n            if circle not in check: # checking that if we have never faced the data before\\n                check.append(circle) # adding the data as we checked the point now\\n                x,y,r = circle[0],circle[1],circle[2] \\n                for i in range(x-r,x+r+1):\\n                    for j in range(y-r,y+r+1):\\n                        if ((x-i)**2+(y-j)**2)<=r*r: # using circle formula to check a point is inside of a given circle\\n\\t\\t\\t\\t\\t\\t# formula: A point (h,k) is on or inside of a circle if (x-h)^2+(y-k)^2 <= r^2\\n                            key  = \\'(\\' + str(i) + \\'+\\' + str(j) + \\')\\' # we add the point in our hashtable as key \\'(i+j)\\' and increment the countvalue i.e. ret\\n                            if key not in pt:\\n                                pt[key] = 1\\n                                ret += 1\\n                            else: pt[key] += 1\\n                \\n        #print(pt)\\n        return ret",
                "codeTag": "Python3"
            },
            {
                "id": 2005965,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    \\n    boolean isInside(int circle[] ,int x ,int y){\\n        return (x - circle[0])*(x - circle[0]) + (y-circle[1])*(y-circle[1]) -circle[2]*circle[2]<=0; \\n    }\\n    \\n    public int countLatticePoints(int[][] circles) {\\n        int ans = 0;\\n        HashSet<String> set = new HashSet<>() ; \\n        for(int i=0;i<circles.length;i++){\\n            int x = circles [i][0];\\n            int y = circles [i][1];\\n            int r = circles [i][2];\\n            \\n            for(int j = x-r;j<=x+r;j++){\\n                for(int k = y-r;k<=y+r;k++){\\n                    if(isInside(circles[i],j,k))\\n                    {\\n                        if(!set.contains(j+\" \"+k)){\\n                            ans++;\\n                            set.add(j+\" \"+k);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        return ans ;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    boolean isInside(int circle[] ,int x ,int y){\\n        return (x - circle[0])*(x - circle[0]) + (y-circle[1])*(y-circle[1]) -circle[2]*circle[2]<=0; \\n    }\\n    \\n    public int countLatticePoints(int[][] circles) {\\n        int ans = 0;\\n        HashSet<String> set = new HashSet<>() ; \\n        for(int i=0;i<circles.length;i++){\\n            int x = circles [i][0];\\n            int y = circles [i][1];\\n            int r = circles [i][2];\\n            \\n            for(int j = x-r;j<=x+r;j++){\\n                for(int k = y-r;k<=y+r;k++){\\n                    if(isInside(circles[i],j,k))\\n                    {\\n                        if(!set.contains(j+\" \"+k)){\\n                            ans++;\\n                            set.add(j+\" \"+k);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        return ans ;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005646,
                "title": "python-straightforward-beats-95-runtime",
                "content": "Hmm, I guess a little bit overthinking did bring the speed up. So I was worried that I have lots of circles that centre at the same point, then I decided to remove them first. Hence, we have this algorithm that is fairly fast.\\n\\nSo first, we group keep only one circle if multiple is centred at the same point. We keep the largest one of course. Then we just go through each circle, and go through each possible point, and add them to a set.\\n\\n```python\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        found = set()\\n        distance = lambda x, y, cx, cy: (x - cx)**2 + (y - cy)**2\\n        centre_to_radius = {}\\n        for x, y, radius in circles:\\n            centre_to_radius[x, y] = max(centre_to_radius.get((x, y), -1), radius)\\n        for (centre_x, centre_y), radius in centre_to_radius.items():\\n            for x in range(centre_x - radius, centre_x + radius + 1):\\n                for y in range(centre_y - radius, centre_y + radius + 1):\\n                    if (x, y) not in found\\\\\\n                    and distance(x, y, centre_x, centre_y) <= radius * radius:\\n                        found.add((x, y))\\n        return len(found)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        found = set()\\n        distance = lambda x, y, cx, cy: (x - cx)**2 + (y - cy)**2\\n        centre_to_radius = {}\\n        for x, y, radius in circles:\\n            centre_to_radius[x, y] = max(centre_to_radius.get((x, y), -1), radius)\\n        for (centre_x, centre_y), radius in centre_to_radius.items():\\n            for x in range(centre_x - radius, centre_x + radius + 1):\\n                for y in range(centre_y - radius, centre_y + radius + 1):\\n                    if (x, y) not in found\\\\\\n                    and distance(x, y, centre_x, centre_y) <= radius * radius:\\n                        found.add((x, y))\\n        return len(found)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001645,
                "title": "c-solution-100-faster-simple-with-explaining",
                "content": "Three main points:\\n1. For circle [x, y, r], narrow down the possible circled points X: [x-r, x+r] AND Y:[y-r, y+r];\\n2. Judge a point [x+i, x+j] is circled by circle [x, y, r], simply check if (r^2 >= i^2 + j^2);\\n3. Use points[][] to avoid duplicated account.\\n\\n```\\nint countLatticePoints (int** circles, int circlesSize, int* circlesColSize) {\\n    int  i, j, k, x, y, r, count = 0;\\n    char points[201][201] = {{0}};\\n    \\n    for (k = 0; k < circlesSize; k++) {\\n        x = circles[k][0];\\n        y = circles[k][1];\\n        r = circles[k][2];\\n        \\n        for (i = -r; i <= r; i++) {\\n            for (j = -r; j <= r; j++) {\\n                if (points[x+i][y+j] == 0 && r*r >= i*i + j*j) {\\n                    points[x+i][y+j] = 1;\\n                    count++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint countLatticePoints (int** circles, int circlesSize, int* circlesColSize) {\\n    int  i, j, k, x, y, r, count = 0;\\n    char points[201][201] = {{0}};\\n    \\n    for (k = 0; k < circlesSize; k++) {\\n        x = circles[k][0];\\n        y = circles[k][1];\\n        r = circles[k][2];\\n        \\n        for (i = -r; i <= r; i++) {\\n            for (j = -r; j <= r; j++) {\\n                if (points[x+i][y+j] == 0 && r*r >= i*i + j*j) {\\n                    points[x+i][y+j] = 1;\\n                    count++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1997004,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& c) {\\n        \\n        set<pair<int,int>> st;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            int x=c[i][0];\\n            int y=c[i][1];\\n            int r=c[i][2];\\n            for(int i=x-r;i<=x+r;i++)\\n            {\\n                for(int j=y-r;j<=y+r;j++)\\n                {\\n                    if((i-x)*(i-x)+(j-y)*(j-y)<=r*r)\\n                        st.insert({i,j});\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& c) {\\n        \\n        set<pair<int,int>> st;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            int x=c[i][0];\\n            int y=c[i][1];\\n            int r=c[i][2];\\n            for(int i=x-r;i<=x+r;i++)\\n            {\\n                for(int j=y-r;j<=y+r;j++)\\n                {\\n                    if((i-x)*(i-x)+(j-y)*(j-y)<=r*r)\\n                        st.insert({i,j}",
                "codeTag": "Java"
            },
            {
                "id": 1993604,
                "title": "javascript-sort-and-interval-merging-time-o-radius-circles-y-circles-log-circles",
                "content": "```\\nRuntime: 82 ms, faster than 100.00% of JavaScript online submissions for Count Lattice Points Inside a Circle.\\nMemory Usage: 48.8 MB, less than 75.90% of JavaScript online submissions for Count Lattice Points Inside a Circle.\\n\\nvar countLatticePoints = function(circles) {\\n    const coordinateRange = Array.from({ length: 201 }, () => []);\\n\\n    const isInsideCircle = (j, x, i, y, r) => (j - x) ** 2 + (i - y) ** 2 <= r * r;\\n\\n\\t/*   Time O(radius * circles)   */\\n    for (const [x, y, r] of circles) {\\n        for (let i = y + r, j = x; i >= y; i--) {\\n            for (; isInsideCircle(j, x, i, y, r); j++);\\n\\n            coordinateRange[i].push([2 * x - (j - 1), j - 1]);\\n            coordinateRange[2 * y - i].push([2 * x - (j - 1), j - 1]);\\n        }\\n    }\\n\\n\\t/*   Time O(Y * circles * log(circles))  */\\n    coordinateRange.forEach((ranges) =>\\n        ranges.sort(([start2, end2], [start1, end1]) =>\\n            start2 === start1 ? end2 - end1 : start2 - start1\\n        )\\n    );\\n\\n\\tlet ans = 0;\\n\\n    for (const ranges of coordinateRange) {\\n        let start = 0, end = -1;\\n\\n        for (const range of ranges) {\\n            if (range[0] > end) {\\n                ans += end - start + 1;\\n                start = range[0];\\n            }\\n            end = Math.max(end, range[1]);\\n        }\\n        ans += end - start + 1;\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nRuntime: 82 ms, faster than 100.00% of JavaScript online submissions for Count Lattice Points Inside a Circle.\\nMemory Usage: 48.8 MB, less than 75.90% of JavaScript online submissions for Count Lattice Points Inside a Circle.\\n\\nvar countLatticePoints = function(circles) {\\n    const coordinateRange = Array.from({ length: 201 }, () => []);\\n\\n    const isInsideCircle = (j, x, i, y, r) => (j - x) ** 2 + (i - y) ** 2 <= r * r;\\n\\n\\t/*   Time O(radius * circles)   */\\n    for (const [x, y, r] of circles) {\\n        for (let i = y + r, j = x; i >= y; i--) {\\n            for (; isInsideCircle(j, x, i, y, r); j++);\\n\\n            coordinateRange[i].push([2 * x - (j - 1), j - 1]);\\n            coordinateRange[2 * y - i].push([2 * x - (j - 1), j - 1]);\\n        }\\n    }\\n\\n\\t/*   Time O(Y * circles * log(circles))  */\\n    coordinateRange.forEach((ranges) =>\\n        ranges.sort(([start2, end2], [start1, end1]) =>\\n            start2 === start1 ? end2 - end1 : start2 - start1\\n        )\\n    );\\n\\n\\tlet ans = 0;\\n\\n    for (const ranges of coordinateRange) {\\n        let start = 0, end = -1;\\n\\n        for (const range of ranges) {\\n            if (range[0] > end) {\\n                ans += end - start + 1;\\n                start = range[0];\\n            }\\n            end = Math.max(end, range[1]);\\n        }\\n        ans += end - start + 1;\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1993257,
                "title": "can-someone-tell-me-what-is-wrong-with-my-answer-javascript",
                "content": "```\\nvar countLatticePoints = function (circles) {\\n  const visited = new Set();\\n  const checkIsInside = (a, b, r, x, y) => {\\n    if ((a - x) ** 2 + (b - y) ** 2 > r ** 2) return false;\\n    return true;\\n  };\\n\\n  circles.forEach((circle) => {\\n    const [a, b, r] = circle;\\n    for (let x = a - r; x <= a + r; x++) {\\n      for (let y = b - r; y <= b + r; y++) {\\n        const coordinate = `${x}${y}`;\\n        if (checkIsInside(a, b, r, x, y)) visited.add(coordinate);\\n      }\\n    }\\n  });\\n  return visited.size;\\n};\\n```\\n\\nin the case of this\\n```\\nconst circles = [\\n  [10, 7, 3],\\n  [5, 9, 5],\\n  [10, 4, 2],\\n  [3, 8, 2],\\n  [2, 3, 1],\\n  [2, 10, 1],\\n  [10, 9, 8],\\n  [6, 6, 3],\\n  [8, 6, 3],\\n  [9, 8, 7],\\n  [9, 4, 3],\\n  [7, 4, 1],\\n  [4, 6, 2],\\n  [4, 3, 2],\\n  [8, 3, 3],\\n];\\n```\\nI always get 231 instead of 232.\\n\\nPlease someone help me what is wrong with my answer .... :(",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countLatticePoints = function (circles) {\\n  const visited = new Set();\\n  const checkIsInside = (a, b, r, x, y) => {\\n    if ((a - x) ** 2 + (b - y) ** 2 > r ** 2) return false;\\n    return true;\\n  };\\n\\n  circles.forEach((circle) => {\\n    const [a, b, r] = circle;\\n    for (let x = a - r; x <= a + r; x++) {\\n      for (let y = b - r; y <= b + r; y++) {\\n        const coordinate = `${x}${y}`;\\n        if (checkIsInside(a, b, r, x, y)) visited.add(coordinate);\\n      }\\n    }\\n  });\\n  return visited.size;\\n};\\n```\n```\\nconst circles = [\\n  [10, 7, 3],\\n  [5, 9, 5],\\n  [10, 4, 2],\\n  [3, 8, 2],\\n  [2, 3, 1],\\n  [2, 10, 1],\\n  [10, 9, 8],\\n  [6, 6, 3],\\n  [8, 6, 3],\\n  [9, 8, 7],\\n  [9, 4, 3],\\n  [7, 4, 1],\\n  [4, 6, 2],\\n  [4, 3, 2],\\n  [8, 3, 3],\\n];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1987546,
                "title": "rust-easy-to-understand-check-all-point-within-circle",
                "content": "\\n```rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn count_lattice_points(circles: Vec<Vec<i32>>) -> i32 {\\n        let mut set = HashSet::new();\\n        \\n        for circle in circles{\\n            let x = circle[0];\\n            let y = circle[1];\\n            let r = circle[2];\\n            \\n            for px in (x - r)..=(x + r){\\n                for py in (y - r)..=(y+ r){\\n                    \\n\\t\\t\\t\\t\\t// difference from the center of the circle\\n                    let delta_x = x - px;\\n                    let delta_y = y - py;\\n                    \\n\\t\\t\\t\\t\\t// using pythagoras theorem ( x^2 + y^2 = z^2 )\\n\\t\\t\\t\\t\\t// to get the point\\'s (px, py) magnitude from the center of the circle\\n\\t\\t\\t\\t\\t\\n                    let magnitude = ((delta_x.pow(2) + delta_y.pow(2)) as f64).sqrt();\\n                    \\n                    if(magnitude <= r as f64){\\n                        set.insert((i, j));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        set.len() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn count_lattice_points(circles: Vec<Vec<i32>>) -> i32 {\\n        let mut set = HashSet::new();\\n        \\n        for circle in circles{\\n            let x = circle[0];\\n            let y = circle[1];\\n            let r = circle[2];\\n            \\n            for px in (x - r)..=(x + r){\\n                for py in (y - r)..=(y+ r){\\n                    \\n\\t\\t\\t\\t\\t// difference from the center of the circle\\n                    let delta_x = x - px;\\n                    let delta_y = y - py;\\n                    \\n\\t\\t\\t\\t\\t// using pythagoras theorem ( x^2 + y^2 = z^2 )\\n\\t\\t\\t\\t\\t// to get the point\\'s (px, py) magnitude from the center of the circle\\n\\t\\t\\t\\t\\t\\n                    let magnitude = ((delta_x.pow(2) + delta_y.pow(2)) as f64).sqrt();\\n                    \\n                    if(magnitude <= r as f64){\\n                        set.insert((i, j));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        set.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1986495,
                "title": "python-math-simmetry",
                "content": "Runtime: 1067 ms, faster than 94.65% of Python3 online submissions for Count Lattice Points Inside a Circle.\\nMemory Usage: 17.7 MB, less than 78.30% of Python3 online submissions for Count Lattice Points Inside a Circle.\\n```\\nclass Solution:\\n  def countLatticePoints(self, circles: List[List[int]]) -> int:\\n    table = set()\\n    \\n    for c in circles :\\n      xl = c[0] - c[2]\\n      xr = c[0] + c[2]\\n      yu = c[1]\\n      yd = c[1]\\n      step = 1\\n      r2 = c[2]*c[2]\\n      \\n      for x in range (xl, xr +1) : table.add((x<<8) + yu)\\n      while step <= c[2] :\\n        yu += 1\\n        yd -= 1\\n        x = int(math.sqrt(r2 - step*step))\\n        for X in range(c[0] - x, c[0] + x + 1) :\\n          table.add((X<<8) + yu)\\n          table.add((X<<8) + yd)\\n        step += 1\\n    \\n    return len(table)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def countLatticePoints(self, circles: List[List[int]]) -> int:\\n    table = set()\\n    \\n    for c in circles :\\n      xl = c[0] - c[2]\\n      xr = c[0] + c[2]\\n      yu = c[1]\\n      yd = c[1]\\n      step = 1\\n      r2 = c[2]*c[2]\\n      \\n      for x in range (xl, xr +1) : table.add((x<<8) + yu)\\n      while step <= c[2] :\\n        yu += 1\\n        yd -= 1\\n        x = int(math.sqrt(r2 - step*step))\\n        for X in range(c[0] - x, c[0] + x + 1) :\\n          table.add((X<<8) + yu)\\n          table.add((X<<8) + yd)\\n        step += 1\\n    \\n    return len(table)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986036,
                "title": "python-solution-easy-but-no-so-efficient",
                "content": "def all_points(x,y,r):\\n\\n            lst = []\\n            for a in range(4*r):\\n                col = y-r+a\\n                for b in range(4*r):\\n                    row = x-r+b\\n                    p1,p2 = (x-row)**2,(y-col)**2\\n                    distance = math.sqrt(p1+p2)\\n                    if distance <= r:\\n                        lst.append((row,col))\\n\\n            return lst\\n\\n        \\n        circle = set()\\n        for x,y,r in circles:\\n            circle.add((x,y,r))\\n        result = set()\\n        for x,y,r in circle:\\n            ans = all_points(x,y,r)\\n            for coOrds in ans:\\n                result.add(coOrds)\\n\\n\\n        return (len(result))",
                "solutionTags": [
                    "Python"
                ],
                "code": "def all_points(x,y,r):\\n\\n            lst = []\\n            for a in range(4*r):\\n                col = y-r+a\\n                for b in range(4*r):\\n                    row = x-r+b\\n                    p1,p2 = (x-row)**2,(y-col)**2\\n                    distance = math.sqrt(p1+p2)\\n                    if distance <= r:\\n                        lst.append((row,col))\\n\\n            return lst\\n\\n        \\n        circle = set()\\n        for x,y,r in circles:\\n            circle.add((x,y,r))\\n        result = set()\\n        for x,y,r in circle:\\n            ans = all_points(x,y,r)\\n            for coOrds in ans:\\n                result.add(coOrds)\\n\\n\\n        return (len(result))",
                "codeTag": "Python3"
            },
            {
                "id": 1984232,
                "title": "brute-force-javascript-solutions",
                "content": "```\\nvar countLatticePoints = function(circles) {\\n    let res = 0;\\n    \\n\\t// constraints:\\n\\t//     1 <= xi, yi <= 100\\n\\t//     1 <= ri <= min(xi, yi)\\n    for (let i = 0; i <= 200; i++) {\\n        for (let j = 0; j <= 200; j++) {\\n            for (let [x, y, r] of circles) {\\n                if ((i - x) ** 2 + (j - y) ** 2 <= r ** 2) {\\n                    res++;\\n                    break;\\n                }                    \\n            }\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\nvar countLatticePoints = function(circles) {\\n    let points = new Set();\\n    for (let [x, y, r] of circles) {\\n        for (let i = -r; i <= r; i++) {\\n            for (let j = -r; j <= r; j++) {\\n                if (i * i + j * j <= r * r) {\\n\\t\\t\\t\\t    // avoid points.add([i + x, j + y]), [3, 3] !== [3, 3]\\n\\t\\t\\t\\t\\t// objects are compared using the reference, not the value\\n\\t\\t\\t\\t\\t// MDN: The Set object lets you store unique values of any type, \\n\\t\\t\\t\\t\\t//      whether primitive values or object references.\\n                    points.add(`(${i + x}, ${j + y})`); \\n                }\\n            }\\n        }\\n    }\\n    \\n    return points.size;\\n};\\n\\n// combine the two ideas above\\nvar countLatticePoints = function(circles) {\\n    let points = Array.from(new Uint8Array(201), () => new Uint8Array(201));\\n    let res = 0;\\n    for (let [x, y, r] of circles) {\\n        for (let i = -r; i <= r; i++) {\\n            for (let j = -r; j <= r; j++) {\\n                if (i * i + j * j <= r * r) {\\n                    if (++points[i + x][j + y] === 1) res++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countLatticePoints = function(circles) {\\n    let res = 0;\\n    \\n\\t// constraints:\\n\\t//     1 <= xi, yi <= 100\\n\\t//     1 <= ri <= min(xi, yi)\\n    for (let i = 0; i <= 200; i++) {\\n        for (let j = 0; j <= 200; j++) {\\n            for (let [x, y, r] of circles) {\\n                if ((i - x) ** 2 + (j - y) ** 2 <= r ** 2) {\\n                    res++;\\n                    break;\\n                }                    \\n            }\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\nvar countLatticePoints = function(circles) {\\n    let points = new Set();\\n    for (let [x, y, r] of circles) {\\n        for (let i = -r; i <= r; i++) {\\n            for (let j = -r; j <= r; j++) {\\n                if (i * i + j * j <= r * r) {\\n\\t\\t\\t\\t    // avoid points.add([i + x, j + y]), [3, 3] !== [3, 3]\\n\\t\\t\\t\\t\\t// objects are compared using the reference, not the value\\n\\t\\t\\t\\t\\t// MDN: The Set object lets you store unique values of any type, \\n\\t\\t\\t\\t\\t//      whether primitive values or object references.\\n                    points.add(`(${i + x}, ${j + y})`); \\n                }\\n            }\\n        }\\n    }\\n    \\n    return points.size;\\n};\\n\\n// combine the two ideas above\\nvar countLatticePoints = function(circles) {\\n    let points = Array.from(new Uint8Array(201), () => new Uint8Array(201));\\n    let res = 0;\\n    for (let [x, y, r] of circles) {\\n        for (let i = -r; i <= r; i++) {\\n            for (let j = -r; j <= r; j++) {\\n                if (i * i + j * j <= r * r) {\\n                    if (++points[i + x][j + y] === 1) res++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1983360,
                "title": "python-bruteforce-approach-with-set",
                "content": "For each circle, process all the unprocessed candidate points.\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        visited = set()\\n        res = 0\\n        for cx, cy, r in circles:\\n            for x in range(cx-r,cx+r+1):\\n                for y in range(cy-r,cy+r+1):\\n                    if (x,y) not in visited and (x-cx)**2 + (y-cy)**2 <= r**2:\\n                        visited.add((x,y))\\n                        res += 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "For each circle, process all the unprocessed candidate points.\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        visited = set()\\n        res = 0\\n        for cx, cy, r in circles:\\n            for x in range(cx-r,cx+r+1):\\n                for y in range(cy-r,cy+r+1):\\n                    if (x,y) not in visited and (x-cx)**2 + (y-cy)**2 <= r**2:\\n                        visited.add((x,y))\\n                        res += 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1983128,
                "title": "simple-c-solution",
                "content": "The given task is to brute force all the points from the bottom left corner to the top right corner and check if its inside. \\n\\n```Time complexity -> O(N^2)```\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int countLatticePoints(vector<vector<int>> &v)\\n    {\\n        // lattice points - points with integer coordinates inside the circle\\n        int res = 0, n = v.size();\\n        set<pair<int, int>> s; // storing all unique lattice points\\n        for (int i = 0; i < n; i++)\\n        {\\n            int x = v[i][0], y = v[i][1], r = v[i][2];\\n            int startx = x - r, starty = y - r, endx = x + r, endy = y + r;\\n            for (int i = startx; i <= endx; i++)\\n            {\\n                for (int j = starty; j <= endy; j++)\\n                {\\n                    if ((i - x) * (i - x) + (j - y) * (j - y) <= r * r)\\n                    {\\n                        // if the point is inside the circle\\n                        s.insert({i, j});\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```Time complexity -> O(N^2)```\n```\\nclass Solution\\n{\\npublic:\\n    int countLatticePoints(vector<vector<int>> &v)\\n    {\\n        // lattice points - points with integer coordinates inside the circle\\n        int res = 0, n = v.size();\\n        set<pair<int, int>> s; // storing all unique lattice points\\n        for (int i = 0; i < n; i++)\\n        {\\n            int x = v[i][0], y = v[i][1], r = v[i][2];\\n            int startx = x - r, starty = y - r, endx = x + r, endy = y + r;\\n            for (int i = startx; i <= endx; i++)\\n            {\\n                for (int j = starty; j <= endy; j++)\\n                {\\n                    if ((i - x) * (i - x) + (j - y) * (j - y) <= r * r)\\n                    {\\n                        // if the point is inside the circle\\n                        s.insert({i, j});\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982726,
                "title": "c-consider-all-points",
                "content": "```\\nclass Solution {\\npublic:\\n    bool liesInside(int cx , int cy , int r , int x , int y){\\n        int d = (cx-x)*(cx-x) + (cy-y)*(cy-y) ;\\n        if(d <= r*r) return true ;\\n        return false ;\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int latticePoints = 0 ;\\n        //maximum point covered can be 200 , assumed x = 100 , y = 100 then radius = 100 ;\\n        for(int x = 0 ; x <= 200 ; ++x ){\\n            for(int y = 0 ; y <= 200 ; ++y){\\n                \\n                for(auto &circle : circles){\\n                    int cx = circle[0] , cy = circle[1] , r = circle[2] ;\\n                    if(liesInside(cx,cy,r,x,y)){\\n                        ++latticePoints ;\\n                        break ;\\n                    }\\n                }\\n            }\\n        }\\n        return latticePoints ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool liesInside(int cx , int cy , int r , int x , int y){\\n        int d = (cx-x)*(cx-x) + (cy-y)*(cy-y) ;\\n        if(d <= r*r) return true ;\\n        return false ;\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int latticePoints = 0 ;\\n        //maximum point covered can be 200 , assumed x = 100 , y = 100 then radius = 100 ;\\n        for(int x = 0 ; x <= 200 ; ++x ){\\n            for(int y = 0 ; y <= 200 ; ++y){\\n                \\n                for(auto &circle : circles){\\n                    int cx = circle[0] , cy = circle[1] , r = circle[2] ;\\n                    if(liesInside(cx,cy,r,x,y)){\\n                        ++latticePoints ;\\n                        break ;\\n                    }\\n                }\\n            }\\n        }\\n        return latticePoints ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982183,
                "title": "python-sets",
                "content": "# Solution\\n\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        def each_one(circle):\\n            x,y,r = circle\\n            ans = set()\\n            for i in range(0,r+1):\\n                for j in range(0,r+1):\\n                    if (i)**2 + (j)**2 <= r**2:\\n                        ans.add((i+x,j+y))\\n                        ans.add((-i+x,j+y))\\n                        ans.add((i+x,-j+y))\\n                        ans.add((-i+x,-j+y))\\n                    else:\\n                        break\\n            return ans\\n        ans = set()\\n        for each in circles:\\n            ans = ans | each_one(each)\\n        return len(ans)\\n```\\n# Explanation\\n## helper function:\\nfirst of all, notice that we can do all our calculations on quarter of the circle and then derive the rest of our points based on that since a circle is symmetric about the origin.\\niterate over all points from the origin to the origin+radius on both the x and y axis.\\nif those points have distance less than or equal to `r` from origin, include them in your answer\\nfor every point (i,j) that you include, also include (-i,j), (i,-j), and (-i,-j)\\nreturn answer as a set\\n## outer function\\ncreate an empty set.\\niterate over all circles\\nfor each circle, join the result of the helper function (which returns a set of each point inside the current circle) to ans.\\nreturn ans\\n\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        def each_one(circle):\\n            x,y,r = circle\\n            ans = set()\\n            for i in range(0,r+1):\\n                for j in range(0,r+1):\\n                    if (i)**2 + (j)**2 <= r**2:\\n                        ans.add((i+x,j+y))\\n                        ans.add((-i+x,j+y))\\n                        ans.add((i+x,-j+y))\\n                        ans.add((-i+x,-j+y))\\n                    else:\\n                        break\\n            return ans\\n        ans = set()\\n        for each in circles:\\n            ans = ans | each_one(each)\\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981904,
                "title": "reduce-number-of-loops-by-applying-symmetry",
                "content": "```python\\ndef iterZeroBasedPoints(r):\\n    \\n    yield (0, 0)\\n\\n    for x, y in itertools.product(range(0, r+1), range(0, r+1)):\\n\\n        if (x, y) == (0, 0):\\n            continue\\n\\n        if x**2 + y**2 <= r**2: # Iterate over points with 90 degree rotations\\n            yield (x, y)\\n            yield (y, -x)\\n            yield (-x, -y)\\n            yield (-y, x)\\n\\n\\n@functools.lru_cache()\\ndef getPoints(x0, y0, r) -> set:\\n    return set((x + x0, y + y0) for x, y in iterZeroBasedPoints(r))\\n\\n\\nclass Solution:\\n    \\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        points = reduce(lambda a, b: a.union(b), [getPoints(x, y, r) for x, y, r in circles])\\n        return len(points)\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```python\\ndef iterZeroBasedPoints(r):\\n    \\n    yield (0, 0)\\n\\n    for x, y in itertools.product(range(0, r+1), range(0, r+1)):\\n\\n        if (x, y) == (0, 0):\\n            continue\\n\\n        if x**2 + y**2 <= r**2: # Iterate over points with 90 degree rotations\\n            yield (x, y)\\n            yield (y, -x)\\n            yield (-x, -y)\\n            yield (-y, x)\\n\\n\\n@functools.lru_cache()\\ndef getPoints(x0, y0, r) -> set:\\n    return set((x + x0, y + y0) for x, y in iterZeroBasedPoints(r))\\n\\n\\nclass Solution:\\n    \\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        points = reduce(lambda a, b: a.union(b), [getPoints(x, y, r) for x, y, r in circles])\\n        return len(points)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981867,
                "title": "simple-and-easy-to-understand-neat-and-clean-code-in-c",
                "content": "```\\nint countLatticePoints(vector<vector<int>>& circles) {\\n        \\n        int n = circles.size();\\n        set<pair<int,int>> s; //for storing only unique points\\n        \\n        for(int z=0;z<n;z++){\\n            \\n            int x = circles[z][0];\\n            int y = circles[z][1];\\n            int r = circles[z][2];\\n            \\n            int left = x-r;  //the leftmost point\\n            int down = y-r;  //the rightmost point\\n            \\n//move from leftmost to rightmost points and\\n//move from bottom to top points\\n            \\n            for(int i=left;i<=x+r;i++){\\n                for(int j=down;j<=y+r;j++){\\n                    if((x-i)*(x-i)+(y-j)*(y-j)<=r*r){\\n                        s.insert({i,j});\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return s.size();\\n        \\n        \\n    }",
                "solutionTags": [],
                "code": "```\\nint countLatticePoints(vector<vector<int>>& circles) {\\n        \\n        int n = circles.size();\\n        set<pair<int,int>> s; //for storing only unique points\\n        \\n        for(int z=0;z<n;z++){\\n            \\n            int x = circles[z][0];\\n            int y = circles[z][1];\\n            int r = circles[z][2];\\n            \\n            int left = x-r;  //the leftmost point\\n            int down = y-r;  //the rightmost point\\n            \\n//move from leftmost to rightmost points and\\n//move from bottom to top points\\n            \\n            for(int i=left;i<=x+r;i++){\\n                for(int j=down;j<=y+r;j++){\\n                    if((x-i)*(x-i)+(y-j)*(y-j)<=r*r){\\n                        s.insert({i,j});\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return s.size();\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1981648,
                "title": "c-unordered-set-100-faster",
                "content": "I found that many people use set<pair<int, int>> for simplicity, but it is not reasonable to order these coordinates. Although unordered_set<pair<int, int>> is not supported by default, we can assign a proper hash function to it as we know that the range of 0 <= x, y <= 100. Then by brute force checking them, we have the following solution.\\n\\n(Note that if you try a bad hash function such as pair<int, int> p => p.first ^ p.second, this would lead to tons of hash value confliction and then TLE.)\\n```\\nclass hashFunction {\\npublic:\\n    size_t operator()(const pair<int , int> &x)const {\\n        return x.first * 1000 + x.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        unordered_set<pair<int, int>, hashFunction> uset;\\n        for (auto& circle : circles) {\\n            int sx = circle[0], sy = circle[1], r = circle[2];\\n            for (int x = -r;x <= r;x++) {\\n                for (int y = -r;y <= r;y++) {\\n                    if (x * x + y * y <= r * r) {\\n                        uset.insert({x + sx, y + sy});\\n                    }\\n                }\\n            }\\n        }\\n        return uset.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass hashFunction {\\npublic:\\n    size_t operator()(const pair<int , int> &x)const {\\n        return x.first * 1000 + x.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        unordered_set<pair<int, int>, hashFunction> uset;\\n        for (auto& circle : circles) {\\n            int sx = circle[0], sy = circle[1], r = circle[2];\\n            for (int x = -r;x <= r;x++) {\\n                for (int y = -r;y <= r;y++) {\\n                    if (x * x + y * y <= r * r) {\\n                        uset.insert({x + sx, y + sy});\\n                    }\\n                }\\n            }\\n        }\\n        return uset.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981240,
                "title": "three-loops-100-speed",
                "content": "![image](https://assets.leetcode.com/users/images/05a01cf5-d665-47d0-aa9c-e34126567f8a_1650889549.71587.png)\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        points = set()\\n        for cx, cy, r in circles:\\n            r2 = r * r\\n            for x in range(-r, r + 1):\\n                y_05 = int(pow(r2 - x * x, 0.5))\\n                for y in range(-y_05, y_05 + 1):\\n                    points.add((cx + x, cy + y))\\n        return len(points)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        points = set()\\n        for cx, cy, r in circles:\\n            r2 = r * r\\n            for x in range(-r, r + 1):\\n                y_05 = int(pow(r2 - x * x, 0.5))\\n                for y in range(-y_05, y_05 + 1):\\n                    points.add((cx + x, cy + y))\\n        return len(points)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980932,
                "title": "what-is-wrong-with-my-recursive-solution-getting-wa",
                "content": "I got wrong answer using the following code. Can someone help to understand what is wrong with this one?\\n\\n```\\nclass Solution {\\npublic:\\n    set<pair<int, int>> points;\\n    vector<vector<int>> circ;\\n    set<pair<int, int>> vis;\\n    \\n    \\n    int minY = 200, maxX = -200, maxY = -200, minX = 200;\\n    \\n    bool isInside(int circle_x, int circle_y,\\n                   int rad, int x, int y)\\n    {\\n        \\n        if ((x - circle_x) * (x - circle_x) +\\n            (y - circle_y) * (y - circle_y) <= rad * rad)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    bool isInside(int x, int y)\\n    {\\n        \\n        for (auto v : circ) {\\n            if (isInside(v[0], v[1], v[2], x, y)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    void generate(pair<int, int> currentPos, int radius) {\\n        //cout << \"in generate\\\\n\";\\n        auto x = currentPos.first;\\n        auto y = currentPos.second;\\n       \\n        \\n        if (vis.count({x, y}) != 0) return;\\n        \\n        vis.insert({x, y});\\n        \\n        if (x > maxX || x < minX || y > maxY || y < minY) {\\n            return; // out of area\\n        }\\n        if (points.count({x, y}) == 0 && isInside(x, y)) {\\n            points.insert({x, y});\\n        }\\n        //up\\n        generate({x, y + radius}, radius);\\n        //down\\n        generate({x, y - radius}, radius);\\n        //left \\n        generate({x - radius, y}, radius);\\n        //right\\n        generate({x + radius, y}, radius);\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        circ = circles;\\n        \\n        vis = set<pair<int, int>>();\\n        \\n        minY = INT_MAX, maxX = INT_MIN, maxY = INT_MIN, minX = INT_MAX;\\n        for (auto v : circles) {\\n            minY = min(minY, v[1] - v[2]);\\n            maxY = max(maxY, v[1] + v[2]);\\n            minX = min(minX, v[0] - v[2]);\\n            maxX = max(maxX, v[0] + v[2]);\\n        }\\n        \\n        //cout << minX <<\" \" << maxX << \" \" << minY << \" \" << maxY << endl;\\n        \\n        \\n        for (auto v : circles) {\\n            generate({v[0], v[1]}, v[2]);\\n        }\\n        \\n        return points.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<pair<int, int>> points;\\n    vector<vector<int>> circ;\\n    set<pair<int, int>> vis;\\n    \\n    \\n    int minY = 200, maxX = -200, maxY = -200, minX = 200;\\n    \\n    bool isInside(int circle_x, int circle_y,\\n                   int rad, int x, int y)\\n    {\\n        \\n        if ((x - circle_x) * (x - circle_x) +\\n            (y - circle_y) * (y - circle_y) <= rad * rad)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    bool isInside(int x, int y)\\n    {\\n        \\n        for (auto v : circ) {\\n            if (isInside(v[0], v[1], v[2], x, y)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    void generate(pair<int, int> currentPos, int radius) {\\n        //cout << \"in generate\\\\n\";\\n        auto x = currentPos.first;\\n        auto y = currentPos.second;\\n       \\n        \\n        if (vis.count({x, y}) != 0) return;\\n        \\n        vis.insert({x, y});\\n        \\n        if (x > maxX || x < minX || y > maxY || y < minY) {\\n            return; // out of area\\n        }\\n        if (points.count({x, y}) == 0 && isInside(x, y)) {\\n            points.insert({x, y});\\n        }\\n        //up\\n        generate({x, y + radius}, radius);\\n        //down\\n        generate({x, y - radius}, radius);\\n        //left \\n        generate({x - radius, y}, radius);\\n        //right\\n        generate({x + radius, y}, radius);\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        circ = circles;\\n        \\n        vis = set<pair<int, int>>();\\n        \\n        minY = INT_MAX, maxX = INT_MIN, maxY = INT_MIN, minX = INT_MAX;\\n        for (auto v : circles) {\\n            minY = min(minY, v[1] - v[2]);\\n            maxY = max(maxY, v[1] + v[2]);\\n            minX = min(minX, v[0] - v[2]);\\n            maxX = max(maxX, v[0] + v[2]);\\n        }\\n        \\n        //cout << minX <<\" \" << maxX << \" \" << minY << \" \" << maxY << endl;\\n        \\n        \\n        for (auto v : circles) {\\n            generate({v[0], v[1]}, v[2]);\\n        }\\n        \\n        return points.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1980879,
                "title": "python-set-solution-2613ms",
                "content": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        \\n        #Will be used to ignore duplicate circles\\n        used = set();\\n        \\n        #Put all the lattice points in a set\\n        latticePoints = set();\\n        \\n        for triplet in circles:\\n            circle_id = str( triplet );\\n            \\n            #To ignore duplicates\\n            if circle_id in used:\\n                continue;\\n            \\n            #Feed through helper\\n            self.addLP( latticePoints, triplet );\\n            used.add( circle_id );\\n            \\n        #Return the length of the set\\n        return len( latticePoints );\\n        \\n    def addLP( self, latticePoints, triplet ):\\n        \\n        #Unpack values\\n        r = triplet[ 2 ];\\n        d = r * 2;\\n        x =  triplet[ 0 ] - r;\\n        y =  triplet[ 1 ] - r;\\n\\n        #Used_lengths keeps track of good lengths\\n        valid_lengths = set();\\n        invalid_lengths = set();\\n        \\n        for i in range( d + 1 ):\\n            for j in range( d + 1 ):\\n                \\n                #Find the vertical and horizontal length\\n                #Relative to the center of the circle\\n                #To the current coorindate ( a,b )\\n                a = x + i;\\n                length_a = abs( triplet[ 0 ] - a);\\n                b = y + j;\\n                length_b = abs( triplet[ 1 ] - b);\\n                \\n                \\n                length_id = str( [ length_a, length_b ] );\\n                \\n                #If this length combo has been evaluated:\\n                if length_id in valid_lengths:\\n                    latticePoints.add( str( [ x + i, y + j ]) );\\n                elif length_id in invalid_lengths:\\n                    continue;\\n                    \\n                #Otherwise, check it and add to relevant set\\n                else:\\n                    is_inside = self.inside( length_a, length_b, r );\\n                    if is_inside:\\n                        latticePoints.add( str( [ x + i, y + j ]) );\\n                        valid_lengths.add( length_id );\\n                    else:\\n                        invalid_lengths.add( length_id );\\n        \\n    #a^2 + b^2 = c^2  ==>\\n    #c = sqrt( a^2 + b^2 )\\n    #Check to make sure c is less than or equal to r\\n    def inside( self, length_a , length_b, r ):\\n        a_square = math.pow( length_a, 2 );\\n        b_square = math.pow( length_b, 2 );\\n        c = math.sqrt( a_square + b_square );\\n        return c <= r;\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        \\n        #Will be used to ignore duplicate circles\\n        used = set();\\n        \\n        #Put all the lattice points in a set\\n        latticePoints = set();\\n        \\n        for triplet in circles:\\n            circle_id = str( triplet );\\n            \\n            #To ignore duplicates\\n            if circle_id in used:\\n                continue;\\n            \\n            #Feed through helper\\n            self.addLP( latticePoints, triplet );\\n            used.add( circle_id );\\n            \\n        #Return the length of the set\\n        return len( latticePoints );\\n        \\n    def addLP( self, latticePoints, triplet ):\\n        \\n        #Unpack values\\n        r = triplet[ 2 ];\\n        d = r * 2;\\n        x =  triplet[ 0 ] - r;\\n        y =  triplet[ 1 ] - r;\\n\\n        #Used_lengths keeps track of good lengths\\n        valid_lengths = set();\\n        invalid_lengths = set();\\n        \\n        for i in range( d + 1 ):\\n            for j in range( d + 1 ):\\n                \\n                #Find the vertical and horizontal length\\n                #Relative to the center of the circle\\n                #To the current coorindate ( a,b )\\n                a = x + i;\\n                length_a = abs( triplet[ 0 ] - a);\\n                b = y + j;\\n                length_b = abs( triplet[ 1 ] - b);\\n                \\n                \\n                length_id = str( [ length_a, length_b ] );\\n                \\n                #If this length combo has been evaluated:\\n                if length_id in valid_lengths:\\n                    latticePoints.add( str( [ x + i, y + j ]) );\\n                elif length_id in invalid_lengths:\\n                    continue;\\n                    \\n                #Otherwise, check it and add to relevant set\\n                else:\\n                    is_inside = self.inside( length_a, length_b, r );\\n                    if is_inside:\\n                        latticePoints.add( str( [ x + i, y + j ]) );\\n                        valid_lengths.add( length_id );\\n                    else:\\n                        invalid_lengths.add( length_id );\\n        \\n    #a^2 + b^2 = c^2  ==>\\n    #c = sqrt( a^2 + b^2 )\\n    #Check to make sure c is less than or equal to r\\n    def inside( self, length_a , length_b, r ):\\n        a_square = math.pow( length_a, 2 );\\n        b_square = math.pow( length_b, 2 );\\n        c = math.sqrt( a_square + b_square );\\n        return c <= r;\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980498,
                "title": "precalculation-with-no-sqrt-needed-in-runtime",
                "content": "For any point `(p, q)` in a square of `(x\\xB1r, y\\xB1r) `, we would want to check if it is a lattice point. \\nLet `long_pole` and `short_pole` to represent the max and min value of `abs(p - x)` and `abs(q - y)`.\\nWhen `long_pole >= r/2`, we would want to know the max value of  `short_pole` so that for any `shot_pole` equal or below that value, `(p, q)` is lattice point.\\n\\nSince `r <= 200`, this information can be precalculated.\\n\\nWe track the found lattice points with a hash set.\\n\\nThe precalculated results are too large and it cannot fit into this thread. Using `<PRECALCULATED_RESULTS>` to represent it.\\n\\nPrecalculation\\n```\\nradius_inclusion_map = {x: {} for x in range(1, 201)}\\nfor radius in radius_inclusion_map.keys():\\n    for long_pole in range(radius, (radius+1)//2-1, -1):\\n        for short_pole in range(long_pole, -1, -1):\\n            if short_pole ** 2 + long_pole ** 2 <= radius ** 2:\\n                radius_inclusion_map[radius][long_pole] = short_pole\\n                break\\n\\nprint(radius_inclusion_map)\\n```\\n\\nSolution:\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        radius_inclusion_map = {<PRECALCULATED_RESULTS>}\\n        included = set()\\n        for circle in circles:\\n            for x in range(circle[0] - circle[2], circle[0] + circle[2] + 1):\\n                for y in range(circle[1] - circle[2], circle[1] + circle[2] + 1):\\n                    if (x, y) in included:\\n                        continue\\n                    diff_1, diff_2 = abs(x - circle[0]), abs(y - circle[1])\\n                    long_pole, short_pole = (diff_1, diff_2) if diff_1 >= diff_2 else (diff_2, diff_1)\\n                    if long_pole <= circle[2]//2 or short_pole <= radius_inclusion_map[circle[2]][long_pole]:\\n                        included.add((x, y))\\n        return len(included)\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nradius_inclusion_map = {x: {} for x in range(1, 201)}\\nfor radius in radius_inclusion_map.keys():\\n    for long_pole in range(radius, (radius+1)//2-1, -1):\\n        for short_pole in range(long_pole, -1, -1):\\n            if short_pole ** 2 + long_pole ** 2 <= radius ** 2:\\n                radius_inclusion_map[radius][long_pole] = short_pole\\n                break\\n\\nprint(radius_inclusion_map)\\n```\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        radius_inclusion_map = {<PRECALCULATED_RESULTS>}\\n        included = set()\\n        for circle in circles:\\n            for x in range(circle[0] - circle[2], circle[0] + circle[2] + 1):\\n                for y in range(circle[1] - circle[2], circle[1] + circle[2] + 1):\\n                    if (x, y) in included:\\n                        continue\\n                    diff_1, diff_2 = abs(x - circle[0]), abs(y - circle[1])\\n                    long_pole, short_pole = (diff_1, diff_2) if diff_1 >= diff_2 else (diff_2, diff_1)\\n                    if long_pole <= circle[2]//2 or short_pole <= radius_inclusion_map[circle[2]][long_pole]:\\n                        included.add((x, y))\\n        return len(included)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980296,
                "title": "simple-c-solutions-using-math",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isInside(int x , int y , int x1 , int y1  , int r){\\n        int temp = (x-x1)*(x-x1) + (y-y1)*(y-y1);\\n        if(temp<=r*r){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> st;\\n        for(int i=0 ; i<circles.size() ; i++){\\n            vector<int> temp = circles[i];\\n            int x = temp[0];\\n            int y = temp[1];\\n            int r = temp[2];\\n            \\n            for(int k=-r; k<=r ; k++){\\n               for(int l=-r ; l<=r ; l++){\\n                   if(isInside(x,y , x+k , y+l , r)){\\n                       st.insert({x+k , y+l});\\n                   }\\n               }\\n            }\\n            \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInside(int x , int y , int x1 , int y1  , int r){\\n        int temp = (x-x1)*(x-x1) + (y-y1)*(y-y1);\\n        if(temp<=r*r){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> st;\\n        for(int i=0 ; i<circles.size() ; i++){\\n            vector<int> temp = circles[i];\\n            int x = temp[0];\\n            int y = temp[1];\\n            int r = temp[2];\\n            \\n            for(int k=-r; k<=r ; k++){\\n               for(int l=-r ; l<=r ; l++){\\n                   if(isInside(x,y , x+k , y+l , r)){\\n                       st.insert({x+k , y+l});\\n                   }\\n               }\\n            }\\n            \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980160,
                "title": "python-accepted-faster-than-100",
                "content": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        s=set()\\n        circles = set(map(lambda x: tuple(x), circles))\\n        for i in circles:\\n            for x in range(i[0]-i[2],i[0]+i[2]+1):\\n                for y in range(i[1]-i[2],i[1]+i[2]+1):\\n                    if((x-i[0])**2+(y-i[1])**2)<=i[2]**2:\\n                        s.add((x,y))\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        s=set()\\n        circles = set(map(lambda x: tuple(x), circles))\\n        for i in circles:\\n            for x in range(i[0]-i[2],i[0]+i[2]+1):\\n                for y in range(i[1]-i[2],i[1]+i[2]+1):\\n                    if((x-i[0])**2+(y-i[1])**2)<=i[2]**2:\\n                        s.add((x,y))\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980153,
                "title": "c-optimized-100-faster",
                "content": "A better approach for culling is to identify enclosing circles and eliminating them altogether.\\nAlso, it is possible to construct an example where my approach for culling the inner rectangle points is incorrect (LC does not have such test cases). A better approach is to use a seperate unordered_set for each circle and combine them into one large set for the final count. \\n\\n```\\n    typedef std::pair<int, int> XYPair;\\npublic:\\n    // arg1: c denotes the non-xy plane coordinates of a point on the circumference of\\n    //       the circle whose origin is at \\'(0,0)\\'.\\n    // arg2: o denotes the (x,y) coordinates of the center of the circle.\\n    // arg3: output set of points inside the circle.\\n    void fillPointsUsingCircumferencePoint(XYPair c, XYPair o, unordered_set<uint64_t>& points) \\n    {\\n        int xy[2];\\n        uint64_t *xyPoint = (uint64_t*)xy;\\n        bool skip;\\n        \\n        for (int y = c.second; y > 0; y--) {\\n            for (int x = c.first; x > 0; x--) {\\n                skip = 1;\\n                \\n                xy[0] = x + o.first; xy[1] = y + o.second;\\n                skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n                \\n                xy[0] = (-x) + o.first; xy[1] = y + o.second;\\n                skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n                \\n                xy[0] = x + o.first; xy[1] = (-y) + o.second;\\n                skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n                \\n                xy[0] = (-x) + o.first; xy[1] = (-y) + o.second;\\n                skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n                \\n                // all points inside the rectangle defined by the 4 corners are already inserted.\\n                if (skip)\\n                    break;\\n            }\\n        }\\n    }\\n    \\n    // arg1: a denotes an x/y plane point on the circumference of the circle\\n    //       whose origin is at \\'(0,0)\\'.\\n    // arg2: o denotes the x, y coordinates of the center of the circle.\\n    // arg3: output set of points inside the circle.\\n    void fillPointsOnAxis(XYPair a, XYPair o, unordered_set<uint64_t>& points)\\n    {\\n        int xy[2];\\n        uint64_t *xyPoint = (uint64_t*)xy;\\n        bool skip;\\n        \\n        xy[0] = o.first; xy[1] = o.second;\\n        points.insert(*xyPoint);\\n        for (int x = a.first, y = a.second; x > 0; x--, y--) {    \\n            skip = 1;\\n            \\n            xy[0] = x + o.first; xy[1] = o.second;\\n            skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n            \\n            xy[0] = (-x) + o.first; xy[1] = o.second;\\n            skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n            \\n            xy[0] = o.first; xy[1] = y + o.second;\\n            skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n            \\n            xy[0] = o.first; xy[1] = (-y) + o.second;\\n            skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n            \\n            if (skip)\\n                break;\\n        }\\n    }\\n    \\n    void generateCircumferencePointsAndFill(XYPair o, int radius, unordered_set<uint64_t>& points)\\n    {\\n        for (int x = o.first + radius - 1; x > o.first; --x) {\\n            for (int y = o.second + radius -1; y > o.second; --y) {\\n                if (ceil(sqrt((x-o.first)*(x-o.first) + (y-o.second)*(y-o.second))) <= radius) {\\n                    fillPointsUsingCircumferencePoint(make_pair(x-o.first, y-o.second), o, points);\\n                    break;\\n                }\\n            }\\n        }\\n        fillPointsOnAxis(make_pair(radius, radius), o, points);\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        unordered_set<uint64_t> lp;\\n        \\n        for (auto circle: circles) {\\n            auto origin = make_pair(circle[0], circle[1]);\\n            auto radius = circle[2];\\n            generateCircumferencePointsAndFill(origin, radius, lp);\\n        }\\n        return lp.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    typedef std::pair<int, int> XYPair;\\npublic:\\n    // arg1: c denotes the non-xy plane coordinates of a point on the circumference of\\n    //       the circle whose origin is at \\'(0,0)\\'.\\n    // arg2: o denotes the (x,y) coordinates of the center of the circle.\\n    // arg3: output set of points inside the circle.\\n    void fillPointsUsingCircumferencePoint(XYPair c, XYPair o, unordered_set<uint64_t>& points) \\n    {\\n        int xy[2];\\n        uint64_t *xyPoint = (uint64_t*)xy;\\n        bool skip;\\n        \\n        for (int y = c.second; y > 0; y--) {\\n            for (int x = c.first; x > 0; x--) {\\n                skip = 1;\\n                \\n                xy[0] = x + o.first; xy[1] = y + o.second;\\n                skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n                \\n                xy[0] = (-x) + o.first; xy[1] = y + o.second;\\n                skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n                \\n                xy[0] = x + o.first; xy[1] = (-y) + o.second;\\n                skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n                \\n                xy[0] = (-x) + o.first; xy[1] = (-y) + o.second;\\n                skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n                \\n                // all points inside the rectangle defined by the 4 corners are already inserted.\\n                if (skip)\\n                    break;\\n            }\\n        }\\n    }\\n    \\n    // arg1: a denotes an x/y plane point on the circumference of the circle\\n    //       whose origin is at \\'(0,0)\\'.\\n    // arg2: o denotes the x, y coordinates of the center of the circle.\\n    // arg3: output set of points inside the circle.\\n    void fillPointsOnAxis(XYPair a, XYPair o, unordered_set<uint64_t>& points)\\n    {\\n        int xy[2];\\n        uint64_t *xyPoint = (uint64_t*)xy;\\n        bool skip;\\n        \\n        xy[0] = o.first; xy[1] = o.second;\\n        points.insert(*xyPoint);\\n        for (int x = a.first, y = a.second; x > 0; x--, y--) {    \\n            skip = 1;\\n            \\n            xy[0] = x + o.first; xy[1] = o.second;\\n            skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n            \\n            xy[0] = (-x) + o.first; xy[1] = o.second;\\n            skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n            \\n            xy[0] = o.first; xy[1] = y + o.second;\\n            skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n            \\n            xy[0] = o.first; xy[1] = (-y) + o.second;\\n            skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n            \\n            if (skip)\\n                break;\\n        }\\n    }\\n    \\n    void generateCircumferencePointsAndFill(XYPair o, int radius, unordered_set<uint64_t>& points)\\n    {\\n        for (int x = o.first + radius - 1; x > o.first; --x) {\\n            for (int y = o.second + radius -1; y > o.second; --y) {\\n                if (ceil(sqrt((x-o.first)*(x-o.first) + (y-o.second)*(y-o.second))) <= radius) {\\n                    fillPointsUsingCircumferencePoint(make_pair(x-o.first, y-o.second), o, points);\\n                    break;\\n                }\\n            }\\n        }\\n        fillPointsOnAxis(make_pair(radius, radius), o, points);\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        unordered_set<uint64_t> lp;\\n        \\n        for (auto circle: circles) {\\n            auto origin = make_pair(circle[0], circle[1]);\\n            auto radius = circle[2];\\n            generateCircumferencePointsAndFill(origin, radius, lp);\\n        }\\n        return lp.size();\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1979983,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int, int>> st;\\n        \\n        for (auto& c : circles) {\\n            const int& x = c[0];\\n            const int& y = c[1];\\n            const int& r = c[2];\\n            \\n            for (int i = x - r; i <= x + r; ++i) {\\n                for (int j = y - r; j <= y + r; ++j) {\\n                    if ((i - x) * (i - x) + (j - y) * (j - y) <= r * r) {\\n                        st.insert({i, j});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int, int>> st;\\n        \\n        for (auto& c : circles) {\\n            const int& x = c[0];\\n            const int& y = c[1];\\n            const int& r = c[2];\\n            \\n            for (int i = x - r; i <= x + r; ++i) {\\n                for (int j = y - r; j <= y + r; ++j) {\\n                    if ((i - x) * (i - x) + (j - y) * (j - y) <= r * r) {\\n                        st.insert({i, j});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979808,
                "title": "scala",
                "content": "```\\nimport math.{pow, sqrt}\\n\\nobject Solution {\\n  def countLatticePoints(circles: Array[Array[Int]]): Int = {\\n    circles\\n      .iterator\\n      .flatMap {\\n        case Array(x, y, r) => (x - r to x + r)\\n          .iterator\\n          .flatMap { i =>\\n            val z = sqrt(pow(r, 2.0) - pow(i - x, 2.0)).toInt\\n            (y - z to y + z).iterator.map(i -> _)\\n          }\\n      }\\n      .distinct\\n      .size\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport math.{pow, sqrt}\\n\\nobject Solution {\\n  def countLatticePoints(circles: Array[Array[Int]]): Int = {\\n    circles\\n      .iterator\\n      .flatMap {\\n        case Array(x, y, r) => (x - r to x + r)\\n          .iterator\\n          .flatMap { i =>\\n            val z = sqrt(pow(r, 2.0) - pow(i - x, 2.0)).toInt\\n            (y - z to y + z).iterator.map(i -> _)\\n          }\\n      }\\n      .distinct\\n      .size\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1979653,
                "title": "java-brute-force",
                "content": "```\\nstatic int X= 0, Y= 1, R= 2;\\n\\n// brute force\\npublic int countLatticePoints(int[][] circles) {\\n\\t// 1. sort circles from largest to smallest (heuristic)\\n\\tArrays.sort(circles, (c1, c2)->Integer.compare(c2[R],c1[R]));\\n\\n    // 2. find the smallest rectangle containing all circles\\n\\tint minX= Integer.MAX_VALUE, maxX= Integer.MIN_VALUE;\\n\\tint minY= Integer.MAX_VALUE, maxY= Integer.MIN_VALUE;\\n\\tfor(int[] c:circles){\\n\\t\\tminX= Math.min(minX, c[X]-c[R]);\\n\\t\\tmaxX= Math.max(maxX, c[X]+c[R]);\\n\\t\\tminY= Math.min(minY, c[Y]-c[R]);\\n\\t\\tmaxY= Math.max(maxY, c[Y]+c[R]);\\n\\t}\\n\\t// 3. for all lattice points in the rectangle check if at least one circle contains them\\n\\tint count= 0;\\n\\tfor(int x=minX; x<=maxX; x++){\\n\\t\\tfor(int y=minY; y<=maxY; y++){\\n\\t\\t\\tfor(int[] c:circles){\\n\\t\\t\\t\\tint rsq= c[R]*c[R];\\n\\t\\t\\t\\tint dx= Math.abs(c[X]-x), dy= Math.abs(c[Y]-y);\\n\\t\\t\\t\\tif(dx*dx+dy*dy<=rsq){\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}           \\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}",
                "solutionTags": [],
                "code": "```\\nstatic int X= 0, Y= 1, R= 2;\\n\\n// brute force\\npublic int countLatticePoints(int[][] circles) {\\n\\t// 1. sort circles from largest to smallest (heuristic)\\n\\tArrays.sort(circles, (c1, c2)->Integer.compare(c2[R],c1[R]));\\n\\n    // 2. find the smallest rectangle containing all circles\\n\\tint minX= Integer.MAX_VALUE, maxX= Integer.MIN_VALUE;\\n\\tint minY= Integer.MAX_VALUE, maxY= Integer.MIN_VALUE;\\n\\tfor(int[] c:circles){\\n\\t\\tminX= Math.min(minX, c[X]-c[R]);\\n\\t\\tmaxX= Math.max(maxX, c[X]+c[R]);\\n\\t\\tminY= Math.min(minY, c[Y]-c[R]);\\n\\t\\tmaxY= Math.max(maxY, c[Y]+c[R]);\\n\\t}\\n\\t// 3. for all lattice points in the rectangle check if at least one circle contains them\\n\\tint count= 0;\\n\\tfor(int x=minX; x<=maxX; x++){\\n\\t\\tfor(int y=minY; y<=maxY; y++){\\n\\t\\t\\tfor(int[] c:circles){\\n\\t\\t\\t\\tint rsq= c[R]*c[R];\\n\\t\\t\\t\\tint dx= Math.abs(c[X]-x), dy= Math.abs(c[Y]-y);\\n\\t\\t\\t\\tif(dx*dx+dy*dy<=rsq){\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}           \\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1979578,
                "title": "easy-brute-force-solution-c",
                "content": "Check for all points and store them in set.\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> s;\\n        for(int i=0;i<circles.size();i++){\\n            \\n            int x=circles[i][0];\\n            int y=circles[i][1];\\n            int r=circles[i][2];\\n            int x1=x-r;\\n            int x2=x+r;\\n            int y1=y-r;\\n            int y2=y+r;\\n            \\n            for(int j=x1;j<=x2;j++){\\n                for(int k=y1;k<=y2;k++){\\n                    if(((j-x)*(j-x)+(k-y)*(k-y))<=(r*r))\\n                    s.insert({j,k});\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> s;\\n        for(int i=0;i<circles.size();i++){\\n            \\n            int x=circles[i][0];\\n            int y=circles[i][1];\\n            int r=circles[i][2];\\n            int x1=x-r;\\n            int x2=x+r;\\n            int y1=y-r;\\n            int y2=y+r;\\n            \\n            for(int j=x1;j<=x2;j++){\\n                for(int k=y1;k<=y2;k++){\\n                    if(((j-x)*(j-x)+(k-y)*(k-y))<=(r*r))\\n                    s.insert({j,k});\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979318,
                "title": "c-optimized-brute-force-100-faster-and-100-less-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int minX{INT_MAX}, minY{INT_MAX}, maxX{}, maxY{}, ct{};\\n\\t\\t\\n\\t\\t// Find bounding box containing all circles\\n        for(const auto& circle : circles)\\n        {\\n            minX = std::min(minX, circle[0] - circle[2]);\\n            minY = std::min(minY, circle[1] - circle[2]);\\n            maxX = std::max(maxX, circle[0] + circle[2]);\\n            maxY = std::max(maxY, circle[1] + circle[2]);\\n        }\\n        \\n\\t\\t// Sweep through the bounding box containing all circles\\n        for(int x = minX; x <= maxX; x++)\\n        {\\n            for(int y = minY; y <= maxY; y++)\\n            {\\n                for(const auto& circle : circles)\\n                {\\n                    int distX{circle[0] - x}, distY{circle[1] - y};\\n                    if(circle[2] * circle[2] < distX * distX + distY * distY)\\n                        continue;\\n                    ct++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int minX{INT_MAX}, minY{INT_MAX}, maxX{}, maxY{}, ct{};\\n\\t\\t\\n\\t\\t// Find bounding box containing all circles\\n        for(const auto& circle : circles)\\n        {\\n            minX = std::min(minX, circle[0] - circle[2]);\\n            minY = std::min(minY, circle[1] - circle[2]);\\n            maxX = std::max(maxX, circle[0] + circle[2]);\\n            maxY = std::max(maxY, circle[1] + circle[2]);\\n        }\\n        \\n\\t\\t// Sweep through the bounding box containing all circles\\n        for(int x = minX; x <= maxX; x++)\\n        {\\n            for(int y = minY; y <= maxY; y++)\\n            {\\n                for(const auto& circle : circles)\\n                {\\n                    int distX{circle[0] - x}, distY{circle[1] - y};\\n                    if(circle[2] * circle[2] < distX * distX + distY * distY)\\n                        continue;\\n                    ct++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979252,
                "title": "python-fast-solution-using-sets-1400ms",
                "content": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        lattices = set()\\n        circles = set([tuple(c) for c in circles]) # remove duplicate circles\\n        for circle in circles:\\n            x,y,r = circle\\n            for X in range(x-r,x+r+1): # lattice x-coord range is [x-r,x+r]; check question image in ques description.\\n                for Y in range(y-r, y+r+1): # lattice y-coord range is [y-r,y+r]\\n                    if (X-x)**2 + (Y-y)**2 - r*r<=0: # check circle equation if points lies inside(<) or on(=) the circle.\\n                        lattices.add((X,Y))\\n        return len(lattices)\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        lattices = set()\\n        circles = set([tuple(c) for c in circles]) # remove duplicate circles\\n        for circle in circles:\\n            x,y,r = circle\\n            for X in range(x-r,x+r+1): # lattice x-coord range is [x-r,x+r]; check question image in ques description.\\n                for Y in range(y-r, y+r+1): # lattice y-coord range is [y-r,y+r]\\n                    if (X-x)**2 + (Y-y)**2 - r*r<=0: # check circle equation if points lies inside(<) or on(=) the circle.\\n                        lattices.add((X,Y))\\n        return len(lattices)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979127,
                "title": "java-generate-points-within-circumference",
                "content": "```\\nimport java.awt.*;\\nclass Solution {\\n    //Author: Anand\\n    public int countLatticePoints(int[][] circles) {\\n        Set<Point> ans = new HashSet<>();\\n\\n        for (int[] c : circles) {\\n            int x = c[0];\\n            int y = c[1];\\n            int r = c[2];\\n            for (int i = x - r; i <= x + r; i++) {\\n                for (int j = y - r; j <= y + r; j++) {\\n                    // calculate distance and check if its within curcumference of circle\\n                    if ((x - i) * (x - i) + (y - j) * (y - j) <= r * r) {\\n                        ans.add(new Point(i, j));\\n                    }\\n                }\\n            }\\n        }\\n        return ans.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.awt.*;\\nclass Solution {\\n    //Author: Anand\\n    public int countLatticePoints(int[][] circles) {\\n        Set<Point> ans = new HashSet<>();\\n\\n        for (int[] c : circles) {\\n            int x = c[0];\\n            int y = c[1];\\n            int r = c[2];\\n            for (int i = x - r; i <= x + r; i++) {\\n                for (int j = y - r; j <= y + r; j++) {\\n                    // calculate distance and check if its within curcumference of circle\\n                    if ((x - i) * (x - i) + (y - j) * (y - j) <= r * r) {\\n                        ans.add(new Point(i, j));\\n                    }\\n                }\\n            }\\n        }\\n        return ans.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979084,
                "title": "c-easy-code-to-undeustand",
                "content": "class Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        \\n        set<pair<int,int>>st;\\n        for(auto it:circles)\\n        {\\n            int x=it[0];\\n            int y=it[1];\\n            int r=it[2];\\n            \\n            for(int i=x-r;i<=x+r;i++)\\n                for(int j=y-r;j<=y+r;j++)\\n                    if((i-x)*(i-x) + (j-y)*(j-y) <= r*r)\\n                        st.insert({i,j});\\n        }\\n        return st.size();\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        \\n        set<pair<int,int>>st;\\n        for(auto it:circles)\\n        {\\n            int x=it[0];\\n            int y=it[1];\\n            int r=it[2];\\n            \\n            for(int i=x-r;i<=x+r;i++)\\n                for(int j=y-r;j<=y+r;j++)\\n                    if((i-x)*(i-x) + (j-y)*(j-y) <= r*r)\\n                        st.insert({i,j}",
                "codeTag": "Java"
            },
            {
                "id": 1979081,
                "title": "java-using-set-pair-or-string-with-comments",
                "content": "```\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        Set<Pair<Integer, Integer>> res = new HashSet<>(); //We need a set to avoid the duplicate\\n        for (int i = 0; i < circles.length; i++){\\n            int cx = circles[i][0]; //x of the center of the circle\\n            int cy = circles[i][1]; //y of the center of the circle\\n            int r = circles[i][2]; // radius of the circle\\n            int xl = cx - r, xh = cx + r; //low and high boundaries for x\\n            int yl = cy - r, yh = cy + r; //low and high boundaries for y\\n            \\n            for (int j = xl; j <= xh; j++){\\n                for (int k = yl; k <= yh; k++){\\n                    int xd = Math.abs(cx - j); //x distance from the center\\n                    int yd = Math.abs(cy - k); //y distance from the center\\n                    \\n                    //if it is on or inside of the circle, add to the set\\n                    if (xd * xd + yd * yd <= r * r){\\n                        \\n                        //if we use, new int[j,k], it won\\'t work because it creates a new object, so we use pair. Alternatively we can use String like \\'j_k\\' so that the set doesn\\'t add any duplicate\\n                        Pair<Integer, Integer> pair = new Pair<>(j,k);\\n                        res.add(pair);\\n                    }\\n                }\\n            }\\n        }\\n        return res.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        Set<Pair<Integer, Integer>> res = new HashSet<>(); //We need a set to avoid the duplicate\\n        for (int i = 0; i < circles.length; i++){\\n            int cx = circles[i][0]; //x of the center of the circle\\n            int cy = circles[i][1]; //y of the center of the circle\\n            int r = circles[i][2]; // radius of the circle\\n            int xl = cx - r, xh = cx + r; //low and high boundaries for x\\n            int yl = cy - r, yh = cy + r; //low and high boundaries for y\\n            \\n            for (int j = xl; j <= xh; j++){\\n                for (int k = yl; k <= yh; k++){\\n                    int xd = Math.abs(cx - j); //x distance from the center\\n                    int yd = Math.abs(cy - k); //y distance from the center\\n                    \\n                    //if it is on or inside of the circle, add to the set\\n                    if (xd * xd + yd * yd <= r * r){\\n                        \\n                        //if we use, new int[j,k], it won\\'t work because it creates a new object, so we use pair. Alternatively we can use String like \\'j_k\\' so that the set doesn\\'t add any duplicate\\n                        Pair<Integer, Integer> pair = new Pair<>(j,k);\\n                        res.add(pair);\\n                    }\\n                }\\n            }\\n        }\\n        return res.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978987,
                "title": "c-code-using-hashmap-faster-than-100",
                "content": "This code utilizes the restrictions that the center coordinates and the radius of each circle are less than 100. \\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        unordered_map<int,bool> mp;\\n        for (int i=0;i<circles.size();i++)\\n        {\\n            int a=circles[i][0],b=circles[i][1],r=circles[i][2];\\n            for (int k=-r;k<=r;k++)\\n                for (int j=-r;j<=r;j++)\\n                    if ( j*j+k*k<=r*r && mp.find(1000*(k+a)+j+b)==mp.end())\\n                        mp.insert({1000*(k+a)+j+b,true});\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        unordered_map<int,bool> mp;\\n        for (int i=0;i<circles.size();i++)\\n        {\\n            int a=circles[i][0],b=circles[i][1],r=circles[i][2];\\n            for (int k=-r;k<=r;k++)\\n                for (int j=-r;j<=r;j++)\\n                    if ( j*j+k*k<=r*r && mp.find(1000*(k+a)+j+b)==mp.end())\\n                        mp.insert({1000*(k+a)+j+b,true});\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978914,
                "title": "distance-formula-python",
                "content": "Equation for Circle:\\nx^2 + y^2 = r^2 #When Circle is from origin as center\\n if (x1,y1) is the center\\n (x-x1)^2 + (y-y1)^2 = r^2\\n \\n x can be in range [x1-r,x1+r]\\n y can be in range [y1-r,y1+r]\\n \\n There is no possibility of all numbers on or inside circle.\\n So check for points which have distance from center less than radius of the circle.\\n \\n Here is the code snippet,\\n Please let me know further optimizations that can be done. Would love to hear.\\n\\n```class Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        s=set()\\n        for i in circles:\\n            for x in range(i[0]-i[2],i[0]+i[2]+1):\\n                for y in range(i[1]-i[2],i[1]+i[2]+1):\\n                    if((x-i[0])**2+(y-i[1])**2)<=i[2]**2:\\n                        s.add((x,y))\\n                    else:\\n                        pass\\n        return len(s)```",
                "solutionTags": [],
                "code": "```class Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        s=set()\\n        for i in circles:\\n            for x in range(i[0]-i[2],i[0]+i[2]+1):\\n                for y in range(i[1]-i[2],i[1]+i[2]+1):\\n                    if((x-i[0])**2+(y-i[1])**2)<=i[2]**2:\\n                        s.add((x,y))\\n                    else:\\n                        pass\\n        return len(s)```",
                "codeTag": "Java"
            },
            {
                "id": 1978908,
                "title": "scala-solution",
                "content": "```\\n  def countLatticePoints(circles: Array[Array[Int]]): Int = {\\n    import scala.collection.mutable\\n    def getBounds(x: Int, y: Int, r: Int): Seq[(Int, Int)] = {\\n      for {\\n        i <- (x - r to x + r)\\n        j <- (y - r to y + r) if ((i - x) * (i - x)) + ((j - y) * (j - y)) <= r * r\\n      } yield (i, j)\\n    }\\n\\n    circles.foldLeft(mutable.HashSet.empty[(Int, Int)]){\\n      case (hash, Array(x, y, r)) => hash.addAll(getBounds(x, y, r))\\n    }.size\\n  }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n  def countLatticePoints(circles: Array[Array[Int]]): Int = {\\n    import scala.collection.mutable\\n    def getBounds(x: Int, y: Int, r: Int): Seq[(Int, Int)] = {\\n      for {\\n        i <- (x - r to x + r)\\n        j <- (y - r to y + r) if ((i - x) * (i - x)) + ((j - y) * (j - y)) <= r * r\\n      } yield (i, j)\\n    }\\n\\n    circles.foldLeft(mutable.HashSet.empty[(Int, Int)]){\\n      case (hash, Array(x, y, r)) => hash.addAll(getBounds(x, y, r))\\n    }.size\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1978790,
                "title": "c-only-find-points-for-one-quadrant-of-circle-easy-to-understand",
                "content": "```\\nvoid addCoords(set<pair<int,int>> &s, int x, int y, int x1, int y1){\\n\\ts.insert({x+x1,y+y1});\\n\\ts.insert({x-x1,y-y1});\\n\\ts.insert({x-x1,y+y1});\\n\\ts.insert({x+x1,y-y1});\\n}\\n\\nint countLatticePoints(vector<vector<int>>& circles) {\\n\\tset<pair<int,int>> s;\\n\\n\\tint n = circles.size();\\n\\n\\tfor(int i=0;i<n;i++){\\n\\t\\tint x = circles[i][0], y = circles[i][1], r = circles[i][2];\\n\\n\\t\\tfor(int x1=0;x1<=r;x1++){\\n\\t\\t\\tfor(int y1=0;y1<=r;y1++){\\n\\t\\t\\t\\tif(((x1*x1)+(y1*y1))<=(r*r))\\n\\t\\t\\t\\t\\taddCoords(s,x,y,x1,y1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn s.size();\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nvoid addCoords(set<pair<int,int>> &s, int x, int y, int x1, int y1){\\n\\ts.insert({x+x1,y+y1});\\n\\ts.insert({x-x1,y-y1});\\n\\ts.insert({x-x1,y+y1});\\n\\ts.insert({x+x1,y-y1});\\n}\\n\\nint countLatticePoints(vector<vector<int>>& circles) {\\n\\tset<pair<int,int>> s;\\n\\n\\tint n = circles.size();\\n\\n\\tfor(int i=0;i<n;i++){\\n\\t\\tint x = circles[i][0], y = circles[i][1], r = circles[i][2];\\n\\n\\t\\tfor(int x1=0;x1<=r;x1++){\\n\\t\\t\\tfor(int y1=0;y1<=r;y1++){\\n\\t\\t\\t\\tif(((x1*x1)+(y1*y1))<=(r*r))\\n\\t\\t\\t\\t\\taddCoords(s,x,y,x1,y1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn s.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1978730,
                "title": "python-simulation-beat-100",
                "content": "\\tfrom math import sqrt\\n\\n\\tclass Solution:\\n\\t\\tdef countLatticePoints(self, circles: List[List[int]]) -> int:\\n\\n\\t\\t\\tpt_set=set()\\n\\t\\t\\tfor circle in circles:\\n\\t\\t\\t\\tx = circle[0]\\n\\t\\t\\t\\ty = circle[1]\\n\\t\\t\\t\\tr = circle[2]\\n\\n\\t\\t\\t\\tmin_x =   x - r\\n\\t\\t\\t\\tmax_x =   x + r\\n\\n\\t\\t\\t\\tfor _x in range(min_x,max_x+1):\\n\\t\\t\\t\\t\\t_y = int(sqrt(r**2-(x-_x)**2))\\n\\t\\t\\t\\t\\tfor y_ in range(_y+1):\\n\\t\\t\\t\\t\\t\\tpt_set.add((_x,y+y_))\\n\\t\\t\\t\\t\\t\\tpt_set.add((_x,y-y_))\\n\\n\\n\\n\\t\\t\\treturn len(list(pt_set))\\n                    \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tfrom math import sqrt\\n\\n\\tclass Solution:\\n\\t\\tdef countLatticePoints(self, circles: List[List[int]]) -> int:\\n\\n\\t\\t\\tpt_set=set()\\n\\t\\t\\tfor circle in circles:\\n\\t\\t\\t\\tx = circle[0]\\n\\t\\t\\t\\ty = circle[1]\\n\\t\\t\\t\\tr = circle[2]\\n\\n\\t\\t\\t\\tmin_x =   x - r\\n\\t\\t\\t\\tmax_x =   x + r\\n\\n\\t\\t\\t\\tfor _x in range(min_x,max_x+1):\\n\\t\\t\\t\\t\\t_y = int(sqrt(r**2-(x-_x)**2))\\n\\t\\t\\t\\t\\tfor y_ in range(_y+1):\\n\\t\\t\\t\\t\\t\\tpt_set.add((_x,y+y_))\\n\\t\\t\\t\\t\\t\\tpt_set.add((_x,y-y_))\\n\\n\\n\\n\\t\\t\\treturn len(list(pt_set))\\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 1978671,
                "title": "use-a-dictionary-in-python-faster-than-100",
                "content": "There\\'s so much time difference between using a list to check if the point is repeated to using a dictionary. Spent nearly 4 hours and just changed points=[] to points={} and boom it got accepted.\\nLesson- Always use a dictionary whenever searching is involved.\\n\\n```\\n\\nimport math\\nclass Solution:\\n    def countLatticePoints(self, circles) :\\n\\n        point = {}\\n\\n        for c in circles:\\n\\n            xc = c[0]\\n            yc = c[1]\\n            r = c[2]\\n            xmin = xc - r\\n            xmax = xc + r\\n            ymin = yc - r\\n            ymax = yc + r\\n\\n            for x in range(xmin, xmax + 1):\\n                for y in range(ymin, ymax + 1):\\n\\n                    t = (x, y)\\n                    if t in point:\\n                        continue\\n                    if ((x==xmax or x==xmin)and(y==ymax or y==ymin)):\\n                            continue\\n                    else:\\n                            dist = math.sqrt((x - xc) ** 2 + (y - yc) ** 2)\\n                            if dist <= r:\\n                                point[t]=1\\n\\n\\n        return len((point))\\n\\n\\ns=Solution()\\nprint(s.countLatticePoints([[2,2,2],[3,4,1]]))\\n```\\n\\n![image](https://assets.leetcode.com/users/images/6b2fba46-2e40-4ea8-bf4e-8bd5c82c10bf_1650809287.3620253.png)\\n",
                "solutionTags": [],
                "code": "```\\n\\nimport math\\nclass Solution:\\n    def countLatticePoints(self, circles) :\\n\\n        point = {}\\n\\n        for c in circles:\\n\\n            xc = c[0]\\n            yc = c[1]\\n            r = c[2]\\n            xmin = xc - r\\n            xmax = xc + r\\n            ymin = yc - r\\n            ymax = yc + r\\n\\n            for x in range(xmin, xmax + 1):\\n                for y in range(ymin, ymax + 1):\\n\\n                    t = (x, y)\\n                    if t in point:\\n                        continue\\n                    if ((x==xmax or x==xmin)and(y==ymax or y==ymin)):\\n                            continue\\n                    else:\\n                            dist = math.sqrt((x - xc) ** 2 + (y - yc) ** 2)\\n                            if dist <= r:\\n                                point[t]=1\\n\\n\\n        return len((point))\\n\\n\\ns=Solution()\\nprint(s.countLatticePoints([[2,2,2],[3,4,1]]))\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1820000,
                "content": [
                    {
                        "username": "Charles1791",
                        "content": "In this question, hash set runs slower than a tree set, interesting! Too much hash collision? \\n\\nFor c++ coder: use set<pair<int,int>> instead of unordered_set<pair<int,int>>, or you\\'d get TLE for the last test case"
                    },
                    {
                        "username": "Shohan07",
                        "content": "Circle Equations  https://www.mathopenref.com/coordgeneralcircle.html"
                    }
                ]
            },
            {
                "id": 1576704,
                "content": [
                    {
                        "username": "Charles1791",
                        "content": "In this question, hash set runs slower than a tree set, interesting! Too much hash collision? \\n\\nFor c++ coder: use set<pair<int,int>> instead of unordered_set<pair<int,int>>, or you\\'d get TLE for the last test case"
                    },
                    {
                        "username": "Shohan07",
                        "content": "Circle Equations  https://www.mathopenref.com/coordgeneralcircle.html"
                    }
                ]
            }
        ]
    },
    {
        "title": "Remove Digit From Number to Maximize Result",
        "question_content": "<p>You are given a string <code>number</code> representing a <strong>positive integer</strong> and a character <code>digit</code>.</p>\n\n<p>Return <em>the resulting string after removing <strong>exactly one occurrence</strong> of </em><code>digit</code><em> from </em><code>number</code><em> such that the value of the resulting string in <strong>decimal</strong> form is <strong>maximized</strong></em>. The test cases are generated such that <code>digit</code> occurs at least once in <code>number</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> number = &quot;123&quot;, digit = &quot;3&quot;\n<strong>Output:</strong> &quot;12&quot;\n<strong>Explanation:</strong> There is only one &#39;3&#39; in &quot;123&quot;. After removing &#39;3&#39;, the result is &quot;12&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> number = &quot;1231&quot;, digit = &quot;1&quot;\n<strong>Output:</strong> &quot;231&quot;\n<strong>Explanation:</strong> We can remove the first &#39;1&#39; to get &quot;231&quot; or remove the second &#39;1&#39; to get &quot;123&quot;.\nSince 231 &gt; 123, we return &quot;231&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> number = &quot;551&quot;, digit = &quot;5&quot;\n<strong>Output:</strong> &quot;51&quot;\n<strong>Explanation:</strong> We can remove either the first or second &#39;5&#39; from &quot;551&quot;.\nBoth result in the string &quot;51&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= number.length &lt;= 100</code></li>\n\t<li><code>number</code> consists of digits from <code>&#39;1&#39;</code> to <code>&#39;9&#39;</code>.</li>\n\t<li><code>digit</code> is a digit from <code>&#39;1&#39;</code> to <code>&#39;9&#39;</code>.</li>\n\t<li><code>digit</code> occurs at least once in <code>number</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1996265,
                "title": "check-next-digit",
                "content": "We can generate all strings, and compare them to find the largest. That, however, would be quite wasteful. \\n\\nInstead, we can just remove the leftmost `digit` if it\\'s followed by a larger number. If we cannot find such case, we remove the last occurence of `digit`.  \\n\\n**C++**\\n```cpp\\nstring removeDigit(string n, char digit) {\\n    for (int i = 0; i < n.size() - 1; ++i)\\n        if (n[i] == digit && n[i + 1] > digit)\\n            return n.substr(0, i) + n.substr(i + 1);\\n    int last_d = n.rfind(digit);\\n    return n.substr(0, last_d) + n.substr(last_d + 1);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstring removeDigit(string n, char digit) {\\n    for (int i = 0; i < n.size() - 1; ++i)\\n        if (n[i] == digit && n[i + 1] > digit)\\n            return n.substr(0, i) + n.substr(i + 1);\\n    int last_d = n.rfind(digit);\\n    return n.substr(0, last_d) + n.substr(last_d + 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1996563,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string res = \"\";\\n        for(int i=0; i<number.size(); i++){\\n            if(number[i] == digit){\\n                string temp = number.substr(0, i) + number.substr(i+1);\\n                res = max(res, temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string res = \"\";\\n        for(int i=0; i<number.size(); i++){\\n            if(number[i] == digit){\\n                string temp = number.substr(0, i) + number.substr(i+1);\\n                res = max(res, temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996585,
                "title": "o-n-solution",
                "content": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        int index = 0,n=number.length();\\n        for(int i=0;i<n;i++){\\n            if(number.charAt(i)==digit){\\n                index = i;\\n                if(i<n-1 && digit < number.charAt(i+1)) break;\\n            }\\n        }\\n        number = number.substring(0, index) + number.substring(index+1);\\n        return number;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        int index = 0,n=number.length();\\n        for(int i=0;i<n;i++){\\n            if(number.charAt(i)==digit){\\n                index = i;\\n                if(i<n-1 && digit < number.charAt(i+1)) break;\\n            }\\n        }\\n        number = number.substring(0, index) + number.substring(index+1);\\n        return number;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996226,
                "title": "java-solution-using-sort",
                "content": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {   \\n        List<String> digits = new ArrayList<>();\\n        for (int i = 0; i < number.length(); i++) {\\n            if (number.charAt(i) == digit) {\\n                String stringWithoutDigit = number.substring(0, i) + number.substring(i + 1);\\n                digits.add(stringWithoutDigit);\\n            }\\n        }        \\n        Collections.sort(digits);\\n        return digits.get(digits.size() - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {   \\n        List<String> digits = new ArrayList<>();\\n        for (int i = 0; i < number.length(); i++) {\\n            if (number.charAt(i) == digit) {\\n                String stringWithoutDigit = number.substring(0, i) + number.substring(i + 1);\\n                digits.add(stringWithoutDigit);\\n            }\\n        }        \\n        Collections.sort(digits);\\n        return digits.get(digits.size() - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074599,
                "title": "python-o-n-solution-faster-than-99-submissions-detailed-explanation",
                "content": "***Please Upvote, comment and share if you like the detailed explanation and the solution***\\n\\nLet us understand with an example: \\n`Number = 9515901 and digit = 9`\\n\\n1. Since the occurence of the number `9` is happening twice in the string(number), and we can only remove one `9` from the string, we can achieve the Maximum possible outcome in the below cases:\\n\\t* `Case 1`: If the first occurence of 9 `is greater than` the next element at index `i+1`.\\n\\t* `Case 2`: If not the first occurence, we iterate till next/last occurence, and the next occurence has number 9 less than the index `i+1`.\\n\\t* `Case 3`: This would be if there is a number `9` present at the end of the string.\\n\\t\\n\\n2. In the given example we have 2 possiblities: `515901` and `951501`.\\n\\n3. As per the condition of the problem, the maximum returned value from the above sample should be `951501` as per **case 2**. \\n4. Since `9` is less than `5` (if we consider the outcome `515901`), it would have resulted in a string with lower value. Hence we keep moving forward till we find this condition to be true `number[i]` is greater than `number[i-1]`. And remove the character from from that position.\\n\\n5. `Edge Case`: This is the scenario where none of the above two cases holds true. In this case, we have to remove the last occurence of the digit, hence, `case 3` is added to find the last occurence of `9` and remove it.\\n\\n```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        \\n        # Initializing the last index as zero\\n        last_index = 0\\n        \\n        #iterating each number to find the occurences, \\\\\\n        # and to find if the number is greater than the next element \\\\ \\n\\n        for num in range(1, len(number)):\\n            \\n            # Handling [case 1] and [case 2]\\n            if number[num-1] == digit:\\n                if int(number[num]) > int(number[num-1]):\\n                    return number[:num-1] + number[num:]\\n                else:\\n                    last_index = num - 1\\n        \\n        # If digit is the last number (last occurence) in the string [case 3]\\n        if number[-1] == digit:\\n            last_index = len(number) - 1\\n\\n        return number[:last_index] + number[last_index + 1:]\\n```\\n\\nBetter and faster than **99% of submissions** \\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\n\\n![image](https://assets.leetcode.com/users/images/efc0cc4e-ef92-417f-a54e-e6c63172110e_1653538960.6057386.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        \\n        # Initializing the last index as zero\\n        last_index = 0\\n        \\n        #iterating each number to find the occurences, \\\\\\n        # and to find if the number is greater than the next element \\\\ \\n\\n        for num in range(1, len(number)):\\n            \\n            # Handling [case 1] and [case 2]\\n            if number[num-1] == digit:\\n                if int(number[num]) > int(number[num-1]):\\n                    return number[:num-1] + number[num:]\\n                else:\\n                    last_index = num - 1\\n        \\n        # If digit is the last number (last occurence) in the string [case 3]\\n        if number[-1] == digit:\\n            last_index = len(number) - 1\\n\\n        return number[:last_index] + number[last_index + 1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998434,
                "title": "c-tc-o-n-sc-o-1-no-string-compare-explanation",
                "content": "\\n\\n# Solution \\n\\n```C++\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        int pos = -1, n = number.size();\\n        for(int i = n-1; i>=0;i--) {\\n            if((number[i] == digit) && (pos == -1 || number[i+1]>number[i])) {\\n                pos = i;\\n            }\\n        }\\n        return number.erase(pos,1);\\n    }\\n};\\n```\\n\\n# Observation\\n*(1) The left-most digit greater than its right neighbor*\\n\\nWhen\\n```\\ndigit = \\'3\\'  and number \"14323938\"\\n```\\nYou just need to delete the first digit=3 which is greater than its right element.\\nThen you can get the answer is \\n```\\n1432_938. \\n```\\n\\n*(2) Otherwise, consider the right-most digit*\\n\\nBut if there is not exist first digit which is greater than its right element,  then\\nyou just need to delete the last digit to get the answer.\\nFor example,\\n```\\ndigit = \\'3\\'  and number= \"143233138\"\\n```\\n\\nthe answer is \\n```\\n1432331_8\\n```\\n.\\n\\n# Code Explanation\\nI set pos = -1 first.\\nIn my loop, it running from the most right to most left. \\nSo it will set the pos int\\xF4 the last digit in number first. \\nIf there is digit in front of pos  that larger than its right neighbor, then update pos. \\nSo the pos can be the pos of first digit which is greater than its right neighbor if the such pos exist.\\n\\nSome people may ask that should I need to check the boundary of  i+1. \\n```number[i+1]>number[i]```\\nIn our loop structure, we don\\'t need to check i+1<n because the code will check the truth of pos==-1 \\nfirst when right-most element of string is the same as to digit. So we can save time to check ```i+1<n```\\n\\n\\n\\n\\n# Complexity Analysis \\n*Time Complexity O(N)*\\nThe loop only travel from right-most element to left-most element. \\nAnd each operation in it using O(1)\\nSo the total time complexity is O(N) in worst case.\\n*Space Complexity O(1)*\\nAfter finding the pos, it erase internal char in string and return the string itself.\\nSo space complexity is O(1). \\n\\n# Optimize \\nI put the O(N) code in the top  of this article.\\nBut if you want to improve the code in average case, then you can do this.\\n\\n```C++\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        int n = number.size(), pos = n;\\n        for(int i = 0;i<n;i++) {\\n            if(number[i] == digit && number[i+1]>number[i]) {\\n                pos=i;\\n                break;\\n            }\\n        }        \\n        if(pos==n) {\\n            for(int i = n-1; i>=0;i--) {\\n                if (number[i] == digit) {\\n                    pos = i;\\n                    break;\\n                }\\n            }            \\n        }\\n        return number.erase(pos,1);\\n    }\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        int pos = -1, n = number.size();\\n        for(int i = n-1; i>=0;i--) {\\n            if((number[i] == digit) && (pos == -1 || number[i+1]>number[i])) {\\n                pos = i;\\n            }\\n        }\\n        return number.erase(pos,1);\\n    }\\n};\\n```\n```\\ndigit = \\'3\\'  and number \"14323938\"\\n```\n```\\n1432_938. \\n```\n```\\ndigit = \\'3\\'  and number= \"143233138\"\\n```\n```\\n1432331_8\\n```\n```number[i+1]>number[i]```\n```i+1<n```\n```C++\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        int n = number.size(), pos = n;\\n        for(int i = 0;i<n;i++) {\\n            if(number[i] == digit && number[i+1]>number[i]) {\\n                pos=i;\\n                break;\\n            }\\n        }        \\n        if(pos==n) {\\n            for(int i = n-1; i>=0;i--) {\\n                if (number[i] == digit) {\\n                    pos = i;\\n                    break;\\n                }\\n            }            \\n        }\\n        return number.erase(pos,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2633956,
                "title": "java-solution-easy",
                "content": "### Please Upvote !!! :D\\n```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        for (int i = 1; i < number.length(); i++) {\\n            if (number.charAt(i - 1) == digit) {\\n                if (number.charAt(i) > number.charAt(i - 1)) {\\n                    return number.substring(0, i - 1) + number.substring(i);\\n                }\\n            }\\n        }\\n\\n        int lastIdx = number.lastIndexOf(digit);\\n        return number.substring(0, lastIdx) + number.substring(lastIdx + 1);\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        for (int i = 1; i < number.length(); i++) {\\n            if (number.charAt(i - 1) == digit) {\\n                if (number.charAt(i) > number.charAt(i - 1)) {\\n                    return number.substring(0, i - 1) + number.substring(i);\\n                }\\n            }\\n        }\\n\\n        int lastIdx = number.lastIndexOf(digit);\\n        return number.substring(0, lastIdx) + number.substring(lastIdx + 1);\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997475,
                "title": "java-simple",
                "content": "```java\\npublic String removeDigit(String number, char digit) {\\n        List<String> nums = new ArrayList<>();\\n        \\n        for (int i = 0; i < number.length(); i++) {\\n            if (number.charAt(i) == digit) \\n                nums.add(number.substring(0, i) + number.substring(i + 1));\\n        }\\n        \\n        return nums.stream().sorted().collect(Collectors.toList()).get(nums.size() - 1);\\n    }\\n```\\n\\nMy repositories with leetcode problems solving - [Java](https://github.com/FLlGHT/algorithms/tree/master/j-algorithms/src/main/java),  [C++](https://github.com/FLlGHT/algorithms/tree/master/c-algorithms/src/main/c%2B%2B)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic String removeDigit(String number, char digit) {\\n        List<String> nums = new ArrayList<>();\\n        \\n        for (int i = 0; i < number.length(); i++) {\\n            if (number.charAt(i) == digit) \\n                nums.add(number.substring(0, i) + number.substring(i + 1));\\n        }\\n        \\n        return nums.stream().sorted().collect(Collectors.toList()).get(nums.size() - 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1996355,
                "title": "python-3-brute-force-easy-solution",
                "content": "**Approach:** For all the occurences, remove it and find the maximum of all the possible numbers generated.\\n\\n**DO UPVOTE IF YOU FOUND IT HELPFUL.**\\n\\n```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        ans = 0\\n        for i, dig in enumerate(list(number)):\\n            if dig == digit:\\n                ans = max(ans, int(number[:i]+number[i+1:]))\\n        \\n        return str(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        ans = 0\\n        for i, dig in enumerate(list(number)):\\n            if dig == digit:\\n                ans = max(ans, int(number[:i]+number[i+1:]))\\n        \\n        return str(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571790,
                "title": "python-easy-solution",
                "content": "```\\ndef removeDigit(self, number: str, digit: str) -> str:\\n        output = []\\n        for i in range(len(number)):\\n            if number[i] == digit:\\n                output.append(number[:i]+number[i+1:])\\n        return max(output)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef removeDigit(self, number: str, digit: str) -> str:\\n        output = []\\n        for i in range(len(number)):\\n            if number[i] == digit:\\n                output.append(number[:i]+number[i+1:])\\n        return max(output)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1996388,
                "title": "c-brute-force-clean-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    string removeDigit(string number, char digit) {\\n     \\n        int n=number.size();\\n        int i;\\n        vector<string>ans;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(number[i]==digit)\\n            {\\n                string res=number.substr(0,i);\\n                res+=number.substr(i+1,n-i-1);\\n                \\n               //cout<<res<<endl;\\n                ans.push_back(res);\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans[ans.size()-1];\\n    }\\n};\\n```\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    string removeDigit(string number, char digit) {\\n     \\n        int n=number.size();\\n        int i;\\n        vector<string>ans;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(number[i]==digit)\\n            {\\n                string res=number.substr(0,i);\\n                res+=number.substr(i+1,n-i-1);\\n                \\n               //cout<<res<<endl;\\n                ans.push_back(res);\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans[ans.size()-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3770024,
                "title": "easy-cpp-solution-with-detailed-stepwise-explanation",
                "content": "\\n\\n# Approach\\n1. Initialize an empty string named `result` to store the final result.\\n2. Start a `for` loop that iterates from `i = 0` to `i < number.size()`.\\n3. Inside the loop, check if the character at index `i` in `number` is equal to the given `digit`.\\n4. If the character matches the `digit`, create a temporary string named `temp` by removing the character at index `i` from `number`. This is done using the `substr` function to concatenate the substrings before and after the digit.\\n5. Compare `temp` with `result` using the `max` function and store the larger string as the new value of `result`. This ensures that `result` will contain the maximum value obtained by removing `digit` from `number`.\\n6. Continue the loop until all characters in `number` have been checked.\\n7. After the loop ends, return the final `result` string, which represents `number` with the maximum occurrences of `digit` removed.\\n\\n# Complexity\\n- Time complexity:\\n   - O(n)\\n\\n- Space complexity:\\n   - O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string result=\"\";\\n        for(int i=0;i<number.size();i++)\\n        {\\n            if(number[i]==digit)\\n            {\\n                string temp =number.substr(0,i)+number.substr(i+1,number.size());\\n                result=max(temp,result);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n# Please upvote and feel free to ask doubts",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string result=\"\";\\n        for(int i=0;i<number.size();i++)\\n        {\\n            if(number[i]==digit)\\n            {\\n                string temp =number.substr(0,i)+number.substr(i+1,number.size());\\n                result=max(temp,result);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996344,
                "title": "intuition-explained-o-n-time-o-1-space-simple-solution-c",
                "content": "#### \\u2728 METHOD: \\n* Example: string s = 13413 and digit = 3\\n\\t* We will get the highest number by following these 2 conditions:\\n\\t\\t* condition 1: **if the next character is larger than current character**\\n\\t\\t* condition 2:  **element following previous condition and is the leftmost character.**\\n\\t* In the given example we have 2 possiblities:\\n\\t\\t* 1413 and 1341\\n\\t\\t* According to the above mentioned two conditions: 1413 will be the answer as the 3 indexed 1 is the \"3\" with next element greater than it and is the leftmost \"3\"\\n\\t* **Handling the edge case**! \\n\\t\\t* The case when we get none of the characters following condition 1 is the edge case\\n\\t\\t* In this case, we have to remove the last occurence of the digit.\\n```\\nstring removeDigit(string s, char digit) {\\n        int n = s.length();\\n        long int last = s.find_last_of(digit);\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i] == digit)\\n            {\\n                if(i != last)\\n                {\\n                    if(s[i+1] > s[i])\\n                    {\\n                        s.erase(i, 1);\\n                        break;\\n                    }\\n                }\\n                else\\n                {\\n                    s.erase(i, 1);\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring removeDigit(string s, char digit) {\\n        int n = s.length();\\n        long int last = s.find_last_of(digit);\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i] == digit)\\n            {\\n                if(i != last)\\n                {\\n                    if(s[i+1] > s[i])\\n                    {\\n                        s.erase(i, 1);\\n                        break;\\n                    }\\n                }\\n                else\\n                {\\n                    s.erase(i, 1);\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3180787,
                "title": "c-super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- My intuition was to traverse the string from last to find out the maximum, but when I coded, I found.. no matter how u traverse (either from beginning or end) the result remains same.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The function iterates over the number string in reverse order using a for loop that starts from n-1 and goes till 0.\\n\\n- For each iteration, if the current character in the string number is equal to digit, the function removes that character from the string by creating a new string temp which is formed by concatenating two substrings of the number string. The first substring is from the start of the string till the current character, and the second substring is from the next character till the end of the string.\\n\\n- After removing the character, the function compares the temp string with the current value of res and sets res to the maximum of the two strings. This is done because the goal of the function is to return the largest number that can be obtained by removing one occurrence of the digit character.\\n\\n- Finally, after the loop, the function returns the res string which is the largest number that can be obtained by removing one occurrence of the digit character from the input number string.\\n\\n\\n\\n\\n\\n\\n# Complexity\\nTime complexity: O(n)\\n- The time complexity of the function is O(n), where n is the length of the input string number. This is because the function iterates over the entire string number once in the for loop. The comparison and concatenation of strings in each iteration takes O(n) time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nSpace complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The space complexity of the function is O(n), where n is the length of the input string number. This is because the function creates a new string temp in each iteration which has the same length as the input string number. The function also creates a string res which is updated in each iteration and its final length is also equal to the length of the input string number.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) \\n    {\\n        int n = number.size();\\n        string res = \"\";\\n\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            if(number[i] == digit)\\n            {\\n                string temp = number.substr(0, i) + number.substr(i+1, n);\\n                res = max(res, temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) \\n    {\\n        int n = number.size();\\n        string res = \"\";\\n\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            if(number[i] == digit)\\n            {\\n                string temp = number.substr(0, i) + number.substr(i+1, n);\\n                res = max(res, temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066393,
                "title": "c-string-easy-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) \\n    {\\n        string ans = \"0\";\\n        \\n        //Iterating over the number and whenever digit is found, we remove it and\\n        //string that has been made after removing digit will be compared to get max string \\n        for(int i=0; i<number.size(); i++)\\n        {\\n            if(number[i]==digit)\\n            {\\n                string temp = number.substr(0,i) + number.substr(i+1, number.size());\\n                ans = max(ans, temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) \\n    {\\n        string ans = \"0\";\\n        \\n        //Iterating over the number and whenever digit is found, we remove it and\\n        //string that has been made after removing digit will be compared to get max string \\n        for(int i=0; i<number.size(); i++)\\n        {\\n            if(number[i]==digit)\\n            {\\n                string temp = number.substr(0,i) + number.substr(i+1, number.size());\\n                ans = max(ans, temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998326,
                "title": "100-faster-solution-easy-solution",
                "content": "```\\nclass Solution {\\n    public String removeDigit(String s, char digit) {\\n        int n = s.length();\\n        String res = \"\";\\n        for(int i=0; i<n; i++){\\n            if(s.charAt(i)==digit){\\n                String t = s.substring(0,i)+s.substring(i+1);\\n                if(t.compareTo(res)>0){\\n                    res = t;\\n                }\\n            }      \\n        }\\n        \\n        return res;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String s, char digit) {\\n        int n = s.length();\\n        String res = \"\";\\n        for(int i=0; i<n; i++){\\n            if(s.charAt(i)==digit){\\n                String t = s.substring(0,i)+s.substring(i+1);\\n                if(t.compareTo(res)>0){\\n                    res = t;\\n                }\\n            }      \\n        }\\n        \\n        return res;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996404,
                "title": "javascript-easy-solution-sorting",
                "content": "```\\n/**\\n * @param {string} number\\n * @param {character} digit\\n * @return {string}\\n */\\nvar removeDigit = function(number, digit) {\\n    \\n    let str = [];\\n    let flag = 0;\\n    for (let i = 0; i < number.length; i++) {\\n        if (number[i] == digit ) {\\n            let temp = number.substring(0, i) + number.substring(i+1);\\n            str.push(temp);\\n        }\\n    }\\n    \\n    str.sort();\\n    return str[str.length-1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {string} number\\n * @param {character} digit\\n * @return {string}\\n */\\nvar removeDigit = function(number, digit) {\\n    \\n    let str = [];\\n    let flag = 0;\\n    for (let i = 0; i < number.length; i++) {\\n        if (number[i] == digit ) {\\n            let temp = number.substring(0, i) + number.substring(i+1);\\n            str.push(temp);\\n        }\\n    }\\n    \\n    str.sort();\\n    return str[str.length-1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1996280,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string x=number;\\n        int n=x.length();\\n        int i=0,j=n-1;\\n        bool ok=true;\\n        while(i<n)\\n        {\\n            if(i-1<n&&digit==x[i]&&x[i+1]>digit)\\n            {\\n                ok=false;\\n                x.erase(i,1);\\n                break;\\n            }\\n            i++;\\n        }\\n       \\n        while(j>=0)\\n        {\\n            if(digit==number[j])\\n            {\\n                number.erase(j,1);\\n                break;\\n            }\\n            j--;\\n        }\\n        if(ok)\\n        return number;\\n        \\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string x=number;\\n        int n=x.length();\\n        int i=0,j=n-1;\\n        bool ok=true;\\n        while(i<n)\\n        {\\n            if(i-1<n&&digit==x[i]&&x[i+1]>digit)\\n            {\\n                ok=false;\\n                x.erase(i,1);\\n                break;\\n            }\\n            i++;\\n        }\\n       \\n        while(j>=0)\\n        {\\n            if(digit==number[j])\\n            {\\n                number.erase(j,1);\\n                break;\\n            }\\n            j--;\\n        }\\n        if(ok)\\n        return number;\\n        \\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903768,
                "title": "c-best-solution-in-o-n-time-complexity-and-o-1-space-complexity",
                "content": "**Bold**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: \\n1) Run a for loop and create a count for the number of times the digit appears.\\n2) Go through the string and the first instance where s[i] is equal to the digit and s[i+1] is greater than the digit, remove s[i] and return.\\n3) In cases where the s[i+1] is always lesser than or equal to the digit, we erase the last instance of the digit, which is why the iter variable is created\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) \\n    {\\n        int count=0,iter=1;;\\n        int s[number.size()];\\n        for (int i = 0; i < number.length(); ++i) \\n        {\\n            if (number[i] == digit) \\n            {\\n                count++;\\n            }\\n        }\\n        for (int i = 0; i < number.length(); ++i) \\n        {\\n            if (number[i] == digit && iter==count) \\n            {\\n                number.erase(number.begin() + i);\\n                break;\\n            }\\n            else if(number[i] == digit && iter!=count)\\n            {\\n                if(number[i+1]>number[i]) \\n                    {\\n                        number.erase(number.begin() + i);\\n                        break;\\n                    }\\n                else\\n                {\\n                    iter++;\\n                    continue;\\n                }\\n            }\\n            \\n        }\\n    return number;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) \\n    {\\n        int count=0,iter=1;;\\n        int s[number.size()];\\n        for (int i = 0; i < number.length(); ++i) \\n        {\\n            if (number[i] == digit) \\n            {\\n                count++;\\n            }\\n        }\\n        for (int i = 0; i < number.length(); ++i) \\n        {\\n            if (number[i] == digit && iter==count) \\n            {\\n                number.erase(number.begin() + i);\\n                break;\\n            }\\n            else if(number[i] == digit && iter!=count)\\n            {\\n                if(number[i+1]>number[i]) \\n                    {\\n                        number.erase(number.begin() + i);\\n                        break;\\n                    }\\n                else\\n                {\\n                    iter++;\\n                    continue;\\n                }\\n            }\\n            \\n        }\\n    return number;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599927,
                "title": "java-string-math-easy-solution",
                "content": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        int l=number.length();\\n        int last=number.lastIndexOf(digit);\\n        for(int i=0;i<l-1;i++){\\n            if(number.charAt(i)==digit && number.charAt(i+1)>number.charAt(i)){\\n                return number.substring(0,i)+number.substring(i+1);\\n            }\\n        }\\n        return number.substring(0,last)+number.substring(last+1);\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        int l=number.length();\\n        int last=number.lastIndexOf(digit);\\n        for(int i=0;i<l-1;i++){\\n            if(number.charAt(i)==digit && number.charAt(i+1)>number.charAt(i)){\\n                return number.substring(0,i)+number.substring(i+1);\\n            }\\n        }\\n        return number.substring(0,last)+number.substring(last+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001661,
                "title": "check-next-digit-before-deleting",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) \\n    {\\n        string ans = \"\"; int pos = -1; bool flag = false;\\n        for (int i = 0; i < number.size(); i++)\\n        {\\n            if (number[i] == digit)\\n            {\\n                pos = i;\\n                if ((i < number.size() - 1) && number[i] < number[i + 1] && !flag)\\n                {\\n                    flag = true;\\n                    continue;\\n                }\\n            }\\n            ans += number[i];\\n        }\\n        \\n        if (flag == false)\\n        {\\n            ans = \"\";\\n            for (int i = 0; i < number.size(); i++)\\n                if (i != pos)\\n                    ans += number[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) \\n    {\\n        string ans = \"\"; int pos = -1; bool flag = false;\\n        for (int i = 0; i < number.size(); i++)\\n        {\\n            if (number[i] == digit)\\n            {\\n                pos = i;\\n                if ((i < number.size() - 1) && number[i] < number[i + 1] && !flag)\\n                {\\n                    flag = true;\\n                    continue;\\n                }\\n            }\\n            ans += number[i];\\n        }\\n        \\n        if (flag == false)\\n        {\\n            ans = \"\";\\n            for (int i = 0; i < number.size(); i++)\\n                if (i != pos)\\n                    ans += number[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997952,
                "title": "100-fast-and-easy-code-check-next-digit",
                "content": "**Intutuion** : If you want to get maximum number by deleting we have to replace it by bigger number else we have to delete the last occurence of the digit. \\nSo here we store the index of the occurence of digit and check if the next number is bigger than the number then we break out of loop and remove that number else we remove the last occurence of the digit\\n\\n```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        int idx=-1;\\n       int n=number.size();\\n        for(int i=0;i<number.size();i++){\\n            if(number[i]==digit){\\n                idx=i;\\n            }\\n            if(idx!=-1 && idx!=n-1){\\n                if(number[idx+1]>digit)\\n                    break;\\n            }\\n        }\\n        number.erase(number.begin()+idx);\\n        return number;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        int idx=-1;\\n       int n=number.size();\\n        for(int i=0;i<number.size();i++){\\n            if(number[i]==digit){\\n                idx=i;\\n            }\\n            if(idx!=-1 && idx!=n-1){\\n                if(number[idx+1]>digit)\\n                    break;\\n            }\\n        }\\n        number.erase(number.begin()+idx);\\n        return number;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997030,
                "title": "easy-faster-than-100-o-n-time-java",
                "content": "**Explanation**\\nTo get the maximum element we have to remove leftmost(most Significant) occurence of **digit** whose **next character** is **greater** than it.\\nIn case we are unable to find such occurance....we willl remove the right most(least significant) occurance of the **digit** so  as to get **maximum number**.\\n```\\nfor(int i=0; i<number.length()-1; i++){\\n            if(number.charAt(i)==digit){\\n                if(number.charAt(i+1)>digit){\\n                     StringBuilder sb = new StringBuilder();\\n                     for(int j=0; j<number.length(); j++){\\n                        if(j!=i){\\n                            sb.append(number.charAt(j));\\n                        }\\n                    }\\n                    return sb.toString();\\n                }\\n            }\\n        }\\n\\t\\t//In case we are unable to find\\n        for(int i=number.length()-1; i>=0; i--){\\n            if(number.charAt(i)==digit){\\n                     StringBuilder sb = new StringBuilder();\\n                    for(int j=0; j<number.length(); j++){\\n                        if(j!=i){\\n                            sb.append(number.charAt(j));\\n                        }\\n                    }\\n                    return sb.toString();\\n            }\\n        }\\n        return \"\";\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nfor(int i=0; i<number.length()-1; i++){\\n            if(number.charAt(i)==digit){\\n                if(number.charAt(i+1)>digit){\\n                     StringBuilder sb = new StringBuilder();\\n                     for(int j=0; j<number.length(); j++){\\n                        if(j!=i){\\n                            sb.append(number.charAt(j));\\n                        }\\n                    }\\n                    return sb.toString();\\n                }\\n            }\\n        }\\n\\t\\t//In case we are unable to find\\n        for(int i=number.length()-1; i>=0; i--){\\n            if(number.charAt(i)==digit){\\n                     StringBuilder sb = new StringBuilder();\\n                    for(int j=0; j<number.length(); j++){\\n                        if(j!=i){\\n                            sb.append(number.charAt(j));\\n                        }\\n                    }\\n                    return sb.toString();\\n            }\\n        }\\n        return \"\";\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2678150,
                "title": "c-o-n-3-lines",
                "content": "```\\n    string removeDigit(string s, char digit) {\\n        for(int i=0;i<s.size()-1;i++)\\n            if(s[i]==digit && s[i] < s[i+1]) return s.erase(i, 1);\\n        return s.erase(s.find_last_of(digit), 1);\\n    }",
                "solutionTags": [],
                "code": "```\\n    string removeDigit(string s, char digit) {\\n        for(int i=0;i<s.size()-1;i++)\\n            if(s[i]==digit && s[i] < s[i+1]) return s.erase(i, 1);\\n        return s.erase(s.find_last_of(digit), 1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2462835,
                "title": "funny-go-solution",
                "content": "```\\nfunc removeDigit(number string, digit byte) string {\\n    var res string\\n    \\n    for i := 0; i < len(number); i++ {\\n        if number[i] == digit {\\n            if res == \"\" || number[:i] + number[i+1:] > res {\\n                res = number[:i] + number[i+1:]\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc removeDigit(number string, digit byte) string {\\n    var res string\\n    \\n    for i := 0; i < len(number); i++ {\\n        if number[i] == digit {\\n            if res == \"\" || number[:i] + number[i+1:] > res {\\n                res = number[:i] + number[i+1:]\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2450174,
                "title": "java-easy-o-n-with-detailed-explanation",
                "content": "Upvote please, if it helps or U like it. Feel free to leave questions or good ideas. \\nIt is all done by myself. \\nThank you! \\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\n// after one digit deleted, no matter which digit deleted, new number has the length of n - 1.\\n// we want the new number greater than the old.\\n\\n// if we delete the digit at index (i), compare with the (i + 1) , \\n\\n// if (i + 1) > (i), (i + 1) will subtitute the (i), and the new number is greater than the old.\\n//     EX -> 1114999, digit = 4, we got 111999, 1119 > 1114\\n//     For we search the digit starting from the most significant index, the first deletion is it.\\n\\n\\n// if (i + 1) < (i), the new one is less than the old, so don\\'t do anything to it for now. \\n// Just record the index, if it is the only targer digit, it is the only number to delete.\\n\\n// if (i + 1) == (i), (i + 1) means the consecutive number, the change depands on the next non-target digit. Just find the last one.\\npublic String removeDigit(String number, char digit) {\\n\\t// using StringBuffer, StringBuffer is more efficient to delete.\\n\\t// (String also works, needs more codes and overhead)\\n\\tStringBuffer sb = new StringBuffer(number);\\n\\n\\t// to record the last occured digit\\n\\tint last = 0;\\n\\n\\t// search the digit starting from most significant index\\n\\tfor (int i = 0; i < sb.length(); i++) {\\n\\n\\t\\t// if we find the digit, compare with the next digit(i, i + 1)\\n\\t\\t// A: i != sb.length() - 1 : compare with the next digit, so i can\\'t reach to i - 1\\n\\t\\t// B: sb.charAt(i) == digit && sb.charAt(i + 1) != digit, ignore the consecutive one, preocess the last.\\n\\t\\tif (i != sb.length() - 1 && sb.charAt(i) == digit && sb.charAt(i + 1) != digit) {\\n\\n\\t\\t\\t// find the next is greater\\n\\t\\t\\tif (sb.charAt(i + 1) >= sb.charAt(i)) {\\n\\t\\t\\t\\treturn sb.deleteCharAt(i).toString();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// record the last index, if it is only one digit.\\n\\t\\tif (sb.charAt(i) == digit)\\n\\t\\t\\tlast = i;\\n\\t}\\n\\n\\t// there is only one digit, delete it.\\n\\treturn sb.deleteCharAt(last).toString();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// after one digit deleted, no matter which digit deleted, new number has the length of n - 1.\\n// we want the new number greater than the old.\\n\\n// if we delete the digit at index (i), compare with the (i + 1) , \\n\\n// if (i + 1) > (i), (i + 1) will subtitute the (i), and the new number is greater than the old.\\n//     EX -> 1114999, digit = 4, we got 111999, 1119 > 1114\\n//     For we search the digit starting from the most significant index, the first deletion is it.\\n\\n\\n// if (i + 1) < (i), the new one is less than the old, so don\\'t do anything to it for now. \\n// Just record the index, if it is the only targer digit, it is the only number to delete.\\n\\n// if (i + 1) == (i), (i + 1) means the consecutive number, the change depands on the next non-target digit. Just find the last one.\\npublic String removeDigit(String number, char digit) {\\n\\t// using StringBuffer, StringBuffer is more efficient to delete.\\n\\t// (String also works, needs more codes and overhead)\\n\\tStringBuffer sb = new StringBuffer(number);\\n\\n\\t// to record the last occured digit\\n\\tint last = 0;\\n\\n\\t// search the digit starting from most significant index\\n\\tfor (int i = 0; i < sb.length(); i++) {\\n\\n\\t\\t// if we find the digit, compare with the next digit(i, i + 1)\\n\\t\\t// A: i != sb.length() - 1 : compare with the next digit, so i can\\'t reach to i - 1\\n\\t\\t// B: sb.charAt(i) == digit && sb.charAt(i + 1) != digit, ignore the consecutive one, preocess the last.\\n\\t\\tif (i != sb.length() - 1 && sb.charAt(i) == digit && sb.charAt(i + 1) != digit) {\\n\\n\\t\\t\\t// find the next is greater\\n\\t\\t\\tif (sb.charAt(i + 1) >= sb.charAt(i)) {\\n\\t\\t\\t\\treturn sb.deleteCharAt(i).toString();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// record the last index, if it is only one digit.\\n\\t\\tif (sb.charAt(i) == digit)\\n\\t\\t\\tlast = i;\\n\\t}\\n\\n\\t// there is only one digit, delete it.\\n\\treturn sb.deleteCharAt(last).toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2287461,
                "title": "java-solution-with-explanation-easy-logic",
                "content": "**Time Complexity**:   `O(N)`\\n\\n**Approach:**\\nTake the following examples:\\n* 9292929 with digit as 9 :\\n\\twe will try to delete 9 from the rightmost side\\n* 1212121 with digit as 1:\\n\\ttry to delete from leftmost side\\n* 8282898 with digit as 8\\n\\tfor this one, position is 4 (0-indexed) \\n\\t\\nFrom the above observations we can deduce that we will check if the current digit is greater than the digit to the immediate right then we will store the position as the last occurence for the position to be deleted. Else, the digit is removed and returned.\\n\\nAfter the loop is traversed and nothing is returned, then we shall delete the position in last occurence(`lastocc`) and returned.\\n\\n**Special Case:** we are not checking for the last character is equal to digit or not.... so there is a possibility of wrong answer. Hence, i\\'m checking the position and updating the value of last occurence (`lastocc`)\\n\\n**Code:**\\n\\n```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        int len=number.length(),lastocc=len-1;//lastocc can be initialized with any value\\n        for(int i=0;i<len-1;i++){\\n            char ch=number.charAt(i),chnext=number.charAt(i+1);\\n            if(ch==digit)\\n                if(ch>=chnext)\\n                    lastocc=i;\\n                else return number.substring(0,i)+number.substring(i+1);\\n        }\\n        lastocc=number.charAt(len-1)==digit? len-1 : lastocc;//updating lastocc for SPECIAL CASE\\n        return number.substring(0,lastocc)+number.substring(lastocc+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        int len=number.length(),lastocc=len-1;//lastocc can be initialized with any value\\n        for(int i=0;i<len-1;i++){\\n            char ch=number.charAt(i),chnext=number.charAt(i+1);\\n            if(ch==digit)\\n                if(ch>=chnext)\\n                    lastocc=i;\\n                else return number.substring(0,i)+number.substring(i+1);\\n        }\\n        lastocc=number.charAt(len-1)==digit? len-1 : lastocc;//updating lastocc for SPECIAL CASE\\n        return number.substring(0,lastocc)+number.substring(lastocc+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099004,
                "title": "python-easy-98",
                "content": "```\\nclass Solution:\\n    def removeDigit(self, s: str, d: str) -> str:\\n        a=0\\n        for i in range(len(s)):\\n            if s[i]==d:\\n                a=max(a,int(s[:i]+s[i+1:]))\\n        return str(a)\\n```\\n![image](https://assets.leetcode.com/users/images/751debc8-40a5-4a0f-aa68-5c2e213f58bb_1654100159.3457003.jpeg)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, s: str, d: str) -> str:\\n        a=0\\n        for i in range(len(s)):\\n            if s[i]==d:\\n                a=max(a,int(s[:i]+s[i+1:]))\\n        return str(a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063821,
                "title": "c-basic-string-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string ans = \"0\";\\n        \\n        //Iterate through the digits of number and every time we see digit, try removing it.\\n        //string that has been made after removing digit will be compared to get max string \\n        for(int i=0; i<number.size(); i++){\\n            if(number[i]==digit){\\n                string temp = number.substr(0,i) + number.substr(i+1, number.size());\\n                ans = max(ans, temp);\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string ans = \"0\";\\n        \\n        //Iterate through the digits of number and every time we see digit, try removing it.\\n        //string that has been made after removing digit will be compared to get max string \\n        for(int i=0; i<number.size(); i++){\\n            if(number[i]==digit){\\n                string temp = number.substr(0,i) + number.substr(i+1, number.size());\\n                ans = max(ans, temp);\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004676,
                "title": "easy-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        int N = number.length();\\n        for (int i = 0; i < N - 1; i++) {\\n            if (number[i] == digit and number[i] < number[i + 1]) {\\n                return (number.substr(0, i) + number.substr(i + 1));\\n            }\\n        }\\n        \\n        for (int i = N - 1; i >= 0; --i) {\\n            if (number[i] == digit)\\n                return number.erase(i, 1);\\n        }\\n        \\n        return number;\\n    }\\n};\\n```\\n/*\\n    BAD APPROACH -- WASTAGE OF SPACE\\n    ================================\\n        vector<string> db;\\n        int N = number.length();\\n        \\n        for (int i = 0; i < N; i++) {\\n            if (number[i] == digit) {\\n                string s = number.substr(0, i) + ((i == N - 1) ? \"\" : number.substr(i + 1));\\n                db.push_back(s);\\n            }\\n        }\\n        \\n        string ans = *max_element(db.begin(), db.end());\\n        return ans;\\n*/",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        int N = number.length();\\n        for (int i = 0; i < N - 1; i++) {\\n            if (number[i] == digit and number[i] < number[i + 1]) {\\n                return (number.substr(0, i) + number.substr(i + 1));\\n            }\\n        }\\n        \\n        for (int i = N - 1; i >= 0; --i) {\\n            if (number[i] == digit)\\n                return number.erase(i, 1);\\n        }\\n        \\n        return number;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999679,
                "title": "c-o-n-time-o-1-space",
                "content": "```\\n    public string RemoveDigit(string number, char digit)\\n    {\\n        for (int i = 0; i < number.Length - 1; i++)\\n        {\\n            if (number[i] == digit && number[i] < number[i + 1])\\n            {\\n                //Case 1. Remove the leftmost digit, which is smaller than its next number\\n                return number.Substring(0, i) + number.Substring(i + 1);\\n            }\\n        }\\n\\n        //Case 2. Remove the last digit\\n        int lastIndex = number.LastIndexOf(digit);\\n        return number.Substring(0, lastIndex) + number.Substring(lastIndex + 1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public string RemoveDigit(string number, char digit)\\n    {\\n        for (int i = 0; i < number.Length - 1; i++)\\n        {\\n            if (number[i] == digit && number[i] < number[i + 1])\\n            {\\n                //Case 1. Remove the leftmost digit, which is smaller than its next number\\n                return number.Substring(0, i) + number.Substring(i + 1);\\n            }\\n        }\\n\\n        //Case 2. Remove the last digit\\n        int lastIndex = number.LastIndexOf(digit);\\n        return number.Substring(0, lastIndex) + number.Substring(lastIndex + 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1997130,
                "title": "c-0ms-easy-clean-code-no-sorting-needed",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstring removeDigit(string number, char digit) {\\n\\t\\t\\tstring ans=\"\";\\n\\t\\t\\tint n=number.size();\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(number[i]==digit)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstring temp=number.substr(0,i)+number.substr(i+1);\\n\\t\\t\\t\\t\\tans=max(temp,ans);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstring removeDigit(string number, char digit) {\\n\\t\\t\\tstring ans=\"\";\\n\\t\\t\\tint n=number.size();\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(number[i]==digit)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstring temp=number.substr(0,i)+number.substr(i+1);\\n\\t\\t\\t\\t\\tans=max(temp,ans);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3274049,
                "title": "c-simple-solution",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public string RemoveDigit(string number, char digit) \\n    {\\n        List<string> numbers = new List<string>();\\n        for(int i = 0; i < number.Length; i++)\\n        {\\n            if(number[i] == digit)\\n            {\\n                numbers.Add(number.Remove(i, 1));\\n            }\\n        }\\n\\n        return numbers.Max();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string RemoveDigit(string number, char digit) \\n    {\\n        List<string> numbers = new List<string>();\\n        for(int i = 0; i < number.Length; i++)\\n        {\\n            if(number[i] == digit)\\n            {\\n                numbers.Add(number.Remove(i, 1));\\n            }\\n        }\\n\\n        return numbers.Max();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701388,
                "title": "c-easy-o-n",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    \\tstring removeDigit(string number, char digit) {\\n\\t\\tstring ans=\"\";\\n\\t\\tint n=number.size();\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tif(number[i]==digit)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring temp=number.substr(0,i)+number.substr(i+1,n-i-1);\\n\\t\\t\\t\\tans=max(temp,ans);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\tstring removeDigit(string number, char digit) {\\n\\t\\tstring ans=\"\";\\n\\t\\tint n=number.size();\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tif(number[i]==digit)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring temp=number.substr(0,i)+number.substr(i+1,n-i-1);\\n\\t\\t\\t\\tans=max(temp,ans);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671691,
                "title": "java-sorting-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        List<String> digits = new ArrayList<>();\\n        for(int i=0;i<number.length();i++){\\n            if(number.charAt(i)==digit){\\n                digits.add(number.substring(0,i)+number.substring(i+1,number.length())); \\n            }\\n        }\\n        Collections.sort(digits);\\n        return (String)digits.get(digits.size()-1);\\n    }\\n}\\n```\\n*Kindly upvote if you find it helpful*",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        List<String> digits = new ArrayList<>();\\n        for(int i=0;i<number.length();i++){\\n            if(number.charAt(i)==digit){\\n                digits.add(number.substring(0,i)+number.substring(i+1,number.length())); \\n            }\\n        }\\n        Collections.sort(digits);\\n        return (String)digits.get(digits.size()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637733,
                "title": "checking-every-possible-outcome",
                "content": "UPVOTE\\n```\\n        vector<string> ans;\\n        for(int i=0;i<number.size();i++){\\n            if(number[i]==digit){\\n                ans.push_back(number.substr(0,i)+number.substr(i+1,number.size()-i));\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans[ans.size()-1];\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n        vector<string> ans;\\n        for(int i=0;i<number.size();i++){\\n            if(number[i]==digit){\\n                ans.push_back(number.substr(0,i)+number.substr(i+1,number.size()-i));\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans[ans.size()-1];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2575576,
                "title": "python-o-n-easy-solution-and-o-1-space",
                "content": "\\tclass Solution:\\n\\t\\tdef removeDigit(self, number: str, digit: str) -> str:\\n\\t\\t\\tind = -1\\n\\t\\t\\tif len(number) == 1:\\n\\t\\t\\t\\treturn \\'\\'\\n        \\n\\t\\t\\tfor i, dig in enumerate(number):\\n\\t\\t\\t\\tif dig == digit:\\n\\t\\t\\t\\t\\tif i<len(number)-1 and int(number[i+1]) > int(number[i]):\\n\\t\\t\\t\\t\\t\\treturn number[:i] + number[i+1:]\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tind = i\\n\\t\\t\\treturn number[:ind] + number[ind+1:]\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef removeDigit(self, number: str, digit: str) -> str:\\n\\t\\t\\tind = -1\\n\\t\\t\\tif len(number) == 1:\\n\\t\\t\\t\\treturn \\'\\'\\n        \\n\\t\\t\\tfor i, dig in enumerate(number):\\n\\t\\t\\t\\tif dig == digit:\\n\\t\\t\\t\\t\\tif i<len(number)-1 and int(number[i+1]) > int(number[i]):\\n\\t\\t\\t\\t\\t\\treturn number[:i] + number[i+1:]\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tind = i\\n\\t\\t\\treturn number[:ind] + number[ind+1:]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2515744,
                "title": "easy-o-n-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        int n=number.length();\\n        int max=INT_MIN;\\n        int index;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(number[i]==digit)\\n            {\\n                if(int(number[i+1])>int(digit))\\n                {\\n                    index=i;\\n                    return number.substr(0,index)+number.substr(index+1);\\n                    max=int(number[i+1]);\\n                }\\n                else{\\n                    index=i;\\n                }\\n            }\\n        }\\n        if(int(number[n-1])==int(digit))\\n        {\\n            return number.substr(0,n-1);            \\n        }\\n        return number.substr(0,index)+number.substr(index+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        int n=number.length();\\n        int max=INT_MIN;\\n        int index;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(number[i]==digit)\\n            {\\n                if(int(number[i+1])>int(digit))\\n                {\\n                    index=i;\\n                    return number.substr(0,index)+number.substr(index+1);\\n                    max=int(number[i+1]);\\n                }\\n                else{\\n                    index=i;\\n                }\\n            }\\n        }\\n        if(int(number[n-1])==int(digit))\\n        {\\n            return number.substr(0,n-1);            \\n        }\\n        return number.substr(0,index)+number.substr(index+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385267,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        int n= number.size();\\n        string maxi = \"\";\\n        string s = number;\\n        for(int i=0; i<n; i++){\\n            if(digit==number[i]){\\n                number.erase(number.begin()+i);\\n                maxi= max(maxi,number);\\n            }\\n            number = s;\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n//Please upvote if you like it.\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        int n= number.size();\\n        string maxi = \"\";\\n        string s = number;\\n        for(int i=0; i<n; i++){\\n            if(digit==number[i]){\\n                number.erase(number.begin()+i);\\n                maxi= max(maxi,number);\\n            }\\n            number = s;\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n//Please upvote if you like it.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372644,
                "title": "easy-understandable-java-solution-beginner-friendly-with-explanation-o-n",
                "content": ">### Approach\\n\\n>**case 1:**\\n1.  We check the (i+1)th element for each ith element that matches the digit,  if the (i+1)th element is greater then we will delete the ith element (which is the given digit) then return.\\n \\n>**case 2:**\\n If (i+1)th element is smaller then we won\\'t delete the ith element instead we will continue checking for the occurance of  <u>case 1</u> if it is not met then we look \\n for the last occurance of the digit but as we were checking for the (i+1)th element\\n the loop would have not checked nth element/last element which is the last occurance\\n if the digit has occured at last so we check the last element if so, then we delete it and return, else we have stored the last digit occurance in the variable j then we delete it\\n and return the result\\n\\n**Example**\\nnumber = 123453 digit = 3\\nAns = 12453\\nAs the first \\'3\\' is smaller than the next element \\'4\\' removing it will make the number greater \\n\\nnumber = 125325 digit = 5\\nAns = 12532\\nAs the first \\'5\\' is greater than the next element removing it will make the number smaller\\nso we remove the last occurance\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        StringBuilder sb = new StringBuilder(number);\\n        String maxRes=\"\"; //Result string\\n        int i; int j=0;\\n        for(i=0; i<sb.length()-1; i++){\\n            if(sb.charAt(i)==digit){\\n                j=i;\\n                if((int)(sb.charAt(i)-\\'0\\')<\\n                      (int)(sb.charAt(i+1)-\\'0\\')){\\n                    return String.valueOf(sb.deleteCharAt(i));\\n                }\\n            }\\n        }\\n        if(sb.charAt(sb.length()-1)==digit)  //As we have not checked the last element above\\n        return String.valueOf(sb.deleteCharAt(sb.length()-1));  /*If the last element equals digit then we delete it and return;*/\\n        return String.valueOf(sb.deleteCharAt(j)); /*Else we delete the last occurance of the\\n\\t\\tdigit and return the maxRes*/\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String removeDigit(String number, char digit) {\\n        StringBuilder sb = new StringBuilder(number);\\n        String maxRes=\"\"; //Result string\\n        int i; int j=0;\\n        for(i=0; i<sb.length()-1; i++){\\n            if(sb.charAt(i)==digit){\\n                j=i;\\n                if((int)(sb.charAt(i)-\\'0\\')<\\n                      (int)(sb.charAt(i+1)-\\'0\\')){\\n                    return String.valueOf(sb.deleteCharAt(i));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2252259,
                "title": "java-1ms-99-intuition-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm/Theory\\n        Theory: \\n        - Right from beginning, traverse the string and inspect each digit. If it matches the given digit, check its immediate neighbour.\\n        - Ignore the next neighbour if it\\'s the same given digit. 552 5 : removing first 5 will give 52, same as removing 2nd 5.\\n          Thus, the revevant digit is the next different neighbour digit.\\n        1. The best outcome is when you find the first an immediate digit higher than the given one.\\n           EG: \"7462782791\" \"7\". \\n           In this case, we can see that if we remove 2nd 7, the next digit 8 is greater and this will give the max possible number.\\n           If such situation is encountered, substring it and return it immediately\\n        2. However, there might be cases when no such higher digit is found, and all the remaing immediate digits are lesser or equal. \\n           In this case, removing any digit will cause a smaller number, as the digit will be replaced by a smaller one\\n           EG: \"7462752761\", \"7\"\\n           As we can see, all immediate digits of 7 are 4,5,6. All of them are smaller and will cause a decrease of number.\\n           Mathematically, we can to remove the last encountered 1,\\n        Algorithm:\\n        1. Traverse the string and keep an index of last position where given digit is encountered.\\n        2. If current digit == givenDigit and next one is greater than diven digit, you found the answer. Substring it.\\n        3. If not returned from #1 & #2, check if lastIndex has been set. If not, it means only the last char is the digit, so substring\\n           from 0 to n-1.\\n        4. If not returned from #3, it means we need to substring from 0 to lastPoistion + lastPosition +1, \\n        so bascially substringing the last position of the digit.\\n    */\\n    public String removeDigit(String number, char digit) {\\n        int last = -1;\\n        char[] chrs = number.toCharArray();\\n        for (int i = 0; i < chrs.length - 1; i++) {\\n            if (chrs[i] == digit) {\\n                last = i;\\n                if (chrs[i + 1] > digit) {\\n                    return number.substring(0, i) + number.substring(i + 1);\\n                }\\n            }\\n        }\\n        // if nothing found, the last one is to be removed\\n        if (last == -1) {\\n            return number.substring(0, chrs.length -1);\\n        }\\n        if (chrs[chrs.length -1] == digit) {\\n            last = chrs.length - 1;\\n        }\\n        return number.substring(0, last) + number.substring(last + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm/Theory\\n        Theory: \\n        - Right from beginning, traverse the string and inspect each digit. If it matches the given digit, check its immediate neighbour.\\n        - Ignore the next neighbour if it\\'s the same given digit. 552 5 : removing first 5 will give 52, same as removing 2nd 5.\\n          Thus, the revevant digit is the next different neighbour digit.\\n        1. The best outcome is when you find the first an immediate digit higher than the given one.\\n           EG: \"7462782791\" \"7\". \\n           In this case, we can see that if we remove 2nd 7, the next digit 8 is greater and this will give the max possible number.\\n           If such situation is encountered, substring it and return it immediately\\n        2. However, there might be cases when no such higher digit is found, and all the remaing immediate digits are lesser or equal. \\n           In this case, removing any digit will cause a smaller number, as the digit will be replaced by a smaller one\\n           EG: \"7462752761\", \"7\"\\n           As we can see, all immediate digits of 7 are 4,5,6. All of them are smaller and will cause a decrease of number.\\n           Mathematically, we can to remove the last encountered 1,\\n        Algorithm:\\n        1. Traverse the string and keep an index of last position where given digit is encountered.\\n        2. If current digit == givenDigit and next one is greater than diven digit, you found the answer. Substring it.\\n        3. If not returned from #1 & #2, check if lastIndex has been set. If not, it means only the last char is the digit, so substring\\n           from 0 to n-1.\\n        4. If not returned from #3, it means we need to substring from 0 to lastPoistion + lastPosition +1, \\n        so bascially substringing the last position of the digit.\\n    */\\n    public String removeDigit(String number, char digit) {\\n        int last = -1;\\n        char[] chrs = number.toCharArray();\\n        for (int i = 0; i < chrs.length - 1; i++) {\\n            if (chrs[i] == digit) {\\n                last = i;\\n                if (chrs[i + 1] > digit) {\\n                    return number.substring(0, i) + number.substring(i + 1);\\n                }\\n            }\\n        }\\n        // if nothing found, the last one is to be removed\\n        if (last == -1) {\\n            return number.substring(0, chrs.length -1);\\n        }\\n        if (chrs[chrs.length -1] == digit) {\\n            last = chrs.length - 1;\\n        }\\n        return number.substring(0, last) + number.substring(last + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096176,
                "title": "python-o-n-solution-keep-max-result",
                "content": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        res = 0\\n        \\n        for i in range(len(number)):\\n            if number[i] == digit:\\n                res = max(res, int(number[:i] + number[i+1:]))\\n                \\n        return str(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        res = 0\\n        \\n        for i in range(len(number)):\\n            if number[i] == digit:\\n                res = max(res, int(number[:i] + number[i+1:]))\\n                \\n        return str(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076383,
                "title": "java-biginteger",
                "content": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        StringBuffer b = new StringBuffer(number);\\n        BigInteger ans = BigInteger.ZERO;\\n        for(int i =0;i<b.length();i++){\\n            if(b.charAt(i)==digit){\\n                b.deleteCharAt(i);\\n                if(ans.compareTo(new BigInteger(b.toString()))<0){\\n                    ans = new BigInteger(b.toString());\\n                }\\n                b.insert(i,number.charAt(i));    \\n            }\\n            \\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        StringBuffer b = new StringBuffer(number);\\n        BigInteger ans = BigInteger.ZERO;\\n        for(int i =0;i<b.length();i++){\\n            if(b.charAt(i)==digit){\\n                b.deleteCharAt(i);\\n                if(ans.compareTo(new BigInteger(b.toString()))<0){\\n                    ans = new BigInteger(b.toString());\\n                }\\n                b.insert(i,number.charAt(i));    \\n            }\\n            \\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066029,
                "title": "c-basic-sub-string-concept-o-n-solution",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) \\n    {\\n        string res = \"\";\\n        \\n        // iterate over the number string\\n        for(int i=0;i<number.length();i++)\\n        {\\n            // if current value is equal to the given digit\\n            if(number[i] == digit)\\n            {\\n                // try to construct new string without current char that will (0->i and i+1->n)\\n                string tmp = number.substr(0,i) + number.substr(i+1, number.size());\\n                \\n                // storing max value in decimal\\n                res = max(res,tmp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) \\n    {\\n        string res = \"\";\\n        \\n        // iterate over the number string\\n        for(int i=0;i<number.length();i++)\\n        {\\n            // if current value is equal to the given digit\\n            if(number[i] == digit)\\n            {\\n                // try to construct new string without current char that will (0->i and i+1->n)\\n                string tmp = number.substr(0,i) + number.substr(i+1, number.size());\\n                \\n                // storing max value in decimal\\n                res = max(res,tmp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2035359,
                "title": "javascript-time-o-n-space-o-1",
                "content": "```\\nconst removeDigit = function(number, digit) {\\n    let max = \\'\\'\\n    for (let i = 0; i < number.length; i++) {\\n        if (number[i] === digit) {\\n            let temp = number.slice(0, i) + number.slice(i + 1)\\n            if (temp > max) max = temp\\n        }\\n    }\\n    return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst removeDigit = function(number, digit) {\\n    let max = \\'\\'\\n    for (let i = 0; i < number.length; i++) {\\n        if (number[i] === digit) {\\n            let temp = number.slice(0, i) + number.slice(i + 1)\\n            if (temp > max) max = temp\\n        }\\n    }\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2019117,
                "title": "c-easy-select-max-easy-short",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        \\n        string tmp=\"\";\\n        string ans=\"\";\\n        \\n        for(int i=0;i<number.size();i++) {\\n            \\n            tmp=number;\\n            if(tmp[i]==digit) {\\n                if(i==number.size()-1)\\n                    tmp.pop_back();\\n                else\\n                    tmp.erase(tmp.begin()+i,tmp.begin()+i+1);\\n                ans=max(ans,tmp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nif(helpful)\\n\\tupVote();",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        \\n        string tmp=\"\";\\n        string ans=\"\";\\n        \\n        for(int i=0;i<number.size();i++) {\\n            \\n            tmp=number;\\n            if(tmp[i]==digit) {\\n                if(i==number.size()-1)\\n                    tmp.pop_back();\\n                else\\n                    tmp.erase(tmp.begin()+i,tmp.begin()+i+1);\\n                ans=max(ans,tmp);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1996949,
                "title": "easy-solution-o-n",
                "content": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        l=[]\\n        for i in range(len(number)):\\n            if number[i]==digit:\\n                l.append(int(number[:i]+number[i+1:]))\\n        return str(max(l))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        l=[]\\n        for i in range(len(number)):\\n            if number[i]==digit:\\n                l.append(int(number[:i]+number[i+1:]))\\n        return str(max(l))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996793,
                "title": "2-different-approaches",
                "content": "```\\nstring removeDigit(string number, char digit) {\\n        // Brute-Force Approach\\n        int n = number.size();\\n        string res = \"\";\\n        for(int i=0;i<n;i++){\\n            string s = \"\";\\n            \\n            if(number[i] == digit){\\n                for(int j=0;j<n;j++){\\n                    if(i == j)\\n                        continue;\\n                    else\\n                        s += number[j];\\n                }\\n            }\\n            res = max(res,s);\\n        }   \\n        return res;\\n    }\\n\\t\\n   \\n // Using substr. Solution\\n        string res = \"\";\\n        for(int i=0;i<n;i++){\\n            if(number[i] == digit)\\n                res = max(res,number.substr(0,i) + number.substr(i+1,n-i-1));\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring removeDigit(string number, char digit) {\\n        // Brute-Force Approach\\n        int n = number.size();\\n        string res = \"\";\\n        for(int i=0;i<n;i++){\\n            string s = \"\";\\n            \\n            if(number[i] == digit){\\n                for(int j=0;j<n;j++){\\n                    if(i == j)\\n                        continue;\\n                    else\\n                        s += number[j];\\n                }\\n            }\\n            res = max(res,s);\\n        }   \\n        return res;\\n    }\\n\\t\\n   \\n // Using substr. Solution\\n        string res = \"\";\\n        for(int i=0;i<n;i++){\\n            if(number[i] == digit)\\n                res = max(res,number.substr(0,i) + number.substr(i+1,n-i-1));\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1996785,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public String removeDigit(String s, char d) {\\n        int p=0;\\n        for(char c:s.toCharArray())\\n        {\\n            if(c==d)\\n                p++;\\n        }\\n        int k=s.length();\\n        for(int i=0;i<k-1;i++)\\n        {\\n            if(s.charAt(i)==d&&s.charAt(i)>=s.charAt(i+1))\\n                continue;\\n            else if(s.charAt(i)==d)\\n            {\\n                s=s.substring(0,i)+s.substring(i+1);\\n                break;\\n            }\\n        }\\n        if(k==s.length())\\n        {\\n            k=s.lastIndexOf(d);\\n            s=s.substring(0,k)+s.substring(k+1);\\n        }\\n        return s;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public String removeDigit(String s, char d) {\\n        int p=0;\\n        for(char c:s.toCharArray())\\n        {\\n            if(c==d)\\n                p++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1996451,
                "title": "check-greater-java-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        String ans = \"\";\\n        for(int i = 0; i < number.length(); ++i){\\n            if(number.charAt(i) == digit){\\n                String actual = number.substring(0, i) + number.substring(i+1);\\n                if(checkGreater(ans, actual))\\n                    ans = actual;\\n            }\\n        }\\n        return ans;\\n    }\\n    private boolean checkGreater(String ans, String actual){\\n        for(int i = 0;; i < Math.min(ans.length(), actual.length()); i++){\\n            if(actual.charAt(i) > ans.charAt(i)) return true;\\n            else if(actual.charAt(i) < ans.charAt(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        String ans = \"\";\\n        for(int i = 0; i < number.length(); ++i){\\n            if(number.charAt(i) == digit){\\n                String actual = number.substring(0, i) + number.substring(i+1);\\n                if(checkGreater(ans, actual))\\n                    ans = actual;\\n            }\\n        }\\n        return ans;\\n    }\\n    private boolean checkGreater(String ans, String actual){\\n        for(int i = 0;; i < Math.min(ans.length(), actual.length()); i++){\\n            if(actual.charAt(i) > ans.charAt(i)) return true;\\n            else if(actual.charAt(i) < ans.charAt(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996362,
                "title": "funny-simple-hack-to-the-problem-by-codeforces-expert-python-o-n-solution",
                "content": "```\\n# LC - A\\nclass Solution:\\n    def removeDigit(self, num: str, dig: str, ind = 0) -> str:\\n        for pos in range(len(num) - 1):\\n            if num[pos] == dig:\\n                ind = pos\\n                if num[pos + 1] > dig:\\n                    return num[:pos] + num[pos + 1:]\\n        if num[-1] == dig:\\n            return num[:len(num) - 1]\\n        return num[:ind] + num[ind + 1:]\\n```",
                "solutionTags": [],
                "code": "```\\n# LC - A\\nclass Solution:\\n    def removeDigit(self, num: str, dig: str, ind = 0) -> str:\\n        for pos in range(len(num) - 1):\\n            if num[pos] == dig:\\n                ind = pos\\n                if num[pos + 1] > dig:\\n                    return num[:pos] + num[pos + 1:]\\n        if num[-1] == dig:\\n            return num[:len(num) - 1]\\n        return num[:ind] + num[ind + 1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996296,
                "title": "java-big-decimal-solution",
                "content": "```\\nimport java.math.BigDecimal;\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        BigDecimal max = new BigDecimal(0);\\n        for(int i=0;i<number.length();i++){\\n            if(number.charAt(i)==digit){\\n                String left = number.substring(0,i);\\n                String right = number.substring(i+1);\\n                String num = left + right;\\n                BigDecimal numberBD = new BigDecimal(num);\\n                if(numberBD.compareTo(max)==1)\\n                    max = numberBD;\\n            }\\n\\n        }\\n        return max.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.math.BigDecimal;\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        BigDecimal max = new BigDecimal(0);\\n        for(int i=0;i<number.length();i++){\\n            if(number.charAt(i)==digit){\\n                String left = number.substring(0,i);\\n                String right = number.substring(i+1);\\n                String num = left + right;\\n                BigDecimal numberBD = new BigDecimal(num);\\n                if(numberBD.compareTo(max)==1)\\n                    max = numberBD;\\n            }\\n\\n        }\\n        return max.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698781,
                "title": "beat-100-no-brute-froce-no-substr",
                "content": "# Approach\\nScan from left to right. If the next digit is bigger than the target (aka `digit` described in problem) one,  it will be the optimal solution.\\nIf every next digits always as same as, or less than the target, then delete the rightmost target. Because you always need to maximize the result, so if you fall into this case, delete the rightmost one is the prefered solution.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        int n=0;\\n\\n        while((n=number.find(digit, n)) != string::npos){\\n            if(n!=number.length()-1 && number[n+1]>number[n]){\\n                number.erase(n,1);\\n                return number;\\n            }\\n            n++;\\n        }\\n\\n        number.erase(number.rfind(digit), 1);\\n        return number;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        int n=0;\\n\\n        while((n=number.find(digit, n)) != string::npos){\\n            if(n!=number.length()-1 && number[n+1]>number[n]){\\n                number.erase(n,1);\\n                return number;\\n            }\\n            n++;\\n        }\\n\\n        number.erase(number.rfind(digit), 1);\\n        return number;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593996,
                "title": "efficient-solution-with-bigint-javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} number\\n * @param {character} digit\\n * @return {string}\\n */\\nvar removeDigit = function(number, digit) {\\n  let largestNum = 0n; \\n\\n  for (let ind = 0; ind < number.length; ind++) {\\n    if (number[ind] === digit) {\\n      const numString = number.substring(0, ind) + number.substring(ind + 1); \\n      const num = BigInt(numString); \\n      if (num > largestNum) largestNum = num; \\n    }\\n  }\\n\\n  return largestNum.toString();\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {string} number\\n * @param {character} digit\\n * @return {string}\\n */\\nvar removeDigit = function(number, digit) {\\n  let largestNum = 0n; \\n\\n  for (let ind = 0; ind < number.length; ind++) {\\n    if (number[ind] === digit) {\\n      const numString = number.substring(0, ind) + number.substring(ind + 1); \\n      const num = BigInt(numString); \\n      if (num > largestNum) largestNum = num; \\n    }\\n  }\\n\\n  return largestNum.toString();\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3315928,
                "title": "2259-checking-the-next-digit-beats-96-72",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        n = len(number)\\n        for x in range(1, n):\\n            prev, cur = number[x-1], number[x]\\n            if prev == digit:\\n                last_ind = x-1\\n                if cur > prev:\\n                    ind = x - 1\\n                    return number[:ind] + number[ind+1:]\\n        else:\\n            if number[-1] == digit:\\n                last_ind = n-1\\n            if last_ind < n-1:\\n                return number[:last_ind] + number[last_ind+1:]\\n            return number[:last_ind]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Greedy",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        n = len(number)\\n        for x in range(1, n):\\n            prev, cur = number[x-1], number[x]\\n            if prev == digit:\\n                last_ind = x-1\\n                if cur > prev:\\n                    ind = x - 1\\n                    return number[:ind] + number[ind+1:]\\n        else:\\n            if number[-1] == digit:\\n                last_ind = n-1\\n            if last_ind < n-1:\\n                return number[:last_ind] + number[last_ind+1:]\\n            return number[:last_ind]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060325,
                "title": "this-is-not-effective-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        vector<string> vec;\\n        int len = number.length();\\n        for(int i = 0; i < len; i++){\\n            if(number[i] == digit){\\n                vec.push_back(number.substr(0, i) + number.substr(i+1));\\n            }\\n        }\\n        sort(vec.begin(), vec.end());\\n\\n        return vec[vec.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        vector<string> vec;\\n        int len = number.length();\\n        for(int i = 0; i < len; i++){\\n            if(number[i] == digit){\\n                vec.push_back(number.substr(0, i) + number.substr(i+1));\\n            }\\n        }\\n        sort(vec.begin(), vec.end());\\n\\n        return vec[vec.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916283,
                "title": "python3-2-line-faster-than-99-25",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        nums = [ int(number[:n] + number[n+1:]) for n in range(len(number)) if number[n] == digit]\\n        return str(max(nums))\\n```\\n![image.png](https://assets.leetcode.com/users/images/b49f5fb6-b9e9-4495-9a15-d67ec2f8b76f_1671159365.356508.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        nums = [ int(number[:n] + number[n+1:]) for n in range(len(number)) if number[n] == digit]\\n        return str(max(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804312,
                "title": "remove-digit-from-number-to-maximize-result-solution-java",
                "content": "class Solution {\\n  public String removeDigit(String number, char digit) {\\n    for (int i = 0; i + 1 < number.length(); ++i)\\n      if (number.charAt(i) == digit && digit < number.charAt(i + 1))\\n        return new StringBuilder(number).deleteCharAt(i).toString();\\n    return new StringBuilder(number).deleteCharAt(number.lastIndexOf(digit)).toString();\\n  }\\n}\\n",
                "solutionTags": [
                    "String",
                    "Greedy",
                    "Enumeration"
                ],
                "code": "class Solution {\\n  public String removeDigit(String number, char digit) {\\n    for (int i = 0; i + 1 < number.length(); ++i)\\n      if (number.charAt(i) == digit && digit < number.charAt(i + 1))\\n        return new StringBuilder(number).deleteCharAt(i).toString();\\n    return new StringBuilder(number).deleteCharAt(number.lastIndexOf(digit)).toString();\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 2670972,
                "title": "simple-loop-beats-100",
                "content": "# Intuition\\nThe problem could be solved without creating extra strings, but this way is simple and easy to test.\\n\\n# Approach\\n1- Loop over the string\\n2- Erase/remove the target digit once\\n3- Keep track of the largest string. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string mx = \"\";        \\n        for (int i = 0; i < number.size(); ++i) {\\n            if (number[i] == digit) {\\n                mx = max(mx, string(number).erase(i, 1));\\n            }\\n        }\\n\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string mx = \"\";        \\n        for (int i = 0; i < number.size(); ++i) {\\n            if (number[i] == digit) {\\n                mx = max(mx, string(number).erase(i, 1));\\n            }\\n        }\\n\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649534,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef removeDigit(self, number: str, digit: str) -> str:\\n\\t\\t\\toutput = []\\n\\t\\t\\tfor i in range(len(number)):\\n\\t\\t\\t\\tif number[i] == digit:\\n\\t\\t\\t\\t\\toutput.append(\"\".join(number[:i]+number[i+1:]))\\n\\t\\t\\treturn max(output)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef removeDigit(self, number: str, digit: str) -> str:\\n\\t\\t\\toutput = []\\n\\t\\t\\tfor i in range(len(number)):\\n\\t\\t\\t\\tif number[i] == digit:\\n\\t\\t\\t\\t\\toutput.append(\"\".join(number[:i]+number[i+1:]))\\n\\t\\t\\treturn max(output)",
                "codeTag": "Java"
            },
            {
                "id": 2585517,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        maxRes= 0\\n        for i in range(len(number)):\\n            if number[i]==digit:\\n                maxRes= max(maxRes, int(number[:i]+ number[i+1:]))\\n        return str(maxRes)\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        maxRes= 0\\n        for i in range(len(number)):\\n            if number[i]==digit:\\n                maxRes= max(maxRes, int(number[:i]+ number[i+1:]))\\n        return str(maxRes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528711,
                "title": "c-string-comparison-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string temp;\\n        for (int i = 0 ;i<number.size()-1;i++){\\n           temp.push_back(\\'0\\');\\n        }\\n\\n           for(int i = 0; i<number.size(); i++){\\n               if (number[i] == digit){\\n                   string str = number.substr(0,i) + number.substr(i+1,number.size()-1);\\n                   for (int j =0;j<str.size();j++){\\n                        if(str[j]-\\'0\\'>temp[j]-\\'0\\')\\n                        {\\n                            temp = str;\\n                            break;\\n                        }\\n                      else if(temp[j]-\\'0\\'>str[j]-\\'0\\')\\n                          break;\\n                   }\\n               }\\n           }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string temp;\\n        for (int i = 0 ;i<number.size()-1;i++){\\n           temp.push_back(\\'0\\');\\n        }\\n\\n           for(int i = 0; i<number.size(); i++){\\n               if (number[i] == digit){\\n                   string str = number.substr(0,i) + number.substr(i+1,number.size()-1);\\n                   for (int j =0;j<str.size();j++){\\n                        if(str[j]-\\'0\\'>temp[j]-\\'0\\')\\n                        {\\n                            temp = str;\\n                            break;\\n                        }\\n                      else if(temp[j]-\\'0\\'>str[j]-\\'0\\')\\n                          break;\\n                   }\\n               }\\n           }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2471157,
                "title": "store-in-a-list-then-sort-them",
                "content": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        List<String> list = new ArrayList<>();\\n        for(int i=0;i<number.length();i++)\\n        {\\n            \\n            if(number.charAt(i)==digit)\\n            {\\n                String str = number.substring(0,i) + number.substring(i+1, number.length());\\n                list.add(str);\\n            }\\n            \\n        }\\n        Collections.sort(list);\\n        return list.get(list.size()-1);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String removeDigit(String number, char digit) {\\n        List<String> list = new ArrayList<>();\\n        for(int i=0;i<number.length();i++)\\n        {\\n            \\n            if(number.charAt(i)==digit)\\n            {\\n                String str = number.substring(0,i) + number.substring(i+1, number.length());\\n                list.add(str);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2454031,
                "title": "java-solution-using-compareto",
                "content": "```\\n    public String removeDigit(String number, char digit) {\\n        \\n        String ans = \"0\";\\n        \\n        for(int i=0; i<number.length(); i++){\\n            if(number.charAt(i) == digit){\\n                String newNumber = number.substring(0, i) + number.substring(i+1);\\n                if (newNumber.compareTo(ans) >= 1){\\n                    ans = newNumber;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String removeDigit(String number, char digit) {\\n        \\n        String ans = \"0\";\\n        \\n        for(int i=0; i<number.length(); i++){\\n            if(number.charAt(i) == digit){\\n                String newNumber = number.substring(0, i) + number.substring(i+1);\\n                if (newNumber.compareTo(ans) >= 1){\\n                    ans = newNumber;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2451322,
                "title": "java-sol-o-n-with-explanation",
                "content": "\\tclass Solution {\\n\\t\\tpublic String removeDigit(String number, char digit) {\\n\\t\\t\\tint lastTargetDigit = 0; \\n\\t\\t\\tfor(int i=0; i<number.length(); ++i){\\n\\t\\t\\t\\tif(i+1 < number.length() && number.charAt(i) < number.charAt(i+1) && number.charAt(i) == digit)\\n\\t\\t\\t\\t   return number.substring(0, i) + number.substring(i+1, number.length()); \\n\\t\\t\\t\\tif(number.charAt(i) == digit)\\n\\t\\t\\t\\t\\tlastTargetDigit = i;\\n\\t\\t\\t} \\n\\t\\t\\treturn  number.substring(0, lastTargetDigit) + number.substring(lastTargetDigit+1, number.length()); \\n\\t\\t}\\n\\t}\\n\\n\\t// time O(n), n is the length of number \\n\\t// space O(1)\\n\\t// idea: if we want to maximize the number after remove the target digit\\n\\t// from left to right, we find the first target digit such that char(i) == digit && char(i+1) > char(i) \\n\\t// otherwise we remove the first occurance of digit from right to left. \\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic String removeDigit(String number, char digit) {\\n\\t\\t\\tint lastTargetDigit = 0; \\n\\t\\t\\tfor(int i=0; i<number.length(); ++i){\\n\\t\\t\\t\\tif(i+1 < number.length() && number.charAt(i) < number.charAt(i+1) && number.charAt(i) == digit)\\n\\t\\t\\t\\t   return number.substring(0, i) + number.substring(i+1, number.length()); \\n\\t\\t\\t\\tif(number.charAt(i) == digit)\\n\\t\\t\\t\\t\\tlastTargetDigit = i;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2427700,
                "title": "python-7-line-clean-and-simple-o-n-solution",
                "content": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        last_seen = None\\n\\t\\t\\n        for i in range(len(number)):\\n            if number[i] == digit:\\n                if i < len(number) - 1 and int(number[i + 1]) > int(number[i]):\\n                    return number[:i] + number[i + 1:]\\n                last_seen = i\\n\\n        return number[:last_seen] + number[last_seen + 1:]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        last_seen = None\\n\\t\\t\\n        for i in range(len(number)):\\n            if number[i] == digit:\\n                if i < len(number) - 1 and int(number[i + 1]) > int(number[i]):\\n                    return number[:i] + number[i + 1:]\\n                last_seen = i\\n\\n        return number[:last_seen] + number[last_seen + 1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418265,
                "title": "easy-python-solution-94-39-faster",
                "content": "Very easy solution, where you will first make str to list to modify it, then itterate through the list of number and whenever it will find the digit you will remove it and check if the number will be higher than the current max then we would just do it for every occurance of digit.\\n```\\ndef removeDigit(self, number: str, digit: str) -> str:\\n        \\n        lst = list(number)\\n        m = float(-inf)\\n        \\n        for i, v in enumerate(lst):\\n            if v == digit:\\n                temp = list(lst)\\n                temp.pop(i)\\n                tempNum = int(\"\".join(temp))\\n                m = max(tempNum, m)\\n        \\n        return str(m)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef removeDigit(self, number: str, digit: str) -> str:\\n        \\n        lst = list(number)\\n        m = float(-inf)\\n        \\n        for i, v in enumerate(lst):\\n            if v == digit:\\n                temp = list(lst)\\n                temp.pop(i)\\n                tempNum = int(\"\".join(temp))\\n                m = max(tempNum, m)\\n        \\n        return str(m)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2403088,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n     \\n        string ans=\"\";\\n        string str=number;\\n        for(int i=0;i<number.size();i++)\\n        {\\n            if(number[i]==digit)\\n            {\\n                number.erase(number.begin()+i);\\n                ans=max(ans,number);\\n            }\\n            number=str;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n     \\n        string ans=\"\";\\n        string str=number;\\n        for(int i=0;i<number.size();i++)\\n        {\\n            if(number[i]==digit)\\n            {\\n                number.erase(number.begin()+i);\\n                ans=max(ans,number);\\n            }\\n            number=str;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2350286,
                "title": "python-very-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def removeDigit(self, n: str, d: str) -> str:\\n        maxi=-10000\\n        for i in range(len(n)):\\n            if n[i]==d:\\n                maxi=max(maxi,int(n[:i]+n[i+1:])) #finding the maximum value among the remaining values\\n            \\n        return str(maxi)\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, n: str, d: str) -> str:\\n        maxi=-10000\\n        for i in range(len(n)):\\n            if n[i]==d:\\n                maxi=max(maxi,int(n[:i]+n[i+1:])) #finding the maximum value among the remaining values\\n            \\n        return str(maxi)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314805,
                "title": "python-easy-to-understand",
                "content": "Just iterate over each digit and exculed that digit and see if it is a maximum number\\n```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        \\n        max_num = 0\\n        \\n        for i in range(len(number)):\\n            if number[i] == digit:\\n                max_num = max(max_num, int(\"\".join(number[:i])+\"\".join(number[i+1:])))\\n        \\n        return str(max_num)\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        \\n        max_num = 0\\n        \\n        for i in range(len(number)):\\n            if number[i] == digit:\\n                max_num = max(max_num, int(\"\".join(number[:i])+\"\".join(number[i+1:])))\\n        \\n        return str(max_num)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308773,
                "title": "easy-string-solution",
                "content": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n    \\n      \\n      for(int i= 1; i< number.length() ; i++){\\n        if(number.charAt(i-1) == digit){\\n          if(number.charAt(i-1)  < number.charAt(i)){\\n            return (number.substring(0,i-1) + number.substring(i));\\n          }\\n        }\\n      }\\n      \\n      int lastindex=number.lastIndexOf(digit);\\n      return (number.substring(0,lastindex)+number.substring(lastindex+1));\\n      \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n    \\n      \\n      for(int i= 1; i< number.length() ; i++){\\n        if(number.charAt(i-1) == digit){\\n          if(number.charAt(i-1)  < number.charAt(i)){\\n            return (number.substring(0,i-1) + number.substring(i));\\n          }\\n        }\\n      }\\n      \\n      int lastindex=number.lastIndexOf(digit);\\n      return (number.substring(0,lastindex)+number.substring(lastindex+1));\\n      \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292002,
                "title": "beats-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string str=\"\";\\n        for(int i=0; i<number.length(); i++)\\n        {\\n            if(number[i]==digit)\\n            {\\n                if(i!=number.length()-1)\\n                {\\n                    str=number.substr(0,i) + number.substr(i+1,number.length());\\n                    if(number[i+1]>number[i])\\n                    return str;\\n                }\\n                else\\n                {\\n                     str=number.substr(0,i) + number.substr(i+1,number.length());\\n                    return str;\\n                }\\n                \\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string str=\"\";\\n        for(int i=0; i<number.length(); i++)\\n        {\\n            if(number[i]==digit)\\n            {\\n                if(i!=number.length()-1)\\n                {\\n                    str=number.substr(0,i) + number.substr(i+1,number.length());\\n                    if(number[i+1]>number[i])\\n                    return str;\\n                }\\n                else\\n                {\\n                     str=number.substr(0,i) + number.substr(i+1,number.length());\\n                    return str;\\n                }\\n                \\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287310,
                "title": "simple-and-easy-to-understand-java-solution",
                "content": "```\\nclass Solution {\\n    public String removeDigit(String num, char digit) {\\n        int i,j;\\n        String s3=\"\",s4=\"\";\\n        for(i=0;i<num.length();i++){\\n            if((int)num.charAt(i)==(int)digit){  \\n                s3=(num.substring(0,i)).concat(num.substring(i+1,num.length()));\\n                if(s4==\"\" || s3.length()>s4.length()){\\n                    s4=s3;\\n                }\\n                else{\\n\\n                    if(s3.length()==s4.length()){\\n                        for(j=0;j<s3.length();j++){\\n                            if(s4.charAt(j)>s3.charAt(j))\\n                                break;\\n                            if(s3.charAt(j)>s4.charAt(j))\\n                            {\\n                                s4=s3;\\n                                break;\\n                            }\\n                        }\\n\\n                    }\\n                }\\n            }\\n        }\\n        return s4;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String num, char digit) {\\n        int i,j;\\n        String s3=\"\",s4=\"\";\\n        for(i=0;i<num.length();i++){\\n            if((int)num.charAt(i)==(int)digit){  \\n                s3=(num.substring(0,i)).concat(num.substring(i+1,num.length()));\\n                if(s4==\"\" || s3.length()>s4.length()){\\n                    s4=s3;\\n                }\\n                else{\\n\\n                    if(s3.length()==s4.length()){\\n                        for(j=0;j<s3.length();j++){\\n                            if(s4.charAt(j)>s3.charAt(j))\\n                                break;\\n                            if(s3.charAt(j)>s4.charAt(j))\\n                            {\\n                                s4=s3;\\n                                break;\\n                            }\\n                        }\\n\\n                    }\\n                }\\n            }\\n        }\\n        return s4;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2237874,
                "title": "c-explaining-why-std-max-can-work",
                "content": "std::max(string, string) => it will compare each character of the 1st string and the 2nd string (1st index vs 1st index, 2nd index vs 2nd index, 3rd index vs 3rd index, ....) until get the different character then return the string that have character[index] greater, if all characters are equal then requturn the 1st string .\\nFor ex: max(\"1551\", \"\") => compare \\'1\\' vs \\'\\', the empty character in the ascii table is zero (0) then when we look at the ascii table we can get \\'1\\' > \\'\\' => the result is \"1551\"\\nex2: max(\"1551\", \"161\")=> compare \\'1\\' vs \\'1\\', it equals, then next to the 2nd character of two string -> \\'5\\' vs \\'6\\' when compare it, we get \\'5\\' < \\'6\\' then the result is \"161\";\\nNote that: it not compare the length of each string;\\n\\n![image](https://assets.leetcode.com/users/images/5a176ae2-b2da-4310-8d2f-29662627952e_1656957107.285726.png)\\n\\n```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string res = \"\";\\n        for(int i=0; i<number.size(); i++){\\n            if(number[i] == digit){\\n                string temp = number.substr(0, i) + number.substr(i+1);\\n                res = max(res, temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string res = \"\";\\n        for(int i=0; i<number.size(); i++){\\n            if(number[i] == digit){\\n                string temp = number.substr(0, i) + number.substr(i+1);\\n                res = max(res, temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210059,
                "title": "c-solution-0ms-faster-than-100",
                "content": "string removeDigit(string number, char digit) {\\n        string t;\\n        string mx=\"0\";\\n        for(int i=0;i<number.size();i++)\\n        {\\n            if(number[i]==digit)\\n            {\\n              t=number.substr(0,i)+number.substr(i+1);\\n                if(mx<t)\\n                    mx=t;\\n            }  \\n        }\\n        return mx;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "string removeDigit(string number, char digit) {\\n        string t;\\n        string mx=\"0\";\\n        for(int i=0;i<number.size();i++)\\n        {\\n            if(number[i]==digit)\\n            {\\n              t=number.substr(0,i)+number.substr(i+1);\\n                if(mx<t)\\n                    mx=t;\\n            }  \\n        }\\n        return mx;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2196878,
                "title": "java-faster-than-97-7-explanation",
                "content": "***Explanation:***\\n\\nIn this question, we iterate through the string and find if the ith index matches the given digit. If so, then we check the condition that if the value succeeding the current index is greater than it or not. If so, we return the answer after removing the digit at that particular index.\\nLet us consider the following example:\\n```\\nnumber = 4874289\\ndigit = 8\\n```\\nThere are two occurrences of 8 in the number. If we remove the first occurrence of 8, then the resulting number will be `474289`, and if we remove the second occurrence, then the number will be `487429`, clearly, `487429 >  474289`.\\n\\nThe idea is to replace the given digit with a digit greater than it to increase the overall value of the number.\\n\\nHowever, if neither of the digits after the required digit are greater than it, then remove the last index of the  required digit so that effectively it decreases the value of the number to a lesser extent. \\n\\n***Code:***\\n```\\nclass Solution \\n{\\n    public String removeDigit(String number,char digit) \\n    {\\n        for(int i=1;i<number.length();i++)\\n        {\\n            if(number.charAt(i-1)==digit)\\n            {\\n                if(number.charAt(i-1)<number.charAt(i))\\n                {\\n                    return number.substring(0,i-1)+number.substring(i);\\n                }\\n            }\\n        }\\n        int idx=number.lastIndexOf(digit);\\n        return number.substring(0,idx)+number.substring(idx+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nnumber = 4874289\\ndigit = 8\\n```\n```\\nclass Solution \\n{\\n    public String removeDigit(String number,char digit) \\n    {\\n        for(int i=1;i<number.length();i++)\\n        {\\n            if(number.charAt(i-1)==digit)\\n            {\\n                if(number.charAt(i-1)<number.charAt(i))\\n                {\\n                    return number.substring(0,i-1)+number.substring(i);\\n                }\\n            }\\n        }\\n        int idx=number.lastIndexOf(digit);\\n        return number.substring(0,idx)+number.substring(idx+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190897,
                "title": "c-0ms-fastest-solution-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        int n = number.size();\\n        int del;\\n        for(int i=0;i<n;i++){\\n            if(number[i] == digit){\\n                if(i+1<n && number[i+1] > digit){\\n                    del = i;\\n                    break;\\n                }\\n                else if(i+1<n && number[i+1] == digit){\\n                    del = i;\\n                    continue;\\n                }\\n                else{\\n                    del = i;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<n;i++){\\n            if(i != del){\\n                ans += number[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        int n = number.size();\\n        int del;\\n        for(int i=0;i<n;i++){\\n            if(number[i] == digit){\\n                if(i+1<n && number[i+1] > digit){\\n                    del = i;\\n                    break;\\n                }\\n                else if(i+1<n && number[i+1] == digit){\\n                    del = i;\\n                    continue;\\n                }\\n                else{\\n                    del = i;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<n;i++){\\n            if(i != del){\\n                ans += number[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188134,
                "title": "remove-digit-from-number-to-maximize-result-java",
                "content": "class Solution {\\n    public String removeDigit(String number, char digit) {\\n        int i=1;\\n        for(;i<number.length();i++){\\n            if(number.charAt(i-1)==digit){\\n                if(number.charAt(i-1)<number.charAt(i)){\\n                    return(number.substring(0,i-1)+number.substring(i));\\n                }\\n            }\\n        }\\n        int lastIndex=number.lastIndexOf(digit);\\n        return(number.substring(0,lastIndex)+ number.substring(lastIndex+1));\\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String removeDigit(String number, char digit) {\\n        int i=1;\\n        for(;i<number.length();i++){\\n            if(number.charAt(i-1)==digit){\\n                if(number.charAt(i-1)<number.charAt(i)){\\n                    return(number.substring(0,i-1)+number.substring(i));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2150961,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions-for-remove-digit-from-number-to-maximize-result",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        vector<string> v;\\n            for(int i=0;i<number.size();i++)\\n            {\\n                string s=number;\\n                if(number[i]==digit)\\n                {\\n                    s.erase(i,1);\\n                    v.push_back(s);\\n                }\\n            }\\n        return *max_element(v.begin(),v.end());\\n\\n    }\\n};\\n```\\nPlease upvote my code if you liked it, It will really help!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        vector<string> v;\\n            for(int i=0;i<number.size();i++)\\n            {\\n                string s=number;\\n                if(number[i]==digit)\\n                {\\n                    s.erase(i,1);\\n                    v.push_back(s);\\n                }\\n            }\\n        return *max_element(v.begin(),v.end());\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147370,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Greedy Approach***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    string removeDigit(string str, char digit) {\\n        \\n        int n = str.size();\\n        \\n        int last_occurance;\\n        \\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            if(str[i] == digit)\\n            {\\n                if(str[i] < str[i + 1])  // next digit greater than curr digit \\n                {\\n                    str.erase(i, 1);\\n        \\n                    return str;\\n                }\\n                else   // update the last occurance\\n                {\\n                    last_occurance = i;\\n                }\\n            }\\n        }\\n        \\n        if(str[n - 1] == digit)\\n        {\\n            last_occurance = n - 1;\\n        }\\n        \\n        str.erase(last_occurance, 1);\\n        \\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string str, char digit) {\\n        \\n        int n = str.size();\\n        \\n        int last_occurance;\\n        \\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            if(str[i] == digit)\\n            {\\n                if(str[i] < str[i + 1])  // next digit greater than curr digit \\n                {\\n                    str.erase(i, 1);\\n        \\n                    return str;\\n                }\\n                else   // update the last occurance\\n                {\\n                    last_occurance = i;\\n                }\\n            }\\n        }\\n        \\n        if(str[n - 1] == digit)\\n        {\\n            last_occurance = n - 1;\\n        }\\n        \\n        str.erase(last_occurance, 1);\\n        \\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147277,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Approach 1 : Brute Force***\\n\\n* ***Time Complexity : O(N * N)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    string removeDigit(string str, char digit) {\\n        \\n        int n = str.size();\\n        \\n        string maxi = \"\";\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(str[i] == digit)\\n            {\\n                string left = \"\";\\n                \\n                string right = \"\";\\n                \\n                left = str.substr(0, i);\\n                \\n                right = str.substr(i + 1);\\n                \\n                string temp = left + right;\\n                \\n                maxi = max(maxi, temp);\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string str, char digit) {\\n        \\n        int n = str.size();\\n        \\n        string maxi = \"\";\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(str[i] == digit)\\n            {\\n                string left = \"\";\\n                \\n                string right = \"\";\\n                \\n                left = str.substr(0, i);\\n                \\n                right = str.substr(i + 1);\\n                \\n                string temp = left + right;\\n                \\n                maxi = max(maxi, temp);\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131450,
                "title": "python-greedy-remove",
                "content": "imagine we have number 1212121, digit = 1.\\nif any num right after the occurance of \"digit\" is larger, it will be the result. 212121 > 122121 > ....\\n\\nYou can also enumerate all possible result and compare them, given the constraint 2 <= number.length <= 100.\\n```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        \\n        n = len(number)\\n        \\n        last = -1\\n        for i in range(n):\\n            \\n            if number[i] == digit:\\n                if i < n-1 and number[i+1] > number[i]:\\n                    return number[:i]+number[i+1:]\\n                \\n                last = i\\n                \\n        return number[:last]+number[last+1:]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        \\n        n = len(number)\\n        \\n        last = -1\\n        for i in range(n):\\n            \\n            if number[i] == digit:\\n                if i < n-1 and number[i+1] > number[i]:\\n                    return number[:i]+number[i+1:]\\n                \\n                last = i\\n                \\n        return number[:last]+number[last+1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123484,
                "title": "kotlin-1-line-solution",
                "content": "```\\nfun removeDigit(number: String, digit: Char): String {\\n\\treturn number.indices.filter { number[it] == digit.toChar() }.map { number.replaceRange(it, it + 1, \"\") }.max()!!\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun removeDigit(number: String, digit: Char): String {\\n\\treturn number.indices.filter { number[it] == digit.toChar() }.map { number.replaceRange(it, it + 1, \"\") }.max()!!\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084967,
                "title": "python-3-o-n-time-o-n-space",
                "content": "![image](https://assets.leetcode.com/users/images/11f425c3-32dc-4f50-8b5a-927bd6ef7238_1653768502.1773694.png)\\n\\n\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        \"\"\" O(N)TS \"\"\"\\n        j = next((i for i, (a, b) in enumerate(itertools.pairwise(number)) if a == digit and a < b), number.rfind(digit))\\n        return number[:j] + number[j + 1:]",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/11f425c3-32dc-4f50-8b5a-927bd6ef7238_1653768502.1773694.png)\\n\\n\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        \"\"\" O(N)TS \"\"\"\\n        j = next((i for i, (a, b) in enumerate(itertools.pairwise(number)) if a == digit and a < b), number.rfind(digit))\\n        return number[:j] + number[j + 1:]",
                "codeTag": "Python3"
            },
            {
                "id": 2074877,
                "title": "c-3-lines-in-o-n-time-using-substr-function",
                "content": "If any suggestions please comment below.\\n```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string res=\"\";\\n        for(int i=0;i<number.size();i++)\\n        {\\n            if(number[i]==digit)\\n            {\\n                res=max(number.substr(0,i) + number.substr(i+1), res);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string res=\"\";\\n        for(int i=0;i<number.size();i++)\\n        {\\n            if(number[i]==digit)\\n            {\\n                res=max(number.substr(0,i) + number.substr(i+1), res);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074693,
                "title": "javascript-o-n-time-o-1-space-with-comments",
                "content": "Detect the digit. We want to maximize the number. So if the next number is greater than the digit, we get rid of it and make it bigger.\\nIf not, then by removing the current digit, we make the number smaller. It\\'s best to delete the furthest position, as down-sizing of the number will be minimized. Thus we only keep the latest index of the digit.\\n```\\nvar removeDigit = function(number, digit) {\\n    let idx;\\n    \\n    for (let i = 0; i < number.length; i++) {\\n        if (number[i] == digit) {\\n\\t\\t\\n\\t\\t\\t// By deleting this digit, the number gets larger.\\n            if (number[i+1] > digit) {\\n                return number.slice(0, i) + number.slice(i+1);\\n            }\\n            \\n\\t\\t\\t// By deleting this digit, the number gets smaller. We keep the index and continue to see if there is \\n\\t\\t\\t// another digit that will make the number larger later on. If that\\'s not the case in the end, \\n\\t\\t\\t// we delete the furthest of such to minimize the loss.\\n            else {\\n                idx = i;\\n            }\\n        }\\n    }\\n    \\n    return number.slice(0, idx) + number.slice(idx+1);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar removeDigit = function(number, digit) {\\n    let idx;\\n    \\n    for (let i = 0; i < number.length; i++) {\\n        if (number[i] == digit) {\\n\\t\\t\\n\\t\\t\\t// By deleting this digit, the number gets larger.\\n            if (number[i+1] > digit) {\\n                return number.slice(0, i) + number.slice(i+1);\\n            }\\n            \\n\\t\\t\\t// By deleting this digit, the number gets smaller. We keep the index and continue to see if there is \\n\\t\\t\\t// another digit that will make the number larger later on. If that\\'s not the case in the end, \\n\\t\\t\\t// we delete the furthest of such to minimize the loss.\\n            else {\\n                idx = i;\\n            }\\n        }\\n    }\\n    \\n    return number.slice(0, idx) + number.slice(idx+1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2074471,
                "title": "python-3-brute-force-single-statment",
                "content": "Runtime: 32 ms\\nMemory Usage: 13.9 MB\\n\\nEasily collapsible to a one-liner, but expanded for visual clarity.  \\n```Python\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        return max (\\n            number[:i] + number[i+1:]\\n            for i in range(len(number))\\n            if number[i] == digit\\n        )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        return max (\\n            number[:i] + number[i+1:]\\n            for i in range(len(number))\\n            if number[i] == digit\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053456,
                "title": "javascript-69ms-beats-82",
                "content": "```\\n/**\\n * @param {string} number\\n * @param {character} digit\\n * @return {string}\\n */\\nconst removeDigit = (number, digit) => {\\n    let max = \\'0\\';\\n    \\n    for (const i in number) {\\n        const n = number[i];\\n        const temp = [...number];\\n        if (n === digit) {\\n            temp.splice(i, 1);\\n            const curr = temp.join(\\'\\');\\n            if (curr > max)\\n                max = curr;\\n        }\\n    }\\n    \\n    return max;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} number\\n * @param {character} digit\\n * @return {string}\\n */\\nconst removeDigit = (number, digit) => {\\n    let max = \\'0\\';\\n    \\n    for (const i in number) {\\n        const n = number[i];\\n        const temp = [...number];\\n        if (n === digit) {\\n            temp.splice(i, 1);\\n            const curr = temp.join(\\'\\');\\n            if (curr > max)\\n                max = curr;\\n        }\\n    }\\n    \\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2053387,
                "title": "simple-o-n-java-solution",
                "content": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        \\n        // the unintuitive algorithm: \\n        // Loop over the number String character by character.\\n        // When we find an occurence of the digit, look to see if the next \\n        // digit over is larger.  If so, this is the occurence we need to delete (why does this work?).  \\n        // If we never see our digit preceeding a larger value, then remove the last occurence of the digit.\\n        \\n        int lastIndex = -1 ;\\n        StringBuilder sb = new StringBuilder(number);\\n        for(int i = 0; i < number.length(); i++) {\\n            char currentChar = number.charAt(i);\\n            \\n            if (currentChar == digit) {\\n                // always set the most recent index that we find our digit.  This allows us to \\n                // remove the last occurence if we need to\\n                lastIndex = i;   \\n                \\n                if (i < number.length() - 1 && Integer.valueOf(number.charAt(i + 1)) > Integer.valueOf(digit)) {\\n                    // the digit to the right of our current digit, is greater.  This is the occurence\\n                    // of our digit that we need to remove.  Since we already set the lastIndex above, we\\n                    // can now just break from the for loop and immediately return below.\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return sb.deleteCharAt(lastIndex).toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        \\n        // the unintuitive algorithm: \\n        // Loop over the number String character by character.\\n        // When we find an occurence of the digit, look to see if the next \\n        // digit over is larger.  If so, this is the occurence we need to delete (why does this work?).  \\n        // If we never see our digit preceeding a larger value, then remove the last occurence of the digit.\\n        \\n        int lastIndex = -1 ;\\n        StringBuilder sb = new StringBuilder(number);\\n        for(int i = 0; i < number.length(); i++) {\\n            char currentChar = number.charAt(i);\\n            \\n            if (currentChar == digit) {\\n                // always set the most recent index that we find our digit.  This allows us to \\n                // remove the last occurence if we need to\\n                lastIndex = i;   \\n                \\n                if (i < number.length() - 1 && Integer.valueOf(number.charAt(i + 1)) > Integer.valueOf(digit)) {\\n                    // the digit to the right of our current digit, is greater.  This is the occurence\\n                    // of our digit that we need to remove.  Since we already set the lastIndex above, we\\n                    // can now just break from the for loop and immediately return below.\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return sb.deleteCharAt(lastIndex).toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033812,
                "title": "c-simple-for-loop-solution",
                "content": "```\\npublic string RemoveDigit(string number, char digit) {\\n\\tint maxIndex = 0;\\n\\tfor (int i = 0; i < number.Length; i++)\\n\\t{\\n\\t\\tif (number[i] == digit)\\n\\t\\t{\\n\\t\\t    // if the target digit is smaller than the next digit, remove it. \\n\\t\\t\\tif (i != number.Length - 1 && number[i] < number[i + 1] )  \\n\\t\\t\\t{\\n\\t\\t\\t\\treturn number.Remove(i, 1);\\n\\t\\t\\t}\\n\\t\\t\\tmaxIndex = i;\\n\\t\\t}\\n\\t}\\n\\t// remove the last one\\n\\treturn number.Remove(maxIndex,1);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic string RemoveDigit(string number, char digit) {\\n\\tint maxIndex = 0;\\n\\tfor (int i = 0; i < number.Length; i++)\\n\\t{\\n\\t\\tif (number[i] == digit)\\n\\t\\t{\\n\\t\\t    // if the target digit is smaller than the next digit, remove it. \\n\\t\\t\\tif (i != number.Length - 1 && number[i] < number[i + 1] )  \\n\\t\\t\\t{\\n\\t\\t\\t\\treturn number.Remove(i, 1);\\n\\t\\t\\t}\\n\\t\\t\\tmaxIndex = i;\\n\\t\\t}\\n\\t}\\n\\t// remove the last one\\n\\treturn number.Remove(maxIndex,1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2033135,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        ans = []\\n        for ind,i in enumerate(number):\\n            if i == digit:\\n                ans.append(int(number[:ind]+number[ind+1:]))\\n        return str(max(ans))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        ans = []\\n        for ind,i in enumerate(number):\\n            if i == digit:\\n                ans.append(int(number[:ind]+number[ind+1:]))\\n        return str(max(ans))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017235,
                "title": "scala-simple-linear",
                "content": "The algorithm is based on an observation, that the removal of a digit increases the value of string if the digit is followed by a bigger digit and decreases if it\\'s followed by a lower digit. So, to maximize the string we should either remove the FIRST digit that is followed by a bigger digit, or the LAST digit which isn\\'t followed by a bigger digit.\\n```scala\\ndef removeDigit(number: String, digit: Char): String = {\\n  def go(l: List[Char], acc: List[Char]): List[Char] =\\n    l match {\\n      case h1 :: h2 :: tail if h1 == digit & h1 < h2 => acc.reverse ::: h2 :: tail\\n      case Nil =>\\n        val (prepend, append) = acc.splitAt(acc.indexWhere(_ == digit))\\n        append.tail.reverse ::: prepend.reverse\\n      case h :: tail => go(tail, h :: acc)\\n    }\\n\\n  new String(go(number.toList, List.empty).toArray) \\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\ndef removeDigit(number: String, digit: Char): String = {\\n  def go(l: List[Char], acc: List[Char]): List[Char] =\\n    l match {\\n      case h1 :: h2 :: tail if h1 == digit & h1 < h2 => acc.reverse ::: h2 :: tail\\n      case Nil =>\\n        val (prepend, append) = acc.splitAt(acc.indexWhere(_ == digit))\\n        append.tail.reverse ::: prepend.reverse\\n      case h :: tail => go(tail, h :: acc)\\n    }\\n\\n  new String(go(number.toList, List.empty).toArray) \\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2017064,
                "title": "easy-solution-python3",
                "content": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        res=\"\"\\n        for x in range(len(number)):\\n            if number[x]==digit:\\n                if x<len(number)-1:\\n                    if number[x]<number[x+1]:\\n                        return number[0:x]+number[x+1:]\\n        for x in range(len(number)-1,-1,-1):\\n            if number[x]==digit:\\n                return number[0:x]+number[x+1:]\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        res=\"\"\\n        for x in range(len(number)):\\n            if number[x]==digit:\\n                if x<len(number)-1:\\n                    if number[x]<number[x+1]:\\n                        return number[0:x]+number[x+1:]\\n        for x in range(len(number)-1,-1,-1):\\n            if number[x]==digit:\\n                return number[0:x]+number[x+1:]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015650,
                "title": "c-easy-solution-100-fast-easy-to-understand",
                "content": "\\n\\n\\n    class Solution {\\n    public:\\n    string removeDigit(string number, char digit) {\\n        int x=-1;\\n        for(int i=0;i<number.length();i++){\\n            if(number[i]==digit){\\n                if(number[i]<number[i+1]){\\n                    x=i;\\n                    break;\\n                }\\n                x=i;\\n            }\\n        }\\n        string str=\"\";\\n        for(int i=0;i<number.length();i++){\\n            if(x==i){\\n                continue;\\n            }\\n            else{\\n                str+=number[i];\\n            }\\n        }\\n        return str;\\n      }\\n    };",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    public:\\n    string removeDigit(string number, char digit) {\\n        int x=-1;\\n        for(int i=0;i<number.length();i++){\\n            if(number[i]==digit){\\n                if(number[i]<number[i+1]){\\n                    x=i;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2015164,
                "title": "easy-cpp-solution",
                "content": "*Here all we need to do is to check from starting point and traverse the and search if at any point \\'i\\' value is equal to our digit and the next value is greater than our digit then simply delete that position else delete the final occurence of our digit. Thats it!*\\n```\\n\\nusing namespace std;\\nclass Solution {\\npublic:\\n    string removeDigit(string s, char digit) {\\n        int n = s.size(),last_occurence = -1,target = -1;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==digit){\\n                last_occurence =i;\\n                break;\\n            }\\n        }\\n        for(int i=0;i<n-1;i++){\\n            if(s[i]==digit && s[i+1]>s[i]){\\n                target = i;\\n                break;\\n            }\\n        }\\n        if(target!=-1){\\n            s.erase(s.begin()+target);\\n        }else if(last_occurence!=-1){\\n            s.erase(s.begin()+last_occurence); \\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nusing namespace std;\\nclass Solution {\\npublic:\\n    string removeDigit(string s, char digit) {\\n        int n = s.size(),last_occurence = -1,target = -1;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==digit){\\n                last_occurence =i;\\n                break;\\n            }\\n        }\\n        for(int i=0;i<n-1;i++){\\n            if(s[i]==digit && s[i+1]>s[i]){\\n                target = i;\\n                break;\\n            }\\n        }\\n        if(target!=-1){\\n            s.erase(s.begin()+target);\\n        }else if(last_occurence!=-1){\\n            s.erase(s.begin()+last_occurence); \\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014227,
                "title": "java-1ms-solution",
                "content": "```\\n        char[] chars = number.toCharArray();\\n        StringBuilder str = new StringBuilder(number);\\n        int position = -1;\\n        for (int i = 0; i < chars.length - 1; i++) {\\n            if (chars[i] == digit && chars[i] < chars[i + 1]) {\\n                position = i;\\n                break;\\n            }\\n        }\\n        if (position == -1) {\\n            return str.deleteCharAt(number.lastIndexOf(digit)).toString();\\n        } else {\\n            return str.deleteCharAt(position).toString();\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n        char[] chars = number.toCharArray();\\n        StringBuilder str = new StringBuilder(number);\\n        int position = -1;\\n        for (int i = 0; i < chars.length - 1; i++) {\\n            if (chars[i] == digit && chars[i] < chars[i + 1]) {\\n                position = i;\\n                break;\\n            }\\n        }\\n        if (position == -1) {\\n            return str.deleteCharAt(number.lastIndexOf(digit)).toString();\\n        } else {\\n            return str.deleteCharAt(position).toString();\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2013190,
                "title": "runtime-6-ms-c-solution-vector",
                "content": "class Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        vector<string> v;\\n        string str;\\n        for(int j=0;j<number.size();j++)\\n        {\\n            if(number[j]==digit)\\n            {\\n                str=number;\\n                str.erase(str.begin() + j);\\n                v.push_back(str); \\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        return v[v.size()-1];\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        vector<string> v;\\n        string str;\\n        for(int j=0;j<number.size();j++)\\n        {\\n            if(number[j]==digit)\\n            {\\n                str=number;\\n                str.erase(str.begin() + j);\\n                v.push_back(str); \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2007824,
                "title": "java-compareto-method-easy",
                "content": "When ever it encounter the digit, we form a temp string excluding digit. The value of our result string and temp string can be directly compared using `.compareTo` method. If temp is greater than result then update result.\\n\\n```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        String res = \"\";\\n        \\n        for(int i = 0; i < number.length(); i++) {\\n            if(number.charAt(i) == digit) {\\n                String temp = number.substring(0, i) + number.substring(i + 1);\\n                if(temp.compareTo(res) > 0) \\n                    res = temp;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        String res = \"\";\\n        \\n        for(int i = 0; i < number.length(); i++) {\\n            if(number.charAt(i) == digit) {\\n                String temp = number.substring(0, i) + number.substring(i + 1);\\n                if(temp.compareTo(res) > 0) \\n                    res = temp;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001161,
                "title": "javascript-solutions",
                "content": "```\\nvar removeDigit = function(number, digit) {\\n    let nums = [];\\n    for (let i = 0; i < number.length; i++) \\n        if (number[i] === digit) nums.push(number.slice(0, i) + number.slice(i + 1));\\n    \\n    return nums.sort()[nums.length - 1];\\n};\\n```\\n\\n```\\nvar removeDigit = function(number, digit) {\\n    let found = false;\\n    for (let i = 0; i < number.length; i++) {\\n        // hit the target\\n        if (number[i] === digit) {\\n            lastIndex = i;\\n            // check the digit next to the target, if it is larger than target\\n            // then the current hit is the right digit to remove\\n            if (i < number.length - 1 && number[i + 1] > digit) found = true;\\n        }\\n\\n        // reach the end\\n        if (i === number.length - 1) found = true;\\n                \\n        if (found) return number.slice(0, lastIndex) + number.slice(lastIndex + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeDigit = function(number, digit) {\\n    let nums = [];\\n    for (let i = 0; i < number.length; i++) \\n        if (number[i] === digit) nums.push(number.slice(0, i) + number.slice(i + 1));\\n    \\n    return nums.sort()[nums.length - 1];\\n};\\n```\n```\\nvar removeDigit = function(number, digit) {\\n    let found = false;\\n    for (let i = 0; i < number.length; i++) {\\n        // hit the target\\n        if (number[i] === digit) {\\n            lastIndex = i;\\n            // check the digit next to the target, if it is larger than target\\n            // then the current hit is the right digit to remove\\n            if (i < number.length - 1 && number[i + 1] > digit) found = true;\\n        }\\n\\n        // reach the end\\n        if (i === number.length - 1) found = true;\\n                \\n        if (found) return number.slice(0, lastIndex) + number.slice(lastIndex + 1);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1999757,
                "title": "java-solution-in-4-line",
                "content": "```\\nclass Solution {\\n\\n\\tpublic String removeDigit(String number, char digit) {\\n\\t\\tString result = \"\";\\n\\t\\tfor (int i = 0; i < number.length(); i++) {\\n\\t\\t\\tif (number.charAt(i) == digit && result.compareTo(number.substring(0, i) + number.substring(i + 1)) < 0) {\\n\\t\\t\\t\\tresult = number.substring(0, i) + number.substring(i + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n\\tpublic String removeDigit(String number, char digit) {\\n\\t\\tString result = \"\";\\n\\t\\tfor (int i = 0; i < number.length(); i++) {\\n\\t\\t\\tif (number.charAt(i) == digit && result.compareTo(number.substring(0, i) + number.substring(i + 1)) < 0) {\\n\\t\\t\\t\\tresult = number.substring(0, i) + number.substring(i + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997991,
                "title": "c-code-simple-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        vector<int> m;\\n        vector<string> s; \\n        for(int i=0; i< number.size() ; i++)\\n        {\\n            if(number[i] == digit)\\n            {\\n                m.push_back(i);\\n            }\\n        }\\n        int n = m.size();\\n        for(int i= 0 ; i< n ; i++)\\n        {\\n            string temp = number;\\n            temp.erase(temp.begin()+m[i]);\\n            s.push_back(temp);\\n        }\\n        sort(s.begin() , s.end());\\n        return s[s.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        vector<int> m;\\n        vector<string> s; \\n        for(int i=0; i< number.size() ; i++)\\n        {\\n            if(number[i] == digit)\\n            {\\n                m.push_back(i);\\n            }\\n        }\\n        int n = m.size();\\n        for(int i= 0 ; i< n ; i++)\\n        {\\n            string temp = number;\\n            temp.erase(temp.begin()+m[i]);\\n            s.push_back(temp);\\n        }\\n        sort(s.begin() , s.end());\\n        return s[s.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997783,
                "title": "remove-digit-from-number-to-maximize-result",
                "content": "class Solution {\\npublic:\\n    string removeDigit(string s, char digit) \\n    {\\n        int f=0;\\n        \\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==digit)\\n            {\\n                f++;\\n            }\\n        }\\n        \\n        \\n          for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==digit)\\n            {\\n                f--;\\n                if(i+1<s.size() && (s[i+1]-\\'0\\'>s[i]-\\'0\\'))\\n                {\\n                    s.erase(s.begin()+i);\\n                    break;\\n                }\\n                else if(i+1 <s.size() && (s[i+1]-\\'0\\'<= s[i]-\\'0\\'))\\n                {\\n                    if(f==0)\\n                    {\\n                        s.erase(s.begin()+i);break;\\n                        \\n                    }\\n                      \\n                }\\n                else\\n                {\\n                    s.erase(s.begin()+i);break;\\n                    \\n                }\\n            }\\n        }\\n        \\n        \\n        return s;\\n        \\n        \\n        \\n        \\n    }\\n};\\n\\n\\n\\n# **//pls upvoteeeeeeeeeeeeeeeeeeeeeeeeeeeee**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string removeDigit(string s, char digit) \\n    {\\n        int f=0;\\n        \\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==digit)\\n            {\\n                f++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1997738,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        num = []\\n        for i, val in enumerate(number):\\n            if val == digit:\\n                num.append(number[:i]+number[i+1:])\\n        return max(num)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        num = []\\n        for i, val in enumerate(number):\\n            if val == digit:\\n                num.append(number[:i]+number[i+1:])\\n        return max(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997595,
                "title": "java-easy-sol",
                "content": "````\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        ArrayList<String>ans=new ArrayList<>();\\n        for(int i=0;i<number.length();i++)\\n        {\\n            if(number.charAt(i)==digit)\\n            {\\n                ans.add(number.substring(0,i)+number.substring(i+1));\\n            }\\n        }\\n        Collections.sort(ans);\\n        return ans.get(ans.size()-1);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String removeDigit(String number, char digit) {\\n        ArrayList<String>ans=new ArrayList<>();\\n        for(int i=0;i<number.length();i++)\\n        {\\n            if(number.charAt(i)==digit)\\n            {\\n                ans.add(number.substring(0,i)+number.substring(i+1));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1997243,
                "title": "easy-explaination-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        \\n        int n = number.size()  ; \\n        for(int i=0;i<n;i++){\\n            if(i+1<n && number[i] < number[i+1] && number[i]==digit){ // Checking if it is possible to remove digit from the front\\n                number.erase(number.begin()+i)  ; \\n                return number; \\n            }\\n        }\\n        \\n    \\n        for(int i = n-1 ;i>=0 ; --i ){\\n            if(number[i]==digit){\\n                number.erase(number.begin()+i)  ;   // Remove the last occurence of digit ( only possible way )\\n                break ;\\n            }\\n        }\\n        \\n        return number; \\n    }\\n};\\n// Time complexity : O(n) \\n// Space complexity : O(1) \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        \\n        int n = number.size()  ; \\n        for(int i=0;i<n;i++){\\n            if(i+1<n && number[i] < number[i+1] && number[i]==digit){ // Checking if it is possible to remove digit from the front\\n                number.erase(number.begin()+i)  ; \\n                return number; \\n            }\\n        }\\n        \\n    \\n        for(int i = n-1 ;i>=0 ; --i ){\\n            if(number[i]==digit){\\n                number.erase(number.begin()+i)  ;   // Remove the last occurence of digit ( only possible way )\\n                break ;\\n            }\\n        }\\n        \\n        return number; \\n    }\\n};\\n// Time complexity : O(n) \\n// Space complexity : O(1) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997240,
                "title": "brute-force-easy-to-understand-with-explaination-t-c-o-n-s-c-o-1-java",
                "content": "1. Change the number from string to StringBuilder (because t.c to remove and add in stringBuilder is O(1)).\\n2. Loop through the string\\n3. Remove the digit if found in string and then compare with the current max \\n4. After comparision place the digit back to its position.\\n5. In the end you will have the max Number\\n```\\n  public String removeDigit(String number, char digit) {\\n\\n        String max = \"\";\\n\\n        StringBuilder sb = new StringBuilder(number);\\n\\n        for (int i = 0; i < number.length(); i++) {\\n            if (sb.charAt(i) == digit) {\\n                sb.deleteCharAt(i);\\n                String curr = sb.toString();\\n                if (curr.compareTo(max) > 0) {\\n                    max = temp;\\n                }\\n                sb.insert(i, digit);\\n            }\\n        }\\n\\n        return max;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  public String removeDigit(String number, char digit) {\\n\\n        String max = \"\";\\n\\n        StringBuilder sb = new StringBuilder(number);\\n\\n        for (int i = 0; i < number.length(); i++) {\\n            if (sb.charAt(i) == digit) {\\n                sb.deleteCharAt(i);\\n                String curr = sb.toString();\\n                if (curr.compareTo(max) > 0) {\\n                    max = temp;\\n                }\\n                sb.insert(i, digit);\\n            }\\n        }\\n\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1997128,
                "title": "easy-to-understand-java",
                "content": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        String max = \"\";\\n        int N = number.length();\\n        for(int i=0; i< N; i++){\\n            char ch = number.charAt(i);\\n            StringBuilder newNumber = new StringBuilder(\"\");\\n            if(ch == digit){\\n                for(int j=0; j<i; j++){\\n                    newNumber.append(number.charAt(j));\\n                }\\n                for(int j=i+1; j< N; j++){\\n                    newNumber.append(number.charAt(j));\\n                }\\n            }\\n            String temp = newNumber.toString();\\n            if(temp.compareTo(max) > 0){\\n                max = temp;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\nIf you have any **doubts**, feel **free to ask**...\\nIf you understand the **concept**. Don\\'t Forget to **upvote** \\uD83D\\uDE0A\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        String max = \"\";\\n        int N = number.length();\\n        for(int i=0; i< N; i++){\\n            char ch = number.charAt(i);\\n            StringBuilder newNumber = new StringBuilder(\"\");\\n            if(ch == digit){\\n                for(int j=0; j<i; j++){\\n                    newNumber.append(number.charAt(j));\\n                }\\n                for(int j=i+1; j< N; j++){\\n                    newNumber.append(number.charAt(j));\\n                }\\n            }\\n            String temp = newNumber.toString();\\n            if(temp.compareTo(max) > 0){\\n                max = temp;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996934,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions-for-remove-digit-from-number-to-maximize-result",
                "content": "```\\n class Solution {\\n   public:\\n    string removeDigit(string number, char digit) {\\n        \\n        int cnt = 0;\\n        int n = number.length();\\n        int l_o = -1;\\n        int res = -1;\\n        for(int i = 0 ; i < n ; i++){\\n            if( i < n- 1 && number[i] == digit && number[i] < number[i+1]){\\n                cnt++;\\n                if(res == -1){\\n                    res = i;\\n                }\\n                \\n            }\\n            if(number[i] == digit){\\n                l_o = i;\\n            }\\n            \\n            \\n        }\\n        string ans = \"\";\\n        if(cnt == 0){\\n            for(int i = 0 ; i < n ; i++){\\n                if(i != l_o)\\n                    ans = ans + number[i];\\n            }\\n            \\n\\n        }else{\\n            for(int i = 0 ; i < n ; i++){\\n                if(i != res)\\n                    ans = ans + number[i];\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n class Solution {\\n   public:\\n    string removeDigit(string number, char digit) {\\n        \\n        int cnt = 0;\\n        int n = number.length();\\n        int l_o = -1;\\n        int res = -1;\\n        for(int i = 0 ; i < n ; i++){\\n            if( i < n- 1 && number[i] == digit && number[i] < number[i+1]){\\n                cnt++;\\n                if(res == -1){\\n                    res = i;\\n                }\\n                \\n            }\\n            if(number[i] == digit){\\n                l_o = i;\\n            }\\n            \\n            \\n        }\\n        string ans = \"\";\\n        if(cnt == 0){\\n            for(int i = 0 ; i < n ; i++){\\n                if(i != l_o)\\n                    ans = ans + number[i];\\n            }\\n            \\n\\n        }else{\\n            for(int i = 0 ; i < n ; i++){\\n                if(i != res)\\n                    ans = ans + number[i];\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996896,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string t, r = \"\";\\n        int l = number.length();\\n        for(int i=0; i<l; ++i){\\n            t = number;\\n            if(t[i] == digit ){\\n                t.erase(i,1);\\n                if(t > r){\\n                    r = t;\\n                }\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string t, r = \"\";\\n        int l = number.length();\\n        for(int i=0; i<l; ++i){\\n            t = number;\\n            if(t[i] == digit ){\\n                t.erase(i,1);\\n                if(t > r){\\n                    r = t;\\n                }\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996778,
                "title": "python-easy-solution",
                "content": "\\nRuntime: 36 ms, faster than 82.96% of Python3 online submissions for Remove Digit From Number to Maximize Result.\\nMemory Usage: 13.9 MB, less than 68.84% of Python3 online submissions for Remove Digit From Number to Maximize Result.\\n```\\nclass Solution:\\n  def removeDigit(self, number: str, digit: str) -> str:\\n    last = -1\\n    for i in range (len(number)) :\\n      if number[i] == digit :\\n        last = i\\n        if i != len(number) - 1 and number[i] < number[i+1] :\\n          return number[0:i] + number[i+1:]\\n    return number[0:last] + number[last+1:]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def removeDigit(self, number: str, digit: str) -> str:\\n    last = -1\\n    for i in range (len(number)) :\\n      if number[i] == digit :\\n        last = i\\n        if i != len(number) - 1 and number[i] < number[i+1] :\\n          return number[0:i] + number[i+1:]\\n    return number[0:last] + number[last+1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996684,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        possibles = []\\n        es = []\\n        N = number\\n        for i in range(0, len(N)):\\n            if (N)[i] == digit:\\n                es.append(i)\\n        for k in es:\\n            chars = list(N)\\n            chars[k] = \\'\\'\\n            possibles.append((\"\".join(chars)))\\n        return max(possibles)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        possibles = []\\n        es = []\\n        N = number\\n        for i in range(0, len(N)):\\n            if (N)[i] == digit:\\n                es.append(i)\\n        for k in es:\\n            chars = list(N)\\n            chars[k] = \\'\\'\\n            possibles.append((\"\".join(chars)))\\n        return max(possibles)",
                "codeTag": "Java"
            },
            {
                "id": 1996635,
                "title": "c-solution-uisng-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        vector<string>v;\\n        string a=\"\";\\n        for(int i=0;i<number.length();i++){\\n            if(number[i]==digit){\\n                a=number;\\n                a.erase(i,1);\\n            }\\n        v.push_back(a);\\n    }\\n        sort(begin(v),end(v));\\n        return v[v.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        vector<string>v;\\n        string a=\"\";\\n        for(int i=0;i<number.length();i++){\\n            if(number[i]==digit){\\n                a=number;\\n                a.erase(i,1);\\n            }\\n        v.push_back(a);\\n    }\\n        sort(begin(v),end(v));\\n        return v[v.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996607,
                "title": "c-easy-to-understand-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    bool cmp(string s1,string s2){\\n        vector<int>t1,t2;\\n        for(auto i:s1){\\n            int temp = int(i);\\n            t1.push_back(temp);\\n        }\\n        for(auto i:s2){\\n            int temp = int(i);\\n            t2.push_back(temp);\\n        }\\n        for(int i=0;i<t1.size();i++){\\n            if(t2>t1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    string removeDigit(string num, char digit) {\\n        string ans=\"\",t1=\"\";\\n        int temp=0;\\n        for(int i=0;i<num.length();i++){\\n            if(num[i]==digit){\\n                t1=\"\";\\n                for(int j=0;j<num.length();j++){\\n                    if(j!=i){\\n                        t1+=num[j];\\n                    }\\n                }\\n                if(ans==\"\"){\\n                    ans=t1;\\n                }\\n                if(cmp(ans,t1)){\\n                    ans=t1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool cmp(string s1,string s2){\\n        vector<int>t1,t2;\\n        for(auto i:s1){\\n            int temp = int(i);\\n            t1.push_back(temp);\\n        }\\n        for(auto i:s2){\\n            int temp = int(i);\\n            t2.push_back(temp);\\n        }\\n        for(int i=0;i<t1.size();i++){\\n            if(t2>t1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    string removeDigit(string num, char digit) {\\n        string ans=\"\",t1=\"\";\\n        int temp=0;\\n        for(int i=0;i<num.length();i++){\\n            if(num[i]==digit){\\n                t1=\"\";\\n                for(int j=0;j<num.length();j++){\\n                    if(j!=i){\\n                        t1+=num[j];\\n                    }\\n                }\\n                if(ans==\"\"){\\n                    ans=t1;\\n                }\\n                if(cmp(ans,t1)){\\n                    ans=t1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996587,
                "title": "python-clean-simple",
                "content": "```py\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        last = 0\\n        for i in range(1, len(number)):\\n            if number[i-1] == digit and number[i] > digit:\\n                last = i-1\\n                break\\n        else:\\n            last = number.rindex(digit)\\n        return number[:last] + number[last+1:]\\n```\\n\\nor...\\n\\n```py\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        last, n = 0, len(number)\\n        for i in range(n):\\n            if digit == number[i]:\\n                last = i\\n                if i < n-1 and digit < number[i+1]:\\n                    break\\n        return number[:last] + number[last+1:]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        last = 0\\n        for i in range(1, len(number)):\\n            if number[i-1] == digit and number[i] > digit:\\n                last = i-1\\n                break\\n        else:\\n            last = number.rindex(digit)\\n        return number[:last] + number[last+1:]\\n```\n```py\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        last, n = 0, len(number)\\n        for i in range(n):\\n            if digit == number[i]:\\n                last = i\\n                if i < n-1 and digit < number[i+1]:\\n                    break\\n        return number[:last] + number[last+1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996531,
                "title": "my-swift-solution-space-time-beat-100",
                "content": "For problems involving the removal of a digit to change the number value, removing the possible left-most digit will always mostly impact the resulting value. Right-most possible digit least.\\n\\nWe define the matching digit is the digit that matches the given character. The following digit is the digit next to the matched digit. For every matching digit, the result of comparing its value with the following digit would determine whether the resulting value is larger or smaller.\\n\\nIn this problem, we want to maximize the resulting value. If this is impossible in a situation where all found matching digits are smaller, we want to diminish the impact of decreasing the number.\\n\\nStarting from the left, once we find removing a matched digit could increase the resulting value, this matched digit would be the answer. Remove and return ASAP.\\n\\nDuring our journey, we may encounter digits whose removal will decrease the value first. We need to find the right-most one in this case, so we need to keep tracking the newest matched digit we find.\\n\\n\\n```\\nclass Solution {\\n    func removeDigit(_ number: String, _ digit: Character) -> String {\\n        var result = number\\n        var removeIndex: String.Index?\\n        \\n        for index in number.indices {\\n            if number[index] == digit {\\n                removeIndex = index\\n                let indexNext: String.Index = number.index(after: index)\\n                \\n                if indexNext != number.endIndex && number[indexNext] > digit {\\n                    result.remove(at: removeIndex!)\\n                    return result\\n                }\\n            }\\n        }\\n        result.remove(at: removeIndex!)\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "String",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\n    func removeDigit(_ number: String, _ digit: Character) -> String {\\n        var result = number\\n        var removeIndex: String.Index?\\n        \\n        for index in number.indices {\\n            if number[index] == digit {\\n                removeIndex = index\\n                let indexNext: String.Index = number.index(after: index)\\n                \\n                if indexNext != number.endIndex && number[indexNext] > digit {\\n                    result.remove(at: removeIndex!)\\n                    return result\\n                }\\n            }\\n        }\\n        result.remove(at: removeIndex!)\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996471,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string maxNumber;\\n        for (int i = 0; i < number.size(); ++i)\\n        {\\n            if (number[i] == digit)\\n            {\\n                maxNumber = max(maxNumber, number.substr(0, i) + number.substr(i + 1));\\n            }\\n        }\\n        return maxNumber;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string maxNumber;\\n        for (int i = 0; i < number.size(); ++i)\\n        {\\n            if (number[i] == digit)\\n            {\\n                maxNumber = max(maxNumber, number.substr(0, i) + number.substr(i + 1));\\n            }\\n        }\\n        return maxNumber;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996441,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        String ans = \"\", temp;\\n        int n = number.length();\\n        for (int i = 0; i < n; ++i) {\\n            if (number.charAt(i) == digit) {\\n                temp = number.substring(0, i) + number.substring(i + 1);\\n                if (ans.compareTo(temp) < 0)\\n                    ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        String ans = \"\", temp;\\n        int n = number.length();\\n        for (int i = 0; i < n; ++i) {\\n            if (number.charAt(i) == digit) {\\n                temp = number.substring(0, i) + number.substring(i + 1);\\n                if (ans.compareTo(temp) < 0)\\n                    ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996417,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        int n=number.size();\\n        int idx=0;\\n        \\n        bool check=false;\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(number[i]==digit)\\n            {\\n                idx=i;\\n                if(number[i+1]>number[i])\\n                {\\n                    check=true;\\n                    break;\\n                }\\n            }  \\n        }\\n        if(!check)\\n        {\\n            if(number[n-1]==digit)\\n                idx=n-1;\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i!=idx)\\n            {\\n                ans+=number[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        int n=number.size();\\n        int idx=0;\\n        \\n        bool check=false;\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(number[i]==digit)\\n            {\\n                idx=i;\\n                if(number[i+1]>number[i])\\n                {\\n                    check=true;\\n                    break;\\n                }\\n            }  \\n        }\\n        if(!check)\\n        {\\n            if(number[n-1]==digit)\\n                idx=n-1;\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i!=idx)\\n            {\\n                ans+=number[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996383,
                "title": "c-simple-solution",
                "content": "```\\nstring removeDigit(string number, char digit) \\n    {\\n        int i;\\n        for(i=0;i<number.size();i++)\\n        {\\n            if(number[i]==digit)\\n            {\\n                if(number[i+1]>number[i])\\n                {\\n                    number.erase(number.begin()+i);\\n                    return number;\\n                }\\n            }\\n        }\\n        \\n        while(1)\\n        {\\n            if(number[i]==digit)\\n            {\\n                number.erase(number.begin()+i);\\n                break;\\n            }\\n            i--;\\n        }\\n        \\n        return number;\\n    }",
                "solutionTags": [],
                "code": "```\\nstring removeDigit(string number, char digit) \\n    {\\n        int i;\\n        for(i=0;i<number.size();i++)\\n        {\\n            if(number[i]==digit)\\n            {\\n                if(number[i+1]>number[i])\\n                {\\n                    number.erase(number.begin()+i);\\n                    return number;\\n                }\\n            }\\n        }\\n        \\n        while(1)\\n        {\\n            if(number[i]==digit)\\n            {\\n                number.erase(number.begin()+i);\\n                break;\\n            }\\n            i--;\\n        }\\n        \\n        return number;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1996342,
                "title": "java-solution-with-comments-for-understanding",
                "content": "```\\n\\tstatic boolean check(String a, String b){\\n        if(a.length() > b.length()) return false; // return false if length of a is greater tha b\\n        \\n        for(int i=0;i<Math.min(a.length(),b.length());i++){ //loop will continue for same digit\\n            if(Integer.valueOf(a.charAt(i)) < Integer.valueOf(b.charAt(i))) return true; //return true if we found the greater digit in b\\n            else if(Integer.valueOf(a.charAt(i)) > Integer.valueOf(b.charAt(i))) return false; //return false if digit in a is greater than b\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public String removeDigit(String number, char digit) {\\n        String ans =\"\"; //to store the ans\\n        for(int i=0;i<number.length();i++){\\n            if(number.charAt(i) == digit){\\n                String s1 = number.substring(0,i); //string before the that digit\\n                s1 += number.substring(i+1); //string after that digit\\n                if(ans == \"\") ans = s1; // if empty then we put the value directly\\n                else if(check(ans,s1)) ans = s1; // if not then check first between ans and s1\\n            }\\n        }\\n        return ans; // final ans\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tstatic boolean check(String a, String b){\\n        if(a.length() > b.length()) return false; // return false if length of a is greater tha b\\n        \\n        for(int i=0;i<Math.min(a.length(),b.length());i++){ //loop will continue for same digit\\n            if(Integer.valueOf(a.charAt(i)) < Integer.valueOf(b.charAt(i))) return true; //return true if we found the greater digit in b\\n            else if(Integer.valueOf(a.charAt(i)) > Integer.valueOf(b.charAt(i))) return false; //return false if digit in a is greater than b\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public String removeDigit(String number, char digit) {\\n        String ans =\"\"; //to store the ans\\n        for(int i=0;i<number.length();i++){\\n            if(number.charAt(i) == digit){\\n                String s1 = number.substring(0,i); //string before the that digit\\n                s1 += number.substring(i+1); //string after that digit\\n                if(ans == \"\") ans = s1; // if empty then we put the value directly\\n                else if(check(ans,s1)) ans = s1; // if not then check first between ans and s1\\n            }\\n        }\\n        return ans; // final ans\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1996322,
                "title": "c-check-next-or-last",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string n, char digit) {\\n        int last = 0;\\n        for (int i = 0; i < n.size(); i++) {\\n            if (n[i] == digit) {\\n                last = i;\\n                if (i != n.size() - 1 and n[i + 1] > n[i]) {\\n                    break;\\n                }\\n            }    \\n        }\\n        n.erase(n.begin() + last);\\n\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string n, char digit) {\\n        int last = 0;\\n        for (int i = 0; i < n.size(); i++) {\\n            if (n[i] == digit) {\\n                last = i;\\n                if (i != n.size() - 1 and n[i + 1] > n[i]) {\\n                    break;\\n                }\\n            }    \\n        }\\n        n.erase(n.begin() + last);\\n\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996287,
                "title": "c-sorting",
                "content": "```\\npublic class Solution {\\n    public string RemoveDigit(string number, char digit) {\\n        List<string> list = new List<string>();\\n        for(int i = 0; i < number.Length; i++)\\n        {\\n            if(number[i]==digit)\\n                list.Add(number.Substring(0, i)+number.Substring(i+1));\\n        }\\n        \\n        list = list.OrderBy(x=>x).ToList();\\n        \\n        return list[list.Count-1];\\n    }\\n}",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\n    public string RemoveDigit(string number, char digit) {\\n        List<string> list = new List<string>();\\n        for(int i = 0; i < number.Length; i++)\\n        {\\n            if(number[i]==digit)\\n                list.Add(number.Substring(0, i)+number.Substring(i+1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1996220,
                "title": "java-deletecharat-optimal",
                "content": "1. We require two indices. One for the first occurance of digit where the character on its right is larger than digit(min_id). Another for the last occurance of digit(last_id)\\n2. If min_id remains unchanged during the iteration, remove the last occurance of digit(last_id)\\n3. Else, remove digit from min_id index\\n```\\nclass Solution\\n{\\n    public String removeDigit(String number, char digit)\\n    {\\n        int min_id = -1, last_id = -1;\\n        for(int i = 0; i < number.length(); i++)\\n        {\\n            if(number.charAt(i) == digit)\\n            {\\n                if(i < number.length()-1 && number.charAt(i) < number.charAt(i+1))\\n                {\\n                    min_id = i;\\n                    break;\\n                }\\n                last_id = i;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(number);\\n        if(min_id == -1)\\n            sb = sb.deleteCharAt(last_id);\\n        else\\n            sb = sb.deleteCharAt(min_id);\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public String removeDigit(String number, char digit)\\n    {\\n        int min_id = -1, last_id = -1;\\n        for(int i = 0; i < number.length(); i++)\\n        {\\n            if(number.charAt(i) == digit)\\n            {\\n                if(i < number.length()-1 && number.charAt(i) < number.charAt(i+1))\\n                {\\n                    min_id = i;\\n                    break;\\n                }\\n                last_id = i;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(number);\\n        if(min_id == -1)\\n            sb = sb.deleteCharAt(last_id);\\n        else\\n            sb = sb.deleteCharAt(min_id);\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086365,
                "title": "easy-solution-7-lines",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        n = len(number)\\n        for i in range(n):\\n            if number[i] == digit:\\n                if i < n-1 and number[i+1] > digit:\\n                    return number[:i] + number[i+1:]\\n                latest = i\\n        return number[:latest] + number[latest+1:]\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        n = len(number)\\n        for i in range(n):\\n            if number[i] == digit:\\n                if i < n-1 and number[i+1] > digit:\\n                    return number[:i] + number[i+1:]\\n                latest = i\\n        return number[:latest] + number[latest+1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085379,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        String res = \"\";\\n\\n        for(int i=0; i<number.length(); i++){\\n            StringBuilder str = new StringBuilder(number);\\n            if(str.charAt(i)==digit){\\n                String temp = str.deleteCharAt(i).toString();\\n                if(res.compareTo(temp) < 0)\\n                    res = temp;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        String res = \"\";\\n\\n        for(int i=0; i<number.length(); i++){\\n            StringBuilder str = new StringBuilder(number);\\n            if(str.charAt(i)==digit){\\n                String temp = str.deleteCharAt(i).toString();\\n                if(res.compareTo(temp) < 0)\\n                    res = temp;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079342,
                "title": "discuss",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        for (int i = 0; i + 1 < number.length(); ++i)\\n        if (number.charAt(i) == digit && digit < number.charAt(i + 1))\\n            return new StringBuilder(number).deleteCharAt(i).toString();\\n        return new StringBuilder(number).deleteCharAt(number.lastIndexOf(digit)).toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        for (int i = 0; i + 1 < number.length(); ++i)\\n        if (number.charAt(i) == digit && digit < number.charAt(i + 1))\\n            return new StringBuilder(number).deleteCharAt(i).toString();\\n        return new StringBuilder(number).deleteCharAt(number.lastIndexOf(digit)).toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078333,
                "title": "remove-digit-from-number-to-maximize-result-simple-easy-solution",
                "content": "# Intuition\\nYou are given a string number representing a positive integer and a character digit.\\n\\nReturn the resulting string after removing exactly one occurrence of digit from number such that the value of the resulting string in decimal form is maximized. The test cases are generated such that digit occurs at least once in number.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        newstr = 0\\n        \\n        for idx,n in enumerate(number):\\n            if n==digit:\\n                curr = number[:idx]+number[idx+1::]\\n                newstr = max(int(curr),newstr)\\n            else:\\n                pass\\n        \\n        return str(newstr)\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        newstr = 0\\n        \\n        for idx,n in enumerate(number):\\n            if n==digit:\\n                curr = number[:idx]+number[idx+1::]\\n                newstr = max(int(curr),newstr)\\n            else:\\n                pass\\n        \\n        return str(newstr)\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077366,
                "title": "java-optimize-approch-in-o-n-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeDigit(String nums, char digit) {\\n        int cnt=0, len = nums.length();\\n        for(int i=0; i<len ; i++){\\n            if(nums.charAt(i)==digit){\\n                cnt=i;\\n                if(i<len-1 && digit < nums.charAt(i+1)) break;\\n            }\\n        }\\n        return nums.substring(0, cnt) + nums.substring(cnt+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String nums, char digit) {\\n        int cnt=0, len = nums.length();\\n        for(int i=0; i<len ; i++){\\n            if(nums.charAt(i)==digit){\\n                cnt=i;\\n                if(i<len-1 && digit < nums.charAt(i+1)) break;\\n            }\\n        }\\n        return nums.substring(0, cnt) + nums.substring(cnt+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076704,
                "title": "simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        String result = \"\", cur = \"\";\\n        for(int i=0;i<number.length();i++){\\n            StringBuilder sb = new StringBuilder(number);\\n            if(number.charAt(i) == digit){\\n                String res = sb.delete(i,i+1).toString();\\n                if(result.compareTo(res) <0) {\\n                    result = res;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n\\n// java.base/java.lang.NumberFormatException.forInputString\\n//   at line 668, java.base/java.lang.Integer.parseInt\\n//   at line 786, java.base/java.lang.Integer.parseInt\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        String result = \"\", cur = \"\";\\n        for(int i=0;i<number.length();i++){\\n            StringBuilder sb = new StringBuilder(number);\\n            if(number.charAt(i) == digit){\\n                String res = sb.delete(i,i+1).toString();\\n                if(result.compareTo(res) <0) {\\n                    result = res;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n\\n// java.base/java.lang.NumberFormatException.forInputString\\n//   at line 668, java.base/java.lang.Integer.parseInt\\n//   at line 786, java.base/java.lang.Integer.parseInt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076266,
                "title": "simple-solution",
                "content": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        last = 0\\n        for i in range(len(number)-1):\\n            if number[i] == digit:\\n                if number[i] < number[i+1]:\\n                    return number[:i]+number[i+1:]\\n                last = i        \\n        return number[:-1] if number[-1] == digit else number[:last]+number[last+1:]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        last = 0\\n        for i in range(len(number)-1):\\n            if number[i] == digit:\\n                if number[i] < number[i+1]:\\n                    return number[:i]+number[i+1:]\\n                last = i        \\n        return number[:-1] if number[-1] == digit else number[:last]+number[last+1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076195,
                "title": "swift-memory-64-runtime-50-upvote",
                "content": "# Intuition\\nTo remove the digit found in the number (String type) and finally return the largest number in the form of a String.\\n\\n# Approach\\nIterative\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    func removeDigit(_ number: String, _ digit: Character) -> String {\\n        var resultArray = [String]()\\n        var numCopy = number\\n\\n        for (i, value) in number.enumerated() {\\n            if value == digit {\\n                let index = number.index(number.startIndex, offsetBy: i)\\n                // removing wherever found the digit/s\\n                numCopy.remove(at: index)\\n                resultArray.append(numCopy)\\n                // re-initializing the variable to keep indexes as before\\n                numCopy = number\\n            }\\n        }\\n        // sorting to get the largest at last\\n        resultArray.sort()\\n        // returning the last (largest)\\n        return String(resultArray.last!)\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    func removeDigit(_ number: String, _ digit: Character) -> String {\\n        var resultArray = [String]()\\n        var numCopy = number\\n\\n        for (i, value) in number.enumerated() {\\n            if value == digit {\\n                let index = number.index(number.startIndex, offsetBy: i)\\n                // removing wherever found the digit/s\\n                numCopy.remove(at: index)\\n                resultArray.append(numCopy)\\n                // re-initializing the variable to keep indexes as before\\n                numCopy = number\\n            }\\n        }\\n        // sorting to get the largest at last\\n        resultArray.sort()\\n        // returning the last (largest)\\n        return String(resultArray.last!)\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065954,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        maxnum = float(\\'-inf\\')\\n\\n        number = list(number)\\n\\n        for i in range(len(number)):\\n            curr = \"\"\\n            if number[i] == digit:\\n                curr = number[:i] + number[i+1:]\\n                maxnum = max(maxnum, int(\\'\\'.join(curr)))\\n\\n        return str(maxnum)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        maxnum = float(\\'-inf\\')\\n\\n        number = list(number)\\n\\n        for i in range(len(number)):\\n            curr = \"\"\\n            if number[i] == digit:\\n                curr = number[:i] + number[i+1:]\\n                maxnum = max(maxnum, int(\\'\\'.join(curr)))\\n\\n        return str(maxnum)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057617,
                "title": "easy-java-solution-0-ms",
                "content": "# Code\\n```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        int n = number.length();\\n\\n        for(int i = 0; i < n-1; i++){\\n            if(number.charAt(i) == digit && number.charAt(i+1) > digit)\\n                return number.substring(0,i) + number.substring(i+1);\\n        }\\n\\n        int idx = number.lastIndexOf(digit);\\n\\n        return number.substring(0,idx) + number.substring(idx+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        int n = number.length();\\n\\n        for(int i = 0; i < n-1; i++){\\n            if(number.charAt(i) == digit && number.charAt(i+1) > digit)\\n                return number.substring(0,i) + number.substring(i+1);\\n        }\\n\\n        int idx = number.lastIndexOf(digit);\\n\\n        return number.substring(0,idx) + number.substring(idx+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057385,
                "title": "40-lines-noobs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n      \\n        String num = \"\";\\n        String max= \"\";\\n\\n\\n        for (int i = 0; i < number.length(); i++) {\\n            if (number.charAt(i) == digit || number.charAt(i) == \\' \\') {\\n                String before = number.substring(0, i);\\n                String after = number.substring(i + 1);\\n                num=before + after;\\n                if(max==\"\")\\n                max=before+after;\\n                \\n            }\\n                if (num.length()>max.length()) {\\n                    max = num;\\n                }\\n                else if (num.length()<max.length()) {\\n                    max = max;}\\n                else if (max.length()==num.length()) {\\n                   \\n                    for (int j = 0; j < max.length(); j++) {\\n                        if (max.charAt(j) > num.charAt(j)) {\\n                            max = max;\\n                            break;\\n                        }\\n                        else if (max.charAt(j) < num.charAt(j)) {\\n                            max = num;\\n                            break;\\n                        }\\n                    }\\n                }\\n\\n\\n            }\\n       return max;   }\\n}\\n\\n       \\n    \\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n      \\n        String num = \"\";\\n        String max= \"\";\\n\\n\\n        for (int i = 0; i < number.length(); i++) {\\n            if (number.charAt(i) == digit || number.charAt(i) == \\' \\') {\\n                String before = number.substring(0, i);\\n                String after = number.substring(i + 1);\\n                num=before + after;\\n                if(max==\"\")\\n                max=before+after;\\n                \\n            }\\n                if (num.length()>max.length()) {\\n                    max = num;\\n                }\\n                else if (num.length()<max.length()) {\\n                    max = max;}\\n                else if (max.length()==num.length()) {\\n                   \\n                    for (int j = 0; j < max.length(); j++) {\\n                        if (max.charAt(j) > num.charAt(j)) {\\n                            max = max;\\n                            break;\\n                        }\\n                        else if (max.charAt(j) < num.charAt(j)) {\\n                            max = num;\\n                            break;\\n                        }\\n                    }\\n                }\\n\\n\\n            }\\n       return max;   }\\n}\\n\\n       \\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055709,
                "title": "c-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public string RemoveDigit(string number, char digit) {\\n        string result = number;\\n        int lastFoundIndex = 0;\\n        for(int i=0;i<number.Length;i++){\\n            if(number[i]==digit){\\n                if(i<number.Length-1 && number[i+1]>digit){\\n                    result = number.Substring(0,i);\\n                    result+= number.Substring(i+1);\\n                    return result;\\n                }\\n               lastFoundIndex=i;\\n            }\\n        }\\n        result = number.Substring(0,lastFoundIndex);\\n        if(lastFoundIndex!=number.Length-1){\\n            result+= number.Substring(lastFoundIndex+1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string RemoveDigit(string number, char digit) {\\n        string result = number;\\n        int lastFoundIndex = 0;\\n        for(int i=0;i<number.Length;i++){\\n            if(number[i]==digit){\\n                if(i<number.Length-1 && number[i+1]>digit){\\n                    result = number.Substring(0,i);\\n                    result+= number.Substring(i+1);\\n                    return result;\\n                }\\n               lastFoundIndex=i;\\n            }\\n        }\\n        result = number.Substring(0,lastFoundIndex);\\n        if(lastFoundIndex!=number.Length-1){\\n            result+= number.Substring(lastFoundIndex+1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051818,
                "title": "python3-easy-solution",
                "content": "# Python3 easy solution \\n\\n# Approach\\nFind out and save index of all the appearance of the digit selected. Remove each index one at a time from teh number and compare each version of teh number with each other. The biggest number is the answer.\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        numsSet = set()\\n\\n        for i in range(len(number)):\\n            if number[i] == digit:\\n                numsSet.add(i)\\n\\n        maxValue = 0\\n        for index in numsSet:\\n            tempNum = number[:index] + number[index + 1 :]\\n            maxValue = max(int(tempNum), int(maxValue))\\n\\n        return f\\'{maxValue}\\'\\n```\\n\\n--- \\n\\n**Feel free to visit my Python course:**\\n[Learn Python for FREE](https://python.merajkazi.xyz)\\n\\n**My website:**\\n[merajkazi.xyz](https://merajkazi.xyz)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        numsSet = set()\\n\\n        for i in range(len(number)):\\n            if number[i] == digit:\\n                numsSet.add(i)\\n\\n        maxValue = 0\\n        for index in numsSet:\\n            tempNum = number[:index] + number[index + 1 :]\\n            maxValue = max(int(tempNum), int(maxValue))\\n\\n        return f\\'{maxValue}\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047858,
                "title": "jebasraja-very-easy",
                "content": "# Intuition:KARUNYA UNIVERSITY::ACCENTURE\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.math.BigInteger;\\nclass Solution \\n{\\n    public String removeDigit(String number, char digit) \\n    {\\n         \\n        BigInteger finalAnswer = BigInteger.ZERO;\\n        BigInteger bigNumber = new BigInteger(number);\\n\\n        for (int i = 0; i < number.length(); i++) {\\n            if (digit == number.charAt(i)) {\\n                String newNumberStr = number.substring(0, i) + number.substring(i + 1);\\n                BigInteger a = new BigInteger(newNumberStr);\\n                finalAnswer = finalAnswer.max(a);\\n            }\\n        }\\n\\n       // System.out.println(finalAnswer);\\n        //System.out.println(finalAnswer.toString());\\n\\n        return finalAnswer.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\nclass Solution \\n{\\n    public String removeDigit(String number, char digit) \\n    {\\n         \\n        BigInteger finalAnswer = BigInteger.ZERO;\\n        BigInteger bigNumber = new BigInteger(number);\\n\\n        for (int i = 0; i < number.length(); i++) {\\n            if (digit == number.charAt(i)) {\\n                String newNumberStr = number.substring(0, i) + number.substring(i + 1);\\n                BigInteger a = new BigInteger(newNumberStr);\\n                finalAnswer = finalAnswer.max(a);\\n            }\\n        }\\n\\n       // System.out.println(finalAnswer);\\n        //System.out.println(finalAnswer.toString());\\n\\n        return finalAnswer.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047839,
                "title": "gigachad-solution-xv",
                "content": "# Complexity\\n- Time complexity:\\nO(n log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        List<String> list = new ArrayList<>();\\n        for(int i = 0; i < number.length(); i++) {\\n            if(number.charAt(i) == digit) {\\n                list.add(number.substring(0, i) + number.substring(i + 1));\\n            }\\n        }\\n        Collections.sort(list);\\n\\n        return list.get(list.size() - 1);\\n    } \\n}\\n```\\n\\nUpvote if you want to be GigaChad",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        List<String> list = new ArrayList<>();\\n        for(int i = 0; i < number.length(); i++) {\\n            if(number.charAt(i) == digit) {\\n                list.add(number.substring(0, i) + number.substring(i + 1));\\n            }\\n        }\\n        Collections.sort(list);\\n\\n        return list.get(list.size() - 1);\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044403,
                "title": "simple-and-easy-solution-in-cpp-o-n",
                "content": "string removeDigit(string number, char digit) {\\n        int visit=0;\\n        for(int i=0;i<number.size();i++)\\n        {\\n            if(i+1<number.size()&&number[i]==digit&&(number[i+1]-\\'0\\')>(digit-\\'0\\'))\\n            {\\n                visit=i;\\n                break;\\n            }\\n           else if(number[i]==digit)\\n               visit=i;\\n        }\\n        string temp=\"\";\\n       \\n        for(int i=0;i<number.size();i++){\\n            if(i!=visit)\\n                temp.push_back(number[i]);\\n        }\\n        return temp;\\n    }\\n};",
                "solutionTags": [],
                "code": "string removeDigit(string number, char digit) {\\n        int visit=0;\\n        for(int i=0;i<number.size();i++)\\n        {\\n            if(i+1<number.size()&&number[i]==digit&&(number[i+1]-\\'0\\')>(digit-\\'0\\'))\\n            {\\n                visit=i;\\n                break;\\n            }\\n           else if(number[i]==digit)\\n               visit=i;\\n        }\\n        string temp=\"\";\\n       \\n        for(int i=0;i<number.size();i++){\\n            if(i!=visit)\\n                temp.push_back(number[i]);\\n        }\\n        return temp;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 4044227,
                "title": "c-easy-and-readable-solution-faster-than-85",
                "content": "![image.png](https://assets.leetcode.com/users/images/3f88ab4d-bc77-4d29-a19d-06e1a18b8f35_1694701019.7982888.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public string RemoveDigit(string number, char digit) {\\n        if (!number.Contains(digit))\\n            return number;\\n        List<string> ls = new();\\n        for (int i = 0; i < number.Length; i++)\\n            if (number[i] == digit)\\n                ls.Add(number.Remove(i, 1));\\n        return ls.Max();\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string RemoveDigit(string number, char digit) {\\n        if (!number.Contains(digit))\\n            return number;\\n        List<string> ls = new();\\n        for (int i = 0; i < number.Length; i++)\\n            if (number[i] == digit)\\n                ls.Add(number.Remove(i, 1));\\n        return ls.Max();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038797,
                "title": "java-simple-using-string-builder-1-ms",
                "content": "# Intuition\\nsearching of previous are smaller or not  \\n\\n# Approach\\nusing string builder\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        \\n    StringBuilder s = new StringBuilder(number);\\n            int index = -1;\\nfor(int i=0;i<number.length();i++)\\n\\n            {\\n                if(number.charAt(i)==digit){\\n                    index= i;\\n                }\\n                if(i==number.length()-1 && number.charAt(i)==digit){\\n                    s.deleteCharAt(i);\\n                }\\n                if(i < number.length()-1 && number.charAt(i)==digit && number.charAt(i+1) > number.charAt(i) ){\\n                      s.deleteCharAt(i);\\n                      return String.valueOf(s);\\n                }\\n            }\\n\\nif(s.length()==number.length()){\\n    s.deleteCharAt(index);\\n}\\n            return String.valueOf(s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        \\n    StringBuilder s = new StringBuilder(number);\\n            int index = -1;\\nfor(int i=0;i<number.length();i++)\\n\\n            {\\n                if(number.charAt(i)==digit){\\n                    index= i;\\n                }\\n                if(i==number.length()-1 && number.charAt(i)==digit){\\n                    s.deleteCharAt(i);\\n                }\\n                if(i < number.length()-1 && number.charAt(i)==digit && number.charAt(i+1) > number.charAt(i) ){\\n                      s.deleteCharAt(i);\\n                      return String.valueOf(s);\\n                }\\n            }\\n\\nif(s.length()==number.length()){\\n    s.deleteCharAt(index);\\n}\\n            return String.valueOf(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036396,
                "title": "solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        a=[]\\n        b=[]\\n        for i in number :\\n            a.append(i)\\n        # print(a)\\n        c=a\\n        for i in range(0,len(number)) :\\n            if a[i]==digit :\\n                d=\\'\\'\\n                for j in range(0,len(number)) :\\n                    if j!=i :\\n                        d+=number[j]\\n                b.append(int(d))\\n        return (str(max(b)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        a=[]\\n        b=[]\\n        for i in number :\\n            a.append(i)\\n        # print(a)\\n        c=a\\n        for i in range(0,len(number)) :\\n            if a[i]==digit :\\n                d=\\'\\'\\n                for j in range(0,len(number)) :\\n                    if j!=i :\\n                        d+=number[j]\\n                b.append(int(d))\\n        return (str(max(b)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035709,
                "title": "python-solution-100-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 33ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.34mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        mx=-1\\n        for i in range(len(number)):\\n            if(number[i]==digit):\\n                now=number[:i]+number[i+1:]\\n                if(int(now)>int(mx)):\\n                    mx=now\\n        return mx\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        mx=-1\\n        for i in range(len(number)):\\n            if(number[i]==digit):\\n                now=number[:i]+number[i+1:]\\n                if(int(now)>int(mx)):\\n                    mx=now\\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035670,
                "title": "beats-100-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        \\n        int l= number.size();\\n        int c= 0;\\n\\n        for(int i=0; i<l ; i++)\\n        {\\n            if(number[i]==digit && i!=l-1)\\n            {\\n                c=i;\\n                if(number[i+1]>number[i]) \\n                return number.substr(0,i) + number.substr(i+1);\\n            }\\n\\n            if(i==l-1)\\n            {\\n                if(number[i]==digit) return number.substr(0,i);\\n                else\\n                return number.substr(0,c) + number.substr(c+1);\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        \\n        int l= number.size();\\n        int c= 0;\\n\\n        for(int i=0; i<l ; i++)\\n        {\\n            if(number[i]==digit && i!=l-1)\\n            {\\n                c=i;\\n                if(number[i+1]>number[i]) \\n                return number.substr(0,i) + number.substr(i+1);\\n            }\\n\\n            if(i==l-1)\\n            {\\n                if(number[i]==digit) return number.substr(0,i);\\n                else\\n                return number.substr(0,c) + number.substr(c+1);\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030614,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDigit(string s, char d) {\\n        string ans=\"\";\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            if(s[i]==d)\\n            {\\n                ans=max(ans,s.substr(0,i)+s.substr(i+1,s.length()));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDigit(string s, char d) {\\n        string ans=\"\";\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            if(s[i]==d)\\n            {\\n                ans=max(ans,s.substr(0,i)+s.substr(i+1,s.length()));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025899,
                "title": "beats-100-easy-explanation-c",
                "content": "# Intuition\\n#### we try to remove the given digit at any index  and get the removal that would give us the max number\\n\\n# Approach\\n#### whenever we meet the index of the digit that has to be removed we crop it out by using this line here\\n```\\ntemp = number.substr(0,i) +\"\"+ number.substr(i+1,number.size());\\n```\\n#### and then we got a normal max variable that traces the removal that would give me the maximum number\\n\\n```\\nif(max < temp){\\n    max = temp;\\n}\\n```\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string max = \"\";\\n        string temp = number;\\n        for(int i = 0 ; i < number.size() ; i++ ){\\n            if(number[i] == digit){\\n             temp = number.substr(0,i) +\"\"+ number.substr(i+1,number.size());\\n             if(max < temp){\\n                max = temp;\\n             }\\n            }\\n        }\\n       return max; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\ntemp = number.substr(0,i) +\"\"+ number.substr(i+1,number.size());\\n```\n```\\nif(max < temp){\\n    max = temp;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string removeDigit(string number, char digit) {\\n        string max = \"\";\\n        string temp = number;\\n        for(int i = 0 ; i < number.size() ; i++ ){\\n            if(number[i] == digit){\\n             temp = number.substr(0,i) +\"\"+ number.substr(i+1,number.size());\\n             if(max < temp){\\n                max = temp;\\n             }\\n            }\\n        }\\n       return max; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021871,
                "title": "java-solution-brute-force-not-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolution with Java \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nNot Efficient\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNot Efficient\\n# Code\\n```\\nimport java.math.BigInteger;\\n    class Solution {\\n    public String removeDigit(String number, char digit) {\\n    ArrayList<BigInteger> list = new ArrayList<>();\\n    for(int i=0;i<number.length();i++){\\n        char a=number.charAt(i);\\n        if(a==digit){\\n            String partBefore=number.substring(0,i);\\n            String partAfter=number.substring(i+1,number.length());\\n            String number2=partBefore+partAfter;\\n            list.add(new BigInteger(number2));\\n        }\\n    }        \\n    BigInteger max = Collections.max(list);\\n    return max.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\n    class Solution {\\n    public String removeDigit(String number, char digit) {\\n    ArrayList<BigInteger> list = new ArrayList<>();\\n    for(int i=0;i<number.length();i++){\\n        char a=number.charAt(i);\\n        if(a==digit){\\n            String partBefore=number.substring(0,i);\\n            String partAfter=number.substring(i+1,number.length());\\n            String number2=partBefore+partAfter;\\n            list.add(new BigInteger(number2));\\n        }\\n    }        \\n    BigInteger max = Collections.max(list);\\n    return max.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019810,
                "title": "just-check-next-digit-with-simple-for-loop",
                "content": "# Code\\n```\\n/**\\n * @param {string} number\\n * @param {character} digit\\n * @return {string}\\n */\\nvar removeDigit = function(number, digit) {\\n    let digitIdx = -1;\\n    for (let i = 0; i < number.length; i++) {\\n        if (number[i] === digit) {\\n            digitIdx = i;\\n            if (number[i + 1] > digit) {\\n                break;\\n            }\\n        }\\n    }\\n    return number.slice(0, digitIdx) + number.slice(digitIdx + 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} number\\n * @param {character} digit\\n * @return {string}\\n */\\nvar removeDigit = function(number, digit) {\\n    let digitIdx = -1;\\n    for (let i = 0; i < number.length; i++) {\\n        if (number[i] === digit) {\\n            digitIdx = i;\\n            if (number[i + 1] > digit) {\\n                break;\\n            }\\n        }\\n    }\\n    return number.slice(0, digitIdx) + number.slice(digitIdx + 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4016222,
                "title": "intuitive-5-liner-o-n-string-slicing-solution-beats-92-39",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def removeDigit(self, num: str, digit: str) -> str:\\n        ans = \"0\"\\n        for i in range(len(num)):\\n            if num[i] == digit:\\n                ans = max(ans, num[:i]+num[i+1:])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def removeDigit(self, num: str, digit: str) -> str:\\n        ans = \"0\"\\n        for i in range(len(num)):\\n            if num[i] == digit:\\n                ans = max(ans, num[:i]+num[i+1:])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006515,
                "title": "simple-java-substring-problem",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLoop through the `number` string and in each iteration, chop the string from $$0th$$ position to $$(i-1)th$$ position and concatenate this with the remaining portion of string starting from $$(i+1)th$$ position. In other words, exclude the $$ith$$ character from the string. Let\\'s store this string in a temporary variable `num`.\\n\\nCompare this `num` string with `result` string lexicographically using `compareTo()` function. If `num` string is lexicographically greater than the `result` string, update the `result` string and finally after the loop ends, return `result`.\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        String result = \"\";\\n\\n        for (int i = 0; i < number.length(); i++) {\\n            if (number.charAt(i) == digit) {\\n                // new string without i.\\n                String num = number.substring(0, i) + number.substring(i + 1);\\n                if(num.compareTo(result)>0){\\n                    result = num;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDigit(String number, char digit) {\\n        String result = \"\";\\n\\n        for (int i = 0; i < number.length(); i++) {\\n            if (number.charAt(i) == digit) {\\n                // new string without i.\\n                String num = number.substring(0, i) + number.substring(i + 1);\\n                if(num.compareTo(result)>0){\\n                    result = num;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1821347,
                "content": [
                    {
                        "username": "anowarul_karim",
                        "content": "just think do you really need to store all the possible answer.  Just think about the next position after matching."
                    },
                    {
                        "username": "ZeynepE",
                        "content": "TIP: Don\\'t try to convert anything to integers or other data types. You can use strings to compare numbers. And although strings are compared based on their ASCII value somehow it works. Wish they gave us this tip in the problem description. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nobody cares bro, low test nigga"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Who with a normal mind would make this testcase: \"299858953917872714814599237991174513476623756395992135212546127959342974628712329595771672911914471\""
                    },
                    {
                        "username": "priyajitmukherjee2008",
                        "content": "public static String removeDigit(String number, char digit) {\n\t\tList<Integer> list = new ArrayList<>();\n\t\tStringBuilder sb =  new StringBuilder(number);\n        for(int i =0; i<number.length(); i++)\n        {\n            if(number.charAt(i)==digit)\n            {\n            \tSystem.out.println(\"matches\");\n            \tlist.add(Integer.parseInt(new StringBuilder(number).deleteCharAt(i).toString()));          \t\n            }\n        }\n        Comparator<Integer> cmp = new Comparator<Integer>() {\n\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tif(o1>o2)\n\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n        \t\n\t\t};\n        list.sort(cmp);\n        return(list.get(list.size()-1)).toString();\n\t}"
                    },
                    {
                        "username": "piyush12345678900",
                        "content": "what is the mistake in my solution\\n\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        arr=[]\\n        number=input()\\n        digit=input()\\n        for _ in range(len(number)):\\n            if number[_]==digit:\\n                arr.append(int(number[0:_:1]+number[_+1::]))\\n        max(arr)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution seems to have a few errors and misunderstandings:\\n\\n1. `number=input()` and `digit=input()`: These lines are unnecessary. The function\\'s arguments `number` and `digit` are already being passed in when the function is called. You should remove these lines.\\n\\n2. `if number[]==digit:`: This line has a syntax error. It seems like you want to iterate over the digits in `number`, but you forgot to include the index inside the brackets.\\n\\n3. `arr.append(int(number[0::1]+number[_+1::]))`: This line will append the integer version of the string `number` without the current digit to `arr`. However, your slicing seems to be off. `number[0::1]` will include all the digits in `number`, and `number[_+1::]` will include all digits after the current one. This would not exclude the current digit from the result.\\n\\n4. `max(arr)`: This line returns the maximum value in `arr`, but it does not convert it back to a string. Also, it\\'s not inside a return statement, so the function does not return anything.\\n\\nA corrected version of your function could look like this:\\n\\n```python\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        arr = []\\n        for _ in range(len(number)):\\n            if number[_] == digit:\\n                arr.append(int(number[0:_] + number[_+1:]))\\n        return str(max(arr))\\n```\\n\\nThis version of your function removes the `digit` from `number` at every possible position and stores the resulting numbers in `arr`. Then it finds the maximum value in `arr`, converts it to a string and returns it. However, this is not the correct approach to the problem because you\\'re not seeking to create the maximum number by removing a `digit` at every possible position but to create the maximum number by removing a `digit` once. "
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "1st step->Take an arraylist of string\\n2nd step->add the possible string after removal of required character by using substring concertination.   \\n  if(number.charAt(i)==digit){\\n                list.add(number.substring(0,i)+number.substring(i+1));\\n            }\\nstep3->Then sort the arraylist by using Collections.sort(list) method\\nstep4->the last element of the list give the largest number after removal of character."
                    }
                ]
            },
            {
                "id": 2067575,
                "content": [
                    {
                        "username": "anowarul_karim",
                        "content": "just think do you really need to store all the possible answer.  Just think about the next position after matching."
                    },
                    {
                        "username": "ZeynepE",
                        "content": "TIP: Don\\'t try to convert anything to integers or other data types. You can use strings to compare numbers. And although strings are compared based on their ASCII value somehow it works. Wish they gave us this tip in the problem description. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nobody cares bro, low test nigga"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Who with a normal mind would make this testcase: \"299858953917872714814599237991174513476623756395992135212546127959342974628712329595771672911914471\""
                    },
                    {
                        "username": "priyajitmukherjee2008",
                        "content": "public static String removeDigit(String number, char digit) {\n\t\tList<Integer> list = new ArrayList<>();\n\t\tStringBuilder sb =  new StringBuilder(number);\n        for(int i =0; i<number.length(); i++)\n        {\n            if(number.charAt(i)==digit)\n            {\n            \tSystem.out.println(\"matches\");\n            \tlist.add(Integer.parseInt(new StringBuilder(number).deleteCharAt(i).toString()));          \t\n            }\n        }\n        Comparator<Integer> cmp = new Comparator<Integer>() {\n\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tif(o1>o2)\n\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n        \t\n\t\t};\n        list.sort(cmp);\n        return(list.get(list.size()-1)).toString();\n\t}"
                    },
                    {
                        "username": "piyush12345678900",
                        "content": "what is the mistake in my solution\\n\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        arr=[]\\n        number=input()\\n        digit=input()\\n        for _ in range(len(number)):\\n            if number[_]==digit:\\n                arr.append(int(number[0:_:1]+number[_+1::]))\\n        max(arr)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution seems to have a few errors and misunderstandings:\\n\\n1. `number=input()` and `digit=input()`: These lines are unnecessary. The function\\'s arguments `number` and `digit` are already being passed in when the function is called. You should remove these lines.\\n\\n2. `if number[]==digit:`: This line has a syntax error. It seems like you want to iterate over the digits in `number`, but you forgot to include the index inside the brackets.\\n\\n3. `arr.append(int(number[0::1]+number[_+1::]))`: This line will append the integer version of the string `number` without the current digit to `arr`. However, your slicing seems to be off. `number[0::1]` will include all the digits in `number`, and `number[_+1::]` will include all digits after the current one. This would not exclude the current digit from the result.\\n\\n4. `max(arr)`: This line returns the maximum value in `arr`, but it does not convert it back to a string. Also, it\\'s not inside a return statement, so the function does not return anything.\\n\\nA corrected version of your function could look like this:\\n\\n```python\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        arr = []\\n        for _ in range(len(number)):\\n            if number[_] == digit:\\n                arr.append(int(number[0:_] + number[_+1:]))\\n        return str(max(arr))\\n```\\n\\nThis version of your function removes the `digit` from `number` at every possible position and stores the resulting numbers in `arr`. Then it finds the maximum value in `arr`, converts it to a string and returns it. However, this is not the correct approach to the problem because you\\'re not seeking to create the maximum number by removing a `digit` at every possible position but to create the maximum number by removing a `digit` once. "
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "1st step->Take an arraylist of string\\n2nd step->add the possible string after removal of required character by using substring concertination.   \\n  if(number.charAt(i)==digit){\\n                list.add(number.substring(0,i)+number.substring(i+1));\\n            }\\nstep3->Then sort the arraylist by using Collections.sort(list) method\\nstep4->the last element of the list give the largest number after removal of character."
                    }
                ]
            },
            {
                "id": 2058686,
                "content": [
                    {
                        "username": "anowarul_karim",
                        "content": "just think do you really need to store all the possible answer.  Just think about the next position after matching."
                    },
                    {
                        "username": "ZeynepE",
                        "content": "TIP: Don\\'t try to convert anything to integers or other data types. You can use strings to compare numbers. And although strings are compared based on their ASCII value somehow it works. Wish they gave us this tip in the problem description. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nobody cares bro, low test nigga"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Who with a normal mind would make this testcase: \"299858953917872714814599237991174513476623756395992135212546127959342974628712329595771672911914471\""
                    },
                    {
                        "username": "priyajitmukherjee2008",
                        "content": "public static String removeDigit(String number, char digit) {\n\t\tList<Integer> list = new ArrayList<>();\n\t\tStringBuilder sb =  new StringBuilder(number);\n        for(int i =0; i<number.length(); i++)\n        {\n            if(number.charAt(i)==digit)\n            {\n            \tSystem.out.println(\"matches\");\n            \tlist.add(Integer.parseInt(new StringBuilder(number).deleteCharAt(i).toString()));          \t\n            }\n        }\n        Comparator<Integer> cmp = new Comparator<Integer>() {\n\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tif(o1>o2)\n\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n        \t\n\t\t};\n        list.sort(cmp);\n        return(list.get(list.size()-1)).toString();\n\t}"
                    },
                    {
                        "username": "piyush12345678900",
                        "content": "what is the mistake in my solution\\n\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        arr=[]\\n        number=input()\\n        digit=input()\\n        for _ in range(len(number)):\\n            if number[_]==digit:\\n                arr.append(int(number[0:_:1]+number[_+1::]))\\n        max(arr)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution seems to have a few errors and misunderstandings:\\n\\n1. `number=input()` and `digit=input()`: These lines are unnecessary. The function\\'s arguments `number` and `digit` are already being passed in when the function is called. You should remove these lines.\\n\\n2. `if number[]==digit:`: This line has a syntax error. It seems like you want to iterate over the digits in `number`, but you forgot to include the index inside the brackets.\\n\\n3. `arr.append(int(number[0::1]+number[_+1::]))`: This line will append the integer version of the string `number` without the current digit to `arr`. However, your slicing seems to be off. `number[0::1]` will include all the digits in `number`, and `number[_+1::]` will include all digits after the current one. This would not exclude the current digit from the result.\\n\\n4. `max(arr)`: This line returns the maximum value in `arr`, but it does not convert it back to a string. Also, it\\'s not inside a return statement, so the function does not return anything.\\n\\nA corrected version of your function could look like this:\\n\\n```python\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        arr = []\\n        for _ in range(len(number)):\\n            if number[_] == digit:\\n                arr.append(int(number[0:_] + number[_+1:]))\\n        return str(max(arr))\\n```\\n\\nThis version of your function removes the `digit` from `number` at every possible position and stores the resulting numbers in `arr`. Then it finds the maximum value in `arr`, converts it to a string and returns it. However, this is not the correct approach to the problem because you\\'re not seeking to create the maximum number by removing a `digit` at every possible position but to create the maximum number by removing a `digit` once. "
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "1st step->Take an arraylist of string\\n2nd step->add the possible string after removal of required character by using substring concertination.   \\n  if(number.charAt(i)==digit){\\n                list.add(number.substring(0,i)+number.substring(i+1));\\n            }\\nstep3->Then sort the arraylist by using Collections.sort(list) method\\nstep4->the last element of the list give the largest number after removal of character."
                    }
                ]
            },
            {
                "id": 1818036,
                "content": [
                    {
                        "username": "anowarul_karim",
                        "content": "just think do you really need to store all the possible answer.  Just think about the next position after matching."
                    },
                    {
                        "username": "ZeynepE",
                        "content": "TIP: Don\\'t try to convert anything to integers or other data types. You can use strings to compare numbers. And although strings are compared based on their ASCII value somehow it works. Wish they gave us this tip in the problem description. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nobody cares bro, low test nigga"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Who with a normal mind would make this testcase: \"299858953917872714814599237991174513476623756395992135212546127959342974628712329595771672911914471\""
                    },
                    {
                        "username": "priyajitmukherjee2008",
                        "content": "public static String removeDigit(String number, char digit) {\n\t\tList<Integer> list = new ArrayList<>();\n\t\tStringBuilder sb =  new StringBuilder(number);\n        for(int i =0; i<number.length(); i++)\n        {\n            if(number.charAt(i)==digit)\n            {\n            \tSystem.out.println(\"matches\");\n            \tlist.add(Integer.parseInt(new StringBuilder(number).deleteCharAt(i).toString()));          \t\n            }\n        }\n        Comparator<Integer> cmp = new Comparator<Integer>() {\n\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tif(o1>o2)\n\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n        \t\n\t\t};\n        list.sort(cmp);\n        return(list.get(list.size()-1)).toString();\n\t}"
                    },
                    {
                        "username": "piyush12345678900",
                        "content": "what is the mistake in my solution\\n\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        arr=[]\\n        number=input()\\n        digit=input()\\n        for _ in range(len(number)):\\n            if number[_]==digit:\\n                arr.append(int(number[0:_:1]+number[_+1::]))\\n        max(arr)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution seems to have a few errors and misunderstandings:\\n\\n1. `number=input()` and `digit=input()`: These lines are unnecessary. The function\\'s arguments `number` and `digit` are already being passed in when the function is called. You should remove these lines.\\n\\n2. `if number[]==digit:`: This line has a syntax error. It seems like you want to iterate over the digits in `number`, but you forgot to include the index inside the brackets.\\n\\n3. `arr.append(int(number[0::1]+number[_+1::]))`: This line will append the integer version of the string `number` without the current digit to `arr`. However, your slicing seems to be off. `number[0::1]` will include all the digits in `number`, and `number[_+1::]` will include all digits after the current one. This would not exclude the current digit from the result.\\n\\n4. `max(arr)`: This line returns the maximum value in `arr`, but it does not convert it back to a string. Also, it\\'s not inside a return statement, so the function does not return anything.\\n\\nA corrected version of your function could look like this:\\n\\n```python\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        arr = []\\n        for _ in range(len(number)):\\n            if number[_] == digit:\\n                arr.append(int(number[0:_] + number[_+1:]))\\n        return str(max(arr))\\n```\\n\\nThis version of your function removes the `digit` from `number` at every possible position and stores the resulting numbers in `arr`. Then it finds the maximum value in `arr`, converts it to a string and returns it. However, this is not the correct approach to the problem because you\\'re not seeking to create the maximum number by removing a `digit` at every possible position but to create the maximum number by removing a `digit` once. "
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "1st step->Take an arraylist of string\\n2nd step->add the possible string after removal of required character by using substring concertination.   \\n  if(number.charAt(i)==digit){\\n                list.add(number.substring(0,i)+number.substring(i+1));\\n            }\\nstep3->Then sort the arraylist by using Collections.sort(list) method\\nstep4->the last element of the list give the largest number after removal of character."
                    }
                ]
            },
            {
                "id": 1766368,
                "content": [
                    {
                        "username": "anowarul_karim",
                        "content": "just think do you really need to store all the possible answer.  Just think about the next position after matching."
                    },
                    {
                        "username": "ZeynepE",
                        "content": "TIP: Don\\'t try to convert anything to integers or other data types. You can use strings to compare numbers. And although strings are compared based on their ASCII value somehow it works. Wish they gave us this tip in the problem description. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nobody cares bro, low test nigga"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Who with a normal mind would make this testcase: \"299858953917872714814599237991174513476623756395992135212546127959342974628712329595771672911914471\""
                    },
                    {
                        "username": "priyajitmukherjee2008",
                        "content": "public static String removeDigit(String number, char digit) {\n\t\tList<Integer> list = new ArrayList<>();\n\t\tStringBuilder sb =  new StringBuilder(number);\n        for(int i =0; i<number.length(); i++)\n        {\n            if(number.charAt(i)==digit)\n            {\n            \tSystem.out.println(\"matches\");\n            \tlist.add(Integer.parseInt(new StringBuilder(number).deleteCharAt(i).toString()));          \t\n            }\n        }\n        Comparator<Integer> cmp = new Comparator<Integer>() {\n\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tif(o1>o2)\n\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n        \t\n\t\t};\n        list.sort(cmp);\n        return(list.get(list.size()-1)).toString();\n\t}"
                    },
                    {
                        "username": "piyush12345678900",
                        "content": "what is the mistake in my solution\\n\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        arr=[]\\n        number=input()\\n        digit=input()\\n        for _ in range(len(number)):\\n            if number[_]==digit:\\n                arr.append(int(number[0:_:1]+number[_+1::]))\\n        max(arr)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution seems to have a few errors and misunderstandings:\\n\\n1. `number=input()` and `digit=input()`: These lines are unnecessary. The function\\'s arguments `number` and `digit` are already being passed in when the function is called. You should remove these lines.\\n\\n2. `if number[]==digit:`: This line has a syntax error. It seems like you want to iterate over the digits in `number`, but you forgot to include the index inside the brackets.\\n\\n3. `arr.append(int(number[0::1]+number[_+1::]))`: This line will append the integer version of the string `number` without the current digit to `arr`. However, your slicing seems to be off. `number[0::1]` will include all the digits in `number`, and `number[_+1::]` will include all digits after the current one. This would not exclude the current digit from the result.\\n\\n4. `max(arr)`: This line returns the maximum value in `arr`, but it does not convert it back to a string. Also, it\\'s not inside a return statement, so the function does not return anything.\\n\\nA corrected version of your function could look like this:\\n\\n```python\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        arr = []\\n        for _ in range(len(number)):\\n            if number[_] == digit:\\n                arr.append(int(number[0:_] + number[_+1:]))\\n        return str(max(arr))\\n```\\n\\nThis version of your function removes the `digit` from `number` at every possible position and stores the resulting numbers in `arr`. Then it finds the maximum value in `arr`, converts it to a string and returns it. However, this is not the correct approach to the problem because you\\'re not seeking to create the maximum number by removing a `digit` at every possible position but to create the maximum number by removing a `digit` once. "
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "1st step->Take an arraylist of string\\n2nd step->add the possible string after removal of required character by using substring concertination.   \\n  if(number.charAt(i)==digit){\\n                list.add(number.substring(0,i)+number.substring(i+1));\\n            }\\nstep3->Then sort the arraylist by using Collections.sort(list) method\\nstep4->the last element of the list give the largest number after removal of character."
                    }
                ]
            },
            {
                "id": 1760500,
                "content": [
                    {
                        "username": "anowarul_karim",
                        "content": "just think do you really need to store all the possible answer.  Just think about the next position after matching."
                    },
                    {
                        "username": "ZeynepE",
                        "content": "TIP: Don\\'t try to convert anything to integers or other data types. You can use strings to compare numbers. And although strings are compared based on their ASCII value somehow it works. Wish they gave us this tip in the problem description. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nobody cares bro, low test nigga"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Who with a normal mind would make this testcase: \"299858953917872714814599237991174513476623756395992135212546127959342974628712329595771672911914471\""
                    },
                    {
                        "username": "priyajitmukherjee2008",
                        "content": "public static String removeDigit(String number, char digit) {\n\t\tList<Integer> list = new ArrayList<>();\n\t\tStringBuilder sb =  new StringBuilder(number);\n        for(int i =0; i<number.length(); i++)\n        {\n            if(number.charAt(i)==digit)\n            {\n            \tSystem.out.println(\"matches\");\n            \tlist.add(Integer.parseInt(new StringBuilder(number).deleteCharAt(i).toString()));          \t\n            }\n        }\n        Comparator<Integer> cmp = new Comparator<Integer>() {\n\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tif(o1>o2)\n\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n        \t\n\t\t};\n        list.sort(cmp);\n        return(list.get(list.size()-1)).toString();\n\t}"
                    },
                    {
                        "username": "piyush12345678900",
                        "content": "what is the mistake in my solution\\n\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        arr=[]\\n        number=input()\\n        digit=input()\\n        for _ in range(len(number)):\\n            if number[_]==digit:\\n                arr.append(int(number[0:_:1]+number[_+1::]))\\n        max(arr)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution seems to have a few errors and misunderstandings:\\n\\n1. `number=input()` and `digit=input()`: These lines are unnecessary. The function\\'s arguments `number` and `digit` are already being passed in when the function is called. You should remove these lines.\\n\\n2. `if number[]==digit:`: This line has a syntax error. It seems like you want to iterate over the digits in `number`, but you forgot to include the index inside the brackets.\\n\\n3. `arr.append(int(number[0::1]+number[_+1::]))`: This line will append the integer version of the string `number` without the current digit to `arr`. However, your slicing seems to be off. `number[0::1]` will include all the digits in `number`, and `number[_+1::]` will include all digits after the current one. This would not exclude the current digit from the result.\\n\\n4. `max(arr)`: This line returns the maximum value in `arr`, but it does not convert it back to a string. Also, it\\'s not inside a return statement, so the function does not return anything.\\n\\nA corrected version of your function could look like this:\\n\\n```python\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        arr = []\\n        for _ in range(len(number)):\\n            if number[_] == digit:\\n                arr.append(int(number[0:_] + number[_+1:]))\\n        return str(max(arr))\\n```\\n\\nThis version of your function removes the `digit` from `number` at every possible position and stores the resulting numbers in `arr`. Then it finds the maximum value in `arr`, converts it to a string and returns it. However, this is not the correct approach to the problem because you\\'re not seeking to create the maximum number by removing a `digit` at every possible position but to create the maximum number by removing a `digit` once. "
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "1st step->Take an arraylist of string\\n2nd step->add the possible string after removal of required character by using substring concertination.   \\n  if(number.charAt(i)==digit){\\n                list.add(number.substring(0,i)+number.substring(i+1));\\n            }\\nstep3->Then sort the arraylist by using Collections.sort(list) method\\nstep4->the last element of the list give the largest number after removal of character."
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum White Tiles Covered by a Carpet",
        "question_content": "<p>You are given a 2D integer array <code>tiles</code> where <code>tiles[i] = [l<sub>i</sub>, r<sub>i</sub>]</code> represents that every tile <code>j</code> in the range <code>l<sub>i</sub> &lt;= j &lt;= r<sub>i</sub></code> is colored white.</p>\n\n<p>You are also given an integer <code>carpetLen</code>, the length of a single carpet that can be placed <strong>anywhere</strong>.</p>\n\n<p>Return <em>the <strong>maximum</strong> number of white tiles that can be covered by the carpet</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/25/example1drawio3.png\" style=\"width: 644px; height: 158px;\" />\n<pre>\n<strong>Input:</strong> tiles = [[1,5],[10,11],[12,18],[20,25],[30,32]], carpetLen = 10\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> Place the carpet starting on tile 10. \nIt covers 9 white tiles, so we return 9.\nNote that there may be other places where the carpet covers 9 white tiles.\nIt can be shown that the carpet cannot cover more than 9 white tiles.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/24/example2drawio.png\" style=\"width: 231px; height: 168px;\" />\n<pre>\n<strong>Input:</strong> tiles = [[10,11],[1,1]], carpetLen = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Place the carpet starting on tile 10. \nIt covers 2 white tiles, so we return 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tiles.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>tiles[i].length == 2</code></li>\n\t<li><code>1 &lt;= l<sub>i</sub> &lt;= r<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= carpetLen &lt;= 10<sup>9</sup></code></li>\n\t<li>The <code>tiles</code> are <strong>non-overlapping</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2038534,
                "title": "sliding-window",
                "content": "**Intuition:** it\\'s always better to place a carpet at the beginning of a range. The reason is: if you shift a carpet one tile right, you *might* cover another white tile, but you definitely uncover the previous white tile.\\n \\n\\nSo, we sort tile ranges, and check how many white tiles we can cover, starting from the beginning of each range.\\n\\nTo avoid TLE, we \"drag\" our carpet left-to-right, using the sliding window technique. It\\'s a bit tricky for this problem:\\n1. We track the placement of the carpet in `j` (so the left side is `tiles[j][0]`).\\n2. When we can cover `tiles[i]`, we add those tiles to `cover` and extend the sliding window (`++i`).\\n3. Otherwise, we compute `partial` cover of `tiles[i]` (total cover is `cover + partial`).\\n\\t- We remove `tiles[j]` from `cover`.\\n\\t- We move the carpet to the next tile (`++j`), shrinking the sliding window.\\n\\n![image](https://assets.leetcode.com/users/images/09744dc4-64ab-4519-b400-1af7cdbcfc80_1652551719.1047068.png)\\n\\n**C++**\\n```cpp\\nint maximumWhiteTiles(vector<vector<int>>& t, int len) {\\n    int res = 0, j = 0, cover = 0;\\n    sort(begin(t), end(t));\\n    for (int i = 0; res < len && i < t.size(); )\\n        if (t[j][0] + len > t[i][1]) {\\n            cover += t[i][1] - t[i][0] + 1;\\n            res = max(res, cover);\\n            ++i;\\n        }\\n        else {\\n            int partial = max(0, t[j][0] + len - t[i][0]);\\n            res = max(res, cover + partial);\\n            cover -= (t[j][1] - t[j][0] + 1);\\n            ++j;\\n        }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint maximumWhiteTiles(vector<vector<int>>& t, int len) {\\n    int res = 0, j = 0, cover = 0;\\n    sort(begin(t), end(t));\\n    for (int i = 0; res < len && i < t.size(); )\\n        if (t[j][0] + len > t[i][1]) {\\n            cover += t[i][1] - t[i][0] + 1;\\n            res = max(res, cover);\\n            ++i;\\n        }\\n        else {\\n            int partial = max(0, t[j][0] + len - t[i][0]);\\n            res = max(res, cover + partial);\\n            cover -= (t[j][1] - t[j][0] + 1);\\n            ++j;\\n        }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038177,
                "title": "python-greedy-prefix-sum-binary-search-easy-to-understand-with-explanation",
                "content": "**Explanation:**\\n1. Sort the tiles by the starting position.\\n2. Build the prefix sum array to store the length sum of tiles.\\n3. Traverse each tile, given its starting position s, we know that the furthest position that the carpet can cover to is s+carpetLen-1. Having the furthest position, we binary search the index of the ending tile that the carpet can partially cover. Note that in this step, we greedily align the starting position of the carpet with the starting position of the tile.\\n4. Calculate the length of the ending tile that the carpet cannot partially cover. This is the compensate part that we need to subtract at last.\\n\\n```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        # sort the tiles by the starting position\\n        tiles.sort(key = lambda x:x[0])\\n        # build the starting position array\\n        startPos = [tiles[i][0] for i in range(len(tiles))]\\n        # build the prefix sum array\\n        preSum = [0] * (len(tiles) + 1)\\n        for i in range(1, len(tiles) + 1):\\n            preSum[i] = preSum[i - 1] + (tiles[i-1][1]-tiles[i-1][0] + 1)\\n        \\n        res = 0\\n        for i in range(len(tiles)):\\n            s, e = tiles[i]\\n            # if the length of tile >= length of carpet, return carpetLen\\n            if e >= s + carpetLen - 1:\\n                return carpetLen\\n            # binary search the index of the ending tile that the carpet can partially cover\\n            endIdx = bisect_right(startPos, s + carpetLen - 1) - 1\\n            # calculate the length of the ending tile that the carpet cannot cover \\n            compensate = 0\\n            if tiles[endIdx][1] > s + carpetLen - 1:\\n                compensate = tiles[endIdx][1] - s - carpetLen + 1\\n            # update the result\\n            res = max(res, preSum[endIdx+1] - preSum[i] - compensate)\\n            \\n        return res",
                "solutionTags": [],
                "code": "**Explanation:**\\n1. Sort the tiles by the starting position.\\n2. Build the prefix sum array to store the length sum of tiles.\\n3. Traverse each tile, given its starting position s, we know that the furthest position that the carpet can cover to is s+carpetLen-1. Having the furthest position, we binary search the index of the ending tile that the carpet can partially cover. Note that in this step, we greedily align the starting position of the carpet with the starting position of the tile.\\n4. Calculate the length of the ending tile that the carpet cannot partially cover. This is the compensate part that we need to subtract at last.\\n\\n```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        # sort the tiles by the starting position\\n        tiles.sort(key = lambda x:x[0])\\n        # build the starting position array\\n        startPos = [tiles[i][0] for i in range(len(tiles))]\\n        # build the prefix sum array\\n        preSum = [0] * (len(tiles) + 1)\\n        for i in range(1, len(tiles) + 1):\\n            preSum[i] = preSum[i - 1] + (tiles[i-1][1]-tiles[i-1][0] + 1)\\n        \\n        res = 0\\n        for i in range(len(tiles)):\\n            s, e = tiles[i]\\n            # if the length of tile >= length of carpet, return carpetLen\\n            if e >= s + carpetLen - 1:\\n                return carpetLen\\n            # binary search the index of the ending tile that the carpet can partially cover\\n            endIdx = bisect_right(startPos, s + carpetLen - 1) - 1\\n            # calculate the length of the ending tile that the carpet cannot cover \\n            compensate = 0\\n            if tiles[endIdx][1] > s + carpetLen - 1:\\n                compensate = tiles[endIdx][1] - s - carpetLen + 1\\n            # update the result\\n            res = max(res, preSum[endIdx+1] - preSum[i] - compensate)\\n            \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2038512,
                "title": "c-prefix-sum-binary-search-sorting-simple-and-detailed-explanation",
                "content": "**Logic**\\n1. Sort array to make sequence monotonic increasing order\\n2.  Calculate Prefix sum of white tiles, where prefix sum at ith location denote that (prefix sum till i-1) + Total tiles in ith location.  This will help us to find total white tiles in range [i, j] in O(1) time\\n3.  Store End Location of each tiles in variable name \"et\" as per my code ,Purpose: We will apply binary search on it to find out maximum end location that carpet of length L can cover.\\n4.  Now Run a loop for each tiles, and do following\\n* Take start of carpet location as tiles[i][0]\\n* End location of carpet be start + length of carpet - 1\\n* Now Search maximum end location in tiles that carpet can cover using binary search\\n* Now find total white tiles Presence between ith index as start index And End location as end Index. Using prefix sum array\\n* Update ans with maximum total white tiles\\n\\n \\n```\\nclass Solution {\\n public:\\n  int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n\\n    //Sort tiles by start index , this also gurantee that tiles will also sorted by end index due to non overlapping condition\\n    sort(tiles.begin(), tiles.end());\\n    int n = tiles.size();\\n\\n    // store prefix sum of each tiles , basically pre[i] denote (total white tiles in tiles at index i) + total white tiles before ith tiles.\\n    // et[i] will store end location of ith tiles  \\n    int prefix[n + 1], et[n];\\n\\n    prefix[0] = 0;\\n    for (int i = 0; i < n; i++) {\\n      prefix[i + 1] = prefix[i] + (tiles[i][1] - tiles[i][0] + 1);\\n      et[i] = tiles[i][1];\\n    }\\n\\n    int ans = 0;\\n\\n    //take each tiles[i][0] as start location of carpet and End will be start + carpetLen - 1\\n    // now search total tiles that can be cover in start and end of target\\n    // Basically you need to search end of carpet in et array (store end location of tiles)\\n    // calculate total white tiles in carpet between start index i and end index receive by search, using prefix sum array\\n    for (int i = 0; i < n; i++) {\\n      int start = tiles[i][0];\\n      int end = start + carpetLen - 1;\\n\\n      int indx = upper_bound(et, et + n, end) - et;\\n\\n      // tsum will store number of white tiles covered by carpet between i and indx - 1 ,reason for indx - 1 because we are using upper bound that will always return indx whose value is greater than end.\\n      int tsum = prefix[indx] - prefix[i];\\n\\n      // now add tiles between end and indx covered by carpet\\n      if (indx < n and end >= tiles[indx][0]) tsum += end - tiles[indx][0] + 1;\\n\\n      // update ans with max tiles that can be cover in carpet\\n      ans = max(ans, tsum);\\n\\n    }\\n    return ans;\\n  }\\n};\\n```\\n\\nTime Complexity : O(NlogN) because of sorting.\\nSpace Complexity : O(N) because we used prefix and et array",
                "solutionTags": [
                    "Sorting",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n\\n    //Sort tiles by start index , this also gurantee that tiles will also sorted by end index due to non overlapping condition\\n    sort(tiles.begin(), tiles.end());\\n    int n = tiles.size();\\n\\n    // store prefix sum of each tiles , basically pre[i] denote (total white tiles in tiles at index i) + total white tiles before ith tiles.\\n    // et[i] will store end location of ith tiles  \\n    int prefix[n + 1], et[n];\\n\\n    prefix[0] = 0;\\n    for (int i = 0; i < n; i++) {\\n      prefix[i + 1] = prefix[i] + (tiles[i][1] - tiles[i][0] + 1);\\n      et[i] = tiles[i][1];\\n    }\\n\\n    int ans = 0;\\n\\n    //take each tiles[i][0] as start location of carpet and End will be start + carpetLen - 1\\n    // now search total tiles that can be cover in start and end of target\\n    // Basically you need to search end of carpet in et array (store end location of tiles)\\n    // calculate total white tiles in carpet between start index i and end index receive by search, using prefix sum array\\n    for (int i = 0; i < n; i++) {\\n      int start = tiles[i][0];\\n      int end = start + carpetLen - 1;\\n\\n      int indx = upper_bound(et, et + n, end) - et;\\n\\n      // tsum will store number of white tiles covered by carpet between i and indx - 1 ,reason for indx - 1 because we are using upper bound that will always return indx whose value is greater than end.\\n      int tsum = prefix[indx] - prefix[i];\\n\\n      // now add tiles between end and indx covered by carpet\\n      if (indx < n and end >= tiles[indx][0]) tsum += end - tiles[indx][0] + 1;\\n\\n      // update ans with max tiles that can be cover in carpet\\n      ans = max(ans, tsum);\\n\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038674,
                "title": "python-explanation-with-pictures-sliding-window",
                "content": "Put carpet at the begining `left = T[i][0]` of each range and use prefix sum to find out the covered tiles within `[left, left + carpetlength - 1]`.\\n\\n> **Why we start with begining of each range?**\\n> \\n> Imagine we can reach a maximum covered number **without** starting from a start, that is, the left end of the carpet is either:\\n> - In the middle of a range.\\n> - In the middle of a gap.\\n\\n\\n> - In the first case, we can move the tile to the left, since the left end is already in a range of tiles, thus every move we are \\'adding\\' one covered tile from the left, and reducing **at most** one covered tile from the right. Thus the number of covered tiles is non-decreasing until we reach the start of this range.\\n> - In the second case, we can move the tile to the right, since the left end is already in the gap, thus every move we are \\'reducing\\' 0 covered tile from the left, and adding **at least** covered tile from the right. Thus the number of covered tiles is non-decreasing until we reach the end of this gap.\\n\\n> In either case, we can always find the state where the left end of the carpet matches the start of a range, with equal or larger covered tile.\\n> Thus starting with the begining of each range gives maximum result.\\n\\n\\n![image](https://assets.leetcode.com/users/images/3a399384-dc88-4b16-9073-705ae1c689cc_1652550127.7933428.png)\\n\\nTwo cases, as shown in picture below.\\n- Case 1, if the carpet\\'s **right end** doesn\\'t cover a tile, we can get the sum from `prefix[j] - prefix[i]` array directly.\\n- Case 2, if the carpet\\'s right end covers a tile from `j`-th range, we have to substract the tiles in range `j` that are not covered by the carpet.\\n\\n![image](https://assets.leetcode.com/users/images/44396d78-ced4-4f53-9374-6580e5730462_1652550132.4202952.png)\\n\\n\\n```\\ndef maximumWhiteTiles(self, T: List[List[int]], clen: int) -> int:\\n        T.sort()\\n        pref = [0] + list(itertools.accumulate(r - l + 1 for l, r in T))\\n        ends = [r for _, r in T]\\n        \\n        n = len(ends)\\n        j, ans = 0, 0\\n        \\n        for i in range(n):\\n            l, _ = T[i]                        # Carpet starts from the begining of each range\\n            r = min(ends[-1], l + clen - 1)    # The rightmost index having tile is ends[-1]\\n\\n            while j < n and ends[j] < r:       # While the WHOLE current range is covered by carpet\\n                j += 1\\n            \\n            # Two cases: \\n            if T[j][0] > r:    # If the right end of the carpet doesn\\'t reach the j-th range.\\n                ans = max(ans, pref[j] - pref[i])\\n            else:              # If the right end of the carpet covers part of the j-th range.\\n                ans = max(ans, pref[j + 1] - pref[i] - ends[j] + r)\\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef maximumWhiteTiles(self, T: List[List[int]], clen: int) -> int:\\n        T.sort()\\n        pref = [0] + list(itertools.accumulate(r - l + 1 for l, r in T))\\n        ends = [r for _, r in T]\\n        \\n        n = len(ends)\\n        j, ans = 0, 0\\n        \\n        for i in range(n):\\n            l, _ = T[i]                        # Carpet starts from the begining of each range\\n            r = min(ends[-1], l + clen - 1)    # The rightmost index having tile is ends[-1]\\n\\n            while j < n and ends[j] < r:       # While the WHOLE current range is covered by carpet\\n                j += 1\\n            \\n            # Two cases: \\n            if T[j][0] > r:    # If the right end of the carpet doesn\\'t reach the j-th range.\\n                ans = max(ans, pref[j] - pref[i])\\n            else:              # If the right end of the carpet covers part of the j-th range.\\n                ans = max(ans, pref[j + 1] - pref[i] - ends[j] + r)\\n            \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2038116,
                "title": "easy-c-code-binary-search",
                "content": "Explaination:\\n1) sort the tiles array according to the first element.\\n2) building prefix array to find number of tiles in a certain range.\\n3) apply binary search to find the end point of the carpet starting at index i.\\n4) find the number of tiles from index i and end point of the carpet found in step 3 and update the ans variable.\\n\\n\\n```\\nint maximumWhiteTiles(vector<vector<int>>& tiles, int k) {\\n        sort(tiles.begin(),tiles.end());\\n        int n = tiles.size();\\n        \\n        // prefix array to find the number of tiles in a certain range in constant time.\\n        vector<int> pre(n,0);\\n        pre[0]=tiles[0][1]-tiles[0][0]+1;       \\n        for(int i=1;i<n;i++){\\n            pre[i] = pre[i-1] + tiles[i][1]-tiles[i][0]+1;\\n        }\\n        \\n        // using another array to apply binary search upon.     \\n        vector<int> tile;\\n        for(auto &i : tiles)tile.push_back(i[0]);\\n        \\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            // binary search to find the index where the carpet ends starting from index i.\\n            auto it = lower_bound(tile.begin(),tile.end(),k+tiles[i][0]); \\n            if(it==tile.end() or (*it)>k+tiles[i][0])\\n                --it;\\n            \\n            // adding the intervals which are completely covered by carpet.          \\n            int temp = (it-tile.begin()-1>=0 ? pre[it-tile.begin()-1] : 0)-(i-1>=0 ? pre[i-1] : 0);\\n            \\n            // adding the last interval which may or may not completely be covered by the carpet.\\n            if(it!=tile.end() and (k+tiles[i][0])>=(*it))\\n                temp+=min(k+tiles[i][0]-(*it),pre[it-tile.begin()]-(it-tile.begin()-1>=0 ? pre[it-tile.begin()-1] : 0));\\n            \\n            // updating our ans variable            \\n            ans = max(ans,temp);\\n        }\\n        return ans;\\n    }\\n\\t",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "Explaination:\\n1) sort the tiles array according to the first element.\\n2) building prefix array to find number of tiles in a certain range.\\n3) apply binary search to find the end point of the carpet starting at index i.\\n4) find the number of tiles from index i and end point of the carpet found in step 3 and update the ans variable.\\n\\n\\n```\\nint maximumWhiteTiles(vector<vector<int>>& tiles, int k) {\\n        sort(tiles.begin(),tiles.end());\\n        int n = tiles.size();\\n        \\n        // prefix array to find the number of tiles in a certain range in constant time.\\n        vector<int> pre(n,0);\\n        pre[0]=tiles[0][1]-tiles[0][0]+1;       \\n        for(int i=1;i<n;i++){\\n            pre[i] = pre[i-1] + tiles[i][1]-tiles[i][0]+1;\\n        }\\n        \\n        // using another array to apply binary search upon.     \\n        vector<int> tile;\\n        for(auto &i : tiles)tile.push_back(i[0]);\\n        \\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            // binary search to find the index where the carpet ends starting from index i.\\n            auto it = lower_bound(tile.begin(),tile.end(),k+tiles[i][0]); \\n            if(it==tile.end() or (*it)>k+tiles[i][0])\\n                --it;\\n            \\n            // adding the intervals which are completely covered by carpet.          \\n            int temp = (it-tile.begin()-1>=0 ? pre[it-tile.begin()-1] : 0)-(i-1>=0 ? pre[i-1] : 0);\\n            \\n            // adding the last interval which may or may not completely be covered by the carpet.\\n            if(it!=tile.end() and (k+tiles[i][0])>=(*it))\\n                temp+=min(k+tiles[i][0]-(*it),pre[it-tile.begin()]-(it-tile.begin()-1>=0 ? pre[it-tile.begin()-1] : 0));\\n            \\n            // updating our ans variable            \\n            ans = max(ans,temp);\\n        }\\n        return ans;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2038434,
                "title": "binary-search-considering-start-value-o-nlogn",
                "content": "```\\nclass Solution {\\n\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        Arrays.sort(tiles, (a, b) -> a[0] - b[0]); // sort on basis of start\\n        int n = tiles.length;\\n        int pref[] = new int[n];\\n        pref[0] = tiles[0][1] - tiles[0][0] + 1;\\n        for (int i = 1; i < n; i++) {\\n            pref[i] = pref[i - 1] + (tiles[i][1] - tiles[i][0] + 1); // prefix of white tiles\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < tiles.length; i++) {\\n            int s = i, e = n - 1;\\n            int req = tiles[i][0] + carpetLen - 1; // max expansion from current start \\n            int pos = i;\\n\\t\\t\\t//binary search to find req lies on which less than equal to range.\\n            while (s <= e) {\\n                int mid = s + (e - s) / 2;\\n                if (tiles[mid][0] > req) {\\n                    e = mid - 1;\\n                } else {\\n                    pos = mid;\\n                    s = mid + 1;\\n                }\\n            }\\n\\t\\t\\t// if ending of that last possible tile range is greater than maximum possible expansion\\n\\t\\t\\t// then cover only the required white tiles\\n            int ex = (tiles[pos][1] >= req) ? (req - tiles[pos][0] + 1) : (tiles[pos][1] - tiles[pos][0] + 1); \\n\\t\\t\\t// all mid tiles will get covered anyhow \\n            int sum = (pos - 1 >= 0 ? pref[pos - 1] : 0) - (i - 1 >= 0 ? pref[i - 1] : 0) + ex;\\n            ans = Math.max(ans, sum);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        Arrays.sort(tiles, (a, b) -> a[0] - b[0]); // sort on basis of start\\n        int n = tiles.length;\\n        int pref[] = new int[n];\\n        pref[0] = tiles[0][1] - tiles[0][0] + 1;\\n        for (int i = 1; i < n; i++) {\\n            pref[i] = pref[i - 1] + (tiles[i][1] - tiles[i][0] + 1); // prefix of white tiles\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < tiles.length; i++) {\\n            int s = i, e = n - 1;\\n            int req = tiles[i][0] + carpetLen - 1; // max expansion from current start \\n            int pos = i;\\n\\t\\t\\t//binary search to find req lies on which less than equal to range.\\n            while (s <= e) {\\n                int mid = s + (e - s) / 2;\\n                if (tiles[mid][0] > req) {\\n                    e = mid - 1;\\n                } else {\\n                    pos = mid;\\n                    s = mid + 1;\\n                }\\n            }\\n\\t\\t\\t// if ending of that last possible tile range is greater than maximum possible expansion\\n\\t\\t\\t// then cover only the required white tiles\\n            int ex = (tiles[pos][1] >= req) ? (req - tiles[pos][0] + 1) : (tiles[pos][1] - tiles[pos][0] + 1); \\n\\t\\t\\t// all mid tiles will get covered anyhow \\n            int sum = (pos - 1 >= 0 ? pref[pos - 1] : 0) - (i - 1 >= 0 ? pref[i - 1] : 0) + ex;\\n            ans = Math.max(ans, sum);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038223,
                "title": "python-one-pass-with-greedy-window-o-nlogn-simple-code",
                "content": "Note that the optimal carpet cover occurs when the left end of the carpet coincides with the left end of an interval\\n```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort()\\n\\t\\t#j: window index\\n        j = cover = res = 0\\n        for i in range(len(tiles)):\\n\\t\\t\\t#slide the window as far as we can to cover fully the intervals with the carpet\\n            while j<len(tiles) and tiles[j][1]-tiles[i][0] + 1 <= carpetLen:\\n                cover += tiles[j][1]-tiles[j][0] + 1\\n                j += 1\\n\\t\\t\\t#process the remnant, that is, when the tiles[j] is covered by the carpet partially(not fully)\\n            if j<len(tiles) and tiles[j][0]-tiles[i][0] + 1 <= carpetLen:\\n                res = max(res, cover + carpetLen-(tiles[j][0]-tiles[i][0]))\\n            else:\\n                res = max(res, cover)\\n            #when the tiles[j] is covered partially, the interval is not added to the variable cover\\n\\t\\t\\tif i!=j:\\n                cover -= tiles[i][1]-tiles[i][0]+1\\n\\t\\t\\tj = max(j, i+1)\\n        return res",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "Note that the optimal carpet cover occurs when the left end of the carpet coincides with the left end of an interval\\n```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort()\\n\\t\\t#j: window index\\n        j = cover = res = 0\\n        for i in range(len(tiles)):\\n\\t\\t\\t#slide the window as far as we can to cover fully the intervals with the carpet\\n            while j<len(tiles) and tiles[j][1]-tiles[i][0] + 1 <= carpetLen:\\n                cover += tiles[j][1]-tiles[j][0] + 1\\n                j += 1\\n\\t\\t\\t#process the remnant, that is, when the tiles[j] is covered by the carpet partially(not fully)\\n            if j<len(tiles) and tiles[j][0]-tiles[i][0] + 1 <= carpetLen:\\n                res = max(res, cover + carpetLen-(tiles[j][0]-tiles[i][0]))\\n            else:\\n                res = max(res, cover)\\n            #when the tiles[j] is covered partially, the interval is not added to the variable cover\\n\\t\\t\\tif i!=j:\\n                cover -= tiles[i][1]-tiles[i][0]+1\\n\\t\\t\\tj = max(j, i+1)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2039310,
                "title": "python-easy-explained-all-possible-solutions",
                "content": "Let, \\n* `u` = start of a tile,\\n* `v` = end of a tile.\\nThe idea here is to **start from all the start indices one by one**, and look for the number of tiles the carpet can cover in the forward direction (as we are coming from back, we donot need to check the backward direction).\\n\\nThe end_point of a carpet (`length_to_cover`) strating from any point `i`, can be given by `i + carpetLen - 1`.\\n\\n**Important NOTE:** (we will be coming back to this point)\\n* Now, we need to search the farthest tile that the carpet can cover. We have start indices of each tile stored. So, if the `length_to_cover` is smaller than the start index value of the current tile, then **our farthest tile** that the carpet will touch **is the previous tile**. Right? Hence our, `end_indx = indx - 1` (look at the code parallely while reading the explanation).\\n\\nNow, we have considered the tile that (even) touches the carpet (not necessarily covered in the carpet). So, there might be some tile parts/units that the carpet might not cover.\\n\\nThe **left over portion of the tile** (that was not complete covered) can be given by the difference between the extreme end of the corresponding tile and the length that the carpet can cover *(see this only works as all the lengths are cumulative additions)*.\\n\\nNow, we want how many tiles were cover within a particular range (in other words, how many gaps are present in a particular length range). For this, we stored the prefix sum of all the tile lengths, each `tile length = ending position - start position + 1`.\\n\\nNow, as we know how many tiles we can cover within a particular position range, **we can calulate the total amount of tiles covered from current position to end_indx position**. But the prefix sum array starts from a sum of 0, having one extra element than the number of tiles. So, get the sum of tiles in range from i + 1 to end_indx + 1, i.e, `prefix[end_indx + 1] - prefix[i]`. \\n*(Ask in comments if you did not understand why `prefix[i]` and why not `prefix[i-1]`).*\\n\\nNow, we if we subtract the left over tiles units (of the last covered tile =`length_diff`) from this sum of tile units, we get the total number of tiles units, that can be covered in this iteration.\\n\\nBut the final answer should be the max of all.\\n\\nThe full Code is given below: **(TLE, Not Accepted)** Why?? => Read below.\\n```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort()\\n        \\n        prefix, start_indx = [0], []\\n        for i, j in tiles:\\n            start_indx.append(i)\\n            prefix.append(j - i + 1 + prefix[-1])\\n            \\n        ans = 0\\n        for i, elem in enumerate(tiles):\\n            u, v = elem\\n            length_to_cover = u + carpetLen - 1\\n            \\n            if v >= length_to_cover:\\n                return carpetLen\\n            \\n            end_indx = len(start_indx) - 1\\n            for indx, s in enumerate(start_indx):\\n                if s > length_to_cover:\\n                    end_indx = indx - 1\\n                    break\\n            \\n            length_diff = 0\\n            if tiles[end_indx][1] > length_to_cover:\\n                length_diff = tiles[end_indx][1] - length_to_cover\\n            ans = max(ans, prefix[end_indx + 1] - prefix[i] - length_diff)\\n            \\n        return ans\\n```\\nThe above code runs good for fairly large input size (but still not large enough to get accepted).\\n![image](https://assets.leetcode.com/users/images/feac0b51-549d-427a-a754-cec9794a4087_1652573226.6494923.png)\\n\\n**Time and Space Complexity Analysis for the above code:**\\nThe above code runs two nested loops of length \\'n\\' simultaneosly. Hence, **time complexity = O(n^2)**.\\nAnd, **space complexity = O(n)** owing to the two arrays, prefix and start_indx of length \\'n\\'.\\n\\n**Now, Why TLE??** => Look at the Constraints `tiles.length = n = 5 * (10 ^ 4)`.\\nTLE generally occurs If we exceed 10^8, and if we are using Python, you can\\'t even touch 10^8 (forget about exceeding it). Our solution takes` O(n^2) time = O((5 * 10 ^ 4)^2) = O (25 * 10 ^ 8) > O(10 ^ 9)`. Hence, Sure-Shot TLE.\\n\\nThis O(n^2) solution is accepted for faster languages like C++, Java.\\n\\n**Can we do any better?** (to reduce the time complexity) => Yes! Obviously, otherwise what will python users do? Leave the contest??? LOL... \\n\\n***Come back to the Important NOTE*** that I talked about earlier: Here, we were linearly searching the sorted array in O(n) time. Isn\\'t it foolishness? If the array is sorted, we can search using binary search approach in O(log n) time. \\n\\nJust replace the below code by `end_indx = bisect_right(start_indx, length_to_cover) - 1`. which simply means search \"length_to_cover\" in start_indx array using binary searching.\\n```\\n\\t\\t\\tend_indx = len(start_indx) - 1\\n            for indx, s in enumerate(start_indx):\\n                if s > length_to_cover:\\n                    end_indx = indx - 1\\n                    break\\n```\\n\\nWhat is bisect? ==> It is used for binary search in python.\\n**Why bisect_right**? Why not bisect_left? \\n* As the bisect_right() method returns the position on which a new element can be inserted into an already sorted Python list, while maintaining the sorted order. If there are one or more elements present with the same value as the new value then the insertion point is past the right side of the last such element.\\n* **In simple words**, It will find the last occuracnce of the element (if element is present in array) at some index i and return i + 1. If it didn\\'t find the element, it return the immediate next greatest element, which is exactly what we were doing in linear search `if s > length_to_cover`.\\n\\nThe Full (**Optimized**) Code is given below:\\n```\\nclass Solution:\\n    from bisect import bisect_right\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort()\\n        \\n        prefix, start_indx = [0], []\\n        for i, j in tiles:\\n            start_indx.append(i)\\n            prefix.append(j - i + 1 + prefix[-1])\\n            \\n        ans = 0\\n        for i, elem in enumerate(tiles):\\n            u, v = elem\\n            length_to_cover = u + carpetLen - 1\\n            \\n            if v >= length_to_cover:\\n                return carpetLen\\n            \\n\\t\\t\\t# binary search applied here\\n            end_indx = bisect_right(start_indx, length_to_cover) - 1\\n            \\n            length_diff = 0\\n            if tiles[end_indx][1] > length_to_cover:\\n                length_diff = tiles[end_indx][1] - length_to_cover\\n            ans = max(ans, prefix[end_indx + 1] - prefix[i] - length_diff)\\n            \\n        return ans\\n```\\n![image](https://assets.leetcode.com/users/images/05f9cb0d-2bbf-4bec-832b-14b9b443fe6f_1652573525.4135897.png)\\n\\n**Optimized Time Complexity: O(nlogn)** owing to both sorting and loop+binary search (performed sequentially not simultaneously).\\n\\nUpvote, if helpful.",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort()\\n        \\n        prefix, start_indx = [0], []\\n        for i, j in tiles:\\n            start_indx.append(i)\\n            prefix.append(j - i + 1 + prefix[-1])\\n            \\n        ans = 0\\n        for i, elem in enumerate(tiles):\\n            u, v = elem\\n            length_to_cover = u + carpetLen - 1\\n            \\n            if v >= length_to_cover:\\n                return carpetLen\\n            \\n            end_indx = len(start_indx) - 1\\n            for indx, s in enumerate(start_indx):\\n                if s > length_to_cover:\\n                    end_indx = indx - 1\\n                    break\\n            \\n            length_diff = 0\\n            if tiles[end_indx][1] > length_to_cover:\\n                length_diff = tiles[end_indx][1] - length_to_cover\\n            ans = max(ans, prefix[end_indx + 1] - prefix[i] - length_diff)\\n            \\n        return ans\\n```\n```\\n\\t\\t\\tend_indx = len(start_indx) - 1\\n            for indx, s in enumerate(start_indx):\\n                if s > length_to_cover:\\n                    end_indx = indx - 1\\n                    break\\n```\n```\\nclass Solution:\\n    from bisect import bisect_right\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort()\\n        \\n        prefix, start_indx = [0], []\\n        for i, j in tiles:\\n            start_indx.append(i)\\n            prefix.append(j - i + 1 + prefix[-1])\\n            \\n        ans = 0\\n        for i, elem in enumerate(tiles):\\n            u, v = elem\\n            length_to_cover = u + carpetLen - 1\\n            \\n            if v >= length_to_cover:\\n                return carpetLen\\n            \\n\\t\\t\\t# binary search applied here\\n            end_indx = bisect_right(start_indx, length_to_cover) - 1\\n            \\n            length_diff = 0\\n            if tiles[end_indx][1] > length_to_cover:\\n                length_diff = tiles[end_indx][1] - length_to_cover\\n            ans = max(ans, prefix[end_indx + 1] - prefix[i] - length_diff)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038364,
                "title": "c-prefix-sum-binary-search-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        long long n = tiles.size() , ans = INT_MIN;\\n        sort(tiles.begin(),tiles.end());\\n        vector<long long> len(n) , li(n);\\n\\t\\t//len array stores the prefix sum of tiles\\n\\t\\t//li array stores the last index tiles[i]\\n        for(int i=0;i<n;i++){\\n            len[i] = (long long)(tiles[i][1] - tiles[i][0] + 1);\\n            len[i]+=(i==0) ? 0 : len[i-1];\\n            li[i] = tiles[i][1];\\n        }\\n        \\n        for(int i=0 ; i<n ; i++){\\n\\t\\t   //sp means starting tile index\\n\\t\\t   //ep means ending tile index\\n            long long sp = tiles[i][0] , ep = tiles[i][0] + (long long)carpetLen-1 , tc=0;\\n            int idx = lower_bound(li.begin(),li.end(),ep) - li.begin();\\n\\t\\t\\t\\n\\t\\t\\t//logic to take count of tiles covered\\n            if(idx==n){\\n                tc = len[n-1];\\n                tc-=(i==0) ? 0 : len[i-1];\\n            }else{\\n                tc = ep<tiles[idx][0] ? 0 : ep - (long long)tiles[idx][0]  + 1;\\n                idx--;\\n                if(idx>=0){\\n                    tc+=len[idx];\\n                    tc-=(i==0) ? 0 : len[i-1];\\n                }\\n            }\\n            ans = max(ans,tc);\\n        }\\n        return (int)ans;\\n    }\\n};\\n```\\nTC - O(nlogN)\\nIn case you like the approach , pls upvote",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        long long n = tiles.size() , ans = INT_MIN;\\n        sort(tiles.begin(),tiles.end());\\n        vector<long long> len(n) , li(n);\\n\\t\\t//len array stores the prefix sum of tiles\\n\\t\\t//li array stores the last index tiles[i]\\n        for(int i=0;i<n;i++){\\n            len[i] = (long long)(tiles[i][1] - tiles[i][0] + 1);\\n            len[i]+=(i==0) ? 0 : len[i-1];\\n            li[i] = tiles[i][1];\\n        }\\n        \\n        for(int i=0 ; i<n ; i++){\\n\\t\\t   //sp means starting tile index\\n\\t\\t   //ep means ending tile index\\n            long long sp = tiles[i][0] , ep = tiles[i][0] + (long long)carpetLen-1 , tc=0;\\n            int idx = lower_bound(li.begin(),li.end(),ep) - li.begin();\\n\\t\\t\\t\\n\\t\\t\\t//logic to take count of tiles covered\\n            if(idx==n){\\n                tc = len[n-1];\\n                tc-=(i==0) ? 0 : len[i-1];\\n            }else{\\n                tc = ep<tiles[idx][0] ? 0 : ep - (long long)tiles[idx][0]  + 1;\\n                idx--;\\n                if(idx>=0){\\n                    tc+=len[idx];\\n                    tc-=(i==0) ? 0 : len[i-1];\\n                }\\n            }\\n            ans = max(ans,tc);\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038241,
                "title": "easy-short-python-with-explanation-and-example",
                "content": "Brute force solution: For the start each tile, continue to iterate to the right until we run out of `carpetLen`. This runs in `O(n^2)`\\n=> Better solution with runtime `O(nlogn)`:\\n- We create a prefix sum array `dp` to store the TOTAL coverage from 0 to the start of each tile\\n- For each tile with start `s`, we binary search the end of the carpet `s + carpetLen` to see which tile on the right would the carpet end belongs to\\n- Finally, knowing the index of the right tile `r`, we subtract the TOTAL coverage of the right tile (memorized in the `dp` array) to the TOTAL coverage of the left tile (memorized in the `dp` array) and any offset (since the end may lie somewhere within the right tile, or on the right hand side of it if the right tile is the last one)\\n- Example:\\nInput: \\n`tiles = [[1,5],[10,11],[12,18],[20,25],[30,32]], carpetLen = 10`\\n=>\\n`starts = [1, 10, 12, 20, 30]`\\n`ends = [5, 11, 18, 25, 32]`\\n`dp = [0, 5, 7, 14, 20, 23]`\\n=> for each iteration:\\n[e, l, r, cover] = \\n[11 0 2 6]\\n[20 1 4 9]\\n[22 2 4 9]\\n[30 3 5 6]\\n[40 4 5 3]\\n=> maxCover = 9\\n```\\ndef maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n\\ttiles.sort()\\n\\tmaxCover = 0\\n\\tstarts, ends = zip(*tiles)\\n\\tdp = [0]*(len(tiles) + 1) # dp: total covered lengths from 0\\n\\tfor i in range(len(tiles)):\\n\\t\\tdp[i+1] = dp[i] + ends[i] - starts[i] + 1 # length of each tile is end - start + 1\\n\\tfor l in range(len(tiles)):\\n\\t\\te = starts[l] + carpetLen\\n\\t\\tr = bisect_right(starts, e)\\n\\t\\tcover = dp[r] - dp[l] - max(0, ends[r-1] - e + 1) # total cover on the right MINUS total cover on the left MINUS offset\\n\\t\\tmaxCover = max(maxCover, cover)\\n\\treturn maxCover \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\ndef maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n\\ttiles.sort()\\n\\tmaxCover = 0\\n\\tstarts, ends = zip(*tiles)\\n\\tdp = [0]*(len(tiles) + 1) # dp: total covered lengths from 0\\n\\tfor i in range(len(tiles)):\\n\\t\\tdp[i+1] = dp[i] + ends[i] - starts[i] + 1 # length of each tile is end - start + 1\\n\\tfor l in range(len(tiles)):\\n\\t\\te = starts[l] + carpetLen\\n\\t\\tr = bisect_right(starts, e)\\n\\t\\tcover = dp[r] - dp[l] - max(0, ends[r-1] - e + 1) # total cover on the right MINUS total cover on the left MINUS offset\\n\\t\\tmaxCover = max(maxCover, cover)\\n\\treturn maxCover \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2038199,
                "title": "java-sorting-sliding-window-o-nlogn",
                "content": "You can prove by contradiiction that we will get maximum overlap when we start the carpet at the start of a tile.\\nOnce we know this then we can put carpet at every tile start and calculate overlap.\\nIdea is that when you move to a tile you do need to recalculate overlap between prevStart to previousEnd, you just need to subtract overlap with previous tile & overlap with new tiles added.\\n```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        Arrays.sort(tiles, Comparator.comparingInt(i -> i[0]));\\n        int rv = 0, overlap = 0, ei = 0, prevEnd = 0;\\n        for (int si = 0; si < tiles.length; si++) {\\n            int st = tiles[si][0], end = st + carpetLen - 1;\\n            if (si > 0) {\\n                overlap -= (Math.min(prevEnd, tiles[si-1][1]) - tiles[si-1][0] + 1);\\n            }\\n            if (ei-1 >= si && tiles[ei-1][1] > prevEnd) {\\n                overlap += (Math.min(end, tiles[ei-1][1]) - prevEnd);\\n            }\\n            \\n            while (ei < tiles.length && tiles[ei][0] <= end) {\\n                overlap += (Math.min(end, tiles[ei][1]) - tiles[ei][0] + 1);\\n                ei++;\\n            }\\n            \\n            prevEnd = end;\\n            rv = Math.max(overlap, rv);\\n        }\\n        return rv;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        Arrays.sort(tiles, Comparator.comparingInt(i -> i[0]));\\n        int rv = 0, overlap = 0, ei = 0, prevEnd = 0;\\n        for (int si = 0; si < tiles.length; si++) {\\n            int st = tiles[si][0], end = st + carpetLen - 1;\\n            if (si > 0) {\\n                overlap -= (Math.min(prevEnd, tiles[si-1][1]) - tiles[si-1][0] + 1);\\n            }\\n            if (ei-1 >= si && tiles[ei-1][1] > prevEnd) {\\n                overlap += (Math.min(end, tiles[ei-1][1]) - prevEnd);\\n            }\\n            \\n            while (ei < tiles.length && tiles[ei][0] <= end) {\\n                overlap += (Math.min(end, tiles[ei][1]) - tiles[ei][0] + 1);\\n                ei++;\\n            }\\n            \\n            prevEnd = end;\\n            rv = Math.max(overlap, rv);\\n        }\\n        return rv;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058588,
                "title": "sliding-window-sort-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& t, int len) {\\n        sort(t.begin(),t.end());\\n        int n=t.size(),s=0,e=0,ans=0,area=0;\\n        for(;e<n && s<n;){\\n            if(t[s][0]+len>t[e][1]){\\n                area+=t[e][1]-t[e][0]+1;\\n                ans=max(ans,area);   \\n                ++e;\\n            }\\n            else{\\n                ans=max(ans,area+max(0,t[s][0]+len-t[e][0]));\\n                area-=(t[s][1]-t[s][0]+1);\\n                ++s;\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& t, int len) {\\n        sort(t.begin(),t.end());\\n        int n=t.size(),s=0,e=0,ans=0,area=0;\\n        for(;e<n && s<n;){\\n            if(t[s][0]+len>t[e][1]){\\n                area+=t[e][1]-t[e][0]+1;\\n                ans=max(ans,area);   \\n                ++e;\\n            }\\n            else{\\n                ans=max(ans,area+max(0,t[s][0]+len-t[e][0]));\\n                area-=(t[s][1]-t[s][0]+1);\\n                ++s;\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118443,
                "title": "c-solution-fully-commented-sorting-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(),tiles.end());\\n        int start=0;\\n        int end=0;\\n        int n=tiles.size();\\n        int whites=0;\\n        int ans=0;\\n        while(start<n && end<n){\\n            if(tiles[start][0]+carpetLen > tiles[end][1]){\\n                whites+=tiles[end][1]-tiles[end][0]+1;\\n                ans=max(ans,whites);\\n                end++;\\n            }\\n            else{\\n                int val=whites + max(0,tiles[start][0]+carpetLen-tiles[end][0]);\\n                //it is not neccessary that all white tiles of a particular section should come under the carpet. We can take only those whites that are coming under carpet\\n                //for example if carpet length is 10 and\\n                // (1,5) (10,11)\\n                //   s     e\\n                //now 1+10=11 which is  not gretaer than tiles[e][1]\\n                //so we cannot include both the tiles at 10 and 11 but we can include some tiles from them\\n                //as we can see 1+10 is 11 and tiles[e][0] is 10 which is less than the carpet coverage\\n                //so we will include the 10th tile in our range excluding the 11th one\\n                // val is doing this thing for us\\n                // tiles[start][0]+carpetLen-tiles[end][0] gives the white tiles that can be included in current range\\n                ans=max(ans,val);\\n                whites=whites-(tiles[start][1]-tiles[start][0]+1); //sliding the current window\\n                start++;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(),tiles.end());\\n        int start=0;\\n        int end=0;\\n        int n=tiles.size();\\n        int whites=0;\\n        int ans=0;\\n        while(start<n && end<n){\\n            if(tiles[start][0]+carpetLen > tiles[end][1]){\\n                whites+=tiles[end][1]-tiles[end][0]+1;\\n                ans=max(ans,whites);\\n                end++;\\n            }\\n            else{\\n                int val=whites + max(0,tiles[start][0]+carpetLen-tiles[end][0]);\\n                //it is not neccessary that all white tiles of a particular section should come under the carpet. We can take only those whites that are coming under carpet\\n                //for example if carpet length is 10 and\\n                // (1,5) (10,11)\\n                //   s     e\\n                //now 1+10=11 which is  not gretaer than tiles[e][1]\\n                //so we cannot include both the tiles at 10 and 11 but we can include some tiles from them\\n                //as we can see 1+10 is 11 and tiles[e][0] is 10 which is less than the carpet coverage\\n                //so we will include the 10th tile in our range excluding the 11th one\\n                // val is doing this thing for us\\n                // tiles[start][0]+carpetLen-tiles[end][0] gives the white tiles that can be included in current range\\n                ans=max(ans,val);\\n                whites=whites-(tiles[start][1]-tiles[start][0]+1); //sliding the current window\\n                start++;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038127,
                "title": "java-solution-binary-search-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int binary_search( int[][] tiles, int left, int right, int val )\\n    {\\n        int ans = -1;\\n        while( left <= right )\\n        {\\n            int mid = left + (right-left)/2;\\n\\n            if( tiles[mid][0] <= val && tiles[mid][1] >= val )\\n                return mid;\\n            if( tiles[mid][0] > val )\\n                right = mid-1;\\n            else\\n            {\\n                ans =  mid;\\n                left = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        int n = tiles.length;\\n        long[] totalTiles = new long[n];\\n        int ans = 0;\\n\\n        Arrays.sort( tiles, (t1, t2) -> t1[0] - t2[0] );\\n\\n\\t\\t// Prefix sum : which stores the count of white tiles from 0th index to ith index. \\n        for( int i = 0; i < n; i++ )\\n        {\\n            totalTiles[i] = ( i > 0 ? totalTiles[i-1] : 0 ) + tiles[i][1] - tiles[i][0] + 1;\\n        }\\n\\n        for( int i = 0; i < n; i++ )\\n        {\\n            int nextPoint = tiles[i][0] + carpetLen - 1;  // carpent ends at\\n            int index = binary_search( tiles, i, n-1, nextPoint );  // valid index in srted tiles, where \\'nextpoint\\' lies.\\n\\n            int temp = (int) totalTiles[index] - ( i > 0 ? (int) totalTiles[i-1] : 0 );\\n\\n            if( nextPoint < tiles[index][1] )\\n                temp -= ( tiles[index][1] - nextPoint );\\n            ans = Math.max( ans, temp );\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int binary_search( int[][] tiles, int left, int right, int val )\\n    {\\n        int ans = -1;\\n        while( left <= right )\\n        {\\n            int mid = left + (right-left)/2;\\n\\n            if( tiles[mid][0] <= val && tiles[mid][1] >= val )\\n                return mid;\\n            if( tiles[mid][0] > val )\\n                right = mid-1;\\n            else\\n            {\\n                ans =  mid;\\n                left = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        int n = tiles.length;\\n        long[] totalTiles = new long[n];\\n        int ans = 0;\\n\\n        Arrays.sort( tiles, (t1, t2) -> t1[0] - t2[0] );\\n\\n\\t\\t// Prefix sum : which stores the count of white tiles from 0th index to ith index. \\n        for( int i = 0; i < n; i++ )\\n        {\\n            totalTiles[i] = ( i > 0 ? totalTiles[i-1] : 0 ) + tiles[i][1] - tiles[i][0] + 1;\\n        }\\n\\n        for( int i = 0; i < n; i++ )\\n        {\\n            int nextPoint = tiles[i][0] + carpetLen - 1;  // carpent ends at\\n            int index = binary_search( tiles, i, n-1, nextPoint );  // valid index in srted tiles, where \\'nextpoint\\' lies.\\n\\n            int temp = (int) totalTiles[index] - ( i > 0 ? (int) totalTiles[i-1] : 0 );\\n\\n            if( nextPoint < tiles[index][1] )\\n                temp -= ( tiles[index][1] - nextPoint );\\n            ans = Math.max( ans, temp );\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046234,
                "title": "python-prefix-sum-binary-search-with-comments",
                "content": "```\\nimport bisect\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], l: int) -> int:\\n        # Sort based on tile start\\n        tiles.sort(key=lambda t: t[0])\\n\\n        # Build prefix sum\\n        prefix = [0]\\n        for t in tiles:\\n            prefix.append(t[1] - t[0] + 1 + prefix[-1])\\n        \\n        res = 0\\n        for i in range(len(tiles)):\\n            curr = tiles[i]\\n            end = curr[0] + l - 1 # Where the carpet ends if starts from the left side of curr\\n            idx = bisect.bisect_right(tiles, end, key=lambda e: e[0]) - 1  # Idx of the last tile the carpet can cover\\n            if tiles[idx][1] <= end:  # The tile is fully covered\\n                cover = prefix[idx+1] - prefix[i]\\n            else:\\n                cover = (prefix[idx] - prefix[i]) + (end - tiles[idx][0] + 1)  # The tile is partially covered\\n                \\n            res = max(cover, res)\\n            if res == l:\\n                return l  # No need for further searches if all tiles are white\\n\\n        return res  \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nimport bisect\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], l: int) -> int:\\n        # Sort based on tile start\\n        tiles.sort(key=lambda t: t[0])\\n\\n        # Build prefix sum\\n        prefix = [0]\\n        for t in tiles:\\n            prefix.append(t[1] - t[0] + 1 + prefix[-1])\\n        \\n        res = 0\\n        for i in range(len(tiles)):\\n            curr = tiles[i]\\n            end = curr[0] + l - 1 # Where the carpet ends if starts from the left side of curr\\n            idx = bisect.bisect_right(tiles, end, key=lambda e: e[0]) - 1  # Idx of the last tile the carpet can cover\\n            if tiles[idx][1] <= end:  # The tile is fully covered\\n                cover = prefix[idx+1] - prefix[i]\\n            else:\\n                cover = (prefix[idx] - prefix[i]) + (end - tiles[idx][0] + 1)  # The tile is partially covered\\n                \\n            res = max(cover, res)\\n            if res == l:\\n                return l  # No need for further searches if all tiles are white\\n\\n        return res  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038523,
                "title": "simple-greedy-approach-with-two-loops-comments-added-no-prefix-sum-array-binary-search-queues",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        //sort by tile start\\n        sort(tiles.begin(), tiles.end());\\n        \\n        // define endIdx i.e. index for tile chunk where the carpet ends.\\n        int ans = 0, total = 0, endIdx=0;\\n        for(int startIdx = 0;startIdx<tiles.size();startIdx++) {\\n            \\n            //align carpet with start of current tile chunk\\n            int start = tiles[startIdx][0];\\n            \\n            //given carpet length this is how far carpet end can go.\\n            int end = start + carpetLen -1;\\n            \\n            // search on which tile chunk in given array would be the end of carpet.\\n            // note: here for each startIdx we see how far endIdx can go further\\n            // there won\\'t be any case where for a startIdx we will need to move endIdx backwards.\\n            while(endIdx<tiles.size() && tiles[endIdx][1]<end) {\\n                total += tiles[endIdx][1]-tiles[endIdx][0]+1;\\n                endIdx++;\\n            }\\n            \\n            // if we have reached the end of array or carpet ended somwhere between tile chunks.\\n            // then possible answer is total for this startIdx.\\n            if(endIdx==tiles.size() || tiles[endIdx][0] > end) {\\n                ans = max(ans, total);\\n            } else {\\n                // else if we only add tile chunk start to carpet end in our answer.\\n                ans = max(ans, total + (end - tiles[endIdx][0]+1));\\n            }\\n            \\n            //since we move to next startIdx in next iteration, remove tiles from current startIdx\\n            total -= tiles[startIdx][1] - tiles[startIdx][0] + 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        //sort by tile start\\n        sort(tiles.begin(), tiles.end());\\n        \\n        // define endIdx i.e. index for tile chunk where the carpet ends.\\n        int ans = 0, total = 0, endIdx=0;\\n        for(int startIdx = 0;startIdx<tiles.size();startIdx++) {\\n            \\n            //align carpet with start of current tile chunk\\n            int start = tiles[startIdx][0];\\n            \\n            //given carpet length this is how far carpet end can go.\\n            int end = start + carpetLen -1;\\n            \\n            // search on which tile chunk in given array would be the end of carpet.\\n            // note: here for each startIdx we see how far endIdx can go further\\n            // there won\\'t be any case where for a startIdx we will need to move endIdx backwards.\\n            while(endIdx<tiles.size() && tiles[endIdx][1]<end) {\\n                total += tiles[endIdx][1]-tiles[endIdx][0]+1;\\n                endIdx++;\\n            }\\n            \\n            // if we have reached the end of array or carpet ended somwhere between tile chunks.\\n            // then possible answer is total for this startIdx.\\n            if(endIdx==tiles.size() || tiles[endIdx][0] > end) {\\n                ans = max(ans, total);\\n            } else {\\n                // else if we only add tile chunk start to carpet end in our answer.\\n                ans = max(ans, total + (end - tiles[endIdx][0]+1));\\n            }\\n            \\n            //since we move to next startIdx in next iteration, remove tiles from current startIdx\\n            total -= tiles[startIdx][1] - tiles[startIdx][0] + 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228510,
                "title": "sliding-window-time-95-and-space-80-beats-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int l) {\\n        int i = 0, j = 0, ans = 0,cover = 0,n=tiles.size(),p;\\n        sort(tiles.begin(),tiles.end());\\n        for(i = 0; i < n&&ans<l; ){\\n            if(tiles[j][0]+l>tiles[i][1]){\\n                cover += tiles[i][1]-tiles[i][0]+1;\\n                ans = max(ans,cover);\\n                i++;\\n            }else{\\n                p = max(tiles[j][0]+l-tiles[i][0],0);\\n                ans = max(ans,cover+p);\\n                cover -= (tiles[j][1]-tiles[j][0]+1);\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int l) {\\n        int i = 0, j = 0, ans = 0,cover = 0,n=tiles.size(),p;\\n        sort(tiles.begin(),tiles.end());\\n        for(i = 0; i < n&&ans<l; ){\\n            if(tiles[j][0]+l>tiles[i][1]){\\n                cover += tiles[i][1]-tiles[i][0]+1;\\n                ans = max(ans,cover);\\n                i++;\\n            }else{\\n                p = max(tiles[j][0]+l-tiles[i][0],0);\\n                ans = max(ans,cover+p);\\n                cover -= (tiles[j][1]-tiles[j][0]+1);\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048317,
                "title": "c-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>&nums, int len) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>sum(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            sum[i]=nums[i][1]-nums[i][0]+1;\\n            if(i)\\n            {\\n                sum[i]+=sum[i-1];\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int st=nums[i][0];\\n            int ed=nums[i][1];\\n            int req=st+len-1;\\n            int l=i;\\n            int r=n-1;\\n            int index=i;\\n            while(l<=r)\\n            {\\n                int mid=(l+r)/2;\\n                if(nums[mid][0]<=req)\\n                {\\n                    l=mid+1;\\n                    index=mid;\\n                }\\n                else\\n                {\\n                    r=mid-1;\\n                }\\n            }\\n            int tile=sum[index];\\n            if(i)\\n            {\\n                tile-=sum[i-1];\\n            }\\n            if(nums[index][1]>req)\\n            {\\n                tile-=(nums[index][1]-req);\\n            }\\n            ans=max(ans,tile);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>&nums, int len) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>sum(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            sum[i]=nums[i][1]-nums[i][0]+1;\\n            if(i)\\n            {\\n                sum[i]+=sum[i-1];\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int st=nums[i][0];\\n            int ed=nums[i][1];\\n            int req=st+len-1;\\n            int l=i;\\n            int r=n-1;\\n            int index=i;\\n            while(l<=r)\\n            {\\n                int mid=(l+r)/2;\\n                if(nums[mid][0]<=req)\\n                {\\n                    l=mid+1;\\n                    index=mid;\\n                }\\n                else\\n                {\\n                    r=mid-1;\\n                }\\n            }\\n            int tile=sum[index];\\n            if(i)\\n            {\\n                tile-=sum[i-1];\\n            }\\n            if(nums[index][1]>req)\\n            {\\n                tile-=(nums[index][1]-req);\\n            }\\n            ans=max(ans,tile);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038801,
                "title": "java-simple-sliding-window",
                "content": "```\\nclass Solution\\n{\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen)\\n    {\\n        Arrays.sort(tiles,(a,b)->{return a[0]-b[0];});\\n        int x = 0;\\n        int y = 0;\\n        long maxCount = 0;\\n        long count = 0;\\n        \\n        while(y < tiles.length && x <= y)\\n        {\\n            long start = tiles[x][0];\\n            long end = tiles[y][1];\\n            \\n            if(end-start+1 <= carpetLen) \\n            {\\n                count += tiles[y][1] - tiles[y][0]+1;\\n                maxCount = Math.max(maxCount,count);\\n                y++;\\n            }\\n            else \\n            {\\n                long midDist = start+carpetLen-1;\\n                long s = tiles[y][0];\\n                long e = tiles[y][1];\\n                if(midDist <= e && midDist >= s)  maxCount = Math.max(maxCount,count+midDist-s+1);\\n                count -= tiles[x][1] - tiles[x][0] + 1;\\n                x++;\\n            }\\n        }\\n        return (int)maxCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen)\\n    {\\n        Arrays.sort(tiles,(a,b)->{return a[0]-b[0];});\\n        int x = 0;\\n        int y = 0;\\n        long maxCount = 0;\\n        long count = 0;\\n        \\n        while(y < tiles.length && x <= y)\\n        {\\n            long start = tiles[x][0];\\n            long end = tiles[y][1];\\n            \\n            if(end-start+1 <= carpetLen) \\n            {\\n                count += tiles[y][1] - tiles[y][0]+1;\\n                maxCount = Math.max(maxCount,count);\\n                y++;\\n            }\\n            else \\n            {\\n                long midDist = start+carpetLen-1;\\n                long s = tiles[y][0];\\n                long e = tiles[y][1];\\n                if(midDist <= e && midDist >= s)  maxCount = Math.max(maxCount,count+midDist-s+1);\\n                count -= tiles[x][1] - tiles[x][0] + 1;\\n                x++;\\n            }\\n        }\\n        return (int)maxCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038296,
                "title": "binary-search-self-understanding-clean-code",
                "content": "```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int cLen) {\\n        Arrays.sort(tiles,(a,b)->{\\n            if(a[0]!=b[0])\\n                return a[0] - b[0];\\n            else\\n                return a[1] - b[1];\\n        });\\n        \\n        int n = tiles.length;\\n        int[]psum = new int[n];\\n        \\n        int val = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            val += (tiles[i][1] - tiles[i][0] + 1);\\n            psum[i] = val;\\n        }\\n        \\n        int max = 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int st = tiles[i][0];\\n            int find = st + cLen - 1;\\n            int idx = binarySearch(tiles,find);\\n            int sum = (idx-2>=0 && i-1>=0) ? psum[idx-2] - psum[i-1]: 0;\\n            if(idx-2>=0  && i==0)\\n                sum = psum[idx-2];\\n            if(find >= tiles[idx-1][1])\\n                sum+= (tiles[idx-1][1] - tiles[idx-1][0] + 1);\\n            else\\n                sum+= (find - tiles[idx-1][0] + 1);\\n            max = Math.max(max,sum);\\n        }\\n        return max;\\n    }\\n    \\n    public int binarySearch(int[][] tiles, int find)\\n    {\\n        int st = 0;\\n        int end = tiles.length;\\n        while(st<end)\\n        {\\n            int mid = st + (end - st)/2;\\n            if(tiles[mid][0] <= find)\\n                st = mid+1;\\n            else\\n                end = mid;\\n        }\\n        return st;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int cLen) {\\n        Arrays.sort(tiles,(a,b)->{\\n            if(a[0]!=b[0])\\n                return a[0] - b[0];\\n            else\\n                return a[1] - b[1];\\n        });\\n        \\n        int n = tiles.length;\\n        int[]psum = new int[n];\\n        \\n        int val = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            val += (tiles[i][1] - tiles[i][0] + 1);\\n            psum[i] = val;\\n        }\\n        \\n        int max = 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int st = tiles[i][0];\\n            int find = st + cLen - 1;\\n            int idx = binarySearch(tiles,find);\\n            int sum = (idx-2>=0 && i-1>=0) ? psum[idx-2] - psum[i-1]: 0;\\n            if(idx-2>=0  && i==0)\\n                sum = psum[idx-2];\\n            if(find >= tiles[idx-1][1])\\n                sum+= (tiles[idx-1][1] - tiles[idx-1][0] + 1);\\n            else\\n                sum+= (find - tiles[idx-1][0] + 1);\\n            max = Math.max(max,sum);\\n        }\\n        return max;\\n    }\\n    \\n    public int binarySearch(int[][] tiles, int find)\\n    {\\n        int st = 0;\\n        int end = tiles.length;\\n        while(st<end)\\n        {\\n            int mid = st + (end - st)/2;\\n            if(tiles[mid][0] <= find)\\n                st = mid+1;\\n            else\\n                end = mid;\\n        }\\n        return st;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822596,
                "title": "ruby-binary-search-and-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef maximum_white_tiles(tiles, carpet_len)\\n  tiles.sort!\\n\\n  pref = tiles.each_with_object( [0] ) do |(fr, to), ary|\\n    ary << ary[-1] + to - fr + 1\\n  end\\n\\n  ans = 0\\n  tiles.each_with_index do |(fr, to), i|\\n    # Starting at fr, find the idx of the furthest right tiles\\n    idx = tiles.bsearch_index { |x, y| fr + carpet_len <= x } \\n    idx ||= tiles.size\\n    \\n    cur = pref[idx] - pref[i]\\n    # What if the carpet doesn\\'t reach tiles[idx - 1] end?\\n    to_remove = tiles[idx - 1][1] - (fr + carpet_len - 1)\\n    cur -= to_remove if to_remove >= 0\\n\\n    ans = cur if cur > ans\\n  end\\n\\n  ans\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef maximum_white_tiles(tiles, carpet_len)\\n  tiles.sort!\\n\\n  pref = tiles.each_with_object( [0] ) do |(fr, to), ary|\\n    ary << ary[-1] + to - fr + 1\\n  end\\n\\n  ans = 0\\n  tiles.each_with_index do |(fr, to), i|\\n    # Starting at fr, find the idx of the furthest right tiles\\n    idx = tiles.bsearch_index { |x, y| fr + carpet_len <= x } \\n    idx ||= tiles.size\\n    \\n    cur = pref[idx] - pref[i]\\n    # What if the carpet doesn\\'t reach tiles[idx - 1] end?\\n    to_remove = tiles[idx - 1][1] - (fr + carpet_len - 1)\\n    cur -= to_remove if to_remove >= 0\\n\\n    ans = cur if cur > ans\\n  end\\n\\n  ans\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3323807,
                "title": "c-sliding-window-o-nlogn-commented",
                "content": "```c++\\nint maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n    // Sort the input vector of tiles based on their starting position\\n    sort(tiles.begin(), tiles.end());\\n\\n    // Initialize two variables: `got` to keep track of how many white tiles are currently \"in hand\",\\n    // and `res` to keep track of the maximum number of white tiles seen so far\\n    auto got = 0, res = 0;\\n\\n    // Loop through the tiles vector, stopping when `res` is greater than or equal to `carpetLen` or\\n    // when we\\'ve processed all the tiles\\n    for (int i = 0, j = 0; res < carpetLen && i < tiles.size();) {\\n\\n        // Get the start and end position of the current tile being considered\\n        auto start = tiles[i][0], end = tiles[i][1];\\n\\n        // Calculate the position where the carpet ends\\n        auto to = tiles[j][0] + carpetLen;\\n\\n        // If the carpet ends after the current tile, add the entire tile\\'s length to `got`,\\n        // update `res` if needed, and move on to the next tile\\n        if (to > end) {\\n            got += end - start + 1;\\n            res = max(res, got);\\n            i++;\\n        }\\n\\n        // If the carpet ends before the current tile, add the amount of the tile that is covered\\n        // by the carpet to `got`, update `res` if needed, subtract the entire length of the current\\n        // tile from `got`, and move on to the next tile\\n        else {\\n            auto partial = max(0, to - start);\\n            res = max(res, got + partial);\\n            got -= (tiles[j][1] - tiles[j][0] + 1);\\n            j++;\\n        }\\n    }\\n\\n    // Return the maximum number of white tiles seen\\n    return res;\\n}\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nint maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n    // Sort the input vector of tiles based on their starting position\\n    sort(tiles.begin(), tiles.end());\\n\\n    // Initialize two variables: `got` to keep track of how many white tiles are currently \"in hand\",\\n    // and `res` to keep track of the maximum number of white tiles seen so far\\n    auto got = 0, res = 0;\\n\\n    // Loop through the tiles vector, stopping when `res` is greater than or equal to `carpetLen` or\\n    // when we\\'ve processed all the tiles\\n    for (int i = 0, j = 0; res < carpetLen && i < tiles.size();) {\\n\\n        // Get the start and end position of the current tile being considered\\n        auto start = tiles[i][0], end = tiles[i][1];\\n\\n        // Calculate the position where the carpet ends\\n        auto to = tiles[j][0] + carpetLen;\\n\\n        // If the carpet ends after the current tile, add the entire tile\\'s length to `got`,\\n        // update `res` if needed, and move on to the next tile\\n        if (to > end) {\\n            got += end - start + 1;\\n            res = max(res, got);\\n            i++;\\n        }\\n\\n        // If the carpet ends before the current tile, add the amount of the tile that is covered\\n        // by the carpet to `got`, update `res` if needed, subtract the entire length of the current\\n        // tile from `got`, and move on to the next tile\\n        else {\\n            auto partial = max(0, to - start);\\n            res = max(res, got + partial);\\n            got -= (tiles[j][1] - tiles[j][0] + 1);\\n            j++;\\n        }\\n    }\\n\\n    // Return the maximum number of white tiles seen\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2743658,
                "title": "java-solution-using-binary-search-prefix-sum",
                "content": "# Intuition\\nI have to say this is not a straight forward problem using Binary Search. At first, the problem looks like it is a Sliding Window problems. Yet the range of l and r is huge, which make it impossible for a normal sliding window, in which we just increase and decrease the size of the window. \\n\\nTo be able to come up with a Binary Search solution, once need to observe that we always need to start at any tiles[i][0]. I think that is the key to know that we can use Binary Search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        Arrays.sort(tiles, (a, b) ->  a[0] - b[0]);\\n        int n = tiles.length;\\n        int[] prefix = new int[n];\\n        int max = 0;\\n        for(int i = 0; i < n; i++){\\n            prefix[i] = (i > 0 ? prefix[i-1] : 0) + tiles[i][1] - tiles[i][0] + 1;\\n        }\\n        for(int i = 0; i < n; i++){\\n            int start = tiles[i][0];\\n            int end = tiles[i][0] + carpetLen - 1;\\n            //Find the index in which the end will lying in\\n            int index = helper(tiles, end, i, n - 1);\\n            \\n            int sum = prefix[index] - (i > 0 ? prefix[i-1] : 0);\\n            if(end < tiles[index][1]){\\n                sum -= tiles[index][1] - end;\\n            }\\n            max = Math.max(max, sum);\\n        }\\n        return max;\\n    }\\n    public int helper(int[][] tiles, int target, int left, int right){\\n        while(right - left > 1){\\n            int mid = left + (right-left)/2;\\n            //If target is on the left of mid\\n            if(tiles[mid][1] >= target){\\n                right = mid;\\n            }else{ // tiles[mid][1] < target => definitely will be on the right\\n                left = mid;\\n            }\\n        }\\n        // l1 l2 r1 r2\\n        if(tiles[right][0] <= target){\\n            return right;\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        Arrays.sort(tiles, (a, b) ->  a[0] - b[0]);\\n        int n = tiles.length;\\n        int[] prefix = new int[n];\\n        int max = 0;\\n        for(int i = 0; i < n; i++){\\n            prefix[i] = (i > 0 ? prefix[i-1] : 0) + tiles[i][1] - tiles[i][0] + 1;\\n        }\\n        for(int i = 0; i < n; i++){\\n            int start = tiles[i][0];\\n            int end = tiles[i][0] + carpetLen - 1;\\n            //Find the index in which the end will lying in\\n            int index = helper(tiles, end, i, n - 1);\\n            \\n            int sum = prefix[index] - (i > 0 ? prefix[i-1] : 0);\\n            if(end < tiles[index][1]){\\n                sum -= tiles[index][1] - end;\\n            }\\n            max = Math.max(max, sum);\\n        }\\n        return max;\\n    }\\n    public int helper(int[][] tiles, int target, int left, int right){\\n        while(right - left > 1){\\n            int mid = left + (right-left)/2;\\n            //If target is on the left of mid\\n            if(tiles[mid][1] >= target){\\n                right = mid;\\n            }else{ // tiles[mid][1] < target => definitely will be on the right\\n                left = mid;\\n            }\\n        }\\n        // l1 l2 r1 r2\\n        if(tiles[right][0] <= target){\\n            return right;\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421753,
                "title": "java-sliding-window-commented-solution-for-easy-understanding",
                "content": "Approach - Sorted tiles + Sliding window to cover max carpetLen\\n\\n``` //\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        \\n        //Index to keep track of sliding window\\n        int start =0;\\n        int end=0;\\n        \\n        int currentCovered=0; //length covered by current window\\n        int maxCovered=0; //Max across all tiles\\n        \\n\\t\\t//Sort tiles in ascending order\\n        Arrays.sort(tiles,(a,b)->(a[0]-b[0]));\\n        \\n        while(start<=end && end < tiles.length){\\n\\t\\t\\n            int[] endTile = tiles[end];\\n            int[] startTile = tiles[start];\\n            \\n            //Check when picking end tile, if start to end is within carpetLen\\n            int currentWindowSize = endTile[1]-startTile[0]+1;\\n            if(currentWindowSize<=carpetLen){\\n                //Since its within carpetLen include end tile, and update end\\n               \\n\\t\\t\\t   int endTileLen = endTile[1]-endTile[0]+1;\\n                currentCovered= currentCovered+endTileLen;\\n                maxCovered = Math.max(maxCovered, currentCovered);\\n                end++;\\n            }else{\\n                //if it exceeds the carpetLen, then we can only cover partially, calculate partial value of end that can be covered\\n\\t\\t\\t\\t//eg: start[0,5] end[6,10] with carpetLen 7, when picking end we need to pick [0,5] + [6,7] ie partially\\n                \\n\\t\\t\\t\\tint endTilePartial = startTile[0] + carpetLen - endTile[0];\\n                maxCovered = Math.max(maxCovered, currentCovered+endTilePartial);\\n                \\n                //currentCovered+=endTilePartial; \\n                //Note - Do not add partial to currentCovered, endTile will be completely picked in the next iteration once start is removed\\n                \\n                //remove start so we can keep extending end\\n                int startTileLen = startTile[1]-startTile[0]+1;\\n                currentCovered-= startTileLen;\\n                start++;                \\n            } \\n        }\\n        return maxCovered;        \\n    }",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "Approach - Sorted tiles + Sliding window to cover max carpetLen\\n\\n``` //\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        \\n        //Index to keep track of sliding window\\n        int start =0;\\n        int end=0;\\n        \\n        int currentCovered=0; //length covered by current window\\n        int maxCovered=0; //Max across all tiles\\n        \\n\\t\\t//Sort tiles in ascending order\\n        Arrays.sort(tiles,(a,b)->(a[0]-b[0]));\\n        \\n        while(start<=end && end < tiles.length){\\n\\t\\t\\n            int[] endTile = tiles[end];\\n            int[] startTile = tiles[start];\\n            \\n            //Check when picking end tile, if start to end is within carpetLen\\n            int currentWindowSize = endTile[1]-startTile[0]+1;\\n            if(currentWindowSize<=carpetLen){\\n                //Since its within carpetLen include end tile, and update end\\n               \\n\\t\\t\\t   int endTileLen = endTile[1]-endTile[0]+1;\\n                currentCovered= currentCovered+endTileLen;\\n                maxCovered = Math.max(maxCovered, currentCovered);\\n                end++;\\n            }else{\\n                //if it exceeds the carpetLen, then we can only cover partially, calculate partial value of end that can be covered\\n\\t\\t\\t\\t//eg: start[0,5] end[6,10] with carpetLen 7, when picking end we need to pick [0,5] + [6,7] ie partially\\n                \\n\\t\\t\\t\\tint endTilePartial = startTile[0] + carpetLen - endTile[0];\\n                maxCovered = Math.max(maxCovered, currentCovered+endTilePartial);\\n                \\n                //currentCovered+=endTilePartial; \\n                //Note - Do not add partial to currentCovered, endTile will be completely picked in the next iteration once start is removed\\n                \\n                //remove start so we can keep extending end\\n                int startTileLen = startTile[1]-startTile[0]+1;\\n                currentCovered-= startTileLen;\\n                start++;                \\n            } \\n        }\\n        return maxCovered;        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2094644,
                "title": "c-easyto-understand-sorting-prefix-sum-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(),tiles.end());\\n        int n=tiles.size();\\n        vector<int> prefix(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            prefix[i]=tiles[i][1]-tiles[i][0]+1;\\n            if(i>0)\\n            {\\n                prefix[i]+=prefix[i-1];\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int leftEnd=tiles[i][0];\\n            int rightEnd=tiles[i][0]+carpetLen-1;\\n            int l=i,r=n-1,left=i,right=i-1;\\n            int curr=0;\\n            while(l<=r)\\n            {\\n                int mid=(l+r)/2;\\n                if(tiles[mid][1]<=rightEnd)\\n                {\\n                    right=mid;\\n                    l=mid+1;\\n                }\\n                else\\n                {\\n                    r=mid-1;\\n                }\\n            }\\n            if(right!=i-1)\\n            {\\n                curr+=prefix[right];\\n                if(left>0)\\n                curr-=prefix[left-1];\\n            }\\n            if(right+1<n)\\n            {\\n                curr+=max(0,rightEnd-tiles[right+1][0]+1);\\n            }\\n            ans=max(ans,curr);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(),tiles.end());\\n        int n=tiles.size();\\n        vector<int> prefix(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            prefix[i]=tiles[i][1]-tiles[i][0]+1;\\n            if(i>0)\\n            {\\n                prefix[i]+=prefix[i-1];\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int leftEnd=tiles[i][0];\\n            int rightEnd=tiles[i][0]+carpetLen-1;\\n            int l=i,r=n-1,left=i,right=i-1;\\n            int curr=0;\\n            while(l<=r)\\n            {\\n                int mid=(l+r)/2;\\n                if(tiles[mid][1]<=rightEnd)\\n                {\\n                    right=mid;\\n                    l=mid+1;\\n                }\\n                else\\n                {\\n                    r=mid-1;\\n                }\\n            }\\n            if(right!=i-1)\\n            {\\n                curr+=prefix[right];\\n                if(left>0)\\n                curr-=prefix[left-1];\\n            }\\n            if(right+1<n)\\n            {\\n                curr+=max(0,rightEnd-tiles[right+1][0]+1);\\n            }\\n            ans=max(ans,curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056094,
                "title": "java-sliding-window",
                "content": "```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int k) {\\n        Arrays.sort(tiles,(a,b)->a[0]-b[0]);\\n        int max=0,cnt=0,l=0;\\n        for(int r=0;r<tiles.length;r++) {\\n            // add all right tiles\\n            cnt+=tiles[r][1]-tiles[r][0]+1;\\n            int len=0;\\n            while(l<tiles.length&&(len=tiles[r][1]-tiles[l][0]+1)>k) {\\n                // keep removing tiles from left side\\n                max=Math.max(max,cnt-len+k);\\n                cnt-=tiles[l][1]-tiles[l][0]+1;\\n                l++;\\n            }\\n            max=Math.max(max,cnt);\\n            if(max==k) return k;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int k) {\\n        Arrays.sort(tiles,(a,b)->a[0]-b[0]);\\n        int max=0,cnt=0,l=0;\\n        for(int r=0;r<tiles.length;r++) {\\n            // add all right tiles\\n            cnt+=tiles[r][1]-tiles[r][0]+1;\\n            int len=0;\\n            while(l<tiles.length&&(len=tiles[r][1]-tiles[l][0]+1)>k) {\\n                // keep removing tiles from left side\\n                max=Math.max(max,cnt-len+k);\\n                cnt-=tiles[l][1]-tiles[l][0]+1;\\n                l++;\\n            }\\n            max=Math.max(max,cnt);\\n            if(max==k) return k;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050875,
                "title": "simple-explanation-with-comments",
                "content": "**Intutuion:** just put carpet on the starting of every tile range and count how many tiles we can cover.\\n \\n##### \\t\\t why we are not trying to put carpet in between any tile range \\n\\t\\n\\t\\t\\t1. Consider A window if your slide it by 2 to right side you may cover 2 more tile  but you will lose front 2 tiles resulting the same answer.\\n\\t\\t\\t2. Looking at the time constraints,is it feasible to check for each and every value in the tile range??\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int n;\\n\\t/*\\n\\tbinarySearch function will return the last position\\n\\tin the array before our carpet ends.\\n\\ti.e. arr={{1,5},{10,12},{20,25}} carpetLen=15\\n\\tif we apply binary search at index 0 we will get index 1.\\n\\t\\n\\t*/\\n    int binarySearch(vector<vector<int>>& arr,ll key)\\n    {\\n        int l=0;\\n        int h=n-1;\\n        int ret=-1;\\n        while(l<=h)\\n        {\\n            int mid=(l+h)>>1;\\n            if(arr[mid][0]<=key)\\n            {\\n                ret=mid;\\n                l=mid+1;\\n            }\\n            else\\n                h=mid-1;\\n        }\\n        return ret;\\n    }\\n    int maximumWhiteTiles(vector<vector<int>>& arr, int clen) {\\n        sort(arr.begin(),arr.end());\\n        n=arr.size();\\n        ll sum=0;\\n        vector<ll> presum;\\n\\t\\t/* we will use prefix sum array to determine how many elements between \\n\\t\\t   our carpet.\\n\\t\\t*/\\n        for(auto x:arr)\\n        {\\n            sum+=(x[1]-x[0]+1);\\n            presum.push_back(sum);\\n        }\\n        int ans=0;\\n\\t\\t\\n\\t\\t/* Now we will check how many tiles we can cover by placing the carpet\\n\\t\\ton the first tile of every tile range.\\n\\t\\t\\n\\t\\tNow to get the position of the last element from the end of carpet we will \\n\\t\\tuse binaraySearch function.now there can be 3 possible location where \\n\\t\\tour carpet can land.\\n\\t\\t\\n\\t\\t\\t1. Inside current tile range,i.e. current range is {1,100} and carpet \\n\\t\\t\\t   lenght is  20.\\n\\t\\t\\t2. Inside in another tile range , i.e. current range is {1,5} ,\\n\\t\\t\\t    arr={{1,5},{10,12},{20,25}} carpetLen=11\\n\\t\\t\\t3. Between two tile range or  after all the tile ranges.\\t\\t\\t   \\n\\t\\t\\t\\t   \\n\\t\\t*/\\n         for(int i=0;i<n;i++)\\n        {\\n            int start=arr[i][0];\\n            int end=arr[i][1];\\n          \\n                ll last=start+clen-1; //will denote where our carpet lands\\n                int pos=binarySearch(arr,last); //will get the last tile range before the end of carpet\\n                ll temp=(presum[pos]-presum[i]); //here we calculate how many tiles are there b/w the last position before our carpet lands and the begginng of the carpet\\n                   temp+=(min(last,(ll)end)-start+1); // now we will add the tiles of the current tile range,we have taken min(last,(ll)end) since carpet can land inside our tile range, as discussed above\\n\\t\\t\\t\\t   /*\\n\\t\\t\\t\\t   Now if carpet lands inside some other range,\\n\\t\\t\\t\\t   we need to subtract the remaining tiles from the end\\n\\t\\t\\t\\t   of that tile to the position where our carpet landed.\\n\\t\\t\\t\\t   */\\n                   if(pos!=i && last<arr[pos][1]) \\n                       temp-=(arr[pos][1]-last);\\n                ans=max((ll)ans,temp);                \\n            }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Time Complexity:** *O(NlogN)*\\n**Space Complexity:** *O(N)*\\n\\n**Feel free to comment any doubt or mistake.**\\n**If you reached here please considering upvote**",
                "solutionTags": [
                    "Array",
                    "Greedy",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int n;\\n\\t/*\\n\\tbinarySearch function will return the last position\\n\\tin the array before our carpet ends.\\n\\ti.e. arr={{1,5},{10,12},{20,25}} carpetLen=15\\n\\tif we apply binary search at index 0 we will get index 1.\\n\\t\\n\\t*/\\n    int binarySearch(vector<vector<int>>& arr,ll key)\\n    {\\n        int l=0;\\n        int h=n-1;\\n        int ret=-1;\\n        while(l<=h)\\n        {\\n            int mid=(l+h)>>1;\\n            if(arr[mid][0]<=key)\\n            {\\n                ret=mid;\\n                l=mid+1;\\n            }\\n            else\\n                h=mid-1;\\n        }\\n        return ret;\\n    }\\n    int maximumWhiteTiles(vector<vector<int>>& arr, int clen) {\\n        sort(arr.begin(),arr.end());\\n        n=arr.size();\\n        ll sum=0;\\n        vector<ll> presum;\\n\\t\\t/* we will use prefix sum array to determine how many elements between \\n\\t\\t   our carpet.\\n\\t\\t*/\\n        for(auto x:arr)\\n        {\\n            sum+=(x[1]-x[0]+1);\\n            presum.push_back(sum);\\n        }\\n        int ans=0;\\n\\t\\t\\n\\t\\t/* Now we will check how many tiles we can cover by placing the carpet\\n\\t\\ton the first tile of every tile range.\\n\\t\\t\\n\\t\\tNow to get the position of the last element from the end of carpet we will \\n\\t\\tuse binaraySearch function.now there can be 3 possible location where \\n\\t\\tour carpet can land.\\n\\t\\t\\n\\t\\t\\t1. Inside current tile range,i.e. current range is {1,100} and carpet \\n\\t\\t\\t   lenght is  20.\\n\\t\\t\\t2. Inside in another tile range , i.e. current range is {1,5} ,\\n\\t\\t\\t    arr={{1,5},{10,12},{20,25}} carpetLen=11\\n\\t\\t\\t3. Between two tile range or  after all the tile ranges.\\t\\t\\t   \\n\\t\\t\\t\\t   \\n\\t\\t*/\\n         for(int i=0;i<n;i++)\\n        {\\n            int start=arr[i][0];\\n            int end=arr[i][1];\\n          \\n                ll last=start+clen-1; //will denote where our carpet lands\\n                int pos=binarySearch(arr,last); //will get the last tile range before the end of carpet\\n                ll temp=(presum[pos]-presum[i]); //here we calculate how many tiles are there b/w the last position before our carpet lands and the begginng of the carpet\\n                   temp+=(min(last,(ll)end)-start+1); // now we will add the tiles of the current tile range,we have taken min(last,(ll)end) since carpet can land inside our tile range, as discussed above\\n\\t\\t\\t\\t   /*\\n\\t\\t\\t\\t   Now if carpet lands inside some other range,\\n\\t\\t\\t\\t   we need to subtract the remaining tiles from the end\\n\\t\\t\\t\\t   of that tile to the position where our carpet landed.\\n\\t\\t\\t\\t   */\\n                   if(pos!=i && last<arr[pos][1]) \\n                       temp-=(arr[pos][1]-last);\\n                ans=max((ll)ans,temp);                \\n            }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044664,
                "title": "java-time-o-nlogn-space-o-1-sorting-sliding-window",
                "content": "```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int len) {\\n        int result = 0, start = 0, covered = 0;\\n        Arrays.sort(tiles,(a,b)->(a[0]-b[0]));\\n        \\n        for(int end = 0; result<len&&end<tiles.length;){\\n            if(tiles[start][0]+len>tiles[end][1]){\\n                covered += Math.min(len, tiles[end][1] - tiles[end][0] + 1);\\n                result = Math.max(result,covered);\\n                end++;\\n            }else{\\n                int partial = Math.max(0,tiles[start][0] + len - tiles[end][0]);\\n                result = Math.max(result,covered+partial);\\n                covered -= (tiles[start][1]-tiles[start][0]+1);\\n                start++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int len) {\\n        int result = 0, start = 0, covered = 0;\\n        Arrays.sort(tiles,(a,b)->(a[0]-b[0]));\\n        \\n        for(int end = 0; result<len&&end<tiles.length;){\\n            if(tiles[start][0]+len>tiles[end][1]){\\n                covered += Math.min(len, tiles[end][1] - tiles[end][0] + 1);\\n                result = Math.max(result,covered);\\n                end++;\\n            }else{\\n                int partial = Math.max(0,tiles[start][0] + len - tiles[end][0]);\\n                result = Math.max(result,covered+partial);\\n                covered -= (tiles[start][1]-tiles[start][0]+1);\\n                start++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044395,
                "title": "c-sliding-window-solution",
                "content": "Runtime: 422 ms, faster than 50.00% of C++ online submissions for Maximum White Tiles Covered by a Carpet.\\nMemory Usage: 69.6 MB, less than 100.00% of C++ online submissions for Maximum White Tiles Covered by a Carpet.\\n\\n\\n```\\n1. Sort the tiles array\\n2. Check how many tiles are covered by carpet length when start from each tile interval.\\n3. Use sliding window of carpet length to calculate the covered tiles.\\n4. Checking tile cover from start of each tile interval is optimal cause if we ignore the start white tile then\\nwe might get a white tile at the end which is of another tile interval but we always miss a white tile at start.\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        \\n\\t\\t// base case \\n        if(carpetLen==1) return 1;\\n        \\n        // sort tile intervals\\n        sort(tiles.begin(),tiles.end());\\n\\n        int tileSize = tiles.size();\\n\\n        // max tiles covered by carpet\\n        int maxCovered = 0;\\n        \\n        // total length of current window\\n        int totalLen = 0;\\n        \\n        // current tile interval length\\n        int tileLen = 0;\\n        \\n        // total tiles covered in current window \\n        int coveredTile = 0;\\n        \\n        // extra tile to be added from current tile interval\\n        int extraTile;\\n                \\n        // start index of tile intervals in current window\\n        int startIndex = 0;\\n        \\n        // loop until all tile intervals are checked or maxCovered < carpetLen\\n        for(int currentIndex=0;currentIndex<tileSize && maxCovered < carpetLen;currentIndex++)\\n        {\\n            // get the current tile interval length\\n            tileLen = tiles[currentIndex][1] - tiles[currentIndex][0] + 1;\\n                \\n            // check if current window length + tileLen >= carpet length\\n            // if then we have to calculate number of tiles covered with in carpet length\\n            while(totalLen + tileLen >= carpetLen && startIndex<=currentIndex && maxCovered < carpetLen)\\n            {\\n                // current window length >= carpet length then there is no more tile\\n                // to be add from current tile interval and so extra tile will be 0\\n                // otherwise we add the carpet length - current window length extra tiles\\n                extraTile = totalLen >= carpetLen ? 0 : (carpetLen-totalLen);\\n                \\n                // updated max covered tile with total tiles covered by current window + extra tiles \\n                maxCovered = max(maxCovered,coveredTile+extraTile);\\n                \\n                // as current window length + tileLen > carpet length, we slide our window right and so \\n                // we deduce start index tile interval length from cover tile count and total window length\\n                coveredTile -= (tiles[startIndex][1] - tiles[startIndex][0] + 1);\\n                totalLen -= (tiles[startIndex][1] - tiles[startIndex][0] + 1);\\n                \\n                // also deduce the gap between start tile interval and its next tile interval\\n                totalLen -= startIndex+1 < tileSize ? (tiles[startIndex+1][0] - tiles[startIndex][1] - 1) : 0;\\n                \\n                // increment start tile index and move right\\n                startIndex++;                \\n            }\\n             \\n            // update current window length and covered tile length with tileLen\\n            coveredTile += tileLen;\\n            totalLen += tileLen;\\n            \\n            // also update current window length with gap between current tile interval and next tile interval \\n            totalLen += currentIndex+1 < tileSize ? (tiles[currentIndex+1][0] - tiles[currentIndex][1] - 1) : 0;\\n        }\\n        \\n        // check current window length <= carpet length and then update max covered tile\\n        if(totalLen <= carpetLen)maxCovered = max(coveredTile,maxCovered);\\n        \\n        return maxCovered;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\n1. Sort the tiles array\\n2. Check how many tiles are covered by carpet length when start from each tile interval.\\n3. Use sliding window of carpet length to calculate the covered tiles.\\n4. Checking tile cover from start of each tile interval is optimal cause if we ignore the start white tile then\\nwe might get a white tile at the end which is of another tile interval but we always miss a white tile at start.\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        \\n\\t\\t// base case \\n        if(carpetLen==1) return 1;\\n        \\n        // sort tile intervals\\n        sort(tiles.begin(),tiles.end());\\n\\n        int tileSize = tiles.size();\\n\\n        // max tiles covered by carpet\\n        int maxCovered = 0;\\n        \\n        // total length of current window\\n        int totalLen = 0;\\n        \\n        // current tile interval length\\n        int tileLen = 0;\\n        \\n        // total tiles covered in current window \\n        int coveredTile = 0;\\n        \\n        // extra tile to be added from current tile interval\\n        int extraTile;\\n                \\n        // start index of tile intervals in current window\\n        int startIndex = 0;\\n        \\n        // loop until all tile intervals are checked or maxCovered < carpetLen\\n        for(int currentIndex=0;currentIndex<tileSize && maxCovered < carpetLen;currentIndex++)\\n        {\\n            // get the current tile interval length\\n            tileLen = tiles[currentIndex][1] - tiles[currentIndex][0] + 1;\\n                \\n            // check if current window length + tileLen >= carpet length\\n            // if then we have to calculate number of tiles covered with in carpet length\\n            while(totalLen + tileLen >= carpetLen && startIndex<=currentIndex && maxCovered < carpetLen)\\n            {\\n                // current window length >= carpet length then there is no more tile\\n                // to be add from current tile interval and so extra tile will be 0\\n                // otherwise we add the carpet length - current window length extra tiles\\n                extraTile = totalLen >= carpetLen ? 0 : (carpetLen-totalLen);\\n                \\n                // updated max covered tile with total tiles covered by current window + extra tiles \\n                maxCovered = max(maxCovered,coveredTile+extraTile);\\n                \\n                // as current window length + tileLen > carpet length, we slide our window right and so \\n                // we deduce start index tile interval length from cover tile count and total window length\\n                coveredTile -= (tiles[startIndex][1] - tiles[startIndex][0] + 1);\\n                totalLen -= (tiles[startIndex][1] - tiles[startIndex][0] + 1);\\n                \\n                // also deduce the gap between start tile interval and its next tile interval\\n                totalLen -= startIndex+1 < tileSize ? (tiles[startIndex+1][0] - tiles[startIndex][1] - 1) : 0;\\n                \\n                // increment start tile index and move right\\n                startIndex++;                \\n            }\\n             \\n            // update current window length and covered tile length with tileLen\\n            coveredTile += tileLen;\\n            totalLen += tileLen;\\n            \\n            // also update current window length with gap between current tile interval and next tile interval \\n            totalLen += currentIndex+1 < tileSize ? (tiles[currentIndex+1][0] - tiles[currentIndex][1] - 1) : 0;\\n        }\\n        \\n        // check current window length <= carpet length and then update max covered tile\\n        if(totalLen <= carpetLen)maxCovered = max(coveredTile,maxCovered);\\n        \\n        return maxCovered;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038760,
                "title": "c-fully-commented-solution-prefix-sum-sliding-window-sorting-o-nlogn",
                "content": "1. Sort the tile intervals.\\n2. Calculate count of white tiles between any tile i.e. tile[left] to tile[right] using prefix sum.\\n3. Create windows of appropriate sizes such that the length between starting tile and ending tile less than equal to the carpet length.\\n4. Find the number of tiles which can be covered in each window and if the number is greater than the maximum count so far then update it.\\n\\n```\\nstruct Solution {\\n    \\n    int maximumWhiteTiles(vector<vector<int>>& a, int len) {\\n        \\n        const int n = a.size();\\n        \\n\\t\\t// Adding some elements just to make life easier\\n        a.push_back({0, 0});\\n        sort(a.begin(), a.end());\\n        a.push_back({0x3fffffff, 0x3fffffff});\\n\\t\\t// 0x3fffffff its just a number which greater then 1e9\\n\\t\\t// Can\\'t take INT_MAX because it will overflow on adding with another number\\n        \\n        int s[n+1]; s[0] = 0;\\n        \\n\\t\\t// Preparing prefix sum array\\n        for (int i = 1; i <= n; i++) {\\n            s[i] = s[i-1] + (a[i][1] - a[i][0] + 1);\\n        }\\n        \\n        int i = 1, j = 1, ans = 0;\\n        while (j <= n) {\\n\\t\\t\\n            while (j <= n && a[j][1] - a[i][0] + 1 <= len) ++j; // Finding the upper bound for the current window\\n\\t\\t\\t\\n\\t\\t\\t// s[j-1] - s[i-1] --> number of tiles from i to j-1\\n\\t\\t\\t// len - (a[j][0] - a[i][0]) --> number of some tiles (partially covered titles) which will be covered by the carpet of the next interval\\n\\t\\t\\t// it can be less then 0 thats why take max(0, len - (a[j][0] - a[i][0]))\\n            ans = max(ans, (s[j-1] - s[i-1]) + max(0, len - (a[j][0] - a[i][0])));\\n\\t\\t\\t\\n            ++i; // Shifting the window\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nTime Complexity : O(nLogn) (Sorting) + O(n) (Prefix sum) + O(n) (Sliding Window) --> O(nLogn)\\nSpace Complexity : O(n) (Prefix sum array)\\n\\nThank you! and Sorry for my bad english... :-)",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nstruct Solution {\\n    \\n    int maximumWhiteTiles(vector<vector<int>>& a, int len) {\\n        \\n        const int n = a.size();\\n        \\n\\t\\t// Adding some elements just to make life easier\\n        a.push_back({0, 0});\\n        sort(a.begin(), a.end());\\n        a.push_back({0x3fffffff, 0x3fffffff});\\n\\t\\t// 0x3fffffff its just a number which greater then 1e9\\n\\t\\t// Can\\'t take INT_MAX because it will overflow on adding with another number\\n        \\n        int s[n+1]; s[0] = 0;\\n        \\n\\t\\t// Preparing prefix sum array\\n        for (int i = 1; i <= n; i++) {\\n            s[i] = s[i-1] + (a[i][1] - a[i][0] + 1);\\n        }\\n        \\n        int i = 1, j = 1, ans = 0;\\n        while (j <= n) {\\n\\t\\t\\n            while (j <= n && a[j][1] - a[i][0] + 1 <= len) ++j; // Finding the upper bound for the current window\\n\\t\\t\\t\\n\\t\\t\\t// s[j-1] - s[i-1] --> number of tiles from i to j-1\\n\\t\\t\\t// len - (a[j][0] - a[i][0]) --> number of some tiles (partially covered titles) which will be covered by the carpet of the next interval\\n\\t\\t\\t// it can be less then 0 thats why take max(0, len - (a[j][0] - a[i][0]))\\n            ans = max(ans, (s[j-1] - s[i-1]) + max(0, len - (a[j][0] - a[i][0])));\\n\\t\\t\\t\\n            ++i; // Shifting the window\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038286,
                "title": "greedy-prefixsum-queue-o-nlogn",
                "content": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen : int) -> int:\\n        tiles.sort(key=lambda x:(x[0]))\\n        ans=0\\n        q=deque()\\n        presum=[0]*(len(tiles)+1)\\n        for i in range(len(tiles)):\\n            start,end=tiles[i]\\n            presum[i+1]=((end-start) +presum[i] +1)\\n        for i in range(len(tiles)):\\n            start,end=tiles[i]\\n            while q and tiles[q[0]][0]+carpetLen<=end:\\n                maxposs=tiles[q[0]][0]+carpetLen  # maximum Possible  start+ carpetLen \\n                ans=max(ans,maxposs-start + presum[i]-presum[q[0]] )  \\n                q.popleft()\\n            q.append(i)\\n            ans=max(ans,presum[i+1]-presum[q[0]])\\n        return min(ans,carpetLen )\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen : int) -> int:\\n        tiles.sort(key=lambda x:(x[0]))\\n        ans=0\\n        q=deque()\\n        presum=[0]*(len(tiles)+1)\\n        for i in range(len(tiles)):\\n            start,end=tiles[i]\\n            presum[i+1]=((end-start) +presum[i] +1)\\n        for i in range(len(tiles)):\\n            start,end=tiles[i]\\n            while q and tiles[q[0]][0]+carpetLen<=end:\\n                maxposs=tiles[q[0]][0]+carpetLen  # maximum Possible  start+ carpetLen \\n                ans=max(ans,maxposs-start + presum[i]-presum[q[0]] )  \\n                q.popleft()\\n            q.append(i)\\n            ans=max(ans,presum[i+1]-presum[q[0]])\\n        return min(ans,carpetLen )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038263,
                "title": "java-short-sliding-window",
                "content": "```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        Arrays.sort(tiles, (a,b) -> a[0] - b[0]);  // Sort by start position\\n        int ans = 0, ci = 0, cj = 0, i = 0, j = 0;\\n        for(i = 0; i<tiles.length; i++){\\n            int covered = 0;\\n            ci = tiles[i][0]; // carpet start at tile start\\n            cj = ci+carpetLen;\\n            covered += (cj > tiles[i][1] ? tiles[i][1] - tiles[i][0] + 1 : cj-tiles[i][0]);\\n            for(j=i+1; j<tiles.length; j++){\\n                if(tiles[j][0] > cj) break;  //tile start > carpet end then break\\n                else covered += (cj > tiles[j][1] ? tiles[j][1] - tiles[j][0] + 1 : cj-tiles[j][0]); \\n            }\\n            ans = Math.max(covered, ans);\\n            if(j==tiles.length) return ans;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nEDIT:\\n\\n```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        Arrays.sort(tiles, (a,b) -> a[0] - b[0]);\\n        int ans = 0, ci = 0, cj = 0, covered = 0;\\n        for(int idx = 0; idx < tiles.length; ){\\n            cj = tiles[ci][0] + carpetLen;\\n            if(ci == idx || cj > tiles[idx][1]){\\n                covered += (tiles[idx][1] - tiles[idx][0] + 1);\\n                ans = Math.max(covered, ans); \\n                idx++;\\n            }\\n            else{\\n                int partial = cj - tiles[idx][0];\\n                ans = Math.max(covered + partial, ans);\\n                covered -= (tiles[ci][1] - tiles[ci][0] + 1);\\n                ci++;\\n            }\\n        }\\n        return Math.min(ans, carpetLen);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        Arrays.sort(tiles, (a,b) -> a[0] - b[0]);  // Sort by start position\\n        int ans = 0, ci = 0, cj = 0, i = 0, j = 0;\\n        for(i = 0; i<tiles.length; i++){\\n            int covered = 0;\\n            ci = tiles[i][0]; // carpet start at tile start\\n            cj = ci+carpetLen;\\n            covered += (cj > tiles[i][1] ? tiles[i][1] - tiles[i][0] + 1 : cj-tiles[i][0]);\\n            for(j=i+1; j<tiles.length; j++){\\n                if(tiles[j][0] > cj) break;  //tile start > carpet end then break\\n                else covered += (cj > tiles[j][1] ? tiles[j][1] - tiles[j][0] + 1 : cj-tiles[j][0]); \\n            }\\n            ans = Math.max(covered, ans);\\n            if(j==tiles.length) return ans;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        Arrays.sort(tiles, (a,b) -> a[0] - b[0]);\\n        int ans = 0, ci = 0, cj = 0, covered = 0;\\n        for(int idx = 0; idx < tiles.length; ){\\n            cj = tiles[ci][0] + carpetLen;\\n            if(ci == idx || cj > tiles[idx][1]){\\n                covered += (tiles[idx][1] - tiles[idx][0] + 1);\\n                ans = Math.max(covered, ans); \\n                idx++;\\n            }\\n            else{\\n                int partial = cj - tiles[idx][0];\\n                ans = Math.max(covered + partial, ans);\\n                covered -= (tiles[ci][1] - tiles[ci][0] + 1);\\n                ci++;\\n            }\\n        }\\n        return Math.min(ans, carpetLen);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487964,
                "title": "sliding-window-c-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) if tiles were given in sorted order else O(nlogn) to sort the tiles\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int x) {\\n        sort(tiles.begin(), tiles.end());\\n        int cnt = 0, ans = 0, n = tiles.size();\\n        for(int i = 0, j = 0; i < n; i++){\\n            if(i > 0) cnt -= tiles[i-1][1] - tiles[i-1][0]+1;\\n\\n            while(j < n && tiles[j][1] - tiles[i][0] + 1 <= x){\\n                cnt += tiles[j][1] - tiles[j][0] + 1;\\n                j++;\\n            }\\n            int addi = 0;\\n            if(j < n) addi = max(0, tiles[i][0] + x - tiles[j][0]);\\n            ans = max(ans, cnt+addi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int x) {\\n        sort(tiles.begin(), tiles.end());\\n        int cnt = 0, ans = 0, n = tiles.size();\\n        for(int i = 0, j = 0; i < n; i++){\\n            if(i > 0) cnt -= tiles[i-1][1] - tiles[i-1][0]+1;\\n\\n            while(j < n && tiles[j][1] - tiles[i][0] + 1 <= x){\\n                cnt += tiles[j][1] - tiles[j][0] + 1;\\n                j++;\\n            }\\n            int addi = 0;\\n            if(j < n) addi = max(0, tiles[i][0] + x - tiles[j][0]);\\n            ans = max(ans, cnt+addi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865696,
                "title": "javascript-sliding-window",
                "content": "My original solution took O(n^2) and was giving TLE\\nTook reference from below solution and tweaked it to cover edge cases\\nhttps://leetcode.com/problems/maximum-white-tiles-covered-by-a-carpet/solutions/2042218/js-sliding-window-o-nlogn/\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn + 2n) ~ O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} tiles\\n * @param {number} carpetLen\\n * @return {number}\\n */\\nvar maximumWhiteTiles = function (tiles, carpetLen) {\\n    tiles.sort((a, b) => a[0] - b[0])\\n\\n    let right = 1;\\n    let cover = tiles[0][1] - tiles[0][0] + 1;\\n    let maxCovered = cover;\\n    if (maxCovered >= carpetLen) return carpetLen\\n\\n    for (const tile of tiles) {\\n        let start = tile[0]\\n        let end = start + carpetLen - 1\\n\\n        while (right < tiles.length && tiles[right][1] <= end) {\\n            cover += tiles[right][1] - tiles[right][0] + 1\\n            right++\\n        }\\n        if (right === tiles.length || end < tiles[right][0]) {\\n            maxCovered = Math.max(maxCovered, cover)\\n        } else {\\n            let partial = end - tiles[right][0] + 1\\n            maxCovered = Math.max(maxCovered, cover + partial)\\n        }\\n\\n        cover -= (tile[1] - tile[0]) + 1\\n    }\\n\\n    return maxCovered\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} tiles\\n * @param {number} carpetLen\\n * @return {number}\\n */\\nvar maximumWhiteTiles = function (tiles, carpetLen) {\\n    tiles.sort((a, b) => a[0] - b[0])\\n\\n    let right = 1;\\n    let cover = tiles[0][1] - tiles[0][0] + 1;\\n    let maxCovered = cover;\\n    if (maxCovered >= carpetLen) return carpetLen\\n\\n    for (const tile of tiles) {\\n        let start = tile[0]\\n        let end = start + carpetLen - 1\\n\\n        while (right < tiles.length && tiles[right][1] <= end) {\\n            cover += tiles[right][1] - tiles[right][0] + 1\\n            right++\\n        }\\n        if (right === tiles.length || end < tiles[right][0]) {\\n            maxCovered = Math.max(maxCovered, cover)\\n        } else {\\n            let partial = end - tiles[right][0] + 1\\n            maxCovered = Math.max(maxCovered, cover + partial)\\n        }\\n\\n        cover -= (tile[1] - tile[0]) + 1\\n    }\\n\\n    return maxCovered\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2515814,
                "title": "python-bin-serach-prefix-summ",
                "content": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort()\\n        \\n        ps=[(tiles[0][1]-tiles[0][0])+1]\\n        for i in range(1,len(tiles)):ps.append(ps[-1]+(tiles[i][1]-tiles[i][0])+1)\\n            \\n        a=0\\n        for i in range(len(tiles)):\\n            st=tiles[i][0]\\n            end=st+carpetLen-1\\n            \\n            l=i\\n            r=len(tiles)-1\\n            k=-1\\n            while l<=r:\\n                m=(l+r)//2\\n                t=tiles[m]\\n                if end<=t[1] and end>=t[0]:\\n                    k=m\\n                    break\\n                if end>t[1]:\\n                    l=m+1\\n                if end<t[0]:\\n                    r=m-1\\n\\n            if k>0:\\n                ss=ps[k-1]\\n                if i>0:\\n                    ss-=ps[i-1]\\n                ss=ss+(end-tiles[k][0])+1\\n            elif k==0:\\n                ss=(end-tiles[k][0])+1\\n            elif l>r:\\n                ss=ps[r]\\n                if i>0:\\n                    ss-=ps[i-1]\\n\\n            a=max(a,ss)\\n        return a\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort()\\n        \\n        ps=[(tiles[0][1]-tiles[0][0])+1]\\n        for i in range(1,len(tiles)):ps.append(ps[-1]+(tiles[i][1]-tiles[i][0])+1)\\n            \\n        a=0\\n        for i in range(len(tiles)):\\n            st=tiles[i][0]\\n            end=st+carpetLen-1\\n            \\n            l=i\\n            r=len(tiles)-1\\n            k=-1\\n            while l<=r:\\n                m=(l+r)//2\\n                t=tiles[m]\\n                if end<=t[1] and end>=t[0]:\\n                    k=m\\n                    break\\n                if end>t[1]:\\n                    l=m+1\\n                if end<t[0]:\\n                    r=m-1\\n\\n            if k>0:\\n                ss=ps[k-1]\\n                if i>0:\\n                    ss-=ps[i-1]\\n                ss=ss+(end-tiles[k][0])+1\\n            elif k==0:\\n                ss=(end-tiles[k][0])+1\\n            elif l>r:\\n                ss=ps[r]\\n                if i>0:\\n                    ss-=ps[i-1]\\n\\n            a=max(a,ss)\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429901,
                "title": "python-easy-to-understand-solution-using-prefix-sum-and-binary-search",
                "content": "The approach is described below:\\n1. Sort the tiles by li (start of range) in ascending order to make the solution more practical.\\n2. Try placing the carpet at every starting position of a range of tiles. For example, if we have [1,5], [10, 11], [12, 18], we first try to place the carpet at position 1, then 10 and then 12. Why? Because starting the carpet at any other position will lead to the carpet covering tiles that are not white and we don\\'t care about such placements.\\n3. After placing the carpet[0] at a known position (starting range of tiles), we need to check where our carpet[1] will land. This can be done by simply adding carpetLen to carpet[0]. Now, we have to find the number of white tiles between carpet[0] and carpet[1].\\nWe have 2 different cases: (a) will lie in a non-white range after the carpet[0] tile range (b) will lie in a white range after the range of carpet[0] (or same range).\\nWe can use prefix sum to get the total number of white tiles between the white ranges.\\ntiles[0] = [1, 5]\\ntiles[1] = [10, 11]\\ntiles[2] = [12, 18]\\npreSum[0] = number of white between ranges 0 and 0 is (5-1) + 1 = 5 white tiles\\npreSum[1] = number of white between ranges 0 and 1 is 5 + (11 - 10) + 1 = 5 + 2 = 7\\npreSum[2] = number of white between ranges 0 and 2 is 7 + (18 - 12) + 1 = 7 + 7 = 14\\nTo get the number of white tiles between 1 and 2, we just need to remove preSum[0] from preSum[2].\\nSo now, given ranges, we can quickly find the number of white tiles between them.\\n4. The last problem to figure out is how to quickly find the end range where carpet[1] lands (without examining all ranges). We use binary search: if the index is inside a range, we return range. Otherwise, if index < range[0], we search before. Else, we search after. If we don\\'t find a range that contains carpet[1], then we return the largest range that ends before carpet[1].\\n\\n```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: [[int]], carpetLen: int) -> int:\\n\\t    # sorting in ascending order by li\\n        tiles = sorted(tiles, key=lambda x: x[0])\\n\\n        def findTilesRange(end, low, high):\\n            if low > high:\\n                # we couldn\\'t find end in any range\\n                return high\\n            else:\\n                # get the mid range\\n                mid = low + ((high - low) // 2)\\n\\n                if tiles[mid][0] <= end <= tiles[mid][1]:\\n                    return mid\\n                elif end < tiles[mid][0]:\\n                    return findTilesRange(end, low, mid - 1)\\n                elif end > tiles[mid][1]:\\n                    return findTilesRange(end, mid + 1, high)\\n\\n        # then we calculate preSum which would tell us the number of white tiles between ranges\\n        # pre[i] = number of white tiles between range[0] and range[i]\\n        # start with preSum[0] = number of white tiles of range tiles[0]\\n        preSum = {}\\n        preSum[-1] = 0\\n        preSum[0] = (tiles[0][1] - tiles[0][0]) + 1\\n\\n        for i in range(1, len(tiles)):\\n            currentRangeTilesCount = (tiles[i][1] - tiles[i][0]) + 1\\n            preSum[i] = preSum[i - 1] + currentRangeTilesCount\\n\\n        maximumTilesCovered = 0\\n\\n        # now we try to place the carpet at the beginning of every range\\n        for i in range(0, len(tiles)):\\n            carpetStart = tiles[i][0]\\n            carpetEnd = carpetStart + carpetLen - 1\\n\\n            # now we need to find carpetEnd belongs to which range. If it doesn\\'t belong to any white range, we need\\n            # the binary search function to return the index of the largest range right before carpetEnd\\n            rangeStart = i\\n            rangeEnd = findTilesRange(carpetEnd, 0, len(tiles) - 1)\\n\\n            # now we need to get the number of white tiles between rangeStart and rangeEnd\\n            # we know that rangeStart is covered from the start but rangeEnd may be covered in part.\\n            if carpetEnd >= tiles[rangeEnd][1]:\\n                # rangeEnd is covered in entirety\\n                numberOfWhiteTiles = preSum[rangeEnd] - preSum[rangeStart - 1]\\n            else:\\n                # carpetEnd is somewhere in the range so we need to remove the remaining tiles on the right\\n                numberOfWhiteTiles = preSum[rangeEnd] - preSum[rangeStart - 1]\\n\\n                # we need to remove more tiles that are to the right of carpetEnd in rangeEnd tiles\\n                numberOfWhiteTiles -= tiles[rangeEnd][1] - carpetEnd\\n\\n            maximumTilesCovered = max(maximumTilesCovered, numberOfWhiteTiles)\\n\\n        return maximumTilesCovered\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: [[int]], carpetLen: int) -> int:\\n\\t    # sorting in ascending order by li\\n        tiles = sorted(tiles, key=lambda x: x[0])\\n\\n        def findTilesRange(end, low, high):\\n            if low > high:\\n                # we couldn\\'t find end in any range\\n                return high\\n            else:\\n                # get the mid range\\n                mid = low + ((high - low) // 2)\\n\\n                if tiles[mid][0] <= end <= tiles[mid][1]:\\n                    return mid\\n                elif end < tiles[mid][0]:\\n                    return findTilesRange(end, low, mid - 1)\\n                elif end > tiles[mid][1]:\\n                    return findTilesRange(end, mid + 1, high)\\n\\n        # then we calculate preSum which would tell us the number of white tiles between ranges\\n        # pre[i] = number of white tiles between range[0] and range[i]\\n        # start with preSum[0] = number of white tiles of range tiles[0]\\n        preSum = {}\\n        preSum[-1] = 0\\n        preSum[0] = (tiles[0][1] - tiles[0][0]) + 1\\n\\n        for i in range(1, len(tiles)):\\n            currentRangeTilesCount = (tiles[i][1] - tiles[i][0]) + 1\\n            preSum[i] = preSum[i - 1] + currentRangeTilesCount\\n\\n        maximumTilesCovered = 0\\n\\n        # now we try to place the carpet at the beginning of every range\\n        for i in range(0, len(tiles)):\\n            carpetStart = tiles[i][0]\\n            carpetEnd = carpetStart + carpetLen - 1\\n\\n            # now we need to find carpetEnd belongs to which range. If it doesn\\'t belong to any white range, we need\\n            # the binary search function to return the index of the largest range right before carpetEnd\\n            rangeStart = i\\n            rangeEnd = findTilesRange(carpetEnd, 0, len(tiles) - 1)\\n\\n            # now we need to get the number of white tiles between rangeStart and rangeEnd\\n            # we know that rangeStart is covered from the start but rangeEnd may be covered in part.\\n            if carpetEnd >= tiles[rangeEnd][1]:\\n                # rangeEnd is covered in entirety\\n                numberOfWhiteTiles = preSum[rangeEnd] - preSum[rangeStart - 1]\\n            else:\\n                # carpetEnd is somewhere in the range so we need to remove the remaining tiles on the right\\n                numberOfWhiteTiles = preSum[rangeEnd] - preSum[rangeStart - 1]\\n\\n                # we need to remove more tiles that are to the right of carpetEnd in rangeEnd tiles\\n                numberOfWhiteTiles -= tiles[rangeEnd][1] - carpetEnd\\n\\n            maximumTilesCovered = max(maximumTilesCovered, numberOfWhiteTiles)\\n\\n        return maximumTilesCovered\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429653,
                "title": "c-solution",
                "content": "```\\nstruct cmp {\\n    bool operator() (const vector<int> &a, const vector<int> &b) {\\n        return a[1] < b[1];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int len) {\\n        int n = tiles.size(), total = 0;\\n        sort(tiles.begin(), tiles.end());\\n        \\n        vector<int> nums(n);\\n        for(int i=0; i<n; i++) {\\n            nums[i] = total;\\n            total += tiles[i][1] - tiles[i][0] + 1;\\n        }\\n\\n        int ret = 0;\\n\\n        for(int i=0; i<n; i++) {\\n            int end = tiles[i][0] + len - 1;\\n            int j = lower_bound(tiles.begin(), tiles.end(), vector<int>{end,end} ,cmp()) - tiles.begin();\\n\\n            if(j == n) {\\n                ret = max(ret, total - nums[i]);\\n                break;\\n            }\\n            int re = (end >= tiles[j][0] ) ? end + 1 - tiles[j][0] : 0;\\n            ret = max(ret, nums[j] - nums[i] + re);\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstruct cmp {\\n    bool operator() (const vector<int> &a, const vector<int> &b) {\\n        return a[1] < b[1];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int len) {\\n        int n = tiles.size(), total = 0;\\n        sort(tiles.begin(), tiles.end());\\n        \\n        vector<int> nums(n);\\n        for(int i=0; i<n; i++) {\\n            nums[i] = total;\\n            total += tiles[i][1] - tiles[i][0] + 1;\\n        }\\n\\n        int ret = 0;\\n\\n        for(int i=0; i<n; i++) {\\n            int end = tiles[i][0] + len - 1;\\n            int j = lower_bound(tiles.begin(), tiles.end(), vector<int>{end,end} ,cmp()) - tiles.begin();\\n\\n            if(j == n) {\\n                ret = max(ret, total - nums[i]);\\n                break;\\n            }\\n            int re = (end >= tiles[j][0] ) ? end + 1 - tiles[j][0] : 0;\\n            ret = max(ret, nums[j] - nums[i] + re);\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344966,
                "title": "easy-java-solution-using-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n\\n        \\n        Arrays.sort(tiles,(a,b)->a[0]-b[0]);\\n        int right =0,ans =0,currtotal =0;\\n      int n = tiles.length;\\n        for(int i =0;i<n;i++){\\n            \\n         int start = tiles[i][0];\\n         int end = start+carpetLen-1;\\n            \\n            while(right<n && tiles[right][1]<end){\\n                currtotal +=tiles[right][1]-tiles[right][0]+1;\\n                right++;\\n            }\\n            if(right ==n || tiles[right][0]>end){\\n                ans =Math.max(ans,currtotal);\\n            }\\n            else\\n                ans = Math.max(ans,currtotal+end-tiles[right][0]+1);\\n            currtotal-=tiles[i][1]-tiles[i][0]+1;\\n            \\n            \\n    \\n                \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n\\n        \\n        Arrays.sort(tiles,(a,b)->a[0]-b[0]);\\n        int right =0,ans =0,currtotal =0;\\n      int n = tiles.length;\\n        for(int i =0;i<n;i++){\\n            \\n         int start = tiles[i][0];\\n         int end = start+carpetLen-1;\\n            \\n            while(right<n && tiles[right][1]<end){\\n                currtotal +=tiles[right][1]-tiles[right][0]+1;\\n                right++;\\n            }\\n            if(right ==n || tiles[right][0]>end){\\n                ans =Math.max(ans,currtotal);\\n            }\\n            else\\n                ans = Math.max(ans,currtotal+end-tiles[right][0]+1);\\n            currtotal-=tiles[i][1]-tiles[i][0]+1;\\n            \\n            \\n    \\n                \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153581,
                "title": "python3-prefix-sum-binary-search-and-sorting",
                "content": "```class Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        startPositions = [(x[0], x[1]-x[0]+1) for x in tiles]\\n        startPositions.sort(key=lambda x: x[0])\\n        presum = [0 for _ in range(len(tiles) + 1)]\\n        ret = 0\\n        for i in range(1, len(presum)):\\n            presum[i] = presum[i-1] + startPositions[i-1][1]\\n        \\n        for inx, (start_position, length) in enumerate(startPositions):\\n            compensate = 0\\n            if length >= carpetLen:\\n                return carpetLen\\n            carpet_end_length = carpetLen + start_position - 1\\n            carpet_end_inx = bisect.bisect_right(startPositions, (carpet_end_length, float(\"inf\"))) - 1\\n            tiles_lengthcarpet_end_inx = startPositions[carpet_end_inx][0] + startPositions[carpet_end_inx][1] - 1\\n            if tiles_lengthcarpet_end_inx > carpet_end_length:\\n                compensate = tiles_lengthcarpet_end_inx - carpet_end_length\\n            covered_length = presum[carpet_end_inx+1] - compensate - presum[inx]\\n            ret = max(ret, covered_length)\\n        return ret\\n            \\n",
                "solutionTags": [],
                "code": "```class Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        startPositions = [(x[0], x[1]-x[0]+1) for x in tiles]\\n        startPositions.sort(key=lambda x: x[0])\\n        presum = [0 for _ in range(len(tiles) + 1)]\\n        ret = 0\\n        for i in range(1, len(presum)):\\n            presum[i] = presum[i-1] + startPositions[i-1][1]\\n        \\n        for inx, (start_position, length) in enumerate(startPositions):\\n            compensate = 0\\n            if length >= carpetLen:\\n                return carpetLen\\n            carpet_end_length = carpetLen + start_position - 1\\n            carpet_end_inx = bisect.bisect_right(startPositions, (carpet_end_length, float(\"inf\"))) - 1\\n            tiles_lengthcarpet_end_inx = startPositions[carpet_end_inx][0] + startPositions[carpet_end_inx][1] - 1\\n            if tiles_lengthcarpet_end_inx > carpet_end_length:\\n                compensate = tiles_lengthcarpet_end_inx - carpet_end_length\\n            covered_length = presum[carpet_end_inx+1] - compensate - presum[inx]\\n            ret = max(ret, covered_length)\\n        return ret\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 2148636,
                "title": "python3-greedy",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/e134859baf16ddb9bd1645d01619449f3d067c14) for solutions of biweekly 78. \\n\\n```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort()\\n        ans = ii = val = 0 \\n        for i in range(len(tiles)): \\n            hi = tiles[i][0] + carpetLen - 1\\n            while ii < len(tiles) and tiles[ii][1] <= hi:\\n                val += tiles[ii][1] - tiles[ii][0] + 1\\n                ii += 1\\n            partial = 0 \\n            if ii < len(tiles): partial = max(0, hi - tiles[ii][0] + 1)\\n            ans = max(ans, val + partial)\\n            val -= tiles[i][1] - tiles[i][0] + 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort()\\n        ans = ii = val = 0 \\n        for i in range(len(tiles)): \\n            hi = tiles[i][0] + carpetLen - 1\\n            while ii < len(tiles) and tiles[ii][1] <= hi:\\n                val += tiles[ii][1] - tiles[ii][0] + 1\\n                ii += 1\\n            partial = 0 \\n            if ii < len(tiles): partial = max(0, hi - tiles[ii][0] + 1)\\n            ans = max(ans, val + partial)\\n            val -= tiles[i][1] - tiles[i][0] + 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138509,
                "title": "greedy-binary-search-and-intuition-behind-greedy-logic-with-diagrams-python",
                "content": "Let, the double lines represent the carpet and the rectangles represents a bunch of continuous white tiles.\\n\\nAt any point the start and endpoint of a carpet falls into one of the following 4 cases.\\n\\n1. In this case, both the start and end point of the carpet is not on a tile. Now if we move the carpet one step forward the number of white tile the carpet covers will remain constant.\\n![image](https://assets.leetcode.com/users/images/e6d3897c-262d-4266-bcd1-2bb7d8151971_1654954491.974952.png)\\n2. Here, the start point of the carpet is not on a tile but the end point of the carpet is on a tile. Now if  we move carpet one step forward the number of tile the carpet covers increases by 1. \\n![image](https://assets.leetcode.com/users/images/dc170c38-396b-4892-b6e2-3430ad0f4c12_1654954501.8922558.png)\\nThus from the above two cases we can say that when the start point of carpet is not on a tile and we keep moving forward the carpet by one step, the number of tiles the carpet covers will increase or remain constant. This keeps happening until the start of carpet reaches the start of a tile.\\nOnce that happens,\\n3. Both start of carpet and end of carpet are on a tile. Now if we move carpet forward number of tiles it covers remains constant.\\n![image](https://assets.leetcode.com/users/images/abe3c7af-51a0-4539-b025-4b5ec07b5e4c_1654954506.0417957.png)\\n\\n3. Again, if start of carpet is on a tile and end of tile is not, then when we move carpet forward, number of tiles covered decreases.\\n![image](https://assets.leetcode.com/users/images/1068b0e8-45a3-4e27-af90-feac3eabe8a3_1654954510.5877671.png)\\n\\n**So, we can say that the starting points of tiles is a point of maximum** (value increases or remains constant until this point and then decreases or remains constant). Answer lies in one of the starting point of all the tiles.\\nIn this diagram, the red dot represents the start of tile and the dotted line represents end of that tile. Red dots are points of maximum.\\n![image](https://assets.leetcode.com/users/images/2937d086-4c2b-4bf1-bd79-4a779744bf2d_1654954522.009874.png)\\n\\nNow on the implementation part, for each starting point we check how many tiles can be covered by the carpet if placed here. The end point of the carpet can be binary searched.\\n\\n\\n```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        \\n        def bs(currentTile, tileEnd):\\n            lo = currentTile\\n            hi = l - 1\\n            res = currentTile\\n            while lo <= hi:\\n                mid = (lo + hi) // 2\\n                if tileEnd >= tiles[mid][0]:\\n                    lo = mid + 1\\n                    res = mid\\n                else:\\n                    hi = mid - 1\\n            return res\\n        \\n        l = len(tiles)\\n        tiles.sort()\\n        \\n        widths = [r - l + 1 for l, r in tiles]\\n        \\n        prefixSum = list(accumulate(widths, initial = 0))\\n        \\n        ans = 0\\n        for i in range(l):\\n            start, end = tiles[i]\\n            \\n            tileEnd = start + carpetLen - 1\\n            \\n            if tileEnd <= end:\\n                return carpetLen\\n            \\n            startPos = i\\n\\t\\t\\t# binary seach end of tile\\n            endPos = bs(i, tileEnd)\\n            \\n            toRemove = 0\\n            \\n            # carpet partially covers this tile\\n\\t\\t\\t# toRemove is the portion which needs to be subtracted\\n            if tiles[endPos][1] > tileEnd:\\n                toRemove = tiles[endPos][1] - tileEnd\\n            \\n            ans = max(ans, prefixSum[endPos+1] - prefixSum[startPos] - toRemove)\\n        \\n        return ans\\n```\\n\\nTime Complexity: O(nlogn)\\n\\n",
                "solutionTags": [
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        \\n        def bs(currentTile, tileEnd):\\n            lo = currentTile\\n            hi = l - 1\\n            res = currentTile\\n            while lo <= hi:\\n                mid = (lo + hi) // 2\\n                if tileEnd >= tiles[mid][0]:\\n                    lo = mid + 1\\n                    res = mid\\n                else:\\n                    hi = mid - 1\\n            return res\\n        \\n        l = len(tiles)\\n        tiles.sort()\\n        \\n        widths = [r - l + 1 for l, r in tiles]\\n        \\n        prefixSum = list(accumulate(widths, initial = 0))\\n        \\n        ans = 0\\n        for i in range(l):\\n            start, end = tiles[i]\\n            \\n            tileEnd = start + carpetLen - 1\\n            \\n            if tileEnd <= end:\\n                return carpetLen\\n            \\n            startPos = i\\n\\t\\t\\t# binary seach end of tile\\n            endPos = bs(i, tileEnd)\\n            \\n            toRemove = 0\\n            \\n            # carpet partially covers this tile\\n\\t\\t\\t# toRemove is the portion which needs to be subtracted\\n            if tiles[endPos][1] > tileEnd:\\n                toRemove = tiles[endPos][1] - tileEnd\\n            \\n            ans = max(ans, prefixSum[endPos+1] - prefixSum[startPos] - toRemove)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128380,
                "title": "python-sliding-window-o-nlogn",
                "content": "Sliding Window\\n\\n`tc` refers to tile  coverage\\nKeep adding new tile blocks to tc and check for partial coverage.\\n\\n```\\nclass Solution(object):\\n    def maximumWhiteTiles(self, tiles, carpetLen):\\n\\n        l, r, res, tc = 0, 0, 0, 0\\n        tiles.sort()\\n        \\n        for r in range(len(tiles)):\\n\\n            # slide window if necessary\\n            while tiles[r][1] - tiles[l][0] + 1 > carpetLen:\\n                if l == r : \\n                    return carpetLen\\n                \\n                # partial coverage for last tile\\n                partial = max(0, tiles[l][0] + carpetLen - tiles[r][0])\\n                if tc + partial <= carpetLen : \\n                    res = max(res, tc + partial)\\n                \\n                #adjust tile coverage and pop left tile\\n                tc -= tiles[l][1] - tiles[l][0] + 1\\n                l += 1\\n\\n            # add current item r to window\\n            tc += tiles[r][1] - tiles[r][0] + 1\\n            if tiles[r][1] - tiles[l][0] + 1 <= carpetLen:\\n                res = max(res, tc)\\n\\n        return res",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "Sliding Window\\n\\n`tc` refers to tile  coverage\\nKeep adding new tile blocks to tc and check for partial coverage.\\n\\n```\\nclass Solution(object):\\n    def maximumWhiteTiles(self, tiles, carpetLen):\\n\\n        l, r, res, tc = 0, 0, 0, 0\\n        tiles.sort()\\n        \\n        for r in range(len(tiles)):\\n\\n            # slide window if necessary\\n            while tiles[r][1] - tiles[l][0] + 1 > carpetLen:\\n                if l == r : \\n                    return carpetLen\\n                \\n                # partial coverage for last tile\\n                partial = max(0, tiles[l][0] + carpetLen - tiles[r][0])\\n                if tc + partial <= carpetLen : \\n                    res = max(res, tc + partial)\\n                \\n                #adjust tile coverage and pop left tile\\n                tc -= tiles[l][1] - tiles[l][0] + 1\\n                l += 1\\n\\n            # add current item r to window\\n            tc += tiles[r][1] - tiles[r][0] + 1\\n            if tiles[r][1] - tiles[l][0] + 1 <= carpetLen:\\n                res = max(res, tc)\\n\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2104237,
                "title": "java-sliding-window-with-high-level-explanation",
                "content": "I almost spent the whole day on this question :(\\nI am not as smart as the most voted posts but here\\'s what i learned from this prolem.\\n\\n1) Sliding window is tricky to implement especially with multiple moving parts. I often trip myself when implementing it. The trick i learned is to have at least one for loop to process one state at a time. When processing this state, focus on this state. For example in this question, each for loop focuses on a single tile segment. We add it no matter what, and then discuss the condition how to move the starting tile to fix it.\\n```\\nstart = 0\\nfor (end in 0 to i) {\\n     process the end value\\n\\t \\n\\t while (condition is not met) {\\n\\t     process start value\\n\\t }\\n\\t \\n\\t (optional) double check if condition is still met {\\n\\t     update the answer\\n\\t }\\n\\t \\n}\\n```\\n\\n\\n2) Sliding window doesn\\'t mean you have to loop the window position, the window can be the condition and we loop the inputs. This is where i missed when i started on my own. After quickly read other people\\'s post, I discovered this idea and switched back to my own implementation.\\n\\n3) the Math.max(start, toRemove[0]) is also tricky. We must remember which part of the start segment has been removed. Otherwise, it is a double counting error. I spent hours debugging cuz i was able to pass 90% of the test cases. Eventually i found out i missed the use case where we moved the window multiple times in the same segment.\\n\\n\\n4) I hate this type of interval / segment problems.. So hard to count the boundary. Fingers crossed i won\\'t run into one during onsite interview :)\\n\\n\\n```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {        \\n        // alternative solution: \\n        // loop through the tiles instead of the window\\n        // every new tile we try to add it to the existing window\\n        // if we can add whole, great\\n        // if we can add part of it, we just add all of it and shrink the window start\\n        // we need to move up the window to make sure we can continue to add more tiles\\n        Arrays.sort(tiles, (a, b) ->{\\n            // just to make sure input is not trolling us\\n            return Integer.compare(a[0], b[0]);\\n        });\\n        \\n        \\n        int max = 0;\\n        int start = tiles[0][0]; // window start at the first tile segment start\\n        int end = 0; // window end\\n        int sum = 0; // window sum\\n        int j = 0;  // tile pointer\\n        for (int i = 0; i < tiles.length; ++i) {\\n            // just add the whole tile no matter what\\n            int[] t = tiles[i];\\n            end = t[1];\\n            sum += (t[1] - t[0] + 1);\\n            // window might be over expanded\\n            while (end - start + 1 > carpetLen) {\\n                // move up the carpet to at least cover the current one\\n                // several possibilities\\n                // try to remove start until the window is good again\\n                int[] toRemove = tiles[j];\\n                int newStart = end - carpetLen + 1; // min starting position, we must start on this position to have a valid window\\n                // we can remove the next tile entirely\\n                if (toRemove[1] < newStart) {\\n                    sum -= (toRemove[1] - Math.max(start, toRemove[0]) + 1);\\n                    ++j;\\n                    start = tiles[j][0]; // skip any empty spaces since they don\\'t matter\\n                } else {\\n                    // we cannot just remove the whole tile, move our start window pointer to the min position\\n                    sum -= (newStart - Math.max(start, toRemove[0]));\\n                    start = newStart;\\n                }\\n            }\\n            \\n            max = Math.max(max, sum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstart = 0\\nfor (end in 0 to i) {\\n     process the end value\\n\\t \\n\\t while (condition is not met) {\\n\\t     process start value\\n\\t }\\n\\t \\n\\t (optional) double check if condition is still met {\\n\\t     update the answer\\n\\t }\\n\\t \\n}\\n```\n```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {        \\n        // alternative solution: \\n        // loop through the tiles instead of the window\\n        // every new tile we try to add it to the existing window\\n        // if we can add whole, great\\n        // if we can add part of it, we just add all of it and shrink the window start\\n        // we need to move up the window to make sure we can continue to add more tiles\\n        Arrays.sort(tiles, (a, b) ->{\\n            // just to make sure input is not trolling us\\n            return Integer.compare(a[0], b[0]);\\n        });\\n        \\n        \\n        int max = 0;\\n        int start = tiles[0][0]; // window start at the first tile segment start\\n        int end = 0; // window end\\n        int sum = 0; // window sum\\n        int j = 0;  // tile pointer\\n        for (int i = 0; i < tiles.length; ++i) {\\n            // just add the whole tile no matter what\\n            int[] t = tiles[i];\\n            end = t[1];\\n            sum += (t[1] - t[0] + 1);\\n            // window might be over expanded\\n            while (end - start + 1 > carpetLen) {\\n                // move up the carpet to at least cover the current one\\n                // several possibilities\\n                // try to remove start until the window is good again\\n                int[] toRemove = tiles[j];\\n                int newStart = end - carpetLen + 1; // min starting position, we must start on this position to have a valid window\\n                // we can remove the next tile entirely\\n                if (toRemove[1] < newStart) {\\n                    sum -= (toRemove[1] - Math.max(start, toRemove[0]) + 1);\\n                    ++j;\\n                    start = tiles[j][0]; // skip any empty spaces since they don\\'t matter\\n                } else {\\n                    // we cannot just remove the whole tile, move our start window pointer to the min position\\n                    sum -= (newStart - Math.max(start, toRemove[0]));\\n                    start = newStart;\\n                }\\n            }\\n            \\n            max = Math.max(max, sum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061330,
                "title": "python-merge-intervals-easy-to-understand-beats-98-95",
                "content": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort(key = lambda x:x[0])\\n        new_tiles = [tiles[0]]\\n        for i in range(1,len(tiles)):\\n            s,e = tiles[i]\\n            if s == tiles[i-1][1] + 1:\\n                new_tiles[-1][1] = e\\n            else:\\n                new_tiles.append([s, e])\\n        l, r = 0, 0 \\n        cur_len,  res = 0, 0\\n        start = new_tiles[0][0]\\n        while l <=r and r < len(new_tiles):\\n            if new_tiles[r][1] - start +1 < carpetLen:\\n                cur_len += new_tiles[r][1] - new_tiles[r][0] + 1\\n                r += 1\\n            else:\\n                cur_len += max(0, ((start + carpetLen) - new_tiles[r][0]))\\n                res = max(res, min(carpetLen, cur_len))\\n                cur_len -= max(0, ((start + carpetLen) - new_tiles[r][0]))\\n                cur_len -= (new_tiles[l][1] - new_tiles[l][0] + 1) \\n                l += 1\\n                if l > r:\\n                    cur_len = new_tiles[r][1] - new_tiles[r][0] + 1\\n                    start = new_tiles[r][0]\\n                else:\\n                    start = new_tiles[l][0]\\n            res = max(res, min(carpetLen, cur_len))\\n        return max(res, min(carpetLen, cur_len))\\n\\t",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort(key = lambda x:x[0])\\n        new_tiles = [tiles[0]]\\n        for i in range(1,len(tiles)):\\n            s,e = tiles[i]\\n            if s == tiles[i-1][1] + 1:\\n                new_tiles[-1][1] = e\\n            else:\\n                new_tiles.append([s, e])\\n        l, r = 0, 0 \\n        cur_len,  res = 0, 0\\n        start = new_tiles[0][0]\\n        while l <=r and r < len(new_tiles):\\n            if new_tiles[r][1] - start +1 < carpetLen:\\n                cur_len += new_tiles[r][1] - new_tiles[r][0] + 1\\n                r += 1\\n            else:\\n                cur_len += max(0, ((start + carpetLen) - new_tiles[r][0]))\\n                res = max(res, min(carpetLen, cur_len))\\n                cur_len -= max(0, ((start + carpetLen) - new_tiles[r][0]))\\n                cur_len -= (new_tiles[l][1] - new_tiles[l][0] + 1) \\n                l += 1\\n                if l > r:\\n                    cur_len = new_tiles[r][1] - new_tiles[r][0] + 1\\n                    start = new_tiles[r][0]\\n                else:\\n                    start = new_tiles[l][0]\\n            res = max(res, min(carpetLen, cur_len))\\n        return max(res, min(carpetLen, cur_len))\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 2061324,
                "title": "python-prefixsum-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles = sorted(tiles, key = lambda x : x[0])\\n        prefix_sum = [0]\\n        res = 0\\n        for idx, (start, end) in enumerate(tiles):\\n            cur_cover = 0\\n            prefix_sum.append(prefix_sum[-1] + (end - start + 1))\\n            begin = max(0, end - carpetLen + 1)\\n            l, r = -1, len(tiles)\\n            while l + 1 < r:\\n                mid = (l + r) // 2 # >> 1\\n                if tiles[mid][0] <= begin:\\n                    l = mid\\n                else:\\n                    r = mid\\n            if tiles[max(0, l)][0] <= begin <= tiles[max(0, l)][1]:\\n                cur_cover += tiles[l][1] - begin + 1\\n            cur_cover += prefix_sum[idx + 1] - prefix_sum[l + 1]\\n            res = max(res, cur_cover)\\n        return res\\n    \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles = sorted(tiles, key = lambda x : x[0])\\n        prefix_sum = [0]\\n        res = 0\\n        for idx, (start, end) in enumerate(tiles):\\n            cur_cover = 0\\n            prefix_sum.append(prefix_sum[-1] + (end - start + 1))\\n            begin = max(0, end - carpetLen + 1)\\n            l, r = -1, len(tiles)\\n            while l + 1 < r:\\n                mid = (l + r) // 2 # >> 1\\n                if tiles[mid][0] <= begin:\\n                    l = mid\\n                else:\\n                    r = mid\\n            if tiles[max(0, l)][0] <= begin <= tiles[max(0, l)][1]:\\n                cur_cover += tiles[l][1] - begin + 1\\n            cur_cover += prefix_sum[idx + 1] - prefix_sum[l + 1]\\n            res = max(res, cur_cover)\\n        return res\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2049399,
                "title": "python-one-pass-with-skipping-window-o-nlogn-simple-explanation-beating-92",
                "content": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], leng: int) -> int:\\n        tiles.sort()\\n        cur = 0  # current coverage of the tiles\\n        ans = 0  # maximum of \\'cur\\' above\\n        q = deque()\\n        for i, j in tiles:\\n            \\n            # move the window all the way to reach the right corner j of current tile\\n            # any tile fall out of the window is deducted\\n            while q and q[0][1] < j - leng + 1:\\n                m, n = q.popleft()\\n                cur -= n-m+1\\n            \\n            # if the tile is half covered, we also need to deduct it,\\n            # and also update the coordinate of this half-covered tile\\n            # for example:\\n            #      _______\\n            # [1,2,3] [6,7], leng = 5\\n            if q and j-leng+1 > q[0][0]:\\n                cur -= (j-leng+1)-q[0][0]\\n                q[0] = (j-leng+1, q[0][1])\\n            \\n            # Adding the leng of current tile if it is fully in the windows\\n            # otherwise only add what is covered\\n            if leng >= j-i+1:\\n                cur += j-i+1\\n                q.append((i, j))\\n            else:\\n                cur += leng\\n                q.append((j-leng+1, j))\\n                \\n            ans = max(ans, cur)\\n            \\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], leng: int) -> int:\\n        tiles.sort()\\n        cur = 0  # current coverage of the tiles\\n        ans = 0  # maximum of \\'cur\\' above\\n        q = deque()\\n        for i, j in tiles:\\n            \\n            # move the window all the way to reach the right corner j of current tile\\n            # any tile fall out of the window is deducted\\n            while q and q[0][1] < j - leng + 1:\\n                m, n = q.popleft()\\n                cur -= n-m+1\\n            \\n            # if the tile is half covered, we also need to deduct it,\\n            # and also update the coordinate of this half-covered tile\\n            # for example:\\n            #      _______\\n            # [1,2,3] [6,7], leng = 5\\n            if q and j-leng+1 > q[0][0]:\\n                cur -= (j-leng+1)-q[0][0]\\n                q[0] = (j-leng+1, q[0][1])\\n            \\n            # Adding the leng of current tile if it is fully in the windows\\n            # otherwise only add what is covered\\n            if leng >= j-i+1:\\n                cur += j-i+1\\n                q.append((i, j))\\n            else:\\n                cur += leng\\n                q.append((j-leng+1, j))\\n                \\n            ans = max(ans, cur)\\n            \\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2049230,
                "title": "c-2271-maximum-white-tiles-covered-by-a-carpet",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(), tiles.end()); \\n        int ans = 0; \\n        for (int i = 0, j = 0, val = 0; i < tiles.size() && j < tiles.size(); ++i) {\\n            int hi = tiles[i][0] + carpetLen - 1; \\n            for (; j < tiles.size() && tiles[j][1] <= hi; ++j) \\n                val += tiles[j][1] - tiles[j][0] + 1; \\n            int partial = 0; \\n            if (j < tiles.size()) partial = max(0, hi - tiles[j][0] + 1); \\n            ans = max(ans, val + partial); \\n            val -= tiles[i][1] - tiles[i][0] + 1; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(), tiles.end()); \\n        int ans = 0; \\n        for (int i = 0, j = 0, val = 0; i < tiles.size() && j < tiles.size(); ++i) {\\n            int hi = tiles[i][0] + carpetLen - 1; \\n            for (; j < tiles.size() && tiles[j][1] <= hi; ++j) \\n                val += tiles[j][1] - tiles[j][0] + 1; \\n            int partial = 0; \\n            if (j < tiles.size()) partial = max(0, hi - tiles[j][0] + 1); \\n            ans = max(ans, val + partial); \\n            val -= tiles[i][1] - tiles[i][0] + 1; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046020,
                "title": "easy-c-using-map",
                "content": "```\\n//hope you like it\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpet) {\\n      sort(tiles.begin(),tiles.end());  \\n      ll l= tiles[0][0];\\n      map<ll,ll>left,right;\\n      ll count=0;\\n      for(int i=0;i<tiles.size();i++){\\n          left[tiles[i][1]]= tiles[i][0];\\n          count+= tiles[i][1]-tiles[i][0]+1;\\n          right[tiles[i][1]]=count;\\n      }\\n      count=0;\\n      ll cov=0;\\n      ll cap= carpet;\\n      for(int i=0;i<tiles.size();i++){\\n          ll frs,sec;\\n          count += tiles[i][1]- tiles[i][0]+1;\\n          if(tiles[i][1]-cap < l){\\n              sec= count;\\n          }\\n          else{\\n              ll r= tiles[i][1]- cap + 1;\\n              ll tot;\\n              if(right.find(r)!=right.end()){\\n                  tot= count - right.find(r)->second;\\n                  tot++;\\n                  sec=tot;\\n                 \\n              }\\n              else{\\n              auto it= right.upper_bound(r);\\n              tot= count - it->second;\\n              tot+= it->first - max(r,left[it->first]) + 1;\\n              sec= tot;\\n              \\n              }\\n          }\\n           cov = max(cov, sec);\\n      }\\n        return cov;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//hope you like it\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpet) {\\n      sort(tiles.begin(),tiles.end());  \\n      ll l= tiles[0][0];\\n      map<ll,ll>left,right;\\n      ll count=0;\\n      for(int i=0;i<tiles.size();i++){\\n          left[tiles[i][1]]= tiles[i][0];\\n          count+= tiles[i][1]-tiles[i][0]+1;\\n          right[tiles[i][1]]=count;\\n      }\\n      count=0;\\n      ll cov=0;\\n      ll cap= carpet;\\n      for(int i=0;i<tiles.size();i++){\\n          ll frs,sec;\\n          count += tiles[i][1]- tiles[i][0]+1;\\n          if(tiles[i][1]-cap < l){\\n              sec= count;\\n          }\\n          else{\\n              ll r= tiles[i][1]- cap + 1;\\n              ll tot;\\n              if(right.find(r)!=right.end()){\\n                  tot= count - right.find(r)->second;\\n                  tot++;\\n                  sec=tot;\\n                 \\n              }\\n              else{\\n              auto it= right.upper_bound(r);\\n              tot= count - it->second;\\n              tot+= it->first - max(r,left[it->first]) + 1;\\n              sec= tot;\\n              \\n              }\\n          }\\n           cov = max(cov, sec);\\n      }\\n        return cov;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043884,
                "title": "c-solution-using-binary-search-and-prefix-sum",
                "content": "```\\n int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        int n = tiles.size();\\n        sort(tiles.begin(), tiles.end());\\n        \\n        vector<int> prefSum(n);\\n        prefSum[0] = tiles[0][1] - tiles[0][0] + 1;\\n        for(int i = 1 ; i < n ; i++) {\\n            int len = tiles[i][1] - tiles[i][0] + 1;\\n            prefSum[i] = prefSum[i-1] + len;\\n        }\\n        \\n        vector<int> t(n);\\n        for(int i = 0 ; i < n ; i++) t[i] = tiles[i][0];\\n        \\n        int ans = 0;\\n        for(int i = 0 ; i < n ; i++) {\\n            int j = upper_bound(t.begin(), t.end(), carpetLen + t[i]) - t.begin();\\n            j--;\\n            \\n            int cover = 0;\\n            if(j > i) {\\n                cover += prefSum[j-1];\\n                if(i-1 >= 0) cover -= prefSum[i-1];\\n            }\\n            \\n            if(carpetLen + t[i] > tiles[j][1]) cover += tiles[j][1] - tiles[j][0] + 1;\\n            else cover += carpetLen + t[i] - t[j];\\n            \\n            ans = max(ans, cover);\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\n int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        int n = tiles.size();\\n        sort(tiles.begin(), tiles.end());\\n        \\n        vector<int> prefSum(n);\\n        prefSum[0] = tiles[0][1] - tiles[0][0] + 1;\\n        for(int i = 1 ; i < n ; i++) {\\n            int len = tiles[i][1] - tiles[i][0] + 1;\\n            prefSum[i] = prefSum[i-1] + len;\\n        }\\n        \\n        vector<int> t(n);\\n        for(int i = 0 ; i < n ; i++) t[i] = tiles[i][0];\\n        \\n        int ans = 0;\\n        for(int i = 0 ; i < n ; i++) {\\n            int j = upper_bound(t.begin(), t.end(), carpetLen + t[i]) - t.begin();\\n            j--;\\n            \\n            int cover = 0;\\n            if(j > i) {\\n                cover += prefSum[j-1];\\n                if(i-1 >= 0) cover -= prefSum[i-1];\\n            }\\n            \\n            if(carpetLen + t[i] > tiles[j][1]) cover += tiles[j][1] - tiles[j][0] + 1;\\n            else cover += carpetLen + t[i] - t[j];\\n            \\n            ans = max(ans, cover);\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2043770,
                "title": "java-readable-code-sliding-window",
                "content": "Java version of : https://leetcode.com/problems/maximum-white-tiles-covered-by-a-carpet/discuss/2038534/Sliding-Window    \\n````\\n    int end = 1;\\n    int start = 0;\\n    int maximumWhiteTiles(int[][] tiles, int len) {\\n        int result = 0, startTileIndex = 0, covered = 0;\\n\\n        Arrays.sort(tiles, Comparator.comparingInt(a -> a[0]));\\n\\n        for (int endTileIndex = 0; result < len && endTileIndex < tiles.length; )\\n            if (startTileIndex == endTileIndex || tiles[startTileIndex][start] + len > tiles[endTileIndex][end]) {\\n                covered += Math.min(len, tiles[endTileIndex][end] - tiles[endTileIndex][start] + 1);\\n                result = Math.max(result, covered);\\n                ++endTileIndex;\\n            }\\n            else {\\n                int partial = Math.max(0, tiles[startTileIndex][start] + len - tiles[endTileIndex][start]);\\n                result = Math.max(result, covered + partial);\\n                covered -= (tiles[startTileIndex][end] - tiles[startTileIndex][start] + 1);\\n                ++startTileIndex;\\n            }\\n\\n        return result;\\n    }",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "Java version of : https://leetcode.com/problems/maximum-white-tiles-covered-by-a-carpet/discuss/2038534/Sliding-Window    \\n````\\n    int end = 1;\\n    int start = 0;\\n    int maximumWhiteTiles(int[][] tiles, int len) {\\n        int result = 0, startTileIndex = 0, covered = 0;\\n\\n        Arrays.sort(tiles, Comparator.comparingInt(a -> a[0]));\\n\\n        for (int endTileIndex = 0; result < len && endTileIndex < tiles.length; )\\n            if (startTileIndex == endTileIndex || tiles[startTileIndex][start] + len > tiles[endTileIndex][end]) {\\n                covered += Math.min(len, tiles[endTileIndex][end] - tiles[endTileIndex][start] + 1);\\n                result = Math.max(result, covered);\\n                ++endTileIndex;\\n            }\\n            else {\\n                int partial = Math.max(0, tiles[startTileIndex][start] + len - tiles[endTileIndex][start]);\\n                result = Math.max(result, covered + partial);\\n                covered -= (tiles[startTileIndex][end] - tiles[startTileIndex][start] + 1);\\n                ++startTileIndex;\\n            }\\n\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2043755,
                "title": "easy-c-code-solve-with-two-pointer",
                "content": "```\\n\\nFirst sort tiles as it\\'s start value.\\nThen use two pointer i and j, initially both are 0;\\nif(data[j].second - data[i].first <  carpetLenth ) then move 2nd pointer otherwise move first pointer.\\nwhen carpetLen is less then took partial tiles of last taken tiles chunk.\\nEverytime we track the max value if anytime max value == carpetLen then we can return the result.\\n\\n\\nint maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(), tiles.end(),\\n          [](const std::vector<int>& a, const std::vector<int>& b) {\\n                      return a[0] < b[0];\\n                    });\\n        int res = 0;\\n        int val = 0;\\n        int pre = tiles[0][0];\\n        int pos = 0;\\n        for(int i=0;i<tiles.size();i++)\\n        {\\n            val = val + tiles[i][1] - tiles[i][0]+1;\\n            if(tiles[i][1] - pre+1 <= carpetLen) res = max(res, val);\\n            else \\n            {\\n                res = max(res, val - ((tiles[i][1] - pre+1) - carpetLen));\\n                if(pos<tiles.size()-1)\\n                {\\n                    pre = tiles[pos+1][0];\\n                    val = val - (tiles[pos][1] - tiles[pos][0]+1);\\n                    val = val - (tiles[i][1] - tiles[i][0]+1);\\n                    i--;\\n                    pos++;\\n                }\\n            }\\n            if(res == carpetLen) break;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n\\nFirst sort tiles as it\\'s start value.\\nThen use two pointer i and j, initially both are 0;\\nif(data[j].second - data[i].first <  carpetLenth ) then move 2nd pointer otherwise move first pointer.\\nwhen carpetLen is less then took partial tiles of last taken tiles chunk.\\nEverytime we track the max value if anytime max value == carpetLen then we can return the result.\\n\\n\\nint maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(), tiles.end(),\\n          [](const std::vector<int>& a, const std::vector<int>& b) {\\n                      return a[0] < b[0];\\n                    });\\n        int res = 0;\\n        int val = 0;\\n        int pre = tiles[0][0];\\n        int pos = 0;\\n        for(int i=0;i<tiles.size();i++)\\n        {\\n            val = val + tiles[i][1] - tiles[i][0]+1;\\n            if(tiles[i][1] - pre+1 <= carpetLen) res = max(res, val);\\n            else \\n            {\\n                res = max(res, val - ((tiles[i][1] - pre+1) - carpetLen));\\n                if(pos<tiles.size()-1)\\n                {\\n                    pre = tiles[pos+1][0];\\n                    val = val - (tiles[pos][1] - tiles[pos][0]+1);\\n                    val = val - (tiles[i][1] - tiles[i][0]+1);\\n                    i--;\\n                    pos++;\\n                }\\n            }\\n            if(res == carpetLen) break;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2042218,
                "title": "js-sliding-window-o-nlogn",
                "content": "````\\n/**\\n * @param {number[][]} tiles\\n * @param {number} carpetLen\\n * @return {number}\\n */\\nvar maximumWhiteTiles = function(tiles, carpetLen) {\\n    tiles.sort((a,b) => a[0]-b[0])\\n    \\n    let right=0\\n    let cover=0\\n    let maxCovered=0\\n    \\n    for(let tile of tiles) {\\n        let start=tile[0]\\n        let end=start+carpetLen-1\\n\\n        while(right < tiles.length && tiles[right][1] <= end) {\\n            cover+=tiles[right][1]-tiles[right][0]+1\\n            right++\\n        }\\n        if(right === tiles.length || end <= tiles[right][0]) {\\n            maxCovered=Math.max(maxCovered, cover)\\n        } else {\\n            let partial=end-tiles[right][0]+1\\n            maxCovered=Math.max(maxCovered, cover+partial)\\n        }\\n        \\n        cover-=(tile[1]-tile[0])+1\\n    }\\n    \\n    return maxCovered\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "````\\n/**\\n * @param {number[][]} tiles\\n * @param {number} carpetLen\\n * @return {number}\\n */\\nvar maximumWhiteTiles = function(tiles, carpetLen) {\\n    tiles.sort((a,b) => a[0]-b[0])\\n    \\n    let right=0\\n    let cover=0\\n    let maxCovered=0\\n    \\n    for(let tile of tiles) {\\n        let start=tile[0]\\n        let end=start+carpetLen-1\\n\\n        while(right < tiles.length && tiles[right][1] <= end) {\\n            cover+=tiles[right][1]-tiles[right][0]+1\\n            right++\\n        }\\n        if(right === tiles.length || end <= tiles[right][0]) {\\n            maxCovered=Math.max(maxCovered, cover)\\n        } else {\\n            let partial=end-tiles[right][0]+1\\n            maxCovered=Math.max(maxCovered, cover+partial)\\n        }\\n        \\n        cover-=(tile[1]-tile[0])+1\\n    }\\n    \\n    return maxCovered\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2041019,
                "title": "python-binary-search-easy",
                "content": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort(key=lambda x: x[0])\\n        ends = [t[1] for t in tiles]\\n        acc = [0]\\n        for a, b in tiles:\\n            acc.append(acc[-1] + b - a + 1)\\n\\n        def calc(start):\\n            end = bisect.bisect_left(ends, tiles[start][0] + carpetLen)\\n            sol = (max(tiles[start][0] + carpetLen - tiles[end][0], 0) if end < len(ends) else 0) + acc[end] - acc[\\n                start]\\n            return sol\\n\\n        return max(calc(start_index) for start_index in range(len(tiles)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort(key=lambda x: x[0])\\n        ends = [t[1] for t in tiles]\\n        acc = [0]\\n        for a, b in tiles:\\n            acc.append(acc[-1] + b - a + 1)\\n\\n        def calc(start):\\n            end = bisect.bisect_left(ends, tiles[start][0] + carpetLen)\\n            sol = (max(tiles[start][0] + carpetLen - tiles[end][0], 0) if end < len(ends) else 0) + acc[end] - acc[\\n                start]\\n            return sol\\n\\n        return max(calc(start_index) for start_index in range(len(tiles)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040625,
                "title": "easy-intuitive-proper-explaination-prefix-sum-binary-search-o-nlogn",
                "content": "1. Sort the array tiles of size n on the basis of left element of each pair. \\n2. Build an array prefix_sum where prefix_sum[i] represents the number of white tiles from tiles[0][0] to tiles[i -1][1] (both inclusive). Size of this array is n + 1. \\n3. Create another array lastInd to store right element of each pair, so that we can easily find the range which the carpet covers partially.\\n4. Now loop through the tiles array and consider each pair (m, n) :\\n   * Consider we start placing the carpet from m, then we need to find uptil which range this carpet      goes so we find the carpet\\'s end index, let\\'s say cend, \\n   * Find index of upper bound of cend, let\\'s say idx, to find number of white tiles carpet covers partially as well as fully.\\n   * Number of white tiles carpet covers partially = cend - tiles[idx][0] + 1, provided that idx < n and tiles[idx][0] <= cend as only then carpet covers some white tiles in the range (tiles[idx][0], tiles[idx][1]).\\n   * Number of white tiles carpet covers fully can be found out using the prefix_sum array, just remember to remove the white tiles before m(the index we start laying carpet from).\\n\\n    **Time Complexity = O(N*LogN)** (Upper bound takes LogN time)\\n\\t**Space Complexity = O(N)**\\n\\t\\n      Feel free to ***upvote*** if you like the solution. Thanks :)\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        // sort the array\\n        sort(tiles.begin(), tiles.end());\\n        int n = tiles.size();\\n\\t\\t\\n\\t\\t// build prefix sum array and an array to store last index of each range\\n        vector<int> prefix_sum(n + 1, 0);   // here size is taken as n + 1 for convenience\\n        vector<int> lastInd(n);\\n\\t\\t\\n        for(int i = 1; i <= n; i++) {\\n            prefix_sum[i] = prefix_sum[i - 1] + (tiles[i - 1][1] - tiles[i - 1][0] + 1);\\n            lastInd[i - 1] = tiles[i - 1][1];\\n        }\\n        \\n        int maxmTiles = 0;\\n        // loop through the tiles array consider the left of each pair as starting index to place carpet\\n       for(int i = 0; i < n; i++) {\\n           int start = tiles[i][0];\\n           int cend = start + carpetLen - 1;\\n           int indx = upper_bound(lastInd.begin(), lastInd.end(), cend) - lastInd.begin();\\n           int countTiles = prefix_sum[indx];\\n           \\n           if(indx < n && tiles[indx][0] <= cend) {\\n               countTiles += cend - tiles[indx][0] + 1;\\n           }\\n           if(i > 0) {\\n               countTiles -= prefix_sum[i];\\n           }\\n           maxmTiles = max(maxmTiles, countTiles);\\n       }\\n        return maxmTiles;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        // sort the array\\n        sort(tiles.begin(), tiles.end());\\n        int n = tiles.size();\\n\\t\\t\\n\\t\\t// build prefix sum array and an array to store last index of each range\\n        vector<int> prefix_sum(n + 1, 0);   // here size is taken as n + 1 for convenience\\n        vector<int> lastInd(n);\\n\\t\\t\\n        for(int i = 1; i <= n; i++) {\\n            prefix_sum[i] = prefix_sum[i - 1] + (tiles[i - 1][1] - tiles[i - 1][0] + 1);\\n            lastInd[i - 1] = tiles[i - 1][1];\\n        }\\n        \\n        int maxmTiles = 0;\\n        // loop through the tiles array consider the left of each pair as starting index to place carpet\\n       for(int i = 0; i < n; i++) {\\n           int start = tiles[i][0];\\n           int cend = start + carpetLen - 1;\\n           int indx = upper_bound(lastInd.begin(), lastInd.end(), cend) - lastInd.begin();\\n           int countTiles = prefix_sum[indx];\\n           \\n           if(indx < n && tiles[indx][0] <= cend) {\\n               countTiles += cend - tiles[indx][0] + 1;\\n           }\\n           if(i > 0) {\\n               countTiles -= prefix_sum[i];\\n           }\\n           maxmTiles = max(maxmTiles, countTiles);\\n       }\\n        return maxmTiles;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039502,
                "title": "deque-sliding-window",
                "content": "class Solution {\\n    public:\\n    \\n    int maxUtil(vector<vector<int>>&tiles,int carpetLen){\\n        \\n        int n=tiles.size();  \\n        deque<pair<int,int>>dq;\\n        deque<long long>v;\\n        long long prev=0;\\n        long long res=0;\\n        int j=0;\\n        for(int i=0;i<tiles.size();i++){\\n           long long end=tiles[i][0]+carpetLen-1;\\n            if(!dq.empty()){\\n            prev-=v.front();\\n            v.pop_front();\\n            dq.pop_front();\\n            }\\n                if(!dq.empty()){\\n                  prev-=v.back();\\n                    v.pop_back();\\n                    long long x=min((long long)dq.back().second,end)-dq.back().first+1;\\n                    v.push_back(x);\\n                    prev+=x;\\n                }\\n            while(j<n && tiles[j][0]<=end){\\n                dq.push_back({tiles[j][0],tiles[j][1]});\\n                long long x=min(end,(long long)tiles[j][1])-tiles[j][0]+1;\\n                v.push_back(x);\\n                prev+=x;\\n                j++;\\n            }\\n            res=max(res,prev);\\n       }\\n        return res;\\n    }\\n         \\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n     //so sliding window\\n     sort(tiles.begin(),tiles.end());\\n       return maxUtil(tiles,carpetLen);    \\n    }\\n};",
                "solutionTags": [
                    "Queue",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    public:\\n    \\n    int maxUtil(vector<vector<int>>&tiles,int carpetLen){\\n        \\n        int n=tiles.size();  \\n        deque<pair<int,int>>dq;\\n        deque<long long>v;\\n        long long prev=0;\\n        long long res=0;\\n        int j=0;\\n        for(int i=0;i<tiles.size();i++){\\n           long long end=tiles[i][0]+carpetLen-1;\\n            if(!dq.empty()){\\n            prev-=v.front();\\n            v.pop_front();\\n            dq.pop_front();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2039145,
                "title": "c-super-easy-sliding-window-solution-with-explanation-o-nlogn-time-o-1-time",
                "content": "```\\nclass Solution {\\npublic:\\n    //INTUITION: It is logical to count the length beginning from the start of an white tile interval only. Because say the interval is (5,8) and the carpet length is 2. So if we start at 5 or 6 the effect would be same. \\n    // and say (5,7) is white tiles and 8th is not, and again 9th is white. Now say the carpet length is 4. Now if we consider the carpet to cover 5,6,7,8 (3 white 1 gap) or 6,7,8,9 (3 white 1 gap). That\\'s also same effect even with non-white gaps in the middle.\\n    \\n    //ALGO: We consider every interval\\'s staring pt as a starting point for putting the carpet and keep updating the number of white tiles covered as found\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(),tiles.end());\\n        int ans = 0, whiteTilesCovered = 0, j = 0, prevRight = 0; //prevRight = previous carpet covering\\'s rightmost index\\n        for(int i = 0; i<tiles.size(); i++)\\n        {\\n            int left = tiles[i][0];\\n            int right = left+carpetLen-1; //max index till which the carpet can cover if started from the current index (current index = starting point of current white tile interval)\\n            \\n            if(i>0) whiteTilesCovered -= (min(prevRight, tiles[i-1][1])-tiles[i-1][0]+1); //removing the previosly considered carpet covering\\n            if (j > 0 && tiles[j-1][1] > prevRight) whiteTilesCovered += (min(right, tiles[j-1][1]) - prevRight); //adding current carpet covering (appearing before currently considered interval only)\\n            while (j < tiles.size() && tiles[j][0] <= right) \\n            {\\n                whiteTilesCovered += (min(right, tiles[j][1]) - tiles[j][0] + 1); //adding carpet covering for the currently considered interval\\n                ++j;\\n            }\\n            \\n            prevRight = right; \\n            ans = max(whiteTilesCovered,ans); //updating max carpet covering of white tiles\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //INTUITION: It is logical to count the length beginning from the start of an white tile interval only. Because say the interval is (5,8) and the carpet length is 2. So if we start at 5 or 6 the effect would be same. \\n    // and say (5,7) is white tiles and 8th is not, and again 9th is white. Now say the carpet length is 4. Now if we consider the carpet to cover 5,6,7,8 (3 white 1 gap) or 6,7,8,9 (3 white 1 gap). That\\'s also same effect even with non-white gaps in the middle.\\n    \\n    //ALGO: We consider every interval\\'s staring pt as a starting point for putting the carpet and keep updating the number of white tiles covered as found\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(),tiles.end());\\n        int ans = 0, whiteTilesCovered = 0, j = 0, prevRight = 0; //prevRight = previous carpet covering\\'s rightmost index\\n        for(int i = 0; i<tiles.size(); i++)\\n        {\\n            int left = tiles[i][0];\\n            int right = left+carpetLen-1; //max index till which the carpet can cover if started from the current index (current index = starting point of current white tile interval)\\n            \\n            if(i>0) whiteTilesCovered -= (min(prevRight, tiles[i-1][1])-tiles[i-1][0]+1); //removing the previosly considered carpet covering\\n            if (j > 0 && tiles[j-1][1] > prevRight) whiteTilesCovered += (min(right, tiles[j-1][1]) - prevRight); //adding current carpet covering (appearing before currently considered interval only)\\n            while (j < tiles.size() && tiles[j][0] <= right) \\n            {\\n                whiteTilesCovered += (min(right, tiles[j][1]) - tiles[j][0] + 1); //adding carpet covering for the currently considered interval\\n                ++j;\\n            }\\n            \\n            prevRight = right; \\n            ans = max(whiteTilesCovered,ans); //updating max carpet covering of white tiles\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038999,
                "title": "java-well-commented-o-nlog-n",
                "content": "```\\n    static int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        int result = 0;\\n        //Sorting tiles in ascending order based on starting position.\\n        Arrays.sort(tiles, new Comparator<int[]>(){public int compare(int[] t, int[] t1) {return t[0] - t1[0];}});\\n        \\n        int [] pfx = new int [tiles.length];\\n        //prefix sum of white tiles:\\n        pfx[0] = tiles[0][1] - tiles[0][0] + 1;\\n        for(int i = 1; i < tiles.length; i++) {\\n            pfx[i] = tiles[i][1] - tiles[i][0] + 1 + pfx[i-1];\\n        }\\n        \\n        //storing as key the ending position of a tile and the corresponding value is its index.\\n        TreeMap<Integer, Integer> t = new TreeMap<>();\\n        for(int i = 0; i < tiles.length; i++) \\n            t.put(tiles[i][1], i);\\n        \\n        \\n        \\n        for(int i = 0; i < tiles.length; i++) {\\n            int curScore = tiles[i][1] - tiles[i][0] + 1, remaining = carpetLen - curScore;\\n            //Finding closest tile that cannot be entirely covered with the remaining carpet length.\\n            Entry<Integer, Integer> e = t.higherEntry(remaining + tiles[i][1]);\\n            int sum = 0;\\n            //if there is no such tile, it means we can cover all tiles starting from current tile.\\n            if(e == null) {\\n                sum += pfx[pfx.length - 1] - pfx[i];\\n            }\\n            else {\\n                //tiles before index e.getValue() are guaranteed to be entirely covered by the carpet.\\n                sum += pfx[e.getValue()- 1] - pfx[i];\\n                //rest stores the remaining length of the carpet after covering tiles [tiles[i]...tiles[e.getValue()-1]] inclusive.\\n                int rest = carpetLen - (tiles[e.getValue()][0] - tiles[i][0]);\\n                if(rest > 0) {\\n                    //if there is still remaining portion of the carpet, we can add it to the sum too.\\n                    sum += rest;\\n                }\\n            }\\n            result = Math.max(result, curScore + sum);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    static int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        int result = 0;\\n        //Sorting tiles in ascending order based on starting position.\\n        Arrays.sort(tiles, new Comparator<int[]>(){public int compare(int[] t, int[] t1) {return t[0] - t1[0];}});\\n        \\n        int [] pfx = new int [tiles.length];\\n        //prefix sum of white tiles:\\n        pfx[0] = tiles[0][1] - tiles[0][0] + 1;\\n        for(int i = 1; i < tiles.length; i++) {\\n            pfx[i] = tiles[i][1] - tiles[i][0] + 1 + pfx[i-1];\\n        }\\n        \\n        //storing as key the ending position of a tile and the corresponding value is its index.\\n        TreeMap<Integer, Integer> t = new TreeMap<>();\\n        for(int i = 0; i < tiles.length; i++) \\n            t.put(tiles[i][1], i);\\n        \\n        \\n        \\n        for(int i = 0; i < tiles.length; i++) {\\n            int curScore = tiles[i][1] - tiles[i][0] + 1, remaining = carpetLen - curScore;\\n            //Finding closest tile that cannot be entirely covered with the remaining carpet length.\\n            Entry<Integer, Integer> e = t.higherEntry(remaining + tiles[i][1]);\\n            int sum = 0;\\n            //if there is no such tile, it means we can cover all tiles starting from current tile.\\n            if(e == null) {\\n                sum += pfx[pfx.length - 1] - pfx[i];\\n            }\\n            else {\\n                //tiles before index e.getValue() are guaranteed to be entirely covered by the carpet.\\n                sum += pfx[e.getValue()- 1] - pfx[i];\\n                //rest stores the remaining length of the carpet after covering tiles [tiles[i]...tiles[e.getValue()-1]] inclusive.\\n                int rest = carpetLen - (tiles[e.getValue()][0] - tiles[i][0]);\\n                if(rest > 0) {\\n                    //if there is still remaining portion of the carpet, we can add it to the sum too.\\n                    sum += rest;\\n                }\\n            }\\n            result = Math.max(result, curScore + sum);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038846,
                "title": "binary-search-with-prefix-sum",
                "content": "```\\nclass Solution {\\n\\npublic:\\n    #define ll long long int\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n          sort(tiles.begin(),tiles.end());\\n        ll n=tiles.size();\\n        vector<ll> t;\\n        for(int i=0;i<n;i++){\\n            t.push_back(tiles[i][0]);\\n        }\\n        vector<ll> pre(n,0);\\n        pre[0]=tiles[0][1]-tiles[0][0]+1;\\n        ll ans=INT_MIN;\\n        for(ll i=1;i<n;i++){\\n            pre[i]=pre[i-1]+(tiles[i][1]-tiles[i][0]+1);\\n        }\\n       \\n        for(ll i=0;i<n;i++){\\n        ll st=t[i];\\n        ll end=st+carpetLen;\\n          int idx=lower_bound(t.begin(),t.end(),end)-t.begin();\\n         if(idx==tiles.size()){\\n            ans=max(ans, (pre[n-1]-(i-1>=0?pre[i-1]:0)));\\n            \\n            }else{\\n              \\n                while(t[idx]>end){\\n                    idx--;\\n                }\\n                ll val=0;\\n                  if(tiles[idx][1]>=end){\\n                           val+=(end-tiles[idx][0]);\\n                      idx--;\\n                    }\\n                     val+=(idx>=0? pre[idx]:0)-(i-1>=0?pre[i-1]:0);\\n                  \\n               \\n                    ans=max(ans, val);\\n              \\n                \\n            }\\n            \\n            \\n        }\\n                        return ans;\\n      \\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    #define ll long long int\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n          sort(tiles.begin(),tiles.end());\\n        ll n=tiles.size();\\n        vector<ll> t;\\n        for(int i=0;i<n;i++){\\n            t.push_back(tiles[i][0]);\\n        }\\n        vector<ll> pre(n,0);\\n        pre[0]=tiles[0][1]-tiles[0][0]+1;\\n        ll ans=INT_MIN;\\n        for(ll i=1;i<n;i++){\\n            pre[i]=pre[i-1]+(tiles[i][1]-tiles[i][0]+1);\\n        }\\n       \\n        for(ll i=0;i<n;i++){\\n        ll st=t[i];\\n        ll end=st+carpetLen;\\n          int idx=lower_bound(t.begin(),t.end(),end)-t.begin();\\n         if(idx==tiles.size()){\\n            ans=max(ans, (pre[n-1]-(i-1>=0?pre[i-1]:0)));\\n            \\n            }else{\\n              \\n                while(t[idx]>end){\\n                    idx--;\\n                }\\n                ll val=0;\\n                  if(tiles[idx][1]>=end){\\n                           val+=(end-tiles[idx][0]);\\n                      idx--;\\n                    }\\n                     val+=(idx>=0? pre[idx]:0)-(i-1>=0?pre[i-1]:0);\\n                  \\n               \\n                    ans=max(ans, val);\\n              \\n                \\n            }\\n            \\n            \\n        }\\n                        return ans;\\n      \\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038489,
                "title": "c-easy-using-prefix-sum-and-upper-bound-o-n-logn",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& t, int len) {\\n        sort(t.begin(),t.end());\\n        vector<int> t1;\\n        t1.push_back(t[0][1]);\\n        int ans=0;\\n        vector<long> sum(t.size());\\n        sum[0]=t[0][1]-t[0][0]+1;\\n        for(int i=1;i<t.size();i++) { sum[i]=sum[i-1]+t[i][1]-t[i][0]+1; t1.push_back(t[i][1]); }\\n        for(int i=0;i<t.size();i++){\\n            int start=t[i][0];\\n            int end=min(t[i][0]+len-1,1000000000);\\n            auto it=upper_bound(t1.begin(),t1.end(),end);\\n            int pos;\\n            if(it==t1.end()) pos=t.size()-1; \\n            else pos=(it-t1.begin())-1;\\n            int res=0;\\n            //cout<<pos;\\n            if(pos>=0){\\n            res=sum[pos]-sum[i];\\n            res=res+t[i][1]-t[i][0]+1;\\n            }\\n            if(pos<(t.size()-1)||(pos<0)){\\n                pos++;\\n                if(t[pos][0]<=end) res+=end-t[pos][0]+1;\\n            }\\n            ans=max(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& t, int len) {\\n        sort(t.begin(),t.end());\\n        vector<int> t1;\\n        t1.push_back(t[0][1]);\\n        int ans=0;\\n        vector<long> sum(t.size());\\n        sum[0]=t[0][1]-t[0][0]+1;\\n        for(int i=1;i<t.size();i++) { sum[i]=sum[i-1]+t[i][1]-t[i][0]+1; t1.push_back(t[i][1]); }\\n        for(int i=0;i<t.size();i++){\\n            int start=t[i][0];\\n            int end=min(t[i][0]+len-1,1000000000);\\n            auto it=upper_bound(t1.begin(),t1.end(),end);\\n            int pos;\\n            if(it==t1.end()) pos=t.size()-1; \\n            else pos=(it-t1.begin())-1;\\n            int res=0;\\n            //cout<<pos;\\n            if(pos>=0){\\n            res=sum[pos]-sum[i];\\n            res=res+t[i][1]-t[i][0]+1;\\n            }\\n            if(pos<(t.size()-1)||(pos<0)){\\n                pos++;\\n                if(t[pos][0]<=end) res+=end-t[pos][0]+1;\\n            }\\n            ans=max(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2038447,
                "title": "python-sort-and-sliding-window",
                "content": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        T = len(tiles)\\n        tiles.sort()\\n        max_tiles = to = curr_tiles = 0\\n        for start, end in tiles:            \\n            while to < T and tiles[to][1] - start + 1 <= carpetLen:\\n                curr_tiles += tiles[to][1] - tiles[to][0] + 1\\n                to += 1\\n                \\n            if to < T and tiles[to][0] - start + 1 <= carpetLen:\\n                max_tiles = max(max_tiles, curr_tiles + start + carpetLen - tiles[to][0])\\n            else:\\n                max_tiles = max(max_tiles, curr_tiles)\\n            \\n            curr_tiles -= end - start + 1\\n                    \\n        return max_tiles\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        T = len(tiles)\\n        tiles.sort()\\n        max_tiles = to = curr_tiles = 0\\n        for start, end in tiles:            \\n            while to < T and tiles[to][1] - start + 1 <= carpetLen:\\n                curr_tiles += tiles[to][1] - tiles[to][0] + 1\\n                to += 1\\n                \\n            if to < T and tiles[to][0] - start + 1 <= carpetLen:\\n                max_tiles = max(max_tiles, curr_tiles + start + carpetLen - tiles[to][0])\\n            else:\\n                max_tiles = max(max_tiles, curr_tiles)\\n            \\n            curr_tiles -= end - start + 1\\n                    \\n        return max_tiles\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038445,
                "title": "converted-into-classical-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        int len=-1;\\n        int mim=INT_MAX;\\n        int til=0;\\n        for(int i=0;i<tiles.size();++i)\\n        {\\n            len=max(len,tiles[i][1]);\\n            mim=min(mim,tiles[i][0]);\\n            til+=(tiles[i][1]-tiles[i][0])+1;\\n        }\\n        int alen=len-mim+1;\\n        if(carpetLen>=alen)\\n        {\\n            return til;\\n        }\\n        string s(alen,\\'0\\');\\n        for(int i=0;i<tiles.size();++i)\\n        {\\n            for(int j=tiles[i][0];j<=tiles[i][1];++j)\\n            {\\n                s[j-mim]=\\'1\\';\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<carpetLen;++i)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                count++;\\n            }\\n        }\\n        int i=0,j=carpetLen,ans=0;\\n        while(j<=s.length())\\n        {\\n            ans=max(count,ans);\\n            if(s[j]==\\'1\\')\\n            {\\n                count+=1;\\n            }\\n            if(s[i]==\\'1\\')\\n            {\\n                count--;\\n            }\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        int len=-1;\\n        int mim=INT_MAX;\\n        int til=0;\\n        for(int i=0;i<tiles.size();++i)\\n        {\\n            len=max(len,tiles[i][1]);\\n            mim=min(mim,tiles[i][0]);\\n            til+=(tiles[i][1]-tiles[i][0])+1;\\n        }\\n        int alen=len-mim+1;\\n        if(carpetLen>=alen)\\n        {\\n            return til;\\n        }\\n        string s(alen,\\'0\\');\\n        for(int i=0;i<tiles.size();++i)\\n        {\\n            for(int j=tiles[i][0];j<=tiles[i][1];++j)\\n            {\\n                s[j-mim]=\\'1\\';\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<carpetLen;++i)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                count++;\\n            }\\n        }\\n        int i=0,j=carpetLen,ans=0;\\n        while(j<=s.length())\\n        {\\n            ans=max(count,ans);\\n            if(s[j]==\\'1\\')\\n            {\\n                count+=1;\\n            }\\n            if(s[i]==\\'1\\')\\n            {\\n                count--;\\n            }\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038400,
                "title": "c-sort-then-linear-search-with-explaination",
                "content": "First we can realize that we only would start the carpet at the start of a tile-set. If we started in the middle of a set, n tiles from the start, then we loose out on the first n tiles and could at most have only covered n new tiles, so we may as well have started at the left most tile in the set instead. So we can try placing the carpet at the start of each tile set and see which one covers the most tiles.\\n\\nIf we have a long carpet, when we go from the start of one tile-set to the next, we might fully or partially cover some other tile-set in both cases (spots with `|` mark the tiles that are covered in both cases):\\n```\\ncccccccccccccccccc\\nwwww www    wwww   wwww\\n     |||    ||||\\n     cccccccccccccccccc\\nwwww www    wwww   wwww\\n```\\n\\nRather than recalculating this fact, we can just check what\\'s newly covered and what\\'s now uncovered by keeping track of the previous starting and ending postions of the carpet (spots with `|` mark newly uncovered or covered tiles):\\n```\\ncccccccccccccccccc\\nwwww www    wwww   wwww\\n|||||             |||||\\n     cccccccccccccccccc\\nwwww www    wwww   wwww\\n```\\n\\nWe always uncover the whole last tile-set (in the above example, the first 4 white tiles) since we move the the start of the next tile-set. Then we calculate what the n new tiles to the left of the last ending tile cover. In this way we will only process each tile-set once and so besides the initial sorting of tiles, the counting takes O(N) time.\\n\\n```\\nclass Solution\\n{\\n  public:\\n    int maximumWhiteTiles(vector<vector<int>> &tiles, int carpetLen)\\n    {\\n        sort(tiles.begin(), tiles.end());\\n\\n        // Initialized so that the first tile starts \"fresh\"\\n        int lastStart = -carpetLen;\\n        int lastEnd = -1;\\n        int lastEndTileIndex = 0;\\n        int covered = 0;\\n        int maxCovered = 0;\\n\\n        for (int i = 0; i < tiles.size(); ++i)\\n        {\\n            if (i != 0)\\n            {\\n                // Remove the last tile-set that we started from\\n                covered -= tiles[i - 1][1] - tiles[i - 1][0] + 1;\\n            }\\n\\n            int newStart = tiles[i][0];\\n            int increase = min(newStart - lastStart, carpetLen);\\n            int sudoStart = max(newStart, lastEnd + 1);\\n            int sudoEnd = sudoStart + increase - 1;\\n\\n            // While the end of the additional carpet lenth covers at least 1 tile in the current set, mark those as covered and then try the next set.\\n            while (lastEndTileIndex < tiles.size() && sudoEnd >= tiles[lastEndTileIndex][0])\\n            {\\n                covered += min(sudoEnd, tiles[lastEndTileIndex][1]) - max(sudoStart, tiles[lastEndTileIndex][0]) + 1;\\n                ++lastEndTileIndex;\\n            }\\n\\n            maxCovered = max(maxCovered, covered);\\n\\t\\t\\t\\n\\t\\t\\t// When the carpet ends in the middle of a set, the while loop will have gone 1 set too far\\n\\t\\t\\tif (sudoEnd <= tiles[lastEndTileIndex - 1][1])\\n            {\\n                --lastEndTileIndex;\\n            }\\n\\t\\t\\t// Once the end of the carpet is past the last tile in the last tile-set, starting the carpet any further to the right will only remove tiles\\n            else if (lastEndTileIndex == tiles.size())\\n            {\\n                break;\\n            }\\n\\n            lastStart = newStart;\\n            lastEnd = sudoEnd;\\n        }\\n\\n        return maxCovered;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ncccccccccccccccccc\\nwwww www    wwww   wwww\\n     |||    ||||\\n     cccccccccccccccccc\\nwwww www    wwww   wwww\\n```\n```\\ncccccccccccccccccc\\nwwww www    wwww   wwww\\n|||||             |||||\\n     cccccccccccccccccc\\nwwww www    wwww   wwww\\n```\n```\\nclass Solution\\n{\\n  public:\\n    int maximumWhiteTiles(vector<vector<int>> &tiles, int carpetLen)\\n    {\\n        sort(tiles.begin(), tiles.end());\\n\\n        // Initialized so that the first tile starts \"fresh\"\\n        int lastStart = -carpetLen;\\n        int lastEnd = -1;\\n        int lastEndTileIndex = 0;\\n        int covered = 0;\\n        int maxCovered = 0;\\n\\n        for (int i = 0; i < tiles.size(); ++i)\\n        {\\n            if (i != 0)\\n            {\\n                // Remove the last tile-set that we started from\\n                covered -= tiles[i - 1][1] - tiles[i - 1][0] + 1;\\n            }\\n\\n            int newStart = tiles[i][0];\\n            int increase = min(newStart - lastStart, carpetLen);\\n            int sudoStart = max(newStart, lastEnd + 1);\\n            int sudoEnd = sudoStart + increase - 1;\\n\\n            // While the end of the additional carpet lenth covers at least 1 tile in the current set, mark those as covered and then try the next set.\\n            while (lastEndTileIndex < tiles.size() && sudoEnd >= tiles[lastEndTileIndex][0])\\n            {\\n                covered += min(sudoEnd, tiles[lastEndTileIndex][1]) - max(sudoStart, tiles[lastEndTileIndex][0]) + 1;\\n                ++lastEndTileIndex;\\n            }\\n\\n            maxCovered = max(maxCovered, covered);\\n\\t\\t\\t\\n\\t\\t\\t// When the carpet ends in the middle of a set, the while loop will have gone 1 set too far\\n\\t\\t\\tif (sudoEnd <= tiles[lastEndTileIndex - 1][1])\\n            {\\n                --lastEndTileIndex;\\n            }\\n\\t\\t\\t// Once the end of the carpet is past the last tile in the last tile-set, starting the carpet any further to the right will only remove tiles\\n            else if (lastEndTileIndex == tiles.size())\\n            {\\n                break;\\n            }\\n\\n            lastStart = newStart;\\n            lastEnd = sudoEnd;\\n        }\\n\\n        return maxCovered;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038398,
                "title": "swift-sorting-prefix-sum-two-pointers",
                "content": "- Sort the tiles by start position\\n- Pre-compute `sums` where `sums[i]` is number of white tiles from `0 -> i`\\n- Iterate over every index `right` from `0..<n`\\n\\t- We try to put the carpet\\'s end at `sorted[right][1]` ~ `end = sorted[right][1]`\\n\\t- As we already know `end` and `carpetLen`, we should also know `start = end - carpetLen + 1`\\n\\t- We keep track an index `left` denoting the furthest tile on the left that the carpet may cover (entirely or partially). As long as `sorted[left][1] < start`, we eliminate `sorted[left]` as it\\'s no longer covered by the carpet\\n\\t- In the end, the carpet may partially cover `sorted[left]` (`sorted[left][0] <= start`) so we need to update the covered area accordingly\\n\\n```swift\\nclass Solution {\\n  func maximumWhiteTiles(_ tiles: [[Int]], _ carpetLen: Int) -> Int {\\n    func length(_ tile: [Int]) -> Int {\\n      tile[1] - tile[0] + 1\\n    }\\n    \\n    let n = tiles.count\\n    let sorted = tiles.sorted { $0[0] < $1[0] }\\n    var sums = [Int](), sum = 0\\n    for tile in sorted {\\n      sum += length(tile)\\n      sums.append(sum)\\n    }\\n    \\n    var res = 0, left = 0\\n    for right in 0..<n {\\n      var curr = left == 0 ? sums[right] : sums[right] - sums[left - 1]\\n      \\n      let start = sorted[right][1] - carpetLen + 1\\n      while left < right, sorted[left][1] < start {\\n        curr -= length(sorted[left])\\n        left += 1\\n      }\\n      \\n      curr -= max(0, start - sorted[left][0])\\n      res = max(res, curr)\\n    }\\n    \\n    return res\\n  }\\n}\\n// Time complexity: O(nlogn) \\n// Space complexity: O(n)\\n```",
                "solutionTags": [
                    "Swift",
                    "Two Pointers",
                    "Sliding Window",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```swift\\nclass Solution {\\n  func maximumWhiteTiles(_ tiles: [[Int]], _ carpetLen: Int) -> Int {\\n    func length(_ tile: [Int]) -> Int {\\n      tile[1] - tile[0] + 1\\n    }\\n    \\n    let n = tiles.count\\n    let sorted = tiles.sorted { $0[0] < $1[0] }\\n    var sums = [Int](), sum = 0\\n    for tile in sorted {\\n      sum += length(tile)\\n      sums.append(sum)\\n    }\\n    \\n    var res = 0, left = 0\\n    for right in 0..<n {\\n      var curr = left == 0 ? sums[right] : sums[right] - sums[left - 1]\\n      \\n      let start = sorted[right][1] - carpetLen + 1\\n      while left < right, sorted[left][1] < start {\\n        curr -= length(sorted[left])\\n        left += 1\\n      }\\n      \\n      curr -= max(0, start - sorted[left][0])\\n      res = max(res, curr)\\n    }\\n    \\n    return res\\n  }\\n}\\n// Time complexity: O(nlogn) \\n// Space complexity: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038342,
                "title": "javascript-greedy-prefix-sum-binary-search-398ms",
                "content": "Main idea: \\n(1) sort the array by left, since intervals are non-overlapping, so after sorting  pre[r] < cur[l] always met\\n(2) answer is greedy for each intervals L, calulate the covered length(use), and max to result.\\n(3) how to caculate each covered length(use), find the possible R is in which interval use binary search upper_bound()\\n(4) for calculate the covered length, we need the prefix sum array of each interval distance\\nTC: 5 * n * logn\\n```\\n///////////////////////////////////////////////// Template /////////////////////////////////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] > x ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\nconst preSum = (a) => { let pre = [0]; for (let i = 0; i < a.length; i++) { pre.push(pre[i] + a[i]); } return pre; };\\nconst subArraySum = (a, l, r) => a[r + 1] - a[l];\\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nconst maximumWhiteTiles = (tiles, carpetLen) => {\\n    tiles.sort((x, y) => x[0] - y[0]);\\n    let n = tiles.length, a = tiles.map(x => x[0]), dis = tiles.map(e => e[1] - e[0] + 1), bi = new Bisect();\\n    let pre = preSum(dis), res = Number.MIN_SAFE_INTEGER;\\n    for (let i = 0; i < n; i++) {\\n        let l = tiles[i][0];\\n        let end = l + carpetLen - 1;\\n        let idx = bi.bisect_right(a, end) - 1; // step 3, possible R,  upperbound() - 1, first value > end, -1 must <= \\n        let stop = tiles[idx];\\n        let lastLen = Math.min(end, stop[1]) - stop[0] + 1; // tiles[idx] coverage\\n        let rangeSum = subArraySum(pre, i, idx - 1); // [l, idx - 1] covered length use prefix sum\\n        let use = rangeSum + lastLen; // covered length\\n        res = Math.max(res, use);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\n///////////////////////////////////////////////// Template /////////////////////////////////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] > x ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\nconst preSum = (a) => { let pre = [0]; for (let i = 0; i < a.length; i++) { pre.push(pre[i] + a[i]); } return pre; };\\nconst subArraySum = (a, l, r) => a[r + 1] - a[l];\\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nconst maximumWhiteTiles = (tiles, carpetLen) => {\\n    tiles.sort((x, y) => x[0] - y[0]);\\n    let n = tiles.length, a = tiles.map(x => x[0]), dis = tiles.map(e => e[1] - e[0] + 1), bi = new Bisect();\\n    let pre = preSum(dis), res = Number.MIN_SAFE_INTEGER;\\n    for (let i = 0; i < n; i++) {\\n        let l = tiles[i][0];\\n        let end = l + carpetLen - 1;\\n        let idx = bi.bisect_right(a, end) - 1; // step 3, possible R,  upperbound() - 1, first value > end, -1 must <= \\n        let stop = tiles[idx];\\n        let lastLen = Math.min(end, stop[1]) - stop[0] + 1; // tiles[idx] coverage\\n        let rangeSum = subArraySum(pre, i, idx - 1); // [l, idx - 1] covered length use prefix sum\\n        let use = rangeSum + lastLen; // covered length\\n        res = Math.max(res, use);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038236,
                "title": "python-solution",
                "content": "```\\ntiles.sort(key = lambda x: x[1])\\nstarts, ends, sums = [], [], []\\npSums = defaultdict(int)\\ncur = 0\\nfor a, b in tiles:\\n\\tstarts.append(a)\\n\\tends.append(b)\\n\\tsums.append(b - a + 1)\\n\\tcur += b - a + 1\\n\\tpSums[b] = cur\\nresult = 0\\nfor i, a in enumerate(ends):\\n\\tj = bisect_left(ends, a - carpetLen)\\n\\tb = ends[j]\\n\\tif a == b:\\n\\t\\tresult = max(result, min(sums[i], carpetLen))\\n\\telse:\\n\\t\\tif carpetLen - (a - starts[j]) - 1 < 0:\\n\\t\\t\\tresult = max(result, pSums[a] - pSums[b] + (carpetLen - (a - b)))\\n\\t\\telse:\\n\\t\\t\\tresult = max(result, pSums[a] - (pSums[ends[j - 1]] if j > 0 else 0))\\nreturn result\\n```",
                "solutionTags": [],
                "code": "```\\ntiles.sort(key = lambda x: x[1])\\nstarts, ends, sums = [], [], []\\npSums = defaultdict(int)\\ncur = 0\\nfor a, b in tiles:\\n\\tstarts.append(a)\\n\\tends.append(b)\\n\\tsums.append(b - a + 1)\\n\\tcur += b - a + 1\\n\\tpSums[b] = cur\\nresult = 0\\nfor i, a in enumerate(ends):\\n\\tj = bisect_left(ends, a - carpetLen)\\n\\tb = ends[j]\\n\\tif a == b:\\n\\t\\tresult = max(result, min(sums[i], carpetLen))\\n\\telse:\\n\\t\\tif carpetLen - (a - starts[j]) - 1 < 0:\\n\\t\\t\\tresult = max(result, pSums[a] - pSums[b] + (carpetLen - (a - b)))\\n\\t\\telse:\\n\\t\\t\\tresult = max(result, pSums[a] - (pSums[ends[j - 1]] if j > 0 else 0))\\nreturn result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038182,
                "title": "java-binary-search-prefix-sum-commented-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public static int search(int [][]arr,int ele,int n){\\n        int l=0,r=n-1,mid,ans=0;\\n        while(l<=r){\\n            mid=(l+r)/2;\\n            if(arr[mid][0]<=ele && arr[mid][1]>=ele){\\n                return mid;\\n            }\\n            else if(arr[mid][0]>ele){\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return r;\\n    }\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        int n=tiles.length;\\n        // Sort the array by there starting position so that it helps us in binary search\\n        Arrays.sort(tiles,new SortByFirst());\\n        int pref[]=new int[n];\\n        // Create the prefix sum of number of tiles at every position so that it helps us to find total number of tiles between any two indices quickly\\n        for(int i=0;i<n;i++){\\n            pref[i]=tiles[i][1]-tiles[i][0]+1;\\n        }\\n        for(int i=1;i<n;i++){\\n            pref[i]+=pref[i-1];\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            // Let\\'s suppose if we put carpet starting at position tiles[i][0] then what will be its ending point...Wait?\\n            // Yes you are correct it will end at {tiles[i]+carpetLen-1} then that\\'s all find out the index of ending point\\n            int idx=search(tiles,tiles[i][0]+carpetLen-1,n);\\n            int extra=0;\\n            if(tiles[idx][0]<=tiles[i][0]+carpetLen-1 && tiles[idx][1]>=tiles[i][0]+carpetLen-1){\\n                extra=tiles[i][0]+carpetLen-tiles[idx][0];\\n                idx--;\\n            }\\n            // Now use the prefic sum to find number of carpet between the starting point and ending point and get the max one...ACCEPTED\\n            ans=Math.max(ans,(idx<0?0:pref[idx])-(i-1<0?0:pref[i-1])+extra);\\n        }\\n        return ans;\\n    }\\n    static class SortByFirst implements Comparator<int[]>{\\n        public int compare(int []a,int []b){\\n            return a[0]-b[0];\\n        }\\n    }\\n}\\n\\n//Time Complexity-> O(n*log(n))\\n//Space Complexity-> O(n)\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public static int search(int [][]arr,int ele,int n){\\n        int l=0,r=n-1,mid,ans=0;\\n        while(l<=r){\\n            mid=(l+r)/2;\\n            if(arr[mid][0]<=ele && arr[mid][1]>=ele){\\n                return mid;\\n            }\\n            else if(arr[mid][0]>ele){\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return r;\\n    }\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        int n=tiles.length;\\n        // Sort the array by there starting position so that it helps us in binary search\\n        Arrays.sort(tiles,new SortByFirst());\\n        int pref[]=new int[n];\\n        // Create the prefix sum of number of tiles at every position so that it helps us to find total number of tiles between any two indices quickly\\n        for(int i=0;i<n;i++){\\n            pref[i]=tiles[i][1]-tiles[i][0]+1;\\n        }\\n        for(int i=1;i<n;i++){\\n            pref[i]+=pref[i-1];\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            // Let\\'s suppose if we put carpet starting at position tiles[i][0] then what will be its ending point...Wait?\\n            // Yes you are correct it will end at {tiles[i]+carpetLen-1} then that\\'s all find out the index of ending point\\n            int idx=search(tiles,tiles[i][0]+carpetLen-1,n);\\n            int extra=0;\\n            if(tiles[idx][0]<=tiles[i][0]+carpetLen-1 && tiles[idx][1]>=tiles[i][0]+carpetLen-1){\\n                extra=tiles[i][0]+carpetLen-tiles[idx][0];\\n                idx--;\\n            }\\n            // Now use the prefic sum to find number of carpet between the starting point and ending point and get the max one...ACCEPTED\\n            ans=Math.max(ans,(idx<0?0:pref[idx])-(i-1<0?0:pref[i-1])+extra);\\n        }\\n        return ans;\\n    }\\n    static class SortByFirst implements Comparator<int[]>{\\n        public int compare(int []a,int []b){\\n            return a[0]-b[0];\\n        }\\n    }\\n}\\n\\n//Time Complexity-> O(n*log(n))\\n//Space Complexity-> O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038159,
                "title": "c-binary-search-problem-and-prefix-sum-problem",
                "content": "Time Complexity : O(n log n)\\nSpace Complexity : O(n)\\n```\\nclass Solution {\\npublic:\\n    \\n    static bool comparator(vector<int>&a,vector<int>&b){\\n        if(a[0]<b[0])\\n            return true;\\n        if(a[0]==b[0])\\n            return a[1]<=b[1];\\n        return false;\\n    }\\n    \\n    int binSearch(vector<vector<int>>&tiles,int size,int tar){\\n        int l = 0;\\n        int u = size-1;\\n        \\n        while(l+1<u){\\n            int mid = (l+u)/2;\\n            \\n            if(tiles[mid][0]<=tar&&tar<=tiles[mid][1])\\n                return mid;\\n            \\n            if(tiles[mid][1]<tar){\\n                l=mid;\\n            }\\n            else u=mid;\\n        }\\n        \\n        //cout<<\"tar : \"<<tar<<endl;\\n        \\n        if(tiles[l][0]<=tar&&tar<=tiles[l][1])\\n            return l;\\n        \\n        if(tar<tiles[u][0])\\n            return l;\\n        \\n        if(tar>=tiles[u][0])\\n            return u;\\n        return u;\\n    }\\n    \\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        \\n        sort(tiles.begin(),tiles.end(),comparator);\\n        \\n        int i=0;\\n        int size=tiles.size();\\n        \\n        int maxi=0;\\n        \\n        int sum=0;\\n        \\n        /*cout<<\"Tile : \";\\n        for(auto ele:tiles){\\n            cout<<ele[0]<<\" \"<<ele[1]<<\" ; \";\\n        }\\n        cout<<endl;*/\\n        \\n        vector<int>prefS={0};\\n        for(auto ele:tiles){\\n            sum+=(ele[1]-ele[0]+1);\\n            prefS.push_back(sum);\\n        }\\n        \\n        /*for(auto ele:prefS){\\n            cout<<ele<<\" \";\\n        }\\n        cout<<endl;*/\\n        \\n        \\n        while(i<size){\\n            int start=tiles[i][0];\\n            int tar=start+carpetLen-1;\\n            int ind = binSearch(tiles,size,tar);\\n            \\n            //cout<<ind<<endl;\\n            \\n            int tSum = (prefS[ind]-prefS[i]);\\n            \\n            \\n            if(/*tiles[ind][0]<=tar&&*/tar<=tiles[ind][1]){\\n                tSum+=(tar-tiles[ind][0])+1;\\n                \\n            }\\n            else if(tar>tiles[ind][1]){\\n                tSum+=(tiles[ind][1]-tiles[ind][0]+1);\\n            }\\n            \\n            //cout<<tSum<<endl;\\n            maxi=max(maxi,tSum);\\n            i++;\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool comparator(vector<int>&a,vector<int>&b){\\n        if(a[0]<b[0])\\n            return true;\\n        if(a[0]==b[0])\\n            return a[1]<=b[1];\\n        return false;\\n    }\\n    \\n    int binSearch(vector<vector<int>>&tiles,int size,int tar){\\n        int l = 0;\\n        int u = size-1;\\n        \\n        while(l+1<u){\\n            int mid = (l+u)/2;\\n            \\n            if(tiles[mid][0]<=tar&&tar<=tiles[mid][1])\\n                return mid;\\n            \\n            if(tiles[mid][1]<tar){\\n                l=mid;\\n            }\\n            else u=mid;\\n        }\\n        \\n        //cout<<\"tar : \"<<tar<<endl;\\n        \\n        if(tiles[l][0]<=tar&&tar<=tiles[l][1])\\n            return l;\\n        \\n        if(tar<tiles[u][0])\\n            return l;\\n        \\n        if(tar>=tiles[u][0])\\n            return u;\\n        return u;\\n    }\\n    \\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        \\n        sort(tiles.begin(),tiles.end(),comparator);\\n        \\n        int i=0;\\n        int size=tiles.size();\\n        \\n        int maxi=0;\\n        \\n        int sum=0;\\n        \\n        /*cout<<\"Tile : \";\\n        for(auto ele:tiles){\\n            cout<<ele[0]<<\" \"<<ele[1]<<\" ; \";\\n        }\\n        cout<<endl;*/\\n        \\n        vector<int>prefS={0};\\n        for(auto ele:tiles){\\n            sum+=(ele[1]-ele[0]+1);\\n            prefS.push_back(sum);\\n        }\\n        \\n        /*for(auto ele:prefS){\\n            cout<<ele<<\" \";\\n        }\\n        cout<<endl;*/\\n        \\n        \\n        while(i<size){\\n            int start=tiles[i][0];\\n            int tar=start+carpetLen-1;\\n            int ind = binSearch(tiles,size,tar);\\n            \\n            //cout<<ind<<endl;\\n            \\n            int tSum = (prefS[ind]-prefS[i]);\\n            \\n            \\n            if(/*tiles[ind][0]<=tar&&*/tar<=tiles[ind][1]){\\n                tSum+=(tar-tiles[ind][0])+1;\\n                \\n            }\\n            else if(tar>tiles[ind][1]){\\n                tSum+=(tiles[ind][1]-tiles[ind][0]+1);\\n            }\\n            \\n            //cout<<tSum<<endl;\\n            maxi=max(maxi,tSum);\\n            i++;\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2038158,
                "title": "java-binary-search-with-treemap",
                "content": "Idea is to iterate over each of the tile, consider it as the starting point of where you begin to keep your carpet. Check how far can it go. This can be done using Binary Search.\\n\\n```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        int n = tiles.length;\\n        Arrays.sort(tiles, Comparator.comparingInt(a -> a[0])); // sorting tiles by starting index\\n        TreeMap<Integer , Integer> map = new TreeMap<>(); // TreeMap to perform binary search\\n        Map<Integer,Integer> idxMap = new HashMap<>(); // stores starting of interval against the index\\n        long[] pre = new long[n+1]; // stores prefix sums \\n        int idx = 0;\\n        for(int[] tile : tiles) {\\n            map.put(tile[0], tile[1]);\\n            pre[idx + 1] = (tile[1] - tile[0] + 1) + pre[idx];\\n            idxMap.put(tile[0] , idx++);\\n        }\\n        idx = 0;\\n        int max = 0;\\n        for(int key : map.keySet()){\\n            int end = key + carpetLen - 1; // how far can u stretch your carpet\\n            Map.Entry<Integer,Integer> entry = map.floorEntry(end);\\n            int endIdx = idxMap.get(entry.getKey());\\n            if(endIdx >= idx){\\n                int temp = (int) (pre[endIdx] - pre[idx]);\\n                if(entry.getValue() >= end)\\n                    temp += end -  (entry.getKey()) + 1;\\n                else\\n                    temp += (entry.getValue() - entry.getKey() + 1);\\n                max = Math.max(temp , max);\\n            }\\n            idx++;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        int n = tiles.length;\\n        Arrays.sort(tiles, Comparator.comparingInt(a -> a[0])); // sorting tiles by starting index\\n        TreeMap<Integer , Integer> map = new TreeMap<>(); // TreeMap to perform binary search\\n        Map<Integer,Integer> idxMap = new HashMap<>(); // stores starting of interval against the index\\n        long[] pre = new long[n+1]; // stores prefix sums \\n        int idx = 0;\\n        for(int[] tile : tiles) {\\n            map.put(tile[0], tile[1]);\\n            pre[idx + 1] = (tile[1] - tile[0] + 1) + pre[idx];\\n            idxMap.put(tile[0] , idx++);\\n        }\\n        idx = 0;\\n        int max = 0;\\n        for(int key : map.keySet()){\\n            int end = key + carpetLen - 1; // how far can u stretch your carpet\\n            Map.Entry<Integer,Integer> entry = map.floorEntry(end);\\n            int endIdx = idxMap.get(entry.getKey());\\n            if(endIdx >= idx){\\n                int temp = (int) (pre[endIdx] - pre[idx]);\\n                if(entry.getValue() >= end)\\n                    temp += end -  (entry.getKey()) + 1;\\n                else\\n                    temp += (entry.getValue() - entry.getKey() + 1);\\n                max = Math.max(temp , max);\\n            }\\n            idx++;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063741,
                "title": "easy-to-understand-sliding-window-java-solution-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen)\\n    {\\n        final int n = tiles.length;\\n        final long[] pref = new long[n + 1];\\n\\n        if (n == 1) \\n        {\\n            return Integer.min(carpetLen, tiles[0][1] - tiles[0][0] + 1);\\n        }\\n\\n        Arrays.sort(tiles, (a, b) -> a[0] - b[0]);        \\n\\n        for (int i = 1; i <= n; i++)\\n        {\\n            pref[i] = pref[i - 1] + (tiles[i - 1][1] - tiles[i - 1][0] + 1);\\n        }\\n\\n        int ans = 0;\\n;\\n        for (int i = 0, j = 0; j < n; j++)\\n        {\\n            while(i <= j && tiles[j][1] - tiles[i][0] + 1 > carpetLen)\\n            {\\n                int mid = tiles[i][0] + carpetLen - 1;\\n\\n                if (mid >= tiles[j][0] && mid <= tiles[j][1]) \\n                {\\n                    ans = Integer.max(ans, (int) (pref[j] - pref[i]) + (mid - tiles[j][0] + 1));\\n                }\\n\\n                i++;\\n            }\\n\\n            ans = Integer.max(ans,  (int) (pref[j + 1] - pref[i]));\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen)\\n    {\\n        final int n = tiles.length;\\n        final long[] pref = new long[n + 1];\\n\\n        if (n == 1) \\n        {\\n            return Integer.min(carpetLen, tiles[0][1] - tiles[0][0] + 1);\\n        }\\n\\n        Arrays.sort(tiles, (a, b) -> a[0] - b[0]);        \\n\\n        for (int i = 1; i <= n; i++)\\n        {\\n            pref[i] = pref[i - 1] + (tiles[i - 1][1] - tiles[i - 1][0] + 1);\\n        }\\n\\n        int ans = 0;\\n;\\n        for (int i = 0, j = 0; j < n; j++)\\n        {\\n            while(i <= j && tiles[j][1] - tiles[i][0] + 1 > carpetLen)\\n            {\\n                int mid = tiles[i][0] + carpetLen - 1;\\n\\n                if (mid >= tiles[j][0] && mid <= tiles[j][1]) \\n                {\\n                    ans = Integer.max(ans, (int) (pref[j] - pref[i]) + (mid - tiles[j][0] + 1));\\n                }\\n\\n                i++;\\n            }\\n\\n            ans = Integer.max(ans,  (int) (pref[j + 1] - pref[i]));\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960454,
                "title": "python-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom bisect import bisect_left\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        \\n        stc=[]\\n        pre=[]\\n        l=0\\n        tiles.sort()\\n        last=0\\n        maxx=0\\n        for i in tiles:\\n            stc.append(i[0])\\n            stc.append(i[1])\\n            pre.append(i[1]-i[0]+1+last)\\n            l+=2\\n            last=pre[-1]\\n        for i in range(l//2):\\n            K=bisect_left(stc,tiles[i][0]+carpetLen-1)\\n            ind=(K)//2\\n            tt=0\\n            if ind!=i:\\n                tt+=pre[ind-1]-pre[i]+(tiles[i][1]-tiles[i][0]+1)\\n            \\n            if K%2==1:\\n                tt+=(tiles[i][0]+carpetLen-stc[K-1])\\n            elif K<l and tiles[i][0]+carpetLen-1 == stc[K]:\\n                tt+=1\\n            maxx=max(maxx,tt)\\n        return maxx\\n                \\n            \\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom bisect import bisect_left\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        \\n        stc=[]\\n        pre=[]\\n        l=0\\n        tiles.sort()\\n        last=0\\n        maxx=0\\n        for i in tiles:\\n            stc.append(i[0])\\n            stc.append(i[1])\\n            pre.append(i[1]-i[0]+1+last)\\n            l+=2\\n            last=pre[-1]\\n        for i in range(l//2):\\n            K=bisect_left(stc,tiles[i][0]+carpetLen-1)\\n            ind=(K)//2\\n            tt=0\\n            if ind!=i:\\n                tt+=pre[ind-1]-pre[i]+(tiles[i][1]-tiles[i][0]+1)\\n            \\n            if K%2==1:\\n                tt+=(tiles[i][0]+carpetLen-stc[K-1])\\n            elif K<l and tiles[i][0]+carpetLen-1 == stc[K]:\\n                tt+=1\\n            maxx=max(maxx,tt)\\n        return maxx\\n                \\n            \\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900086,
                "title": "long-but-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        int ans = 0;\\n        int n = tiles.size();\\n        sort(tiles.begin(),tiles.end());\\n        vector<int> arr(n);\\n\\n        for(int i=0;i<n;i++){\\n            arr[i] = tiles[i][1] - tiles[i][0] +1;\\n            if(i>0) arr[i] = arr[i] + arr[i-1];\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int leftEnd=tiles[i][0], rightEnd = tiles[i][0]+carpetLen-1;\\n            int l = i, r=n-1; int left = i, right=i-1;\\n\\n            while(l<=r){\\n                int mid = (l+r)/2;\\n                if(tiles[mid][1] <= rightEnd){\\n                    right = mid;\\n                    l=mid+1;\\n                }else{\\n                    r = mid-1;\\n                }\\n            }\\n            int curr=0;\\n            if(right != i-1){\\n                curr += arr[right];\\n                if(left >0){\\n                    curr -= arr[left-1];\\n                }\\n            }\\n\\n            if(right +1 <n){\\n                curr += max(0, rightEnd - tiles[right+1][0]+1);\\n            }\\n\\n            ans = max(ans, curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        int ans = 0;\\n        int n = tiles.size();\\n        sort(tiles.begin(),tiles.end());\\n        vector<int> arr(n);\\n\\n        for(int i=0;i<n;i++){\\n            arr[i] = tiles[i][1] - tiles[i][0] +1;\\n            if(i>0) arr[i] = arr[i] + arr[i-1];\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int leftEnd=tiles[i][0], rightEnd = tiles[i][0]+carpetLen-1;\\n            int l = i, r=n-1; int left = i, right=i-1;\\n\\n            while(l<=r){\\n                int mid = (l+r)/2;\\n                if(tiles[mid][1] <= rightEnd){\\n                    right = mid;\\n                    l=mid+1;\\n                }else{\\n                    r = mid-1;\\n                }\\n            }\\n            int curr=0;\\n            if(right != i-1){\\n                curr += arr[right];\\n                if(left >0){\\n                    curr -= arr[left-1];\\n                }\\n            }\\n\\n            if(right +1 <n){\\n                curr += max(0, rightEnd - tiles[right+1][0]+1);\\n            }\\n\\n            ans = max(ans, curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874851,
                "title": "beats-90-prefixsum-binarysearch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to sort the tiles first, and then, if we observe, wherever the carpet is, we must start with the tiles[i][0].\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* sort the tiles array\\n* make a prefixSum array which contains the prefix sums of the length of the tiles.\\n* iterate through each tile, and using binary search find the least tile\\'s start where target (tilesStart[i] + carpetLen-1) >= tile\\'s start\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(Nlog(N))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(),tiles.end());\\n        int n = tiles.size();\\n        vector<int> tilesStart;\\n        vector<int> prefixSum(n+1,0);\\n        for(int i =0;i<n ;i++){ tilesStart.push_back(tiles[i][0]);\\n        }\\n        for(int i =1;i<=n ;i++) prefixSum[i] = prefixSum[i-1] + tiles[i-1][1]-tiles[i-1][0]  + 1;\\n        int answer = 0;\\n        for(int i =0;i<n ;i++){\\n            int target = tilesStart[i] + carpetLen-1;\\n            int l = i, r = n-1;\\n            int targetIdx = -1;\\n            // cout<< \"tar\"<< target<< endl;\\n            while(l<r){\\n                // cout<< l << \" \" << r << endl;\\n                int mid = l + (r-l+1)/2;\\n                if (tilesStart[mid] == target) {targetIdx = mid;\\n                    break;\\n                }\\n                else if (tilesStart[mid] > target) r = mid-1;\\n                else l = mid;\\n            }\\n            if (l==r) targetIdx = l;\\n            // cout << targetIdx << \"i\" << endl;\\n            if (i==targetIdx){\\n                if (carpetLen >= tiles[i][1]-tiles[i][0]+1)  answer = max(answer,tiles[i][1]-tiles[i][0]+1);\\n                else answer = max(answer,carpetLen);\\n                // cout << answer<< \"an\" << endl;\\n            }\\n            else{\\n                int localAnswer = prefixSum[targetIdx] - prefixSum[i];\\n                localAnswer += (target-tilesStart[targetIdx]+1 <= tiles[targetIdx][1]-tiles[targetIdx][0]+1)? \\n                target-tilesStart[targetIdx]+1 : tiles[targetIdx][1]-tiles[targetIdx][0]+1;\\n                // cout << localAnswer <<\" \" << endl;\\n                answer = max(answer,localAnswer);\\n            }\\n        }\\n\\n        return answer;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(),tiles.end());\\n        int n = tiles.size();\\n        vector<int> tilesStart;\\n        vector<int> prefixSum(n+1,0);\\n        for(int i =0;i<n ;i++){ tilesStart.push_back(tiles[i][0]);\\n        }\\n        for(int i =1;i<=n ;i++) prefixSum[i] = prefixSum[i-1] + tiles[i-1][1]-tiles[i-1][0]  + 1;\\n        int answer = 0;\\n        for(int i =0;i<n ;i++){\\n            int target = tilesStart[i] + carpetLen-1;\\n            int l = i, r = n-1;\\n            int targetIdx = -1;\\n            // cout<< \"tar\"<< target<< endl;\\n            while(l<r){\\n                // cout<< l << \" \" << r << endl;\\n                int mid = l + (r-l+1)/2;\\n                if (tilesStart[mid] == target) {targetIdx = mid;\\n                    break;\\n                }\\n                else if (tilesStart[mid] > target) r = mid-1;\\n                else l = mid;\\n            }\\n            if (l==r) targetIdx = l;\\n            // cout << targetIdx << \"i\" << endl;\\n            if (i==targetIdx){\\n                if (carpetLen >= tiles[i][1]-tiles[i][0]+1)  answer = max(answer,tiles[i][1]-tiles[i][0]+1);\\n                else answer = max(answer,carpetLen);\\n                // cout << answer<< \"an\" << endl;\\n            }\\n            else{\\n                int localAnswer = prefixSum[targetIdx] - prefixSum[i];\\n                localAnswer += (target-tilesStart[targetIdx]+1 <= tiles[targetIdx][1]-tiles[targetIdx][0]+1)? \\n                target-tilesStart[targetIdx]+1 : tiles[targetIdx][1]-tiles[targetIdx][0]+1;\\n                // cout << localAnswer <<\" \" << endl;\\n                answer = max(answer,localAnswer);\\n            }\\n        }\\n\\n        return answer;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3737548,
                "title": "java-twopointers-oop-clean-code",
                "content": "# Approach\\n1. Use a flexible window - two pointers. Right will point to current tile and left will point to the first tile covered by the carpet\\n2. For each tile segment, cover the current segment. Increase the number of covered tiles AND used carpet. \\n3. If you\\'ve used too much carpet (used > carpetLen)\\n    - try to uncover as much carpet from the leftmost tile where the carpet starts.\\n    - if completely uncovering that segment does not give back enough carpet, then switch to next segment (left++)\\n    - when switching to next segment, you also gain back the carpet that covers the empty/blank space between segments\\n4. Also, keep track of where your carpet starts within the left segment: \\n   -  EG: [1,10] but you might have to oncover some tiles, thus your carpet can start from position 5.   \\n5. For each segment, advance/cover it and adjust the left side/segment of the carpet. After each step, get the max number of covered tiles.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        Arrays.sort(tiles, Comparator.comparingInt(a -> a[0]));\\n        FlexibleCarpet flexibleCarpet = new FlexibleCarpet(tiles, carpetLen);\\n        int maxCoveredTiles = 0;\\n        for (int i = 0; i < tiles.length; i++) {\\n            flexibleCarpet.coverNextTile();\\n            maxCoveredTiles = Math.max(maxCoveredTiles, flexibleCarpet.getCoveredTiles());\\n        }\\n        return maxCoveredTiles;\\n    }\\n\\n    private static class FlexibleCarpet {\\n        private int[][] tiles;\\n        private int maxCarpetLength, usedCarpet, excessCarpet;\\n        private int carpetStart, left, coveredTiles, right;\\n\\n        public FlexibleCarpet(int[][] tiles, int maxCarpetLength) {\\n            this.tiles = tiles;\\n            this.maxCarpetLength = maxCarpetLength;\\n            carpetStart = tiles[0][0];\\n        }\\n\\n        public void coverNextTile() {\\n            coveredTiles += tiles[right][1] + 1 - tiles[right][0];\\n            usedCarpet += ((tiles[right][1] + 1 - tiles[right][0])  + \\n                (right > 0 ? tiles[right][0] - tiles[right - 1][1] - 1 : 0));\\n            right++;\\n            adjustCarpet();\\n        }\\n\\n        private void adjustCarpet() {\\n            while (usedCarpet > maxCarpetLength) {\\n                excessCarpet = usedCarpet - maxCarpetLength;\\n                if (excessCarpet >= tiles[left][1] + 1 - carpetStart) {\\n                    usedCarpet -= ((tiles[left][1] + 1 - carpetStart) + (tiles[left + 1][0] - tiles[left][1] - 1));\\n                    coveredTiles -= (tiles[left][1] + 1 - carpetStart);\\n                    left++;\\n                    carpetStart = tiles[left][0];\\n                } else {\\n                    carpetStart += excessCarpet;\\n                    usedCarpet -= excessCarpet;\\n                    coveredTiles -= excessCarpet;\\n                }\\n            }\\n        }\\n\\n        public int getCoveredTiles() {\\n            return coveredTiles;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        Arrays.sort(tiles, Comparator.comparingInt(a -> a[0]));\\n        FlexibleCarpet flexibleCarpet = new FlexibleCarpet(tiles, carpetLen);\\n        int maxCoveredTiles = 0;\\n        for (int i = 0; i < tiles.length; i++) {\\n            flexibleCarpet.coverNextTile();\\n            maxCoveredTiles = Math.max(maxCoveredTiles, flexibleCarpet.getCoveredTiles());\\n        }\\n        return maxCoveredTiles;\\n    }\\n\\n    private static class FlexibleCarpet {\\n        private int[][] tiles;\\n        private int maxCarpetLength, usedCarpet, excessCarpet;\\n        private int carpetStart, left, coveredTiles, right;\\n\\n        public FlexibleCarpet(int[][] tiles, int maxCarpetLength) {\\n            this.tiles = tiles;\\n            this.maxCarpetLength = maxCarpetLength;\\n            carpetStart = tiles[0][0];\\n        }\\n\\n        public void coverNextTile() {\\n            coveredTiles += tiles[right][1] + 1 - tiles[right][0];\\n            usedCarpet += ((tiles[right][1] + 1 - tiles[right][0])  + \\n                (right > 0 ? tiles[right][0] - tiles[right - 1][1] - 1 : 0));\\n            right++;\\n            adjustCarpet();\\n        }\\n\\n        private void adjustCarpet() {\\n            while (usedCarpet > maxCarpetLength) {\\n                excessCarpet = usedCarpet - maxCarpetLength;\\n                if (excessCarpet >= tiles[left][1] + 1 - carpetStart) {\\n                    usedCarpet -= ((tiles[left][1] + 1 - carpetStart) + (tiles[left + 1][0] - tiles[left][1] - 1));\\n                    coveredTiles -= (tiles[left][1] + 1 - carpetStart);\\n                    left++;\\n                    carpetStart = tiles[left][0];\\n                } else {\\n                    carpetStart += excessCarpet;\\n                    usedCarpet -= excessCarpet;\\n                    coveredTiles -= excessCarpet;\\n                }\\n            }\\n        }\\n\\n        public int getCoveredTiles() {\\n            return coveredTiles;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692402,
                "title": "c-python-sliding-window-solution-with-explanation",
                "content": "First, sort the ```tiles``` using left side, carpetLen is a window,\\nwe can put right side of window on each tile and and count how many tiles covered by window.\\n\\n### python\\n```python\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort(key=lambda x: x[0])\\n\\t\\t# tr is right side of window\\n\\t\\t# left side of window is tr - carpetLen + 1\\n        left = cover = 0\\n\\t\\t# left is the tile where left side of window is\\n\\t\\t# cover is total tiles covered by window\\n        ans = 0\\n        for tl, tr in tiles:\\n\\t\\t\\t# add tile into wondow\\n            cover += tr - tl + 1\\n\\t\\t\\t# when the left side of the window has passed the right side of a consecutive tiles\\n\\t\\t\\t# move the left pointer\\n            while tiles[left][1] < tr - carpetLen + 1:\\n                cover -= tiles[left][1] - tiles[left][0] + 1\\n                left += 1\\n\\t\\t\\t# if left side of the window is on anther consecutive tiles, there are some part of area is not covered by window\\n            ans = max(ans, cover - max(0, tr - carpetLen + 1 - tiles[left][0]))\\n        return ans\\n```\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(), tiles.end());\\n        int left = 0, cover = 0, ans = 0;\\n        for (auto& v: tiles) {\\n            const int &tl = v[0], &tr = v[1];\\n            cover += tr - tl + 1;\\n            while (tiles[left][1] < tr - carpetLen + 1) {\\n                cover -= tiles[left][1] - tiles[left][0] + 1;\\n                left += 1;\\n            }\\n            ans = max(ans, cover - max(0, tr - carpetLen + 1 - tiles[left][0]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```tiles```\n```python\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort(key=lambda x: x[0])\\n\\t\\t# tr is right side of window\\n\\t\\t# left side of window is tr - carpetLen + 1\\n        left = cover = 0\\n\\t\\t# left is the tile where left side of window is\\n\\t\\t# cover is total tiles covered by window\\n        ans = 0\\n        for tl, tr in tiles:\\n\\t\\t\\t# add tile into wondow\\n            cover += tr - tl + 1\\n\\t\\t\\t# when the left side of the window has passed the right side of a consecutive tiles\\n\\t\\t\\t# move the left pointer\\n            while tiles[left][1] < tr - carpetLen + 1:\\n                cover -= tiles[left][1] - tiles[left][0] + 1\\n                left += 1\\n\\t\\t\\t# if left side of the window is on anther consecutive tiles, there are some part of area is not covered by window\\n            ans = max(ans, cover - max(0, tr - carpetLen + 1 - tiles[left][0]))\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(), tiles.end());\\n        int left = 0, cover = 0, ans = 0;\\n        for (auto& v: tiles) {\\n            const int &tl = v[0], &tr = v[1];\\n            cover += tr - tl + 1;\\n            while (tiles[left][1] < tr - carpetLen + 1) {\\n                cover -= tiles[left][1] - tiles[left][0] + 1;\\n                left += 1;\\n            }\\n            ans = max(ans, cover - max(0, tr - carpetLen + 1 - tiles[left][0]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495598,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `tiles`\\n */\\nclass Solution {\\n public:\\n  int maximumWhiteTiles(vector<vector<int>> &tiles, const int carpetLen) {\\n    const int n = static_cast<int>(tiles.size());\\n    sort(tiles.begin(), tiles.end());\\n    int length_presums[n + 1];\\n    length_presums[0] = 0;\\n    for (int i = 0; i < n; ++i) {\\n      length_presums[i + 1] = length_presums[i] + (tiles[i].back() - tiles[i].front() + 1);\\n    }\\n    \\n    int ret = 0;\\n    for (int i = 0; i < n; ++i) {\\n      const int start = tiles[i].front();\\n      const int end = start + carpetLen - 1;\\n      auto ub = upper_bound(tiles.begin() + i, tiles.end(), vector<int>{end, numeric_limits<int>::max()});\\n      const int last_index = static_cast<int>(ub - tiles.begin()) - 1;\\n      const int covered = length_presums[last_index + 1] - length_presums[i] - max(0, (tiles[last_index].back() - end));\\n      ret = max(ret, covered);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `tiles`\\n */\\nclass Solution {\\n public:\\n  int maximumWhiteTiles(vector<vector<int>> &tiles, const int carpetLen) {\\n    const int n = static_cast<int>(tiles.size());\\n    sort(tiles.begin(), tiles.end());\\n    int length_presums[n + 1];\\n    length_presums[0] = 0;\\n    for (int i = 0; i < n; ++i) {\\n      length_presums[i + 1] = length_presums[i] + (tiles[i].back() - tiles[i].front() + 1);\\n    }\\n    \\n    int ret = 0;\\n    for (int i = 0; i < n; ++i) {\\n      const int start = tiles[i].front();\\n      const int end = start + carpetLen - 1;\\n      auto ub = upper_bound(tiles.begin() + i, tiles.end(), vector<int>{end, numeric_limits<int>::max()});\\n      const int last_index = static_cast<int>(ub - tiles.begin()) - 1;\\n      const int covered = length_presums[last_index + 1] - length_presums[i] - max(0, (tiles[last_index].back() - end));\\n      ret = max(ret, covered);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490646,
                "title": "typescript-solution-of-torocholazzz-s-javascript-python-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n log n), where n is the number of tiles. This is because the code first sorts the tiles in $$O(n log n)$$time, and then it iterates over the sorted tiles in O(n) time.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThe space complexity of the code is $$O(n)$$, where n is the number of tiles. This is because the code stores the sorted tiles in an array, which takes up O(n) space.\\n# Code\\n```\\nfunction maximumWhiteTiles(tiles: [[number, number]], carpetLen: number): number {\\n  const sorted = tiles.sort((a, b) => a[0] - b[0]);\\n  let res = 0;\\n  \\n  let total = 0;\\n  let right = 0;\\n\\n  for (let tile of sorted) {\\n    const start = tile[0];\\n    const end = start + carpetLen - 1;\\n    while (right < sorted.length && tiles[right][1] < end) {\\n      total += tiles[right][1] - tiles[right][0] + 1;\\n      right++;\\n    }\\n    if (right === sorted.length || sorted[right][0] > end) {\\n      res = Math.max(res, total);\\n    } else {\\n      res = Math.max(res, total + (end - tiles[right][0] + 1));\\n    }\\n    total -= tile[1] - tile[0] + 1;\\n  }\\n  \\n  return res;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction maximumWhiteTiles(tiles: [[number, number]], carpetLen: number): number {\\n  const sorted = tiles.sort((a, b) => a[0] - b[0]);\\n  let res = 0;\\n  \\n  let total = 0;\\n  let right = 0;\\n\\n  for (let tile of sorted) {\\n    const start = tile[0];\\n    const end = start + carpetLen - 1;\\n    while (right < sorted.length && tiles[right][1] < end) {\\n      total += tiles[right][1] - tiles[right][0] + 1;\\n      right++;\\n    }\\n    if (right === sorted.length || sorted[right][0] > end) {\\n      res = Math.max(res, total);\\n    } else {\\n      res = Math.max(res, total + (end - tiles[right][0] + 1));\\n    }\\n    total -= tile[1] - tile[0] + 1;\\n  }\\n  \\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486843,
                "title": "c-easy-to-understand-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(), tiles.end());\\n\\n        int left = 0;\\n        int right = 0;\\n        int ans = 0;\\n        int cover = 0;\\n\\n        for(right = 0; ans < carpetLen and right < tiles.size(); ){\\n            //Carpet starts from left tiles\\n\\n            //If the carpet cover the current tile then it length will be \\n            //tiles[right][1] - tiles[left][0] + 1\\n            if((tiles[right][1] - tiles[left][0] + 1) <= carpetLen){\\n                //We can cover the whole tile\\n                cover += (tiles[right][1] - tiles[right][0] + 1);\\n                ans = max(ans, cover);\\n                right++;\\n            }else{\\n                //We cannot cover the whole tile\\n                int partial = max(0, tiles[left][0] + carpetLen - tiles[right][0]);\\n                ans = max(ans, cover + partial);\\n\\n                //Move the left point of the carpet to the next tile\\n                cover -= (tiles[left][1] - tiles[left][0] + 1);\\n                left++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(), tiles.end());\\n\\n        int left = 0;\\n        int right = 0;\\n        int ans = 0;\\n        int cover = 0;\\n\\n        for(right = 0; ans < carpetLen and right < tiles.size(); ){\\n            //Carpet starts from left tiles\\n\\n            //If the carpet cover the current tile then it length will be \\n            //tiles[right][1] - tiles[left][0] + 1\\n            if((tiles[right][1] - tiles[left][0] + 1) <= carpetLen){\\n                //We can cover the whole tile\\n                cover += (tiles[right][1] - tiles[right][0] + 1);\\n                ans = max(ans, cover);\\n                right++;\\n            }else{\\n                //We cannot cover the whole tile\\n                int partial = max(0, tiles[left][0] + carpetLen - tiles[right][0]);\\n                ans = max(ans, cover + partial);\\n\\n                //Move the left point of the carpet to the next tile\\n                cover -= (tiles[left][1] - tiles[left][0] + 1);\\n                left++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439052,
                "title": "c-o-nlongn-sliding-window-solution-o-1-memory",
                "content": "# Intuition\\nCarpet must always be placed at the beginning of a group. There is not advantage of putting it in the middle.\\n\\n# Approach\\nSort groups by start pos. Move carpet left to right and keep track of currently covered area.\\n\\n# Complexity\\n- Time complexity:\\nO(N*Log(N)) for sort. O(N) for max covered area calculation.\\n\\n- Space complexity:\\nO(1) - no extra memory was used.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        // sort based on interval starts\\n        sort(tiles.begin(), tiles.end(), [](const auto& a, const auto& b) { return a[0] < b[0]; } );\\n\\n        // best result, 1 is always possible\\n        int r = 1;\\n\\n        // currently covered area by sliding window\\n        int cover = 0;\\n\\n        // end of sliding window\\n        int i = 0;\\n        // start of sliding window\\n        int j = 0;\\n\\n        for (int i = 0;i < tiles.size() && j < tiles.size();) {\\n            // check, if we can fit entire group under carpet\\n            if (tiles[j][0] + carpetLen > tiles[i][1]) {\\n                cover += (tiles[i][1] - tiles[i][0] + 1);\\n                r = max(r, cover);\\n\\n                i ++;\\n            } else {\\n                // if we can not just add new group\\n                // we need to calculate how many tiles we can cover\\n                int partial = tiles[j][0] + carpetLen - tiles[i][0];\\n                // possibly update best case result\\n                r = max(r, cover + partial);\\n\\n                // move tail of sliding window\\n                cover -= (tiles[j][1] - tiles[j][0] + 1);\\n                j ++;\\n            }\\n        }\\n\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        // sort based on interval starts\\n        sort(tiles.begin(), tiles.end(), [](const auto& a, const auto& b) { return a[0] < b[0]; } );\\n\\n        // best result, 1 is always possible\\n        int r = 1;\\n\\n        // currently covered area by sliding window\\n        int cover = 0;\\n\\n        // end of sliding window\\n        int i = 0;\\n        // start of sliding window\\n        int j = 0;\\n\\n        for (int i = 0;i < tiles.size() && j < tiles.size();) {\\n            // check, if we can fit entire group under carpet\\n            if (tiles[j][0] + carpetLen > tiles[i][1]) {\\n                cover += (tiles[i][1] - tiles[i][0] + 1);\\n                r = max(r, cover);\\n\\n                i ++;\\n            } else {\\n                // if we can not just add new group\\n                // we need to calculate how many tiles we can cover\\n                int partial = tiles[j][0] + carpetLen - tiles[i][0];\\n                // possibly update best case result\\n                r = max(r, cover + partial);\\n\\n                // move tail of sliding window\\n                cover -= (tiles[j][1] - tiles[j][0] + 1);\\n                j ++;\\n            }\\n        }\\n\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406236,
                "title": "python3-faster-than-97",
                "content": "# Complexity\\n- Time complexity: $$O(n \\\\log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        l = len(tiles)\\n        cover = 0\\n        j = 0\\n        ans = 0\\n        tiles.sort()\\n        for i in range(l):\\n            l_start, r_start = tiles[i]\\n            len_start = r_start - l_start + 1\\n            if len_start >= carpetLen:\\n                return carpetLen           \\n            while j < l and tiles[j][1] - l_start + 1 <= carpetLen:\\n                cover += tiles[j][1] - tiles[j][0] + 1\\n                j += 1\\n            if j == l:\\n                return max(ans, cover)\\n            else:\\n                ans = max(ans, cover+max(carpetLen+l_start-tiles[j][0],0))\\n            cover -= len_start\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        l = len(tiles)\\n        cover = 0\\n        j = 0\\n        ans = 0\\n        tiles.sort()\\n        for i in range(l):\\n            l_start, r_start = tiles[i]\\n            len_start = r_start - l_start + 1\\n            if len_start >= carpetLen:\\n                return carpetLen           \\n            while j < l and tiles[j][1] - l_start + 1 <= carpetLen:\\n                cover += tiles[j][1] - tiles[j][0] + 1\\n                j += 1\\n            if j == l:\\n                return max(ans, cover)\\n            else:\\n                ans = max(ans, cover+max(carpetLen+l_start-tiles[j][0],0))\\n            cover -= len_start\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405422,
                "title": "c-binary-search-sorting",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        int n = tiles.size();\\n        vector<int> pref(n);\\n        sort(tiles.begin(),tiles.end());\\n        pref[0] = (tiles[0][1]-tiles[0][0])+1;\\n        for(int i=1;i<n;i++)\\n        {\\n            pref[i] = pref[i-1]+(tiles[i][1]-tiles[i][0])+1;\\n        }\\n        vector<int> en(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            en[i] = tiles[i][1];\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int maxl = tiles[i][0]+carpetLen-1;\\n            int idx = upper_bound(en.begin(),en.end(),maxl)-en.begin();\\n            if(idx<n)\\n            {\\n                int lower = tiles[idx][0];\\n                int upper = tiles[idx][1];\\n                int sum = 0;\\n                if(idx-1>=0)\\n                {\\n                    if(i-1>=0)\\n                    sum = pref[idx-1]-pref[i-1];\\n                    else\\n                    sum = pref[idx-1];\\n                }\\n                if(maxl>=lower)\\n                {\\n                    sum+=maxl-lower+1;\\n                }\\n                ans = max(ans,sum);\\n            }\\n            else\\n            {\\n                int sum = 0;\\n                if(i-1>=0)\\n                {\\n                    sum = pref[n-1]-pref[i-1];\\n                }\\n                else\\n                sum = pref[n-1];\\n                ans = max(ans,sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        int n = tiles.size();\\n        vector<int> pref(n);\\n        sort(tiles.begin(),tiles.end());\\n        pref[0] = (tiles[0][1]-tiles[0][0])+1;\\n        for(int i=1;i<n;i++)\\n        {\\n            pref[i] = pref[i-1]+(tiles[i][1]-tiles[i][0])+1;\\n        }\\n        vector<int> en(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            en[i] = tiles[i][1];\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int maxl = tiles[i][0]+carpetLen-1;\\n            int idx = upper_bound(en.begin(),en.end(),maxl)-en.begin();\\n            if(idx<n)\\n            {\\n                int lower = tiles[idx][0];\\n                int upper = tiles[idx][1];\\n                int sum = 0;\\n                if(idx-1>=0)\\n                {\\n                    if(i-1>=0)\\n                    sum = pref[idx-1]-pref[i-1];\\n                    else\\n                    sum = pref[idx-1];\\n                }\\n                if(maxl>=lower)\\n                {\\n                    sum+=maxl-lower+1;\\n                }\\n                ans = max(ans,sum);\\n            }\\n            else\\n            {\\n                int sum = 0;\\n                if(i-1>=0)\\n                {\\n                    sum = pref[n-1]-pref[i-1];\\n                }\\n                else\\n                sum = pref[n-1];\\n                ans = max(ans,sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328574,
                "title": "c-golang-sliding-window",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(), tiles.end());\\n        int ans = 0, total = 0;\\n        for(int start = 0, end = 0; end < tiles.size(); end++) {\\n            total += tiles[end][1] - tiles[end][0] + 1;\\n            while(tiles[start][1] < tiles[end][1] - carpetLen) {\\n                total -= tiles[start][1] - tiles[start][0] + 1;\\n                start++;\\n            } \\n            // ans = max(ans, total - (tiles[start][1] - tiles[start][0] + 1) + (tiles[start][1] + 1 - max(tiles[start][0], tiles[end][1] - carpetLen + 1)));\\n            ans = max(ans, total + tiles[start][0] - max(tiles[start][0], tiles[end][1] - carpetLen + 1));\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc max(a, b int) int {\\n    if a > b {return a}\\n    return b\\n}\\n\\nfunc maximumWhiteTiles(tiles [][]int, carpetLen int) int {\\n    sort.Slice(tiles, func(i, j int) bool {\\n        return tiles[i][0] < tiles[j][0]\\n    })\\n    var ans, total int = 0, 0\\n    for start, end := 0, 0; end < len(tiles); end++ {\\n        total += tiles[end][1] - tiles[end][0] + 1\\n        for tiles[start][1] < tiles[end][1] - carpetLen {\\n            total -= tiles[start][1] - tiles[start][0] + 1\\n            start++\\n        } \\n        // ans = max(ans, total - (tiles[start][1] - tiles[start][0] + 1) + (tiles[start][1] + 1 - max(tiles[start][0], tiles[end][1] - carpetLen + 1)))\\n        ans = max(ans, total + tiles[start][0] - max(tiles[start][0], tiles[end][1] - carpetLen + 1))\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(), tiles.end());\\n        int ans = 0, total = 0;\\n        for(int start = 0, end = 0; end < tiles.size(); end++) {\\n            total += tiles[end][1] - tiles[end][0] + 1;\\n            while(tiles[start][1] < tiles[end][1] - carpetLen) {\\n                total -= tiles[start][1] - tiles[start][0] + 1;\\n                start++;\\n            } \\n            // ans = max(ans, total - (tiles[start][1] - tiles[start][0] + 1) + (tiles[start][1] + 1 - max(tiles[start][0], tiles[end][1] - carpetLen + 1)));\\n            ans = max(ans, total + tiles[start][0] - max(tiles[start][0], tiles[end][1] - carpetLen + 1));\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc max(a, b int) int {\\n    if a > b {return a}\\n    return b\\n}\\n\\nfunc maximumWhiteTiles(tiles [][]int, carpetLen int) int {\\n    sort.Slice(tiles, func(i, j int) bool {\\n        return tiles[i][0] < tiles[j][0]\\n    })\\n    var ans, total int = 0, 0\\n    for start, end := 0, 0; end < len(tiles); end++ {\\n        total += tiles[end][1] - tiles[end][0] + 1\\n        for tiles[start][1] < tiles[end][1] - carpetLen {\\n            total -= tiles[start][1] - tiles[start][0] + 1\\n            start++\\n        } \\n        // ans = max(ans, total - (tiles[start][1] - tiles[start][0] + 1) + (tiles[start][1] + 1 - max(tiles[start][0], tiles[end][1] - carpetLen + 1)))\\n        ans = max(ans, total + tiles[start][0] - max(tiles[start][0], tiles[end][1] - carpetLen + 1))\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317724,
                "title": "python-sort-prefixsum-binarysearch",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort()\\n        starts, PS = [], [0]\\n        \\n        for l, r in tiles:\\n            starts.append(l)\\n            PS.append(PS[-1] + r - l + 1)\\n        \\n        res = 0\\n        for i, pair in enumerate(tiles):\\n            l, r = pair\\n            reach = l + carpetLen - 1\\n            if r >= reach:\\n                return carpetLen\\n            endIdx = bisect_right(starts, reach) - 1\\n            amtOver = max(0, tiles[endIdx][1]-reach)\\n            res = max(res, PS[endIdx+1]-PS[i] - amtOver)\\n        return res\\n\\n\\n        \\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort()\\n        starts, PS = [], [0]\\n        \\n        for l, r in tiles:\\n            starts.append(l)\\n            PS.append(PS[-1] + r - l + 1)\\n        \\n        res = 0\\n        for i, pair in enumerate(tiles):\\n            l, r = pair\\n            reach = l + carpetLen - 1\\n            if r >= reach:\\n                return carpetLen\\n            endIdx = bisect_right(starts, reach) - 1\\n            amtOver = max(0, tiles[endIdx][1]-reach)\\n            res = max(res, PS[endIdx+1]-PS[i] - amtOver)\\n        return res\\n\\n\\n        \\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307920,
                "title": "greedy-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo maximize the number of white tiles covered, we wanna avoid wasting the avaible carpet. Therefore, we always align the carpet at the beginning of white tiles.\\nBy maintaing a left and a right sliding window variable, we avoid having to loop through the tiles nestedly.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        Array.Sort(tiles, (a, b) => a[0].CompareTo(b[0]));\\n        int res, cur, left, right;\\n        res = cur = left = right = 0;\\n        while (right < tiles.Length && left < tiles.Length) {\\n            if (tiles[right][1] - tiles[left][0] + 1 <= carpetLen) {\\n                cur += tiles[right][1] - tiles[right][0] + 1;\\n                res = Math.Max(res, cur);\\n                ++right;\\n            } else {\\n                var partial = carpetLen - tiles[right][0] + tiles[left][0];\\n                res = Math.Max(res, cur + partial);\\n                cur -= tiles[left][1] - tiles[left][0] + 1;\\n                ++left;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        Array.Sort(tiles, (a, b) => a[0].CompareTo(b[0]));\\n        int res, cur, left, right;\\n        res = cur = left = right = 0;\\n        while (right < tiles.Length && left < tiles.Length) {\\n            if (tiles[right][1] - tiles[left][0] + 1 <= carpetLen) {\\n                cur += tiles[right][1] - tiles[right][0] + 1;\\n                res = Math.Max(res, cur);\\n                ++right;\\n            } else {\\n                var partial = carpetLen - tiles[right][0] + tiles[left][0];\\n                res = Math.Max(res, cur + partial);\\n                cur -= tiles[left][1] - tiles[left][0] + 1;\\n                ++left;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270396,
                "title": "c",
                "content": "```\\nclass Solution {\\n\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(), tiles.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[0] < b[0];} );\\n        \\n        int ret= 0 ;\\n        int n = tiles.size() ;\\n        vector<int>preSum(n+1, 0) ;\\n        \\n        for(int i = 1; i <= n; i++)\\n            preSum[i] = preSum[i-1] + tiles[i-1][1] - tiles[i-1][0] + 1 ;\\n        \\n        int left = 0, right = 0 ;\\n        while(left < n && right < n){\\n            int end = tiles[left][0] +  carpetLen - 1;\\n            while(right < n && tiles[right][1] <= end)\\n                right++ ;\\n\\n            int count = preSum[right] - preSum[left] ;\\n            \\n            if(right < n && tiles[right][0] <= end)\\n                count += end -tiles[right][0] + 1 ;\\n            ret = max(ret, count) ;\\n            left++ ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(), tiles.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[0] < b[0];} );\\n        \\n        int ret= 0 ;\\n        int n = tiles.size() ;\\n        vector<int>preSum(n+1, 0) ;\\n        \\n        for(int i = 1; i <= n; i++)\\n            preSum[i] = preSum[i-1] + tiles[i-1][1] - tiles[i-1][0] + 1 ;\\n        \\n        int left = 0, right = 0 ;\\n        while(left < n && right < n){\\n            int end = tiles[left][0] +  carpetLen - 1;\\n            while(right < n && tiles[right][1] <= end)\\n                right++ ;\\n\\n            int count = preSum[right] - preSum[left] ;\\n            \\n            if(right < n && tiles[right][0] <= end)\\n                count += end -tiles[right][0] + 1 ;\\n            ret = max(ret, count) ;\\n            left++ ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238030,
                "title": "c-o-nlog-n-clean-complete-partial-coverage",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s always better to put the carpet at the beginning of an interval so we can try to align the left border of the carpet with every starting point of segments.\\n\\nHowever, the last overlapping segment may be partially covered, so I split the covered segments into two categories\\n1. completely covered segments and\\n2. partially covered segments\\n\\nand keep track number of these tiles respectively.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt could take O(n) to find the completely/partially covered tiles for each starting point. However, the greater the starting point, the last covered tiles must be greater or equal to the previous one.\\n\\nDue to the abovementioned trend, sliding window method is taken into consideration. \\n\\n1. Sort the disjoint tile segment using their starting point\\n2. Iterate through all the possible staring point of the carpet and keep a sliding window with a right pointer on the first non-completely overlapping segment.\\n3. Update the right pointer and compute the number of completely/partially covered tiles\\n4. Update `max_covered_tiles`\\n5. Slide the left boundary and update the number of completely/partially covered tiles\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSorting $O(n\\\\log n)$\\nSliding Window $O(n)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(quicksort)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        ::sort(tiles.begin(), tiles.end());\\n        int complete = 0, partial = 0, n = tiles.size(), max_cover_len = 0;\\n        for (int l = 0, r = 0; l < n; ++l) {\\n            // cleft := left border of the carpet, cright := right boundary\\n            int cleft = tiles[l][0], cright = tiles[l][0] + carpetLen - 1;\\n            \\n            // add as much complete segment as possible \\n            for (; r < n && tiles[r][1] <= cright; ++r)\\n                complete += tiles[r][1] - tiles[r][0] + 1;\\n\\n            // compute partial coverage\\n            partial = 0;\\n            if (r < n && tiles[r][0] <= cright)\\n                partial = cright - tiles[r][0] + 1;\\n            \\n            // update maximal cover length\\n            max_cover_len = max(max_cover_len, complete + partial);\\n            if (max_cover_len == carpetLen) { break; }\\n            \\n            // remove left\\n            if (tiles[l][1] <= cright)\\n                complete -= tiles[l][1] - tiles[l][0] + 1;\\n        }\\n\\n        return max_cover_len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        ::sort(tiles.begin(), tiles.end());\\n        int complete = 0, partial = 0, n = tiles.size(), max_cover_len = 0;\\n        for (int l = 0, r = 0; l < n; ++l) {\\n            // cleft := left border of the carpet, cright := right boundary\\n            int cleft = tiles[l][0], cright = tiles[l][0] + carpetLen - 1;\\n            \\n            // add as much complete segment as possible \\n            for (; r < n && tiles[r][1] <= cright; ++r)\\n                complete += tiles[r][1] - tiles[r][0] + 1;\\n\\n            // compute partial coverage\\n            partial = 0;\\n            if (r < n && tiles[r][0] <= cright)\\n                partial = cright - tiles[r][0] + 1;\\n            \\n            // update maximal cover length\\n            max_cover_len = max(max_cover_len, complete + partial);\\n            if (max_cover_len == carpetLen) { break; }\\n            \\n            // remove left\\n            if (tiles[l][1] <= cright)\\n                complete -= tiles[l][1] - tiles[l][0] + 1;\\n        }\\n\\n        return max_cover_len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200924,
                "title": "golang-simple-solution",
                "content": "```go\\nfunc maximumWhiteTiles(tiles [][]int, carpetLen int) int {\\n\\tif carpetLen == 1 {\\n\\t\\treturn 1\\n\\t}\\n\\tsort.Slice(tiles, func(i, j int) bool {\\n\\t\\treturn tiles[i][0] < tiles[j][0]\\n\\t})\\n\\t// left bound index of tiles\\n\\tlIndex := 0\\n\\tcurCover, maxCover := 0, 0\\n\\tfor _, v := range tiles {\\n\\t\\t// longer than or equal to carpetLen\\n\\t\\t// return carpetLen directly\\n\\t\\tif v[1]-v[0]+1 >= carpetLen {\\n\\t\\t\\treturn carpetLen\\n\\t\\t}\\n\\t\\t// lBound, included\\n\\t\\tlBound := v[1] - carpetLen + 1\\n\\t\\tfor tiles[lIndex][1] < lBound {\\n\\t\\t\\tcurCover -= tiles[lIndex][1] - tiles[lIndex][0] + 1\\n\\t\\t\\tlIndex++\\n\\t\\t}\\n\\t\\tif tiles[lIndex][0] < lBound {\\n\\t\\t\\tcurCover -= lBound - tiles[lIndex][0]\\n\\t\\t\\ttiles[lIndex][0] = lBound\\n\\t\\t}\\n\\t\\tcurCover += v[1] - v[0] + 1\\n\\t\\tif curCover > maxCover {\\n\\t\\t\\tmaxCover = curCover\\n\\t\\t}\\n\\t}\\n\\treturn maxCover\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc maximumWhiteTiles(tiles [][]int, carpetLen int) int {\\n\\tif carpetLen == 1 {\\n\\t\\treturn 1\\n\\t}\\n\\tsort.Slice(tiles, func(i, j int) bool {\\n\\t\\treturn tiles[i][0] < tiles[j][0]\\n\\t})\\n\\t// left bound index of tiles\\n\\tlIndex := 0\\n\\tcurCover, maxCover := 0, 0\\n\\tfor _, v := range tiles {\\n\\t\\t// longer than or equal to carpetLen\\n\\t\\t// return carpetLen directly\\n\\t\\tif v[1]-v[0]+1 >= carpetLen {\\n\\t\\t\\treturn carpetLen\\n\\t\\t}\\n\\t\\t// lBound, included\\n\\t\\tlBound := v[1] - carpetLen + 1\\n\\t\\tfor tiles[lIndex][1] < lBound {\\n\\t\\t\\tcurCover -= tiles[lIndex][1] - tiles[lIndex][0] + 1\\n\\t\\t\\tlIndex++\\n\\t\\t}\\n\\t\\tif tiles[lIndex][0] < lBound {\\n\\t\\t\\tcurCover -= lBound - tiles[lIndex][0]\\n\\t\\t\\ttiles[lIndex][0] = lBound\\n\\t\\t}\\n\\t\\tcurCover += v[1] - v[0] + 1\\n\\t\\tif curCover > maxCover {\\n\\t\\t\\tmaxCover = curCover\\n\\t\\t}\\n\\t}\\n\\treturn maxCover\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3092375,
                "title": "python-greedy-binary-search-solution",
                "content": "```\\ndef maximumWhiteTiles(self, nums: List[List[int]], x: int) -> int:\\n\\tnums, ans = sorted(nums), 0\\n\\tpsum = [0]+list(accumulate([p[1]-p[0]+1 for p in nums]))\\n\\tfor i in range(len(nums)):\\n\\t\\ts, end = nums[i][0], nums[i][0]+x-1\\n\\t\\tidx = bisect.bisect(nums, end, key=lambda p:p[0])-1\\n\\t\\tif nums[idx][1]<=end:\\n\\t\\t\\tans = max(ans, psum[idx+1]-psum[i])\\n\\t\\telse:\\n\\t\\t\\tans = max(ans, (psum[idx]-psum[i])+(end-nums[idx][0]+1))\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef maximumWhiteTiles(self, nums: List[List[int]], x: int) -> int:\\n\\tnums, ans = sorted(nums), 0\\n\\tpsum = [0]+list(accumulate([p[1]-p[0]+1 for p in nums]))\\n\\tfor i in range(len(nums)):\\n\\t\\ts, end = nums[i][0], nums[i][0]+x-1\\n\\t\\tidx = bisect.bisect(nums, end, key=lambda p:p[0])-1\\n\\t\\tif nums[idx][1]<=end:\\n\\t\\t\\tans = max(ans, psum[idx+1]-psum[i])\\n\\t\\telse:\\n\\t\\t\\tans = max(ans, (psum[idx]-psum[i])+(end-nums[idx][0]+1))\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3025172,
                "title": "ruby-boring-sliding-window",
                "content": "```ruby\\ndef maximum_white_tiles a, t\\n    a.sort_by!(&:first).map! { _1[1] -= _1[0] - 1; _1 }\\n    i, j, z, m, c = 0, 0, a.size, 0, 0\\n    loop do\\n        b = a[i].first + t\\n        while j < z && a[j].sum <= b\\n            c += a[j].last\\n            j += 1\\n        end\\n        return [m, c].max if j == z\\n        m = [m, c + (a[j].first < b ? b - a[j].first : 0)].max\\n        c -= a[i].last if c > 0\\n        return m if (i += 1) == z\\n        j = i if i > j\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef maximum_white_tiles a, t\\n    a.sort_by!(&:first).map! { _1[1] -= _1[0] - 1; _1 }\\n    i, j, z, m, c = 0, 0, a.size, 0, 0\\n    loop do\\n        b = a[i].first + t\\n        while j < z && a[j].sum <= b\\n            c += a[j].last\\n            j += 1\\n        end\\n        return [m, c].max if j == z\\n        m = [m, c + (a[j].first < b ? b - a[j].first : 0)].max\\n        c -= a[i].last if c > 0\\n        return m if (i += 1) == z\\n        j = i if i > j\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3002214,
                "title": "sliding-window-o-n-besides-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nstandard algorithm of sliding way, but need to handle case of partial overlap\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        for (auto &v : tiles) {\\n            if (v[1] - v[0] + 1 >= carpetLen) {\\n                return carpetLen;\\n            }\\n        }\\n\\n        int N = tiles.size();\\n        sort(tiles.begin(), tiles.end());\\n        int res = 0;\\n        int start = 0;\\n        for (int end = 0, covered = 0; end < N; end++) {\\n            while (tiles[end][1] - tiles[start][0] + 1 > carpetLen) {\\n                // handle case of partial overlap\\n                int partial = max(0, tiles[start][0] + carpetLen - tiles[end][0]);\\n                res = max(res, covered + partial);\\n\\n\\n                covered -= tiles[start][1] - tiles[start][0] + 1;\\n                start++;\\n            }\\n            covered += tiles[end][1] - tiles[end][0] + 1;\\n            res = max(res, covered);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        for (auto &v : tiles) {\\n            if (v[1] - v[0] + 1 >= carpetLen) {\\n                return carpetLen;\\n            }\\n        }\\n\\n        int N = tiles.size();\\n        sort(tiles.begin(), tiles.end());\\n        int res = 0;\\n        int start = 0;\\n        for (int end = 0, covered = 0; end < N; end++) {\\n            while (tiles[end][1] - tiles[start][0] + 1 > carpetLen) {\\n                // handle case of partial overlap\\n                int partial = max(0, tiles[start][0] + carpetLen - tiles[end][0]);\\n                res = max(res, covered + partial);\\n\\n\\n                covered -= tiles[start][1] - tiles[start][0] + 1;\\n                start++;\\n            }\\n            covered += tiles[end][1] - tiles[end][0] + 1;\\n            res = max(res, covered);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994001,
                "title": "python-fully-commented-sliding-window",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], cl: int) -> int:\\n        tiles.sort()\\n        i,j = 0,0;\\n        n = len(tiles)\\n        s,res=0,0 # white tiles count \\n        while(i<n and j<n):\\n            if(tiles[i][0]+cl>tiles[j][1]): # if greator then the end of current jth range\\n                s += tiles[j][1]-tiles[j][0]+1 # then add whole range tiles\\n                res = max(res,s)\\n                j+=1\\n            else:\\n                temp = s + max(0,tiles[i][0]+cl-tiles[j][0]) # partial or no tiles overlap with carpet, add those tiles\\n                s -= (tiles[i][1]-tiles[i][0]+1) # remove white tiles\\n                i+=1 # shrink the window \\n                res = max(res,temp) # update the ans\\n        return res\\n            \\n        \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], cl: int) -> int:\\n        tiles.sort()\\n        i,j = 0,0;\\n        n = len(tiles)\\n        s,res=0,0 # white tiles count \\n        while(i<n and j<n):\\n            if(tiles[i][0]+cl>tiles[j][1]): # if greator then the end of current jth range\\n                s += tiles[j][1]-tiles[j][0]+1 # then add whole range tiles\\n                res = max(res,s)\\n                j+=1\\n            else:\\n                temp = s + max(0,tiles[i][0]+cl-tiles[j][0]) # partial or no tiles overlap with carpet, add those tiles\\n                s -= (tiles[i][1]-tiles[i][0]+1) # remove white tiles\\n                i+=1 # shrink the window \\n                res = max(res,temp) # update the ans\\n        return res\\n            \\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988619,
                "title": "binary-search-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& a, int t) {\\n        sort(a.begin(),a.end());\\n        \\n        int ans=0,n=a.size();\\n        vector<int> cnt(n);\\n        \\n        cnt[0]=a[0][1]-a[0][0]+1;\\n        if(cnt[0]>=t)\\n            return t;\\n        ans=max(ans,cnt[0]);\\n        \\n        for(int i=1;i<n;i++){\\n            int curr=a[i][1]-a[i][0]+1;\\n            if(curr>=t)\\n                return t;\\n            ans=max(ans,curr);\\n            cnt[i]=cnt[i-1]+curr;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            int rt=a[i][0]+t-1;\\n            if(a[n-1][1]<=rt){\\n                int p=0;\\n                if(i)\\n                    p=cnt[i-1];\\n                ans=max(ans,cnt[n-1]-p);\\n                return ans;\\n            }\\n            \\n            int mx=i,l=i,r=n-1;\\n            while(l<=r){\\n                int m=l+((r-l)>>1);\\n                if(a[m][0]<=rt){\\n                    l=m+1;\\n                    mx=max(mx,m);\\n                }\\n                else\\n                    r=m-1;\\n            }\\n\\n            if(mx>i){\\n                int p=0;\\n                if(i)\\n                    p=cnt[i-1];\\n                int cd=cnt[mx-1]-p+min(rt,a[mx][1])+1-a[mx][0];\\n                ans=max(ans,cd);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& a, int t) {\\n        sort(a.begin(),a.end());\\n        \\n        int ans=0,n=a.size();\\n        vector<int> cnt(n);\\n        \\n        cnt[0]=a[0][1]-a[0][0]+1;\\n        if(cnt[0]>=t)\\n            return t;\\n        ans=max(ans,cnt[0]);\\n        \\n        for(int i=1;i<n;i++){\\n            int curr=a[i][1]-a[i][0]+1;\\n            if(curr>=t)\\n                return t;\\n            ans=max(ans,curr);\\n            cnt[i]=cnt[i-1]+curr;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            int rt=a[i][0]+t-1;\\n            if(a[n-1][1]<=rt){\\n                int p=0;\\n                if(i)\\n                    p=cnt[i-1];\\n                ans=max(ans,cnt[n-1]-p);\\n                return ans;\\n            }\\n            \\n            int mx=i,l=i,r=n-1;\\n            while(l<=r){\\n                int m=l+((r-l)>>1);\\n                if(a[m][0]<=rt){\\n                    l=m+1;\\n                    mx=max(mx,m);\\n                }\\n                else\\n                    r=m-1;\\n            }\\n\\n            if(mx>i){\\n                int p=0;\\n                if(i)\\n                    p=cnt[i-1];\\n                int cd=cnt[mx-1]-p+min(rt,a[mx][1])+1-a[mx][0];\\n                ans=max(ans,cd);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933997,
                "title": "python-prefix-sum-two-pointers-solution",
                "content": "*Runtime 2987 ms, Beats 36.90%\\nMemory 39.3 MB, Beats 39.11%*\\n\\n## Intuition:\\n1. There are `i` white tiles, for each `i`, find the rightmost `j` that is covered by the black carpet.\\n2. The rightmost `j`th white tile is either **completely covered** or **partially covered**.\\n3. If **completely covered**, total covered space can be easily calculated using prefix sum. \\n4. If **partially covered**, `total` = completely covered `i`...`j - 1` white tiles + partially covered `j` tile. \\n\\n\\n```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        n = len(tiles)\\n        tiles.sort()\\n\\n        pre_sum = [0 for i in range(n)]\\n        for i in range(n):\\n            if i == 0:\\n                pre_sum[i] = tiles[i][1] - tiles[i][0] + 1\\n            else:\\n                pre_sum[i] = pre_sum[i - 1] + tiles[i][1] - tiles[i][0] + 1\\n        # print(pre_sum)\\n\\n        ans = 0\\n        j = 0\\n        for i in range(n):\\n            total = 0\\n            while j < n:\\n                if tiles[i][0] + carpetLen - 1 >= tiles[j][1]:\\n                    j += 1\\n                elif tiles[i][0] + carpetLen - 1 >= tiles[j][0]:\\n                    total = (tiles[i][0] + carpetLen - 1) - tiles[j][0] + 1\\n                    break\\n                else:\\n                    break\\n            \\n            if i == 0:\\n                if j != 0:\\n                    total += pre_sum[j - 1]\\n            else:\\n                total += pre_sum[j - 1] - pre_sum[i - 1]\\n            \\n            # print(i, j, total)\\n            ans = max(ans, total)\\n        \\n        return ans\\n```\\nPlease upvote if it helps! (\\u25CF\\'\\u25E1\\'\\u25CF)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        n = len(tiles)\\n        tiles.sort()\\n\\n        pre_sum = [0 for i in range(n)]\\n        for i in range(n):\\n            if i == 0:\\n                pre_sum[i] = tiles[i][1] - tiles[i][0] + 1\\n            else:\\n                pre_sum[i] = pre_sum[i - 1] + tiles[i][1] - tiles[i][0] + 1\\n        # print(pre_sum)\\n\\n        ans = 0\\n        j = 0\\n        for i in range(n):\\n            total = 0\\n            while j < n:\\n                if tiles[i][0] + carpetLen - 1 >= tiles[j][1]:\\n                    j += 1\\n                elif tiles[i][0] + carpetLen - 1 >= tiles[j][0]:\\n                    total = (tiles[i][0] + carpetLen - 1) - tiles[j][0] + 1\\n                    break\\n                else:\\n                    break\\n            \\n            if i == 0:\\n                if j != 0:\\n                    total += pre_sum[j - 1]\\n            else:\\n                total += pre_sum[j - 1] - pre_sum[i - 1]\\n            \\n            # print(i, j, total)\\n            ans = max(ans, total)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906271,
                "title": "java-intuitive-sliding-window-o-nlgn",
                "content": "\\nAs optimal value only exists when carpet (window)\\'s right side aligns with a serial of white tiles\\'s right side, we only need to check the covered number of white tiles at that time.\\n\\nSo we sort then just do sliding window.\\n```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        Arrays.sort(tiles, (a, b) -> a[0] - b[0]);\\n        int currNum = 0;\\n        int maxNum = 0;\\n        Queue<int[]> window = new LinkedList<>();\\n        for (int i = 0; i < tiles.length; i++) {\\n            int[] lastSerial = tiles[i];\\n            currNum += lastSerial[1] - lastSerial[0] + 1;\\n            window.offer(lastSerial);\\n            while (window.peek()[1] <= lastSerial[1] - carpetLen) {\\n                int[] excludedTile = window.poll();\\n                currNum -= excludedTile[1] - excludedTile[0] + 1;\\n            }\\n            int covered = currNum - Math.max(0, lastSerial[1] - carpetLen + 1 - window.peek()[0]);\\n            maxNum = Math.max(maxNum, covered);\\n        }\\n        return maxNum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        Arrays.sort(tiles, (a, b) -> a[0] - b[0]);\\n        int currNum = 0;\\n        int maxNum = 0;\\n        Queue<int[]> window = new LinkedList<>();\\n        for (int i = 0; i < tiles.length; i++) {\\n            int[] lastSerial = tiles[i];\\n            currNum += lastSerial[1] - lastSerial[0] + 1;\\n            window.offer(lastSerial);\\n            while (window.peek()[1] <= lastSerial[1] - carpetLen) {\\n                int[] excludedTile = window.poll();\\n                currNum -= excludedTile[1] - excludedTile[0] + 1;\\n            }\\n            int covered = currNum - Math.max(0, lastSerial[1] - carpetLen + 1 - window.peek()[0]);\\n            maxNum = Math.max(maxNum, covered);\\n        }\\n        return maxNum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811720,
                "title": "not-easy-c-solution",
                "content": "# Complexity\\n- Time complexity:\\n0(N * log(N))\\n- Space complexity:\\n0(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int k) {\\n        sort(tiles.begin(),tiles.end());//1 + 7 \\n        int st = 0,wTiles = 0;\\n        int soln = 0;\\n        for(int ed = 0;ed<tiles.size() && soln<k ;ed++){//1-1 10-11\\n           // cout<<\"Execute\";\\n            if(tiles[ed][1]-tiles[st][0]+1<=k){\\n                wTiles += (tiles[ed][1] - tiles[ed][0] + 1);\\n                soln = max(soln,wTiles);\\n            }\\n            else{\\n                while(st<=ed && tiles[ed][1]-tiles[st][0]+1>k){\\n                    int extra = max(0,tiles[st][0] + k - tiles[ed][0]);\\n                    soln = max(soln,wTiles + extra);\\n                    if(st!=ed) wTiles -= (tiles[st][1] - tiles[st][0] + 1);\\n                    st++;\\n                }\\n                if(st<=ed)\\n                wTiles += (tiles[ed][1] - tiles[ed][0] + 1);\\n                soln = max(soln,wTiles);\\n            }\\n        }\\n        return soln;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int k) {\\n        sort(tiles.begin(),tiles.end());//1 + 7 \\n        int st = 0,wTiles = 0;\\n        int soln = 0;\\n        for(int ed = 0;ed<tiles.size() && soln<k ;ed++){//1-1 10-11\\n           // cout<<\"Execute\";\\n            if(tiles[ed][1]-tiles[st][0]+1<=k){\\n                wTiles += (tiles[ed][1] - tiles[ed][0] + 1);\\n                soln = max(soln,wTiles);\\n            }\\n            else{\\n                while(st<=ed && tiles[ed][1]-tiles[st][0]+1>k){\\n                    int extra = max(0,tiles[st][0] + k - tiles[ed][0]);\\n                    soln = max(soln,wTiles + extra);\\n                    if(st!=ed) wTiles -= (tiles[st][1] - tiles[st][0] + 1);\\n                    st++;\\n                }\\n                if(st<=ed)\\n                wTiles += (tiles[ed][1] - tiles[ed][0] + 1);\\n                soln = max(soln,wTiles);\\n            }\\n        }\\n        return soln;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2801682,
                "title": "java-time-o-nlogn-space-o-n-or-o-logn-sorting-sliding-window",
                "content": "```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] t, int c) {\\n        Arrays.sort(t,(a,b)->(a[0]-b[0]));\\n        int n = t.length;\\n        long ans = 0, now = 0;\\n        for(int i=0, j = 0;i<n;i++){\\n            while(j<n&&t[j][1]-t[i][0]+1<=c){\\n                now += t[j][1]-t[j][0]+1;\\n                j++;\\n            }\\n            ans = Math.max(ans, now + (j<n?Math.max(0, t[i][0]+c-t[j][0]):0));\\n            now -= t[i][1]-t[i][0]+1;\\n        }\\n        return (int)ans;\\n    }\\n}\\n\\n\\n\\n//1, 5\\n//10, 14\\n//20, 20\\n//30, 23\\n\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] t, int c) {\\n        Arrays.sort(t,(a,b)->(a[0]-b[0]));\\n        int n = t.length;\\n        long ans = 0, now = 0;\\n        for(int i=0, j = 0;i<n;i++){\\n            while(j<n&&t[j][1]-t[i][0]+1<=c){\\n                now += t[j][1]-t[j][0]+1;\\n                j++;\\n            }\\n            ans = Math.max(ans, now + (j<n?Math.max(0, t[i][0]+c-t[j][0]):0));\\n            now -= t[i][1]-t[i][0]+1;\\n        }\\n        return (int)ans;\\n    }\\n}\\n\\n\\n\\n//1, 5\\n//10, 14\\n//20, 20\\n//30, 23\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801663,
                "title": "java-time-o-nlogn-space-o-n-or-o-logn-prefix-sum-sorting-binary-search-greedy",
                "content": "```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] t, int c) {\\n        Arrays.sort(t,(a,b)->(a[0]-b[0]));\\n        int n = t.length;\\n        int[] sum = new int[n+1];\\n        for(int i=1;i<=n;i++)\\n            sum[i] = sum[i-1] + t[i-1][1] - t[i-1][0] + 1;\\n        \\n        int ans = 0;\\n        for(int i = 0;i <n;i++){\\n            int l = i, r = n-1, target = t[i][0]+c-1;\\n            int index = -1;\\n            while(l<=r){\\n                int mid = (l+r)/2;\\n                if(t[mid][0]<=target){\\n                    l = mid + 1;\\n                    index = mid;\\n                }else{\\n                    r = mid - 1;\\n                }\\n            }\\n            int tmp = sum[index] - sum[i];\\n            if(target>t[index][1]){\\n                tmp += t[index][1] - t[index][0] + 1;\\n            }else{\\n                tmp += target - t[index][0] + 1;\\n            }\\n            ans = Math.max(ans, tmp);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n\\n\\n//1, 5\\n//10, 14\\n//20, 20\\n//30, 23\\n\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] t, int c) {\\n        Arrays.sort(t,(a,b)->(a[0]-b[0]));\\n        int n = t.length;\\n        int[] sum = new int[n+1];\\n        for(int i=1;i<=n;i++)\\n            sum[i] = sum[i-1] + t[i-1][1] - t[i-1][0] + 1;\\n        \\n        int ans = 0;\\n        for(int i = 0;i <n;i++){\\n            int l = i, r = n-1, target = t[i][0]+c-1;\\n            int index = -1;\\n            while(l<=r){\\n                int mid = (l+r)/2;\\n                if(t[mid][0]<=target){\\n                    l = mid + 1;\\n                    index = mid;\\n                }else{\\n                    r = mid - 1;\\n                }\\n            }\\n            int tmp = sum[index] - sum[i];\\n            if(target>t[index][1]){\\n                tmp += t[index][1] - t[index][0] + 1;\\n            }else{\\n                tmp += target - t[index][0] + 1;\\n            }\\n            ans = Math.max(ans, tmp);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n\\n\\n//1, 5\\n//10, 14\\n//20, 20\\n//30, 23\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714775,
                "title": "python3-self-explanatory-code-with-comments-sliding-window",
                "content": "It is optimal to keep starting point of carpet at starting point of each interval , because even if you start at mid interval and it reaches till mid of some another interval , marble covered wont change because if you move carpet towards right to gain 1 marble, you simultaneously loose 1 marble on left.\\n```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLength: int) -> int:\\n        n=len(tiles)\\n        tiles.sort(key=lambda x:x[0]) #sorting on starting point\\n        i,j,whiteMarbel,ans=[0]*4\\n        while i<n:\\n            nextStartingPoint=tiles[i][0]+carpetLength #carpet will cover till nextStartingPoint-1.\\n            partial=0\\n            while j<n and tiles[j][1]<nextStartingPoint:\\n                whiteMarbel+=tiles[j][1]-tiles[j][0]+1 #storing all whitemarbels which are covered by carpet.\\n                j+=1\\n            if j<n:\\n                partial=max(0,nextStartingPoint-tiles[j][0]) #if current laid carpet overlap with partial interval\\n            ans=max(ans,whiteMarbel+partial) #calculating max value \\n            whiteMarbel-=tiles[i][1]-tiles[i][0]+1 #removing value at ith index as we are sliding starting point of carpet to next index\\n            i+=1\\n        return ans\\n```\\n\\'Upvote if you find this useful\\'",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLength: int) -> int:\\n        n=len(tiles)\\n        tiles.sort(key=lambda x:x[0]) #sorting on starting point\\n        i,j,whiteMarbel,ans=[0]*4\\n        while i<n:\\n            nextStartingPoint=tiles[i][0]+carpetLength #carpet will cover till nextStartingPoint-1.\\n            partial=0\\n            while j<n and tiles[j][1]<nextStartingPoint:\\n                whiteMarbel+=tiles[j][1]-tiles[j][0]+1 #storing all whitemarbels which are covered by carpet.\\n                j+=1\\n            if j<n:\\n                partial=max(0,nextStartingPoint-tiles[j][0]) #if current laid carpet overlap with partial interval\\n            ans=max(ans,whiteMarbel+partial) #calculating max value \\n            whiteMarbel-=tiles[i][1]-tiles[i][0]+1 #removing value at ith index as we are sliding starting point of carpet to next index\\n            i+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690289,
                "title": "c-binary-search-prefix-sum-clean-code",
                "content": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpet) {\\n        \\n        sort(tiles.begin() , tiles.end());\\n        \\n        vector< int > nums(tiles.size());\\n        \\n        int n=tiles.size();\\n        \\n         vector<ll> psum(n , 0);\\n        \\n         psum[0]=(tiles[0][1] - tiles[0][0]+1);\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i>=1)\\n            {\\n                psum[i]=psum[i-1] + (tiles[i][1] - tiles[i][0]+1);\\n            }\\n            \\n            nums[i]=tiles[i][0];\\n        }\\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<tiles.size();i++)\\n        {\\n            int reqd = (tiles[i][0] + carpet-1);\\n            \\n            int idx = upper_bound(nums.begin() , nums.end() , reqd)-nums.begin();\\n            \\n            idx--;\\n            \\n            int sum=0;\\n            \\n            if(idx>0)\\n             sum = (   psum[idx-1] - psum[i] + tiles[i][1]-tiles[i][0] +1);\\n            \\n                \\n                \\n            reqd=min(reqd , tiles[idx][1]);\\n            \\n            sum+=(reqd - tiles[idx][0]+1);\\n            \\n            ans=max(ans , sum);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpet) {\\n        \\n        sort(tiles.begin() , tiles.end());\\n        \\n        vector< int > nums(tiles.size());\\n        \\n        int n=tiles.size();\\n        \\n         vector<ll> psum(n , 0);\\n        \\n         psum[0]=(tiles[0][1] - tiles[0][0]+1);\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i>=1)\\n            {\\n                psum[i]=psum[i-1] + (tiles[i][1] - tiles[i][0]+1);\\n            }\\n            \\n            nums[i]=tiles[i][0];\\n        }\\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<tiles.size();i++)\\n        {\\n            int reqd = (tiles[i][0] + carpet-1);\\n            \\n            int idx = upper_bound(nums.begin() , nums.end() , reqd)-nums.begin();\\n            \\n            idx--;\\n            \\n            int sum=0;\\n            \\n            if(idx>0)\\n             sum = (   psum[idx-1] - psum[i] + tiles[i][1]-tiles[i][0] +1);\\n            \\n                \\n                \\n            reqd=min(reqd , tiles[idx][1]);\\n            \\n            sum+=(reqd - tiles[idx][0]+1);\\n            \\n            ans=max(ans , sum);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689971,
                "title": "prefix-sum-binary-search-easy-to-understand-c-code",
                "content": "* ***Using Prefix Sum && Binary Search***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // function for finding the upper bound of the val\\n\\n    int upper_bound(vector<vector<int>>& arr, int low, int n, int val)\\n    {\\n        int high = n - 1;\\n\\n        int ans = n;\\n\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n\\n            if(arr[mid][0] > val)\\n            {\\n                ans = mid;\\n\\n                high = mid - 1;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    int maximumWhiteTiles(vector<vector<int>>& arr, int len) {\\n\\n        int n = arr.size();\\n        \\n        // sort the array \\n\\n        sort(arr.begin(), arr.end());\\n        \\n        // find the prefix sum\\n\\n        vector<int> prefix(n, 0);\\n\\n        prefix[0] = arr[0][1] - arr[0][0] + 1;\\n\\n        for(int i = 1; i < n; i++)\\n        {\\n            prefix[i] = prefix[i - 1] + arr[i][1] - arr[i][0] + 1;\\n        }\\n        \\n        // traverse each interval and find the maxi\\n\\n        int maxi = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            // find the upper bound\\n            \\n            int idx = upper_bound(arr, i + 1, n, (arr[i][0] + len - 1));\\n\\n            idx--;\\n            \\n            // find the sum between [i to idx]\\n\\n            int sum = 0;\\n\\n            if(i > 0)\\n            {\\n                sum -= prefix[i - 1];\\n            }\\n\\n            if(idx > 0)\\n            {\\n                sum += prefix[idx - 1]; \\n            }\\n            \\n            // include the sum of the last interval according to condition\\n\\n            sum += min(arr[idx][1], arr[i][0] + len - 1) - arr[idx][0] + 1;\\n            \\n            // update maxi\\n\\n            maxi = max(maxi, sum);\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // function for finding the upper bound of the val\\n\\n    int upper_bound(vector<vector<int>>& arr, int low, int n, int val)\\n    {\\n        int high = n - 1;\\n\\n        int ans = n;\\n\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n\\n            if(arr[mid][0] > val)\\n            {\\n                ans = mid;\\n\\n                high = mid - 1;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    int maximumWhiteTiles(vector<vector<int>>& arr, int len) {\\n\\n        int n = arr.size();\\n        \\n        // sort the array \\n\\n        sort(arr.begin(), arr.end());\\n        \\n        // find the prefix sum\\n\\n        vector<int> prefix(n, 0);\\n\\n        prefix[0] = arr[0][1] - arr[0][0] + 1;\\n\\n        for(int i = 1; i < n; i++)\\n        {\\n            prefix[i] = prefix[i - 1] + arr[i][1] - arr[i][0] + 1;\\n        }\\n        \\n        // traverse each interval and find the maxi\\n\\n        int maxi = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            // find the upper bound\\n            \\n            int idx = upper_bound(arr, i + 1, n, (arr[i][0] + len - 1));\\n\\n            idx--;\\n            \\n            // find the sum between [i to idx]\\n\\n            int sum = 0;\\n\\n            if(i > 0)\\n            {\\n                sum -= prefix[i - 1];\\n            }\\n\\n            if(idx > 0)\\n            {\\n                sum += prefix[idx - 1]; \\n            }\\n            \\n            // include the sum of the last interval according to condition\\n\\n            sum += min(arr[idx][1], arr[i][0] + len - 1) - arr[idx][0] + 1;\\n            \\n            // update maxi\\n\\n            maxi = max(maxi, sum);\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681229,
                "title": "python-sliding-window-solution-faster-than-90",
                "content": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort(); sz = len(tiles)\\n        left, right, cover, result = 0, 0, 0, 0\\n        while 0 <= right < sz and result < carpetLen:\\n            if left == right or tiles[left][0] + carpetLen > tiles[right][1]:\\n                cover += min(carpetLen, tiles[right][1] - tiles[right][0] + 1)\\n                result = max(result, cover)\\n                right += 1\\n            else:\\n                partial = max(0, tiles[left][0] + carpetLen - tiles[right][0])\\n                result = max(result, cover + partial)\\n                cover -= (tiles[left][1] - tiles[left][0] + 1)\\n                left += 1\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort(); sz = len(tiles)\\n        left, right, cover, result = 0, 0, 0, 0\\n        while 0 <= right < sz and result < carpetLen:\\n            if left == right or tiles[left][0] + carpetLen > tiles[right][1]:\\n                cover += min(carpetLen, tiles[right][1] - tiles[right][0] + 1)\\n                result = max(result, cover)\\n                right += 1\\n            else:\\n                partial = max(0, tiles[left][0] + carpetLen - tiles[right][0])\\n                result = max(result, cover + partial)\\n                cover -= (tiles[left][1] - tiles[left][0] + 1)\\n                left += 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661667,
                "title": "java-prefix-sum-binary-search-with-self-explaining-variable-names",
                "content": "Inspired by published solutions, with more readable variable and function names to help people understand the idea. \\n\\n```\\npublic int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        \\n        Arrays.sort(tiles, (a, b) -> a[0] - b[0]);\\n\\n        int[] prefixSum = new int[tiles.length];\\n        prefixSum[0] = tiles[0][1] - tiles[0][0] + 1;\\n        for (int i = 1; i < tiles.length; i++) {\\n            prefixSum[i] = prefixSum[i-1] + tiles[i][1] - tiles[i][0] + 1;\\n        }\\n\\n\\n        int maxCovered = 0;\\n        for (int i = 0; i < tiles.length; i++) {\\n            int carpetEndPosition = tiles[i][0] + carpetLen - 1;\\n            int lastTileIndex = binSearchForLastCoveredTileIndex(tiles, i, tiles.length - 1, carpetEndPosition);\\n\\n            int lastTileCovered = 0;\\n            if (tiles[lastTileIndex][1] >= carpetEndPosition) {\\n                lastTileCovered = carpetEndPosition - tiles[lastTileIndex][0] + 1;\\n            }\\n            else {\\n                lastTileCovered = tiles[lastTileIndex][1] - tiles[lastTileIndex][0] + 1;\\n            }\\n\\n            int currCovered = (lastTileIndex >= 1 ? prefixSum[lastTileIndex - 1] : 0) - (i >= 1 ? prefixSum[i-1] : 0) + lastTileCovered;\\n            maxCovered = Math.max(maxCovered, currCovered); \\n        }\\n\\n        return maxCovered;\\n    }\\n\\n    private int binSearchForLastCoveredTileIndex(int[][] tiles, int left, int right, int val) {\\n        int mid = 0;\\n        while(left < right - 1) {\\n            mid = left + (right - left) / 2;\\n            if (tiles[mid][0] <= val) {\\n                left = mid;\\n            }\\n            else {\\n                right = mid;\\n            }\\n        }\\n\\n        // Post processing - when the loop stops, left will be right - 1, we need to check for a corner case where the carpet reaches beyond the last tile, and choose the RIGHT position, otherwise we can always choose LEFT.\\n        return tiles[right][0] <= val ? right : left;\\n    }\\n\\t\\n```",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\npublic int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        \\n        Arrays.sort(tiles, (a, b) -> a[0] - b[0]);\\n\\n        int[] prefixSum = new int[tiles.length];\\n        prefixSum[0] = tiles[0][1] - tiles[0][0] + 1;\\n        for (int i = 1; i < tiles.length; i++) {\\n            prefixSum[i] = prefixSum[i-1] + tiles[i][1] - tiles[i][0] + 1;\\n        }\\n\\n\\n        int maxCovered = 0;\\n        for (int i = 0; i < tiles.length; i++) {\\n            int carpetEndPosition = tiles[i][0] + carpetLen - 1;\\n            int lastTileIndex = binSearchForLastCoveredTileIndex(tiles, i, tiles.length - 1, carpetEndPosition);\\n\\n            int lastTileCovered = 0;\\n            if (tiles[lastTileIndex][1] >= carpetEndPosition) {\\n                lastTileCovered = carpetEndPosition - tiles[lastTileIndex][0] + 1;\\n            }\\n            else {\\n                lastTileCovered = tiles[lastTileIndex][1] - tiles[lastTileIndex][0] + 1;\\n            }\\n\\n            int currCovered = (lastTileIndex >= 1 ? prefixSum[lastTileIndex - 1] : 0) - (i >= 1 ? prefixSum[i-1] : 0) + lastTileCovered;\\n            maxCovered = Math.max(maxCovered, currCovered); \\n        }\\n\\n        return maxCovered;\\n    }\\n\\n    private int binSearchForLastCoveredTileIndex(int[][] tiles, int left, int right, int val) {\\n        int mid = 0;\\n        while(left < right - 1) {\\n            mid = left + (right - left) / 2;\\n            if (tiles[mid][0] <= val) {\\n                left = mid;\\n            }\\n            else {\\n                right = mid;\\n            }\\n        }\\n\\n        // Post processing - when the loop stops, left will be right - 1, we need to check for a corner case where the carpet reaches beyond the last tile, and choose the RIGHT position, otherwise we can always choose LEFT.\\n        return tiles[right][0] <= val ? right : left;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2643457,
                "title": "python-nlog-n-time-acc-sum-binary-search",
                "content": "class Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n\\n        lenT = len(tiles)\\n        tiles.sort()\\n        accSum = [0]\\n        \\n        for t in range(lenT):\\n            accSum.append(tiles[t][1] - tiles[t][0] + 1 + accSum[-1])\\n    \\n        maxLen = 0\\n        for i in range(lenT):\\n            \\n            tmp = 0\\n            left  = tiles[i][0] \\n            right = tiles[i][0] + carpetLen - 1\\n            \\n            rPos = bisect.bisect_right(tiles, right, key = lambda x: x[0])\\n            tmp = accSum[rPos - 1] - accSum[i]\\n\\n            if(tiles[rPos - 1][1] >= right):\\n                tmp += right - tiles[rPos - 1][0] + 1\\n            else:\\n                tmp += tiles[rPos - 1][1] - tiles[rPos - 1][0] + 1\\n                \\n            maxLen = max(tmp, maxLen)\\n                       \\n        return maxLen",
                "solutionTags": [],
                "code": "class Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n\\n        lenT = len(tiles)\\n        tiles.sort()\\n        accSum = [0]\\n        \\n        for t in range(lenT):\\n            accSum.append(tiles[t][1] - tiles[t][0] + 1 + accSum[-1])\\n    \\n        maxLen = 0\\n        for i in range(lenT):\\n            \\n            tmp = 0\\n            left  = tiles[i][0] \\n            right = tiles[i][0] + carpetLen - 1\\n            \\n            rPos = bisect.bisect_right(tiles, right, key = lambda x: x[0])\\n            tmp = accSum[rPos - 1] - accSum[i]\\n\\n            if(tiles[rPos - 1][1] >= right):\\n                tmp += right - tiles[rPos - 1][0] + 1\\n            else:\\n                tmp += tiles[rPos - 1][1] - tiles[rPos - 1][0] + 1\\n                \\n            maxLen = max(tmp, maxLen)\\n                       \\n        return maxLen",
                "codeTag": "Java"
            },
            {
                "id": 2623212,
                "title": "c-nlog-n-solution-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(), tiles.end());\\n        \\n        int empty = 0;\\n        \\n        int i=0, j=0,ans = 1, n = tiles.size();\\n        \\n        while(j<n){\\n            \\n            if(tiles[j][1] - tiles[j][0] + 1 >= carpetLen)\\n                return carpetLen;\\n\\n            while(i<j && tiles[j][1] - tiles[i][0] + 1 > carpetLen){\\n                ans = max(ans, carpetLen - empty);\\n                empty -= tiles[i+1][0]-tiles[i][1]-1;\\n                i++;\\n            }\\n        \\n            while(j<n && tiles[j][1] - tiles[i][0] +1 <= carpetLen){\\n                 ans = max(ans, tiles[j][1] - tiles[i][0] + 1 - empty);\\n                \\n                if(j<n-1)\\n                    empty += tiles[j+1][0]-tiles[j][1]-1;\\n                \\n                j++;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(), tiles.end());\\n        \\n        int empty = 0;\\n        \\n        int i=0, j=0,ans = 1, n = tiles.size();\\n        \\n        while(j<n){\\n            \\n            if(tiles[j][1] - tiles[j][0] + 1 >= carpetLen)\\n                return carpetLen;\\n\\n            while(i<j && tiles[j][1] - tiles[i][0] + 1 > carpetLen){\\n                ans = max(ans, carpetLen - empty);\\n                empty -= tiles[i+1][0]-tiles[i][1]-1;\\n                i++;\\n            }\\n        \\n            while(j<n && tiles[j][1] - tiles[i][0] +1 <= carpetLen){\\n                 ans = max(ans, tiles[j][1] - tiles[i][0] + 1 - empty);\\n                \\n                if(j<n-1)\\n                    empty += tiles[j+1][0]-tiles[j][1]-1;\\n                \\n                j++;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2605564,
                "title": "java-prefix-sum-binary-search",
                "content": "```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] arr, int len) {\\n        int max = 0;\\n        \\n        Arrays.sort(arr, (a,b)->{\\n           return a[0] - b[0]; \\n        });\\n        \\n        \\n        int[] pre = new int[arr.length];\\n        for(int i = 0 ; i< pre.length ; i ++){\\n            pre[i] = (i== 0 ? 0 : pre[i - 1]) + arr[i][1] - arr[i][0] + 1;\\n        }\\n        \\n        // System.out.println(Arrays.toString(pre));\\n        \\n        for(int i = 0 ; i < arr.length ; i ++){\\n            int end = arr[i][0] + len;\\n            int f = getLen(arr, end, pre) - (i == 0 ? 0 : pre[i-1]);\\n            // System.out.println(end + \" \" + f);\\n            max = Math.max(f, max);\\n        }\\n        return max;\\n    }\\n    public int getLen(int[][] arr, int end, int[] pre){\\n        int i = 0 ; int j = arr.length - 1;\\n        \\n        int ans = 0;\\n        \\n        while(i <= j){\\n            int m = i + (j-i)/2;\\n            if(arr[m][0] <= end && arr[m][1] >= end){\\n                ans = m;\\n                break;\\n            }else if(arr[m][1] < end){\\n                ans = m;\\n                i = m + 1;\\n            }else{\\n                j = m - 1;\\n            }\\n        }\\n        \\n        if(arr[ans][0] <= end && arr[ans][1] >= end) return pre[ans] - (arr[ans][1] - end + 1);\\n        else return pre[ans];\\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public int maximumWhiteTiles(int[][] arr, int len) {\\n        int max = 0;\\n        \\n        Arrays.sort(arr, (a,b)->{\\n           return a[0] - b[0]; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2546881,
                "title": "sliding-window-python",
                "content": "We could maintain a window[i...j] such that tiles[i..j-1] all intersect (are covered fully or covered some parts) with carpet starting at tiles[i]\\'s beginning.\\n```\\ndef maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles = sorted(tiles)\\n        j, res, curr, n = 0, 0, 0, len(tiles)\\n        length = lambda i : tiles[i][1] - tiles[i][0] + 1\\n        for i in range(n):\\n            right_most = tiles[i][0] + carpetLen - 1\\n            while j < n and tiles[j][0] <= right_most:\\n                curr += length(j)\\n                j = j + 1\\n            offset = max(0, tiles[j - 1][1] - right_most)\\n            res = max(res, curr - offset)\\n            curr -= length(i)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles = sorted(tiles)\\n        j, res, curr, n = 0, 0, 0, len(tiles)\\n        length = lambda i : tiles[i][1] - tiles[i][0] + 1\\n        for i in range(n):\\n            right_most = tiles[i][0] + carpetLen - 1\\n            while j < n and tiles[j][0] <= right_most:\\n                curr += length(j)\\n                j = j + 1\\n            offset = max(0, tiles[j - 1][1] - right_most)\\n            res = max(res, curr - offset)\\n            curr -= length(i)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2546877,
                "title": "sliding-window-python",
                "content": "```\\ndef maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles = sorted(tiles)\\n        j, res, curr, n = 0, 0, 0, len(tiles)\\n        length = lambda i : tiles[i][1] - tiles[i][0] + 1\\n        for i in range(n):\\n            right_most = tiles[i][0] + carpetLen - 1\\n            while j < n and tiles[j][0] <= right_most:\\n                curr += length(j)\\n                j = j + 1\\n            offset = max(0, tiles[j - 1][1] - right_most)\\n            res = max(res, curr - offset)\\n            curr -= length(i)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles = sorted(tiles)\\n        j, res, curr, n = 0, 0, 0, len(tiles)\\n        length = lambda i : tiles[i][1] - tiles[i][0] + 1\\n        for i in range(n):\\n            right_most = tiles[i][0] + carpetLen - 1\\n            while j < n and tiles[j][0] <= right_most:\\n                curr += length(j)\\n                j = j + 1\\n            offset = max(0, tiles[j - 1][1] - right_most)\\n            res = max(res, curr - offset)\\n            curr -= length(i)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2521036,
                "title": "java-sliding-window-o-nlogn-sorting",
                "content": "```\\n    // sliding window\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        int res = 0, l = 0, r = 0, curCover = 0;\\n        // sort the tiles by its starting index(ascending order)\\n        // O(NlogN) -> N == tiles.length\\n        Arrays.sort(tiles, (a,b) -> a[0] - b[0]);\\n        \\n        // iterate from left to right, O(N)\\n        // It\\'s always optimal to cover carpet at the starting index of any white tile range\\n        while(r < tiles.length){\\n            // carpet can cover current white tile range\\n            // must be \">\", not \">=\", [1,5], carpetLen = 4 \\n            // -> white tiles length == 5, 4 is not enough to cover the whole white tiles\\n            if(tiles[l][0] + carpetLen > tiles[r][1]){\\n                // update covered length\\n                curCover += tiles[r][1] - tiles[r][0] + 1;\\n                res = Math.max(res, curCover);\\n                \\n                // expand window\\n                r++;\\n            } else {\\n                // the remaining carpet may cover non-white tiles OR partial white tiles\\n                int partial = Math.max(0, tiles[l][0] + carpetLen - tiles[r][0]);\\n                // update covered length\\n                res = Math.max(res, curCover + partial);\\n                \\n                // shrink window\\n                curCover -= (tiles[l][1] - tiles[l][0] + 1);\\n                l++;\\n                \\n                // edge case : [1,5],[6,10], carpetLen = 1\\n                if(l > r){\\n                    // reset window\\n                    r = l; \\n                    curCover = 0;\\n                } \\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\n    // sliding window\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        int res = 0, l = 0, r = 0, curCover = 0;\\n        // sort the tiles by its starting index(ascending order)\\n        // O(NlogN) -> N == tiles.length\\n        Arrays.sort(tiles, (a,b) -> a[0] - b[0]);\\n        \\n        // iterate from left to right, O(N)\\n        // It\\'s always optimal to cover carpet at the starting index of any white tile range\\n        while(r < tiles.length){\\n            // carpet can cover current white tile range\\n            // must be \">\", not \">=\", [1,5], carpetLen = 4 \\n            // -> white tiles length == 5, 4 is not enough to cover the whole white tiles\\n            if(tiles[l][0] + carpetLen > tiles[r][1]){\\n                // update covered length\\n                curCover += tiles[r][1] - tiles[r][0] + 1;\\n                res = Math.max(res, curCover);\\n                \\n                // expand window\\n                r++;\\n            } else {\\n                // the remaining carpet may cover non-white tiles OR partial white tiles\\n                int partial = Math.max(0, tiles[l][0] + carpetLen - tiles[r][0]);\\n                // update covered length\\n                res = Math.max(res, curCover + partial);\\n                \\n                // shrink window\\n                curCover -= (tiles[l][1] - tiles[l][0] + 1);\\n                l++;\\n                \\n                // edge case : [1,5],[6,10], carpetLen = 1\\n                if(l > r){\\n                    // reset window\\n                    r = l; \\n                    curCover = 0;\\n                } \\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2495445,
                "title": "scala-recursion",
                "content": "```scala\\nimport scala.collection.immutable.Queue\\n\\ncase class Interval(from: Int, to: Int) {\\n  def size = coverSize(to)\\n  def coverSize(till: Int) = math.max(0, till - from + 1)\\n}\\n\\ndef maximumWhiteTiles(tiles: Array[Array[Int]], carpetLen: Int): Int = {\\n  val sorted = tiles.collect { case Array(from , to) => Interval(from, to) }.sortBy(_.from).toList\\n  if (sorted.exists(_.size >= carpetLen)) carpetLen\\n  else {\\n    val coverTo = sorted.head.from + carpetLen - 1\\n    val covered = Queue.from(sorted.takeWhile(_.to <= coverTo))\\n    val coverSum = covered.map(_.size).sum\\n    go(carpetLen - 1, covered, coverSum, Int.MinValue, sorted.drop(covered.size))\\n  }\\n}\\n\\ndef go(carpetLen: Int, covered: Queue[Interval], coverSum: Int, maxSeen: Int, remaining: List[Interval]): Int =\\n  remaining match {\\n    case Nil => math.max(maxSeen, coverSum)\\n    case h :: tail =>\\n      val nMaxSeen = math.max(maxSeen, coverSum + h.coverSize(covered.head.from + carpetLen))\\n      val (deqeueued, queue) = covered.dequeue\\n\\n      val nCoverTo = queue.headOption.getOrElse(h).from + carpetLen\\n      val nCovered = remaining.takeWhile(_.to <= nCoverTo)\\n      val nCoverSum = coverSum + nCovered.map(_.size).sum - deqeueued.size\\n\\n      go(carpetLen, queue.enqueueAll(nCovered), nCoverSum, nMaxSeen, remaining.drop(nCovered.size))\\n  }\\n  ```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\nimport scala.collection.immutable.Queue\\n\\ncase class Interval(from: Int, to: Int) {\\n  def size = coverSize(to)\\n  def coverSize(till: Int) = math.max(0, till - from + 1)\\n}\\n\\ndef maximumWhiteTiles(tiles: Array[Array[Int]], carpetLen: Int): Int = {\\n  val sorted = tiles.collect { case Array(from , to) => Interval(from, to) }.sortBy(_.from).toList\\n  if (sorted.exists(_.size >= carpetLen)) carpetLen\\n  else {\\n    val coverTo = sorted.head.from + carpetLen - 1\\n    val covered = Queue.from(sorted.takeWhile(_.to <= coverTo))\\n    val coverSum = covered.map(_.size).sum\\n    go(carpetLen - 1, covered, coverSum, Int.MinValue, sorted.drop(covered.size))\\n  }\\n}\\n\\ndef go(carpetLen: Int, covered: Queue[Interval], coverSum: Int, maxSeen: Int, remaining: List[Interval]): Int =\\n  remaining match {\\n    case Nil => math.max(maxSeen, coverSum)\\n    case h :: tail =>\\n      val nMaxSeen = math.max(maxSeen, coverSum + h.coverSize(covered.head.from + carpetLen))\\n      val (deqeueued, queue) = covered.dequeue\\n\\n      val nCoverTo = queue.headOption.getOrElse(h).from + carpetLen\\n      val nCovered = remaining.takeWhile(_.to <= nCoverTo)\\n      val nCoverSum = coverSum + nCovered.map(_.size).sum - deqeueued.size\\n\\n      go(carpetLen, queue.enqueueAll(nCovered), nCoverSum, nMaxSeen, remaining.drop(nCovered.size))\\n  }\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 2473921,
                "title": "c-prefix-sum-binary-search",
                "content": "Intuition : The starting point of carpet will be beginning of a tile else we\\'ll be losing out area. Place carpet at given index and use prefix sum to get diff of range of tiles. Addionally last range of tile might not be fully covered, so remove uncovered part.\\n\\n```\\nclass Solution {\\npublic:\\n    int getIdxAfter(int val, vector<vector<int>> &tiles){\\n        int lo=0, hi=tiles.size()-1, mid;\\n        while(lo<hi){\\n            mid=lo+(hi-lo)/2;\\n            if(tiles[mid][0]>val)\\n                hi=mid;\\n            else\\n                lo=mid+1;\\n        }\\n        return lo;\\n    }\\n    \\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        int n=tiles.size(), endPoint, idx, lenCovered, res=0;\\n        vector<int> prefixSum(n+1,0);\\n        sort(tiles.begin(), tiles.end());\\n        tiles.push_back({INT_MAX, INT_MAX});\\n        \\n        //cal prefix sum\\n        for(int i=1;i<=n;i++)\\n            prefixSum[i] = prefixSum[i-1]+(tiles[i-1][1]-tiles[i-1][0]+1);\\n        \\n        for(int i=0;i<n;i++){\\n            endPoint = tiles[i][0]+carpetLen-1;\\n            idx = getIdxAfter(endPoint, tiles);\\n            lenCovered = prefixSum[idx]-prefixSum[i] - max(0, tiles[idx-1][1]-endPoint);\\n            res=max(res, lenCovered);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getIdxAfter(int val, vector<vector<int>> &tiles){\\n        int lo=0, hi=tiles.size()-1, mid;\\n        while(lo<hi){\\n            mid=lo+(hi-lo)/2;\\n            if(tiles[mid][0]>val)\\n                hi=mid;\\n            else\\n                lo=mid+1;\\n        }\\n        return lo;\\n    }\\n    \\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        int n=tiles.size(), endPoint, idx, lenCovered, res=0;\\n        vector<int> prefixSum(n+1,0);\\n        sort(tiles.begin(), tiles.end());\\n        tiles.push_back({INT_MAX, INT_MAX});\\n        \\n        //cal prefix sum\\n        for(int i=1;i<=n;i++)\\n            prefixSum[i] = prefixSum[i-1]+(tiles[i-1][1]-tiles[i-1][0]+1);\\n        \\n        for(int i=0;i<n;i++){\\n            endPoint = tiles[i][0]+carpetLen-1;\\n            idx = getIdxAfter(endPoint, tiles);\\n            lenCovered = prefixSum[idx]-prefixSum[i] - max(0, tiles[idx-1][1]-endPoint);\\n            res=max(res, lenCovered);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447517,
                "title": "c-solution-important-observations-to-keep-in-mind",
                "content": "This solution is inpired by [https://leetcode.com/votrubac/](http://). I tried to add some important points to the same in order to make this understanding easier.\\n\\nObservation 1: It is always optimal to place the carpet on the starting tile. \\nThis about this try to do some dry runs on different examples to see why this is true. One possible explanation to this is that if we place the carpet on a non-white tile then we are already minimizing the number of white tiles that we are placing under the carpet. If we place the carpet on a white tile that is not the starting tile then we are also sacrificing some white tiles in the beginning for some other tiles since the length of the carpet remains constant we are adding and losing the same number of white and non-whites tiles.\\n\\nCode Explanation\\nWe use the start and the end of the ranges as how many number of tiles we need to add to our sum now either the carpet fully covers the tile path of partially covers it we add the number of tile accordingly.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& a, int len) {\\n        \\n        sort(a.begin(), a.end());\\n        int n = a.size(), j = 0, i = 0, sum = 0, res = 0;\\n        while(i < n) {\\n            if(i == j or a[j][0] + len > a[i][1]) {\\n                sum += a[i][1] - a[i][0] + 1;\\n                res = max(res, sum);\\n                i += 1;\\n            }\\n            else {\\n                res = max(res, sum + max(0, a[j][0] + len - a[i][0]));\\n                sum -= a[j][1] - a[j][0] + 1;\\n                j += 1;\\n            }\\n        }\\n        \\n        return min(len,res);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& a, int len) {\\n        \\n        sort(a.begin(), a.end());\\n        int n = a.size(), j = 0, i = 0, sum = 0, res = 0;\\n        while(i < n) {\\n            if(i == j or a[j][0] + len > a[i][1]) {\\n                sum += a[i][1] - a[i][0] + 1;\\n                res = max(res, sum);\\n                i += 1;\\n            }\\n            else {\\n                res = max(res, sum + max(0, a[j][0] + len - a[i][0]));\\n                sum -= a[j][1] - a[j][0] + 1;\\n                j += 1;\\n            }\\n        }\\n        \\n        return min(len,res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401713,
                "title": "rust-solution-using-sliding-window",
                "content": "```\\nimpl Solution {\\n    pub fn maximum_white_tiles(mut tiles: Vec<Vec<i32>>, carpet_len: i32) -> i32 {\\n        let n = tiles.len();\\n        tiles.sort_by(|a,b| a[0].cmp(&b[0]));\\n\\n        let mut stack = vec![tiles[0][1] - tiles[0][0] + 1];\\n        for i in 1..n {\\n            stack.push(tiles[i][0] - tiles[i-1][1] - 1);\\n            stack.push(tiles[i][1] - tiles[i][0] + 1);\\n        }\\n        \\n        let n = stack.len();\\n        let mut memo = vec![(0,0,false);n+1];\\n\\n        for i in 0..n {\\n            memo[i+1].0 = memo[i].0;\\n            memo[i+1].1 = memo[i].1;\\n            memo[i+1].0 += stack[i];\\n            if i % 2 == 0 {\\n                memo[i+1].1 += stack[i];\\n                memo[i+1].2 = true;\\n            } \\n        }\\n\\n        let mut max = 0;\\n        let mut ri = 0;\\n        for li in 0..n {\\n            while ri < n && memo[ri].0 - memo[li].0 <= carpet_len {\\n                ri += 1;\\n            }\\n\\n            let sum = memo[ri].0 - memo[li].0;\\n            let score = memo[ri].1 - memo[li].1;\\n            if memo[ri].2 {\\n                if sum < carpet_len {\\n                    max = std::cmp::max(max, score);\\n                } else {\\n                    let over = sum - carpet_len;\\n                    let actual_score = score - over;\\n                    max = std::cmp::max(max, actual_score);\\n                }\\n                } else {\\n                max = std::cmp::max(max, score);\\n            }\\n        }\\n\\n        max.min(carpet_len)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Sliding Window"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_white_tiles(mut tiles: Vec<Vec<i32>>, carpet_len: i32) -> i32 {\\n        let n = tiles.len();\\n        tiles.sort_by(|a,b| a[0].cmp(&b[0]));\\n\\n        let mut stack = vec![tiles[0][1] - tiles[0][0] + 1];\\n        for i in 1..n {\\n            stack.push(tiles[i][0] - tiles[i-1][1] - 1);\\n            stack.push(tiles[i][1] - tiles[i][0] + 1);\\n        }\\n        \\n        let n = stack.len();\\n        let mut memo = vec![(0,0,false);n+1];\\n\\n        for i in 0..n {\\n            memo[i+1].0 = memo[i].0;\\n            memo[i+1].1 = memo[i].1;\\n            memo[i+1].0 += stack[i];\\n            if i % 2 == 0 {\\n                memo[i+1].1 += stack[i];\\n                memo[i+1].2 = true;\\n            } \\n        }\\n\\n        let mut max = 0;\\n        let mut ri = 0;\\n        for li in 0..n {\\n            while ri < n && memo[ri].0 - memo[li].0 <= carpet_len {\\n                ri += 1;\\n            }\\n\\n            let sum = memo[ri].0 - memo[li].0;\\n            let score = memo[ri].1 - memo[li].1;\\n            if memo[ri].2 {\\n                if sum < carpet_len {\\n                    max = std::cmp::max(max, score);\\n                } else {\\n                    let over = sum - carpet_len;\\n                    let actual_score = score - over;\\n                    max = std::cmp::max(max, actual_score);\\n                }\\n                } else {\\n                max = std::cmp::max(max, score);\\n            }\\n        }\\n\\n        max.min(carpet_len)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2393976,
                "title": "c-slidingwindow-vs-segmenttree",
                "content": "Solution 1: Sliding Window, TimeComplexy= O(N)\\n\\n```\\n        public int MaximumWhiteTiles(int[][] tiles, int carpetLen)\\n        {\\n            tiles = tiles.OrderBy(x => x[0]).ToArray();//sort then move from left to right\\n            int n = tiles.Length;\\n            int res = 0;\\n            int left = 0;//the left most tile\\n            int sum = 0;\\n            for(int i = 0; i < n; i++)\\n            {\\n                if (tiles[left][0] + carpetLen-1 < tiles[i][1])//if we cannot cover whole i-th tile\\n                {\\n                    if(tiles[left][0] + carpetLen-1 >= tiles[i][0])\\n                        res = Math.Max(res, sum + tiles[left][0] + carpetLen-1 - tiles[i][0]+1);//update res\\n                    //move left step by step until we can cover whole i-th tile or failed (left=i+1)\\n\\t\\t\\t\\t\\twhile(left<=i && tiles[left][0] + carpetLen-1 < tiles[i][1])\\n                    {\\n                        sum -= tiles[left][1] - tiles[left][0] + 1;\\n                        left++;\\n\\t\\t\\t\\t\\t\\t//here we must update res again, or fail with testcase 44\\n                        if (left<=i && tiles[left][0] + carpetLen - 1 >= tiles[i][0] && tiles[left][0] + carpetLen - 1< tiles[i][1])\\n                            res = Math.Max(res, sum + tiles[left][0] + carpetLen - 1 - tiles[i][0] + 1);\\n                    }\\n                    if (left <= i)//if finally we can cover whole current i-th tile\\n                    {\\n                        sum += tiles[i][1] - tiles[i][0] + 1;\\n                        res = Math.Max(res, sum);\\n                    }\\n                }\\n                else\\n                {\\n                    sum += tiles[i][1] - tiles[i][0] +1;//we can cover current i-th tile without move left\\n                    res = Math.Max(res, sum);\\n                }\\n            }\\n            return res;\\n        }\\n\\n```\\n\\nSolution 2 : Segment Tree, TimeComplexy= O(NLogN)\\n\\nThis question is very similar to other segment tree problem , eg. :\\n* [729. My Calendar I ](https://leetcode.com/problems/my-calendar-i/)\\n* [2276. Count Integers in Intervals](https://leetcode.com/problems/count-integers-in-intervals/)\\n\\nAll these problems share same requirements :\\n* Insert intervals to a huge range , eg [1,1_000_000_000]\\n* Count how many covered in query range [left,right]\\n\\n```\\n        public int MaximumWhiteTiles(int[][] tiles, int carpetLen)\\n        {\\n            int res = 0;\\n            int left = tiles.Min(x => x[0]);\\n            int right = tiles.Max(x => x[1]);\\n            var tree = new SegmentIntervalTree(left, right);//tree\\'s range\\n            //var tree = new SegmentIntervalTree(1, 1_000_000_000);\\n            foreach (var i in tiles)\\n                tree.Insert(i[0], i[1]);//insert all interval to tree\\n            foreach(var i in tiles)\\n                res = Math.Max(res, tree.Count(i[0], i[0] + carpetLen - 1));//get how many points in tree of range [tile[i][0], tile[i][0]+carpetLen)\\n            return res;\\n        }\\n\\t\\t    public class SegmentIntervalTree\\n    {\\n        public readonly SegmentNode root;\\n        //lazy build for merge intervals, 1_000_000_000 is too big for normal segment tree\\n        public SegmentIntervalTree(int start, int end)\\n        {\\n            this.root = new SegmentNode(start, end);\\n        }\\n        public void Insert(int left, int right)\\n        {\\n            insertInternal(root, Math.Max(root.start, left),Math.Min(root.end, right));\\n        }\\n        private long insertInternal(SegmentNode node, int left, int right)\\n        {\\n            //all range of [start,end] already visited\\n            if (node.sum == node.end - node.start + 1)\\n                return node.sum;\\n            //if it will cover the whole range of this node\\n            //reduce memory cost,eg a 2^10 big node only cost 1, but 2^10 nodes with 1 will cost 2^10\\n            if (node.start == left && node.end == right)\\n            {\\n                node.sum = right - left + 1;\\n                return node.sum;\\n            }\\n            int mid = node.start + (node.end - node.start) / 2;\\n            if(node.left == null)//lazy build\\n            {\\n                node.left = new SegmentNode(node.start, mid);\\n                node.right = new SegmentNode(mid + 1, node.end);\\n            }\\n            if (right <= mid)\\n                insertInternal(node.left, left, right);\\n            else if(left>mid)\\n                insertInternal(node.right, left, right);\\n            else\\n            {\\n                insertInternal(node.left, left, mid);\\n                insertInternal(node.right, mid+1, right);\\n            }\\n            node.sum = node.left.sum + node.right.sum;\\n            return node.sum;\\n        }\\n        public int Count(int left=int.MinValue,int right=int.MaxValue)\\n        {\\n            if (left == int.MinValue)\\n                return (int)countInternal(root, root.start, root.end);\\n            else\\n                return (int)countInternal(root, Math.Max(root.start, left), Math.Min(root.end, right));\\n        }\\n        private long countInternal(SegmentNode node, int left, int right)\\n        {\\n            if (node == null) return 0;\\n            //all range of [start,end] already visited\\n            if (node.sum == node.end - node.start + 1)\\n                return right -left+1;\\n            if (node.start == left && node.end == right)\\n            {\\n                return node.sum;\\n            }\\n            else\\n            {\\n                int mid = node.start + (node.end - node.start) / 2;\\n                if (mid + 1 <= left)\\n                {\\n                    return countInternal(node.right, left, right);\\n                }\\n                else if (mid >= right)\\n                {\\n                    return countInternal(node.left, left, right);\\n                }\\n                else\\n                {\\n                    return countInternal(node.left, left, mid)+ countInternal(node.right, mid+1, right);\\n                }\\n            }\\n        }\\n    }\\n    public class SegmentNode\\n    {\\n        public readonly int start, end;\\n        public SegmentNode left, right;\\n        public long sum = 0;\\n        public SegmentNode(int start, int end)\\n        {\\n            this.start = start;\\n            this.end = end;\\n        }\\n    }\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\n        public int MaximumWhiteTiles(int[][] tiles, int carpetLen)\\n        {\\n            tiles = tiles.OrderBy(x => x[0]).ToArray();//sort then move from left to right\\n            int n = tiles.Length;\\n            int res = 0;\\n            int left = 0;//the left most tile\\n            int sum = 0;\\n            for(int i = 0; i < n; i++)\\n            {\\n                if (tiles[left][0] + carpetLen-1 < tiles[i][1])//if we cannot cover whole i-th tile\\n                {\\n                    if(tiles[left][0] + carpetLen-1 >= tiles[i][0])\\n                        res = Math.Max(res, sum + tiles[left][0] + carpetLen-1 - tiles[i][0]+1);//update res\\n                    //move left step by step until we can cover whole i-th tile or failed (left=i+1)\\n\\t\\t\\t\\t\\twhile(left<=i && tiles[left][0] + carpetLen-1 < tiles[i][1])\\n                    {\\n                        sum -= tiles[left][1] - tiles[left][0] + 1;\\n                        left++;\\n\\t\\t\\t\\t\\t\\t//here we must update res again, or fail with testcase 44\\n                        if (left<=i && tiles[left][0] + carpetLen - 1 >= tiles[i][0] && tiles[left][0] + carpetLen - 1< tiles[i][1])\\n                            res = Math.Max(res, sum + tiles[left][0] + carpetLen - 1 - tiles[i][0] + 1);\\n                    }\\n                    if (left <= i)//if finally we can cover whole current i-th tile\\n                    {\\n                        sum += tiles[i][1] - tiles[i][0] + 1;\\n                        res = Math.Max(res, sum);\\n                    }\\n                }\\n                else\\n                {\\n                    sum += tiles[i][1] - tiles[i][0] +1;//we can cover current i-th tile without move left\\n                    res = Math.Max(res, sum);\\n                }\\n            }\\n            return res;\\n        }\\n\\n```\n```\\n        public int MaximumWhiteTiles(int[][] tiles, int carpetLen)\\n        {\\n            int res = 0;\\n            int left = tiles.Min(x => x[0]);\\n            int right = tiles.Max(x => x[1]);\\n            var tree = new SegmentIntervalTree(left, right);//tree\\'s range\\n            //var tree = new SegmentIntervalTree(1, 1_000_000_000);\\n            foreach (var i in tiles)\\n                tree.Insert(i[0], i[1]);//insert all interval to tree\\n            foreach(var i in tiles)\\n                res = Math.Max(res, tree.Count(i[0], i[0] + carpetLen - 1));//get how many points in tree of range [tile[i][0], tile[i][0]+carpetLen)\\n            return res;\\n        }\\n\\t\\t    public class SegmentIntervalTree\\n    {\\n        public readonly SegmentNode root;\\n        //lazy build for merge intervals, 1_000_000_000 is too big for normal segment tree\\n        public SegmentIntervalTree(int start, int end)\\n        {\\n            this.root = new SegmentNode(start, end);\\n        }\\n        public void Insert(int left, int right)\\n        {\\n            insertInternal(root, Math.Max(root.start, left),Math.Min(root.end, right));\\n        }\\n        private long insertInternal(SegmentNode node, int left, int right)\\n        {\\n            //all range of [start,end] already visited\\n            if (node.sum == node.end - node.start + 1)\\n                return node.sum;\\n            //if it will cover the whole range of this node\\n            //reduce memory cost,eg a 2^10 big node only cost 1, but 2^10 nodes with 1 will cost 2^10\\n            if (node.start == left && node.end == right)\\n            {\\n                node.sum = right - left + 1;\\n                return node.sum;\\n            }\\n            int mid = node.start + (node.end - node.start) / 2;\\n            if(node.left == null)//lazy build\\n            {\\n                node.left = new SegmentNode(node.start, mid);\\n                node.right = new SegmentNode(mid + 1, node.end);\\n            }\\n            if (right <= mid)\\n                insertInternal(node.left, left, right);\\n            else if(left>mid)\\n                insertInternal(node.right, left, right);\\n            else\\n            {\\n                insertInternal(node.left, left, mid);\\n                insertInternal(node.right, mid+1, right);\\n            }\\n            node.sum = node.left.sum + node.right.sum;\\n            return node.sum;\\n        }\\n        public int Count(int left=int.MinValue,int right=int.MaxValue)\\n        {\\n            if (left == int.MinValue)\\n                return (int)countInternal(root, root.start, root.end);\\n            else\\n                return (int)countInternal(root, Math.Max(root.start, left), Math.Min(root.end, right));\\n        }\\n        private long countInternal(SegmentNode node, int left, int right)\\n        {\\n            if (node == null) return 0;\\n            //all range of [start,end] already visited\\n            if (node.sum == node.end - node.start + 1)\\n                return right -left+1;\\n            if (node.start == left && node.end == right)\\n            {\\n                return node.sum;\\n            }\\n            else\\n            {\\n                int mid = node.start + (node.end - node.start) / 2;\\n                if (mid + 1 <= left)\\n                {\\n                    return countInternal(node.right, left, right);\\n                }\\n                else if (mid >= right)\\n                {\\n                    return countInternal(node.left, left, right);\\n                }\\n                else\\n                {\\n                    return countInternal(node.left, left, mid)+ countInternal(node.right, mid+1, right);\\n                }\\n            }\\n        }\\n    }\\n    public class SegmentNode\\n    {\\n        public readonly int start, end;\\n        public SegmentNode left, right;\\n        public long sum = 0;\\n        public SegmentNode(int start, int end)\\n        {\\n            this.start = start;\\n            this.end = end;\\n        }\\n    }\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381696,
                "title": "sliding-window-with-comments",
                "content": "\\n```\\npublic class Solution {\\n    public int MaximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        int l =0, r =0, cur =0,ans = int.MinValue;\\n        Array.Sort(tiles, (x,y)=>x[0] - y[0]);\\n        while(r<tiles.Length)\\n        {\\n            cur += tiles[r][1] - tiles[r][0] + 1;//Pull the carpet over the new range of tiles. Add the whole range to result.\\n            int carpetLeft = tiles[r][1] - carpetLen + 1; // Find out the left end of carpet\\n            while (l<= r && tiles[l][0] < carpetLeft) // Remove every range that is not fully covered. Partially covered will be handled later\\n            {\\n                cur -= tiles[l][1] - tiles[l][0] + 1;\\n                l++;\\n            }\\n            int leftoverlap = 0;\\n            if (l > 0 && tiles[l - 1][1] >= carpetLeft)// For the range on left of l, it could be paritlly covered. Add the partial amount to result\\n                leftoverlap = tiles[l - 1][1] - carpetLeft + 1;\\n            ans = Math.Max(ans, cur + leftoverlap);\\n            r++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        int l =0, r =0, cur =0,ans = int.MinValue;\\n        Array.Sort(tiles, (x,y)=>x[0] - y[0]);\\n        while(r<tiles.Length)\\n        {\\n            cur += tiles[r][1] - tiles[r][0] + 1;//Pull the carpet over the new range of tiles. Add the whole range to result.\\n            int carpetLeft = tiles[r][1] - carpetLen + 1; // Find out the left end of carpet\\n            while (l<= r && tiles[l][0] < carpetLeft) // Remove every range that is not fully covered. Partially covered will be handled later\\n            {\\n                cur -= tiles[l][1] - tiles[l][0] + 1;\\n                l++;\\n            }\\n            int leftoverlap = 0;\\n            if (l > 0 && tiles[l - 1][1] >= carpetLeft)// For the range on left of l, it could be paritlly covered. Add the partial amount to result\\n                leftoverlap = tiles[l - 1][1] - carpetLeft + 1;\\n            ans = Math.Max(ans, cur + leftoverlap);\\n            r++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2363320,
                "title": "c-few-lines-easy-faster-than-94-sliding-window",
                "content": "**Please upvote if you found my post helpful**\\n```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort (tiles.begin (), tiles.end ());\\n        int n = tiles.size ();\\n        int i = 0, j = 0, sum = 0, ans = 0;\\n        while (i < n && j < n) {\\n            int start = i;\\n            int end = carpetLen+tiles[i][0]-1;\\n            while (j < n && tiles[j][1] < end) {\\n                sum += tiles[j][1]-tiles[j][0]+1;\\n                j ++;\\n            }\\n            if (j == n || tiles[j][0] > end) {\\n                ans = max (ans, sum); \\n            }\\n            else {\\n                ans = max (ans, sum+(end-tiles[j][0]+1));\\n            }\\n            sum -= (tiles[i][1]-tiles[i][0]+1);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort (tiles.begin (), tiles.end ());\\n        int n = tiles.size ();\\n        int i = 0, j = 0, sum = 0, ans = 0;\\n        while (i < n && j < n) {\\n            int start = i;\\n            int end = carpetLen+tiles[i][0]-1;\\n            while (j < n && tiles[j][1] < end) {\\n                sum += tiles[j][1]-tiles[j][0]+1;\\n                j ++;\\n            }\\n            if (j == n || tiles[j][0] > end) {\\n                ans = max (ans, sum); \\n            }\\n            else {\\n                ans = max (ans, sum+(end-tiles[j][0]+1));\\n            }\\n            sum -= (tiles[i][1]-tiles[i][0]+1);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347414,
                "title": "python-3-binary-search-prefix-sum",
                "content": "\\tclass Solution:\\n\\t\\tdef maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n\\t\\t\\ttiles.sort()\\n\\t\\t\\tpre=[0]\\n\\t\\t\\tfor l,r in tiles:\\n\\t\\t\\t\\tpre.append(pre[-1]+r-l+1)\\n\\t\\t\\tdef get_lower(v):\\n\\t\\t\\t\\tl,r=0,len(tiles)-1\\n\\t\\t\\t\\twhile l<=r:\\n\\t\\t\\t\\t\\tmid=l+(r-l)//2\\n\\t\\t\\t\\t\\tif tiles[mid][0]<=v:\\n\\t\\t\\t\\t\\t\\tres=mid\\n\\t\\t\\t\\t\\t\\tl=mid+1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tr=mid-1\\n\\t\\t\\t\\treturn res\\n\\t\\t\\tans=0\\n\\t\\t\\tfor i,x in enumerate(tiles):\\n\\t\\t\\t\\tr=get_lower(x[0]+carpetLen-1)\\n\\t\\t\\t\\tans=max(ans,pre[r]-pre[i]+min(tiles[r][1]-tiles[r][0]+1,carpetLen+x[0]-tiles[r][0]))\\n\\t\\t\\treturn ans",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n\\t\\t\\ttiles.sort()\\n\\t\\t\\tpre=[0]\\n\\t\\t\\tfor l,r in tiles:\\n\\t\\t\\t\\tpre.append(pre[-1]+r-l+1)\\n\\t\\t\\tdef get_lower(v):\\n\\t\\t\\t\\tl,r=0,len(tiles)-1\\n\\t\\t\\t\\twhile l<=r:\\n\\t\\t\\t\\t\\tmid=l+(r-l)//2\\n\\t\\t\\t\\t\\tif tiles[mid][0]<=v:\\n\\t\\t\\t\\t\\t\\tres=mid\\n\\t\\t\\t\\t\\t\\tl=mid+1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tr=mid-1\\n\\t\\t\\t\\treturn res\\n\\t\\t\\tans=0\\n\\t\\t\\tfor i,x in enumerate(tiles):\\n\\t\\t\\t\\tr=get_lower(x[0]+carpetLen-1)\\n\\t\\t\\t\\tans=max(ans,pre[r]-pre[i]+min(tiles[r][1]-tiles[r][0]+1,carpetLen+x[0]-tiles[r][0]))\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 2286635,
                "title": "python-two-pointers-inside-prefix-sum",
                "content": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort()\\n        prefix_sum = []\\n        for [l, r] in tiles:\\n            if len(prefix_sum) == 0:\\n                prefix_sum.append(r - l + 1)\\n            else:\\n                prefix_sum.append(prefix_sum[-1] + r - l + 1)\\n        max_coverage = 0\\n        j = 0\\n        for i, (li, ri) in enumerate(tiles):\\n            while j + 1 < len(tiles) and li + carpetLen >= tiles[j+1][0]:\\n                j += 1\\n            lj, rj = tiles[j]\\n            \\n            diff = prefix_sum[j] - (prefix_sum[i-1] if i - 1 >= 0 else 0)\\n            if li + carpetLen - 1 < rj:\\n                diff = diff - (rj - (li + carpetLen - 1))\\n            max_coverage = max(max_coverage, diff)\\n        return max_coverage\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort()\\n        prefix_sum = []\\n        for [l, r] in tiles:\\n            if len(prefix_sum) == 0:\\n                prefix_sum.append(r - l + 1)\\n            else:\\n                prefix_sum.append(prefix_sum[-1] + r - l + 1)\\n        max_coverage = 0\\n        j = 0\\n        for i, (li, ri) in enumerate(tiles):\\n            while j + 1 < len(tiles) and li + carpetLen >= tiles[j+1][0]:\\n                j += 1\\n            lj, rj = tiles[j]\\n            \\n            diff = prefix_sum[j] - (prefix_sum[i-1] if i - 1 >= 0 else 0)\\n            if li + carpetLen - 1 < rj:\\n                diff = diff - (rj - (li + carpetLen - 1))\\n            max_coverage = max(max_coverage, diff)\\n        return max_coverage\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257244,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        int n = tiles.size();\\n        sort(tiles.begin(), tiles.end());\\n\\n        map<int, int> mp;\\n        for (int i = 0; i < n; i++) mp[tiles[i][0]] = i;\\n\\n        vector<int> prefix(n, 0);\\n        prefix[0] = tiles[0][1] - tiles[0][0] + 1;\\n        for (int i = 1; i < n; i++) prefix[i] = prefix[i - 1] + tiles[i][1] - tiles[i][0] + 1;\\n\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            int end = tiles[i][0] + carpetLen - 1, cur = 0;\\n            auto it = mp.upper_bound(end);\\n            int pos = (--it)->second;\\n\\n            if (tiles[pos][1] >= end) cur += (end - tiles[pos][0] + 1);\\n            else cur += (tiles[pos][1] - tiles[pos][0] + 1);\\n            if (pos > 0) cur += prefix[pos - 1];\\n            if (i > 0) cur -= prefix[i - 1];\\n            ans = max(ans, cur);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        int n = tiles.size();\\n        sort(tiles.begin(), tiles.end());\\n\\n        map<int, int> mp;\\n        for (int i = 0; i < n; i++) mp[tiles[i][0]] = i;\\n\\n        vector<int> prefix(n, 0);\\n        prefix[0] = tiles[0][1] - tiles[0][0] + 1;\\n        for (int i = 1; i < n; i++) prefix[i] = prefix[i - 1] + tiles[i][1] - tiles[i][0] + 1;\\n\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            int end = tiles[i][0] + carpetLen - 1, cur = 0;\\n            auto it = mp.upper_bound(end);\\n            int pos = (--it)->second;\\n\\n            if (tiles[pos][1] >= end) cur += (end - tiles[pos][0] + 1);\\n            else cur += (tiles[pos][1] - tiles[pos][0] + 1);\\n            if (pos > 0) cur += prefix[pos - 1];\\n            if (i > 0) cur -= prefix[i - 1];\\n            ans = max(ans, cur);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2224954,
                "title": "c-two-pointer-sliding-window",
                "content": "Sort the white tiles based on their position. Since there is no overlap, after sorting, `tiles[i-1][1] <= tiles[i][0]` for all `0 < i < n`. Let there be array `emptySpaces` where `emptySpaces[i]` indicated number of empty spaces between tiles at index `0` and `i`, both inclusive. Start from `i = j = 0` and expand to the right till the `carpetLen` doesn\\'t cover at least one white tile from all the indices. Since we have cumulative sum of empty spaces, we can get empty spaces between index `i` and `j` by `emptySpaces[j] - emptySpaces[i]`. Keep updating the ans as we expand the window.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(), tiles.end());\\n        int n = tiles.size();\\n        vector<int> emptySpaces(n, 0);\\n        int ans = min(carpetLen, tiles[0][1] - tiles[0][0] + 1);\\n        for(int i = 1; i < n; i++){\\n            emptySpaces[i] = emptySpaces[i-1] + (tiles[i][0] - tiles[i-1][1] - 1);\\n            ans = max(ans, min(carpetLen, tiles[i][1] - tiles[i][0] + 1));\\n        }\\n        int i = 0, j = 0;\\n        while(j < n){\\n            while(j < n && tiles[j][1] - tiles[i][1] < carpetLen){\\n                ans = max(ans, min(carpetLen, tiles[j][1] - tiles[i][0] + 1) - emptySpaces[j] + emptySpaces[i]);\\n                j++;\\n            }\\n            if(i == j){\\n                i++;\\n                j = i;\\n                continue;\\n            }\\n            ans = max(ans, min(carpetLen, tiles[j-1][1] - tiles[i][0] + 1) - emptySpaces[j-1] + emptySpaces[i]);\\n            if(j == n){\\n                continue;\\n            }\\n            while(i < j && tiles[j][1] - tiles[i][1] >= carpetLen){\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(), tiles.end());\\n        int n = tiles.size();\\n        vector<int> emptySpaces(n, 0);\\n        int ans = min(carpetLen, tiles[0][1] - tiles[0][0] + 1);\\n        for(int i = 1; i < n; i++){\\n            emptySpaces[i] = emptySpaces[i-1] + (tiles[i][0] - tiles[i-1][1] - 1);\\n            ans = max(ans, min(carpetLen, tiles[i][1] - tiles[i][0] + 1));\\n        }\\n        int i = 0, j = 0;\\n        while(j < n){\\n            while(j < n && tiles[j][1] - tiles[i][1] < carpetLen){\\n                ans = max(ans, min(carpetLen, tiles[j][1] - tiles[i][0] + 1) - emptySpaces[j] + emptySpaces[i]);\\n                j++;\\n            }\\n            if(i == j){\\n                i++;\\n                j = i;\\n                continue;\\n            }\\n            ans = max(ans, min(carpetLen, tiles[j-1][1] - tiles[i][0] + 1) - emptySpaces[j-1] + emptySpaces[i]);\\n            if(j == n){\\n                continue;\\n            }\\n            while(i < j && tiles[j][1] - tiles[i][1] >= carpetLen){\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212372,
                "title": "javascript-o-nlgn",
                "content": "```\\n/**\\n * @param {number[][]} tiles\\n * @param {number} carpetLen\\n * @return {number}\\n */\\nvar maximumWhiteTiles = function(tiles, carpetLen) {\\n    tiles.sort((A, B) => A[0] - B[0])\\n    const len = tiles.length\\n    const sumSF = new Array(len)\\n    sumSF[-1] = 0\\n    \\n    \\n    for (const [i, tile] of tiles.entries()) {\\n        const size = 1 + tile[1] - tile[0]\\n        sumSF[i] = size + sumSF[i - 1]\\n    }\\n    \\n    \\n    let result = 0\\n    for (const [i, tile] of tiles.entries()) {\\n        const [from, to] = tile\\n        let low = 0, high = -1 + len\\n        const last = tiles[high]\\n        \\n        const lastTo = last[1]\\n        if (1 + lastTo - from <= carpetLen) {\\n            result = Math.max(result, sumSF[high] - sumSF[-1 + i])\\n            break\\n        }\\n        \\n        \\n        // find earliest high where\\n        // tiles[high] is enough to hold the carpet\\n        while (low < high) {\\n            const mid = Math.floor((low + high) / 2)\\n            const midSize = 1 + tiles[mid][1] - from\\n            if (midSize >= carpetLen)\\n                high = mid\\n            else\\n                low = 1 + mid\\n        }\\n        \\n        if (tiles[high][0] > -1 + from + carpetLen) {\\n            const outcome = sumSF[high - 1] - sumSF[-1 + i]\\n            result = Math.max(result, outcome)\\n            continue\\n        }\\n        \\n        let outcome = sumSF[high] - sumSF[-1 + i]\\n        const wasted = tiles[high][1] - (-1 + from + carpetLen)\\n        outcome -= wasted\\n        \\n        result = Math.max(result, outcome)\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} tiles\\n * @param {number} carpetLen\\n * @return {number}\\n */\\nvar maximumWhiteTiles = function(tiles, carpetLen) {\\n    tiles.sort((A, B) => A[0] - B[0])\\n    const len = tiles.length\\n    const sumSF = new Array(len)\\n    sumSF[-1] = 0\\n    \\n    \\n    for (const [i, tile] of tiles.entries()) {\\n        const size = 1 + tile[1] - tile[0]\\n        sumSF[i] = size + sumSF[i - 1]\\n    }\\n    \\n    \\n    let result = 0\\n    for (const [i, tile] of tiles.entries()) {\\n        const [from, to] = tile\\n        let low = 0, high = -1 + len\\n        const last = tiles[high]\\n        \\n        const lastTo = last[1]\\n        if (1 + lastTo - from <= carpetLen) {\\n            result = Math.max(result, sumSF[high] - sumSF[-1 + i])\\n            break\\n        }\\n        \\n        \\n        // find earliest high where\\n        // tiles[high] is enough to hold the carpet\\n        while (low < high) {\\n            const mid = Math.floor((low + high) / 2)\\n            const midSize = 1 + tiles[mid][1] - from\\n            if (midSize >= carpetLen)\\n                high = mid\\n            else\\n                low = 1 + mid\\n        }\\n        \\n        if (tiles[high][0] > -1 + from + carpetLen) {\\n            const outcome = sumSF[high - 1] - sumSF[-1 + i]\\n            result = Math.max(result, outcome)\\n            continue\\n        }\\n        \\n        let outcome = sumSF[high] - sumSF[-1 + i]\\n        const wasted = tiles[high][1] - (-1 + from + carpetLen)\\n        outcome -= wasted\\n        \\n        result = Math.max(result, outcome)\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2206512,
                "title": "java-tc-o-nlogn-sc-o-n",
                "content": "```\\nclass Solution {\\n    \\n    static class TilesComparator implements Comparator<int[]> {\\n        public int compare(int[] a, int[] b) {\\n            return a[0] - b[0];\\n        }\\n    }\\n    \\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        int maxCarpetCoverage = 0;\\n        Arrays.sort(tiles, new TilesComparator());\\n        HashMap<Integer,Integer> prefixsum = new HashMap<>();\\n        TreeMap<Integer, Integer> rangemap = new TreeMap<>();\\n        int psum = 0;\\n        for(int i=0;i<tiles.length;i++) {\\n            rangemap.put(tiles[i][0], tiles[i][1]);\\n            prefixsum.put(tiles[i][0], psum);\\n            psum += (tiles[i][1] - tiles[i][0] + 1);\\n        }\\n        for(int i=0;i<tiles.length;i++) {\\n            int startidx = tiles[i][0];\\n            int possibleendidx = carpetLen + startidx - 1;\\n            int actualendidxkey = rangemap.floorKey(possibleendidx);\\n            int constituenttiles = prefixsum.get(actualendidxkey) - prefixsum.get(startidx);\\n            int actualendidxval = rangemap.get(actualendidxkey);\\n            constituenttiles += (Math.min(actualendidxval, possibleendidx) - actualendidxkey + 1);\\n            maxCarpetCoverage = Math.max(maxCarpetCoverage, constituenttiles);   \\n        }\\n        return maxCarpetCoverage;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static class TilesComparator implements Comparator<int[]> {\\n        public int compare(int[] a, int[] b) {\\n            return a[0] - b[0];\\n        }\\n    }\\n    \\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        int maxCarpetCoverage = 0;\\n        Arrays.sort(tiles, new TilesComparator());\\n        HashMap<Integer,Integer> prefixsum = new HashMap<>();\\n        TreeMap<Integer, Integer> rangemap = new TreeMap<>();\\n        int psum = 0;\\n        for(int i=0;i<tiles.length;i++) {\\n            rangemap.put(tiles[i][0], tiles[i][1]);\\n            prefixsum.put(tiles[i][0], psum);\\n            psum += (tiles[i][1] - tiles[i][0] + 1);\\n        }\\n        for(int i=0;i<tiles.length;i++) {\\n            int startidx = tiles[i][0];\\n            int possibleendidx = carpetLen + startidx - 1;\\n            int actualendidxkey = rangemap.floorKey(possibleendidx);\\n            int constituenttiles = prefixsum.get(actualendidxkey) - prefixsum.get(startidx);\\n            int actualendidxval = rangemap.get(actualendidxkey);\\n            constituenttiles += (Math.min(actualendidxval, possibleendidx) - actualendidxkey + 1);\\n            maxCarpetCoverage = Math.max(maxCarpetCoverage, constituenttiles);   \\n        }\\n        return maxCarpetCoverage;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2150445,
                "title": "binary-search-prefix-sum-java-with-commented-code",
                "content": "Find below the commented code for this problem. \\n\\n```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int target) {\\n        // Sort the array in required format\\n        Arrays.sort(tiles, (a,b)->{\\n            return a[0]==b[0] ? a[1]-b[1]:a[0]-b[0];\\n        });\\n        \\n        // make prefix sum array to store the total covered area till ith index\\n        int[] prefix_sum = new int[tiles.length+1];\\n        for(int i = 1; i<=tiles.length; i++){\\n            prefix_sum[i] = prefix_sum[i-1] + tiles[i-1][1] - tiles[i-1][0] + 1;\\n        }\\n        \\n        int max = 0;\\n        for(int i = 1; i<=tiles.length; i++){\\n            // get the index, from where the ith index can reach\\n            int idx = binary_search(tiles, tiles[i-1][0] + target, i-1, tiles.length-1);\\n            \\n            // calculate the sum till the idx index\\n            int prefix = (prefix_sum[idx] - prefix_sum[i-1]);\\n            \\n            // taking into account the ith index, and calculate if more area can be covered in idx or not.\\n            int remaining = Math.min(target - (tiles[idx][0] - tiles[i-1][0]), prefix_sum[idx+1]-prefix_sum[idx]);\\n            \\n            // this is the total possible units that can be covered from ith index\\n            int tmp = prefix + (Math.max(0, remaining));\\n            \\n            \\n            // System.out.println(i + \" \" + idx + \" \" + tmp + \" (\" + prefix + \", \" + remaining + \")\");\\n            // This will bring us the maximum for all such indexes\\n            max = Math.max(max, tmp);\\n        }\\n        \\n        return max;\\n    }\\n    \\n    \\n    // This is the basic binary search which will give us the index idx, such that the target from ith index strickly lies between idx.\\n    public int binary_search(int[][] tiles, int target, int l, int h){\\n        while(l<h){\\n            int mid = l + (h-l)/2;\\n            if(tiles[mid][1]>=target){\\n                h = mid;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int target) {\\n        // Sort the array in required format\\n        Arrays.sort(tiles, (a,b)->{\\n            return a[0]==b[0] ? a[1]-b[1]:a[0]-b[0];\\n        });\\n        \\n        // make prefix sum array to store the total covered area till ith index\\n        int[] prefix_sum = new int[tiles.length+1];\\n        for(int i = 1; i<=tiles.length; i++){\\n            prefix_sum[i] = prefix_sum[i-1] + tiles[i-1][1] - tiles[i-1][0] + 1;\\n        }\\n        \\n        int max = 0;\\n        for(int i = 1; i<=tiles.length; i++){\\n            // get the index, from where the ith index can reach\\n            int idx = binary_search(tiles, tiles[i-1][0] + target, i-1, tiles.length-1);\\n            \\n            // calculate the sum till the idx index\\n            int prefix = (prefix_sum[idx] - prefix_sum[i-1]);\\n            \\n            // taking into account the ith index, and calculate if more area can be covered in idx or not.\\n            int remaining = Math.min(target - (tiles[idx][0] - tiles[i-1][0]), prefix_sum[idx+1]-prefix_sum[idx]);\\n            \\n            // this is the total possible units that can be covered from ith index\\n            int tmp = prefix + (Math.max(0, remaining));\\n            \\n            \\n            // System.out.println(i + \" \" + idx + \" \" + tmp + \" (\" + prefix + \", \" + remaining + \")\");\\n            // This will bring us the maximum for all such indexes\\n            max = Math.max(max, tmp);\\n        }\\n        \\n        return max;\\n    }\\n    \\n    \\n    // This is the basic binary search which will give us the index idx, such that the target from ith index strickly lies between idx.\\n    public int binary_search(int[][] tiles, int target, int l, int h){\\n        while(l<h){\\n            int mid = l + (h-l)/2;\\n            if(tiles[mid][1]>=target){\\n                h = mid;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140639,
                "title": "sort-binary-search-and-greedy-with-comments",
                "content": "**Key Point**:  Position the carpet at the beginning of each set of tiles(Greedy). \\n\\n**Justification of Greedy Approach**: This is since, in case we don\\'t do this (let\\'s say the candidate starting position is a few places right of the starting position of a set of tiles, we may have lost a few tiles on the right, since it may be empty space instead of tiles - where the carpet has moved to)\\n\\nWe then use Binary Search to figure out which set of tiles, the carpet extends to \\n```\\nclass Solution {\\n    int[][] tiles;\\n    int[] tileSum;\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        this.tiles = tiles;\\n        this.tileSum = new int[tiles.length];\\n        \\n        Arrays.sort(tiles, (a, b) -> (a[0] - b[0]));\\n        for(int i = 0; i < tiles.length; i++) tileSum[i] = ((i > 0) ? tileSum[i - 1] : 0) + (tiles[i][1] - tiles[i][0] + 1);\\n        \\n        int maxLength = 0;\\n        for(int i = 0; i < tiles.length; i++) {\\n            //carpeting starts at leftMost idx of tiles[i]\\n            int endCoordinate = tiles[i][0] + carpetLen - 1;\\n            int tileIdx = idxOfFurthestTileWithLeftMostIdxLessThanOrEqualTo(i, endCoordinate);\\n            int usedCarpetLength;\\n            \\n            if(tileIdx == 0) usedCarpetLength = 0;\\n            else usedCarpetLength = tileSum[tileIdx - 1] - (i == 0 ?  0 : tileSum[i - 1]);\\n            \\n            if(endCoordinate > tiles[tileIdx][1]) usedCarpetLength += (tiles[tileIdx][1] - tiles[tileIdx][0] + 1);\\n            else usedCarpetLength += (endCoordinate - tiles[tileIdx][0] + 1);\\n            \\n            maxLength = Math.max(usedCarpetLength, maxLength);\\n        }\\n        \\n        return maxLength;\\n    }\\n    \\n    public int idxOfFurthestTileWithLeftMostIdxLessThanOrEqualTo(int l, int val) {\\n        int r = tiles.length - 1;\\n        int rightMost = -1;\\n        while(l <= r) {\\n            int mid = (l + r)/2;\\n            if(tiles[mid][0] < val) {\\n                rightMost = Math.max(rightMost, mid);\\n                l = mid + 1;\\n            } else if (tiles[mid][0] > val) {\\n                r = mid - 1;\\n            } else {\\n                rightMost = Math.max(rightMost, mid);\\n                break;\\n            }\\n        }\\n        return rightMost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] tiles;\\n    int[] tileSum;\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        this.tiles = tiles;\\n        this.tileSum = new int[tiles.length];\\n        \\n        Arrays.sort(tiles, (a, b) -> (a[0] - b[0]));\\n        for(int i = 0; i < tiles.length; i++) tileSum[i] = ((i > 0) ? tileSum[i - 1] : 0) + (tiles[i][1] - tiles[i][0] + 1);\\n        \\n        int maxLength = 0;\\n        for(int i = 0; i < tiles.length; i++) {\\n            //carpeting starts at leftMost idx of tiles[i]\\n            int endCoordinate = tiles[i][0] + carpetLen - 1;\\n            int tileIdx = idxOfFurthestTileWithLeftMostIdxLessThanOrEqualTo(i, endCoordinate);\\n            int usedCarpetLength;\\n            \\n            if(tileIdx == 0) usedCarpetLength = 0;\\n            else usedCarpetLength = tileSum[tileIdx - 1] - (i == 0 ?  0 : tileSum[i - 1]);\\n            \\n            if(endCoordinate > tiles[tileIdx][1]) usedCarpetLength += (tiles[tileIdx][1] - tiles[tileIdx][0] + 1);\\n            else usedCarpetLength += (endCoordinate - tiles[tileIdx][0] + 1);\\n            \\n            maxLength = Math.max(usedCarpetLength, maxLength);\\n        }\\n        \\n        return maxLength;\\n    }\\n    \\n    public int idxOfFurthestTileWithLeftMostIdxLessThanOrEqualTo(int l, int val) {\\n        int r = tiles.length - 1;\\n        int rightMost = -1;\\n        while(l <= r) {\\n            int mid = (l + r)/2;\\n            if(tiles[mid][0] < val) {\\n                rightMost = Math.max(rightMost, mid);\\n                l = mid + 1;\\n            } else if (tiles[mid][0] > val) {\\n                r = mid - 1;\\n            } else {\\n                rightMost = Math.max(rightMost, mid);\\n                break;\\n            }\\n        }\\n        return rightMost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136805,
                "title": "help-needed-python-sliding-window",
                "content": "Here\\'s my python 2 pointer solution, passed most cases but not a super long test case. not sure what\\'s wrong\\n```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort()\\n        left = 0 \\n        right = 0\\n        res = 0\\n        base = 0\\n        while right < len(tiles):\\n            if tiles[right][0] - tiles[left][0] <= carpetLen:\\n                cur_far = min(tiles[right][1], tiles[left][0] + carpetLen - 1)\\n                cur_cover = cur_far - tiles[right][0] + 1\\n                res = max(res, base + cur_cover)\\n                base += (tiles[right][1] - tiles[right][0] + 1)\\n                right += 1\\n            else:\\n                base -= (tiles[left][1] - tiles[left][0] + 1)\\n                left += 1\\n        return res       \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        tiles.sort()\\n        left = 0 \\n        right = 0\\n        res = 0\\n        base = 0\\n        while right < len(tiles):\\n            if tiles[right][0] - tiles[left][0] <= carpetLen:\\n                cur_far = min(tiles[right][1], tiles[left][0] + carpetLen - 1)\\n                cur_cover = cur_far - tiles[right][0] + 1\\n                res = max(res, base + cur_cover)\\n                base += (tiles[right][1] - tiles[right][0] + 1)\\n                right += 1\\n            else:\\n                base -= (tiles[left][1] - tiles[left][0] + 1)\\n                left += 1\\n        return res       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120057,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int getSize(tuple<int,int,int> t) {\\n        return get<1>(t) - get<0>(t) + 1;\\n    }\\n    \\n    bool is_carpet(tuple<int,int,int> t) {\\n        return get<2>(t) == 1;\\n    }\\n    \\n    int solve(int carpetLen, vector<tuple<int,int,int>> ranges) {\\n        int current_size = 0;\\n        int current_carpet_size = 0;\\n        \\n        int windowStart = 0;\\n        int sol = 0;\\n        for (int i = 0; i < ranges.size(); ++i) {\\n            current_size += getSize(ranges[i]);\\n            \\n            if (is_carpet(ranges[i])) {\\n                current_carpet_size += getSize(ranges[i]);\\n                sol = max(sol, current_carpet_size - max(0, current_size - carpetLen));\\n            }\\n            \\n            while (windowStart <= i && current_size >= carpetLen) {\\n                current_size -= getSize(ranges[windowStart]);\\n                \\n                if (is_carpet(ranges[windowStart]))\\n                    current_carpet_size -= getSize(ranges[windowStart]);\\n                \\n                windowStart++;\\n                \\n                if (is_carpet(ranges[i])) \\n                    sol = max(sol, current_carpet_size - max(0, current_size - carpetLen));\\n            }\\n        }\\n\\n        return sol;\\n    }\\n    \\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        vector<tuple<int,int,int>> ranges;\\n        \\n        sort(tiles.begin(), tiles.end());\\n        for (int i = 0; i < tiles.size(); ++i) {\\n            // Add gaps.\\n            if (i > 0 && tiles[i-1][1] + 1 <= tiles[i][0] - 1)\\n                ranges.push_back({tiles[i-1][1] + 1, tiles[i][0] - 1, 0});\\n            \\n            ranges.push_back({tiles[i][0], tiles[i][1], 1});\\n        }\\n        \\n        return solve(carpetLen, ranges);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getSize(tuple<int,int,int> t) {\\n        return get<1>(t) - get<0>(t) + 1;\\n    }\\n    \\n    bool is_carpet(tuple<int,int,int> t) {\\n        return get<2>(t) == 1;\\n    }\\n    \\n    int solve(int carpetLen, vector<tuple<int,int,int>> ranges) {\\n        int current_size = 0;\\n        int current_carpet_size = 0;\\n        \\n        int windowStart = 0;\\n        int sol = 0;\\n        for (int i = 0; i < ranges.size(); ++i) {\\n            current_size += getSize(ranges[i]);\\n            \\n            if (is_carpet(ranges[i])) {\\n                current_carpet_size += getSize(ranges[i]);\\n                sol = max(sol, current_carpet_size - max(0, current_size - carpetLen));\\n            }\\n            \\n            while (windowStart <= i && current_size >= carpetLen) {\\n                current_size -= getSize(ranges[windowStart]);\\n                \\n                if (is_carpet(ranges[windowStart]))\\n                    current_carpet_size -= getSize(ranges[windowStart]);\\n                \\n                windowStart++;\\n                \\n                if (is_carpet(ranges[i])) \\n                    sol = max(sol, current_carpet_size - max(0, current_size - carpetLen));\\n            }\\n        }\\n\\n        return sol;\\n    }\\n    \\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        vector<tuple<int,int,int>> ranges;\\n        \\n        sort(tiles.begin(), tiles.end());\\n        for (int i = 0; i < tiles.size(); ++i) {\\n            // Add gaps.\\n            if (i > 0 && tiles[i-1][1] + 1 <= tiles[i][0] - 1)\\n                ranges.push_back({tiles[i-1][1] + 1, tiles[i][0] - 1, 0});\\n            \\n            ranges.push_back({tiles[i][0], tiles[i][1], 1});\\n        }\\n        \\n        return solve(carpetLen, ranges);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112916,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLength) {\\n\\n        Arrays.sort(tiles, (x, y) -> x[0] - y[0]);\\n        int currentCover = (tiles[0][1] - tiles[0][0] + 1 >= carpetLength) ? carpetLength : (tiles[0][1] - tiles[0][0] + 1);\\n        int maxCover = currentCover;\\n        int head = 1;\\n        int tail = 0;\\n\\n        while (tail < tiles.length && head < tiles.length && maxCover < carpetLength) {\\n\\n            if (tiles[head][1] - tiles[tail][0] + 1 <= carpetLength) {\\n                currentCover += tiles[head][1] - tiles[head][0] + 1;\\n                maxCover = Math.max(maxCover, currentCover);\\n                ++head;\\n            } else {\\n                int possiblePartialCoverOverCurrentHead = carpetLength - (tiles[head][0] - tiles[tail][0]);\\n                maxCover = Math.max(maxCover, currentCover + possiblePartialCoverOverCurrentHead);\\n                currentCover = currentCover - (tiles[tail][1] - tiles[tail][0] + 1);\\n                ++tail;\\n            }\\n        }\\n        return maxCover;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {number[][]} tiles\\n * @param {number} carpetLength\\n * @return {number}\\n */\\nvar maximumWhiteTiles = function (tiles, carpetLength) {\\n\\n    tiles.sort((x, y) => x[0] - y[0]);\\n    let currentCover = (tiles[0][1] - tiles[0][0] + 1 >= carpetLength) ? carpetLength : (tiles[0][1] - tiles[0][0] + 1);\\n    let maxCover = currentCover;\\n    let head = 1;\\n    let tail = 0;\\n\\n    while (tail < tiles.length && head < tiles.length && maxCover < carpetLength) {\\n\\n        if (tiles[head][1] - tiles[tail][0] + 1 <= carpetLength) {\\n            currentCover += tiles[head][1] - tiles[head][0] + 1;\\n            maxCover = Math.max(maxCover, currentCover);\\n            ++head;\\n        } else {\\n            let possiblePartialCoverOverCurrentHead = carpetLength - (tiles[head][0] - tiles[tail][0]);\\n            maxCover = Math.max(maxCover, currentCover + possiblePartialCoverOverCurrentHead);\\n            currentCover = currentCover - (tiles[tail][1] - tiles[tail][0] + 1);\\n            ++tail;\\n        }\\n    }\\n    return maxCover;\\n};\\n```\\n**C++**\\n```\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\n    \\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLength) {\\n\\n        sort(tiles.begin(), tiles.end(), [](const vector<int>& v1, const vector<int>& v2){return v1[0] < v2[0];});\\n        int currentCover = (tiles[0][1] - tiles[0][0] + 1 >= carpetLength) ? carpetLength : (tiles[0][1] - tiles[0][0] + 1);\\n        int maxCover = currentCover;\\n        int head = 1;\\n        int tail = 0;\\n\\n        while (tail < tiles.size() && head < tiles.size() && maxCover < carpetLength) {\\n\\n            if (tiles[head][1] - tiles[tail][0] + 1 <= carpetLength) {\\n                currentCover += tiles[head][1] - tiles[head][0] + 1;\\n                maxCover = max(maxCover, currentCover);\\n                ++head;\\n            } else {\\n                int possiblePartialCoverOverCurrentHead = carpetLength - (tiles[head][0] - tiles[tail][0]);\\n                maxCover = max(maxCover, currentCover + possiblePartialCoverOverCurrentHead);\\n                currentCover = currentCover - (tiles[tail][1] - tiles[tail][0] + 1);\\n                ++tail;\\n            }\\n        }\\n        return maxCover;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLength) {\\n\\n        Arrays.sort(tiles, (x, y) -> x[0] - y[0]);\\n        int currentCover = (tiles[0][1] - tiles[0][0] + 1 >= carpetLength) ? carpetLength : (tiles[0][1] - tiles[0][0] + 1);\\n        int maxCover = currentCover;\\n        int head = 1;\\n        int tail = 0;\\n\\n        while (tail < tiles.length && head < tiles.length && maxCover < carpetLength) {\\n\\n            if (tiles[head][1] - tiles[tail][0] + 1 <= carpetLength) {\\n                currentCover += tiles[head][1] - tiles[head][0] + 1;\\n                maxCover = Math.max(maxCover, currentCover);\\n                ++head;\\n            } else {\\n                int possiblePartialCoverOverCurrentHead = carpetLength - (tiles[head][0] - tiles[tail][0]);\\n                maxCover = Math.max(maxCover, currentCover + possiblePartialCoverOverCurrentHead);\\n                currentCover = currentCover - (tiles[tail][1] - tiles[tail][0] + 1);\\n                ++tail;\\n            }\\n        }\\n        return maxCover;\\n    }\\n}\\n```\n```\\n/**\\n * @param {number[][]} tiles\\n * @param {number} carpetLength\\n * @return {number}\\n */\\nvar maximumWhiteTiles = function (tiles, carpetLength) {\\n\\n    tiles.sort((x, y) => x[0] - y[0]);\\n    let currentCover = (tiles[0][1] - tiles[0][0] + 1 >= carpetLength) ? carpetLength : (tiles[0][1] - tiles[0][0] + 1);\\n    let maxCover = currentCover;\\n    let head = 1;\\n    let tail = 0;\\n\\n    while (tail < tiles.length && head < tiles.length && maxCover < carpetLength) {\\n\\n        if (tiles[head][1] - tiles[tail][0] + 1 <= carpetLength) {\\n            currentCover += tiles[head][1] - tiles[head][0] + 1;\\n            maxCover = Math.max(maxCover, currentCover);\\n            ++head;\\n        } else {\\n            let possiblePartialCoverOverCurrentHead = carpetLength - (tiles[head][0] - tiles[tail][0]);\\n            maxCover = Math.max(maxCover, currentCover + possiblePartialCoverOverCurrentHead);\\n            currentCover = currentCover - (tiles[tail][1] - tiles[tail][0] + 1);\\n            ++tail;\\n        }\\n    }\\n    return maxCover;\\n};\\n```\n```\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\n    \\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLength) {\\n\\n        sort(tiles.begin(), tiles.end(), [](const vector<int>& v1, const vector<int>& v2){return v1[0] < v2[0];});\\n        int currentCover = (tiles[0][1] - tiles[0][0] + 1 >= carpetLength) ? carpetLength : (tiles[0][1] - tiles[0][0] + 1);\\n        int maxCover = currentCover;\\n        int head = 1;\\n        int tail = 0;\\n\\n        while (tail < tiles.size() && head < tiles.size() && maxCover < carpetLength) {\\n\\n            if (tiles[head][1] - tiles[tail][0] + 1 <= carpetLength) {\\n                currentCover += tiles[head][1] - tiles[head][0] + 1;\\n                maxCover = max(maxCover, currentCover);\\n                ++head;\\n            } else {\\n                int possiblePartialCoverOverCurrentHead = carpetLength - (tiles[head][0] - tiles[tail][0]);\\n                maxCover = max(maxCover, currentCover + possiblePartialCoverOverCurrentHead);\\n                currentCover = currentCover - (tiles[tail][1] - tiles[tail][0] + 1);\\n                ++tail;\\n            }\\n        }\\n        return maxCover;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2109099,
                "title": "c-binary-search-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetlen) {\\n        sort(tiles.begin(),tiles.end());\\n        vector<int> prefix(tiles.size(),0);//stores how many tiles are actually there till the ith segment\\n        prefix[0]=tiles[0][1]-tiles[0][0]+1;\\n        for(int i=1;i<tiles.size();i++){\\n            prefix[i]=prefix[i-1]+(tiles[i][1]-tiles[i][0]+1);\\n        }\\n     \\n        vector<int> endd(tiles.size());\\n        for(int i=0;i<tiles.size();i++){\\n            endd[i]=tiles[i][1];//end index of the tile of the ith segment\\n        }\\n        int res=0;\\n        for(int i=0;i<tiles.size();i++){\\n           int l=tiles[i][0];\\n           int r=tiles[i][0]+carpetlen-1;\\n           int idx=upper_bound(endd.begin(),endd.end(),r)-endd.begin();\\n           //idx which is strictly greater than r\\n            int tt;\\n            if(idx>=tiles.size()){\\n                tt=prefix[idx-1];\\n            }\\n            else{\\n                tt=prefix[idx];\\n                if(r>=tiles[idx][0] and r<=tiles[idx][1])\\n                {\\n                    int diff=tiles[idx][1]-r;\\n                    tt-=diff;\\n                }\\n                else if(r<tiles[idx][0]){\\n                   if(idx>=1){\\n                       tt=prefix[idx-1];\\n                   }\\n                   else{\\n                        tt=r;\\n                    }\\n                }\\n            }\\n            //cout<<tt<<endl;\\n            if(i>=1){\\n                tt-=prefix[i-1];\\n            }\\n            res=max(res,tt);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetlen) {\\n        sort(tiles.begin(),tiles.end());\\n        vector<int> prefix(tiles.size(),0);//stores how many tiles are actually there till the ith segment\\n        prefix[0]=tiles[0][1]-tiles[0][0]+1;\\n        for(int i=1;i<tiles.size();i++){\\n            prefix[i]=prefix[i-1]+(tiles[i][1]-tiles[i][0]+1);\\n        }\\n     \\n        vector<int> endd(tiles.size());\\n        for(int i=0;i<tiles.size();i++){\\n            endd[i]=tiles[i][1];//end index of the tile of the ith segment\\n        }\\n        int res=0;\\n        for(int i=0;i<tiles.size();i++){\\n           int l=tiles[i][0];\\n           int r=tiles[i][0]+carpetlen-1;\\n           int idx=upper_bound(endd.begin(),endd.end(),r)-endd.begin();\\n           //idx which is strictly greater than r\\n            int tt;\\n            if(idx>=tiles.size()){\\n                tt=prefix[idx-1];\\n            }\\n            else{\\n                tt=prefix[idx];\\n                if(r>=tiles[idx][0] and r<=tiles[idx][1])\\n                {\\n                    int diff=tiles[idx][1]-r;\\n                    tt-=diff;\\n                }\\n                else if(r<tiles[idx][0]){\\n                   if(idx>=1){\\n                       tt=prefix[idx-1];\\n                   }\\n                   else{\\n                        tt=r;\\n                    }\\n                }\\n            }\\n            //cout<<tt<<endl;\\n            if(i>=1){\\n                tt-=prefix[i-1];\\n            }\\n            res=max(res,tt);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2095243,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a,vector<int> &b){\\n        return a[1]<b[1];\\n    }\\n    int bs(int end,vector<vector<int>> &tiles,int strt){\\n        if(end<=tiles[strt][1])\\n            return strt;\\n         int l=strt;\\n        int r=tiles.size()-1;\\n        int ans=-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(tiles[mid][0]>end)\\n                r=mid-1;\\n            else if(tiles[mid][1]<end){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n                return mid;\\n            }\\n        return ans;\\n    }\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(),tiles.end(),cmp);\\n        int n=tiles.size();\\n        vector<int> dp(n);\\n        int maxi=0;\\n        dp[0]=tiles[0][1]-tiles[0][0]+1;\\n        for(int i=1;i<n;i++)\\n            dp[i]=dp[i-1]+tiles[i][1]-tiles[i][0]+1;\\n        for(int i=0;i<n;i++){\\n            int end=tiles[i][0]+carpetLen-1;\\n            int idx=bs(end,tiles,i);\\n            int res=0;\\n            if(idx && i)\\n               res=dp[idx-1]-dp[i-1];\\n            else if(idx)\\n                res=dp[idx-1];\\n            res+=min(end-tiles[idx][0]+1,tiles[idx][1]-tiles[idx][0]+1);\\n            maxi=max(maxi,res);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a,vector<int> &b){\\n        return a[1]<b[1];\\n    }\\n    int bs(int end,vector<vector<int>> &tiles,int strt){\\n        if(end<=tiles[strt][1])\\n            return strt;\\n         int l=strt;\\n        int r=tiles.size()-1;\\n        int ans=-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(tiles[mid][0]>end)\\n                r=mid-1;\\n            else if(tiles[mid][1]<end){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n                return mid;\\n            }\\n        return ans;\\n    }\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(),tiles.end(),cmp);\\n        int n=tiles.size();\\n        vector<int> dp(n);\\n        int maxi=0;\\n        dp[0]=tiles[0][1]-tiles[0][0]+1;\\n        for(int i=1;i<n;i++)\\n            dp[i]=dp[i-1]+tiles[i][1]-tiles[i][0]+1;\\n        for(int i=0;i<n;i++){\\n            int end=tiles[i][0]+carpetLen-1;\\n            int idx=bs(end,tiles,i);\\n            int res=0;\\n            if(idx && i)\\n               res=dp[idx-1]-dp[i-1];\\n            else if(idx)\\n                res=dp[idx-1];\\n            res+=min(end-tiles[idx][0]+1,tiles[idx][1]-tiles[idx][0]+1);\\n            maxi=max(maxi,res);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072909,
                "title": "python-prefix-sum-sorting-greedy-start-from-l-of-all-intervals",
                "content": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        n=len(tiles)\\n        tiles.sort()\\n        start,end=[i for i,_ in tiles], [i for _,i in tiles]\\n        pre_sum={-1:0}\\n        ans=0\\n        for i,(s,e) in enumerate(tiles):\\n            pre_sum[i]=pre_sum[i-1]+(e-s+1)\\n        for i,(s,e) in enumerate(tiles):\\n            last=s+carpetLen-1\\n            idx=bisect.bisect_right(start,last) \\n            if end[idx-1]<=last:\\n                ans=max(ans,pre_sum[idx-1]-pre_sum[i-1])\\n            else:\\n                ans=max(ans,pre_sum[idx-2]-pre_sum[i-1]+last-start[idx-1]+1)\\n        ans=min(ans,carpetLen)\\n        return ans\\n                \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        n=len(tiles)\\n        tiles.sort()\\n        start,end=[i for i,_ in tiles], [i for _,i in tiles]\\n        pre_sum={-1:0}\\n        ans=0\\n        for i,(s,e) in enumerate(tiles):\\n            pre_sum[i]=pre_sum[i-1]+(e-s+1)\\n        for i,(s,e) in enumerate(tiles):\\n            last=s+carpetLen-1\\n            idx=bisect.bisect_right(start,last) \\n            if end[idx-1]<=last:\\n                ans=max(ans,pre_sum[idx-1]-pre_sum[i-1])\\n            else:\\n                ans=max(ans,pre_sum[idx-2]-pre_sum[i-1]+last-start[idx-1]+1)\\n        ans=min(ans,carpetLen)\\n        return ans\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072821,
                "title": "python-clean-oop-solution-prefix-sum-binary-search",
                "content": "```\\nfrom bisect import bisect_right\\nfrom dataclasses import dataclass, field\\nfrom itertools import accumulate\\nfrom operator import add\\nfrom typing import List\\n\\n\\n@dataclass(order=True, frozen=True)\\nclass Tile:\\n    start: int\\n    end: int = field(compare=False)\\n\\n    @property\\n    def width(self) -> int:\\n        \"\"\"\\n        :return: tile width \\n        \"\"\"\\n        return self.end - self.start + 1\\n\\n    def carpet_end_idx(self, carpet: int) -> int:\\n        \"\"\"\\n        considering carpet starts from beginning of tile, returning index where carpet ends\\n        :param carpet:\\n        :return:\\n        \"\"\"\\n        return self.start + carpet - 1\\n\\n\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpet: int) -> int:\\n        tiles = sorted(Tile(s, e) for s, e in tiles)\\n\\n        starts = [tile.start for tile in tiles]\\n        prefix_sum = self.create_prefix_sum(tiles)\\n\\n        output = 0\\n\\n        for tile, cum_width_upto_last_tile in zip(tiles, prefix_sum):\\n            if tile.width >= carpet:\\n                return carpet\\n\\n            carpet_end = tile.carpet_end_idx(carpet)\\n\\n            # now to find out how much is covered by carpet if it starts from tile.start, we\\n            # need to find last tile which gets the carpet (so that tile will either be partially\\n            # covered or full covered)\\n\\n            idx = bisect_right(starts, carpet_end)  # for all s in starts[idx:], carpet_end < s\\n\\n            # farthest tile which either contains carpet end or carpet crosses it before reaching\\n            # to next time\\n            last_tile_having_carpet = tiles[idx - 1]\\n\\n            # uncovered tile part will be zero, if tile crosses it\\n            uncovered_tile_space = max(0, last_tile_having_carpet.end - carpet_end)\\n            output = max(output, (prefix_sum[idx] - uncovered_tile_space) - cum_width_upto_last_tile)\\n\\n        return output\\n\\n    @staticmethod\\n    def create_prefix_sum(tiles: List[Tile]) -> List[int]:\\n        \"\"\"\\n        :param tiles:\\n        :return: prefix sum array with tile widths\\n                 => [0, w[0], w[0] + w[1], ..., w[0] + w[1] + ... w[n-1]], where w[i] = tiles[i].width\\n        \"\"\"\\n        widths = (tile.width for tile in tiles)\\n        prefix = accumulate(widths, add, initial=0)\\n        return list(prefix)\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nfrom bisect import bisect_right\\nfrom dataclasses import dataclass, field\\nfrom itertools import accumulate\\nfrom operator import add\\nfrom typing import List\\n\\n\\n@dataclass(order=True, frozen=True)\\nclass Tile:\\n    start: int\\n    end: int = field(compare=False)\\n\\n    @property\\n    def width(self) -> int:\\n        \"\"\"\\n        :return: tile width \\n        \"\"\"\\n        return self.end - self.start + 1\\n\\n    def carpet_end_idx(self, carpet: int) -> int:\\n        \"\"\"\\n        considering carpet starts from beginning of tile, returning index where carpet ends\\n        :param carpet:\\n        :return:\\n        \"\"\"\\n        return self.start + carpet - 1\\n\\n\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpet: int) -> int:\\n        tiles = sorted(Tile(s, e) for s, e in tiles)\\n\\n        starts = [tile.start for tile in tiles]\\n        prefix_sum = self.create_prefix_sum(tiles)\\n\\n        output = 0\\n\\n        for tile, cum_width_upto_last_tile in zip(tiles, prefix_sum):\\n            if tile.width >= carpet:\\n                return carpet\\n\\n            carpet_end = tile.carpet_end_idx(carpet)\\n\\n            # now to find out how much is covered by carpet if it starts from tile.start, we\\n            # need to find last tile which gets the carpet (so that tile will either be partially\\n            # covered or full covered)\\n\\n            idx = bisect_right(starts, carpet_end)  # for all s in starts[idx:], carpet_end < s\\n\\n            # farthest tile which either contains carpet end or carpet crosses it before reaching\\n            # to next time\\n            last_tile_having_carpet = tiles[idx - 1]\\n\\n            # uncovered tile part will be zero, if tile crosses it\\n            uncovered_tile_space = max(0, last_tile_having_carpet.end - carpet_end)\\n            output = max(output, (prefix_sum[idx] - uncovered_tile_space) - cum_width_upto_last_tile)\\n\\n        return output\\n\\n    @staticmethod\\n    def create_prefix_sum(tiles: List[Tile]) -> List[int]:\\n        \"\"\"\\n        :param tiles:\\n        :return: prefix sum array with tile widths\\n                 => [0, w[0], w[0] + w[1], ..., w[0] + w[1] + ... w[n-1]], where w[i] = tiles[i].width\\n        \"\"\"\\n        widths = (tile.width for tile in tiles)\\n        prefix = accumulate(widths, add, initial=0)\\n        return list(prefix)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072627,
                "title": "c-solution-using-binary-search-prefix-sum-best-question-of-the-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(NlogN)\\n    // Space Complexity:- O(N)\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        int n=tiles.size();\\n        sort(tiles.begin(),tiles.end());//sorting the array\\n        vector<int>pref(n);\\n        //then storing prefix sum\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            pref[i]=tiles[i][1]-tiles[i][0]+1;\\n            if(i>0){\\n                pref[i]+=pref[i-1];\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int leftend=tiles[i][0],rightend=tiles[i][0]+carpetLen-1;\\n            //if we start spreading the carpet from first tiles so we start from tile[i][0] to the tiles[i][0]+carpetlen-1\\n            //example if start from [1,5 ]\\n            //leftend=1,rightend=1+10-1=10\\n            //now find how many tiles we fully covered between leftend to right end \\n            //for finding this we use binary search\\n            int l=i,r=n-1,left=i,right=i-1;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                if(tiles[mid][1]<=rightend){\\n                    //we check if that tiles is coming under our rightend if it come under rightend that means we covered that tile fully\\n                    right=mid;\\n                    l=mid+1;//check for next tile in thr right\\n                }\\n                else{\\n                    r=mid-1;//check in left tile\\n                }\\n            }\\n            int curr=0;\\n            if(right!=i-1){\\n                //now we check that we find any tile or not if didn\\'t able to find any tile our right remains i-1 or if we find any tile we stored that index in right\\n                curr+=pref[right];//store the sum of tiles till that index\\n                if(left>0){\\n                    curr-=pref[left-1];//because we have to decrease the sum of tile befor our new left end because we start from new leftend\\n                    //example if start from 1 we have to decrease the pref sum befor thr 1 index\\n                }\\n            }\\n            if(right+1<n){//if we cover full area of some tile and half area of next one tile \\n                curr+=max(0,rightend-tiles[right+1][0]+1);//\\n            }\\n            ans=max(ans,curr);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(NlogN)\\n    // Space Complexity:- O(N)\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        int n=tiles.size();\\n        sort(tiles.begin(),tiles.end());//sorting the array\\n        vector<int>pref(n);\\n        //then storing prefix sum\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            pref[i]=tiles[i][1]-tiles[i][0]+1;\\n            if(i>0){\\n                pref[i]+=pref[i-1];\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int leftend=tiles[i][0],rightend=tiles[i][0]+carpetLen-1;\\n            //if we start spreading the carpet from first tiles so we start from tile[i][0] to the tiles[i][0]+carpetlen-1\\n            //example if start from [1,5 ]\\n            //leftend=1,rightend=1+10-1=10\\n            //now find how many tiles we fully covered between leftend to right end \\n            //for finding this we use binary search\\n            int l=i,r=n-1,left=i,right=i-1;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                if(tiles[mid][1]<=rightend){\\n                    //we check if that tiles is coming under our rightend if it come under rightend that means we covered that tile fully\\n                    right=mid;\\n                    l=mid+1;//check for next tile in thr right\\n                }\\n                else{\\n                    r=mid-1;//check in left tile\\n                }\\n            }\\n            int curr=0;\\n            if(right!=i-1){\\n                //now we check that we find any tile or not if didn\\'t able to find any tile our right remains i-1 or if we find any tile we stored that index in right\\n                curr+=pref[right];//store the sum of tiles till that index\\n                if(left>0){\\n                    curr-=pref[left-1];//because we have to decrease the sum of tile befor our new left end because we start from new leftend\\n                    //example if start from 1 we have to decrease the pref sum befor thr 1 index\\n                }\\n            }\\n            if(right+1<n){//if we cover full area of some tile and half area of next one tile \\n                curr+=max(0,rightend-tiles[right+1][0]+1);//\\n            }\\n            ans=max(ans,curr);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065451,
                "title": "rust-sliding-windows-o-n",
                "content": "```\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn maximum_white_tiles(tiles: Vec<Vec<i32>>, carpet_len: i32) -> i32 {\\n        let mut tiles = tiles;\\n        tiles.sort();\\n        let n = tiles.len();\\n        let mut j = 0;\\n        let mut curr = 0;\\n        let mut ans = 0;\\n        \\n        for i in 0..n {\\n            let t0 = &tiles[i];\\n            let start = t0[0];\\n            while j < n && tiles[j][1] < start + carpet_len {\\n                curr += tiles[j][1] - tiles[j][0] + 1;\\n                j += 1;\\n            }\\n            let mut ext = 0;\\n            if j < n && tiles[j][0] <= start + carpet_len {\\n                ext = start + carpet_len - tiles[j][0];\\n            }\\n            \\n            ans = max(curr + ext, ans);\\n            curr -= tiles[i][1] - tiles[i][0] + 1;\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn maximum_white_tiles(tiles: Vec<Vec<i32>>, carpet_len: i32) -> i32 {\\n        let mut tiles = tiles;\\n        tiles.sort();\\n        let n = tiles.len();\\n        let mut j = 0;\\n        let mut curr = 0;\\n        let mut ans = 0;\\n        \\n        for i in 0..n {\\n            let t0 = &tiles[i];\\n            let start = t0[0];\\n            while j < n && tiles[j][1] < start + carpet_len {\\n                curr += tiles[j][1] - tiles[j][0] + 1;\\n                j += 1;\\n            }\\n            let mut ext = 0;\\n            if j < n && tiles[j][0] <= start + carpet_len {\\n                ext = start + carpet_len - tiles[j][0];\\n            }\\n            \\n            ans = max(curr + ext, ans);\\n            curr -= tiles[i][1] - tiles[i][0] + 1;\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2060945,
                "title": "binary-search-nlogn-approach",
                "content": "class Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        Arrays.sort(tiles, (a, b) -> a[0] - b[0]);\\n        int n = tiles.length;\\n        int ans =0;\\n        int[] pst = new int[n]; //presum for tiles\\n        pst[0] = tiles[0][1] - tiles[0][0] + 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            pst[i] = pst[i-1] + (tiles[i][1] - tiles[i][0] + 1);\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int l=i;\\n            int r=n-1;\\n            int rightbound = tiles[i][0] + carpetLen - 1;\\n            int fcs = i-1; // fully covered section of tile\\n            \\n            while(l<=r)\\n            {\\n                int mid = (l+r)/2;\\n                if(tiles[mid][1] <= rightbound)\\n                {\\n                    fcs = mid;\\n                    l=mid+1;\\n                }\\n                else\\n                    r=mid-1;\\n            }\\n            int cot = 0; //count of tiles when starting from index i\\n            \\n            if(fcs != i-1)\\n            {\\n                cot += pst[fcs];\\n                if(i>0)\\n                    cot -= pst[i-1];\\n            }\\n            // check for partial covered tiles\\n            if(fcs+1<n)\\n            {\\n                cot += Math.max(0, rightbound - tiles[fcs+1][0]+1);\\n            }\\n            \\n            ans = Math.max(ans,cot);\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        Arrays.sort(tiles, (a, b) -> a[0] - b[0]);\\n        int n = tiles.length;\\n        int ans =0;\\n        int[] pst = new int[n]; //presum for tiles\\n        pst[0] = tiles[0][1] - tiles[0][0] + 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            pst[i] = pst[i-1] + (tiles[i][1] - tiles[i][0] + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2059544,
                "title": "binary-search-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(),tiles.end());\\n        int n = tiles.size();\\n        vector<int> pre(n,0);\\n        vector<int> ending;\\n        for(int i = 0 ; i < n ; i++){\\n            ending.push_back(tiles[i][1]);\\n            pre[i] = (i>0?pre[i-1]:0)+(tiles[i][1]-tiles[i][0]+1);\\n        }\\n        long long ans = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            long long curr = 0;\\n            int limit = tiles[i][0]+carpetLen-1;\\n            int idx = lower_bound(ending.begin(),ending.end(), limit) - ending.begin();\\n            if(idx>0){\\n                curr += pre[idx-1]-(i==0?0:pre[i-1]);\\n            }\\n            if(idx<n){\\n                curr += max(limit-tiles[idx][0]+1,0);\\n            }\\n            ans = max(ans,curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(),tiles.end());\\n        int n = tiles.size();\\n        vector<int> pre(n,0);\\n        vector<int> ending;\\n        for(int i = 0 ; i < n ; i++){\\n            ending.push_back(tiles[i][1]);\\n            pre[i] = (i>0?pre[i-1]:0)+(tiles[i][1]-tiles[i][0]+1);\\n        }\\n        long long ans = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            long long curr = 0;\\n            int limit = tiles[i][0]+carpetLen-1;\\n            int idx = lower_bound(ending.begin(),ending.end(), limit) - ending.begin();\\n            if(idx>0){\\n                curr += pre[idx-1]-(i==0?0:pre[i-1]);\\n            }\\n            if(idx<n){\\n                curr += max(limit-tiles[idx][0]+1,0);\\n            }\\n            ans = max(ans,curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058668,
                "title": "c-binary-search-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(), tiles.end());\\n        int n = tiles.size(), res = 0, cnt[n];\\n        cnt[0] = 0;\\n        if (tiles[0][1] - tiles[0][0] + 1 >= carpetLen) return carpetLen;\\n        for (int i = 1; i < n; ++i) {\\n            if (tiles[i][1] - tiles[i][0] + 1 >= carpetLen) return carpetLen;\\n            cnt[i] = cnt[i - 1] + tiles[i][0] - tiles[i - 1][1] - 1;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            auto it = lower_bound(tiles.begin() + i, tiles.end(), vector<int>{tiles[i][0] + carpetLen - 1, -1});\\n            if (it != tiles.begin()) {\\n                if (it != tiles.end()) {\\n                    if ((*it)[0] > tiles[i][0] + carpetLen - 1) --it;\\n                    res = max(res, min((*it)[1] - tiles[i][0] + 1, carpetLen) - (cnt[distance(tiles.begin(), it)] - cnt[i]));\\n                }\\n                else {\\n                    res = max(res, min(tiles[n - 1][1] - tiles[i][0] + 1, carpetLen) - (cnt[n - 1] - cnt[i]));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(), tiles.end());\\n        int n = tiles.size(), res = 0, cnt[n];\\n        cnt[0] = 0;\\n        if (tiles[0][1] - tiles[0][0] + 1 >= carpetLen) return carpetLen;\\n        for (int i = 1; i < n; ++i) {\\n            if (tiles[i][1] - tiles[i][0] + 1 >= carpetLen) return carpetLen;\\n            cnt[i] = cnt[i - 1] + tiles[i][0] - tiles[i - 1][1] - 1;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            auto it = lower_bound(tiles.begin() + i, tiles.end(), vector<int>{tiles[i][0] + carpetLen - 1, -1});\\n            if (it != tiles.begin()) {\\n                if (it != tiles.end()) {\\n                    if ((*it)[0] > tiles[i][0] + carpetLen - 1) --it;\\n                    res = max(res, min((*it)[1] - tiles[i][0] + 1, carpetLen) - (cnt[distance(tiles.begin(), it)] - cnt[i]));\\n                }\\n                else {\\n                    res = max(res, min(tiles[n - 1][1] - tiles[i][0] + 1, carpetLen) - (cnt[n - 1] - cnt[i]));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058413,
                "title": "javascript-answer",
                "content": "```\\nvar maximumWhiteTiles = function(tiles, carpetLen) {\\n\\ttiles = tiles.sort(function (a, b) { return a[0] - b[0] })\\n\\n\\tlet max = 0\\n\\tlet cnt = 0\\n\\tlet l = 0\\n\\n\\tfor (let i = 0; i < tiles.length; i++) {\\n\\t\\tconst tile = tiles[i]\\n\\n\\t\\tcnt = cnt + tile[1] - tile[0] + 1\\n\\n\\t\\tlet len = 0\\n\\t\\twhile (\\n\\t\\t\\tl < tiles.length &&\\n\\t\\t\\t(len = tiles[i][1] - tiles[l][0] + 1) > carpetLen\\n\\t\\t) {\\n\\t\\t\\t// keep removing tiles from left side\\n\\t\\t\\tmax = Math.max(max, cnt - len + carpetLen);\\n\\n\\t\\t\\tcnt -= tiles[l][1] - tiles[l][0] + 1\\n\\n\\t\\t\\tl++;\\n\\t\\t}\\n\\n\\t\\tmax = Math.max(max, cnt);\\n\\n\\t\\tif (max == carpetLen) return carpetLen;\\n\\t}\\n\\n\\treturn max\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar maximumWhiteTiles = function(tiles, carpetLen) {\\n\\ttiles = tiles.sort(function (a, b) { return a[0] - b[0] })\\n\\n\\tlet max = 0\\n\\tlet cnt = 0\\n\\tlet l = 0\\n\\n\\tfor (let i = 0; i < tiles.length; i++) {\\n\\t\\tconst tile = tiles[i]\\n\\n\\t\\tcnt = cnt + tile[1] - tile[0] + 1\\n\\n\\t\\tlet len = 0\\n\\t\\twhile (\\n\\t\\t\\tl < tiles.length &&\\n\\t\\t\\t(len = tiles[i][1] - tiles[l][0] + 1) > carpetLen\\n\\t\\t) {\\n\\t\\t\\t// keep removing tiles from left side\\n\\t\\t\\tmax = Math.max(max, cnt - len + carpetLen);\\n\\n\\t\\t\\tcnt -= tiles[l][1] - tiles[l][0] + 1\\n\\n\\t\\t\\tl++;\\n\\t\\t}\\n\\n\\t\\tmax = Math.max(max, cnt);\\n\\n\\t\\tif (max == carpetLen) return carpetLen;\\n\\t}\\n\\n\\treturn max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2054637,
                "title": "python-faster-than-74-53",
                "content": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n\\t\\ttiles.sort()\\n        N = len(tiles)\\n        res = 0\\n        rightPtr = 0\\n        currTiles = 0\\n        for start, _ in tiles:\\n            end = start + carpetLen - 1\\n            while rightPtr < N and tiles[rightPtr][1] <= end:\\n                currTiles += tiles[rightPtr][1] - tiles[rightPtr][0] + 1\\n                res = max(res, currTiles)\\n                rightPtr += 1\\n            if rightPtr < N:\\n                currTiles2 = currTiles + (end - tiles[rightPtr][0] + 1)\\n                res = max(res, currTiles2)\\n            currTiles -= (_ - start + 1)\\n        return res\\n```\\nRuntime: 1468 ms, 74.53%\\nMemory: 39 MB, 96.78%\\n\\nNote: If written in Java, the runtime will be 82 ms and Memory 76.6 MB.\\nJava Implementation\\n```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        Arrays.sort(tiles, (a, b) -> Integer.compare(a[0], b[0]));\\n        int N = tiles.length;\\n        int res = 0;\\n        int rightPtr = 0;\\n        int currTiles = 0;\\n        int currTiles2 = 0;\\n        int end = 0;\\n        for (int i = 0; i < N; i++){\\n            end = tiles[i][0] + carpetLen - 1;\\n            while ((rightPtr < N) && (tiles[rightPtr][1] <= end)){\\n                currTiles = currTiles + tiles[rightPtr][1] - tiles[rightPtr][0] + 1;\\n                res = Math.max(res, currTiles);\\n                rightPtr = rightPtr + 1;\\n            }\\n            if (rightPtr < N){\\n                currTiles2 = currTiles + (end - tiles[rightPtr][0] + 1);\\n                res = Math.max(res, currTiles2);\\n            }\\n            currTiles = currTiles - (tiles[i][1] - tiles[i][0] + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n\\t\\ttiles.sort()\\n        N = len(tiles)\\n        res = 0\\n        rightPtr = 0\\n        currTiles = 0\\n        for start, _ in tiles:\\n            end = start + carpetLen - 1\\n            while rightPtr < N and tiles[rightPtr][1] <= end:\\n                currTiles += tiles[rightPtr][1] - tiles[rightPtr][0] + 1\\n                res = max(res, currTiles)\\n                rightPtr += 1\\n            if rightPtr < N:\\n                currTiles2 = currTiles + (end - tiles[rightPtr][0] + 1)\\n                res = max(res, currTiles2)\\n            currTiles -= (_ - start + 1)\\n        return res\\n```\n```\\nclass Solution {\\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        Arrays.sort(tiles, (a, b) -> Integer.compare(a[0], b[0]));\\n        int N = tiles.length;\\n        int res = 0;\\n        int rightPtr = 0;\\n        int currTiles = 0;\\n        int currTiles2 = 0;\\n        int end = 0;\\n        for (int i = 0; i < N; i++){\\n            end = tiles[i][0] + carpetLen - 1;\\n            while ((rightPtr < N) && (tiles[rightPtr][1] <= end)){\\n                currTiles = currTiles + tiles[rightPtr][1] - tiles[rightPtr][0] + 1;\\n                res = Math.max(res, currTiles);\\n                rightPtr = rightPtr + 1;\\n            }\\n            if (rightPtr < N){\\n                currTiles2 = currTiles + (end - tiles[rightPtr][0] + 1);\\n                res = Math.max(res, currTiles2);\\n            }\\n            currTiles = currTiles - (tiles[i][1] - tiles[i][0] + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054468,
                "title": "c-binary-search",
                "content": "* Sort the arrray tiles.\\n* Now iterate over the array tiles and lay carpet on the `tiles[i][0]` to get maximum tiles covered (greedy).\\n* If carpet is laid out at` tiles[i][0]`, then its end point will be `tiles[i][0] + caprpetLen - 1` , call it `maxLen` .\\n* Apply binary search in the array and look for the point just above the endpoint of out laid carpet, let the index be `idx`\\n* Just before the index i.e, `idx-1` , all the tiles would have been covered completely , that is , from index `i` to `idx-1`. To get the tiles covered in O(1) , Pre build the prefix sum array, that should be easy!\\n* Now store the covered tiles in `covered`. But it may happen that the end point of our carpet has extended upto the just next index as well that is `idx`. Consider the contributuion of tiles from that `tiles[idx]` as well. That will be `maxLen-tiles[idx][0] + 1` because `maxLen` signifies the end point of our carpet. If it is negative then we consider `0` contribution.\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    ll ans = 1 ;\\n    \\n    struct cmp{\\n      bool operator()(const vector<int>&v1 , const vector<int>&v2){\\n          return v1[1] < v2[1] ;\\n  }  \\n};\\n    \\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(begin(tiles),end(tiles)) ;\\n        vector<ll>pref ;\\n\\t\\t\\n        for(int i = 0 ; i < tiles.size() ; ++i ){\\n            if(i==0) pref.push_back(tiles[i][1] - tiles[i][0] + 1) ;\\n            else pref.push_back(pref.back() + tiles[i][1] - tiles[i][0] + 1 ) ;\\n        }\\n        \\n        //go at every index and see what is the max distance that the carpet can cover \\n        for(int i = 0 ; i < tiles.size() ; ++i ){ \\n            int maxLen = tiles[i][0] + carpetLen - 1 ;\\n            int idx = upper_bound(begin(tiles),end(tiles),vector<int>{INT_MAX,maxLen},cmp()) - begin(tiles) ;\\n            --idx ; \\n            if(idx < 0){\\n                ans = maxLen ;\\n                continue ;\\n            }\\n            ll covered = pref[idx] - (i-1 >=0 ? pref[i-1] : 0LL ) ;\\n            if(idx + 1 < tiles.size() ) covered += max(0LL,maxLen*1LL - 1LL*tiles[idx + 1][0] + 1LL) ;\\n            ans = max(ans,covered) ;\\n        } \\n        return ans ;\\n    }\\n};\\n```\\nUPVOTE IF YOU LIKED IT!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    ll ans = 1 ;\\n    \\n    struct cmp{\\n      bool operator()(const vector<int>&v1 , const vector<int>&v2){\\n          return v1[1] < v2[1] ;\\n  }  \\n};\\n    \\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(begin(tiles),end(tiles)) ;\\n        vector<ll>pref ;\\n\\t\\t\\n        for(int i = 0 ; i < tiles.size() ; ++i ){\\n            if(i==0) pref.push_back(tiles[i][1] - tiles[i][0] + 1) ;\\n            else pref.push_back(pref.back() + tiles[i][1] - tiles[i][0] + 1 ) ;\\n        }\\n        \\n        //go at every index and see what is the max distance that the carpet can cover \\n        for(int i = 0 ; i < tiles.size() ; ++i ){ \\n            int maxLen = tiles[i][0] + carpetLen - 1 ;\\n            int idx = upper_bound(begin(tiles),end(tiles),vector<int>{INT_MAX,maxLen},cmp()) - begin(tiles) ;\\n            --idx ; \\n            if(idx < 0){\\n                ans = maxLen ;\\n                continue ;\\n            }\\n            ll covered = pref[idx] - (i-1 >=0 ? pref[i-1] : 0LL ) ;\\n            if(idx + 1 < tiles.size() ) covered += max(0LL,maxLen*1LL - 1LL*tiles[idx + 1][0] + 1LL) ;\\n            ans = max(ans,covered) ;\\n        } \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054198,
                "title": "c-binary-search-prefixsum-concise-o-nlogn",
                "content": "**C++ Solution**\\nTime: O(NlogN)\\nSpace: O(N)\\n```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(begin(tiles), end(tiles));\\n        int len = tiles.size();\\n\\n        vector<int> prefixSum(len, 0);\\n        prefixSum[0] = tiles[0][1] - tiles[0][0] + 1;\\n        for (int i = 1; i < len; i++) {\\n            prefixSum[i] += prefixSum[i - 1] + tiles[i][1] - tiles[i][0] + 1;\\n        }\\n\\n        int maxCoveredTiles = 1;\\n        for (int i = 0; i < len; i++) {\\n            int tileStartIndex = tiles[i][0];\\n            int carpetEndIndex = tileStartIndex + carpetLen - 1;\\n\\n            int tipOfCarpetIndex = binarySearch(tiles, i, len, carpetEndIndex);\\n            \\n            int currentMaxCoveredTiles = prefixSum[tipOfCarpetIndex] - (i - 1 >= 0 ? prefixSum[i - 1] : 0);\\n            \\n            int tileEndIndex = tiles[tipOfCarpetIndex][1];\\n            int uncoveredPart = tileEndIndex - carpetEndIndex;\\n            \\n            currentMaxCoveredTiles -= (uncoveredPart > 0) ? uncoveredPart : 0;\\n            \\n            maxCoveredTiles = max(maxCoveredTiles, currentMaxCoveredTiles);\\n        }\\n        \\n        return maxCoveredTiles;\\n    }\\n    \\n    int binarySearch(vector<vector<int>> &tiles, int startIndex, int &len, int carpetEndIndex) {\\n        int midIndex;\\n        int leftIndex = startIndex;\\n        int rightIndex = len - 1;\\n        \\n        while (leftIndex <= rightIndex) {\\n            midIndex = (leftIndex + rightIndex) / 2;\\n            int tileStartIndex = tiles[midIndex][0];\\n            int tileEndIndex = tiles[midIndex][1];\\n            \\n            if (carpetEndIndex >= tileStartIndex && carpetEndIndex <= tileEndIndex) {\\n                break;\\n            }\\n            else if (carpetEndIndex < tileStartIndex) {\\n                rightIndex = midIndex - 1;\\n            }\\n            else if (carpetEndIndex > tileEndIndex) {\\n                leftIndex = midIndex + 1;\\n            }\\n        }\\n        \\n        if (rightIndex < leftIndex) {\\n            midIndex = rightIndex;\\n        }\\n        \\n        return midIndex;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(begin(tiles), end(tiles));\\n        int len = tiles.size();\\n\\n        vector<int> prefixSum(len, 0);\\n        prefixSum[0] = tiles[0][1] - tiles[0][0] + 1;\\n        for (int i = 1; i < len; i++) {\\n            prefixSum[i] += prefixSum[i - 1] + tiles[i][1] - tiles[i][0] + 1;\\n        }\\n\\n        int maxCoveredTiles = 1;\\n        for (int i = 0; i < len; i++) {\\n            int tileStartIndex = tiles[i][0];\\n            int carpetEndIndex = tileStartIndex + carpetLen - 1;\\n\\n            int tipOfCarpetIndex = binarySearch(tiles, i, len, carpetEndIndex);\\n            \\n            int currentMaxCoveredTiles = prefixSum[tipOfCarpetIndex] - (i - 1 >= 0 ? prefixSum[i - 1] : 0);\\n            \\n            int tileEndIndex = tiles[tipOfCarpetIndex][1];\\n            int uncoveredPart = tileEndIndex - carpetEndIndex;\\n            \\n            currentMaxCoveredTiles -= (uncoveredPart > 0) ? uncoveredPart : 0;\\n            \\n            maxCoveredTiles = max(maxCoveredTiles, currentMaxCoveredTiles);\\n        }\\n        \\n        return maxCoveredTiles;\\n    }\\n    \\n    int binarySearch(vector<vector<int>> &tiles, int startIndex, int &len, int carpetEndIndex) {\\n        int midIndex;\\n        int leftIndex = startIndex;\\n        int rightIndex = len - 1;\\n        \\n        while (leftIndex <= rightIndex) {\\n            midIndex = (leftIndex + rightIndex) / 2;\\n            int tileStartIndex = tiles[midIndex][0];\\n            int tileEndIndex = tiles[midIndex][1];\\n            \\n            if (carpetEndIndex >= tileStartIndex && carpetEndIndex <= tileEndIndex) {\\n                break;\\n            }\\n            else if (carpetEndIndex < tileStartIndex) {\\n                rightIndex = midIndex - 1;\\n            }\\n            else if (carpetEndIndex > tileEndIndex) {\\n                leftIndex = midIndex + 1;\\n            }\\n        }\\n        \\n        if (rightIndex < leftIndex) {\\n            midIndex = rightIndex;\\n        }\\n        \\n        return midIndex;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051487,
                "title": "c-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        \\n        sort(tiles.begin(), tiles.end());\\n        tiles[0].push_back(tiles[0][1] - tiles[0][0]+1);\\n        for(int i = 1; i < tiles.size(); i++)\\n            tiles[i].push_back(tiles[i-1][2]+(tiles[i][1] - tiles[i][0]+1));\\n        \\n        map<int, vector<int>> t;\\n        for(int i = 0 ; i < tiles.size(); i++)\\n            t[tiles[i][0]] = {tiles[i][1], tiles[i][2]};\\n        \\n        int best = 0;\\n        int prev_tiles = 0;\\n        for(auto it = t.begin(); it != t.end(); ++it){\\n            int last_covered_tile = it->first + carpetLen - 1;\\n            auto last_range = prev(t.upper_bound(last_covered_tile));\\n            \\n            if(last_covered_tile >= last_range->second[0]) best = max(best, last_range->second[1] - prev_tiles);\\n            else{\\n                int last_rem = (last_range->second[0] - (it->first +  carpetLen - 1));\\n                best = max(best, last_range->second[1] - (prev_tiles + last_rem));\\n            }\\n            prev_tiles = it->second[1];\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        \\n        sort(tiles.begin(), tiles.end());\\n        tiles[0].push_back(tiles[0][1] - tiles[0][0]+1);\\n        for(int i = 1; i < tiles.size(); i++)\\n            tiles[i].push_back(tiles[i-1][2]+(tiles[i][1] - tiles[i][0]+1));\\n        \\n        map<int, vector<int>> t;\\n        for(int i = 0 ; i < tiles.size(); i++)\\n            t[tiles[i][0]] = {tiles[i][1], tiles[i][2]};\\n        \\n        int best = 0;\\n        int prev_tiles = 0;\\n        for(auto it = t.begin(); it != t.end(); ++it){\\n            int last_covered_tile = it->first + carpetLen - 1;\\n            auto last_range = prev(t.upper_bound(last_covered_tile));\\n            \\n            if(last_covered_tile >= last_range->second[0]) best = max(best, last_range->second[1] - prev_tiles);\\n            else{\\n                int last_rem = (last_range->second[0] - (it->first +  carpetLen - 1));\\n                best = max(best, last_range->second[1] - (prev_tiles + last_rem));\\n            }\\n            prev_tiles = it->second[1];\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2049448,
                "title": "c-binary-search-prefix-sum-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool mycmp(vector<int>& v1, vector<int>& v2)\\n    {\\n        return (v1[0]<v2[0]);\\n    }\\n    int bsearch(vector<vector<int>>& tiles, int target)\\n    {\\n        //find after which index target is lying\\n        //or upto what index we can consider all blocks of tiles\\n        \\n        int start=0,end=tiles.size()-1;\\n        int ans=-1;\\n        \\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            if(target>=tiles[mid][1])\\n            {\\n                ans=mid;\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        //sort the tiles\\n        //find in every range\\n        \\n        sort(tiles.begin(),tiles.end(),mycmp);\\n        \\n        //try to put carpet at starting of tile block (from both ends) -> greedy  (only this can give maximum occupied tiles)\\n        // O(NlogN) -> try to think of binary search\\n        \\n        //prefix sum and binary search\\n        int n=tiles.size();\\n        vector<int> prsum(n,0);\\n        prsum[0]=tiles[0][1]-tiles[0][0]+1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            int current=tiles[i][1]-tiles[i][0]+1;\\n            prsum[i]=prsum[i-1]+current;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int start=tiles[i][0];  //inclusive\\n            int end=tiles[i][0]+carpetLen-1;  //inclusive\\n            \\n            int index=bsearch(tiles,end);\\n            if(index==-1)\\n            {\\n                int total=(end-tiles[index+1][0]+1);\\n                ans=max(ans,total);\\n            }\\n            else\\n            {\\n                int total= (i==0)?prsum[index]:prsum[index]-prsum[i-1];\\n                if(index<n-1)\\n                {\\n                    if(end>=tiles[index+1][0])\\n                    {\\n                        total+=(end-tiles[index+1][0]+1);\\n                    }\\n                }\\n                ans=max(ans,total);\\n            }\\n            \\n        }\\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool mycmp(vector<int>& v1, vector<int>& v2)\\n    {\\n        return (v1[0]<v2[0]);\\n    }\\n    int bsearch(vector<vector<int>>& tiles, int target)\\n    {\\n        //find after which index target is lying\\n        //or upto what index we can consider all blocks of tiles\\n        \\n        int start=0,end=tiles.size()-1;\\n        int ans=-1;\\n        \\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            if(target>=tiles[mid][1])\\n            {\\n                ans=mid;\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        //sort the tiles\\n        //find in every range\\n        \\n        sort(tiles.begin(),tiles.end(),mycmp);\\n        \\n        //try to put carpet at starting of tile block (from both ends) -> greedy  (only this can give maximum occupied tiles)\\n        // O(NlogN) -> try to think of binary search\\n        \\n        //prefix sum and binary search\\n        int n=tiles.size();\\n        vector<int> prsum(n,0);\\n        prsum[0]=tiles[0][1]-tiles[0][0]+1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            int current=tiles[i][1]-tiles[i][0]+1;\\n            prsum[i]=prsum[i-1]+current;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int start=tiles[i][0];  //inclusive\\n            int end=tiles[i][0]+carpetLen-1;  //inclusive\\n            \\n            int index=bsearch(tiles,end);\\n            if(index==-1)\\n            {\\n                int total=(end-tiles[index+1][0]+1);\\n                ans=max(ans,total);\\n            }\\n            else\\n            {\\n                int total= (i==0)?prsum[index]:prsum[index]-prsum[i-1];\\n                if(index<n-1)\\n                {\\n                    if(end>=tiles[index+1][0])\\n                    {\\n                        total+=(end-tiles[index+1][0]+1);\\n                    }\\n                }\\n                ans=max(ans,total);\\n            }\\n            \\n        }\\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048068,
                "title": "easy-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& t, int c) {\\n         \\n        sort(t.begin(),t.end());\\n        \\n        vector<int> v;\\n        v.push_back(0);\\n        for(int i = 1;i<t.size();i++)\\n        {\\n            v.push_back(t[i][0]-t[i-1][1]-1);//storing range of not white tiles \\n        }\\n        \\n        for(int i=1;i<v.size();i++)\\n        {\\n            v[i]+=v[i-1]; // prefix sum\\n        }\\n        vector<int> sec_sec;\\n        for(int i=0;i<t.size();i++)\\n        {\\n            sec_sec.push_back(t[i][1]);\\n          \\n        }\\n        \\n        int res = 0;\\n        for(int i=0;i<t.size();i++)\\n        {\\n            \\n            int ans = 0;\\n            int tk = t[i][0] + c - 1;// total length that could be cover from current index\\n        \\n            int idx = lower_bound(sec_sec.begin(),sec_sec.end(),tk) - sec_sec.begin();//max index till where it could cover\\n        \\n            if(idx==sec_sec.size())\\n            {\\n                idx--;\\n                \\n            }\\n            \\n            if(tk>=t[idx][0])\\n            {\\n            tk = min(tk,t[idx][1]);\\n            ans+=(tk-t[idx][0]+1);// white tiles covered at last index\\n            \\n            }\\n      \\n           \\n            idx--;\\n            if(idx>=0)\\n            {\\n                ans+=t[idx][1]-t[i][0]+1; // total length cover before last max index\\n        \\n                ans-=(v[idx]-v[i]); // subtracting not white tiles covered as v[idx] storing value of number not white till till idx\\n              \\n            }\\n            \\n           \\n            res = max(ans,res);\\n        \\n            \\n            \\n        }\\n        \\n        \\n        return res;\\n        \\n        \\n        \\n            \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& t, int c) {\\n         \\n        sort(t.begin(),t.end());\\n        \\n        vector<int> v;\\n        v.push_back(0);\\n        for(int i = 1;i<t.size();i++)\\n        {\\n            v.push_back(t[i][0]-t[i-1][1]-1);//storing range of not white tiles \\n        }\\n        \\n        for(int i=1;i<v.size();i++)\\n        {\\n            v[i]+=v[i-1]; // prefix sum\\n        }\\n        vector<int> sec_sec;\\n        for(int i=0;i<t.size();i++)\\n        {\\n            sec_sec.push_back(t[i][1]);\\n          \\n        }\\n        \\n        int res = 0;\\n        for(int i=0;i<t.size();i++)\\n        {\\n            \\n            int ans = 0;\\n            int tk = t[i][0] + c - 1;// total length that could be cover from current index\\n        \\n            int idx = lower_bound(sec_sec.begin(),sec_sec.end(),tk) - sec_sec.begin();//max index till where it could cover\\n        \\n            if(idx==sec_sec.size())\\n            {\\n                idx--;\\n                \\n            }\\n            \\n            if(tk>=t[idx][0])\\n            {\\n            tk = min(tk,t[idx][1]);\\n            ans+=(tk-t[idx][0]+1);// white tiles covered at last index\\n            \\n            }\\n      \\n           \\n            idx--;\\n            if(idx>=0)\\n            {\\n                ans+=t[idx][1]-t[i][0]+1; // total length cover before last max index\\n        \\n                ans-=(v[idx]-v[i]); // subtracting not white tiles covered as v[idx] storing value of number not white till till idx\\n              \\n            }\\n            \\n           \\n            res = max(ans,res);\\n        \\n            \\n            \\n        }\\n        \\n        \\n        return res;\\n        \\n        \\n        \\n            \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047743,
                "title": "js-single-pass-beats-98-2-pointer-sliding-window-easy-understand-o-t-log-t-o-1-space",
                "content": "Intuitions:\\n\\n1. Move a start pointer from the tile where the start of the carpet is, to where the start of the carpet will be after you slide it right. \\n2. Move an end pointer from the tile where the end of the carpet is, to where the end of the carpet will be, after you slide it to the right. \\n3. As start slides right, subtract white it passes over. \\n4. As end slides right, add white is passes over. \\n5. Also track the carpetEnd (`index`) to know the edge cases where you need to add part of a segment instead of the whole one.\\n\\n```\\n/**\\n * @param {number[][]} tiles\\n * @param {number} carpetLen\\n * @return {number}\\n */\\n// O(T log T) time; O(1) space\\nvar maximumWhiteTiles = function(Tiles, carpetLen) {\\n  const T = Tiles.length;\\n  const W = carpetLen;          // window size\\n  \\n  // tile indices\\n  let start = 0;\\n  let end = 0;\\n  \\n  // carpet end index\\n  let prevIndex = 0;\\n  let index = W;\\n  \\n  let white = 0;\\n  let maxWhite = 0;\\n  \\n  Tiles.sort(([A,a], [B,b]) => A == B ? a-b : A-B);\\n  \\n  // O(T)\\n  for( let i = 0; i < T; i++ ) {\\n    updateStart(i-1, i);    \\n    index = Tiles[start][0] + W - 1;\\n    updateEnd(end, prevIndex, index);\\n    prevIndex = index;\\n    maxWhite = Math.max(maxWhite, white);\\n\\tif ( maxWhite === W ) break; // cannot be bigger than this\\n  }\\n  \\n  return maxWhite;\\n\\n  function updateStart(prev, nextTileIndex) {\\n    if ( prev >= 0 ) {\\n      const tileWhiteCount = Tiles[prev][1] - Tiles[prev][0] + 1;\\n      white -= tileWhiteCount;\\n    }\\n    start = nextTileIndex;\\n  }\\n  \\n  function updateEnd(prevTileIndex, prevCarpetEnd, newCarpetEnd) {\\n    for( end = prevTileIndex; end < T; end++ ) {\\n      const nextTile = Tiles[end]; \\n      if ( end == prevTileIndex ) {\\n        const unseenTileStart = Math.max(nextTile[0], prevCarpetEnd+1);\\n        if ( unseenTileStart > newCarpetEnd ) {\\n          break;\\n        } else {\\n          white += Math.min(nextTile[1], newCarpetEnd) - unseenTileStart + 1;\\n          if ( nextTile[1] >= newCarpetEnd ) break;\\n        }\\n      } else {\\n        if ( nextTile[0] > newCarpetEnd ) {\\n          break;\\n        } else {\\n          white += Math.min(nextTile[1], newCarpetEnd) - nextTile[0] + 1;\\n          if ( nextTile[1] >= newCarpetEnd ) break;\\n        }\\n      }\\n    }\\n  }\\n};\\n```\\n\\nMore ideas:\\n\\n1. Align start of window to start of segment to find the max. \"Proof\": If you pick any other alignment, you have two cases: either it\\'s smaller, or it\\'s bigger. In the second case, it can only be bigger if there\\'s more white tiles somewhere else, so align to the start of that region, and you\\'ll be at the biggest. \\n2. This is basically a sparse array, or a very long array in compressed format. We can\\'t use O(ArrayActualLength) because it\\'s too big, so we have to do O(NumberOfTiles). But assume it was just a giant array (with 10^9 values). It\\'s a sliding window (but fixed window, so simpler) question. What\\'s the maximum sum of 1s in a window? Obviously we can just add from the right and subtract from the left as we move left to right.\\n3. We use the sliding window approach ( add from head, subtract from tail ) but adapt it to the much more complex case of the compressed format ( sliding over intervals, in other words *groups or runs of values*, rather than individual values ).\\n4. As there are T (NumberOfTiles) segments to start at, and the `end` segment pointer stops at each tile only once, it is O(T).",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} tiles\\n * @param {number} carpetLen\\n * @return {number}\\n */\\n// O(T log T) time; O(1) space\\nvar maximumWhiteTiles = function(Tiles, carpetLen) {\\n  const T = Tiles.length;\\n  const W = carpetLen;          // window size\\n  \\n  // tile indices\\n  let start = 0;\\n  let end = 0;\\n  \\n  // carpet end index\\n  let prevIndex = 0;\\n  let index = W;\\n  \\n  let white = 0;\\n  let maxWhite = 0;\\n  \\n  Tiles.sort(([A,a], [B,b]) => A == B ? a-b : A-B);\\n  \\n  // O(T)\\n  for( let i = 0; i < T; i++ ) {\\n    updateStart(i-1, i);    \\n    index = Tiles[start][0] + W - 1;\\n    updateEnd(end, prevIndex, index);\\n    prevIndex = index;\\n    maxWhite = Math.max(maxWhite, white);\\n\\tif ( maxWhite === W ) break; // cannot be bigger than this\\n  }\\n  \\n  return maxWhite;\\n\\n  function updateStart(prev, nextTileIndex) {\\n    if ( prev >= 0 ) {\\n      const tileWhiteCount = Tiles[prev][1] - Tiles[prev][0] + 1;\\n      white -= tileWhiteCount;\\n    }\\n    start = nextTileIndex;\\n  }\\n  \\n  function updateEnd(prevTileIndex, prevCarpetEnd, newCarpetEnd) {\\n    for( end = prevTileIndex; end < T; end++ ) {\\n      const nextTile = Tiles[end]; \\n      if ( end == prevTileIndex ) {\\n        const unseenTileStart = Math.max(nextTile[0], prevCarpetEnd+1);\\n        if ( unseenTileStart > newCarpetEnd ) {\\n          break;\\n        } else {\\n          white += Math.min(nextTile[1], newCarpetEnd) - unseenTileStart + 1;\\n          if ( nextTile[1] >= newCarpetEnd ) break;\\n        }\\n      } else {\\n        if ( nextTile[0] > newCarpetEnd ) {\\n          break;\\n        } else {\\n          white += Math.min(nextTile[1], newCarpetEnd) - nextTile[0] + 1;\\n          if ( nextTile[1] >= newCarpetEnd ) break;\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2047734,
                "title": "java-python-sorting-sliding-window",
                "content": "Runtime: 54 ms, faster than 99.35% of Java online submissions for Maximum White Tiles Covered by a Carpet.\\nMemory Usage: 61.4 MB, less than 96.27% of Java online submissions for Maximum White Tiles Covered by a Carpet.\\n```\\nclass Solution {\\n  public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n    if(carpetLen == 1) return 1;\\n    Arrays.sort(tiles, (int[] a, int[] b) -> a[0] - b[0]);\\n   \\n    int ans = 0, i = 0, j = 0, tmp = 0;\\n    \\n    for(;ans != carpetLen;i++){\\n      int end = tiles[i][0] + carpetLen - 1; \\n      for(;j != tiles.length && tiles[j][1] <= end; j++) \\n        tmp += tiles[j][1] - tiles[j][0] + 1; \\n      \\n      if(j == tiles.length) return Math.max(ans, tmp);\\n      \\n      ans = Math.max(ans, tmp + ( end >= tiles[j][0] ? Math.min(end, tiles[j][1]) - tiles[j][0] + 1 : 0) );\\n      \\n      if(tmp == 0) j++;\\n      else tmp -= (tiles[i][1] - tiles[i][0] + 1);\\n    }\\n                \\n    return ans;      \\n  }\\n}\\n```\\n\\nRuntime: 1101 ms, faster than 99.15% of Python3 online submissions for Maximum White Tiles Covered by a Carpet.\\nMemory Usage: 39.2 MB, less than 41.07% of Python3 online submissions for Maximum White Tiles Covered by a Carpet.\\n```\\nclass Solution:\\n  def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n    if carpetLen == 1 : return 1\\n    tiles.sort()\\n   \\n    ans = i = j = tmp = 0\\n    \\n    while ans != carpetLen :\\n      end = tiles[i][0] + carpetLen - 1 \\n      while j != len(tiles) and tiles[j][1] <= end:\\n        tmp += tiles[j][1] - tiles[j][0] + 1\\n        j += 1\\n      \\n      if j == len(tiles) : return max(ans, tmp)\\n       \\n      if end >= tiles[j][0] : ans = max(ans, tmp + min(end, tiles[j][1]) - tiles[j][0] + 1)\\n      else :ans = max(ans, tmp)\\n      \\n      if tmp == 0 : j += 1\\n      else : tmp -= (tiles[i][1] - tiles[i][0] + 1)\\n      i += 1\\n           \\n    return ans\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n  public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n    if(carpetLen == 1) return 1;\\n    Arrays.sort(tiles, (int[] a, int[] b) -> a[0] - b[0]);\\n   \\n    int ans = 0, i = 0, j = 0, tmp = 0;\\n    \\n    for(;ans != carpetLen;i++){\\n      int end = tiles[i][0] + carpetLen - 1; \\n      for(;j != tiles.length && tiles[j][1] <= end; j++) \\n        tmp += tiles[j][1] - tiles[j][0] + 1; \\n      \\n      if(j == tiles.length) return Math.max(ans, tmp);\\n      \\n      ans = Math.max(ans, tmp + ( end >= tiles[j][0] ? Math.min(end, tiles[j][1]) - tiles[j][0] + 1 : 0) );\\n      \\n      if(tmp == 0) j++;\\n      else tmp -= (tiles[i][1] - tiles[i][0] + 1);\\n    }\\n                \\n    return ans;      \\n  }\\n}\\n```\n```\\nclass Solution:\\n  def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n    if carpetLen == 1 : return 1\\n    tiles.sort()\\n   \\n    ans = i = j = tmp = 0\\n    \\n    while ans != carpetLen :\\n      end = tiles[i][0] + carpetLen - 1 \\n      while j != len(tiles) and tiles[j][1] <= end:\\n        tmp += tiles[j][1] - tiles[j][0] + 1\\n        j += 1\\n      \\n      if j == len(tiles) : return max(ans, tmp)\\n       \\n      if end >= tiles[j][0] : ans = max(ans, tmp + min(end, tiles[j][1]) - tiles[j][0] + 1)\\n      else :ans = max(ans, tmp)\\n      \\n      if tmp == 0 : j += 1\\n      else : tmp -= (tiles[i][1] - tiles[i][0] + 1)\\n      i += 1\\n           \\n    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047051,
                "title": "python-easy-to-understand-sliding-window",
                "content": "1. We always place carpet at start of interval. \\n2. Initially window size is 0\\n3. We keep extending window on right until we can no longer cover an interval fully. \\n4. In this case we try to use tiles partially from current interval. Shrink window from left.\\n\\nFor ease of code, for each interval we pre-compute (number of white tiles, number of white tiles + gap until next interval).\\n\\n```\\n    def maximumWhiteTiles(self, tiles, carpetLen):\\n        tiles.sort()\\n        n = len(tiles)\\n        sizes = []\\n        for i in range(n):\\n            white = tiles[i][1] - tiles[i][0] + 1\\n            tillnext = white + (0 if i == n - 1 else tiles[i + 1][0] - tiles[i][1] - 1)\\n            sizes.append((white, tillnext))\\n        res, start, end, cover, rem = 0, 0, 0, 0, carpetLen\\n        while end < n and res < carpetLen:\\n            # use partial if possible, decrease window\\n            if rem < sizes[end][0]:\\n                if rem: res = max(res, cover + rem)\\n                rem += sizes[start][1]\\n                cover -= sizes[start][0]\\n                start += 1\\n            # can fully cover current interval, extend window\\n            else:\\n                cover += sizes[end][0]\\n                rem -= sizes[end][1]\\n                end += 1\\n                res = max(res, cover)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def maximumWhiteTiles(self, tiles, carpetLen):\\n        tiles.sort()\\n        n = len(tiles)\\n        sizes = []\\n        for i in range(n):\\n            white = tiles[i][1] - tiles[i][0] + 1\\n            tillnext = white + (0 if i == n - 1 else tiles[i + 1][0] - tiles[i][1] - 1)\\n            sizes.append((white, tillnext))\\n        res, start, end, cover, rem = 0, 0, 0, 0, carpetLen\\n        while end < n and res < carpetLen:\\n            # use partial if possible, decrease window\\n            if rem < sizes[end][0]:\\n                if rem: res = max(res, cover + rem)\\n                rem += sizes[start][1]\\n                cover -= sizes[start][0]\\n                start += 1\\n            # can fully cover current interval, extend window\\n            else:\\n                cover += sizes[end][0]\\n                rem -= sizes[end][1]\\n                end += 1\\n                res = max(res, cover)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2047038,
                "title": "c-simple-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(),tiles.end());\\n        vector<int> sums(tiles.size());\\n        int total = 0;\\n        for(int i = 0;i<tiles.size();i++) {\\n            auto& x = tiles[i];\\n            sums[i] = total; \\n            total += x[1] - x[0] + 1; \\n        }\\n        int ret = 0; \\n        for(int i = 0;i<tiles.size();i++) {\\n            auto& x = tiles[i];\\n            int end = x[0] + carpetLen - 1; \\n            auto ptr = upper_bound(tiles.begin()+i,tiles.end(), end , [](int a, auto& e) {\\n                return a < e[0]; \\n            });\\n            int j = ptr - tiles.begin() - 1; \\n            auto t = sums[j] - sums[i];\\n            t += min(end, tiles[j][1]) - tiles[j][0] + 1; \\n            ret = max(ret, t);\\n        }\\n        return ret; \\n    }\\n};\\n```\\nsliding window may be a better approach. I may write a sliding window solution tomorrow. \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {\\n        sort(tiles.begin(),tiles.end());\\n        vector<int> sums(tiles.size());\\n        int total = 0;\\n        for(int i = 0;i<tiles.size();i++) {\\n            auto& x = tiles[i];\\n            sums[i] = total; \\n            total += x[1] - x[0] + 1; \\n        }\\n        int ret = 0; \\n        for(int i = 0;i<tiles.size();i++) {\\n            auto& x = tiles[i];\\n            int end = x[0] + carpetLen - 1; \\n            auto ptr = upper_bound(tiles.begin()+i,tiles.end(), end , [](int a, auto& e) {\\n                return a < e[0]; \\n            });\\n            int j = ptr - tiles.begin() - 1; \\n            auto t = sums[j] - sums[i];\\n            t += min(end, tiles[j][1]) - tiles[j][0] + 1; \\n            ret = max(ret, t);\\n        }\\n        return ret; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046427,
                "title": "python-slide-window",
                "content": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        \\n        n = len(tiles)\\n        local_max = 0\\n        res = 0\\n        j = 0\\n        \\n        tiles = sorted(tiles, key = lambda x: x[0])\\n        \\n        for i in range(n):\\n            if j < i:\\n                j = i\\n                \\n            while j < n and tiles[j][1] <= tiles[i][0] + carpetLen - 1:\\n                local_max += (tiles[j][1] - tiles[j][0] + 1)\\n                res = max(local_max, res)\\n                j += 1\\n       \\n            if j < n and tiles[j][0] <= tiles[i][0] + carpetLen - 1:\\n                res = max(res, local_max + tiles[i][0] + \\n                          carpetLen - tiles[j][0])\\n\\n            if i != j:\\n                local_max -= (tiles[i][1] - tiles[i][0] + 1)\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\\n        \\n        n = len(tiles)\\n        local_max = 0\\n        res = 0\\n        j = 0\\n        \\n        tiles = sorted(tiles, key = lambda x: x[0])\\n        \\n        for i in range(n):\\n            if j < i:\\n                j = i\\n                \\n            while j < n and tiles[j][1] <= tiles[i][0] + carpetLen - 1:\\n                local_max += (tiles[j][1] - tiles[j][0] + 1)\\n                res = max(local_max, res)\\n                j += 1\\n       \\n            if j < n and tiles[j][0] <= tiles[i][0] + carpetLen - 1:\\n                res = max(res, local_max + tiles[i][0] + \\n                          carpetLen - tiles[j][0])\\n\\n            if i != j:\\n                local_max -= (tiles[i][1] - tiles[i][0] + 1)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046172,
                "title": "c-sliding-window",
                "content": "Based on [@votrubac](http://https://leetcode.com/votrubac/) answer\\n```\\n    public int MaximumWhiteTiles(int[][] tiles, int carpetLen)\\n    {\\n        Array.Sort(tiles, (a, b) => a[0].CompareTo(b[0]));\\n        int result = 0, leftTile = 0, cover = 0;\\n        for (int rightTile = 0; rightTile < tiles.Length && result < carpetLen;)\\n\\t\\t    //The carpet covers the right tile completely\\n            if (leftTile == rightTile || tiles[leftTile][0] + carpetLen > tiles[rightTile][1]) \\n            {\\n                cover += Math.Min(carpetLen, tiles[rightTile][1] - tiles[rightTile][0] + 1);\\n                result = Math.Max(result, cover);\\n                rightTile++; //Add another Tile to the right of the the sliding window\\n            }\\n            else //The carpet does not cover the right tile completely, so we only consider part of that which is covered\\n            {\\n                int partial = Math.Max(0, tiles[leftTile][0] + carpetLen - tiles[rightTile][0]);\\n                result = Math.Max(result, cover + partial);\\n                cover -= (tiles[leftTile][1] - tiles[leftTile][0] + 1); //Remove the left tile size from the sliding window\\n                leftTile++; //Remove the left tile from the sliding window\\n            }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n    public int MaximumWhiteTiles(int[][] tiles, int carpetLen)\\n    {\\n        Array.Sort(tiles, (a, b) => a[0].CompareTo(b[0]));\\n        int result = 0, leftTile = 0, cover = 0;\\n        for (int rightTile = 0; rightTile < tiles.Length && result < carpetLen;)\\n\\t\\t    //The carpet covers the right tile completely\\n            if (leftTile == rightTile || tiles[leftTile][0] + carpetLen > tiles[rightTile][1]) \\n            {\\n                cover += Math.Min(carpetLen, tiles[rightTile][1] - tiles[rightTile][0] + 1);\\n                result = Math.Max(result, cover);\\n                rightTile++; //Add another Tile to the right of the the sliding window\\n            }\\n            else //The carpet does not cover the right tile completely, so we only consider part of that which is covered\\n            {\\n                int partial = Math.Max(0, tiles[leftTile][0] + carpetLen - tiles[rightTile][0]);\\n                result = Math.Max(result, cover + partial);\\n                cover -= (tiles[leftTile][1] - tiles[leftTile][0] + 1); //Remove the left tile size from the sliding window\\n                leftTile++; //Remove the left tile from the sliding window\\n            }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2045767,
                "title": "golang",
                "content": "```\\nfunc maximumWhiteTiles(tiles [][]int, carpetLen int) int {\\n    sort.Slice(tiles, func(i int, j int) bool {\\n        return tiles[i][0] < tiles[j][0]\\n    })\\n    var list [][]int\\n    cur := 0\\n    for _, t := range tiles {\\n        list = append(list, []int{t[0], t[1], cur})\\n        cur += t[1] - t[0] + 1\\n    }\\n    \\n    res := 0\\n    for _, t := range tiles {\\n        res = max(res, getPre(list, t[0] + carpetLen) - getPre(list, t[0]))\\n        res = max(res, getPre(list, t[1] + 1) - getPre(list, t[1] - carpetLen + 1))\\n    }\\n    return res\\n}\\n\\nfunc max(a int, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc getPre(list [][]int, a int) int {\\n    if a <= list[0][0] {\\n        return 0\\n    }\\n    \\n    j := sort.Search(len(list), func(i int) bool {\\n        return list[i][0] > a\\n    }) - 1\\n    \\n    if list[j][1] < a {\\n        a = list[j][1] + 1\\n    }\\n    \\n    return list[j][2] + a - list[j][0] \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc maximumWhiteTiles(tiles [][]int, carpetLen int) int {\\n    sort.Slice(tiles, func(i int, j int) bool {\\n        return tiles[i][0] < tiles[j][0]\\n    })\\n    var list [][]int\\n    cur := 0\\n    for _, t := range tiles {\\n        list = append(list, []int{t[0], t[1], cur})\\n        cur += t[1] - t[0] + 1\\n    }\\n    \\n    res := 0\\n    for _, t := range tiles {\\n        res = max(res, getPre(list, t[0] + carpetLen) - getPre(list, t[0]))\\n        res = max(res, getPre(list, t[1] + 1) - getPre(list, t[1] - carpetLen + 1))\\n    }\\n    return res\\n}\\n\\nfunc max(a int, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc getPre(list [][]int, a int) int {\\n    if a <= list[0][0] {\\n        return 0\\n    }\\n    \\n    j := sort.Search(len(list), func(i int) bool {\\n        return list[i][0] > a\\n    }) - 1\\n    \\n    if list[j][1] < a {\\n        a = list[j][1] + 1\\n    }\\n    \\n    return list[j][2] + a - list[j][0] \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2043306,
                "title": "go-two-pointer",
                "content": "```\\nfunc max(a int, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc maximumWhiteTiles(a [][]int, l int) int {\\n    sort.SliceStable(a, func(i, j int) bool {\\n        return a[i][0] < a[j][0]\\n    })\\n    \\n    res := 0\\n    var sum, j int = 0, 0\\n    for i := 0; i < len(a); i++ {\\n        to := a[i][0] + l - 1\\n        for j < len(a) && to >= a[j][0] {\\n            sum += (a[j][1] - a[j][0] + 1)\\n            j++\\n        }\\n        if to < a[j - 1][1] {\\n            res = max(res, sum - (a[j - 1][1] - a[j - 1][0] + 1) + (to - a[j - 1][0] + 1))\\n        } else {\\n            res = max(res, sum)\\n        }\\n        sum -= (a[i][1] - a[i][0] + 1)\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc max(a int, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc maximumWhiteTiles(a [][]int, l int) int {\\n    sort.SliceStable(a, func(i, j int) bool {\\n        return a[i][0] < a[j][0]\\n    })\\n    \\n    res := 0\\n    var sum, j int = 0, 0\\n    for i := 0; i < len(a); i++ {\\n        to := a[i][0] + l - 1\\n        for j < len(a) && to >= a[j][0] {\\n            sum += (a[j][1] - a[j][0] + 1)\\n            j++\\n        }\\n        if to < a[j - 1][1] {\\n            res = max(res, sum - (a[j - 1][1] - a[j - 1][0] + 1) + (to - a[j - 1][0] + 1))\\n        } else {\\n            res = max(res, sum)\\n        }\\n        sum -= (a[i][1] - a[i][0] + 1)\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2043140,
                "title": "scala-documented",
                "content": "```\\nobject Solution {\\n  def maximumWhiteTiles(tiles: Array[Array[Int]], carpetLen: Int): Int = {\\n    // sorts the groups of white tiles by their starting points\\n    tiles.sortInPlaceBy(_.head)\\n\\n    /**\\n     * @return the length of the group of white tiles at the given index\\n     */\\n    def length(i: Int) = tiles(i)(1) - tiles(i)(0) + 1\\n    \\n    // The state is (i, j, numTiles) where:\\n    // - [i, j) is the indices of the groups of white tiles that the carpet is covering\\n    // - numTiles is the sum length of the groups of white tiles that the carpet is fully covering\\n    Iterator\\n      .unfold(0, 0, 0) {\\n        case (i, j, _) if i >= tiles.length || j >= tiles.length =>\\n          None\\n        // carpet does not cover any of the group of white tiles at index j\\n        case (i, j, numTiles) if carpetLen <= tiles(j)(0) - tiles(i)(0) =>\\n          // moves the start of the carpet to the next group\\n          Some(numTiles, (i + 1, j, numTiles - length(i)))\\n        // carpet partially covers the group of white tiles at index j\\n        case (i, j, numTiles) if carpetLen <= tiles(j)(1) - tiles(i)(0) =>\\n          // moves the start of the carpet to the next group\\n          Some(numTiles + tiles(i)(0) + carpetLen - tiles(j)(0), (i + 1, j, numTiles - length(i)))\\n        // carpet extends past the group of white tiles at index j\\n        case (i, j, numTiles) =>\\n          // moves the end of the carpet to the next group\\n          Some(numTiles + tiles(j)(1) - tiles(j)(0) + 1, (i, j + 1, numTiles + length(j)))\\n      }\\n      .maxOption\\n      .getOrElse(0)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def maximumWhiteTiles(tiles: Array[Array[Int]], carpetLen: Int): Int = {\\n    // sorts the groups of white tiles by their starting points\\n    tiles.sortInPlaceBy(_.head)\\n\\n    /**\\n     * @return the length of the group of white tiles at the given index\\n     */\\n    def length(i: Int) = tiles(i)(1) - tiles(i)(0) + 1\\n    \\n    // The state is (i, j, numTiles) where:\\n    // - [i, j) is the indices of the groups of white tiles that the carpet is covering\\n    // - numTiles is the sum length of the groups of white tiles that the carpet is fully covering\\n    Iterator\\n      .unfold(0, 0, 0) {\\n        case (i, j, _) if i >= tiles.length || j >= tiles.length =>\\n          None\\n        // carpet does not cover any of the group of white tiles at index j\\n        case (i, j, numTiles) if carpetLen <= tiles(j)(0) - tiles(i)(0) =>\\n          // moves the start of the carpet to the next group\\n          Some(numTiles, (i + 1, j, numTiles - length(i)))\\n        // carpet partially covers the group of white tiles at index j\\n        case (i, j, numTiles) if carpetLen <= tiles(j)(1) - tiles(i)(0) =>\\n          // moves the start of the carpet to the next group\\n          Some(numTiles + tiles(i)(0) + carpetLen - tiles(j)(0), (i + 1, j, numTiles - length(i)))\\n        // carpet extends past the group of white tiles at index j\\n        case (i, j, numTiles) =>\\n          // moves the end of the carpet to the next group\\n          Some(numTiles + tiles(j)(1) - tiles(j)(0) + 1, (i, j + 1, numTiles + length(j)))\\n      }\\n      .maxOption\\n      .getOrElse(0)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1699356,
                "content": [
                    {
                        "username": "calm27",
                        "content": "Perhaps this problem should be Hard, not Medium. "
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "No way this problem is medium, still can\\'t figure it out after a month of trying different approaches."
                    },
                    {
                        "username": "rohitjingar",
                        "content": "This should be hard..."
                    },
                    {
                        "username": "KennanObura",
                        "content": "I had a different idea from what I have seen in Solution sections and perhaps someone could help me understand why it is not working or what could i be possibly doing wrong? What cases I\\'ve missed? \\nThe problem asks for maximal area colored white can be covered by a carpet of Length L. Here is my thought process.\\n- If I create  an array of length Max value of end of a given Tile, I can then mark the beginning with 1 and the end of the tile with -1 of every tile\\nFor example \\n[1,2] ,[4,9]-> [0,0,0,0,0,0,0,0,0,0] -> [0,1,0,-1,1,0,0,0,0,0,-1]\\n- Loop through to fill the ranges of the tile with 1s and i end up with  [0,1,1,0,1,1,1,1,1,0,0]\\n- With 1s and 0s now the problem reduces to finding the max number of 1s in a window of length carpetLen; \\n\\n\\n `int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        int n = 0, maxArea = 0, max = 0;\\n\\n        for(int [] tile: tiles)\\n            n = Math.max(n, tile[1]);\\n\\n        int [] area = new int [n+3];\\n\\n        for(int [] tile: tiles){\\n            area[tile[0]] += 1;\\n            area[tile[1]+1] += -1; \\n        }\\n        for(int i = 1; i < n+2; i++){\\n            area[i] += area[i-1];   \\n        }\\n\\n        for(int i = 1; i < n+2; i++){\\n            area[i] += area[i-1];\\n            max = Math.max(max, area[i]);\\n        }\\n\\n        if(carpetLen > max)\\n            return max;\\n\\n\\n        for(int i =0; i < (n+3)-carpetLen; i++){\\n            maxArea = Math.max(area[i+carpetLen] - area[i], maxArea);\\n        }\\n\\n        return maxArea;\\n    }`\\n\\nIs my thinking wrong? Can this idea work? If so, where am i going wrong for some cases? "
                    },
                    {
                        "username": "L33t-C0d3r",
                        "content": "Vro.. I guess, it will be a huge space like the constraints are high so how will we create such a huge array(10^9).\nAlso when we find the cumulative sum, then we have to traverse a lot, the time and space both are not efficient."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "use chatGpt\\n"
                    }
                ]
            },
            {
                "id": 1960979,
                "content": [
                    {
                        "username": "calm27",
                        "content": "Perhaps this problem should be Hard, not Medium. "
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "No way this problem is medium, still can\\'t figure it out after a month of trying different approaches."
                    },
                    {
                        "username": "rohitjingar",
                        "content": "This should be hard..."
                    },
                    {
                        "username": "KennanObura",
                        "content": "I had a different idea from what I have seen in Solution sections and perhaps someone could help me understand why it is not working or what could i be possibly doing wrong? What cases I\\'ve missed? \\nThe problem asks for maximal area colored white can be covered by a carpet of Length L. Here is my thought process.\\n- If I create  an array of length Max value of end of a given Tile, I can then mark the beginning with 1 and the end of the tile with -1 of every tile\\nFor example \\n[1,2] ,[4,9]-> [0,0,0,0,0,0,0,0,0,0] -> [0,1,0,-1,1,0,0,0,0,0,-1]\\n- Loop through to fill the ranges of the tile with 1s and i end up with  [0,1,1,0,1,1,1,1,1,0,0]\\n- With 1s and 0s now the problem reduces to finding the max number of 1s in a window of length carpetLen; \\n\\n\\n `int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        int n = 0, maxArea = 0, max = 0;\\n\\n        for(int [] tile: tiles)\\n            n = Math.max(n, tile[1]);\\n\\n        int [] area = new int [n+3];\\n\\n        for(int [] tile: tiles){\\n            area[tile[0]] += 1;\\n            area[tile[1]+1] += -1; \\n        }\\n        for(int i = 1; i < n+2; i++){\\n            area[i] += area[i-1];   \\n        }\\n\\n        for(int i = 1; i < n+2; i++){\\n            area[i] += area[i-1];\\n            max = Math.max(max, area[i]);\\n        }\\n\\n        if(carpetLen > max)\\n            return max;\\n\\n\\n        for(int i =0; i < (n+3)-carpetLen; i++){\\n            maxArea = Math.max(area[i+carpetLen] - area[i], maxArea);\\n        }\\n\\n        return maxArea;\\n    }`\\n\\nIs my thinking wrong? Can this idea work? If so, where am i going wrong for some cases? "
                    },
                    {
                        "username": "L33t-C0d3r",
                        "content": "Vro.. I guess, it will be a huge space like the constraints are high so how will we create such a huge array(10^9).\nAlso when we find the cumulative sum, then we have to traverse a lot, the time and space both are not efficient."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "use chatGpt\\n"
                    }
                ]
            },
            {
                "id": 2031127,
                "content": [
                    {
                        "username": "calm27",
                        "content": "Perhaps this problem should be Hard, not Medium. "
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "No way this problem is medium, still can\\'t figure it out after a month of trying different approaches."
                    },
                    {
                        "username": "rohitjingar",
                        "content": "This should be hard..."
                    },
                    {
                        "username": "KennanObura",
                        "content": "I had a different idea from what I have seen in Solution sections and perhaps someone could help me understand why it is not working or what could i be possibly doing wrong? What cases I\\'ve missed? \\nThe problem asks for maximal area colored white can be covered by a carpet of Length L. Here is my thought process.\\n- If I create  an array of length Max value of end of a given Tile, I can then mark the beginning with 1 and the end of the tile with -1 of every tile\\nFor example \\n[1,2] ,[4,9]-> [0,0,0,0,0,0,0,0,0,0] -> [0,1,0,-1,1,0,0,0,0,0,-1]\\n- Loop through to fill the ranges of the tile with 1s and i end up with  [0,1,1,0,1,1,1,1,1,0,0]\\n- With 1s and 0s now the problem reduces to finding the max number of 1s in a window of length carpetLen; \\n\\n\\n `int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        int n = 0, maxArea = 0, max = 0;\\n\\n        for(int [] tile: tiles)\\n            n = Math.max(n, tile[1]);\\n\\n        int [] area = new int [n+3];\\n\\n        for(int [] tile: tiles){\\n            area[tile[0]] += 1;\\n            area[tile[1]+1] += -1; \\n        }\\n        for(int i = 1; i < n+2; i++){\\n            area[i] += area[i-1];   \\n        }\\n\\n        for(int i = 1; i < n+2; i++){\\n            area[i] += area[i-1];\\n            max = Math.max(max, area[i]);\\n        }\\n\\n        if(carpetLen > max)\\n            return max;\\n\\n\\n        for(int i =0; i < (n+3)-carpetLen; i++){\\n            maxArea = Math.max(area[i+carpetLen] - area[i], maxArea);\\n        }\\n\\n        return maxArea;\\n    }`\\n\\nIs my thinking wrong? Can this idea work? If so, where am i going wrong for some cases? "
                    },
                    {
                        "username": "L33t-C0d3r",
                        "content": "Vro.. I guess, it will be a huge space like the constraints are high so how will we create such a huge array(10^9).\nAlso when we find the cumulative sum, then we have to traverse a lot, the time and space both are not efficient."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "use chatGpt\\n"
                    }
                ]
            },
            {
                "id": 1804022,
                "content": [
                    {
                        "username": "calm27",
                        "content": "Perhaps this problem should be Hard, not Medium. "
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "No way this problem is medium, still can\\'t figure it out after a month of trying different approaches."
                    },
                    {
                        "username": "rohitjingar",
                        "content": "This should be hard..."
                    },
                    {
                        "username": "KennanObura",
                        "content": "I had a different idea from what I have seen in Solution sections and perhaps someone could help me understand why it is not working or what could i be possibly doing wrong? What cases I\\'ve missed? \\nThe problem asks for maximal area colored white can be covered by a carpet of Length L. Here is my thought process.\\n- If I create  an array of length Max value of end of a given Tile, I can then mark the beginning with 1 and the end of the tile with -1 of every tile\\nFor example \\n[1,2] ,[4,9]-> [0,0,0,0,0,0,0,0,0,0] -> [0,1,0,-1,1,0,0,0,0,0,-1]\\n- Loop through to fill the ranges of the tile with 1s and i end up with  [0,1,1,0,1,1,1,1,1,0,0]\\n- With 1s and 0s now the problem reduces to finding the max number of 1s in a window of length carpetLen; \\n\\n\\n `int maximumWhiteTiles(int[][] tiles, int carpetLen) {\\n        int n = 0, maxArea = 0, max = 0;\\n\\n        for(int [] tile: tiles)\\n            n = Math.max(n, tile[1]);\\n\\n        int [] area = new int [n+3];\\n\\n        for(int [] tile: tiles){\\n            area[tile[0]] += 1;\\n            area[tile[1]+1] += -1; \\n        }\\n        for(int i = 1; i < n+2; i++){\\n            area[i] += area[i-1];   \\n        }\\n\\n        for(int i = 1; i < n+2; i++){\\n            area[i] += area[i-1];\\n            max = Math.max(max, area[i]);\\n        }\\n\\n        if(carpetLen > max)\\n            return max;\\n\\n\\n        for(int i =0; i < (n+3)-carpetLen; i++){\\n            maxArea = Math.max(area[i+carpetLen] - area[i], maxArea);\\n        }\\n\\n        return maxArea;\\n    }`\\n\\nIs my thinking wrong? Can this idea work? If so, where am i going wrong for some cases? "
                    },
                    {
                        "username": "L33t-C0d3r",
                        "content": "Vro.. I guess, it will be a huge space like the constraints are high so how will we create such a huge array(10^9).\nAlso when we find the cumulative sum, then we have to traverse a lot, the time and space both are not efficient."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "use chatGpt\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Sum of Total Strength of Wizards",
        "question_content": "<p>As the ruler of a kingdom, you have an army of wizards at your command.</p>\n\n<p>You are given a <strong>0-indexed</strong> integer array <code>strength</code>, where <code>strength[i]</code> denotes the strength of the <code>i<sup>th</sup></code> wizard. For a <strong>contiguous</strong> group of wizards (i.e. the wizards&#39; strengths form a <strong>subarray</strong> of <code>strength</code>), the <strong>total strength</strong> is defined as the <strong>product</strong> of the following two values:</p>\n\n<ul>\n\t<li>The strength of the <strong>weakest</strong> wizard in the group.</li>\n\t<li>The <strong>total</strong> of all the individual strengths of the wizards in the group.</li>\n</ul>\n\n<p>Return <em>the <strong>sum</strong> of the total strengths of <strong>all</strong> contiguous groups of wizards</em>. Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>A <strong>subarray</strong> is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> strength = [1,3,1,2]\n<strong>Output:</strong> 44\n<strong>Explanation:</strong> The following are all the contiguous groups of wizards:\n- [1] from [<u><strong>1</strong></u>,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1\n- [3] from [1,<u><strong>3</strong></u>,1,2] has a total strength of min([3]) * sum([3]) = 3 * 3 = 9\n- [1] from [1,3,<u><strong>1</strong></u>,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1\n- [2] from [1,3,1,<u><strong>2</strong></u>] has a total strength of min([2]) * sum([2]) = 2 * 2 = 4\n- [1,3] from [<u><strong>1,3</strong></u>,1,2] has a total strength of min([1,3]) * sum([1,3]) = 1 * 4 = 4\n- [3,1] from [1,<u><strong>3,1</strong></u>,2] has a total strength of min([3,1]) * sum([3,1]) = 1 * 4 = 4\n- [1,2] from [1,3,<u><strong>1,2</strong></u>] has a total strength of min([1,2]) * sum([1,2]) = 1 * 3 = 3\n- [1,3,1] from [<u><strong>1,3,1</strong></u>,2] has a total strength of min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5\n- [3,1,2] from [1,<u><strong>3,1,2</strong></u>] has a total strength of min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6\n- [1,3,1,2] from [<u><strong>1,3,1,2</strong></u>] has a total strength of min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7\nThe sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> strength = [5,4,6]\n<strong>Output:</strong> 213\n<strong>Explanation:</strong> The following are all the contiguous groups of wizards: \n- [5] from [<u><strong>5</strong></u>,4,6] has a total strength of min([5]) * sum([5]) = 5 * 5 = 25\n- [4] from [5,<u><strong>4</strong></u>,6] has a total strength of min([4]) * sum([4]) = 4 * 4 = 16\n- [6] from [5,4,<u><strong>6</strong></u>] has a total strength of min([6]) * sum([6]) = 6 * 6 = 36\n- [5,4] from [<u><strong>5,4</strong></u>,6] has a total strength of min([5,4]) * sum([5,4]) = 4 * 9 = 36\n- [4,6] from [5,<u><strong>4,6</strong></u>] has a total strength of min([4,6]) * sum([4,6]) = 4 * 10 = 40\n- [5,4,6] from [<u><strong>5,4,6</strong></u>] has a total strength of min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60\nThe sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strength.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= strength[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2062017,
                "title": "c-prefix-monotonic-stack-o-n-solution-with-thought-process",
                "content": "**Most tricky part before involving math:**\\nFor each `strength[i]`, we could find a non-empty index range `(left, right)` where `strength[i]` is the min value. So for all subarrays in this range **including** `strength[i]`, the total strength is `strength[i]` * the sum of those subarray sums.\\n\\n*  `left` is the first index on the left side `i` where `strength[left] < strength[i]`\\n*  `right` is the first index on the right side of `i` where `strength[right] <= strength[i]`\\n\\nThese two indices can be pre-calculated using **monotonic stack** (example: [LC496. Next Greater Element I](https://leetcode.com/problems/next-greater-element-i/)).\\n\\nThe reason we use `<` on `left` but `<=` on `right` is to avoid duplicates.\\nHere is an example array: 1 **2 3 4 2** 3 4 2 1\\nFor the highlighted subarray `2 3 4 2`, we want to calculate the strength using the 2nd `2` but not the first `2`.\\n\\n**How do we get the \"sum of all subarrays including `strength[i]` in range `(left, right)`\"?**\\nLet\\'s list the indices:\\n...`left-1`, `left`, **`left + 1`, `left + 2`, ... `i-1`, `i`, `i+1`, ... `right-1`**, `right`, `right+1`...\\n\\nLet `prefix[i]` be the prefix sum of first `i` elements in `strength`.\\n\\nThe sum of subarrays including `i` are:\\n* the subarrays that start with `left+1`:\\nsum(`left+1`, ... `i`) = `prefix[i + 1] - prefix[left + 1]`\\nsum(`left+1`, ... `i+1`) = `prefix[i + 2] - prefix[left + 1]`\\n...\\nsum(`left+1`, ... `right-1`) = `prefix[right] - prefix[left + 1]`\\n* the subarrays that start with `left+2`:\\nsum(`left+2`, ... `i`) = `prefix[i + 1] - prefix[left + 2]`\\nsum(`left+2`, ... `i+1`) = `prefix[i + 2] - prefix[left + 2]`\\n...\\nsum(`left+2`, ... `right-1`) = `prefix[right] - prefix[left + 2]`\\n\\n...\\n* the subarrays that start with `i`:\\nsum(`i`, ... `i`) = `prefix[i + 1] - prefix[i]`\\nsum(`i`, ... `i+1`) = `prefix[i + 2] - prefix[i]`\\n...\\nsum(`i`, ... `right-1`) = `prefix[right] - prefix[i]`\\n\\nThen we combine all above terms, we have:\\n* *positive* parts:\\n`(prefix[i + 1] + prefix[i + 2] + ... + prefix[right]) * (i - left)`\\n* *negative* parts:\\n`(prefix[left + 1] + prefix[left + 2] + ... + prefix[i]) * (right - i)`\\n\\nThe range sum of `prefix` can be optimized by pre-compute prefix-sum of `prefix`.\\n\\n**Time complexity: O(N)**: we have 5 passes of the input array length\\n**Space complexity: O(N)**: two prefix arrays and a stack (vector) is used\\n\\nThe rest is implementation.\\n\\n**C++ code**\\n```\\nint totalStrength(vector<int>& st) {\\n    long long MOD = 1\\'000\\'000\\'007;\\n    const int N = st.size();\\n    // sum of first k elements\\n    vector<long long> prefix(N + 1, 0L);\\n    for (int i = 0; i < N; ++i) {\\n        prefix[i + 1] = (prefix[i] + st[i]) % MOD;\\n    }\\n    // sum of first k prefix\\n    vector<long long> prefix_sum(N + 2, 0L);\\n    for (int i = 0; i <= N; ++i) {\\n        prefix_sum[i + 1] = (prefix_sum[i] + prefix[i]) % MOD;\\n    }\\n    \\n    // first index on the left < current st\\n    vector<int> left(N, -1);\\n    // mono increase\\n    vector<int> stack;\\n    for (int i = 0; i < N; ++i) {\\n        while (!stack.empty() && st[stack.back()] >= st[i]) {\\n            stack.pop_back();\\n        }\\n        left[i] = stack.empty() ? -1 : stack.back();\\n        stack.push_back(i);\\n    }\\n    \\n    // first index on the right <= current st\\n    vector<int> right(N, N);\\n    stack.clear();\\n    for (int i = N - 1; i >= 0; --i) {\\n        while (!stack.empty() && st[stack.back()] > st[i]) {\\n            stack.pop_back();\\n        }\\n        right[i] = stack.empty() ? N : stack.back();\\n        stack.push_back(i);\\n    }\\n    \\n    long long res = 0;\\n    for (int i = 0; i < N; ++i) {\\n        res += ((prefix_sum[right[i] + 1] - prefix_sum[i + 1]) * (i - left[i]) % MOD + MOD * 2 - \\n               (prefix_sum[i + 1] - prefix_sum[left[i] + 1]) * (right[i] - i) % MOD) % MOD * st[i] % MOD;\\n        res %= MOD;\\n    }\\n    return (int) res;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nint totalStrength(vector<int>& st) {\\n    long long MOD = 1\\'000\\'000\\'007;\\n    const int N = st.size();\\n    // sum of first k elements\\n    vector<long long> prefix(N + 1, 0L);\\n    for (int i = 0; i < N; ++i) {\\n        prefix[i + 1] = (prefix[i] + st[i]) % MOD;\\n    }\\n    // sum of first k prefix\\n    vector<long long> prefix_sum(N + 2, 0L);\\n    for (int i = 0; i <= N; ++i) {\\n        prefix_sum[i + 1] = (prefix_sum[i] + prefix[i]) % MOD;\\n    }\\n    \\n    // first index on the left < current st\\n    vector<int> left(N, -1);\\n    // mono increase\\n    vector<int> stack;\\n    for (int i = 0; i < N; ++i) {\\n        while (!stack.empty() && st[stack.back()] >= st[i]) {\\n            stack.pop_back();\\n        }\\n        left[i] = stack.empty() ? -1 : stack.back();\\n        stack.push_back(i);\\n    }\\n    \\n    // first index on the right <= current st\\n    vector<int> right(N, N);\\n    stack.clear();\\n    for (int i = N - 1; i >= 0; --i) {\\n        while (!stack.empty() && st[stack.back()] > st[i]) {\\n            stack.pop_back();\\n        }\\n        right[i] = stack.empty() ? N : stack.back();\\n        stack.push_back(i);\\n    }\\n    \\n    long long res = 0;\\n    for (int i = 0; i < N; ++i) {\\n        res += ((prefix_sum[right[i] + 1] - prefix_sum[i + 1]) * (i - left[i]) % MOD + MOD * 2 - \\n               (prefix_sum[i + 1] - prefix_sum[left[i] + 1]) * (right[i] - i) % MOD) % MOD * st[i] % MOD;\\n        res %= MOD;\\n    }\\n    return (int) res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2061787,
                "title": "amazon-online-assessment",
                "content": "I knew this problem as it was used in Amazon\\'s online assessment. I think that it\\'s quite hard; I am surprised that Amazon was giving it to new grads.\\n\\nThe solution of this problem is based on [84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/). We use a mono-stack to find a subarray `[left, right]` where the current `pivot` is the smallest element. Then, we need to compute sum of all subarrays within `[left, right]` that include pivot. This is a tricky part. \\n\\n> Note: there is an easier solution (see Simplified Solution below). I could not see it rigth away, so it may be useful to read throught the original solution first.\\n\\n#### Original Solution\\nHere, we compute prefix multiple - going from left and going from right.\\n\\nWe use prefix sum and prefix multiple to find sum of all subarrays from `pivot` to `left` (`left_sum`), and from `pivot` to `right` (`right_sum`). Then the sum of all subarrays is `right_sum * (pivot - left - 1) + left_sum * (right - pivot)`. Finally, we multiply this sum by the value of the pivot (smallest) element and add it to the result.\\n\\nLet us look at this example: `[1,2,3,1,2,3,1]`. For `...1...` in the middle, we have the following subarrays that include it.\\n\\n![image](https://assets.leetcode.com/users/images/85b9fb05-8dd7-49f6-87d3-5347c6838933_1653196241.091054.png)\\n\\n**Observation 1**\\nAs you can see, the sum of all subarrays on the left is `18`, and it is included 3 times (into subarrays `...1]`, `...1, 2]` and `...1, 2, 3]`).\\n\\nSimilarly, the sum of all subarrays on the right is `7`, and it contributes to 4 subarrays (`[1, 2, 3, 1...`, `[2, 3, 1...`, `[3, 1...` and `[1...`). Therefore, sum of all `...1...` subarrays is `18 * 3 + 7 * 4`, which is `82`. \\n\\n**Observation 2**\\nWe can see that `1` at position `0` is included once, `2` - twice, `3` - three times, and `1` - four times. So, our prefix multipe array (starting from the left) is computed as `1 * 1 + 2 * 2 + 3 * 3 + 1 * 4 + 2 * 5 + 3 * 6 + 1 * 7`. \\n\\n![image](https://assets.leetcode.com/users/images/a63ed345-27fb-45b3-9948-6ab77b9ace2c_1653197229.068396.png)\\n\\nUsing prefix arrays, we can see that sum of left subarrays that ends at middle `1` is `18` (`18 - 0 - 0 * (7 - 0)`, and sum of right subarrays is `7` (`13 - 1 - 1 * (6 - 1)`).\\n\\nTo sumarize, the sum of subarrays from `i` ending at `j` is `pm_l[j + 1] - pm_l[i]` minus `i * (ps_l[j + 1] - ps_l[i])`. \\n\\n**C++**\\n```cpp\\nint totalStrength(vector<int>& s) {\\n    long long res = 0, sz = s.size(), mod = 1000000007;\\n    vector<int> ps_l(sz + 1), pm_l(sz + 1); // prefix sum and prefix mul from the left.\\n    vector<int> ps_r(sz + 1), pm_r(sz + 1); // ... from the right.\\n    vector<int> st; // mono-increasing stack.\\n    for (long long i = 0; i < sz; ++i) {\\n        ps_l[i + 1] = (ps_l[i] + s[i]) % mod;\\n        pm_l[i + 1] = (pm_l[i] + (i + 1) * s[i]) % mod;\\n    }\\n    for (int i = sz - 1; i >= 0; --i) {\\n        ps_r[i] = (ps_r[i + 1] + s[i]) % mod;\\n        pm_r[i] = (pm_r[i + 1] + (sz - i) * s[i]) % mod;\\n    }        \\n    for (int right = 0; right <= sz; ++right) {\\n        while(!st.empty() && (right == sz || s[st.back()] >= s[right])) {\\n            int pivot = st.back();\\n            st.pop_back();\\n            long long left = st.empty() ? 0 : st.back() + 1;\\n            long long left_sum = (mod + pm_l[pivot + 1] - pm_l[left] - left * (ps_l[pivot + 1] - ps_l[left]) % mod) % mod;\\n            long long right_sum = (mod + pm_r[pivot + 1] - pm_r[right] - (sz - right) * (ps_r[pivot + 1] - ps_r[right])) % mod;\\n            long long all_sum = (right_sum * (pivot - left + 1) + left_sum * (right - pivot)) % mod;\\n            res = (res + all_sum * s[pivot]) % mod;\\n        }\\n        st.push_back(right);\\n    }\\n    return res;\\n}\\n```\\n\\n#### Simplified Solution\\nSame idea, but here we use prefix sum of prefix sum (`pps`). The formula is much simpler, but it\\'s hard to understand why it works. I had the right intuition, but struggled with it for quite a while.\\n\\n**C++**\\n```cpp\\nint totalStrength(vector<int>& s) {\\n    long long res = 0, sz = s.size(), mod = 1000000007;\\n    vector<int> st; // mono-increasing stack.\\n    vector<long long> pps(s.size() + 1);\\n    partial_sum(begin(s), end(s), begin(pps) + 1, [&](int s, int n){ return (s + n) % mod; });\\n    partial_sum(begin(pps), end(pps), begin(pps));\\n    for (int r = 0; r <= sz; ++r) {\\n        while(!st.empty() && (r == sz || s[st.back()] >= s[r])) {\\n            long long i = st.back(); st.pop_back();\\n            long long l = st.empty() ? -1 : st.back();\\n            res = (res + (mod + (pps[r] - pps[i]) * (i - l) % mod - (pps[i] - pps[max(0LL, l)]) * (r - i) % mod) * s[i]) % mod;\\n        }\\n        st.push_back(r);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint totalStrength(vector<int>& s) {\\n    long long res = 0, sz = s.size(), mod = 1000000007;\\n    vector<int> ps_l(sz + 1), pm_l(sz + 1); // prefix sum and prefix mul from the left.\\n    vector<int> ps_r(sz + 1), pm_r(sz + 1); // ... from the right.\\n    vector<int> st; // mono-increasing stack.\\n    for (long long i = 0; i < sz; ++i) {\\n        ps_l[i + 1] = (ps_l[i] + s[i]) % mod;\\n        pm_l[i + 1] = (pm_l[i] + (i + 1) * s[i]) % mod;\\n    }\\n    for (int i = sz - 1; i >= 0; --i) {\\n        ps_r[i] = (ps_r[i + 1] + s[i]) % mod;\\n        pm_r[i] = (pm_r[i + 1] + (sz - i) * s[i]) % mod;\\n    }        \\n    for (int right = 0; right <= sz; ++right) {\\n        while(!st.empty() && (right == sz || s[st.back()] >= s[right])) {\\n            int pivot = st.back();\\n            st.pop_back();\\n            long long left = st.empty() ? 0 : st.back() + 1;\\n            long long left_sum = (mod + pm_l[pivot + 1] - pm_l[left] - left * (ps_l[pivot + 1] - ps_l[left]) % mod) % mod;\\n            long long right_sum = (mod + pm_r[pivot + 1] - pm_r[right] - (sz - right) * (ps_r[pivot + 1] - ps_r[right])) % mod;\\n            long long all_sum = (right_sum * (pivot - left + 1) + left_sum * (right - pivot)) % mod;\\n            res = (res + all_sum * s[pivot]) % mod;\\n        }\\n        st.push_back(right);\\n    }\\n    return res;\\n}\\n```\n```cpp\\nint totalStrength(vector<int>& s) {\\n    long long res = 0, sz = s.size(), mod = 1000000007;\\n    vector<int> st; // mono-increasing stack.\\n    vector<long long> pps(s.size() + 1);\\n    partial_sum(begin(s), end(s), begin(pps) + 1, [&](int s, int n){ return (s + n) % mod; });\\n    partial_sum(begin(pps), end(pps), begin(pps));\\n    for (int r = 0; r <= sz; ++r) {\\n        while(!st.empty() && (r == sz || s[st.back()] >= s[r])) {\\n            long long i = st.back(); st.pop_back();\\n            long long l = st.empty() ? -1 : st.back();\\n            res = (res + (mod + (pps[r] - pps[i]) * (i - l) % mod - (pps[i] - pps[max(0LL, l)]) * (r - i) % mod) * s[i]) % mod;\\n        }\\n        st.push_back(r);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2061985,
                "title": "java-c-python-one-pass-solution",
                "content": "# **Key words**\\nSubarray + sum -> prefix sum\\nSubarray + minimum  -> mono stack\\n<br>\\n\\n# **Intuition**\\nAssume `A[i]` is the leftmost smallest element in a subarray,\\ncalculate each A[i] contibution\\n<br>\\n\\n# **Explanation**\\n1. Find next small on the right\\n2. Find next small or equal on the left.\\n3. For each `A[i]` as the minimum, find the possible subarray sums.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Python**\\n```py\\n    def totalStrength(self, A):\\n        mod = 10 ** 9 + 7\\n        n = len(A)\\n        \\n        # next small on the right\\n        right = [n] * n\\n        stack = []\\n        for i in range(n):\\n            while stack and A[stack[-1]] > A[i]:\\n                right[stack.pop()] = i\\n            stack.append(i)\\n\\n        # next small on the left\\n        left = [-1] * n\\n        stack = []\\n        for i in range(n-1, -1, -1):\\n            while stack and A[stack[-1]] >= A[i]:\\n                left[stack.pop()] = i\\n            stack.append(i)\\n\\n        # for each A[i] as minimum, calculate sum\\n        res = 0\\n        acc = list(accumulate(accumulate(A), initial = 0))\\n        for i in range(n):\\n            l, r = left[i], right[i]\\n            lacc = acc[i] - acc[max(l, 0)]\\n            racc = acc[r] - acc[i]\\n            ln, rn = i - l, r - i\\n            res += A[i] * (racc * ln - lacc * rn)\\n        return res\\n```\\n<br>\\n\\n# **One Pass Solution**\\n\\nSometimes post it without any changes (lazy or busy :).\\nI hope it\\'s simple to read and understand.\\n\\nActually I did it in 5 passes: two for accumulates, two for two directctions, and last one for calculating the result.\\n\\nActually we can combine left and right, then only 4 pases.\\n\\nActually we can also combine left and right and the last pass, then only 3 passes.\\n\\nActually we can also combine all passes, then only one pass.\\n\\n**Java**\\n```java\\n    public int totalStrength(int[] A) {\\n        int res = 0, ac = 0, mod = (int)1e9 + 7, n = A.length;\\n        Stack<Integer> stack = new Stack<>();\\n        int[] acc = new int[n + 2];\\n        for (int r = 0; r <= n; ++r) {\\n            int a = r < n ? A[r] : 0;\\n            ac = (ac + a) % mod;\\n            acc[r + 1] = (ac + acc[r]) % mod;\\n            while (!stack.isEmpty() && A[stack.peek()] > a) {\\n                int i = stack.pop();\\n                int l = stack.isEmpty() ? -1 : stack.peek();\\n                long lacc = l < 0 ? acc[i] : acc[i] - acc[l], racc = acc[r] - acc[i];\\n                int ln = i - l, rn = r - i;\\n                res = (int)(res + (racc * ln - lacc * rn) % mod * A[i] % mod) % mod;\\n            }\\n            stack.push(r);\\n        }\\n        return (res + mod) % mod;\\n    }\\n```\\n**C++**\\n```cpp\\n    int totalStrength(vector<int>& A) {\\n        int res = 0, ac = 0, mod = 1e9 + 7, n = A.size();\\n        vector<int> stack = {}, acc(n + 2);\\n        for (int r = 0; r <= n; ++r) {\\n            int a = r < n ? A[r] : 0;\\n            ac = (ac + a) % mod;\\n            acc[r + 1] = (ac + acc[r]) % mod;\\n            while (!stack.empty() && A[stack.back()] > a) {\\n                int i = stack.back(); stack.pop_back();\\n                int l = stack.empty() ? -1 : stack.back();\\n                long lacc = l < 0 ? acc[i] : acc[i] - acc[l], racc = acc[r] - acc[i];\\n                int ln = i - l, rn = r - i;\\n                res = (res + (racc * ln - lacc * rn) % mod * A[i] % mod) % mod;\\n            }\\n            stack.push_back(r);\\n        }\\n        return (res + mod) % mod;\\n    }\\n```\\n**Python**\\n```py\\n    def totalStrength(self, A):\\n        res, ac, mod, stack, acc = 0, 0, 10 ** 9 + 7, [-1], [0]\\n        A += [0]\\n        for r, a in enumerate(A):\\n            ac += a\\n            acc.append(ac + acc[-1])\\n            while stack and A[stack[-1]] > a:\\n                i = stack.pop()\\n                l = stack[-1]\\n                lacc = acc[i] - acc[max(l, 0)]\\n                racc = acc[r] - acc[i]\\n                ln, rn = i - l, r - i\\n                res += A[i] * (racc * ln - lacc * rn) % mod\\n            stack.append(r)\\n        return res % mod\\n```\\n<br>\\n\\n\\n# More Good Stack Problems\\nHere are some problems that impressed me.\\nGood luck and have fun.\\n\\n- 2281. [Sum of Total Strength of Wizards](https://leetcode.com/problems/sum-of-total-strength-of-wizards/discuss/2061985/python-solution-on/1405190)\\n- 1776. [Car Fleet II](https://leetcode.com/problems/car-fleet-ii/discuss/1085987/javacpython-on-stack-solution/)\\n- 1673. [Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/discuss/952786/javacpython-one-pass-stack-solution/776191 )\\n- 1671. [Minimum Number of Removals to Make Mountain Array](https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/discuss/952136/Python-LIS-O(nlogn))\\n- 1475. [Final Prices With a Special Discount in a Shop](https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/discuss/685390/javacpython-stack-one-pass/809992)\\n- 1425. [Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/discuss/597751/JavaC++Python-O(N)-Decreasing-Deque)\\n- 1130. [Minimum Cost Tree From Leaf Values](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space)\\n- 907. [Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/170750/C++JavaPython-Stack-Solution)\\n- 901. [Online Stock Span](https://leetcode.com/problems/online-stock-span/discuss/168311/C++JavaPython-O(1))\\n- 856. [Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/discuss/141777/C++JavaPython-O(1)-Space)\\n- 503. [Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/discuss/98270/JavaC++Python-Loop-Twice)\\n- 496. Next Greater Element I\\n- 84. Largest Rectangle in Histogram\\n- 42. Trapping Rain Water\\n<br>\\n\\n\\n# More Similar Prefix Problems\\nHere are some similar prolem that I used prefix sum.\\nUpvoted, good luck and have fun.\\n\\n- 2281. [Sum of Total Strength of Wizards](https://leetcode.com/problems/sum-of-total-strength-of-wizards/discuss/2061985/python-solution-on/1405190)\\n- 1074. [Number of Submatrices That Sum to Target](https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/discuss/303750/JavaC++Python-Find-the-Subarray-with-Target-Sum)\\n- 974.  [Subarray Sums Divisible by K](https://leetcode.com/problems/subarray-sums-divisible-by-k/discuss/217985/JavaC++Python-Prefix-Sum)\\n<br>\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```py\\n    def totalStrength(self, A):\\n        mod = 10 ** 9 + 7\\n        n = len(A)\\n        \\n        # next small on the right\\n        right = [n] * n\\n        stack = []\\n        for i in range(n):\\n            while stack and A[stack[-1]] > A[i]:\\n                right[stack.pop()] = i\\n            stack.append(i)\\n\\n        # next small on the left\\n        left = [-1] * n\\n        stack = []\\n        for i in range(n-1, -1, -1):\\n            while stack and A[stack[-1]] >= A[i]:\\n                left[stack.pop()] = i\\n            stack.append(i)\\n\\n        # for each A[i] as minimum, calculate sum\\n        res = 0\\n        acc = list(accumulate(accumulate(A), initial = 0))\\n        for i in range(n):\\n            l, r = left[i], right[i]\\n            lacc = acc[i] - acc[max(l, 0)]\\n            racc = acc[r] - acc[i]\\n            ln, rn = i - l, r - i\\n            res += A[i] * (racc * ln - lacc * rn)\\n        return res\\n```\n```java\\n    public int totalStrength(int[] A) {\\n        int res = 0, ac = 0, mod = (int)1e9 + 7, n = A.length;\\n        Stack<Integer> stack = new Stack<>();\\n        int[] acc = new int[n + 2];\\n        for (int r = 0; r <= n; ++r) {\\n            int a = r < n ? A[r] : 0;\\n            ac = (ac + a) % mod;\\n            acc[r + 1] = (ac + acc[r]) % mod;\\n            while (!stack.isEmpty() && A[stack.peek()] > a) {\\n                int i = stack.pop();\\n                int l = stack.isEmpty() ? -1 : stack.peek();\\n                long lacc = l < 0 ? acc[i] : acc[i] - acc[l], racc = acc[r] - acc[i];\\n                int ln = i - l, rn = r - i;\\n                res = (int)(res + (racc * ln - lacc * rn) % mod * A[i] % mod) % mod;\\n            }\\n            stack.push(r);\\n        }\\n        return (res + mod) % mod;\\n    }\\n```\n```cpp\\n    int totalStrength(vector<int>& A) {\\n        int res = 0, ac = 0, mod = 1e9 + 7, n = A.size();\\n        vector<int> stack = {}, acc(n + 2);\\n        for (int r = 0; r <= n; ++r) {\\n            int a = r < n ? A[r] : 0;\\n            ac = (ac + a) % mod;\\n            acc[r + 1] = (ac + acc[r]) % mod;\\n            while (!stack.empty() && A[stack.back()] > a) {\\n                int i = stack.back(); stack.pop_back();\\n                int l = stack.empty() ? -1 : stack.back();\\n                long lacc = l < 0 ? acc[i] : acc[i] - acc[l], racc = acc[r] - acc[i];\\n                int ln = i - l, rn = r - i;\\n                res = (res + (racc * ln - lacc * rn) % mod * A[i] % mod) % mod;\\n            }\\n            stack.push_back(r);\\n        }\\n        return (res + mod) % mod;\\n    }\\n```\n```py\\n    def totalStrength(self, A):\\n        res, ac, mod, stack, acc = 0, 0, 10 ** 9 + 7, [-1], [0]\\n        A += [0]\\n        for r, a in enumerate(A):\\n            ac += a\\n            acc.append(ac + acc[-1])\\n            while stack and A[stack[-1]] > a:\\n                i = stack.pop()\\n                l = stack[-1]\\n                lacc = acc[i] - acc[max(l, 0)]\\n                racc = acc[r] - acc[i]\\n                ln, rn = i - l, r - i\\n                res += A[i] * (racc * ln - lacc * rn) % mod\\n            stack.append(r)\\n        return res % mod\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2530049,
                "title": "java-easy-to-understand-time-o-n-space-o-n",
                "content": "**For Every i , Find all subarrays where arr[i] is minimum.\\nWe can find sum of all such subarrays in O(1) using derived simple formula**\\n![image](https://assets.leetcode.com/users/images/19ea1168-5ac7-403a-ab9f-e568edf7cf27_1662296846.330915.png)\\n\\n\\n````\\nclass Solution {\\n    //time O(n), space O(n)\\n    public int totalStrength(int[] strength) {\\n        \\n        int MOD = 1000000007;\\n        int n = strength.length;\\n        long[] pOfP = prefixOfPrefixSum(strength,n);\\n        int[] leftSmaller = prevSmaller(strength,n);\\n        \\n        int[] rightSmallerOrEqual = nextSmallerOrEqual(strength,n);\\n        //why we are taking equal also?\\n        //index(4)->3 0 5 4 \\'1\\' 6 7 1 7 5 0 8 and index(7) 3 0 5 4 1 6 7 \\'1\\' 7 5 0 8\\n        //will make some common subarrays and will add it to the result twice\\n        //eg of common subarray ->  (5 4 \\'1\\' 6 7 1 7 5), (5 4 1 6 7 \\'1\\' 7 5)\\n        //so we will treat second 1 as greater element, therefore\\n        //5 4 \\'1\\' 6 7---> here 1,7,5 will not come\\n        //5 4 1 6 7 \\'1\\' 7 5---> here 1,7,5 will come\\n        //we can either do this in leftSmaller or right smaller \\n        //the above case is for rightsmaller which we have taken into consideration\\n        \\n        \\n        long res =0;\\n        for(int i=0;i<n;i++){\\n            int left = leftSmaller[i];\\n            int right = rightSmallerOrEqual[i];\\n            \\n            //derived formula\\n            //{(i-left)*  preOfPre[right-1] - preOfPre[i-1])} - { (right-i)* preOfPre[i-1] - preOfPre[left-1] }\\n            //down we are using +1 in pOfP coz we have taken 0th index of pOfP as dummy bcz we are accessing pOfP[-1] in some cases\\n            long val = (i-left)*(pOfP[right-1+1]-pOfP[i-1+1])%MOD + MOD - \\n                     (right-i)*(pOfP[i-1+1]-pOfP[left-1+1<0 ? 0 : left-1+1])%MOD;\\n            \\n            val = (strength[i]*val)%MOD;\\n            res += val;\\n            res %= MOD;\\n        }\\n        \\n        return (int)res;\\n    }\\n    \\n    //prefix sum of prefix sum\\n    long[] prefixOfPrefixSum(int[] arr, int n){ \\n        long[] res = new long[n+1];\\n        long sum = 0;\\n        res[0] = 0;\\n        for(int i=1 ;i<=n ;i++){\\n            sum+=arr[i-1];\\n            sum %= 1000000007;\\n            res[i] = (res[i-1]+sum)%1000000007;\\n        }\\n        return res;\\n    }\\n        \\n    int[] prevSmaller(int[] arr, int n){\\n        int res[] = new int[n];\\n        Deque<Integer> st = new ArrayDeque<>();\\n        for(int i=0;i<n;i++){\\n            while(!st.isEmpty() && arr[st.peek()]>=arr[i]) st.pop();\\n            res[i] = st.isEmpty() ? -1 : st.peek(); \\n            st.push(i);\\n        }\\n        return res;\\n    }\\n    int[] nextSmallerOrEqual(int[] arr, int n){\\n        int res[] = new int[n];\\n       Deque<Integer> st = new ArrayDeque<>();\\n        for(int i=n-1;i>=0;i--){\\n            while(!st.isEmpty() && arr[st.peek()]>arr[i]) st.pop();\\n            res[i] = st.isEmpty() ? n : st.peek();\\n            st.push(i);\\n        }\\n        return res;\\n    }\\n}\\n````\\n\\n",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "````\\nclass Solution {\\n    //time O(n), space O(n)\\n    public int totalStrength(int[] strength) {\\n        \\n        int MOD = 1000000007;\\n        int n = strength.length;\\n        long[] pOfP = prefixOfPrefixSum(strength,n);\\n        int[] leftSmaller = prevSmaller(strength,n);\\n        \\n        int[] rightSmallerOrEqual = nextSmallerOrEqual(strength,n);\\n        //why we are taking equal also?\\n        //index(4)->3 0 5 4 \\'1\\' 6 7 1 7 5 0 8 and index(7) 3 0 5 4 1 6 7 \\'1\\' 7 5 0 8\\n        //will make some common subarrays and will add it to the result twice\\n        //eg of common subarray ->  (5 4 \\'1\\' 6 7 1 7 5), (5 4 1 6 7 \\'1\\' 7 5)\\n        //so we will treat second 1 as greater element, therefore\\n        //5 4 \\'1\\' 6 7---> here 1,7,5 will not come\\n        //5 4 1 6 7 \\'1\\' 7 5---> here 1,7,5 will come\\n        //we can either do this in leftSmaller or right smaller \\n        //the above case is for rightsmaller which we have taken into consideration\\n        \\n        \\n        long res =0;\\n        for(int i=0;i<n;i++){\\n            int left = leftSmaller[i];\\n            int right = rightSmallerOrEqual[i];\\n            \\n            //derived formula\\n            //{(i-left)*  preOfPre[right-1] - preOfPre[i-1])} - { (right-i)* preOfPre[i-1] - preOfPre[left-1] }\\n            //down we are using +1 in pOfP coz we have taken 0th index of pOfP as dummy bcz we are accessing pOfP[-1] in some cases\\n            long val = (i-left)*(pOfP[right-1+1]-pOfP[i-1+1])%MOD + MOD - \\n                     (right-i)*(pOfP[i-1+1]-pOfP[left-1+1<0 ? 0 : left-1+1])%MOD;\\n            \\n            val = (strength[i]*val)%MOD;\\n            res += val;\\n            res %= MOD;\\n        }\\n        \\n        return (int)res;\\n    }\\n    \\n    //prefix sum of prefix sum\\n    long[] prefixOfPrefixSum(int[] arr, int n){ \\n        long[] res = new long[n+1];\\n        long sum = 0;\\n        res[0] = 0;\\n        for(int i=1 ;i<=n ;i++){\\n            sum+=arr[i-1];\\n            sum %= 1000000007;\\n            res[i] = (res[i-1]+sum)%1000000007;\\n        }\\n        return res;\\n    }\\n        \\n    int[] prevSmaller(int[] arr, int n){\\n        int res[] = new int[n];\\n        Deque<Integer> st = new ArrayDeque<>();\\n        for(int i=0;i<n;i++){\\n            while(!st.isEmpty() && arr[st.peek()]>=arr[i]) st.pop();\\n            res[i] = st.isEmpty() ? -1 : st.peek(); \\n            st.push(i);\\n        }\\n        return res;\\n    }\\n    int[] nextSmallerOrEqual(int[] arr, int n){\\n        int res[] = new int[n];\\n       Deque<Integer> st = new ArrayDeque<>();\\n        for(int i=n-1;i>=0;i--){\\n            while(!st.isEmpty() && arr[st.peek()]>arr[i]) st.pop();\\n            res[i] = st.isEmpty() ? n : st.peek();\\n            st.push(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063910,
                "title": "python-3-prefix-sum-graphically-explained",
                "content": "![image](https://assets.leetcode.com/users/images/90d0cb23-605d-4100-99e1-5c22f96c7143_1653227437.4233584.png)\\n\\nIf encountering such a problem in an OA, I wouldn\\'t able to figure it out... Anyhow, drew some graphs hope to help illustrating the idea a little.\\n\\nThe setup is similar to [907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/) and [828. Count Unique Characters of All Substrings of a Given String](https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/), for each wizard, we want to find out the longest subarry with the wizard as the **LEFTMOST** occurence of the subarray miminum. Note the **LEFTMOST** constraint - as the example below shows, `1` at index 0 covers `[1,3,1,2]`, but `1` at index 2 can only cover `[3,1,2]`. For all subarrays that includes `1` at index 0, there are no duplicates wrt subarrays covered by `1` at index 2.\\n\\n![image](https://assets.leetcode.com/users/images/2ed195a6-b19c-47a1-9b6c-0471e55ec72a_1653228061.635988.png)\\n\\nNext step is, for each `strength[i]`,summing up all subarrays that include `strength[i]`. Prefix sum is required. After running through a few examples, the following shows some findings and gives the formulation. Note the term index `psps[max(-1, i - L - 1)]`, `i - L - 1` can exceed `-1` and give wrong answers, must limit it to `-1`. The formulation makes sense if we think of how many times a wizard serves as start/end of a subarray.\\n\\n![image](https://assets.leetcode.com/users/images/092f5f24-fde2-4809-8198-24e87e511d42_1653233794.1538622.png)\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        n = len(strength)\\n        mod = 1_000_000_007\\n        \\n        # for each strength[i], find [i - l + 1 to i + r - 1 inclusive]\\n        # s.t. strength[i] is the leftmost occurence of minimum\\n        len_l = [0] * n \\n        len_r = [0] * n \\n        stk = []\\n        \\n        for i in range(n - 1, -1, -1):\\n            while stk and strength[stk[-1]] >= strength[i]:\\n                j = stk.pop()\\n                len_l[j] = j - i\\n            stk.append(i)\\n        for j in stk:\\n            len_l[j] = j + 1\\n        \\n        for i in range(n):\\n            while stk and strength[stk[-1]] > strength[i]:\\n                j = stk.pop()\\n                len_r[j] = i - j\\n            stk.append(i)\\n        for j in stk:\\n            len_r[j] = n - j\\n\\t\\t\\t\\n        # prefix sum of prefix sum\\n        psps = list(accumulate(accumulate(strength))) + [0]\\n        \\n        ans = 0\\n        for i in range(n):\\n            L = len_l[i]\\n            R = len_r[i]\\n            total_R = (psps[i + R - 1] - psps[i - 1]) * L\\n            total_L = (psps[i - 1] - psps[max(-1, i - L - 1)]) * R\\n            ans = (ans + strength[i] * (total_R - total_L)) % mod\\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        n = len(strength)\\n        mod = 1_000_000_007\\n        \\n        # for each strength[i], find [i - l + 1 to i + r - 1 inclusive]\\n        # s.t. strength[i] is the leftmost occurence of minimum\\n        len_l = [0] * n \\n        len_r = [0] * n \\n        stk = []\\n        \\n        for i in range(n - 1, -1, -1):\\n            while stk and strength[stk[-1]] >= strength[i]:\\n                j = stk.pop()\\n                len_l[j] = j - i\\n            stk.append(i)\\n        for j in stk:\\n            len_l[j] = j + 1\\n        \\n        for i in range(n):\\n            while stk and strength[stk[-1]] > strength[i]:\\n                j = stk.pop()\\n                len_r[j] = i - j\\n            stk.append(i)\\n        for j in stk:\\n            len_r[j] = n - j\\n\\t\\t\\t\\n        # prefix sum of prefix sum\\n        psps = list(accumulate(accumulate(strength))) + [0]\\n        \\n        ans = 0\\n        for i in range(n):\\n            L = len_l[i]\\n            R = len_r[i]\\n            total_R = (psps[i + R - 1] - psps[i - 1]) * L\\n            total_L = (psps[i - 1] - psps[max(-1, i - L - 1)]) * R\\n            ans = (ans + strength[i] * (total_R - total_L)) % mod\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067907,
                "title": "bad-but-cool-and-educational-dp-solution",
                "content": "Monostack + Prefix Sum of Prefix Sum + Double DP\\nNot a super intuitive solution, but I think it\\'s educational anyway.\\n\\nWe try to solve it from the angle of: \\nfor each i, what\\'s the cost (sum of strength) of all subarrays **ending at i?** \\nLet `dpC[i]` = the cost of all subarrays ending at i. \\nWe will use previously calculated values to build each `dpC[i]` \\nThen, our final answer is simply `sum(dpC)`.\\n\\nLet `A` be the strength array.\\nWe want to calculate `dpC[i]` for the current i.\\nFirst, we break up the subarrays ending at i into 2 groups. \\n`X = cost of subarrays ending at i where A[i] IS the minimum`\\n`Y = cost of subarrays ending at i where A[i] IS NOT the minimum`\\nObviously, `dpC[i] = X + Y`.\\n\\n# **How can we calculate X?**\\nFirst we need to know, up until where is A[i] still the minimum?\\nWe do this using mono-stack, we want an array `ple` where `ple[i]` gives us the index of\\nthe previous element (to the left of i) that\\'s strictly less than `A[i]`.\\n\\nLet `j = ple[i]`. \\nFor the all subarrays starting between `[j+1 ... i]` and ending exactly at `i`, their minimum is guaranteed to be `A[i]`. \\nWe now need the sum of these subarrays. We can compute it\\nusing prefix sum of prefix sum. (In my implementation, i used suffix sum of suffix sum).\\n\\nSince the implementation here is not that important, let\\'s abstract it away as follows:\\nLet `query(L, R)` -> sum of all subarrays with (right index == R) and (L <= left index <= R)\\nexample:\\n`A = [1,3,2,5,4]`\\n`query(1,3) = (3+2+5) + (2+5) + (5) = 22`\\n\\nNow, we have:\\n`j = ple[i]`\\n`X = A[i] * query(j+1, i)`\\n\\n# **How can we calculate Y?**\\nNow, we are considering the cost of all subarrays ending at i, but starting between `[0 ... j]`.\\nLet\\'s simulate the process first: \\nWe will loop backwards from j to 0, keeping track of the running min and running sum.\\nOur running sum starts at the value `sum(j+1 ... i)`.\\n```py\\nY = 0\\ncurMin = A[j]\\ncurSum = sum(A[j+1 ... i])\\nfor k in range(j, -1, -1):  # loop backwards from j to 0\\n    curSum += A[k]\\n    curMin = min(curMin, A[k])\\n    Y += curSum * curMin\\n```\\nNotice that for many of the values, we have already computed them previously.\\nLet\\'s see how we can leverage `dpC[j]` to compute `dpC[i]`.\\nConsider the following example:\\n`A = [1, 2, 5, 3, 7]`\\n`i = 3`\\n`j = ple[i] = 1`\\n`X = A[i] * query(j+1, i) = 3 * ( (3) + (5+3) ) = 33`\\n\\n`dpC[j]` is the cost of all subarrays ending at j, so:\\n`dpC[j] = ( 2(2) + 1(1+2) ) = 7` \\n\\nLet\\'s manually compute `Y` and see how to build the recurrence:\\n`Y` = the cost of all subarrays ending at i, starting before or at j.\\n`Y = ( 2(2+5+3) + 1(1+2+5+3) ) = 31`\\n\\nLet `s = sum( A[j+1 ... i] ) = 5+3 = 8`.\\nNotice that there are 2 subarrays ending at `j`.\\nFor each, we extend them so that they end at `i`.\\nThis is equivalent to adding the value `s` to both.\\nHowever, those subarrays are weighted differently, because of the minimums.\\nSo, we are actually adding `2(s) + 1(s)` to `dpC[j]`. \\nSimplifying we have `(2+1) * s`, or `(sum of the weights) * s` .\\n\\nIn other words, for each subarray ending at `j`, we add `s` * (the minimum at that point).\\nLet `m[r][l]` denote the minimum of A, if we STARTED AT `r` and went backwards until `l`.\\nWhat we need to add to `dpC[j]` in order to obtain `Y` is:\\n`s * sum( m[j][k] for k in [j ... 0] )`\\n\\nDoing this manually of course results in N^2, \\nbut we can use DP again to efficiently compute values of `m`.\\nLet `dpM[i] = sum( suffixMin( A[0 ... i] ) )`.\\nExample: \\n```py\\nA = [1,3,2,5,4]\\ndpM[3] = sum( suffixMin = [1,2,2,5] ) = 1+2+2+5 = 10\\ndpM[1] = sum( suffixMin = [1,3] ) = 1+3 = 4\\n```\\n\\n# **Here\\'s how we compute `dpM`**:\\n```py\\nj = ple[i]\\nsize = i - j\\ndpM[i] = (A[i] * size) + dpM[j]\\n```\\n\\nFor each i, we know A[i] is the minimum (going backwards) until `j`.\\nSo the sum of the suffix min will be `A[i] * (i-j)` + whatever the sum was before that.\\nExample:\\n```py\\ni = 4\\nj = ple[i] = 2\\n\\n           j     i\\nA = [1, 3, 2, 5, 4]\\n# dpM[i] = (4+4) + (2+2+1) = 13\\n# dpM[j] = (2+2+1) = 5\\n\\nsize = i - j = 2\\ndpM[i] = (A[i] * size) + dpM[j]\\n       = 8 + 5\\n       = 13\\n```\\n\\n\\n# **Finally, let\\'s see that we now have the following recurrence for `dpC[i]`.**\\n```py\\nj = ple[i]\\ns = sum( A[j+1 ... i] )    # i compute this in O(1) using suffix sum below\\nX = A[i] * query(j+1, i)   # cost where A[i] is the min\\nY = dpC[j] + dpM[j] * s    # cost where A[i] is not the min\\ndpC[i] = X + Y\\n```\\n\\n***\\n***\\n***\\n\\n# Putting it all together:\\n\\n```py\\nclass Solution:\\n    def totalStrength(self, A: List[int]) -> int:\\n        N = len(A)\\n        Q = int(1e9)+7\\n\\n        # monostack\\n        # ple[i] = previous lesser element, than the one at i\\n        st, ple = [], [-1]*N\\n        for i in range(N-1,-1,-1):\\n            while st and A[st[-1]] > A[i]:\\n                ple[st.pop()] = i\\n            st += [i]\\n\\n        # preprocessing\\n        ps = [0] * (N+1)   # suffix sum\\n        ds = [0] * (N+1)   # suffix sum of suffix sum\\n        dpM = [0] * (N+1)  # dpM[i] = sum( suffixMin of A[0..i] )\\n        for z in range(N):\\n            i, j = ~z-1, ~z\\n            ps[i] = A[j] + ps[j]\\n            ds[i] = ps[i] + ds[j]\\n            k = ple[z]\\n            dpM[z] = A[z] * (z-k)\\n            if k != -1: dpM[z] += dpM[k]\\n\\n        def query(L, R):  # -> sum( sum(A[k..R]) for k in [L..R] )\\n            if R < L: return 0\\n            diff = ds[L] - ds[R+1]\\n            chop = ps[R+1]\\n            size = R-L+1\\n            return diff - chop * size\\n\\n        ans = 0\\n        dpC = [0] * (N+1)\\n        for i in range(N):\\n            j = ple[i]\\n            x = A[i] * query(j+1, i) % Q\\n            if j == -1: y = 0\\n            else:\\n                s = ps[j+1] - ps[i+1]\\n                y = (dpC[j] + dpM[j] * s) % Q\\n            dpC[i] = (x + y) % Q\\n            ans = (ans + dpC[i]) % Q\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```py\\nY = 0\\ncurMin = A[j]\\ncurSum = sum(A[j+1 ... i])\\nfor k in range(j, -1, -1):  # loop backwards from j to 0\\n    curSum += A[k]\\n    curMin = min(curMin, A[k])\\n    Y += curSum * curMin\\n```\n```py\\nA = [1,3,2,5,4]\\ndpM[3] = sum( suffixMin = [1,2,2,5] ) = 1+2+2+5 = 10\\ndpM[1] = sum( suffixMin = [1,3] ) = 1+3 = 4\\n```\n```py\\nj = ple[i]\\nsize = i - j\\ndpM[i] = (A[i] * size) + dpM[j]\\n```\n```py\\ni = 4\\nj = ple[i] = 2\\n\\n           j     i\\nA = [1, 3, 2, 5, 4]\\n# dpM[i] = (4+4) + (2+2+1) = 13\\n# dpM[j] = (2+2+1) = 5\\n\\nsize = i - j = 2\\ndpM[i] = (A[i] * size) + dpM[j]\\n       = 8 + 5\\n       = 13\\n```\n```py\\nj = ple[i]\\ns = sum( A[j+1 ... i] )    # i compute this in O(1) using suffix sum below\\nX = A[i] * query(j+1, i)   # cost where A[i] is the min\\nY = dpC[j] + dpM[j] * s    # cost where A[i] is not the min\\ndpC[i] = X + Y\\n```\n```py\\nclass Solution:\\n    def totalStrength(self, A: List[int]) -> int:\\n        N = len(A)\\n        Q = int(1e9)+7\\n\\n        # monostack\\n        # ple[i] = previous lesser element, than the one at i\\n        st, ple = [], [-1]*N\\n        for i in range(N-1,-1,-1):\\n            while st and A[st[-1]] > A[i]:\\n                ple[st.pop()] = i\\n            st += [i]\\n\\n        # preprocessing\\n        ps = [0] * (N+1)   # suffix sum\\n        ds = [0] * (N+1)   # suffix sum of suffix sum\\n        dpM = [0] * (N+1)  # dpM[i] = sum( suffixMin of A[0..i] )\\n        for z in range(N):\\n            i, j = ~z-1, ~z\\n            ps[i] = A[j] + ps[j]\\n            ds[i] = ps[i] + ds[j]\\n            k = ple[z]\\n            dpM[z] = A[z] * (z-k)\\n            if k != -1: dpM[z] += dpM[k]\\n\\n        def query(L, R):  # -> sum( sum(A[k..R]) for k in [L..R] )\\n            if R < L: return 0\\n            diff = ds[L] - ds[R+1]\\n            chop = ps[R+1]\\n            size = R-L+1\\n            return diff - chop * size\\n\\n        ans = 0\\n        dpC = [0] * (N+1)\\n        for i in range(N):\\n            j = ple[i]\\n            x = A[i] * query(j+1, i) % Q\\n            if j == -1: y = 0\\n            else:\\n                s = ps[j+1] - ps[i+1]\\n                y = (dpC[j] + dpM[j] * s) % Q\\n            dpC[i] = (x + y) % Q\\n            ans = (ans + dpC[i]) % Q\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065780,
                "title": "java-o-n-solution-with-explanation-91ms",
                "content": "**Thinking Process**\\n* Just like the system design, we need to understand the system scale first. According to the constraint, we must solve the problem in `O(NLogN) or O(N)`.\\n* My initial thought is that I can find out the range for each element such that the element is the minimum element among all continuous subarray within that specific range. And this can be done in O(N).\\n* If this direction is correct, the next problem will be `how I can calculate the sum of all the continuous subarray in O(N)`? It seems like I need to apply the prefix sum approach, but how can I use it? To figure it out, I drew an example.\\n* Let\\'s look at the example `[a0, a1, a2, a3, a4, a5, a6, a7, a8]` and assume `a3` is the minimum value for range `a1 to a6` so that the possible subarrays can be generate by the following equation:\\n```\\n[]                                          []\\n[a2]                                        [a4]\\n                  x       a3      x         [a4, a5]\\n[a1, a2]                                    [a4, a5, a6]\\n```\\n* From the above equation, I conclue the sum of the subarrays can be divided into `3` parts:\\n1. Prefix sum = `Sum([a2], [a1, a2]) x number of the possible end points on the right hand sight`\\n2. Middle sum = `number of possible end points on the left hand side x a3 x number of possible end points on the right hand side`\\n3. Post sum = `Sum([a4], [a4, a5], [a4, a5, a6]) x number of possible end points on the left hand side`\\n* To figure out how to calculate the sum of continuous subarrays, I start from drawing the prefix sum array and observe the relationship between the target and prefix sum array.\\n```\\nInput:  [a0, a1, a2, a3, a4]\\nPrefix:[[a0], [a0, a1], [a0, a1, a2], [a0, a1, a2, a3], [a0, a1, a2, a3, a4]]\\nTarget range a3 to a4: [a3] + [a3, a4]\\n```\\nAfter careful observation, I found\\n```\\nTarget [a3] + [a3, a4] = [a0, a1, a2, a3] + [a0, a1, a2, a3, a4] - 2 x [a0, a1, a2]\\n```\\nThus, I need the second prefix sum array to help calculate sum of continuous subarray in O(N).\\n\\n**Implementation**\\n```\\nclass Solution {\\n    static int mod = (int) 1e9 + 7;\\n    public int totalStrength(int[] nums) {\\n        int n = nums.length;\\n        long[] forward = new long[n], backward = new long[n], prefix = new long[n + 1], suffix = new long[n + 1];\\n        forward[0] = prefix[1] = nums[0];\\n        backward[n - 1] = suffix[n - 1] = nums[n - 1];\\n        for (int i = 1; i < n; ++i) {\\n            forward[i] = nums[i] + forward[i - 1];\\n            prefix[i + 1] = prefix[i] + forward[i];\\n        }\\n        for (int i = n - 2; 0 <= i; --i) {\\n            backward[i] = nums[i] + backward[i + 1];\\n            suffix[i] = suffix[i + 1] + backward[i];\\n        }\\n        long res = 0;\\n        Deque<Integer> dq = new LinkedList();\\n        for (int i = 0; i < n; ++i) {\\n            while (!dq.isEmpty() && nums[dq.peekLast()] >= nums[i]) {\\n                int cur = dq.pollLast(), prev = dq.isEmpty() ? -1 : dq.peekLast();\\n                res = (res + getSum(nums, forward, prefix, backward, suffix, prev, cur, i) * nums[cur]) % mod;\\n            }\\n            dq.add(i);\\n        }\\n        while (!dq.isEmpty()) {\\n            int cur = dq.pollLast(), prev = dq.isEmpty() ? -1 : dq.peekLast();\\n            res = (res + getSum(nums, forward, prefix, backward, suffix, prev, cur, n) * nums[cur]) % mod;\\n        }\\n        return (int) res;\\n    }\\n    private long getSum(int[] nums, long[] forward, long[] prefix, long[] backward, long[] suffix, int prev, int cur, int next) {\\n        long sum = ((cur - prev) * (long) nums[cur] % mod) * (next - cur) % mod;\\n        long preSum = getPresum(backward, suffix, prev + 1, cur - 1, next - cur);\\n        long postSum = getPostsum(forward, prefix, cur + 1, next - 1, cur - prev);\\n        return (sum + preSum + postSum) % mod;\\n    }\\n    private long getPresum(long[] backward, long[] suffix, int from, int to, int m) {\\n        int n = backward.length, cnt = to - from + 1;\\n        return (suffix[from] - suffix[to + 1] - cnt * (to + 1 == n ? 0 : backward[to + 1]) % mod) % mod * m % mod;\\n    }\\n    private long getPostsum(long[] forward, long[] prefix, int from, int to, int m) {\\n        int n = forward.length, cnt = to - from + 1;\\n        return (prefix[to + 1] - prefix[from] - cnt * (0 == from ? 0 : forward[from - 1]) % mod) % mod * m % mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n[]                                          []\\n[a2]                                        [a4]\\n                  x       a3      x         [a4, a5]\\n[a1, a2]                                    [a4, a5, a6]\\n```\n```\\nInput:  [a0, a1, a2, a3, a4]\\nPrefix:[[a0], [a0, a1], [a0, a1, a2], [a0, a1, a2, a3], [a0, a1, a2, a3, a4]]\\nTarget range a3 to a4: [a3] + [a3, a4]\\n```\n```\\nTarget [a3] + [a3, a4] = [a0, a1, a2, a3] + [a0, a1, a2, a3, a4] - 2 x [a0, a1, a2]\\n```\n```\\nclass Solution {\\n    static int mod = (int) 1e9 + 7;\\n    public int totalStrength(int[] nums) {\\n        int n = nums.length;\\n        long[] forward = new long[n], backward = new long[n], prefix = new long[n + 1], suffix = new long[n + 1];\\n        forward[0] = prefix[1] = nums[0];\\n        backward[n - 1] = suffix[n - 1] = nums[n - 1];\\n        for (int i = 1; i < n; ++i) {\\n            forward[i] = nums[i] + forward[i - 1];\\n            prefix[i + 1] = prefix[i] + forward[i];\\n        }\\n        for (int i = n - 2; 0 <= i; --i) {\\n            backward[i] = nums[i] + backward[i + 1];\\n            suffix[i] = suffix[i + 1] + backward[i];\\n        }\\n        long res = 0;\\n        Deque<Integer> dq = new LinkedList();\\n        for (int i = 0; i < n; ++i) {\\n            while (!dq.isEmpty() && nums[dq.peekLast()] >= nums[i]) {\\n                int cur = dq.pollLast(), prev = dq.isEmpty() ? -1 : dq.peekLast();\\n                res = (res + getSum(nums, forward, prefix, backward, suffix, prev, cur, i) * nums[cur]) % mod;\\n            }\\n            dq.add(i);\\n        }\\n        while (!dq.isEmpty()) {\\n            int cur = dq.pollLast(), prev = dq.isEmpty() ? -1 : dq.peekLast();\\n            res = (res + getSum(nums, forward, prefix, backward, suffix, prev, cur, n) * nums[cur]) % mod;\\n        }\\n        return (int) res;\\n    }\\n    private long getSum(int[] nums, long[] forward, long[] prefix, long[] backward, long[] suffix, int prev, int cur, int next) {\\n        long sum = ((cur - prev) * (long) nums[cur] % mod) * (next - cur) % mod;\\n        long preSum = getPresum(backward, suffix, prev + 1, cur - 1, next - cur);\\n        long postSum = getPostsum(forward, prefix, cur + 1, next - 1, cur - prev);\\n        return (sum + preSum + postSum) % mod;\\n    }\\n    private long getPresum(long[] backward, long[] suffix, int from, int to, int m) {\\n        int n = backward.length, cnt = to - from + 1;\\n        return (suffix[from] - suffix[to + 1] - cnt * (to + 1 == n ? 0 : backward[to + 1]) % mod) % mod * m % mod;\\n    }\\n    private long getPostsum(long[] forward, long[] prefix, int from, int to, int m) {\\n        int n = forward.length, cnt = to - from + 1;\\n        return (prefix[to + 1] - prefix[from] - cnt * (0 == from ? 0 : forward[from - 1]) % mod) % mod * m % mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306139,
                "title": "o-n-2-solution",
                "content": "Since everyone is posting the same monotonic stack solution over and over, thought I\\'d post the O(n^2) solution for people like me who couldn\\'t be bothered to read or understand that one.\\n\\n**Note that this exceeds the time limit.**\\n```java\\nclass Solution {\\n    \\n    public int totalStrength(int[] strength) {\\n        int sum = 0;\\n        for (int i = 0; i < strength.length; i++) {\\n            int weakest = Integer.MAX_VALUE;\\n            int total = 0;\\n            for (int j = i; j < strength.length; j++) {\\n                if (strength[j] < weakest)\\n                    weakest = strength[j];      \\n                total = (total + strength[j]) % 1000000007;\\n                int totalStrength = (weakest * total) % 1000000007;\\n                sum = (sum + totalStrength) % 1000000007;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```java\\nclass Solution {\\n    \\n    public int totalStrength(int[] strength) {\\n        int sum = 0;\\n        for (int i = 0; i < strength.length; i++) {\\n            int weakest = Integer.MAX_VALUE;\\n            int total = 0;\\n            for (int j = i; j < strength.length; j++) {\\n                if (strength[j] < weakest)\\n                    weakest = strength[j];      \\n                total = (total + strength[j]) % 1000000007;\\n                int totalStrength = (weakest * total) % 1000000007;\\n                sum = (sum + totalStrength) % 1000000007;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064836,
                "title": "if-you-like-math-latex-formula",
                "content": "![image](https://assets.leetcode.com/users/images/407e8301-32a6-44b8-9b42-f90d3b7ebc42_1653250153.197681.png)\\n\\n\\nThe code comes from the above math formula:\\n\\n```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& strength) {\\n        int n = strength.size();\\n        int mod = int(1e9 + 7);\\n        vector<long long> P(n + 1, 0);\\n        for (int i = 0; i < n; ++i) {\\n            P[i + 1] = (P[i] + strength[i]) % mod;\\n        }\\n        vector<long long> Q(n + 2, 0);\\n        for (int i = 0; i <= n; ++i) {\\n            Q[i + 1] = (Q[i] + P[i]) % mod;\\n        }\\n        vector<pair<int, int>> stack;\\n        stack.emplace_back(-1, INT_MIN);\\n        vector<int> A(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            while (!stack.empty() && stack.back().second > strength[i]) {\\n                stack.pop_back();\\n            }\\n            A[i] = i - stack.back().first - 1;\\n            stack.emplace_back(i, strength[i]);\\n        }\\n        stack.clear();\\n        stack.emplace_back(n, INT_MIN);\\n        vector<int> B(n, 0);\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (!stack.empty() && stack.back().second >= strength[i]) {\\n                stack.pop_back();\\n            }\\n            B[i] = stack.back().first - i - 1;\\n            stack.emplace_back(i, strength[i]);\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            long long X = 1L * (A[i] + 1) * (0L + Q[i + B[i] + 2] - Q[i + 1]) % mod;\\n            long long Y = 1L * (B[i] + 1) * (0L + Q[i + 1] - Q[i - A[i]]) % mod;\\n            ans = (0L + ans + 1L * strength[i] * (X - Y) + mod) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& strength) {\\n        int n = strength.size();\\n        int mod = int(1e9 + 7);\\n        vector<long long> P(n + 1, 0);\\n        for (int i = 0; i < n; ++i) {\\n            P[i + 1] = (P[i] + strength[i]) % mod;\\n        }\\n        vector<long long> Q(n + 2, 0);\\n        for (int i = 0; i <= n; ++i) {\\n            Q[i + 1] = (Q[i] + P[i]) % mod;\\n        }\\n        vector<pair<int, int>> stack;\\n        stack.emplace_back(-1, INT_MIN);\\n        vector<int> A(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            while (!stack.empty() && stack.back().second > strength[i]) {\\n                stack.pop_back();\\n            }\\n            A[i] = i - stack.back().first - 1;\\n            stack.emplace_back(i, strength[i]);\\n        }\\n        stack.clear();\\n        stack.emplace_back(n, INT_MIN);\\n        vector<int> B(n, 0);\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (!stack.empty() && stack.back().second >= strength[i]) {\\n                stack.pop_back();\\n            }\\n            B[i] = stack.back().first - i - 1;\\n            stack.emplace_back(i, strength[i]);\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            long long X = 1L * (A[i] + 1) * (0L + Q[i + B[i] + 2] - Q[i + 1]) % mod;\\n            long long Y = 1L * (B[i] + 1) * (0L + Q[i + 1] - Q[i - A[i]]) % mod;\\n            ans = (0L + ans + 1L * strength[i] * (X - Y) + mod) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2353488,
                "title": "anyone-want-understand-this-problem-read-it",
                "content": "This problem is bullshit. If u want to understand, solve problem 907. It is high level problem 907.\\nAnd I got 7 runtime error because signed integer overflow.\\nSolution is too long for an interview  with 45 minutes.\\nIt is almost imposible to solve and explain in the interview without haven\\'t solve problem 907.",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2155079,
                "title": "the-difficulty-level-of-this-question-should-be-god",
                "content": "I could not figure out `o(n)` approach on my own. \\nI needed to read at least 3 solution by really brilliant people (top voted) to understand the approach.\\nThen I had to do the math on pen-paper 3 times (made mistake 2 time) to actually understand the approach.\\nThen when I actually started coding, I made some some silly mistakes around Stack boundry and \\nthe cherry on top was that you need to do `+ mod) % mod` at almost every place you are doing any calculation.\\n\\nOverall, very good learning experience but I really pity the ones who actually face this in interview.\\n\\nRun time complexity: `4 * O(n)` =  `O(n)` \\nSpace compexity: `O(n)`\\n\\nMy java solution -\\n```\\nclass Solution {\\n    public int totalStrength(int[] strength) {\\n        int mod = 1000000007;\\n        \\n        int len = strength.length;\\n        \\n        long[] prefix = prefixSum(strength, len, mod);\\n        \\n        Deque<Integer> stack = new ArrayDeque<>();\\n        stack.push(-1);\\n\\n        long ans = 0;\\n        for(int i = 0; i < len; i++) {\\n            while(stack.peek() != -1 && strength[i] <= strength[stack.peek()]) {\\n                int mid = stack.pop();\\n                int left = stack.peek() + 1;\\n                int right = i - 1;\\n                \\n                int n = (mid - left);\\n                int t = (right - mid);\\n                \\n                long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\\n                val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\\n                val *= strength[mid];\\n                \\n                ans += val;\\n                ans %= mod;\\n            }\\n            \\n            stack.push(i);\\n        }\\n        \\n        int right = len - 1;\\n        while(stack.peek() != -1) {\\n            int mid = stack.pop();\\n            int left = stack.peek() + 1;\\n            \\n            int n = (mid - left);\\n            int t = (right - mid);\\n\\n            long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\\n            val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\\n            val *= strength[mid];\\n\\n            ans += val;\\n            ans %= mod;\\n        }\\n        \\n        return (int)((ans + mod) % mod);\\n    }\\n    \\n    private long[] prefixSum(int[] strength, int len, int mod) {\\n        long[] prefix = new long[len + 1];\\n        \\n        for(int i = 0; i < len; i++) {\\n            prefix[i + 1] = prefix[i] + strength[i];\\n        }\\n        \\n        long[] doublePrefix = new long[len + 2];\\n        for(int i = 0; i <= len; i++) {\\n            doublePrefix[i + 1] = (doublePrefix[i] + prefix[i]) % mod;\\n        }\\n\\n        return doublePrefix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int totalStrength(int[] strength) {\\n        int mod = 1000000007;\\n        \\n        int len = strength.length;\\n        \\n        long[] prefix = prefixSum(strength, len, mod);\\n        \\n        Deque<Integer> stack = new ArrayDeque<>();\\n        stack.push(-1);\\n\\n        long ans = 0;\\n        for(int i = 0; i < len; i++) {\\n            while(stack.peek() != -1 && strength[i] <= strength[stack.peek()]) {\\n                int mid = stack.pop();\\n                int left = stack.peek() + 1;\\n                int right = i - 1;\\n                \\n                int n = (mid - left);\\n                int t = (right - mid);\\n                \\n                long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\\n                val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\\n                val *= strength[mid];\\n                \\n                ans += val;\\n                ans %= mod;\\n            }\\n            \\n            stack.push(i);\\n        }\\n        \\n        int right = len - 1;\\n        while(stack.peek() != -1) {\\n            int mid = stack.pop();\\n            int left = stack.peek() + 1;\\n            \\n            int n = (mid - left);\\n            int t = (right - mid);\\n\\n            long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\\n            val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\\n            val *= strength[mid];\\n\\n            ans += val;\\n            ans %= mod;\\n        }\\n        \\n        return (int)((ans + mod) % mod);\\n    }\\n    \\n    private long[] prefixSum(int[] strength, int len, int mod) {\\n        long[] prefix = new long[len + 1];\\n        \\n        for(int i = 0; i < len; i++) {\\n            prefix[i + 1] = prefix[i] + strength[i];\\n        }\\n        \\n        long[] doublePrefix = new long[len + 2];\\n        for(int i = 0; i <= len; i++) {\\n            doublePrefix[i + 1] = (doublePrefix[i] + prefix[i]) % mod;\\n        }\\n\\n        return doublePrefix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062997,
                "title": "python-step-by-step-optimization-and-margin-decision",
                "content": "The basic idea is for each index i, we find the range such that nums[i] is the minimum value of this range. Then we simply added the subarray which contains nums[i] within the range: sum(subarray)*nums[i]. \\n\\n**Question 1: How to decide the margin of the range for each index  i  ?**\\n\\nCase 1: if take nearest less and equal from **both** side. \\n\\nFor example :\\n\\n![image](https://assets.leetcode.com/users/images/0cc8838f-765a-4fde-a308-b511184e2e45_1653207310.4855132.png)\\n\\nThere will be two problems:\\n1. We will miss index  1  with value  4 \\n2. We will take duplicated interval  [3,5]  for  i=3  and  i=5 \\n\\nIf we want to resolve problem 2 simply by  right   -- , we still can\\'t resolve 1\\n\\n![image](https://assets.leetcode.com/users/images/6ad88c80-278a-4f50-81a5-109c174bf59f_1653207316.0593114.png)\\n\\n\\n\\nCase 2: If take one strictly less from left but less and equal from right. and mitigate problem 2 by  right   -- . Both these two problems can be resolved. \\n\\nFor example:\\n\\n![image](https://assets.leetcode.com/users/images/e3511a75-4407-4bf1-85ab-4ba322e602ed_1653207322.0978074.png)\\n\\n\\n**Question 2: How to optimize step by step?**\\n\\nImplementation 1: no prefix optimization at all\\n\\n```python\\nans = 0\\nmod = 10**9 + 7\\nfor i in range(n):\\n    left = m1[i] + 1\\n    right = m2[i]\\n    for j in range(left,i+1):\\n        for k in range(i,right):\\n            for l in range(j,k+1):\\n                ans = (ans + stp[i]*stp[l]) % mod\\nreturn ans\\n```\\n---\\nWe can simply get rid of loop  l  by presum of stp:  ps  .\\n\\nImplementation 1: optimize by presum only\\n\\n```python\\nans = 0\\nmod = 10**9 + 7\\nfor i in range(n):\\n    left = m1[i] + 1\\n    right = m2[i]\\n    for j in range(left,i+1):\\n        for k in range(i,right):\\n            # for l in range(j,k+1):\\n            ans = (ans + stp[i]*(ps[k+1] - ps[j])) % mod\\nreturn ans\\n```\\n\\n---\\nNow if we want to remove loop k. We will find for each k, we simply add them up. So if we know the range and count, we can do further optimization with the presum of  ps  :  pss  \\n\\nImplementation 2: remove k loop\\n\\n```python\\nans = 0\\nmod = 10**9 + 7\\nfor i in range(n):\\n    left = m1[i] + 1\\n    right = m2[i]\\n    for j in range(left,i+1):\\n        p1 = pss[right+1] - pss[i+1]\\n        p2 = (right - i)*ps[j]\\n        # for k in range(i,right):\\n        #   ans = (ans + stp[i]*(ps[k+1] - ps[j])) % mod\\n        ans = (ans + stp[i]*(p1 - p2)) % mod\\nreturn ans\\n```\\n---\\nNow if we want to remove loop j. We can find for each j, we simply add  ps[j]  up. So if we know the range and count, we can do further optimization with the presum of  ps  :  pss  \\n\\nImplementation 2: remove j loop\\n\\nThen we reach linear\\n```python\\nans = 0\\nmod = 10**9 + 7\\nfor i in range(n):\\n    left = m1[i] + 1\\n    right = m2[i]\\n    p1 = (i+1-left)*(pss[right+1]-pss[i+1])\\n    p2 = (right-i)*(pss[i+1]- pss[left])\\n    # for j in range(left,i+1):\\n    #     p1 = pss[right+1] - pss[i+1]\\n    #     p2 = (right - i)*ps[j]\\n      ans = (ans + stp[i]*(p1 - p2)) % mod\\nreturn ans\\n```\\n\\n\\n\\n---\\n\\n## Codes\\n---\\n\\n- C++\\n  ```c++\\n  // placeholder\\n  ```\\n\\n- Python\\n  ```python\\n  class Solution:\\n      def totalStrength(self, stp: List[int]) -> int:\\n          st = []\\n          n = len(stp)\\n          m1 = defaultdict(lambda:-1)\\n          ps = [0]\\n          for i in range(n):\\n              while st and stp[st[-1]] >= stp[i]:\\n                  st.pop()\\n              if st: m1[i] = st[-1]\\n              st.append(i)\\n              ps.append(ps[-1] + stp[i])\\n          pss = [0]\\n          for i in ps:\\n              pss.append(pss[-1] + i)\\n          st = []\\n          m2 = defaultdict(lambda:n)\\n          for i in range(n-1,-1,-1):\\n              while st and stp[st[-1]] > stp[i]:\\n                  st.pop()\\n              if st: m2[i] = st[-1]\\n              st.append(i)\\n\\n          ans = 0\\n          mod = 10**9 + 7\\n          for i in range(n):\\n              left = m1[i] + 1\\n              right = m2[i]\\n              p1 = (i+1-left)*(pss[right+1]-pss[i+1])\\n              p2 = (right-i)*(pss[i+1]- pss[left])\\n              ans = (ans + stp[i]*(p1 - p2)) % mod\\n          return ans\\n  ```\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nans = 0\\nmod = 10**9 + 7\\nfor i in range(n):\\n    left = m1[i] + 1\\n    right = m2[i]\\n    for j in range(left,i+1):\\n        for k in range(i,right):\\n            for l in range(j,k+1):\\n                ans = (ans + stp[i]*stp[l]) % mod\\nreturn ans\\n```\n```python\\nans = 0\\nmod = 10**9 + 7\\nfor i in range(n):\\n    left = m1[i] + 1\\n    right = m2[i]\\n    for j in range(left,i+1):\\n        for k in range(i,right):\\n            # for l in range(j,k+1):\\n            ans = (ans + stp[i]*(ps[k+1] - ps[j])) % mod\\nreturn ans\\n```\n```python\\nans = 0\\nmod = 10**9 + 7\\nfor i in range(n):\\n    left = m1[i] + 1\\n    right = m2[i]\\n    for j in range(left,i+1):\\n        p1 = pss[right+1] - pss[i+1]\\n        p2 = (right - i)*ps[j]\\n        # for k in range(i,right):\\n        #   ans = (ans + stp[i]*(ps[k+1] - ps[j])) % mod\\n        ans = (ans + stp[i]*(p1 - p2)) % mod\\nreturn ans\\n```\n```python\\nans = 0\\nmod = 10**9 + 7\\nfor i in range(n):\\n    left = m1[i] + 1\\n    right = m2[i]\\n    p1 = (i+1-left)*(pss[right+1]-pss[i+1])\\n    p2 = (right-i)*(pss[i+1]- pss[left])\\n    # for j in range(left,i+1):\\n    #     p1 = pss[right+1] - pss[i+1]\\n    #     p2 = (right - i)*ps[j]\\n      ans = (ans + stp[i]*(p1 - p2)) % mod\\nreturn ans\\n```\n```c++\\n  // placeholder\\n  ```\n```python\\n  class Solution:\\n      def totalStrength(self, stp: List[int]) -> int:\\n          st = []\\n          n = len(stp)\\n          m1 = defaultdict(lambda:-1)\\n          ps = [0]\\n          for i in range(n):\\n              while st and stp[st[-1]] >= stp[i]:\\n                  st.pop()\\n              if st: m1[i] = st[-1]\\n              st.append(i)\\n              ps.append(ps[-1] + stp[i])\\n          pss = [0]\\n          for i in ps:\\n              pss.append(pss[-1] + i)\\n          st = []\\n          m2 = defaultdict(lambda:n)\\n          for i in range(n-1,-1,-1):\\n              while st and stp[st[-1]] > stp[i]:\\n                  st.pop()\\n              if st: m2[i] = st[-1]\\n              st.append(i)\\n\\n          ans = 0\\n          mod = 10**9 + 7\\n          for i in range(n):\\n              left = m1[i] + 1\\n              right = m2[i]\\n              p1 = (i+1-left)*(pss[right+1]-pss[i+1])\\n              p2 = (right-i)*(pss[i+1]- pss[left])\\n              ans = (ans + stp[i]*(p1 - p2)) % mod\\n          return ans\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 2534592,
                "title": "python-o-n-time-and-space",
                "content": "The solution is a combination of two things:\\n1) monotonic stack for finding all mins for subarray ranges, you can prepare with (https://leetcode.com/problems/sum-of-subarray-minimums/)\\n2) using prefix sum of prefix sums to find the total of subarrays containing particular element at certain index (for the more detailed explanation you can check [this post ](https://leetcode.com/problems/sum-of-total-strength-of-wizards/discuss/2530049/JAVA-Easy-to-understand-Time-%3A-O(n)-Space-O(n)) that nicely explains the logic.\\n\\n```\\nclass Solution:\\n    # calculate the sum of presums for certain strength at index i\\n    # we will use it in calculating the sum of all subarrays containing particular element\\n    # we stuff it with an extra value at the end to accomodate the lookups at -1 for left \\n    # boundary which includes the beginning of the array\\n    def get_presums(self, strength):\\n        n  = len(strength)\\n        res = [0] * (n + 2)\\n        cur_sum = 0\\n        \\n        for i in range(n):\\n            cur_sum += strength[i]\\n            res[i+1] = (res[i] + cur_sum)\\n                    \\n        return res\\n            \\n    def totalStrength(self, strength: List[int]) -> int:\\n        if not strength:\\n            return 0\\n        \\n        n = len(strength)\\n        res = 0\\n        stack = []\\n        \\n        pre_sums = self.get_presums(strength)\\n                \\n        # use monotonic stack to find the min for a certain range of subarrays\\n        # and add an extra element at the end of the iterable to make sure we\\'ll pop all elements\\n        # from the stack\\n        for i, num in enumerate(itertools.chain(strength, [-float(\\'inf\\')])):\\n            while stack and num < strength[stack[-1]]:\\n                cur_min_idx = stack.pop()\\n                left  = stack[-1] if stack else -1\\n                \\n                # the TOTAL of all subarrays containing our minimum strength found above\\n                cur_sub_sum = (cur_min_idx - left) * (pre_sums[i] - pre_sums[cur_min_idx]) - (i - cur_min_idx ) * (pre_sums[cur_min_idx] - pre_sums[left])\\n                res +=  cur_sub_sum * strength[cur_min_idx]\\n                        \\n            stack.append(i)\\n                \\n        # i didn\\'t use modular arithmetic along the way and only indicated its use here\\n        # cause in python int numbers don\\'t have the limitation they may have in other languages\\n        return res % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # calculate the sum of presums for certain strength at index i\\n    # we will use it in calculating the sum of all subarrays containing particular element\\n    # we stuff it with an extra value at the end to accomodate the lookups at -1 for left \\n    # boundary which includes the beginning of the array\\n    def get_presums(self, strength):\\n        n  = len(strength)\\n        res = [0] * (n + 2)\\n        cur_sum = 0\\n        \\n        for i in range(n):\\n            cur_sum += strength[i]\\n            res[i+1] = (res[i] + cur_sum)\\n                    \\n        return res\\n            \\n    def totalStrength(self, strength: List[int]) -> int:\\n        if not strength:\\n            return 0\\n        \\n        n = len(strength)\\n        res = 0\\n        stack = []\\n        \\n        pre_sums = self.get_presums(strength)\\n                \\n        # use monotonic stack to find the min for a certain range of subarrays\\n        # and add an extra element at the end of the iterable to make sure we\\'ll pop all elements\\n        # from the stack\\n        for i, num in enumerate(itertools.chain(strength, [-float(\\'inf\\')])):\\n            while stack and num < strength[stack[-1]]:\\n                cur_min_idx = stack.pop()\\n                left  = stack[-1] if stack else -1\\n                \\n                # the TOTAL of all subarrays containing our minimum strength found above\\n                cur_sub_sum = (cur_min_idx - left) * (pre_sums[i] - pre_sums[cur_min_idx]) - (i - cur_min_idx ) * (pre_sums[cur_min_idx] - pre_sums[left])\\n                res +=  cur_sub_sum * strength[cur_min_idx]\\n                        \\n            stack.append(i)\\n                \\n        # i didn\\'t use modular arithmetic along the way and only indicated its use here\\n        # cause in python int numbers don\\'t have the limitation they may have in other languages\\n        return res % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088788,
                "title": "o-n-monotonic-stack-prefix-sum-of-prefix-sums",
                "content": "For a given array `s` of length `n`, we are interested in computing the sum of products \\n```\\nmin(a) * sum(a)\\n```\\nover all subarrays `a` of `s`, i.e.\\n```\\nsum_{a in subarrays(s)} min(a) * sum(a)\\n```\\n\\n**LOCAL PROBLEM**\\nFor each index `i`, we wish to solve the local problem of what is the computed score for all subarrays ending at index `i`, denote it `score(i)`. Of the `i+1` of these subarrays ending at `i`, we should figure out:\\n- which of these subarrays is `s(i)` the minimum value for?\\n- which of these subarrays is `s(i)` not the minimum value for?\\n\\nFor this purpose, we can leverage a monotone increasing stack, where we store indexes such that the corresponding strengths are strictly increasing. Two things can happen as we pop indexes from this stack whose strength is `>= s(i)`:\\n- we exhaust the stack, and so `s(i)` is necessarily the minimum element for all of the `i+1` subarrays ending at index `i`\\n- we arrive at some index `j < i` for which `s(j) < s(i)`\\n\\n**EQUATIONS**\\nWe tackle the first case, as it will inform how to handle the second case. In this situation we get over all `i+1` subarrays ending at index `i`:\\n```\\nscore(i) = s(i) * prefix(i)  + s(i) * [prefix(i) - prefix(0)] + ... + s(i) * [prefix(i) - prefix(i-1)]\\n```\\nwhere:\\n```\\nprefix(i) = sum_{k = 0}^i s(k)\\n```\\nIn the above, the first term corresponds to the subarray of length `i+1` ending at index `i`, ..., last term corresponds to subarray of length `1` ending at index `i`. Doing some algebra, we get:\\n```\\nscore(i) = (i + 1) * s(i) * prefix(i) - [sum_{k=0}^{i-1} prefix(k)] \\n```\\nSo we are already seeing a prefix sum of prefix sums is coming into the picture (more later).\\n\\nNow, what about the second case, where we run into the last index `j < i` for which `s(j) < s(i)`? Well, we know for subarrays corresponding to index intervals `[j+1, i], ..., [i-1, i], [i, i]`, `s(i)` will still remain the minimum value, so we get the following for these `i - j` subarrays ending at index `i` (which is similar to what we saw in the first case of exhausting the stack):\\n```\\ns(i) * [prefix(i) - prefix(j)] + s(i) * [prefix(i) - prefix(j + 1)] + ... + s(i) * [prefix(i) - prefix(i - 1)] =\\n(i - j) * s(i) * prefix(i) - [sum_{k = j}^{i-1} prefix(k)] \\n```\\n\\nNow what about the other `j + 1` subarrays ending at index `i` with index intervals `[0, i], ..., [j, i]`? We know `score(j)` already since `j < i`. All the minima for each subarray ending at index `j`, when we extend these subarrays to end at index `i`, will remain minima, since `s(k) >= s(i) > s(j)`, for `j + 1 <= k <= i`. So we just need to update the sum of strengths for these subarrays, to include the values in index range `[j+1, i]`. \\n\\nHow do we do this?\\n\\nSuppose `m(k, j)` is the minimum for the subarray with index interval `[k, j]`, for `k=0, ..., j`. Then we know that:\\n```\\nscore(j) = m(0, j) * prefix(j) + m(1, j) * [prefix(j) - prefix(0)] + ... + m(j, j) * [prefix(j) - prefix(j - 1)]\\n```\\nExtending each index intervals to go from `[k, j] -> [k, i]` for `k = 0, ..., j` means we get the following:\\n```\\nm(0, j) * prefix(i) + m(1, j) * [prefix(i) - prefix(0)] + ... + m(j, j) * [prefix(i) - prefix(j-1)] = \\nm(0, j) * [prefix(i) - prefix(j) + prefix(j)] + m(1, j) * [prefix(i) - prefix(j) + prefix(j) - prefix(1)] + ... + m(j, j) * [prefix(i) - prefix(j) + prefix(j) - prefix(j-1)] = \\nscore(j) + m(0, j) * [prefix(i) - prefix(j)] + m(1, j) * [prefix(i) - prefix(j)] + ... + m(j, j) * [prefix(i) - prefix(j)] = \\nscore(j) + [prefix(i) - prefix(j)] * sum_{k=0}^j m(k, j)\\n```\\nWe will come back to this last sum of minimums in a moment. But we\\'ve now accounted for:\\n- the `i - j` subarrays ending at index `i` for which `s(i)` is the minimum value\\n- the `j + 1` subarrays ending at index `i` for which `s(i)` is not the minimum value\\n\\nCombining everything, we get:\\n```\\nscore(i) = (i - j) * s(i) * prefix(i) - [sum_{k=j}^{i-1} prefix(k)] + score(j) + [prefix(i) - prefix(j)] * sum_{k=0}^j m(k, j)\\n```\\n\\n**SUM OF MINIMA**\\nThe equation above, the last term involves a sum of minima. Let\\'s denote `min_sum(i)`:\\n```\\nmin_sum(i) = sum_{k=0}^i m(k, i)\\n```\\nwhere `m(k, i) = min{s(k), ..., s(i)}`, for `k <= i`.\\n\\nWe don\\'t want to be computing this from scratch for each calculation of `score(.)`, as this would grow our time complexity to be quadratic in `n`. This is where our monotone increasing stack comes into play again. For index `i`, again our two cases:\\n- we exhaust the stack. Then `s(i)` is the minimum over all subarrays ending at `i`, so we get `min_sum(i) = (i+1) * s(i)`\\n- we run into `j < i` with `s(j) < s(i)`. Then `s(i)` is the minimum value only for the last `i - j` subarrays ending at index `i`, with index intervals `[j+1, i], ..., [i, i]`. We get `min_sum(i) = min_sum(j) + (i - j) * s(i)`\\n\\nThus, we have a recursive formula for `min_sum(i)` that we can compute quickly during our iteration through the array. We simplify our grand formula a bit to reflect this:\\n```\\nscore(i) = (i - j) * s(i) * prefix(i) - [sum_{k=j}^{i-1} prefix(k)] + score(j) + [prefix(i) - prefix(j)] * min_sum(j)\\n```\\n\\n**PREFIX SUM OF PREFIX SUMS**\\nThis is straightforward. We notice this term:\\n```\\nsum_{k=j}^{i-1} prefix(k)\\n```\\nin our equation. So we have to take prefix sums of our prefix sums of `s` upfront, to save time. Define:\\n```\\nprefix_of_prefix(i) = sum_{k=0}^i prefix(k) = sum_{k=0}^i [sum_{l=0}^k s(l)] \\n```\\nOur formula in the second case is now:\\n```\\nscore(i) = \\n(i - j) * s(i) * prefix(i) - [prefix_of_prefix(i-1) - prefix_of_prefix(j-1)] + score(j) + [prefix(i) - prefix(j)] * min_sum(j) =\\n(i - j) * s(i) * prefix(i) - prefix_of_prefix(i-1) + prefix_of_prefix(j-1) + score(j) + [prefix(i) - prefix(j)] * min_sum(j)\\n```\\nPerhaps more algebra can be done to simplify it; I\\'ll leave it to someone else.\\n\\n**PUTTING IT ALL TOGETHER**\\nSo once we know our local result `score(i)`, the sum of scores for all subarrays ending at each index `i`, then we just add this up over all `i` to get our final answer:\\n```\\nscore(0) + ... + score(n - 1)\\n```\\n\\n**CODE**\\n```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        n = len(strength)\\n        mod = 10 ** 9 + 7\\n        \\n        prefix = [0] * n\\n        for i in range(n):\\n            prefix[i] = prefix[i - 1] + strength[i]\\n        \\n        prefix_of_prefix = [0] * n\\n        for i in range(n):\\n            prefix_of_prefix[i] = (prefix_of_prefix[i - 1] + prefix[i]) % mod\\n        \\n        min_sum = [0] * n\\n        score = [0] * n\\n        stack = []\\n        \\n        for i in range(n):\\n            while stack and strength[stack[-1]] >= strength[i]:\\n                stack.pop()\\n            # CASE 1: strength[i] is minimum across all subarrays which end at it \\n            if len(stack) == 0:\\n                min_sum[i] = ((i + 1) * strength[i]) % mod\\n                score[i] = (strength[i] * (i + 1) * prefix[i]) % mod\\n                if i > 0: \\n                    score[i] = (score[i] - strength[i] * prefix_of_prefix[i - 1]) % mod\\n            # CASE 2: s(i) is minimum across [j+1, i], ..., [i, i], but nothing before\\n            else:\\n                j = stack[-1]\\n                min_sum[i] = (min_sum[j] + (i - j) * strength[i]) % mod\\n                # subarrays [j+1, i], ..., [i, i]\\n                score[i] = (strength[i] * (i - j) * prefix[i]) % mod\\n                score[i] = (score[i] - strength[i] * prefix_of_prefix[i - 1]) % mod\\n                if j > 0:\\n                    score[i] = (score[i] + strength[i] * prefix_of_prefix[j - 1]) % mod\\n                # subarrays [0, i], ..., [j, i]\\n                score[i] = (score[i] + score[j] + min_sum[j] * (prefix[i] - prefix[j])) % mod\\n            # finally, add the new element to our monotone increasing stack\\n            stack.append(i)\\n        \\n        return sum(score) % mod\\n```",
                "solutionTags": [],
                "code": "```\\nmin(a) * sum(a)\\n```\n```\\nsum_{a in subarrays(s)} min(a) * sum(a)\\n```\n```\\nscore(i) = s(i) * prefix(i)  + s(i) * [prefix(i) - prefix(0)] + ... + s(i) * [prefix(i) - prefix(i-1)]\\n```\n```\\nprefix(i) = sum_{k = 0}^i s(k)\\n```\n```\\nscore(i) = (i + 1) * s(i) * prefix(i) - [sum_{k=0}^{i-1} prefix(k)] \\n```\n```\\ns(i) * [prefix(i) - prefix(j)] + s(i) * [prefix(i) - prefix(j + 1)] + ... + s(i) * [prefix(i) - prefix(i - 1)] =\\n(i - j) * s(i) * prefix(i) - [sum_{k = j}^{i-1} prefix(k)] \\n```\n```\\nscore(j) = m(0, j) * prefix(j) + m(1, j) * [prefix(j) - prefix(0)] + ... + m(j, j) * [prefix(j) - prefix(j - 1)]\\n```\n```\\nm(0, j) * prefix(i) + m(1, j) * [prefix(i) - prefix(0)] + ... + m(j, j) * [prefix(i) - prefix(j-1)] = \\nm(0, j) * [prefix(i) - prefix(j) + prefix(j)] + m(1, j) * [prefix(i) - prefix(j) + prefix(j) - prefix(1)] + ... + m(j, j) * [prefix(i) - prefix(j) + prefix(j) - prefix(j-1)] = \\nscore(j) + m(0, j) * [prefix(i) - prefix(j)] + m(1, j) * [prefix(i) - prefix(j)] + ... + m(j, j) * [prefix(i) - prefix(j)] = \\nscore(j) + [prefix(i) - prefix(j)] * sum_{k=0}^j m(k, j)\\n```\n```\\nscore(i) = (i - j) * s(i) * prefix(i) - [sum_{k=j}^{i-1} prefix(k)] + score(j) + [prefix(i) - prefix(j)] * sum_{k=0}^j m(k, j)\\n```\n```\\nmin_sum(i) = sum_{k=0}^i m(k, i)\\n```\n```\\nscore(i) = (i - j) * s(i) * prefix(i) - [sum_{k=j}^{i-1} prefix(k)] + score(j) + [prefix(i) - prefix(j)] * min_sum(j)\\n```\n```\\nsum_{k=j}^{i-1} prefix(k)\\n```\n```\\nprefix_of_prefix(i) = sum_{k=0}^i prefix(k) = sum_{k=0}^i [sum_{l=0}^k s(l)] \\n```\n```\\nscore(i) = \\n(i - j) * s(i) * prefix(i) - [prefix_of_prefix(i-1) - prefix_of_prefix(j-1)] + score(j) + [prefix(i) - prefix(j)] * min_sum(j) =\\n(i - j) * s(i) * prefix(i) - prefix_of_prefix(i-1) + prefix_of_prefix(j-1) + score(j) + [prefix(i) - prefix(j)] * min_sum(j)\\n```\n```\\nscore(0) + ... + score(n - 1)\\n```\n```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        n = len(strength)\\n        mod = 10 ** 9 + 7\\n        \\n        prefix = [0] * n\\n        for i in range(n):\\n            prefix[i] = prefix[i - 1] + strength[i]\\n        \\n        prefix_of_prefix = [0] * n\\n        for i in range(n):\\n            prefix_of_prefix[i] = (prefix_of_prefix[i - 1] + prefix[i]) % mod\\n        \\n        min_sum = [0] * n\\n        score = [0] * n\\n        stack = []\\n        \\n        for i in range(n):\\n            while stack and strength[stack[-1]] >= strength[i]:\\n                stack.pop()\\n            # CASE 1: strength[i] is minimum across all subarrays which end at it \\n            if len(stack) == 0:\\n                min_sum[i] = ((i + 1) * strength[i]) % mod\\n                score[i] = (strength[i] * (i + 1) * prefix[i]) % mod\\n                if i > 0: \\n                    score[i] = (score[i] - strength[i] * prefix_of_prefix[i - 1]) % mod\\n            # CASE 2: s(i) is minimum across [j+1, i], ..., [i, i], but nothing before\\n            else:\\n                j = stack[-1]\\n                min_sum[i] = (min_sum[j] + (i - j) * strength[i]) % mod\\n                # subarrays [j+1, i], ..., [i, i]\\n                score[i] = (strength[i] * (i - j) * prefix[i]) % mod\\n                score[i] = (score[i] - strength[i] * prefix_of_prefix[i - 1]) % mod\\n                if j > 0:\\n                    score[i] = (score[i] + strength[i] * prefix_of_prefix[j - 1]) % mod\\n                # subarrays [0, i], ..., [j, i]\\n                score[i] = (score[i] + score[j] + min_sum[j] * (prefix[i] - prefix[j])) % mod\\n            # finally, add the new element to our monotone increasing stack\\n            stack.append(i)\\n        \\n        return sum(score) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062288,
                "title": "c-similar-as-lc907-one-pass-o-n-two-dp-simple-solution-with-explanation",
                "content": "`minv[i]` : sum of minium value of subarrays ended at `i`\\n`dp[i]`: total sum of strengths of subarrays ended at `i`\\n`aggsum[i]`: aggregated sum of all subarrays ended at `i`\\n`sum[i]`: prefix sum ended at `i`\\n\\nWe use increasing mono stack and divide `dp[i]` into two parts: `left` , `right`\\n`left`: total strengths from minimm value at `arr[sk.back()]`\\n`right`: total strengths from current `arr[i]`\\n\\n`dp[i]` = `left` + `right`\\n`lsum`: `sum[i]-sum[sk.back()])` -> sum from `arr[sk.back()+1 ... i]`\\n`asum`: `aggsum[i]-aggsum[sk.back()]` -> aggreated sum from `arr[sk.back()+1 ... i]`\\n\\nif `arr = {1,2,3}`, then aggreated sum `aggsum[2]` = `1*1 + 2*2 + 3*3`, and `sum[2]` = `1+2+3`\\n\\n`left` = `lsum*minv[sk.back()]` + `dp[sk.back()]`\\n`right` = `(asum-lsum*(sk.back()+1))` * `arr[i]`\\n\\nNote that we make stack initialized to `-1` to avoid boundary check\\n\\nTake `arr = {3,1,2}` for example, when we at `i = 2`, \\n`left` = `dp[1] + minv[1]*lsum` = `5 + 2*2` = `9`, where` lsum = sum[2] - sum[sk.back()]`\\n`right` = `(asum - lsum * (sk.back()+1))` * `arr[2]` = `(6 - 2 - 2*2) * 2` = `4`, where `asum = aggsum[2] - aggsum[sk.back()]`\\nso `dp[2]` = `left` + `right` = `9+4` = `13`\\n```\\n        2x2\\n    1x1 1x3\\n3x3 1x4 1x6\\n```\\n\\n* `time`: `O(n)`\\n* `space`: ` O(n)`\\n\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    int totalStrength(vector<int>& arr) {\\n        int n = arr.size(), res = 0, mod = 1e9+7;\\n        vector<ll> dp(n, 0),  minv(n, 0), sum(n, 0), aggsum(n,0);\\n        vector<ll> sk = {-1};\\n        for (int i = 0; i < n; ++i) {\\n            sum[i] = (i ? sum[i-1] : 0) + arr[i];\\n            aggsum[i] = (i ? aggsum[i-1] : 0) + (ll)arr[i]*(i+1);\\n            ll asum = 0, lsum = 0;\\n            while (sk.back() != -1 && arr[sk.back()] > arr[i]) {\\n                sk.pop_back();\\n            }\\n            lsum = sum[i] - (sk.back() == -1 ? 0 : sum[sk.back()]);\\n            asum = aggsum[i] - (sk.back() == -1 ? 0 : aggsum[sk.back()]);\\n            asum -= lsum*(sk.back()+1);\\n\\t\\t\\t\\n            ll last = sk.back() == -1 ? 0 : minv[sk.back()];\\n            minv[i] = last + (i-sk.back()) * arr[i];\\n\\t\\t\\t\\n            ll left = sk.back() == -1 ? 0 : ((minv[sk.back()]%mod)*(lsum%mod)%mod+dp[sk.back()]);\\n            ll right = ((ll)arr[i]*(asum%mod))%mod;\\n            dp[i] = (left+right)%mod;\\n\\t\\t\\tres = (res+dp[i]) % mod;\\n\\t\\t\\t\\n            sk.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```\\nplease upvote if you found helpful!",
                "solutionTags": [],
                "code": "```\\n        2x2\\n    1x1 1x3\\n3x3 1x4 1x6\\n```\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    int totalStrength(vector<int>& arr) {\\n        int n = arr.size(), res = 0, mod = 1e9+7;\\n        vector<ll> dp(n, 0),  minv(n, 0), sum(n, 0), aggsum(n,0);\\n        vector<ll> sk = {-1};\\n        for (int i = 0; i < n; ++i) {\\n            sum[i] = (i ? sum[i-1] : 0) + arr[i];\\n            aggsum[i] = (i ? aggsum[i-1] : 0) + (ll)arr[i]*(i+1);\\n            ll asum = 0, lsum = 0;\\n            while (sk.back() != -1 && arr[sk.back()] > arr[i]) {\\n                sk.pop_back();\\n            }\\n            lsum = sum[i] - (sk.back() == -1 ? 0 : sum[sk.back()]);\\n            asum = aggsum[i] - (sk.back() == -1 ? 0 : aggsum[sk.back()]);\\n            asum -= lsum*(sk.back()+1);\\n\\t\\t\\t\\n            ll last = sk.back() == -1 ? 0 : minv[sk.back()];\\n            minv[i] = last + (i-sk.back()) * arr[i];\\n\\t\\t\\t\\n            ll left = sk.back() == -1 ? 0 : ((minv[sk.back()]%mod)*(lsum%mod)%mod+dp[sk.back()]);\\n            ll right = ((ll)arr[i]*(asum%mod))%mod;\\n            dp[i] = (left+right)%mod;\\n\\t\\t\\tres = (res+dp[i]) % mod;\\n\\t\\t\\t\\n            sk.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282494,
                "title": "java-single-pass-o-n-solution-reasoning-took-me-2-days",
                "content": "Code:\\n```\\nclass Solution {\\n    public int totalStrength(int[] strength) {\\n        long mod = (long)(1e9 + 7);\\n        int n = strength.length;\\n        // prefixSums[I] = sum of STR[0...I]\\n        long[] prefixSums = new long[n];\\n        /*\\n            prefix2Sums is a bit different\\n            it\\'s not a prefixSum of prefixSums\\n            \\n            but rather prefix2Sums[I] = sum of STR[I to I] + STR[I-1 to I] + STR[I-2 to I] + ... STR[0 to I]\\n            this is used in a very trickly way to compute in constant time:\\n            a special range(M, I)\\n            that is STR(M to I) + STR(M+1 to I) + ... + STR(I to I)\\n        */\\n        long[] prefix2Sums = new long[n];\\n        long sum = 0L; // for prefix arrays\\n        long ans = 0L;\\n        // contributions[I] = contribution to answer of all arrays ending at I\\n        long[] contributions = new long[n];\\n        // monotonic increase (non-decreasing) stack in terms of values of the incides \\n        Deque<Integer> indexStack = new ArrayDeque<>();\\n        long stackScore = 0L;\\n        for(int i=0; i<n; i++) {\\n            // build prefix arrays\\n            sum += strength[i];\\n            sum = sum % mod;\\n            prefixSums[i] = sum;\\n            prefix2Sums[i] = (i == 0)? strength[0] : (prefix2Sums[i-1] + (i+1)*(long)strength[i]) % mod;\\n            \\n            while(!indexStack.isEmpty() && strength[indexStack.peekLast()] > strength[i]) {\\n                // enforce monotonic and adjust stackScore\\n                int popped = indexStack.removeLast();\\n                int prevTopIndex = indexStack.isEmpty()? -1 : indexStack.peekLast();\\n                stackScore -= (((long)strength[popped])*(popped - prevTopIndex) % mod);\\n            }\\n            int lastMinIndex = indexStack.isEmpty()? -1 : indexStack.peekLast();\\n            long contributionAfterLastMinIndex = (long)(strength[i])*\\n                (prefix2Sums[i] - ((lastMinIndex == -1)? 0 : ((lastMinIndex+1)*(prefixSums[i] - prefixSums[lastMinIndex]) % mod) + prefix2Sums[lastMinIndex]));\\n            contributionAfterLastMinIndex = (contributionAfterLastMinIndex + mod) % mod;\\n            long contribution = contributionAfterLastMinIndex;\\n            if (lastMinIndex != -1) {\\n                contribution += contributions[lastMinIndex] + (stackScore*(prefixSums[i] - prefixSums[lastMinIndex]) % mod);\\n                contribution = contribution % mod;\\n            }\\n            contributions[i] = (contribution + mod) % mod;\\n            \\n            indexStack.addLast(i);\\n            stackScore += ((long)(strength[i])*(i - lastMinIndex)) % mod;\\n            stackScore = stackScore % mod;\\n            \\n            ans += contributions[i];\\n            ans = ans % mod;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\\n\\nOk so the code may be a bit hard to understand. Especially the mysterious ```stackScore``` variable I used.  So I\\'ll back up and explain the whole approach.  I\\'ll do so by several edits in parts since this will probably be very long and I can\\'t write it all down now.\\n\\nPart 1: Monotonic Stack Motivation\\nWe let ```contributions[I]``` = the contribution towards the total answer of all arrays ending at index ```I```. So question then is how do we solve for any given ```I```? OK, so there are ```I + 1``` arrays ending at ```I``` with indices: ```(0 to I)```, ```(1 to I)```,..., ```(I-1,I)```, ```(I)```. OK, so how do we determine the scores of these arrays? And is there any shared computation? Well, yes, the MIN of many of these arrays can be shared. Let\\'s say our input has a MIN_SO_FAR, ```M1```, at position ```M1I```. So our input looks like ```[strength[0],....,M1, ...strength[I]],...```. Well then, key observation is that ```M1``` is the shared min of ```M1I+1``` subarrays with indices: ```(0 to I)```, ```(1 to I)```,...```(M1I-1 to I)```, ```(M1I to I)```. Obviously every array after ```M1I``` does not contain ```M1``` so to find out any shared MINs to arrays starting to the right of ```M1I```, we\\'d have to find a new MIN. Of course, this MIN cannot be smaller then ```M1``` by definition but also because then the arrays we determined had ```M1``` as a minimum would actually have an even smaller number as the minimum, so contradiction.  This motivates the use of a monotonic stack where we store the indices of the minimums.\\n\\nIf the use of a monotic stack isn\\'t quite clear, here\\'s a quick concrete example showing the discarding nature of the monotonic stack: Say we find strength of ```5``` at ```I``` and strength of ```6``` at any ```J```, ```J < I```. OK, so ```6``` will then never be a minimum used to compute the score of any array ending at ```I```. All arrays starting at ```S``` with ```S <= J``` and ending at ```I``` include ```strength[I]```, which is less than ```strength[I-1]```, so we can discard ```I-1```.\\n\\nPart 2: Solving Ith Contribution by extending prior Contribution Motivation\\nOK so ```contributions[I]``` uses 1 or more different minimums. The minimums used are in our monotonic stack. Now sure, we could iterate over all of them and get an ```O(N^2)``` solution but what\\'s great is we can actually reuse a prior answer. When we add ```I``` to the min stack, we optionally clear out some incides until we find a number not larger than ```strength[I]```. Let\\'s say our stack looks like ```[M1I,M2I,I]``` where ```strength[M1I]```<```strength[M2I]```<```strength[I]``` once we add ```I``` to our stack. So only 3 different minimum values are used to compute ```contributions[I]```. ```strength[I]``` is used for arrays with indices: ```(I)```, ```(I-1,I)```, ```(I-2 to I)```,...,```(M2I+1 to I)```. ```strength[M2I]``` is used for arrays with indices: ```(M2I to I)```, ```(M2I-1 to I)```,...,```(M1I+1 to I)```. And finally ```strength[M1I]``` is used for arrays with indices ```(0 to I)```,...```(M1I-1 to I)```, ```(M1I to I)```.\\n\\nWell, the crucial observation is that two of these minimum numbers (```strength[M1I]```, ```strength[M2I]```) are used to compute a smaller subproblem, ```contributions[M2I]```!! So with some prefix-sum accounting work, we can derive ```contributions[I]``` from extending ```contributions[M2I]```!",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int totalStrength(int[] strength) {\\n        long mod = (long)(1e9 + 7);\\n        int n = strength.length;\\n        // prefixSums[I] = sum of STR[0...I]\\n        long[] prefixSums = new long[n];\\n        /*\\n            prefix2Sums is a bit different\\n            it\\'s not a prefixSum of prefixSums\\n            \\n            but rather prefix2Sums[I] = sum of STR[I to I] + STR[I-1 to I] + STR[I-2 to I] + ... STR[0 to I]\\n            this is used in a very trickly way to compute in constant time:\\n            a special range(M, I)\\n            that is STR(M to I) + STR(M+1 to I) + ... + STR(I to I)\\n        */\\n        long[] prefix2Sums = new long[n];\\n        long sum = 0L; // for prefix arrays\\n        long ans = 0L;\\n        // contributions[I] = contribution to answer of all arrays ending at I\\n        long[] contributions = new long[n];\\n        // monotonic increase (non-decreasing) stack in terms of values of the incides \\n        Deque<Integer> indexStack = new ArrayDeque<>();\\n        long stackScore = 0L;\\n        for(int i=0; i<n; i++) {\\n            // build prefix arrays\\n            sum += strength[i];\\n            sum = sum % mod;\\n            prefixSums[i] = sum;\\n            prefix2Sums[i] = (i == 0)? strength[0] : (prefix2Sums[i-1] + (i+1)*(long)strength[i]) % mod;\\n            \\n            while(!indexStack.isEmpty() && strength[indexStack.peekLast()] > strength[i]) {\\n                // enforce monotonic and adjust stackScore\\n                int popped = indexStack.removeLast();\\n                int prevTopIndex = indexStack.isEmpty()? -1 : indexStack.peekLast();\\n                stackScore -= (((long)strength[popped])*(popped - prevTopIndex) % mod);\\n            }\\n            int lastMinIndex = indexStack.isEmpty()? -1 : indexStack.peekLast();\\n            long contributionAfterLastMinIndex = (long)(strength[i])*\\n                (prefix2Sums[i] - ((lastMinIndex == -1)? 0 : ((lastMinIndex+1)*(prefixSums[i] - prefixSums[lastMinIndex]) % mod) + prefix2Sums[lastMinIndex]));\\n            contributionAfterLastMinIndex = (contributionAfterLastMinIndex + mod) % mod;\\n            long contribution = contributionAfterLastMinIndex;\\n            if (lastMinIndex != -1) {\\n                contribution += contributions[lastMinIndex] + (stackScore*(prefixSums[i] - prefixSums[lastMinIndex]) % mod);\\n                contribution = contribution % mod;\\n            }\\n            contributions[i] = (contribution + mod) % mod;\\n            \\n            indexStack.addLast(i);\\n            stackScore += ((long)(strength[i])*(i - lastMinIndex)) % mod;\\n            stackScore = stackScore % mod;\\n            \\n            ans += contributions[i];\\n            ans = ans % mod;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\n```stackScore```\n```contributions[I]```\n```I```\n```I```\n```I + 1```\n```I```\n```(0 to I)```\n```(1 to I)```\n```(I-1,I)```\n```(I)```\n```M1```\n```M1I```\n```[strength[0],....,M1, ...strength[I]],...```\n```M1```\n```M1I+1```\n```(0 to I)```\n```(1 to I)```\n```(M1I-1 to I)```\n```(M1I to I)```\n```M1I```\n```M1```\n```M1I```\n```M1```\n```M1```\n```5```\n```I```\n```6```\n```J```\n```J < I```\n```6```\n```I```\n```S```\n```S <= J```\n```I```\n```strength[I]```\n```strength[I-1]```\n```I-1```\n```contributions[I]```\n```O(N^2)```\n```I```\n```strength[I]```\n```[M1I,M2I,I]```\n```strength[M1I]```\n```strength[M2I]```\n```strength[I]```\n```I```\n```contributions[I]```\n```strength[I]```\n```(I)```\n```(I-1,I)```\n```(I-2 to I)```\n```(M2I+1 to I)```\n```strength[M2I]```\n```(M2I to I)```\n```(M2I-1 to I)```\n```(M1I+1 to I)```\n```strength[M1I]```\n```(0 to I)```\n```(M1I-1 to I)```\n```(M1I to I)```\n```strength[M1I]```\n```strength[M2I]```\n```contributions[M2I]```\n```contributions[I]```\n```contributions[M2I]```",
                "codeTag": "Java"
            },
            {
                "id": 2062632,
                "title": "javascript-union-find-992ms",
                "content": "```\\nfunction DJSet(n) {\\n    let parent = [], min = [], max = [];\\n    for (let i = 0; i <= n; i++) {\\n        parent.push(i);\\n        min.push(i);\\n        max.push(i);\\n    }\\n    return { find, union, L, R }\\n    function find(x) {\\n        return parent[x] == x ? x : parent[x] = find(parent[x]);\\n    }\\n    function union(x, y) {\\n        x = find(x);\\n        y = find(y);\\n        if (x == y) return false;\\n        if (parent[x] < parent[y]) [x, y] = [y, x];\\n        parent[x] += parent[y];\\n        parent[x] = y;\\n        min[y] = Math.min(min[x], min[y]);\\n        max[y] = Math.max(max[x], max[y]);\\n        return true;\\n    }\\n    function L() {\\n        return min;\\n    }\\n    function R() {\\n        return max;\\n    }\\n}\\n\\nconst ll = BigInt, mod = 1e9 + 7, bmod = ll(mod);\\nconst totalStrength = (a) => {\\n    let n = a.length, ds = new DJSet(n), id = Array(n).fill(0), sum = Array(n + 2).fill(0), vis = Array(n + 2).fill(false), res = 0n;\\n    for (let i = 0; i < n; i++) id[i] = i;\\n    id.sort((x, y) => a[y] - a[x]);\\n    for (let i = 2; i <= n + 1; i++) sum[i] = (sum[i - 1] + a[i - 2]) % mod;\\n    for (let i = 2; i <= n + 1; i++) sum[i] = (sum[i - 1] + sum[i]) % mod;\\n    for (let p of id) {\\n        p++;\\n        if (vis[p - 1]) ds.union(p, p - 1);\\n        if (vis[p + 1]) ds.union(p, p + 1);\\n        vis[p] = true;\\n        let pa = ds.find(p), l = ds.L()[pa], r = ds.R()[pa];\\n        let lcnt = ll((p - l + 1)) * ll((sum[r + 1] - sum[p]));\\n        let rcnt = ll((r - p + 1)) * ll((sum[p] - sum[l - 1]));\\n        lcnt %= bmod;\\n        rcnt %= bmod;\\n        res = (res + ll(a[p - 1]) * (lcnt - rcnt)) % bmod;\\n        res %= bmod;\\n    }\\n    res = (res + bmod) % bmod;\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find",
                    "Prefix Sum"
                ],
                "code": "```\\nfunction DJSet(n) {\\n    let parent = [], min = [], max = [];\\n    for (let i = 0; i <= n; i++) {\\n        parent.push(i);\\n        min.push(i);\\n        max.push(i);\\n    }\\n    return { find, union, L, R }\\n    function find(x) {\\n        return parent[x] == x ? x : parent[x] = find(parent[x]);\\n    }\\n    function union(x, y) {\\n        x = find(x);\\n        y = find(y);\\n        if (x == y) return false;\\n        if (parent[x] < parent[y]) [x, y] = [y, x];\\n        parent[x] += parent[y];\\n        parent[x] = y;\\n        min[y] = Math.min(min[x], min[y]);\\n        max[y] = Math.max(max[x], max[y]);\\n        return true;\\n    }\\n    function L() {\\n        return min;\\n    }\\n    function R() {\\n        return max;\\n    }\\n}\\n\\nconst ll = BigInt, mod = 1e9 + 7, bmod = ll(mod);\\nconst totalStrength = (a) => {\\n    let n = a.length, ds = new DJSet(n), id = Array(n).fill(0), sum = Array(n + 2).fill(0), vis = Array(n + 2).fill(false), res = 0n;\\n    for (let i = 0; i < n; i++) id[i] = i;\\n    id.sort((x, y) => a[y] - a[x]);\\n    for (let i = 2; i <= n + 1; i++) sum[i] = (sum[i - 1] + a[i - 2]) % mod;\\n    for (let i = 2; i <= n + 1; i++) sum[i] = (sum[i - 1] + sum[i]) % mod;\\n    for (let p of id) {\\n        p++;\\n        if (vis[p - 1]) ds.union(p, p - 1);\\n        if (vis[p + 1]) ds.union(p, p + 1);\\n        vis[p] = true;\\n        let pa = ds.find(p), l = ds.L()[pa], r = ds.R()[pa];\\n        let lcnt = ll((p - l + 1)) * ll((sum[r + 1] - sum[p]));\\n        let rcnt = ll((r - p + 1)) * ll((sum[p] - sum[l - 1]));\\n        lcnt %= bmod;\\n        rcnt %= bmod;\\n        res = (res + ll(a[p - 1]) * (lcnt - rcnt)) % bmod;\\n        res %= bmod;\\n    }\\n    res = (res + bmod) % bmod;\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2517967,
                "title": "c-dhassu-question-detailed-explained-solution-with-example-it-will-take-2-hr-atleast",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int totalStrength(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        //Brute force approach takes O(n^3) which will give TLE \\n        \\n        // So we are considering take each element as minimum ele \\n        \\n        // Findout the sum of all possible subarrys that nums[i] can be minimum \\n        \\n        // for it \\n        \\n        // For finding range for each nums[i] , till where it can be minimum \\n        \\n        // We will use Next smaller element concept based on montonic stack \\n        \\n        // Store in some array \\n        \\n          ll res=0;\\n        \\n        vector<int> left(n , -1);\\n        \\n        vector<int> right(n , n);\\n        \\n        vector<ll> psum(n+1 , 0) , prefix_psum(n+2 , 0);\\n        \\n        for(int i=0;i<n;i++ )\\n        {\\n            psum[i+1]=(nums[i]+psum[i])%mod;\\n        }\\n        \\n         for(int i=0;i<=n;i++ )\\n        {\\n            prefix_psum[i+1]=(psum[i]+prefix_psum[i])%mod;\\n        }\\n        \\n        stack<int> stk1 , stk;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            while(!stk1.empty() && nums[stk1.top()]>=nums[i])\\n            {\\n                stk1.pop();\\n            }\\n            \\n            if(!stk1.empty())\\n            {\\n                left[i]=stk1.top();\\n            }\\n            \\n            stk1.push(i);\\n        }\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!stk.empty() && nums[i]<nums[stk.top()])\\n            {\\n                stk.pop();\\n            }\\n            \\n            if(!stk.empty())\\n            {\\n                right[i]=stk.top();\\n            }\\n            \\n            stk.push(i);\\n        }\\n    \\n        // We have stored the range of for each nums[i] as minimum \\n        \\n        // [1 , 4 , 7 , 8 , 3 , 5]\\n        \\n        // left nge [0 ,1 , 2 , 3 ,1 , 5]\\n        \\n        // right nge [5 , 3 , 3 , 3 , 5 , 5]\\n        \\n        // Now we have to find the answer of element 3 as minimum \\n        \\n        // Possible subarrays will be like \\n        \\n        // [4 , 7 , 8 , 3 ] , [4 ,7 , 8 , 3 , 5] , psum[i]-psum[l-1] + psum[i+1]-psum[l-1] => psum[i] + psum[i+1] - (right[i]-i)*psum[l-1]\\n        \\n        // [ 7 , 8 , 3 ] , [7 , 8 , 3 , 5] psum[i]-psum[l] + psum[i+1]-psum[l]                => psum[i]+psum[i+1]- (right[i]-i)*psum[l]\\n        \\n        // [8 , 3 ] , [8 , 3 , 5]  psum[i]-psum[l+1] + psum[i+1]-psum[l+1]\\n        //  => psum[i]+psum[i+1]- (right[i]-i)*psum[l+1]\\n        \\n        // [3 ] , [3 , 5]  psum[i]-psum[i-1] + psum[i+1]-psum[i-1]\\n         //=> psum[i]+psum[i+1]- (right[i]-i)*psum[i-1]\\n        \\n        \\n        // Totally it can be wriiten as (i-left[i]) * (psum[i]+psum[i+1]) - \\n        //  prefix_psum[i-1]-prefix_psum[l-1] * (right[i]-i)\\n        \\n      int MOD=1e9+7;\\n        \\n        ll ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n           /* ll l=left[i];\\n            ll r=right[i];\\n            \\n            ll ans = ((prefix_psum[r+1]-prefix_psum[i+1])%mod*(i-l)%mod  + mod - ((prefix_psum[i+1] - prefix_psum[l+1])* (r-i) )%mod)%mod;\\n            \\n           \\n            \\n             ans=((ans)*nums[i])%mod;\\n            \\n            res=(res%mod + ans%mod)%mod;*/\\n            \\n            \\n             res += ((prefix_psum[right[i] + 1] - prefix_psum[i + 1]) * (i - left[i]) % MOD + MOD  - \\n               (prefix_psum[i + 1] - prefix_psum[left[i] + 1]) * (right[i] - i) % MOD) % MOD * nums[i] % MOD;\\n        res %= MOD;\\n        }\\n        \\n        return (res+MOD)%MOD;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int totalStrength(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        //Brute force approach takes O(n^3) which will give TLE \\n        \\n        // So we are considering take each element as minimum ele \\n        \\n        // Findout the sum of all possible subarrys that nums[i] can be minimum \\n        \\n        // for it \\n        \\n        // For finding range for each nums[i] , till where it can be minimum \\n        \\n        // We will use Next smaller element concept based on montonic stack \\n        \\n        // Store in some array \\n        \\n          ll res=0;\\n        \\n        vector<int> left(n , -1);\\n        \\n        vector<int> right(n , n);\\n        \\n        vector<ll> psum(n+1 , 0) , prefix_psum(n+2 , 0);\\n        \\n        for(int i=0;i<n;i++ )\\n        {\\n            psum[i+1]=(nums[i]+psum[i])%mod;\\n        }\\n        \\n         for(int i=0;i<=n;i++ )\\n        {\\n            prefix_psum[i+1]=(psum[i]+prefix_psum[i])%mod;\\n        }\\n        \\n        stack<int> stk1 , stk;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            while(!stk1.empty() && nums[stk1.top()]>=nums[i])\\n            {\\n                stk1.pop();\\n            }\\n            \\n            if(!stk1.empty())\\n            {\\n                left[i]=stk1.top();\\n            }\\n            \\n            stk1.push(i);\\n        }\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!stk.empty() && nums[i]<nums[stk.top()])\\n            {\\n                stk.pop();\\n            }\\n            \\n            if(!stk.empty())\\n            {\\n                right[i]=stk.top();\\n            }\\n            \\n            stk.push(i);\\n        }\\n    \\n        // We have stored the range of for each nums[i] as minimum \\n        \\n        // [1 , 4 , 7 , 8 , 3 , 5]\\n        \\n        // left nge [0 ,1 , 2 , 3 ,1 , 5]\\n        \\n        // right nge [5 , 3 , 3 , 3 , 5 , 5]\\n        \\n        // Now we have to find the answer of element 3 as minimum \\n        \\n        // Possible subarrays will be like \\n        \\n        // [4 , 7 , 8 , 3 ] , [4 ,7 , 8 , 3 , 5] , psum[i]-psum[l-1] + psum[i+1]-psum[l-1] => psum[i] + psum[i+1] - (right[i]-i)*psum[l-1]\\n        \\n        // [ 7 , 8 , 3 ] , [7 , 8 , 3 , 5] psum[i]-psum[l] + psum[i+1]-psum[l]                => psum[i]+psum[i+1]- (right[i]-i)*psum[l]\\n        \\n        // [8 , 3 ] , [8 , 3 , 5]  psum[i]-psum[l+1] + psum[i+1]-psum[l+1]\\n        //  => psum[i]+psum[i+1]- (right[i]-i)*psum[l+1]\\n        \\n        // [3 ] , [3 , 5]  psum[i]-psum[i-1] + psum[i+1]-psum[i-1]\\n         //=> psum[i]+psum[i+1]- (right[i]-i)*psum[i-1]\\n        \\n        \\n        // Totally it can be wriiten as (i-left[i]) * (psum[i]+psum[i+1]) - \\n        //  prefix_psum[i-1]-prefix_psum[l-1] * (right[i]-i)\\n        \\n      int MOD=1e9+7;\\n        \\n        ll ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n           /* ll l=left[i];\\n            ll r=right[i];\\n            \\n            ll ans = ((prefix_psum[r+1]-prefix_psum[i+1])%mod*(i-l)%mod  + mod - ((prefix_psum[i+1] - prefix_psum[l+1])* (r-i) )%mod)%mod;\\n            \\n           \\n            \\n             ans=((ans)*nums[i])%mod;\\n            \\n            res=(res%mod + ans%mod)%mod;*/\\n            \\n            \\n             res += ((prefix_psum[right[i] + 1] - prefix_psum[i + 1]) * (i - left[i]) % MOD + MOD  - \\n               (prefix_psum[i + 1] - prefix_psum[left[i] + 1]) * (right[i] - i) % MOD) % MOD * nums[i] % MOD;\\n        res %= MOD;\\n        }\\n        \\n        return (res+MOD)%MOD;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481669,
                "title": "java-time-o-n-space-o-n-readable-code-presumofpresum-and-nextsmaller",
                "content": "```Java\\n// time O(n) space O(n)\\nclass Solution {\\n\\tprivate static final int MOD = 1_000_000_007;\\n\\n\\tpublic int totalStrength(int[] strength) {\\n\\t\\tint n = strength.length;\\n\\t\\tlong[] preFix = preSumOfPreSum(strength);\\n\\t\\tint[] nse = nextSmallerOrEqual(strength);\\n\\t\\tint[] ps = prevSmaller(strength);\\n\\n\\t\\tlong ret = 0;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\t// ret += (long)strength[i] * \\n\\t\\t\\t//     ((preFix[nse[i]+1] - preFix[i+1])*(i-ps[i]) - \\n\\t\\t\\t//      (preFix[i+1] - preFix[ps[i]+1])*(nse[i]-i));\\n\\t\\t\\tret += strength[i] * \\n\\t\\t\\t\\tmodSubtract(modSubtract(preFix[nse[i]+1], preFix[i+1]) * (i - ps[i]) % MOD,\\n\\t\\t\\t\\t\\t\\t   modSubtract(preFix[i+1], preFix[ps[i]+1]) * (nse[i]-i) % MOD);\\n\\t\\t\\tret %= MOD;\\n\\t\\t}\\n\\n\\t\\treturn (int)ret;\\n\\t}\\n\\n\\tprivate long modSubtract(long a, long b) {\\n\\t\\tif (a < b) return a + MOD - b;\\n\\t\\treturn a - b;\\n\\t}\\n\\n\\tprivate int[] prevSmaller(int[] nums) {\\n\\t\\tint n = nums.length;\\n\\t\\tint[] ret = new int[n];\\n\\t\\tArrays.fill(ret, -1);\\n\\t\\tint min = nums[0];\\n\\t\\tfor (int i = 1; i < n; ++i) {\\n\\t\\t\\tif (nums[i] <= min) {\\n\\t\\t\\t\\tmin = nums[i];\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint j = i - 1;\\n\\t\\t\\twhile (nums[j] >= nums[i]) {\\n\\t\\t\\t\\tj = ret[j];\\n\\t\\t\\t}\\n\\t\\t\\tret[i] = j;\\n\\t\\t}\\n\\t\\treturn ret;\\n\\n\\t\\t// return new int[]{-1, 0, -1, 2};\\n\\t}\\n\\n\\tprivate int[] nextSmallerOrEqual(int[] nums) {\\n\\t\\tint n = nums.length;\\n\\t\\tint[] ret = new int[n];\\n\\t\\tArrays.fill(ret, n);\\n\\t\\tint min = nums[n-1];\\n\\t\\tfor (int i = n-2; i >= 0; --i) {\\n\\t\\t\\tif (nums[i] < min) {\\n\\t\\t\\t\\tmin = nums[i];\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint j = i + 1;\\n\\t\\t\\twhile (nums[j] > nums[i]) {\\n\\t\\t\\t\\tj = ret[j];\\n\\t\\t\\t}\\n\\t\\t\\tret[i] = j;\\n\\t\\t}\\n\\t\\treturn ret;\\n\\n\\t\\t// return new int[]{2,2,4,4};\\n\\t}\\n\\n\\tprivate long[] preSumOfPreSum(int[] nums) {\\n\\t\\tint n = nums.length;\\n\\t\\tlong[] preSum = new long[n + 1];\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tpreSum[i + 1] = preSum[i] + nums[i];\\n\\t\\t\\tpreSum[i + 1] %= MOD;\\n\\t\\t}\\n\\t\\tlong[] preSumOfPreSum = new long[n + 2];\\n\\t\\tfor (int i = 0; i < n + 1; ++i) {\\n\\t\\t\\tpreSumOfPreSum[i + 1] = preSumOfPreSum[i] + preSum[i];\\n\\t\\t\\tpreSumOfPreSum[i + 1] %= MOD;\\n\\t\\t}\\n\\t\\treturn preSumOfPreSum;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\n// time O(n) space O(n)\\nclass Solution {\\n\\tprivate static final int MOD = 1_000_000_007;\\n\\n\\tpublic int totalStrength(int[] strength) {\\n\\t\\tint n = strength.length;\\n\\t\\tlong[] preFix = preSumOfPreSum(strength);\\n\\t\\tint[] nse = nextSmallerOrEqual(strength);\\n\\t\\tint[] ps = prevSmaller(strength);\\n\\n\\t\\tlong ret = 0;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\t// ret += (long)strength[i] * \\n\\t\\t\\t//     ((preFix[nse[i]+1] - preFix[i+1])*(i-ps[i]) - \\n\\t\\t\\t//      (preFix[i+1] - preFix[ps[i]+1])*(nse[i]-i));\\n\\t\\t\\tret += strength[i] * \\n\\t\\t\\t\\tmodSubtract(modSubtract(preFix[nse[i]+1], preFix[i+1]) * (i - ps[i]) % MOD,\\n\\t\\t\\t\\t\\t\\t   modSubtract(preFix[i+1], preFix[ps[i]+1]) * (nse[i]-i) % MOD);\\n\\t\\t\\tret %= MOD;\\n\\t\\t}\\n\\n\\t\\treturn (int)ret;\\n\\t}\\n\\n\\tprivate long modSubtract(long a, long b) {\\n\\t\\tif (a < b) return a + MOD - b;\\n\\t\\treturn a - b;\\n\\t}\\n\\n\\tprivate int[] prevSmaller(int[] nums) {\\n\\t\\tint n = nums.length;\\n\\t\\tint[] ret = new int[n];\\n\\t\\tArrays.fill(ret, -1);\\n\\t\\tint min = nums[0];\\n\\t\\tfor (int i = 1; i < n; ++i) {\\n\\t\\t\\tif (nums[i] <= min) {\\n\\t\\t\\t\\tmin = nums[i];\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint j = i - 1;\\n\\t\\t\\twhile (nums[j] >= nums[i]) {\\n\\t\\t\\t\\tj = ret[j];\\n\\t\\t\\t}\\n\\t\\t\\tret[i] = j;\\n\\t\\t}\\n\\t\\treturn ret;\\n\\n\\t\\t// return new int[]{-1, 0, -1, 2};\\n\\t}\\n\\n\\tprivate int[] nextSmallerOrEqual(int[] nums) {\\n\\t\\tint n = nums.length;\\n\\t\\tint[] ret = new int[n];\\n\\t\\tArrays.fill(ret, n);\\n\\t\\tint min = nums[n-1];\\n\\t\\tfor (int i = n-2; i >= 0; --i) {\\n\\t\\t\\tif (nums[i] < min) {\\n\\t\\t\\t\\tmin = nums[i];\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint j = i + 1;\\n\\t\\t\\twhile (nums[j] > nums[i]) {\\n\\t\\t\\t\\tj = ret[j];\\n\\t\\t\\t}\\n\\t\\t\\tret[i] = j;\\n\\t\\t}\\n\\t\\treturn ret;\\n\\n\\t\\t// return new int[]{2,2,4,4};\\n\\t}\\n\\n\\tprivate long[] preSumOfPreSum(int[] nums) {\\n\\t\\tint n = nums.length;\\n\\t\\tlong[] preSum = new long[n + 1];\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tpreSum[i + 1] = preSum[i] + nums[i];\\n\\t\\t\\tpreSum[i + 1] %= MOD;\\n\\t\\t}\\n\\t\\tlong[] preSumOfPreSum = new long[n + 2];\\n\\t\\tfor (int i = 0; i < n + 1; ++i) {\\n\\t\\t\\tpreSumOfPreSum[i + 1] = preSumOfPreSum[i] + preSum[i];\\n\\t\\t\\tpreSumOfPreSum[i + 1] %= MOD;\\n\\t\\t}\\n\\t\\treturn preSumOfPreSum;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2150020,
                "title": "c-o-n-monotonic-stack-one-pass",
                "content": "the basic idea is similiar to  **907. Sum of Subarray Minimums** and **2104. Sum of Subarray Ranges**\\ncheck my solutions for those 2 problems \\nhttps://leetcode.com/problems/sum-of-subarray-minimums/discuss/2145071/c-on-time-o1-space-monotonic-stack-step-by-step-explanation\\nhttps://leetcode.com/problems/sum-of-subarray-ranges/discuss/2149253/c-on-time-2-stacks-solution\\n\\n\\tdont ask me about the details about this solution. I don\\'t even know how I got this. It took me a whole day to figure it out and my brain was about to explode. \\n\\nbasically, we need to store the **prefix sum of prefix sum** to avoid TLE. \\nAn O(n^2) monotonic stack solution is relatively easy to come up with. \\nit is the hardest to figure out a mathematical pattern of the prefix sum of prefix sum.\\n\\n```\\nint totalStrength(vector<int>& arr) {\\n        stack<int> s;\\n        vector<long long> p(arr.size()+1);\\n        vector<long long> pp(arr.size()+1);\\n        p[0] = 0;\\n        p[1] = arr[0];\\n        pp[0] = 0;\\n        pp[1] = arr[0];\\n        for(int i=1; i<arr.size(); i++){\\n            p[i+1] = p[i]+arr[i];\\n            pp[i+1] = pp[i]+p[i+1];\\n        }\\n        s.push(-1);\\n        s.push(0);\\n        int top;\\n        int res = 0;\\n        int w,h,cur;\\n        long long val,sum;\\n        int m = 1000000007;\\n        for(int i=1; i<=arr.size(); i++){\\n            cur = i==arr.size() ? -1:arr[i];\\n            while(s.top()!=-1&&cur<=arr[s.top()]){\\n                top = s.top();\\n                s.pop();\\n                w = i-top;\\n                h = top-s.top();\\n                int x = top>h ? top-h:0;\\n\\t\\t\\t\\t// this is the trickiest part!!! \\n                sum = w==1&&h==1 ? arr[top]:(h*((pp[i]-pp[top])%m)-w*((pp[top]-pp[x])%m))%m;\\n                if(sum<0) sum += m;\\n                val = (sum*arr[top])%m;\\n                res = (res+val)%m;\\n            }\\n            s.push(i);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint totalStrength(vector<int>& arr) {\\n        stack<int> s;\\n        vector<long long> p(arr.size()+1);\\n        vector<long long> pp(arr.size()+1);\\n        p[0] = 0;\\n        p[1] = arr[0];\\n        pp[0] = 0;\\n        pp[1] = arr[0];\\n        for(int i=1; i<arr.size(); i++){\\n            p[i+1] = p[i]+arr[i];\\n            pp[i+1] = pp[i]+p[i+1];\\n        }\\n        s.push(-1);\\n        s.push(0);\\n        int top;\\n        int res = 0;\\n        int w,h,cur;\\n        long long val,sum;\\n        int m = 1000000007;\\n        for(int i=1; i<=arr.size(); i++){\\n            cur = i==arr.size() ? -1:arr[i];\\n            while(s.top()!=-1&&cur<=arr[s.top()]){\\n                top = s.top();\\n                s.pop();\\n                w = i-top;\\n                h = top-s.top();\\n                int x = top>h ? top-h:0;\\n\\t\\t\\t\\t// this is the trickiest part!!! \\n                sum = w==1&&h==1 ? arr[top]:(h*((pp[i]-pp[top])%m)-w*((pp[top]-pp[x])%m))%m;\\n                if(sum<0) sum += m;\\n                val = (sum*arr[top])%m;\\n                res = (res+val)%m;\\n            }\\n            s.push(i);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2079666,
                "title": "python-go-prefix-sum-and-monostack-explained-w-proof-o-n",
                "content": "*Python* solution\\n\\n```python\\ndef totalStrength(self, strength):\\n    res, S, A = 0, [0], [0] + strength + [0]                           # O(N)\\n    P = list(itertools.accumulate(itertools.accumulate(A), initial=0)) # O(N)\\n    for r in range(len(A)):                                            # O(N)\\n        while A[S[-1]] > A[r]:                                         # O(1) amortized\\n            l, i = S[-2], S.pop()\\n            res += A[i] * ((i - l) * (P[r] - P[i]) - (r - i) * (P[i] - P[l]))\\n        S.append(r)\\n    return res % (10 ** 9 + 7)\\n```\\n\\nThe techniques regarding *prefix sum and monostack* come to our minds respectively, when we see the problem involves to count the sums and find the minimums of the subarrays. \\n\\nTo calculate the sum of the products between the sums and the minimums of all the subarrays, we can iterate over the whole array, and thus *center on each element*, which is supposed to be *the minimum of any inclusive subarray*, where all the elements on the left are non-smaller and on the right larger than it.\\n\\nUltimately, let\\'s write down the math proof for developing our intution to the faithful  solution as follows,\\n\\n*A* denotes *doable array* that stuffs beignning and end of *strength array* zeros;\\n*p* denotes *prefix sum array of A*;\\n*P* denotes *pefix sum array* initialized with zero of *p*;\\n*S* denotes *monostack* initialied with zero and stores indices of non-descending elements from *A*;\\n*f* denotes *operations* on stored elements from *S* against the incoming element from *A*;\\n*n* denotes *length of A*;\\n*i* denotes *index of minimum* of all current subarrays centered on *A[i]*;\\n*l* denotes *index before leftmost* of all current subarrays centered on *A[i]*;\\n*r* denotes *index after rightmost* of all current subarrays centered on *A[i]*;\\n\\n![image](https://assets.leetcode.com/users/images/2e0bec25-1145-4d76-8f59-4ceabee1e330_1653959344.3350306.png)\\n\\n*Go* solution\\n\\n```go\\ntype stack []int\\n\\nfunc (s *stack) pop() int {\\n\\tvar (\\n\\t\\ti = len(*s) - 1\\n\\t\\tx = (*s)[i]\\n\\t)\\n\\t*s = (*s)[:i]\\n\\treturn x\\n}\\nfunc (s stack) top() int { return s[len(s)-1] }\\nfunc (s *stack) push(x int) { *s = append(*s, x) }\\nfunc (s stack) empty_unused() bool { return len(s)  == 0 }\\n\\nfunc totalStrength(strength []int) int {\\n\\tvar (\\n\\t\\tmod = int64(1000000007)\\n\\t\\tres int64\\n\\t\\tS   = stack{0}\\n\\t\\tp   int64\\n\\t\\tP   = []int64{0}\\n\\t\\tA   = make([]int, len(strength)+2)\\n\\t\\tn   = len(A)\\n\\t)\\n\\tcopy(A[1:n-1], strength)\\n\\n\\tfor r := 0; r < n; r++ {\\n\\t\\tp += int64(A[r])\\n\\t\\tP = append(P, (P[len(P)-1]+p)%mod)\\n\\t\\tfor A[S.top()] > A[r] {\\n\\t\\t\\ti := S.pop()\\n\\t\\t\\tl := S.top()\\n\\t\\t\\tres = (res + int64(A[i])*((int64(i-l)*(P[r]-P[i])-int64(r-i)*(P[i]-P[l]))%mod+mod)) % mod\\n\\t\\t}\\n\\t\\tS.push(r)\\n\\t}\\n\\treturn int(res)\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```python\\ndef totalStrength(self, strength):\\n    res, S, A = 0, [0], [0] + strength + [0]                           # O(N)\\n    P = list(itertools.accumulate(itertools.accumulate(A), initial=0)) # O(N)\\n    for r in range(len(A)):                                            # O(N)\\n        while A[S[-1]] > A[r]:                                         # O(1) amortized\\n            l, i = S[-2], S.pop()\\n            res += A[i] * ((i - l) * (P[r] - P[i]) - (r - i) * (P[i] - P[l]))\\n        S.append(r)\\n    return res % (10 ** 9 + 7)\\n```\n```go\\ntype stack []int\\n\\nfunc (s *stack) pop() int {\\n\\tvar (\\n\\t\\ti = len(*s) - 1\\n\\t\\tx = (*s)[i]\\n\\t)\\n\\t*s = (*s)[:i]\\n\\treturn x\\n}\\nfunc (s stack) top() int { return s[len(s)-1] }\\nfunc (s *stack) push(x int) { *s = append(*s, x) }\\nfunc (s stack) empty_unused() bool { return len(s)  == 0 }\\n\\nfunc totalStrength(strength []int) int {\\n\\tvar (\\n\\t\\tmod = int64(1000000007)\\n\\t\\tres int64\\n\\t\\tS   = stack{0}\\n\\t\\tp   int64\\n\\t\\tP   = []int64{0}\\n\\t\\tA   = make([]int, len(strength)+2)\\n\\t\\tn   = len(A)\\n\\t)\\n\\tcopy(A[1:n-1], strength)\\n\\n\\tfor r := 0; r < n; r++ {\\n\\t\\tp += int64(A[r])\\n\\t\\tP = append(P, (P[len(P)-1]+p)%mod)\\n\\t\\tfor A[S.top()] > A[r] {\\n\\t\\t\\ti := S.pop()\\n\\t\\t\\tl := S.top()\\n\\t\\t\\tres = (res + int64(A[i])*((int64(i-l)*(P[r]-P[i])-int64(r-i)*(P[i]-P[l]))%mod+mod)) % mod\\n\\t\\t}\\n\\t\\tS.push(r)\\n\\t}\\n\\treturn int(res)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2064445,
                "title": "java-tc-o-n-sc-o-n-detail-explanation-64ms-faster-than-100",
                "content": "It\\'s very intuitive to understand the monotonic stack part. The hardest part is to understand how to count the sum which min need multiple to:\\nLet\\'s take [a2 **a3** a4 a5] sub array as example, a3 is the minimum number within the subarray.\\nGet Left Sum: (inclusive min index)\\n    6 a6\\n    5 a6 a5\\n    4 a6 a5 a4 \\n    3 <s>a6 a5 a4</s>|a3\\n    2 <s>a6 a5 a4</s>|a3 a2|\\n    1 a6 a5 a4 a3 a2 a1\\n    0 a6 a5 a4 a3 a2 a1 a0\\n    postSum = each row\\n    postPostSum = sum(each row) = area\\'s sum\\n    then we need the following area\\'s sum\\n    a3\\n    a3 a2\\n    start index = 1, end index = 3\\nSo it\\'s (postPostSum[start + 1] - postPostSum[end + 1] - postSum[end + 1] * (end - start))\\n\\nGet right Sum: (exclusive min index)\\n    0 a0\\n    1 a0 a1\\n    2 a0 a1 a2\\n    3 a0 a1 a2 a3\\n    4 <s>a0 a1 a2 a3</s> |a4|\\n    5 <s>a0 a1 a2 a3</s> |a4 a5|\\n    6 a0 a1 a2 a3 a4 a5 a6\\n    preSum = each row\\n    prePreSum = sum(each row) = area\\'s sum\\n    then we need the following areas\\' sum    \\n    a4\\n    a4 a5\\nSo it\\'s (prePreSum[end - 1] - prePreSum[start - 1] - preSum[start - 1] * (end - start))\\nThen getCurrentSum(int min, int start, int i, int end) is \\n( a2 ( **a3** ) a4 ) a5 )\\nleft = getLeftCount(start, i) * (end - i); because getLeftCount(start, i) appears (end - i) times, \") a4 ) a5 )\" has end - i closing parentheses.\\nright = getRightCount(i + 1, end) * (i - start); because getRightCount(i + 1, end) appears (i - start) times, \"( a2 (\" has i - start open parentheses.\\nFinally we need to add **min * (left + right)** for each i in the array to the final result.\\n  \\n```\\nclass Solution {\\n    final int mod = (int)1e9 + 7;\\n    long[] preSum;\\n    long[] prePreSum;\\n    long[] postSum;\\n    long[] postPostSum;   \\n    public int totalStrength(int[] nums) {\\n        int n = nums.length;\\n        long sum = 0;        \\n        setPreAndPostSum(n, nums);\\n        int[] monotonicStack = new int[n];\\n        int top = -1;\\n        for (int i = 0; i <= nums.length; i++) {\\n            while (top != -1 && (i == nums.length || nums[monotonicStack[top]] >= nums[i])) {\\n                int middle = monotonicStack[top--];\\n                int left = top == -1 ? -1 : monotonicStack[top];\\n                sum += getCurrentSum(nums[middle], left, middle, i);\\n            }\\n            if (i < nums.length) {\\n                monotonicStack[++top] = i;\\n            }\\n        }\\n        return (int)(sum % mod);\\n    }\\t\\n    private void setPreAndPostSum(int n, int[] nums) {\\n        preSum = new long[n];\\n        prePreSum = new long[n];\\n        postSum = new long[n];\\n        postPostSum = new long[n];\\n        for(int i = 0; i < n; i++) {\\n            preSum[i] += (i == 0 ? 0 : preSum[i - 1]) + nums[i];        \\n            prePreSum[i] += (i == 0 ? 0 : prePreSum[i - 1]) + preSum[i];\\n            int j = n - 1 - i;\\n            postSum[j] += (j == n - 1 ? 0 : postSum[j + 1]) + nums[j];\\n            postPostSum[j] += (j == n - 1 ? 0 : postPostSum[j + 1]) + postSum[j];                      \\n        }\\n    }\\n    private long getRightCount(int start, int end) {\\n        if (start == 0) return prePreSum[end - 1];\\n        return (prePreSum[end - 1] - prePreSum[start - 1] - preSum[start - 1] * (end - start)) % mod;\\n    }\\n\\n    private long getLeftCount(int start, int end) {\\n        if (end == postPostSum.length - 1) return postPostSum[start + 1];\\n        return (postPostSum[start + 1] - postPostSum[end + 1] - postSum[end + 1] * (end - start)) % mod;\\n    }\\n    /*\\n    left includes current val, right does not include current value\\n    */\\n    private long getCurrentSum(int min, int start, int i, int end) {\\n        long left = getLeftCount(start, i) * (end - i) % mod;\\n        long right = getRightCount(i + 1, end) * (i - start) % mod;\\n        return min * (left + right) % mod;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    final int mod = (int)1e9 + 7;\\n    long[] preSum;\\n    long[] prePreSum;\\n    long[] postSum;\\n    long[] postPostSum;   \\n    public int totalStrength(int[] nums) {\\n        int n = nums.length;\\n        long sum = 0;        \\n        setPreAndPostSum(n, nums);\\n        int[] monotonicStack = new int[n];\\n        int top = -1;\\n        for (int i = 0; i <= nums.length; i++) {\\n            while (top != -1 && (i == nums.length || nums[monotonicStack[top]] >= nums[i])) {\\n                int middle = monotonicStack[top--];\\n                int left = top == -1 ? -1 : monotonicStack[top];\\n                sum += getCurrentSum(nums[middle], left, middle, i);\\n            }\\n            if (i < nums.length) {\\n                monotonicStack[++top] = i;\\n            }\\n        }\\n        return (int)(sum % mod);\\n    }\\t\\n    private void setPreAndPostSum(int n, int[] nums) {\\n        preSum = new long[n];\\n        prePreSum = new long[n];\\n        postSum = new long[n];\\n        postPostSum = new long[n];\\n        for(int i = 0; i < n; i++) {\\n            preSum[i] += (i == 0 ? 0 : preSum[i - 1]) + nums[i];        \\n            prePreSum[i] += (i == 0 ? 0 : prePreSum[i - 1]) + preSum[i];\\n            int j = n - 1 - i;\\n            postSum[j] += (j == n - 1 ? 0 : postSum[j + 1]) + nums[j];\\n            postPostSum[j] += (j == n - 1 ? 0 : postPostSum[j + 1]) + postSum[j];                      \\n        }\\n    }\\n    private long getRightCount(int start, int end) {\\n        if (start == 0) return prePreSum[end - 1];\\n        return (prePreSum[end - 1] - prePreSum[start - 1] - preSum[start - 1] * (end - start)) % mod;\\n    }\\n\\n    private long getLeftCount(int start, int end) {\\n        if (end == postPostSum.length - 1) return postPostSum[start + 1];\\n        return (postPostSum[start + 1] - postPostSum[end + 1] - postSum[end + 1] * (end - start)) % mod;\\n    }\\n    /*\\n    left includes current val, right does not include current value\\n    */\\n    private long getCurrentSum(int min, int start, int i, int end) {\\n        long left = getLeftCount(start, i) * (end - i) % mod;\\n        long right = getRightCount(i + 1, end) * (i - start) % mod;\\n        return min * (left + right) % mod;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062058,
                "title": "simple-logic-with-1-pass-prefix-sums-can-be-calculated-in-the-same-loop",
                "content": "Just like the largest rectange in a histogram problem we will consider all the contributions of the **weakest wizard**\\n\\nTo get the limits of a wizard contribution we have to get the **left and right limits** within which he is the weakest wizard (excluding left and right)\\n\\nNow,  we have **left......cur.......right**\\nWe can place a open bracket anywhere b/w left and cur\\nAnd a close bracket anywhere b/w cur and right\\n\\n**NOTE** p[i] denotes prefix sum from 0....i, pp[i] denotes **prefix prefix sum** from 0 to i\\n\\nLets look at the contribution when the left bracket is fixed\\n**strength[cur] * ( p[right - 1] - p[left] + p[right - 2] - p[left] + .... p[cur] - p[left])\\nstrength[cur] * ( p[right - 1] + p[right - 2]....+ p[cur]  - p[left] * (right - 1 - cur + 1))\\nstrength[cur] * ( pp[right - 1] - pp[cur - 1] - p[left] * (right - cur))**\\n\\nNow, lets all the terms for different lefts\\n* **strength[cur] * ( pp[right - 1] - pp[cur - 1] - p[left] * (right - cur))**\\n* **strength[cur] * ( pp[right - 1] - pp[cur - 1] - p[left + 1] * (right - cur))**\\n* **.**\\n* **.**\\n* **strength[cur] * ( pp[right - 1] - pp[cur - 1] - p[cur - 1] * (right - cur))**\\n\\nWe get \\n**strength[cur] * ( (pp[right - 1] - pp[cur - 1] ) * (cur - 1 - left + 1) - (p[left] + p[left + 1] + ... p[cur - 1]) * (right - cur)\\nstrength[cur] * ( (pp[right - 1] - pp[cur - 1] ) * (cur - left) - (pp[cur - 1] - pp[left - 1])**\\n\\n```\\nclass Solution {\\n#define ll long long\\npublic:\\n    int totalStrength(vector<int>& stren) {\\n        int n = (int)stren.size();\\n        vector<ll> p1(n, 0), p2(n, 0); // prefix sum and prefix prefix sum\\n        ll mod = 1e9 + 7, ans = 0;\\n        p2[0] = p1[0] = stren[0];\\n        for (int i = 1; i < n; i++) {\\n            p1[i] = p1[i - 1] + stren[i];\\n            p2[i] = p2[i - 1] + p1[i];\\n        }\\n        stack<ll> s; // calculate the contribution for the weakest wizard, we will need the left and right weaker wizards indices. Hence, monotonic stack\\n        for (int i = 0; i < n; i++) {\\n            while (!s.empty() && stren[s.top()] >= stren[i]) {\\n                ll cur = s.top();\\n                s.pop();\\n                ll left = -1;\\n                if (!s.empty()) left = s.top();\\n                ll right = i;\\n                ll pr = right > 0 ? p2[right - 1] : 0;\\n                ll pl = left > 0 ? p2[left - 1] : 0;\\n                ll pcur = cur > 0 ? p2[cur - 1] : 0;\\n                ll t1 = (pr - pcur) % mod;\\n                ll t2 = cur - left;\\n                ll t3 = right - cur;\\n                ll t4 = (pcur - pl) % mod;\\n                ll cal = stren[cur] * ((t1 * t2 - t3 * t4 + 100000 * mod) % mod);\\n                ans += cal;\\n                ans %= mod;\\n            }\\n            s.push(i);\\n        }\\n        // for all wizards which had no weaker wizard to their right\\n        while (!s.empty()) {\\n            ll cur = s.top();\\n            s.pop();\\n            ll left = -1;\\n            if (!s.empty()) left = s.top();\\n            ll right = n;\\n            ll pr = right > 0 ? p2[right - 1] : 0;\\n            ll pl = left > 0 ? p2[left - 1] : 0;\\n            ll pcur = cur > 0 ? p2[cur - 1] : 0;\\n            ll t1 = (pr - pcur) % mod;\\n            ll t2 = cur - left;\\n            ll t3 = right - cur;\\n            ll t4 = (pcur - pl) % mod;\\n            ll cal = stren[cur] * ((t1 * t2 - t3 * t4 + 100000 * mod) % mod);\\n            ans += cal;\\n            ans %= mod;\\n        }\\n        return ans;            \\n    }\\n};\\n```\\n**Please upvote it found helpful!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n#define ll long long\\npublic:\\n    int totalStrength(vector<int>& stren) {\\n        int n = (int)stren.size();\\n        vector<ll> p1(n, 0), p2(n, 0); // prefix sum and prefix prefix sum\\n        ll mod = 1e9 + 7, ans = 0;\\n        p2[0] = p1[0] = stren[0];\\n        for (int i = 1; i < n; i++) {\\n            p1[i] = p1[i - 1] + stren[i];\\n            p2[i] = p2[i - 1] + p1[i];\\n        }\\n        stack<ll> s; // calculate the contribution for the weakest wizard, we will need the left and right weaker wizards indices. Hence, monotonic stack\\n        for (int i = 0; i < n; i++) {\\n            while (!s.empty() && stren[s.top()] >= stren[i]) {\\n                ll cur = s.top();\\n                s.pop();\\n                ll left = -1;\\n                if (!s.empty()) left = s.top();\\n                ll right = i;\\n                ll pr = right > 0 ? p2[right - 1] : 0;\\n                ll pl = left > 0 ? p2[left - 1] : 0;\\n                ll pcur = cur > 0 ? p2[cur - 1] : 0;\\n                ll t1 = (pr - pcur) % mod;\\n                ll t2 = cur - left;\\n                ll t3 = right - cur;\\n                ll t4 = (pcur - pl) % mod;\\n                ll cal = stren[cur] * ((t1 * t2 - t3 * t4 + 100000 * mod) % mod);\\n                ans += cal;\\n                ans %= mod;\\n            }\\n            s.push(i);\\n        }\\n        // for all wizards which had no weaker wizard to their right\\n        while (!s.empty()) {\\n            ll cur = s.top();\\n            s.pop();\\n            ll left = -1;\\n            if (!s.empty()) left = s.top();\\n            ll right = n;\\n            ll pr = right > 0 ? p2[right - 1] : 0;\\n            ll pl = left > 0 ? p2[left - 1] : 0;\\n            ll pcur = cur > 0 ? p2[cur - 1] : 0;\\n            ll t1 = (pr - pcur) % mod;\\n            ll t2 = cur - left;\\n            ll t3 = right - cur;\\n            ll t4 = (pcur - pl) % mod;\\n            ll cal = stren[cur] * ((t1 * t2 - t3 * t4 + 100000 * mod) % mod);\\n            ans += cal;\\n            ans %= mod;\\n        }\\n        return ans;            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062033,
                "title": "perfect-use-of-monotonic-stack-1e9-7-c-solution",
                "content": "```\\nconst long long mod = 1e9+7;\\nclass Solution {\\npublic:\\n   int totalStrength(vector<int>& s) {\\n    long long res = 0, size = s.size();\\n    vector<int> first1(size + 1), last1(size + 1),first2(size + 1), last2(size + 1),st; \\n    for (long long i = 0; i < size; i++) \\n        first1[i + 1] = (first1[i] + s[i]) % mod, last1[i + 1] = (last1[i] + (i + 1) * s[i]) % mod;\\n    for (int i = size - 1; i >= 0; i--) \\n        first2[i] = (first2[i + 1] + s[i]) % mod, last2[i] = (last2[i + 1] + (size - i) * s[i]) % mod; \\n    for (int start = 0; start <= size; start++) {\\n        while(!st.empty() && (start == size || s[st.back()] >= s[start])) {\\n            int top_last = st.back();\\n            st.pop_back();\\n\\t\\t\\tlong long left;\\n\\t\\t\\tif(st.empty()) left = 0;\\n\\t\\t\\telse left = st.back()+1;\\n            long long sum_of_left = (mod + last1[top_last + 1] - last1[left] - left * (first1[top_last + 1] - first1[left]) % mod) % mod;\\n            long long sum_of_right = (mod + last2[top_last + 1] - last2[start] - (size - start) * (first2[top_last + 1] - first2[start])) % mod;\\n            long long sum_of_all = (sum_of_right * (top_last - left + 1) + sum_of_left * (start - top_last)) % mod;\\n            //res += (sum_of_all * s[top_last]) % mod;\\n\\t\\t\\tres = (res+sum_of_all * s[top_last]) % mod;\\n        }\\n        st.push_back(start);\\n    }\\n    return res;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\nconst long long mod = 1e9+7;\\nclass Solution {\\npublic:\\n   int totalStrength(vector<int>& s) {\\n    long long res = 0, size = s.size();\\n    vector<int> first1(size + 1), last1(size + 1),first2(size + 1), last2(size + 1),st; \\n    for (long long i = 0; i < size; i++) \\n        first1[i + 1] = (first1[i] + s[i]) % mod, last1[i + 1] = (last1[i] + (i + 1) * s[i]) % mod;\\n    for (int i = size - 1; i >= 0; i--) \\n        first2[i] = (first2[i + 1] + s[i]) % mod, last2[i] = (last2[i + 1] + (size - i) * s[i]) % mod; \\n    for (int start = 0; start <= size; start++) {\\n        while(!st.empty() && (start == size || s[st.back()] >= s[start])) {\\n            int top_last = st.back();\\n            st.pop_back();\\n\\t\\t\\tlong long left;\\n\\t\\t\\tif(st.empty()) left = 0;\\n\\t\\t\\telse left = st.back()+1;\\n            long long sum_of_left = (mod + last1[top_last + 1] - last1[left] - left * (first1[top_last + 1] - first1[left]) % mod) % mod;\\n            long long sum_of_right = (mod + last2[top_last + 1] - last2[start] - (size - start) * (first2[top_last + 1] - first2[start])) % mod;\\n            long long sum_of_all = (sum_of_right * (top_last - left + 1) + sum_of_left * (start - top_last)) % mod;\\n            //res += (sum_of_all * s[top_last]) % mod;\\n\\t\\t\\tres = (res+sum_of_all * s[top_last]) % mod;\\n        }\\n        st.push_back(start);\\n    }\\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061922,
                "title": "c-prefix-suffix-monotonic-stack",
                "content": "By using monotonic stack, we can find the range <code>[l<sub>i</sub>, r<sub>i</sub>]</code> for each index <code>i</code> such that <code>strength[i]</code> is the minimum value in it. Then we need to calculate the sum of all subarrays which contains <code>strength[i]</code> within <code>[l<sub>i</sub>, r<sub>i</sub>]</code>. \\n\\nIf we list all the subarrays, they are \\n<code>[l<sub>i</sub>, i], [l<sub>i</sub>, i + 1], ..., [l<sub>i</sub>, r<sub>i</sub>], \\n[l<sub>i</sub> + 1, i], ...,  [l<sub>i</sub> + 1, r<sub>i</sub>], \\n..., \\n[i - 1, i], ..., [i - 1, r<sub>i</sub>],\\n[i, i], ..., [i, r<sub>i</sub>]</code>.\\n\\nBy observation, we can find that on the left side of <code>strength[i]</code>, <code>strength[l<sub>i</sub>]</code> occurs <code>rn = r<sub>i</sub> - i + 1</code> times, <code>strength[l<sub>i</sub> + 1]</code> occurs <code>2 * rn</code> times, ...; while on the right side of <code>strength[i]</code>, <code>strength[r<sub>i</sub>]</code> occurs <code>ln = i - l<sub>i</sub> + 1</code> times, <code>strength[r<sub>i</sub> - 1]</code> occurs <code>2 * ln</code> times, ..... So, we only need to calculate <code>lsv = strength[l<sub>i</sub>] + 2 * strength[l<sub>i</sub> + 1] + ... + (i - l<sub>i</sub>) * strength[i - 1]</code> and <code>rsv = strength[r<sub>i</sub>] + 2 * strength[r<sub>i</sub> - 1] + ... + (r<sub>i</sub> - i + 1) * strength[i + 1]</code>. \\n\\nFor the sum of interval, we usually use prefix & suffix sum, here we use a variant of it, i.e., <code>iprefix[i] = iprefix[i - 1] + i * strength[i - 1]</code>, so that we can calculate the <code>lsv = (iprefix[i] - iprefix[l<sub>i</sub>]) - l<sub>i</sub> * (prefix[i] - prefix[l<sub>i</sub>])</code>. Similarly, we can calculate <code>rsv</code>. And the sum of subarrays within <code>[l<sub>i</sub>, r<sub>i</sub>]</code> which contains <code>strength[i]</code> can be represented as <code>lsv * rn + rsv * ln + (ln * rn) * strength[i]</code>.\\n\\n```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& strength) {\\n        int n = strength.size();\\n        long long ans = 0, mod = 1e9 + 7;\\n        vector<long long> prefix(n + 1, 0), iprefix(n + 1, 0), isuffix(n + 1, 0);\\n        for (int i = 1; i <= n; i++)\\n        {\\n            prefix[i] = prefix[i - 1] + strength[i - 1];\\n            iprefix[i] = iprefix[i - 1] + (long long)i * (long long)strength[i - 1];\\n            isuffix[n - i] = isuffix[n - i + 1] + (long long)i * (long long)strength[n - i];\\n        }\\n        vector<int> l(n, -1), r(n, -1);\\n        stack<int> sl, sr;\\n        for (int i = 0; i < n; i++)\\n        {\\n            while (!sl.empty() && strength[sl.top()] > strength[i])\\n                sl.pop();\\n            if (sl.empty())\\n                l[i] = 0;\\n            else\\n                l[i] = sl.top() + 1;\\n            sl.push(i);\\n        }\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            while (!sr.empty() && strength[sr.top()] >= strength[i])\\n                sr.pop();\\n            if (sr.empty())\\n                r[i] = n - 1;\\n            else\\n                r[i] = sr.top() - 1;\\n            sr.push(i);\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n            int lb = l[i], rb = r[i];\\n            long long ln = i - lb + 1, rn = rb - i + 1, mv = strength[i], lsv = 0, rsv = 0, sv = 0;\\n            lsv = (iprefix[i] - iprefix[lb] - lb * (prefix[i] - prefix[lb]) + mod) % mod * rn % mod;\\n            rsv = (isuffix[i + 1] - isuffix[rb + 1] - (n - rb - 1) * (prefix[rb + 1] - prefix[i + 1]) + mod) % mod * ln % mod;\\n            sv = (lsv + rsv + (ln * rn) * (long long)strength[i]) % mod;\\n            ans = (ans + sv * mv) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& strength) {\\n        int n = strength.size();\\n        long long ans = 0, mod = 1e9 + 7;\\n        vector<long long> prefix(n + 1, 0), iprefix(n + 1, 0), isuffix(n + 1, 0);\\n        for (int i = 1; i <= n; i++)\\n        {\\n            prefix[i] = prefix[i - 1] + strength[i - 1];\\n            iprefix[i] = iprefix[i - 1] + (long long)i * (long long)strength[i - 1];\\n            isuffix[n - i] = isuffix[n - i + 1] + (long long)i * (long long)strength[n - i];\\n        }\\n        vector<int> l(n, -1), r(n, -1);\\n        stack<int> sl, sr;\\n        for (int i = 0; i < n; i++)\\n        {\\n            while (!sl.empty() && strength[sl.top()] > strength[i])\\n                sl.pop();\\n            if (sl.empty())\\n                l[i] = 0;\\n            else\\n                l[i] = sl.top() + 1;\\n            sl.push(i);\\n        }\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            while (!sr.empty() && strength[sr.top()] >= strength[i])\\n                sr.pop();\\n            if (sr.empty())\\n                r[i] = n - 1;\\n            else\\n                r[i] = sr.top() - 1;\\n            sr.push(i);\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n            int lb = l[i], rb = r[i];\\n            long long ln = i - lb + 1, rn = rb - i + 1, mv = strength[i], lsv = 0, rsv = 0, sv = 0;\\n            lsv = (iprefix[i] - iprefix[lb] - lb * (prefix[i] - prefix[lb]) + mod) % mod * rn % mod;\\n            rsv = (isuffix[i + 1] - isuffix[rb + 1] - (n - rb - 1) * (prefix[rb + 1] - prefix[i + 1]) + mod) % mod * ln % mod;\\n            sv = (lsv + rsv + (ln * rn) * (long long)strength[i]) % mod;\\n            ans = (ans + sv * mv) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735161,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& st) {\\n    long long MOD = 1\\'000\\'000\\'007;\\n    const int N = st.size();\\n    // sum of first k elements\\n    vector<long long> prefix(N + 1, 0L);\\n    for (int i = 0; i < N; ++i) {\\n        prefix[i + 1] = (prefix[i] + st[i]) % MOD;\\n    }\\n    // sum of first k prefix\\n    vector<long long> prefix_sum(N + 2, 0L);\\n    for (int i = 0; i <= N; ++i) {\\n        prefix_sum[i + 1] = (prefix_sum[i] + prefix[i]) % MOD;\\n    }\\n    \\n    // first index on the left < current st\\n    vector<int> left(N, -1);\\n    // mono increase\\n    vector<int> stack;\\n    for (int i = 0; i < N; ++i) {\\n        while (!stack.empty() && st[stack.back()] >= st[i]) {\\n            stack.pop_back();\\n        }\\n        left[i] = stack.empty() ? -1 : stack.back();\\n        stack.push_back(i);\\n    }\\n    \\n    // first index on the right <= current st\\n    vector<int> right(N, N);\\n    stack.clear();\\n    for (int i = N - 1; i >= 0; --i) {\\n        while (!stack.empty() && st[stack.back()] > st[i]) {\\n            stack.pop_back();\\n        }\\n        right[i] = stack.empty() ? N : stack.back();\\n        stack.push_back(i);\\n    }\\n    \\n    long long res = 0;\\n    for (int i = 0; i < N; ++i) {\\n        res += ((prefix_sum[right[i] + 1] - prefix_sum[i + 1]) * (i - left[i]) % MOD + MOD * 2 - \\n               (prefix_sum[i + 1] - prefix_sum[left[i] + 1]) * (right[i] - i) % MOD) % MOD * st[i] % MOD;\\n        res %= MOD;\\n    }\\n    return (int) res;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& st) {\\n    long long MOD = 1\\'000\\'000\\'007;\\n    const int N = st.size();\\n    // sum of first k elements\\n    vector<long long> prefix(N + 1, 0L);\\n    for (int i = 0; i < N; ++i) {\\n        prefix[i + 1] = (prefix[i] + st[i]) % MOD;\\n    }\\n    // sum of first k prefix\\n    vector<long long> prefix_sum(N + 2, 0L);\\n    for (int i = 0; i <= N; ++i) {\\n        prefix_sum[i + 1] = (prefix_sum[i] + prefix[i]) % MOD;\\n    }\\n    \\n    // first index on the left < current st\\n    vector<int> left(N, -1);\\n    // mono increase\\n    vector<int> stack;\\n    for (int i = 0; i < N; ++i) {\\n        while (!stack.empty() && st[stack.back()] >= st[i]) {\\n            stack.pop_back();\\n        }\\n        left[i] = stack.empty() ? -1 : stack.back();\\n        stack.push_back(i);\\n    }\\n    \\n    // first index on the right <= current st\\n    vector<int> right(N, N);\\n    stack.clear();\\n    for (int i = N - 1; i >= 0; --i) {\\n        while (!stack.empty() && st[stack.back()] > st[i]) {\\n            stack.pop_back();\\n        }\\n        right[i] = stack.empty() ? N : stack.back();\\n        stack.push_back(i);\\n    }\\n    \\n    long long res = 0;\\n    for (int i = 0; i < N; ++i) {\\n        res += ((prefix_sum[right[i] + 1] - prefix_sum[i + 1]) * (i - left[i]) % MOD + MOD * 2 - \\n               (prefix_sum[i + 1] - prefix_sum[left[i] + 1]) * (right[i] - i) % MOD) % MOD * st[i] % MOD;\\n        res %= MOD;\\n    }\\n    return (int) res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424014,
                "title": "solution-with-wrong-answer",
                "content": "Hi there,\\n\\nI got a wrong answer for input \\n`[747,812,112,1230,1426,1477,1388,976,849,1431,1885,1845,1070,1980,280,1075,232,1330,1868,1696,1361,1822,524,1899,1904,538,731,985,279,1608,1558,930,1232,1497,875,1850,1173,805,1720,33,233,330,1429,1688,281,362,1963,927,1688,256,1594,1823,743,553,1633,1898,1101,1278,717,522,1926,1451,119,1283,1016,194,780,1436,1233,710,1608,523,874,1779,1822,134,1984]`\\n\\nI guess it\\'s mod where the problem lies. My code is as follows.\\n\\n```\\nclass Solution {\\n    public int totalStrength(int[] strength) {\\n        int mod = (int) 1e9 + 7;\\n        \\n        int[] sums = new int[strength.length + 1];\\n        int sum = 0;\\n        for (int i = 0; i < strength.length; i ++) {\\n            sum %= mod;\\n            sums[i] = sum;\\n            sum += strength[i];\\n        }\\n        sum %= mod;\\n        sums[strength.length] = sum;\\n        \\n        int[] sumsums = new int[strength.length + 2];\\n        sum = 0;\\n        for (int i = 0; i < strength.length + 1; i ++) {\\n            sum %= mod;\\n            sumsums[i] = sum;\\n            sum += sums[i];\\n        }\\n        sum %= mod;\\n        sumsums[strength.length + 1] = sum;\\n        \\n        int res = 0;\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        stack.offerLast(-1);\\n        \\n        for (int i = 0; i < strength.length; i ++) {\\n            int curr = strength[i];\\n            while (stack.peekLast() != -1 && strength[stack.peekLast()] >= curr) {\\n                int polled = stack.pollLast();\\n                int next = stack.peekLast();\\n                res += ((polled - next) * (sumsums[i + 1] - sumsums[polled + 1])\\n                    - (i - polled) * (sumsums[polled + 1] - sumsums[next + 1]))\\n                    * strength[polled] % mod;\\n                res %= mod;\\n            }\\n            stack.offerLast(i);\\n        }\\n        \\n        while (stack.peekLast() != -1) {\\n            int polled = stack.pollLast();\\n            int i = strength.length;\\n            int next = stack.peekLast();\\n            res += ((polled - next) * (sumsums[i + 1] - sumsums[polled + 1])\\n                    - (i - polled) * (sumsums[polled + 1] - sumsums[next + 1]))\\n                    * strength[polled] % mod;\\n            res %= mod;\\n        }\\n        return res;\\n    }\\n    \\n}\\n```\\n\\nWhat\\'s wrong with it? Thanks :D",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int totalStrength(int[] strength) {\\n        int mod = (int) 1e9 + 7;\\n        \\n        int[] sums = new int[strength.length + 1];\\n        int sum = 0;\\n        for (int i = 0; i < strength.length; i ++) {\\n            sum %= mod;\\n            sums[i] = sum;\\n            sum += strength[i];\\n        }\\n        sum %= mod;\\n        sums[strength.length] = sum;\\n        \\n        int[] sumsums = new int[strength.length + 2];\\n        sum = 0;\\n        for (int i = 0; i < strength.length + 1; i ++) {\\n            sum %= mod;\\n            sumsums[i] = sum;\\n            sum += sums[i];\\n        }\\n        sum %= mod;\\n        sumsums[strength.length + 1] = sum;\\n        \\n        int res = 0;\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        stack.offerLast(-1);\\n        \\n        for (int i = 0; i < strength.length; i ++) {\\n            int curr = strength[i];\\n            while (stack.peekLast() != -1 && strength[stack.peekLast()] >= curr) {\\n                int polled = stack.pollLast();\\n                int next = stack.peekLast();\\n                res += ((polled - next) * (sumsums[i + 1] - sumsums[polled + 1])\\n                    - (i - polled) * (sumsums[polled + 1] - sumsums[next + 1]))\\n                    * strength[polled] % mod;\\n                res %= mod;\\n            }\\n            stack.offerLast(i);\\n        }\\n        \\n        while (stack.peekLast() != -1) {\\n            int polled = stack.pollLast();\\n            int i = strength.length;\\n            int next = stack.peekLast();\\n            res += ((polled - next) * (sumsums[i + 1] - sumsums[polled + 1])\\n                    - (i - polled) * (sumsums[polled + 1] - sumsums[next + 1]))\\n                    * strength[polled] % mod;\\n            res %= mod;\\n        }\\n        return res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373525,
                "title": "faster-than-98-90-easy-python-solution",
                "content": "![image](https://assets.leetcode.com/users/images/cfdbbf06-412c-4266-a704-86cbed3a7149_1659521357.6745205.png)\\n```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        strength = [0] + strength + [0]\\n        def calc_prefix_sum(array):\\n            if not array: return []\\n            result = [array[0]]\\n            for el in array[1:]:\\n                result.append(array[-1]+el)\\n            return result\\n        prefix_sums = calc_prefix_sum(strength)\\n        pp_sums = calc_prefix_sum(prefix_sums)\\n        stack = [0]\\n        total = 0\\n        for right in range(len(strength)):\\n            while pp_sums[stack[-1]] > pp_sums[right]:\\n                left = stack[-2]\\n                i = stack.pop()\\n                pos = (i - left) * (pp_sums[right] - pp_sums[i])\\n                neg = (right - i) * (pp_sums[i] - pp_sums[left])\\n                total += pp_sums[i] * (pos - neg)\\n                stack.push(right)\\n        return total % (10**9+7)\\n    def totalStrength(self, strength):\\n        res, S, A = 0, [0], [0] + strength + [0]                           # O(N)\\n        P = list(itertools.accumulate(itertools.accumulate(A), initial=0)) # O(N)\\n        for r in range(len(A)):                                            # O(N)\\n            while A[S[-1]] > A[r]:                                         # O(1) amortized\\n                l, i = S[-2], S.pop()\\n                res += A[i] * ((i - l) * (P[r] - P[i]) - (r - i) * (P[i] - P[l]))\\n            S.append(r)\\n        return res % (10 ** 9 + 7)\\n```\\n.code is in comment section\\n\\n```\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        strength = [0] + strength + [0]\\n        def calc_prefix_sum(array):\\n            if not array: return []\\n            result = [array[0]]\\n            for el in array[1:]:\\n                result.append(array[-1]+el)\\n            return result\\n        prefix_sums = calc_prefix_sum(strength)\\n        pp_sums = calc_prefix_sum(prefix_sums)\\n        stack = [0]\\n        total = 0\\n        for right in range(len(strength)):\\n            while pp_sums[stack[-1]] > pp_sums[right]:\\n                left = stack[-2]\\n                i = stack.pop()\\n                pos = (i - left) * (pp_sums[right] - pp_sums[i])\\n                neg = (right - i) * (pp_sums[i] - pp_sums[left])\\n                total += pp_sums[i] * (pos - neg)\\n                stack.push(right)\\n        return total % (10**9+7)\\n    def totalStrength(self, strength):\\n        res, S, A = 0, [0], [0] + strength + [0]                           # O(N)\\n        P = list(itertools.accumulate(itertools.accumulate(A), initial=0)) # O(N)\\n        for r in range(len(A)):                                            # O(N)\\n            while A[S[-1]] > A[r]:                                         # O(1) amortized\\n                l, i = S[-2], S.pop()\\n                res += A[i] * ((i - l) * (P[r] - P[i]) - (r - i) * (P[i] - P[l]))\\n            S.append(r)\\n        return res % (10 ** 9 + 7)\\n```\n```\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268290,
                "title": "alternate-solution-using-sparse-table",
                "content": "Approach , Find index m of minimum element in range (l,r) and calculate contribution of all the \\nsegments that have this index in their range in (l,r) . Now Solve the Problem recursively for (l,m-1) and (m+1,r).\\n\\nclass Solution {\\n    #define ll long long \\n    ll arr[100009];\\n    int K = 26;\\n    ll st[100009][28];\\n    int lg[100009];\\nint N;\\nvoid build(){\\n    lg[1] = 0;\\nfor (int i = 2; i <= 100003; i++)\\n    lg[i] = lg[i/2] + 1;\\n    \\nfor (int i = 0; i < N; i++)\\n    st[i][0] = arr[i];\\n\\nfor (int j = 1; j <= K; j++)\\n    for (int i = 0; i + (1 << j) <= N; i++)\\n        st[i][j] = min(st[i][j-1], st[i + (1 << (j - 1))][j - 1]);\\n}\\n    \\n    ll get_min(int L,int R){\\n    \\n    int j = lg[R - L + 1];\\nll minimum = min(st[L][j], st[R - (1 << j) + 1][j]);\\n        return minimum;\\n    }\\n    \\n    \\n    \\n    map<int,int> mp;\\n    \\n    ll mod = (ll)(1e9)+7;\\n    ll add(ll a,ll b){\\n        return (a%mod + b%mod )%mod;\\n    }\\n    ll mul(ll a,ll b){\\n        return (a%mod * b%mod)%mod;\\n    }\\n    ll sub(ll a , ll b){\\n        return (a%mod - b%mod + mod)%mod;\\n    }\\n    int wtf[100009];\\n    int wtb[100009];\\n    int pre[100009];\\n    vector<int> pos[100009];\\n    ll solve(int l,int r){\\n        if(r<l){\\n            return 0ll;\\n        }\\n        else{\\n            ll mn = get_min(l,r);\\n            auto it = lower_bound(pos[mp[mn]].begin(),pos[mp[mn]].end(),l);\\n            int m = *it;\\n            \\n            m++;\\n            l++;\\n            r++;\\n            ll frw = wtf[m-1]-wtf[l-1];\\n            ll pr = pre[m-1]-pre[l-1];\\n            ll pr2 = pre[r]-pre[m-1];\\n            ll bck = wtb[r]-wtb[m-1];\\n            m--;\\n            r--;\\n            l--;\\n            \\n            \\n            frw = sub(frw,mul(l,pr));\\n            ll cntr1 = mul(r-m+1,frw);\\n            \\n            bck = sub(bck,mul(pr2,N-r-2));\\n             ll cntr2 = mul(m-l+1,bck);\\n            ll alr = mul(mn,add(cntr1,cntr2));\\n            ll ntalr = add(solve(l,m-1),solve(m+1,r));\\n            // cout<<l<<\" \"<<r<<\" \"<<alr<<endl;\\n            return add(alr,ntalr);\\n        }\\n    }\\npublic:\\n    int totalStrength(vector<int>& s) {\\n        int n=(int)(s.size());\\n        N=n;\\n        set<int> v;\\n        for(int i=0;i<n;i++){\\n            v.insert(s[i]);\\n        }\\n        int ind=1;\\n        auto it = v.begin();\\n        \\n        while(it!=v.end()){\\n            mp[*it]=ind;\\n            ind++;\\n            it++;\\n        }\\n        for(int i=0;i<n;i++){\\n            pos[mp[s[i]]].push_back(i);\\n        }\\n        for(int i=0;i<n;i++){\\n            arr[i]=s[i];\\n        }\\n        build();\\n        pre[0]=0;\\n        wtf[0]=0;\\n        wtb[0]=0;\\n        for(int i=1;i<=n;i++){\\n            pre[i] = add(pre[i-1],s[i-1]);\\n            wtf[i] = add(wtf[i-1],mul(i,s[i-1]));\\n            wtb[i] = add(wtb[i-1],mul(n-i,s[i-1]));\\n        }\\n        return (int)(solve(0,n-1));\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    #define ll long long \\n    ll arr[100009];\\n    int K = 26;\\n    ll st[100009][28];\\n    int lg[100009];\\nint N;\\nvoid build(){\\n    lg[1] = 0;\\nfor (int i = 2; i <= 100003; i++)\\n    lg[i] = lg[i/2] + 1;\\n    \\nfor (int i = 0; i < N; i++)\\n    st[i][0] = arr[i];\\n\\nfor (int j = 1; j <= K; j++)\\n    for (int i = 0; i + (1 << j) <= N; i++)\\n        st[i][j] = min(st[i][j-1], st[i + (1 << (j - 1))][j - 1]);\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2260723,
                "title": "c-prefixsum",
                "content": "Main code from [here](https://www.youtube.com/watch?v=K31VME56L3o) with some minor modifications.\\n```csharp\\npublic int TotalStrength(int[] strength) {\\n\\tint len = strength.Length;\\n\\tlong mod =1_000_000_007;\\n\\n\\n\\tlong[] prevMin = new long[len];\\n\\tlong[] nextMin = new long[len];\\n\\tArray.Fill(nextMin, len);\\n\\tStack<(long,long)> st = new();\\n\\tfor(int i=0; i<len; i++){\\n\\t\\twhile(st.Count>0 && st.Peek().Item1>strength[i]){\\n\\t\\t\\tvar (_, j) = st.Pop();\\n\\t\\t\\tnextMin[j] = i;\\n\\t\\t}\\n\\t\\tprevMin[i] = st.Count>0?st.Peek().Item2:-1;\\n\\t\\tst.Push((strength[i],i));\\n\\t}\\n\\n\\tlong[] preSum  = new long[len+1];\\n\\tlong[] prePrefix = new long[len+2];\\n\\n\\tfor(int i=0; i<len; i++){\\n\\t\\tpreSum[i+1]=(preSum[i]+strength[i])%mod;\\n\\t}\\n\\n\\tfor(int i=0; i<=len; i++){\\n\\t\\tprePrefix[i+1]=(prePrefix[i]+preSum[i])%mod;\\n\\t}\\n\\n\\n\\tlong ans=0;\\n\\tfor(int i =0;i<len;i++){\\n\\t   ans+=(\\n\\t\\t   ((prePrefix[nextMin[i]+1] - prePrefix[i+1]) * (i-prevMin[i]) % mod)  + mod -\\n\\t\\t   ((prePrefix[i+1] - prePrefix[prevMin[i]+1]) *(nextMin[i]-i) % mod)) * strength[i]%mod;\\n\\t\\tans%=mod;\\n\\t}\\n\\n\\treturn (int)(ans%mod);\\n}\\n    \\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```csharp\\npublic int TotalStrength(int[] strength) {\\n\\tint len = strength.Length;\\n\\tlong mod =1_000_000_007;\\n\\n\\n\\tlong[] prevMin = new long[len];\\n\\tlong[] nextMin = new long[len];\\n\\tArray.Fill(nextMin, len);\\n\\tStack<(long,long)> st = new();\\n\\tfor(int i=0; i<len; i++){\\n\\t\\twhile(st.Count>0 && st.Peek().Item1>strength[i]){\\n\\t\\t\\tvar (_, j) = st.Pop();\\n\\t\\t\\tnextMin[j] = i;\\n\\t\\t}\\n\\t\\tprevMin[i] = st.Count>0?st.Peek().Item2:-1;\\n\\t\\tst.Push((strength[i],i));\\n\\t}\\n\\n\\tlong[] preSum  = new long[len+1];\\n\\tlong[] prePrefix = new long[len+2];\\n\\n\\tfor(int i=0; i<len; i++){\\n\\t\\tpreSum[i+1]=(preSum[i]+strength[i])%mod;\\n\\t}\\n\\n\\tfor(int i=0; i<=len; i++){\\n\\t\\tprePrefix[i+1]=(prePrefix[i]+preSum[i])%mod;\\n\\t}\\n\\n\\n\\tlong ans=0;\\n\\tfor(int i =0;i<len;i++){\\n\\t   ans+=(\\n\\t\\t   ((prePrefix[nextMin[i]+1] - prePrefix[i+1]) * (i-prevMin[i]) % mod)  + mod -\\n\\t\\t   ((prePrefix[i+1] - prePrefix[prevMin[i]+1]) *(nextMin[i]-i) % mod)) * strength[i]%mod;\\n\\t\\tans%=mod;\\n\\t}\\n\\n\\treturn (int)(ans%mod);\\n}\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2068305,
                "title": "python3-mono-stack",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/6660105f1044a4e4d6e382cc02819f520cedce55) for solutions of weekly 294. \\n\\n```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        ans = 0 \\n        stack = []\\n        prefix = list(accumulate(accumulate(strength), initial=0))\\n        for i, x in enumerate(strength + [0]): \\n            while stack and stack[-1][1] >= x: \\n                mid = stack.pop()[0]\\n                lo = stack[-1][0] if stack else -1 \\n                left = prefix[mid] - prefix[max(lo, 0)]\\n                right = prefix[i] - prefix[mid]\\n                ans = (ans + strength[mid]*(right*(mid-lo) - left*(i-mid))) % 1_000_000_007\\n            stack.append((i, x))\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        ans = 0 \\n        stack = []\\n        prefix = list(accumulate(accumulate(strength), initial=0))\\n        for i, x in enumerate(strength + [0]): \\n            while stack and stack[-1][1] >= x: \\n                mid = stack.pop()[0]\\n                lo = stack[-1][0] if stack else -1 \\n                left = prefix[mid] - prefix[max(lo, 0)]\\n                right = prefix[i] - prefix[mid]\\n                ans = (ans + strength[mid]*(right*(mid-lo) - left*(i-mid))) % 1_000_000_007\\n            stack.append((i, x))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064839,
                "title": "share-my-easy-understandable-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    #define MOD 1000000007\\n    int totalStrength(vector<int>& strength) {\\n        int n = strength.size();\\n        \\n        vector<long long> prefsum(n+2),suffsum(n+2);\\n        vector<long long> double_prefsum(n+2),double_suffsum(n+2);\\n        \\n        for(int i=1;i<=n;i++){\\n            prefsum[i] = (prefsum[i-1] + strength[i-1])%MOD;\\n            double_prefsum[i] = (double_prefsum[i-1] + prefsum[i])%MOD;\\n        }\\n        \\n        for(int i=n;i>=1;i--){\\n            suffsum[i] = (suffsum[i+1] + strength[i-1])%MOD;\\n            double_suffsum[i] = (double_suffsum[i+1] + suffsum[i])%MOD;\\n        }\\n        \\n        stack<int> s1,s2;\\n        vector<int> left(n,-1),right(n,n);\\n        \\n        for(int i=0;i<n;i++){\\n            while(!s1.empty() and strength[s1.top()]>=strength[i]){\\n                right[s1.top()] = i;\\n                s1.pop();\\n            }\\n            s1.push(i);\\n        }\\n        \\n        for(int i=n-1;i>=0;i--){\\n            while(!s2.empty() and strength[s2.top()]>strength[i]){\\n                left[s2.top()] = i;\\n                s2.pop();\\n            }\\n            s2.push(i);\\n        }\\n        \\n        auto queryLeftSum = [&](int l,int r){\\n            if(l>r){\\n                return 0;\\n            }\\n            \\n            long long d = r - l + 1;\\n            long long toSubtract = (d*suffsum[r+2])%MOD;\\n            \\n            long long ans = (double_suffsum[l+1] - double_suffsum[r+2] + MOD)%MOD;\\n            ans = (ans-toSubtract+MOD)%MOD;\\n            \\n            return (int)ans;\\n            \\n        };\\n        \\n        auto queryRightSum = [&](int l,int r){\\n            if(l>r){\\n                return 0;\\n            }\\n            \\n            long long d = r - l + 1;\\n            long long toSubtract = (d*prefsum[l])%MOD;\\n            \\n            long long ans = (double_prefsum[r+1] - double_prefsum[l] + MOD)%MOD;\\n            ans = (ans-toSubtract+MOD)%MOD;\\n            \\n            return (int)ans;\\n        };\\n        \\n        long long ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            long long curr_min = strength[i];\\n            int l = left[i] + 1,r = right[i] - 1;\\n            \\n            long long right_sum = queryRightSum(i+1,r);\\n            long long left_sum = queryLeftSum(l,i);\\n            \\n            long long curr_sum = (right_sum*(i-l+1))%MOD;\\n            curr_sum = (curr_sum + (left_sum*(r-i+1))%MOD)%MOD;\\n            \\n            long long curr_ans = (curr_sum*curr_min)%MOD;\\n            \\n            ans = (ans+curr_ans)%MOD;\\n        }\\n        \\n        return ans;        \\n    }\\n};\\n```\\n**Don\\'t Forget to Upvote!**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define MOD 1000000007\\n    int totalStrength(vector<int>& strength) {\\n        int n = strength.size();\\n        \\n        vector<long long> prefsum(n+2),suffsum(n+2);\\n        vector<long long> double_prefsum(n+2),double_suffsum(n+2);\\n        \\n        for(int i=1;i<=n;i++){\\n            prefsum[i] = (prefsum[i-1] + strength[i-1])%MOD;\\n            double_prefsum[i] = (double_prefsum[i-1] + prefsum[i])%MOD;\\n        }\\n        \\n        for(int i=n;i>=1;i--){\\n            suffsum[i] = (suffsum[i+1] + strength[i-1])%MOD;\\n            double_suffsum[i] = (double_suffsum[i+1] + suffsum[i])%MOD;\\n        }\\n        \\n        stack<int> s1,s2;\\n        vector<int> left(n,-1),right(n,n);\\n        \\n        for(int i=0;i<n;i++){\\n            while(!s1.empty() and strength[s1.top()]>=strength[i]){\\n                right[s1.top()] = i;\\n                s1.pop();\\n            }\\n            s1.push(i);\\n        }\\n        \\n        for(int i=n-1;i>=0;i--){\\n            while(!s2.empty() and strength[s2.top()]>strength[i]){\\n                left[s2.top()] = i;\\n                s2.pop();\\n            }\\n            s2.push(i);\\n        }\\n        \\n        auto queryLeftSum = [&](int l,int r){\\n            if(l>r){\\n                return 0;\\n            }\\n            \\n            long long d = r - l + 1;\\n            long long toSubtract = (d*suffsum[r+2])%MOD;\\n            \\n            long long ans = (double_suffsum[l+1] - double_suffsum[r+2] + MOD)%MOD;\\n            ans = (ans-toSubtract+MOD)%MOD;\\n            \\n            return (int)ans;\\n            \\n        };\\n        \\n        auto queryRightSum = [&](int l,int r){\\n            if(l>r){\\n                return 0;\\n            }\\n            \\n            long long d = r - l + 1;\\n            long long toSubtract = (d*prefsum[l])%MOD;\\n            \\n            long long ans = (double_prefsum[r+1] - double_prefsum[l] + MOD)%MOD;\\n            ans = (ans-toSubtract+MOD)%MOD;\\n            \\n            return (int)ans;\\n        };\\n        \\n        long long ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            long long curr_min = strength[i];\\n            int l = left[i] + 1,r = right[i] - 1;\\n            \\n            long long right_sum = queryRightSum(i+1,r);\\n            long long left_sum = queryLeftSum(l,i);\\n            \\n            long long curr_sum = (right_sum*(i-l+1))%MOD;\\n            curr_sum = (curr_sum + (left_sum*(r-i+1))%MOD)%MOD;\\n            \\n            long long curr_ans = (curr_sum*curr_min)%MOD;\\n            \\n            ans = (ans+curr_ans)%MOD;\\n        }\\n        \\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063437,
                "title": "fully-explained-3-approach-stack-prefix-sum-cpp-faster-than-100-00-of-c",
                "content": "Approach-1: Brute Force\\nGoing with the brute force will take O(N^3) as N^2 for finding all the subarray and N for doing the operation for min value and sum.\\nApproach-2: Optimised to O(N^2 log)\\nwe can store the min value(segment tree) and prefix sum and use it for each subarray but it will still take O(N^2).\\nApproach-3: Optimised to N\\nIntuition behind this is to fix the min element and find all the subarray sum which incudes this element.\\n\\nAlgorithm used:\\n1. calculate the presum of presum in an array(presum[k] is the sum of first k elemnt array)\\n2. find the immediate smaller number index on left side\\n3. find immediate smaller or equal munber index on right side\\n4. use pre array to find the sum of all subarry which contains ith element as min element ans multiply it with a[i].\\n\\nreturn the sum of strenght stored in ans\\n\\nPFB my code for your reference:\\n\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int Value(vector<int> a, int n){\\n        vector<long long>pre(n+2,0);\\n        for(int i=1;i<=n;i++)\\n            pre[i]=(pre[i-1]+a[i-1])%mod;\\n        for(int i=1;i<=n+1;i++)\\n            pre[i]=(pre[i-1]+pre[i])%mod;\\n        for(int i=n+1;i>0;i--)\\n            pre[i]=pre[i-1];\\n\\n        vector<int> l(n,-1),r(n,n);\\n        stack<int> st;\\n        // Find all left index\\n        for(int i = 0; i < n; i++){\\n            while (!st.empty() && a[st.top()] >= a[i])\\n                st.pop();\\n            if (!st.empty())\\n                l[i] = st.top();\\n\\n            st.push(i);\\n        }\\n\\n        while(!st.empty())\\n        st.pop();\\n\\n        // Find all right index\\n        for(int i = n - 1; i >= 0; i--){\\n            while (!st.empty() && a[st.top()] > a[i])\\n                st.pop();\\n\\n                if (!st.empty())\\n                    r[i] = st.top();\\n\\n            st.push(i);\\n        }\\n        // for(int i=0;i<n;i++) cout<<a[i]<<\" \"; cout<<\"\\\\n\";\\n        // for(int i=0;i<n;i++) cout<<l[i]<<\" \"; cout<<\"\\\\n\";\\n        // for(int i=0;i<n;i++) cout<<r[i]<<\" \"; cout<<\"\\\\n\";\\n        \\n        long long ans = 0;\\n    for (int i = 0; i < n; ++i) {\\n        ans += (((pre[r[i] + 1] - pre[i + 1]) * (i - l[i]) % mod + mod * 2 - \\n               (pre[i + 1] - pre[l[i] + 1]) * (r[i] - i) % mod) % mod * a[i]) % mod;\\n        ans %= mod;\\n    }\\n    return (int) ans;\\n\\n    }\\n    int totalStrength(vector<int>& s) {\\n        int n=s.size();\\n        return Value(s,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int Value(vector<int> a, int n){\\n        vector<long long>pre(n+2,0);\\n        for(int i=1;i<=n;i++)\\n            pre[i]=(pre[i-1]+a[i-1])%mod;\\n        for(int i=1;i<=n+1;i++)\\n            pre[i]=(pre[i-1]+pre[i])%mod;\\n        for(int i=n+1;i>0;i--)\\n            pre[i]=pre[i-1];\\n\\n        vector<int> l(n,-1),r(n,n);\\n        stack<int> st;\\n        // Find all left index\\n        for(int i = 0; i < n; i++){\\n            while (!st.empty() && a[st.top()] >= a[i])\\n                st.pop();\\n            if (!st.empty())\\n                l[i] = st.top();\\n\\n            st.push(i);\\n        }\\n\\n        while(!st.empty())\\n        st.pop();\\n\\n        // Find all right index\\n        for(int i = n - 1; i >= 0; i--){\\n            while (!st.empty() && a[st.top()] > a[i])\\n                st.pop();\\n\\n                if (!st.empty())\\n                    r[i] = st.top();\\n\\n            st.push(i);\\n        }\\n        // for(int i=0;i<n;i++) cout<<a[i]<<\" \"; cout<<\"\\\\n\";\\n        // for(int i=0;i<n;i++) cout<<l[i]<<\" \"; cout<<\"\\\\n\";\\n        // for(int i=0;i<n;i++) cout<<r[i]<<\" \"; cout<<\"\\\\n\";\\n        \\n        long long ans = 0;\\n    for (int i = 0; i < n; ++i) {\\n        ans += (((pre[r[i] + 1] - pre[i + 1]) * (i - l[i]) % mod + mod * 2 - \\n               (pre[i + 1] - pre[l[i] + 1]) * (r[i] - i) % mod) % mod * a[i]) % mod;\\n        ans %= mod;\\n    }\\n    return (int) ans;\\n\\n    }\\n    int totalStrength(vector<int>& s) {\\n        int n=s.size();\\n        return Value(s,n);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2062325,
                "title": "presums-of-presums-o-n-java",
                "content": "```\\nclass Solution\\n{\\n    private final long mod = 1_000_000_007L;\\n    \\n    public int totalStrength(int[] ss)\\n    {\\n        long stg = 0L;\\n        int n = ss.length;\\n\\t\\t// regular presums\\n        long[] presums = new long[n + 1];\\n        for (int i = 0; i < n; i++)\\n        {\\n            presums[i + 1] = presums[i] + ss[i];\\n        }\\n\\t\\t// advanced presums between presums[0] until presums[i]\\n        long[] presums2 = new long[n + 1];\\n        for (int i = 1; i <= n; i++)\\n        {\\n            presums2[i] = presums2[i - 1] + presums[i];\\n        }\\n        int[] leftSmallerIdxes = new int[n];\\n        int[] rightSmallerOrEqualIdxes = new int[n];\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        for (int i = 0; i < n; i++)\\n        {\\n            int s = ss[i];\\n            while (!deque.isEmpty() && ss[deque.peekLast()] >= s)\\n            {\\n                deque.pollLast();\\n            }\\n            leftSmallerIdxes[i] = deque.isEmpty() ? -1 : deque.peekLast();\\n            deque.addLast(i);\\n        }\\n        deque = new ArrayDeque<>();\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            int s = ss[i];\\n            while (!deque.isEmpty() && ss[deque.peekFirst()] > s)\\n            {\\n                deque.pollFirst();\\n            }\\n            rightSmallerOrEqualIdxes[i] = deque.isEmpty() ? n : deque.peekFirst();\\n            deque.addFirst(i);\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n            long sum = 0;\\n            int leftSmallerIdx = leftSmallerIdxes[i];\\n            int leftCount = i - (leftSmallerIdx + 1);\\n            long leftSum = (i == 0 ? 0 : (leftCount * presums[i] - (presums2[i - 1] - (leftSmallerIdx < 0 ? 0 : presums2[leftSmallerIdx])))) % mod;\\n            int rightSmallerOrEqualIdx = rightSmallerOrEqualIdxes[i];\\n            int rightCount = rightSmallerOrEqualIdx - (i + 1);\\n            long rightSum = (presums2[rightSmallerOrEqualIdx] - presums2[i + 1] - rightCount * presums[i + 1]) % mod;\\n            sum += (leftSum * (rightCount + 1) + rightSum * (leftCount + 1)) % mod;\\n            sum += (long)ss[i] * (long)(leftCount + 1) * (long)(rightCount + 1) % mod;\\n            stg += (long)ss[i] * sum % mod;\\n            stg %= mod;\\n        }\\n        return (int)stg;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    private final long mod = 1_000_000_007L;\\n    \\n    public int totalStrength(int[] ss)\\n    {\\n        long stg = 0L;\\n        int n = ss.length;\\n\\t\\t// regular presums\\n        long[] presums = new long[n + 1];\\n        for (int i = 0; i < n; i++)\\n        {\\n            presums[i + 1] = presums[i] + ss[i];\\n        }\\n\\t\\t// advanced presums between presums[0] until presums[i]\\n        long[] presums2 = new long[n + 1];\\n        for (int i = 1; i <= n; i++)\\n        {\\n            presums2[i] = presums2[i - 1] + presums[i];\\n        }\\n        int[] leftSmallerIdxes = new int[n];\\n        int[] rightSmallerOrEqualIdxes = new int[n];\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        for (int i = 0; i < n; i++)\\n        {\\n            int s = ss[i];\\n            while (!deque.isEmpty() && ss[deque.peekLast()] >= s)\\n            {\\n                deque.pollLast();\\n            }\\n            leftSmallerIdxes[i] = deque.isEmpty() ? -1 : deque.peekLast();\\n            deque.addLast(i);\\n        }\\n        deque = new ArrayDeque<>();\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            int s = ss[i];\\n            while (!deque.isEmpty() && ss[deque.peekFirst()] > s)\\n            {\\n                deque.pollFirst();\\n            }\\n            rightSmallerOrEqualIdxes[i] = deque.isEmpty() ? n : deque.peekFirst();\\n            deque.addFirst(i);\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n            long sum = 0;\\n            int leftSmallerIdx = leftSmallerIdxes[i];\\n            int leftCount = i - (leftSmallerIdx + 1);\\n            long leftSum = (i == 0 ? 0 : (leftCount * presums[i] - (presums2[i - 1] - (leftSmallerIdx < 0 ? 0 : presums2[leftSmallerIdx])))) % mod;\\n            int rightSmallerOrEqualIdx = rightSmallerOrEqualIdxes[i];\\n            int rightCount = rightSmallerOrEqualIdx - (i + 1);\\n            long rightSum = (presums2[rightSmallerOrEqualIdx] - presums2[i + 1] - rightCount * presums[i + 1]) % mod;\\n            sum += (leftSum * (rightCount + 1) + rightSum * (leftCount + 1)) % mod;\\n            sum += (long)ss[i] * (long)(leftCount + 1) * (long)(rightCount + 1) % mod;\\n            stg += (long)ss[i] * sum % mod;\\n            stg %= mod;\\n        }\\n        return (int)stg;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177206,
                "title": "python-geometric-solution",
                "content": "# Intuition\\nI thought it would be fun to do an array-based solution that does not utilize a conventional stack approach. It isn\\'t the fastest but I find it interesting. \\n# Approach\\nThe number of occurrences of a value across all contiguous subarrays is given with position index array $$pos$$ is given by:\\n\\n$$count = (1-median(pos))^2+max(pos)-(pos-median(pos))^2$$\\n\\nGraphically this looks something like: \\n\\n![CountStart.png](https://assets.leetcode.com/users/images/16599079-b0c6-406c-bc0a-10af9f7a6180_1676225008.2669034.png)\\n\\n\\nThe number of occurences of values that in contiguous subarrays that contain some value at some position $$focus$$ is given by a triangular function of peak $$count[focus]$$ with a rising leg from the nearest zero to the left of $$focus$$ and falling leg from the peak to the neartest zero to the right of $$focus$$. See the \"build_line\" function below. They look something like this:\\n![Triang1.png](https://assets.leetcode.com/users/images/086a3888-52bb-49e5-9676-073ff260349d_1676225078.2442956.png)\\n![Triang2.png](https://assets.leetcode.com/users/images/ccc41288-d162-485c-b3c2-ffce5ec5651c_1676225081.5821483.png)\\n\\nWith these two functions established, all we need to do is start with $$counts$$, select the largest strength value, determine the $$linevec$$ at that strength value, calculate strength as:\\n\\n$$strength_{total} = strength_{total} + \\\\Sigma(linevec*strength)*strength[focus]$$\\n\\nand the new counts is just:\\n\\n$$counts=counts-linevec$$\\n\\nWhich after the first pass may look like: \\n![newcounts.png](https://assets.leetcode.com/users/images/5a75f710-42ef-456f-a36c-c9a439649b67_1676225414.8100917.png)\\n\\nThen we just repeat for the next largest strength and so on. \\n\\nThis solution works, but the main issue is that building these triangles isn\\'t as fast as I would hope. \\n\\n# Code\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def build_line(self,counts, focus):\\n        lins = np.zeros(len(counts),dtype=\"int64\")\\n        left_zeros = 0\\n        for i in range(focus-1, -1, -1):\\n            if counts[i] == 0:\\n                left_zeros = i + 1\\n                break\\n        left_dt = counts[focus] // (focus + 1 - left_zeros)  # use integer division\\n        lins[(left_zeros):(focus+1)] = range(counts[focus] - ((focus-left_zeros + 1)- 1) * left_dt,counts[focus]+1,left_dt)\\n            \\n        right_zeros = len(counts) + 1\\n        for i in range(focus, len(counts)):\\n            if counts[i] == 0:\\n                right_zeros = i + 1\\n                break\\n        right_dt = counts[focus] // (right_zeros - focus - 1)  # use integer division\\n        lins[focus:(right_zeros)] = range(counts[focus],counts[focus] - (right_zeros-focus-1) * right_dt - 1,-right_dt)[:len(lins[focus:(right_zeros+1)])]\\n        return lins\\n    \\n    def totalStrength(self, strength: List[int]) -> int:\\n        strength_sum = 0\\n        nparr=np.arange(1, len(strength) + 1)\\n        npmed=np.median(nparr)\\n\\n        counts = np.array((1 - npmed) ** 2 + len(strength) - (nparr - npmed) ** 2,dtype=\"int64\")\\n        mod = 10 ** 9 + 7\\n        strength=np.array(strength,dtype=\"int64\")\\n        for focus in np.argsort(strength):\\n            linevec = self.build_line(counts, focus)\\n            strength_sum = strength_sum + np.dot(strength,linevec) * strength[focus]\\n            counts = counts - linevec\\n            \\n        return (int(strength_sum) % mod)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def build_line(self,counts, focus):\\n        lins = np.zeros(len(counts),dtype=\"int64\")\\n        left_zeros = 0\\n        for i in range(focus-1, -1, -1):\\n            if counts[i] == 0:\\n                left_zeros = i + 1\\n                break\\n        left_dt = counts[focus] // (focus + 1 - left_zeros)  # use integer division\\n        lins[(left_zeros):(focus+1)] = range(counts[focus] - ((focus-left_zeros + 1)- 1) * left_dt,counts[focus]+1,left_dt)\\n            \\n        right_zeros = len(counts) + 1\\n        for i in range(focus, len(counts)):\\n            if counts[i] == 0:\\n                right_zeros = i + 1\\n                break\\n        right_dt = counts[focus] // (right_zeros - focus - 1)  # use integer division\\n        lins[focus:(right_zeros)] = range(counts[focus],counts[focus] - (right_zeros-focus-1) * right_dt - 1,-right_dt)[:len(lins[focus:(right_zeros+1)])]\\n        return lins\\n    \\n    def totalStrength(self, strength: List[int]) -> int:\\n        strength_sum = 0\\n        nparr=np.arange(1, len(strength) + 1)\\n        npmed=np.median(nparr)\\n\\n        counts = np.array((1 - npmed) ** 2 + len(strength) - (nparr - npmed) ** 2,dtype=\"int64\")\\n        mod = 10 ** 9 + 7\\n        strength=np.array(strength,dtype=\"int64\")\\n        for focus in np.argsort(strength):\\n            linevec = self.build_line(counts, focus)\\n            strength_sum = strength_sum + np.dot(strength,linevec) * strength[focus]\\n            counts = counts - linevec\\n            \\n        return (int(strength_sum) % mod)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115987,
                "title": "monotonic-stack-with-comments",
                "content": "# Intuition\\n1. Base on - https://leetcode.com/problems/sum-of-total-strength-of-wizards/solutions/2061985/java-c-python-one-pass-solution/\\n\\n\\n# Approach\\nFor those struggling to understand the formulae `A[i] * (racc * ln - lacc * rn)`, here is a simple example to help derive the formulae. It is not the exact formulae due to smart indexing used but will serve as a good memonic to derive the formulae without having to remember it in an interview. \\n\\nConsider left = 1 , right = 6 and i = 4. We have this array: [a0, a1, a2, a3, a4, a5, a6, a7]\\n\\nSub arrays:\\n1. Sum of sub arrays starting at 1. We will continue increasing right till we reach 6. \\npresum[4] - presum[0]\\npresum[5] - presum[0]\\npresum[6] - presum[0]\\n2. Sum of sub arrays starting at 2. We will continue increasing right till we reach 6. \\npresum[4] - presum[1]\\npresum[5] - presum[1]\\npresum[6] - presum[1]\\n3. Sum of sub arrays starting at 3. We will continue increasing right till we reach 6. \\npresum[4] - presum[2]\\npresum[5] - presum[2]\\npresum[6] - presum[2]\\n\\n4. Sum of sub arrays starting at 4. We will continue increasing right till we reach 6. \\npresum[4] - presum[3] -- special case where the subarray only contains ith element\\npresum[5] - presum[3]\\npresum[6] - presum[3]\\n\\nThese cases cover all the possible sub arrays  that include ith element in them. Their sum will be\\n\\n4 * (presum[6] + presum[5] + presum[4] ) - 3 ( presum[3] + presum[2] + presum[1] + presum[0])\\n\\nThis becomes:\\n\\n(4 - 1 + 1) (presumsum[6] - presumsum[3]) -  (6 - 4 + 1) (presumsum[3] - presumsum[0])\\n\\nWhich is \\n(i - left + 1)(presumsum[right] - presumsum[i - 1]) - (right - i + 1)(presumsum[i - 1] - presumsum[left - 1])\\n\\n\\nBecause of the choice of indexes used, we do not really need to do the +1 and -1 when dealing with array indexing. `list(accumulate(accumulate(A), initial = 0))` will have `(n+1)` elements. And when using indexes, the distance of an array is end_ind - start_ind  (`(i - left + 1)` and `(right - i + 1)` of the equation)\\n\\nYou can use this simple example to remember the formulae, with these additional conditions:\\n1. presumsum should have length n+1 and presumsum[0] will be 0\\n2. Left will be -1 and right will be n if no smaller element exists on left and right \\n3. Equality condition is only used on one side (we use for left side) \\n4. In the formulae derived from an example drop all the extra -1, +1s \\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nimport itertools\\n\\nclass Solution(object):\\n    def totalStrength(self, strength):\\n        \"\"\"\\n        :type strength: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Subarray + sum -> prefix sum\\n        # Subarray + minimum -> mono stack\\n\\n        n = len(strength)\\n\\n        # Monotic stack to find range in which ith element is mininum\\n\\n        # When next_min_right[i] is n, it indicates that there is \\n        # no number to the right less than strength[i]. \\n        # So we can use the last element of the array \\n        # too when building sub metrics. \\n        next_min_right = [n] * n\\n        stack = []\\n        # Iterate left to right to build next_min_right\\n        for i in range(n):\\n            # Building a increasing stack and the incoming element\\n            # is less than then head of stack so remove it\\n            while stack and strength[stack[-1]] > strength[i]:\\n                # Index of next min on right will be the new element that \\n                # was less\\n                next_min_right[stack.pop()] = i\\n            stack.append(i) #Add new element to stack\\n\\n        next_min_left = [-1] * n\\n        stack = []\\n        # Iterate right to left to build next_min_left\\n        for i in range(n-1, -1, -1):\\n            # Here we use >= so a pair of left and right boundry is\\n            # counted only once. (Need more detail)\\n            while stack and strength[stack[-1]] >= strength[i]:\\n                next_min_left[stack.pop()] = i\\n            stack.append(i) # Add new element to stack\\n\\n        prefixsum = [0] * n\\n        prefixsumsum = [0] * (n + 1) # 1 extra to store base case of no sum\\n\\n        for i in range(n):\\n            prefixsum[i] = prefixsum[i-1] + strength[i] if i > 0 else strength[i]\\n        for i in range(0, n):\\n            prefixsumsum[i+1] = prefixsumsum[i + 1 -1] + prefixsum[i]\\n                \\n        strength_sum = 0\\n\\n        for i in range(n):\\n            # Left will have some val since we did >= comparision above\\n            # Right might be n since we used > comparision above\\n            left, right = next_min_left[i], next_min_right[i]\\n\\n            # Left will be -1 only when ther is no element less than it \\n            # on left. So then the number of elements on left will be \\n            # current index i + 1 (i - (-1)). In other cases, the \\n            # number len will be i - left and since 0 indexed this will\\n            # be the correct length \\n            len_left = i - left\\n            r_sum = prefixsumsum[right] - prefixsumsum[i] \\n\\n            len_right = right - i\\n            l_sum = prefixsumsum[i] - prefixsumsum[max(left, 0)] \\n\\n            strength_sum += strength[i] * (len_left * r_sum - len_right * l_sum)\\n        \\n        return strength_sum % (10**9 + 7)\\n\\n        # O(N^2) using the palandrome logic of DP (timeout)\\n        # total_strength = 0\\n\\n        # strength_sums = [0] * len(strength)\\n\\n        # for i in range(len(strength)):\\n        #     strength_sums[i] = strength_sums[i-1] + strength[i] if i > 0 else strength[i]\\n\\n        # minimum_strengths = [[1000000000000000]* len(strength)] * len(strength)\\n    \\n        # for start in range(len(strength)):\\n        #     minimum_strengths[start][start] = strength[start]\\n        #     total_strength += strength[start] * strength[start]\\n\\n        # for end in range(len(strength)):\\n        #     for start in range(end-1, -1, -1):\\n        #         minimum_strengths[start][end] = min(strength[start], minimum_strengths[start+1][end]) \\n        #         strength_sum = strength_sums[end] - strength_sums[start-1] if start > 0 else strength_sums[end]\\n        #         total_strength += strength_sum * minimum_strengths[start][end]\\n        \\n        # return total_strength % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport itertools\\n\\nclass Solution(object):\\n    def totalStrength(self, strength):\\n        \"\"\"\\n        :type strength: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Subarray + sum -> prefix sum\\n        # Subarray + minimum -> mono stack\\n\\n        n = len(strength)\\n\\n        # Monotic stack to find range in which ith element is mininum\\n\\n        # When next_min_right[i] is n, it indicates that there is \\n        # no number to the right less than strength[i]. \\n        # So we can use the last element of the array \\n        # too when building sub metrics. \\n        next_min_right = [n] * n\\n        stack = []\\n        # Iterate left to right to build next_min_right\\n        for i in range(n):\\n            # Building a increasing stack and the incoming element\\n            # is less than then head of stack so remove it\\n            while stack and strength[stack[-1]] > strength[i]:\\n                # Index of next min on right will be the new element that \\n                # was less\\n                next_min_right[stack.pop()] = i\\n            stack.append(i) #Add new element to stack\\n\\n        next_min_left = [-1] * n\\n        stack = []\\n        # Iterate right to left to build next_min_left\\n        for i in range(n-1, -1, -1):\\n            # Here we use >= so a pair of left and right boundry is\\n            # counted only once. (Need more detail)\\n            while stack and strength[stack[-1]] >= strength[i]:\\n                next_min_left[stack.pop()] = i\\n            stack.append(i) # Add new element to stack\\n\\n        prefixsum = [0] * n\\n        prefixsumsum = [0] * (n + 1) # 1 extra to store base case of no sum\\n\\n        for i in range(n):\\n            prefixsum[i] = prefixsum[i-1] + strength[i] if i > 0 else strength[i]\\n        for i in range(0, n):\\n            prefixsumsum[i+1] = prefixsumsum[i + 1 -1] + prefixsum[i]\\n                \\n        strength_sum = 0\\n\\n        for i in range(n):\\n            # Left will have some val since we did >= comparision above\\n            # Right might be n since we used > comparision above\\n            left, right = next_min_left[i], next_min_right[i]\\n\\n            # Left will be -1 only when ther is no element less than it \\n            # on left. So then the number of elements on left will be \\n            # current index i + 1 (i - (-1)). In other cases, the \\n            # number len will be i - left and since 0 indexed this will\\n            # be the correct length \\n            len_left = i - left\\n            r_sum = prefixsumsum[right] - prefixsumsum[i] \\n\\n            len_right = right - i\\n            l_sum = prefixsumsum[i] - prefixsumsum[max(left, 0)] \\n\\n            strength_sum += strength[i] * (len_left * r_sum - len_right * l_sum)\\n        \\n        return strength_sum % (10**9 + 7)\\n\\n        # O(N^2) using the palandrome logic of DP (timeout)\\n        # total_strength = 0\\n\\n        # strength_sums = [0] * len(strength)\\n\\n        # for i in range(len(strength)):\\n        #     strength_sums[i] = strength_sums[i-1] + strength[i] if i > 0 else strength[i]\\n\\n        # minimum_strengths = [[1000000000000000]* len(strength)] * len(strength)\\n    \\n        # for start in range(len(strength)):\\n        #     minimum_strengths[start][start] = strength[start]\\n        #     total_strength += strength[start] * strength[start]\\n\\n        # for end in range(len(strength)):\\n        #     for start in range(end-1, -1, -1):\\n        #         minimum_strengths[start][end] = min(strength[start], minimum_strengths[start+1][end]) \\n        #         strength_sum = strength_sums[end] - strength_sums[start-1] if start > 0 else strength_sums[end]\\n        #         total_strength += strength_sum * minimum_strengths[start][end]\\n        \\n        # return total_strength % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2655618,
                "title": "top-down-recursion-solution",
                "content": "I am using recursion, 68/82 tests passed.  I tried to convert this to a top-down dp solution. For runtime-efficiency I think I can really just pass 2 params to the function (n^2 with memoization). I am not really good at bottom-up dp. I was also asked this question at Amazon. In the past I have always been able to solve the Amazon coding questions but this was really tough.\\n\\n```\\nclass Solution {\\n    int[] strength;\\n    long totalStrengthUtil(int idx, long sum, long min) {\\n        if ( idx == strength.length ) return sum*min;\\n        return sum*min + totalStrengthUtil( idx+1, sum+strength[idx], Math.min( min,strength[idx]));\\n    }\\n    \\n    public int totalStrength(int[] strength) {\\n        this.strength = strength;\\n        long sum = 0;\\n        for ( int i = 0; i < strength.length; ++i ) {\\n            sum += totalStrengthUtil(i+1,strength[i],strength[i]);\\n        }\\n        return (int)(sum%1000000007);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] strength;\\n    long totalStrengthUtil(int idx, long sum, long min) {\\n        if ( idx == strength.length ) return sum*min;\\n        return sum*min + totalStrengthUtil( idx+1, sum+strength[idx], Math.min( min,strength[idx]));\\n    }\\n    \\n    public int totalStrength(int[] strength) {\\n        this.strength = strength;\\n        long sum = 0;\\n        for ( int i = 0; i < strength.length; ++i ) {\\n            sum += totalStrengthUtil(i+1,strength[i],strength[i]);\\n        }\\n        return (int)(sum%1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634028,
                "title": "java-o-n-solution-prefix-sum-of-prefix-sum-mono-stack",
                "content": "```\\nclass Solution {\\n    \\n    private static final int MOD = (int) 1e9 + 7;;\\n    \\n    public int totalStrength(int[] strength) {\\n        int len = strength.length;\\n        // prefix sum of prefix sum\\n        // O(N)\\n        long[] ps = new long[len + 1];\\n        long[] psps = new long[len + 1];\\n        for (int i = 0; i < len; ++i) {\\n            ps[i+1] = (ps[i] + strength[i]) % MOD;\\n            psps[i+1] = (psps[i] + ps[i+1]) % MOD;\\n        }\\n        // mono stack to find the immediate right smaller element\\n        int[] rSmall = new int[len];\\n        Arrays.fill(rSmall, len);\\n        Deque<Integer> monoStk = new ArrayDeque<>();\\n        for (int i = 0; i < len; ++i) {\\n            while (!monoStk.isEmpty() && strength[monoStk.peek()] > strength[i]) {\\n                rSmall[monoStk.pop()] = i;\\n            }\\n            monoStk.push(i);\\n        }\\n        // mono stack to find the immediate left smaller (or equal) element\\n        int[] lSmall = new int[len];\\n        Arrays.fill(lSmall, -1);\\n        monoStk.clear();\\n        for (int i = len - 1; i >= 0; --i) {\\n            while (!monoStk.isEmpty() && strength[monoStk.peek()] >= strength[i]) {\\n                lSmall[monoStk.pop()] = i;\\n            }\\n            monoStk.push(i);\\n        }\\n        // compute & combine contributions of each element\\n        // rCount * (psps[i] - psps[Math.max(0, lSmall[i])]) - lCount * (psps[rSmall[i]] - psps[i])\\n        long ans = 0;\\n        for (int i = 0; i < len; ++i) {\\n            int s = strength[i];\\n            int lCount = i - lSmall[i];\\n            int rCount = rSmall[i] - i;\\n            long total = lCount * (psps[rSmall[i]] + MOD - psps[i]) % MOD + MOD - rCount * (psps[i] + MOD - psps[Math.max(0, lSmall[i])]) % MOD;\\n            ans = (ans + (s * total) % MOD) % MOD;\\n        }\\n        return (int) ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private static final int MOD = (int) 1e9 + 7;;\\n    \\n    public int totalStrength(int[] strength) {\\n        int len = strength.length;\\n        // prefix sum of prefix sum\\n        // O(N)\\n        long[] ps = new long[len + 1];\\n        long[] psps = new long[len + 1];\\n        for (int i = 0; i < len; ++i) {\\n            ps[i+1] = (ps[i] + strength[i]) % MOD;\\n            psps[i+1] = (psps[i] + ps[i+1]) % MOD;\\n        }\\n        // mono stack to find the immediate right smaller element\\n        int[] rSmall = new int[len];\\n        Arrays.fill(rSmall, len);\\n        Deque<Integer> monoStk = new ArrayDeque<>();\\n        for (int i = 0; i < len; ++i) {\\n            while (!monoStk.isEmpty() && strength[monoStk.peek()] > strength[i]) {\\n                rSmall[monoStk.pop()] = i;\\n            }\\n            monoStk.push(i);\\n        }\\n        // mono stack to find the immediate left smaller (or equal) element\\n        int[] lSmall = new int[len];\\n        Arrays.fill(lSmall, -1);\\n        monoStk.clear();\\n        for (int i = len - 1; i >= 0; --i) {\\n            while (!monoStk.isEmpty() && strength[monoStk.peek()] >= strength[i]) {\\n                lSmall[monoStk.pop()] = i;\\n            }\\n            monoStk.push(i);\\n        }\\n        // compute & combine contributions of each element\\n        // rCount * (psps[i] - psps[Math.max(0, lSmall[i])]) - lCount * (psps[rSmall[i]] - psps[i])\\n        long ans = 0;\\n        for (int i = 0; i < len; ++i) {\\n            int s = strength[i];\\n            int lCount = i - lSmall[i];\\n            int rCount = rSmall[i] - i;\\n            long total = lCount * (psps[rSmall[i]] + MOD - psps[i]) % MOD + MOD - rCount * (psps[i] + MOD - psps[Math.max(0, lSmall[i])]) % MOD;\\n            ans = (ans + (s * total) % MOD) % MOD;\\n        }\\n        return (int) ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309903,
                "title": "python-brute-force-o-n-2",
                "content": "Can someone please help me optimize this code coz it fails for TDE for edge cases with large input array length. This is my brute force approach but I think there would be a suitable way to reduce the number of loops.\\n\\n```class Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        last_add = len(strength)-1\\n        ans = 0\\n        for i in range(last_add+1):\\n            for j in range(len(strength)):\\n                if i+j<=last_add:\\n                    check_list = strength[j:j+i+1]\\n                    ans += min(check_list)* sum(check_list)\\n                \\n        return ans%(pow(10,9)+7)```",
                "solutionTags": [],
                "code": "```class Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        last_add = len(strength)-1\\n        ans = 0\\n        for i in range(last_add+1):\\n            for j in range(len(strength)):\\n                if i+j<=last_add:\\n                    check_list = strength[j:j+i+1]\\n                    ans += min(check_list)* sum(check_list)\\n                \\n        return ans%(pow(10,9)+7)```",
                "codeTag": "Java"
            },
            {
                "id": 2296576,
                "title": "c-stack-prefix-sum-hard",
                "content": "#define mod 1000000007\\nclass Solution {\\npublic:\\n\\n     long long solve(long long st, long long end, vector<long long>&pre, vector<long long>&pre2)\\n     {\\n         long long len = end-st+1;\\n         long long x = 0;\\n         if(end>=0)\\n             x+=pre2[end];\\n         \\n         if(st>0)\\n         {\\n            x-=pre2[st-1];\\n            x-=(len)*(pre[st-1]*(1LL));\\n         }\\n         return x;\\n     }\\n    \\n    long long solve2(int st, int end, vector<long long>&pre3, vector<long long>&pre4)\\n     {\\n         long long len = end-st+1;\\n         long long x = 0;\\n         if(st>=0)\\n             x+=pre4[st];\\n         \\n         long long cal = pre3.size()-1;\\n\\n         if(end<cal)\\n         {\\n            x-=pre4[end+1];\\n            x-=(len)*(pre3[end+1]*(1LL));\\n         }\\n         return x;\\n     }\\n    int totalStrength(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> nsl(n),nsr(n);\\n        \\n        stack<int> stl,str;\\n        stl.push(0);\\n        nsl[0]=-1;\\n        \\n        for(int i=1; i<n; i++) \\n        {\\n            \\n            while((!stl.empty()) && nums[stl.top()]>nums[i])\\n                stl.pop();\\n            \\n            if(stl.empty())\\n                nsl[i]=-1;\\n            else\\n                nsl[i]=stl.top();\\n            \\n            stl.push(i);\\n        }\\n        \\n        str.push(n-1);\\n        nsr[n-1]=n;\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            while((!str.empty()) && nums[str.top()]>=nums[i])    \\n                str.pop();\\n            \\n            if(str.empty())\\n                nsr[i]=n;\\n            else\\n                nsr[i]=str.top();\\n            \\n            str.push(i);\\n        }\\n        \\n        vector<long long> pre(n,0),pre2(n,0),pre3(n,0),pre4(n,0);\\n        pre[0]=nums[0];\\n        pre2[0]=nums[0];\\n        pre3[n-1] = nums[n-1];\\n        pre4[n-1] = nums[n-1];\\n        \\n        for(int i=1; i<n; i++)\\n            pre[i] = pre[i-1]+nums[i];\\n        \\n        for(int i=1; i<n; i++)\\n            pre2[i] = pre2[i-1]+pre[i];\\n        \\n        for(int i=n-2; i>=0; i--)\\n            pre3[i] = pre3[i+1]+nums[i];\\n        \\n        for(int i=n-2; i>=0; i--)\\n            pre4[i] = pre4[i+1] +pre3[i];\\n\\n        \\n        long long out=0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            long long st = nsl[i]+1, end = nsr[i]-1;\\n            long long lenr = end-i+1, lenl = i-st+1;\\n             \\n            long long val1 = solve(i,end,pre,pre2);\\n            long long val2 = solve2(st,i-1,pre3,pre4);\\n            \\n            val1%=mod;\\n            val2%=mod;\\n            \\n            long long res= (val1*(1LL))*(lenl*(1LL)) + (val2*(1LL))*(lenr*(1LL));\\n            res%=(mod);\\n            \\n            res*=(nums[i])*(1LL);\\n            res%=(mod);\\n\\n            out+=res;\\n            out%=(mod);\\n        }\\n        return out;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n\\n     long long solve(long long st, long long end, vector<long long>&pre, vector<long long>&pre2)\\n     {\\n         long long len = end-st+1;\\n         long long x = 0;\\n         if(end>=0)\\n             x+=pre2[end];\\n         \\n         if(st>0)\\n         {\\n            x-=pre2[st-1];\\n            x-=(len)*(pre[st-1]*(1LL));\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2239016,
                "title": "o-n-need-some-math-prefix-sum-of-prefix-sum-stack-java",
                "content": "Ugh, this problem is so crazy for being a new grad Amazon OA question.\\n_____________\\nMy intuition is that we need to count the contribution of each wizard. \\nFind its right bound, which is the number `<` to it, and find its left bound, which is the number `<=` to it.\\nThis part is easy. However, the challenge is querying the **the sum** of subarray sum in O(1) or O(logn). \\n\\nI wrote down each number contribution below for a given range where `A[M]` is the min wizard, and A[i] is the leftmost wizard included and `A[j]` is the rightmost wizard included. Through some arrangments, I found that for the left half of the array, the sum is what you see on the bottom of the screenshot below, with `N = m-i+1`. Due to the symmetric property, we can use a suffix array for the right half. \\n\\nOK, it is now time to code. \\n![image](https://assets.leetcode.com/users/images/2943f982-9128-473e-a4b9-d7f49ec8860f_1656988189.1517031.jpeg)\\n\\n> And all that `%M` makes my code so ugly. I hate it so much. \\n\\n**Time Complexity: O(n)**\\n**Space Complexity: O(n)**\\n```Java\\nclass Solution {\\n    public int totalStrength(int[] A) {\\n        int n = A.length, M = (int)1e9+7;\\n        Deque<Integer> rs = new ArrayDeque<>();\\n        Deque<Integer> ls = new ArrayDeque<>();\\n        int[] right= new int[n];\\n        int[] left = new int[n];\\n        int[] pre  = new int[n];\\n        int[] suf  = new int[n];\\n        int[] ppre = new int[n];\\n        int[] ssuf = new int[n];\\n        Arrays.fill(right, n-1);\\n        for (int i=0,j=n-1;i<n;i++,j--){\\n            while(!rs.isEmpty()&&A[i]<A[rs.peek()]){\\n                right[rs.pop()]=i-1;\\n            }\\n            while(!ls.isEmpty()&&A[j]<=A[ls.peek()]){\\n                left[ls.pop()]=j+1;\\n            }\\n            rs.push(i);\\n            ls.push(j);\\n            pre[i]=i==0?A[i]:(A[i]+pre[i-1])%M;\\n            suf[j]=i==0?A[j]:(A[j]+suf[j+1])%M;\\n            ppre[i]=i==0?pre[i]:(pre[i]+ppre[i-1])%M;\\n            ssuf[j]=i==0?suf[j]:(suf[j]+ssuf[j+1])%M;\\n        }\\n        long ans = 0;\\n        for (int i = 0; i<n; i++){\\n            long lval = ((1L*(i-left[i]+1)*pre[i]%M-(i==0?0:(ppre[i-1]-(left[i]<=1?0:ppre[left[i]-2])))+M)%M)*(right[i]-i+1)%M;\\n            long rval = ((1L*(right[i]-i+1)*suf[i]%M-(i==n-1?0:(ssuf[i+1]-(right[i]>=n-2?0:ssuf[right[i]+2])))+M)%M)*(i-left[i]+1)%M;\\n            long mid  = (1L*(i-left[i]+1)*(right[i]-i+1))%M*A[i]%M;\\n            ans = (ans + (lval + rval - mid + M)%M*A[i]%M + M)%M;\\n        }\\n\\n        return (int)ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int totalStrength(int[] A) {\\n        int n = A.length, M = (int)1e9+7;\\n        Deque<Integer> rs = new ArrayDeque<>();\\n        Deque<Integer> ls = new ArrayDeque<>();\\n        int[] right= new int[n];\\n        int[] left = new int[n];\\n        int[] pre  = new int[n];\\n        int[] suf  = new int[n];\\n        int[] ppre = new int[n];\\n        int[] ssuf = new int[n];\\n        Arrays.fill(right, n-1);\\n        for (int i=0,j=n-1;i<n;i++,j--){\\n            while(!rs.isEmpty()&&A[i]<A[rs.peek()]){\\n                right[rs.pop()]=i-1;\\n            }\\n            while(!ls.isEmpty()&&A[j]<=A[ls.peek()]){\\n                left[ls.pop()]=j+1;\\n            }\\n            rs.push(i);\\n            ls.push(j);\\n            pre[i]=i==0?A[i]:(A[i]+pre[i-1])%M;\\n            suf[j]=i==0?A[j]:(A[j]+suf[j+1])%M;\\n            ppre[i]=i==0?pre[i]:(pre[i]+ppre[i-1])%M;\\n            ssuf[j]=i==0?suf[j]:(suf[j]+ssuf[j+1])%M;\\n        }\\n        long ans = 0;\\n        for (int i = 0; i<n; i++){\\n            long lval = ((1L*(i-left[i]+1)*pre[i]%M-(i==0?0:(ppre[i-1]-(left[i]<=1?0:ppre[left[i]-2])))+M)%M)*(right[i]-i+1)%M;\\n            long rval = ((1L*(right[i]-i+1)*suf[i]%M-(i==n-1?0:(ssuf[i+1]-(right[i]>=n-2?0:ssuf[right[i]+2])))+M)%M)*(i-left[i]+1)%M;\\n            long mid  = (1L*(i-left[i]+1)*(right[i]-i+1))%M*A[i]%M;\\n            ans = (ans + (lval + rval - mid + M)%M*A[i]%M + M)%M;\\n        }\\n\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122651,
                "title": "cpp-finally-solved-it-with-explanation",
                "content": "I came across this YT video that explains pretty much of the code:- https://www.youtube.com/watch?v=96xV80pvU6c\\n\\n```\\n#define mod 1000000007\\n#define in long long int\\n\\nclass Solution {\\npublic:\\n    vector<in> prefix1;\\n    vector<in> prefix2;\\n    vector<in> prefix3;\\n    vector<in> prefix4;\\n    unordered_map<int, int> rightside, leftside;\\n    vector<int> st;\\n    int n;\\n    unordered_map<int, int> lastposition;\\n    \\n    void fillprefixes(vector<int>&strength){\\n        for(int i=0;i<n;i++){ \\n            prefix1[i+1] = summ(prefix1[i], strength[i]);\\n            prefix2[i+1] = prefix1[i+1];\\n        }\\n        \\n        for(int i=n-1;i>=0;i--){\\n            prefix3[i+1] = summ(prefix3[i+2], strength[i]);\\n            prefix4[i+1] = prefix3[i+1];\\n        }\\n        \\n        for(int i=n;i>=1;i--) prefix4[i] = summ(prefix4[i], prefix4[i+1]);\\n        for(int i=1;i<=n;i++) prefix2[i] = summ(prefix2[i], prefix2[i-1]);\\n    }\\n    \\n    void fillstack(vector<int>&strength){\\n        for(int i=0;i<n;i++){\\n            if(st.size() == 0) st.push_back(i);\\n            else{\\n                if(strength[i] >= strength[st.back()]) st.push_back(i);\\n                else{ \\n                    while(st.size() && strength[st.back()] > strength[i]){\\n                        rightside[st.back()] = i-1;\\n                        st.pop_back();\\n                    }\\n                    st.push_back(i);\\n                }\\n            }\\n         }\\n        \\n        while(st.size()){\\n            rightside[st.back()] = n-1;\\n            st.pop_back();\\n        }\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(st.size() == 0) st.push_back(i);\\n            else{\\n                if(strength[i] >= strength[st.back()]) st.push_back(i);\\n                else{ \\n                    while(st.size() && strength[st.back()] > strength[i]){\\n                        leftside[st.back()] = i+1;\\n                        st.pop_back();\\n                    }\\n                    st.push_back(i);\\n                }\\n            }\\n        }\\n        \\n        while(st.size()){\\n            leftside[st.back()] = 0;\\n            st.pop_back();\\n        }\\n        \\n    }\\n    \\n    in summ(in a, in b){ return ((a * 1ll) + (b * 1ll))%mod; }\\n    \\n    in mull(in a, in b){ return ((a * 1ll)%mod * (b * 1ll)%mod)%mod; }\\n    \\n    in subb(in a, in b){ return summ(((a * 1ll)%mod - (b * 1ll)%mod)%mod, mod); }\\n    \\n    in getsumright(in a, in b){\\n        if(a > b) return 0;\\n        in ans = subb(prefix2[b+1], prefix2[a]);\\n        in diff = mull(prefix1[a], b-a+1);\\n        return subb(ans, diff);\\n    }\\n    \\n    in getsumleft(in a, in b){\\n        in ans = subb(prefix4[a+1], prefix4[b+2]);\\n        in diff = mull(prefix3[b+2], b-a+1);\\n        return subb(ans, diff);\\n    }\\n    \\n    int totalStrength(vector<int>& strength) {\\n        n = strength.size();\\n        prefix1 = vector<in>(n+2, 0);\\n        prefix2 = vector<in>(n+2, 0);\\n        prefix3 = vector<in>(n+2, 0);\\n        prefix4 = vector<in>(n+2, 0);\\n        \\n        fillprefixes(strength);\\n        fillstack(strength);\\n        \\n        in ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            int left = leftside[i];\\n            int right = rightside[i];\\n            if(lastposition[strength[i]] == 0 && strength[0] != strength[i]){}\\n            else if(i != 0) left = max(leftside[i], lastposition[strength[i]]+1);\\n            lastposition[strength[i]] = i;\\n            \\n            in leftsum = getsumleft(left, i);\\n            in rightsum = getsumright(i+1, right);\\n            \\n            in leftnum = i - left + 1;\\n            in rightnum = right - i + 1;\\n            \\n            leftsum = mull(leftsum, rightnum);\\n            rightsum = mull(rightsum, leftnum);\\n            in totsum = summ(leftsum, rightsum);\\n            totsum = mull(totsum, strength[i]);\\n            ans = summ(ans, totsum);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\n#define mod 1000000007\\n#define in long long int\\n\\nclass Solution {\\npublic:\\n    vector<in> prefix1;\\n    vector<in> prefix2;\\n    vector<in> prefix3;\\n    vector<in> prefix4;\\n    unordered_map<int, int> rightside, leftside;\\n    vector<int> st;\\n    int n;\\n    unordered_map<int, int> lastposition;\\n    \\n    void fillprefixes(vector<int>&strength){\\n        for(int i=0;i<n;i++){ \\n            prefix1[i+1] = summ(prefix1[i], strength[i]);\\n            prefix2[i+1] = prefix1[i+1];\\n        }\\n        \\n        for(int i=n-1;i>=0;i--){\\n            prefix3[i+1] = summ(prefix3[i+2], strength[i]);\\n            prefix4[i+1] = prefix3[i+1];\\n        }\\n        \\n        for(int i=n;i>=1;i--) prefix4[i] = summ(prefix4[i], prefix4[i+1]);\\n        for(int i=1;i<=n;i++) prefix2[i] = summ(prefix2[i], prefix2[i-1]);\\n    }\\n    \\n    void fillstack(vector<int>&strength){\\n        for(int i=0;i<n;i++){\\n            if(st.size() == 0) st.push_back(i);\\n            else{\\n                if(strength[i] >= strength[st.back()]) st.push_back(i);\\n                else{ \\n                    while(st.size() && strength[st.back()] > strength[i]){\\n                        rightside[st.back()] = i-1;\\n                        st.pop_back();\\n                    }\\n                    st.push_back(i);\\n                }\\n            }\\n         }\\n        \\n        while(st.size()){\\n            rightside[st.back()] = n-1;\\n            st.pop_back();\\n        }\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(st.size() == 0) st.push_back(i);\\n            else{\\n                if(strength[i] >= strength[st.back()]) st.push_back(i);\\n                else{ \\n                    while(st.size() && strength[st.back()] > strength[i]){\\n                        leftside[st.back()] = i+1;\\n                        st.pop_back();\\n                    }\\n                    st.push_back(i);\\n                }\\n            }\\n        }\\n        \\n        while(st.size()){\\n            leftside[st.back()] = 0;\\n            st.pop_back();\\n        }\\n        \\n    }\\n    \\n    in summ(in a, in b){ return ((a * 1ll) + (b * 1ll))%mod; }\\n    \\n    in mull(in a, in b){ return ((a * 1ll)%mod * (b * 1ll)%mod)%mod; }\\n    \\n    in subb(in a, in b){ return summ(((a * 1ll)%mod - (b * 1ll)%mod)%mod, mod); }\\n    \\n    in getsumright(in a, in b){\\n        if(a > b) return 0;\\n        in ans = subb(prefix2[b+1], prefix2[a]);\\n        in diff = mull(prefix1[a], b-a+1);\\n        return subb(ans, diff);\\n    }\\n    \\n    in getsumleft(in a, in b){\\n        in ans = subb(prefix4[a+1], prefix4[b+2]);\\n        in diff = mull(prefix3[b+2], b-a+1);\\n        return subb(ans, diff);\\n    }\\n    \\n    int totalStrength(vector<int>& strength) {\\n        n = strength.size();\\n        prefix1 = vector<in>(n+2, 0);\\n        prefix2 = vector<in>(n+2, 0);\\n        prefix3 = vector<in>(n+2, 0);\\n        prefix4 = vector<in>(n+2, 0);\\n        \\n        fillprefixes(strength);\\n        fillstack(strength);\\n        \\n        in ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            int left = leftside[i];\\n            int right = rightside[i];\\n            if(lastposition[strength[i]] == 0 && strength[0] != strength[i]){}\\n            else if(i != 0) left = max(leftside[i], lastposition[strength[i]]+1);\\n            lastposition[strength[i]] = i;\\n            \\n            in leftsum = getsumleft(left, i);\\n            in rightsum = getsumright(i+1, right);\\n            \\n            in leftnum = i - left + 1;\\n            in rightnum = right - i + 1;\\n            \\n            leftsum = mull(leftsum, rightnum);\\n            rightsum = mull(rightsum, leftnum);\\n            in totsum = summ(leftsum, rightsum);\\n            totsum = mull(totsum, strength[i]);\\n            ans = summ(ans, totsum);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070516,
                "title": "like-sum-of-subarray-minimum-with-little-variation",
                "content": "Just find left smaller and right smaller element for every element\\n**Note : Since, there may be duplicates in the array, so you must find (previous smaller or equal element and next smaller element) OR (previous smaller and next smaller or equal element)**\\n\\nThen you need to find sum of all subarrays that include index (i)\\nFor that, I have done 2 prefix sum named as pre and pre2\\nIts by observation\\n\\n```\\nclass Solution {\\npublic:\\n    const unsigned int M = 1000000007;\\n    \\n    vector<int> rightSmaller(vector<int>&s){\\n        stack<int> h;\\n        vector<int> ans;\\n        h.push(s.size()-1);\\n        ans.push_back(s.size());\\n        for(int i = s.size()-2;i>=0;i--){\\n            while(h.size()!=0 && s[h.top()]>s[i]){\\n                h.pop();\\n            }\\n            if(h.size()==0){\\n                ans.push_back(s.size());\\n            }\\n            else{\\n                ans.push_back(h.top());\\n            }\\n            h.push(i);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    \\n    \\n    vector<int> leftSmaller(vector<int>&s){\\n        stack<int> h;\\n        vector<int> ans;\\n        ans.push_back(-1);\\n        h.push(0);\\n        for(int i = 1; i< s.size();i++){\\n            while(h.size()!=0 && s[h.top()]>=s[i]){\\n                h.pop();\\n            }\\n            if(h.size()==0){\\n                ans.push_back(-1);\\n            }\\n            else{\\n                ans.push_back(h.top());\\n            }\\n            h.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    int totalStrength(vector<int>& strength) {\\n        \\n        vector<long long> pre(strength.size()+1,0);\\n        for(int i = 0; i < strength.size();i++){\\n            pre[i+1] = (pre[i]+strength[i])%M;\\n        }\\n        vector<long long>pre2(strength.size()+2,0);\\n        for(int i = 0; i < pre.size();i++){\\n            pre2[i+1] = (pre2[i]+pre[i])%M;\\n        }\\n        \\n        vector<int> right = rightSmaller(strength);\\n        vector<int> left = leftSmaller(strength);\\n     \\nint ans = 0;\\n        for(int i = 0; i < strength.size();i++){\\n            ans += ((pre2[right[i] + 1] - pre2[i + 1]) * (i - left[i]) % M + M * 2 - \\n               (pre2[i + 1] - pre2[left[i] + 1]) * (right[i] - i) % M) % M * strength[i] % M;\\n        ans %= M;\\n          \\n            \\n           \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const unsigned int M = 1000000007;\\n    \\n    vector<int> rightSmaller(vector<int>&s){\\n        stack<int> h;\\n        vector<int> ans;\\n        h.push(s.size()-1);\\n        ans.push_back(s.size());\\n        for(int i = s.size()-2;i>=0;i--){\\n            while(h.size()!=0 && s[h.top()]>s[i]){\\n                h.pop();\\n            }\\n            if(h.size()==0){\\n                ans.push_back(s.size());\\n            }\\n            else{\\n                ans.push_back(h.top());\\n            }\\n            h.push(i);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    \\n    \\n    vector<int> leftSmaller(vector<int>&s){\\n        stack<int> h;\\n        vector<int> ans;\\n        ans.push_back(-1);\\n        h.push(0);\\n        for(int i = 1; i< s.size();i++){\\n            while(h.size()!=0 && s[h.top()]>=s[i]){\\n                h.pop();\\n            }\\n            if(h.size()==0){\\n                ans.push_back(-1);\\n            }\\n            else{\\n                ans.push_back(h.top());\\n            }\\n            h.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    int totalStrength(vector<int>& strength) {\\n        \\n        vector<long long> pre(strength.size()+1,0);\\n        for(int i = 0; i < strength.size();i++){\\n            pre[i+1] = (pre[i]+strength[i])%M;\\n        }\\n        vector<long long>pre2(strength.size()+2,0);\\n        for(int i = 0; i < pre.size();i++){\\n            pre2[i+1] = (pre2[i]+pre[i])%M;\\n        }\\n        \\n        vector<int> right = rightSmaller(strength);\\n        vector<int> left = leftSmaller(strength);\\n     \\nint ans = 0;\\n        for(int i = 0; i < strength.size();i++){\\n            ans += ((pre2[right[i] + 1] - pre2[i + 1]) * (i - left[i]) % M + M * 2 - \\n               (pre2[i + 1] - pre2[left[i] + 1]) * (right[i] - i) % M) % M * strength[i] % M;\\n        ans %= M;\\n          \\n            \\n           \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2068278,
                "title": "c-monotonic-stack-prefix-suffix-sum-next-smaller-to-left-right",
                "content": "```\\nclass Solution {\\npublic:\\n    int md=1e9+7;\\n    int totalStrength(vector<int>& st) {\\n        int n=st.size();\\n        stack<int>s,s1;\\n        vector<long long> nsl(n,-1),nsr(n,n),pr1(n+2),pr2(n+2),sf1(n+2),sf2(n+2);\\n        for(int i=0;i<n;i++){\\n            while(!s.empty() && st[s.top()]>st[i])s.pop();\\n            if(!s.empty())nsl[i]=s.top();\\n            s.push(i);\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            while(!s1.empty() && st[s1.top()]>=st[i])s1.pop();\\n            if(!s1.empty())nsr[i]=s1.top();\\n            s1.push(i);\\n        }\\n        for(int i=1;i<=n;i++){\\n            pr1[i]=(pr1[i-1]+st[i-1])%md;\\n            pr2[i]=(pr2[i-1]+pr1[i])%md;\\n        }\\n        for(int i=n;i>=1;i--){\\n            sf1[i]=(sf1[i+1]+st[i-1])%md;\\n            sf2[i]=(sf2[i+1]+sf1[i])%md;\\n        }\\n        auto lsum=[&](int l,int r){\\n            if(l>r) return 0;\\n            long d=r-l+1,sub=(d*sf1[r+2])%md;\\n            long ans=(sf2[l+1]-sf2[r+2]+md)%md;\\n            ans=(ans-sub+md)%md;\\n            return (int)ans;            \\n        };\\n        auto rsum=[&](int l,int r){\\n            if(l>r) return 0;\\n            long d=r-l+1,sub=(d*pr1[l])%md;\\n            long ans=(pr2[r+1]-pr2[l]+md)%md;\\n            ans=(ans-sub+md)%md;\\n            return (int)ans;            \\n        };\\n        long ans=0;\\n        for(int i=0;i<st.size();i++){\\n            int l=nsl[i]+1,r=nsr[i]-1;\\n            long curr_min=st[i];\\n            long right_sum = rsum(i+1,r);\\n            long left_sum = lsum(l,i);\\n            long curr_sum = (right_sum*(i-l+1))%md;\\n            curr_sum = (curr_sum + (left_sum*(r-i+1))%md)%md;\\n            long curr_ans = (curr_sum*curr_min)%md; \\n            ans = (ans+curr_ans)%md;       \\n        }        \\n        return ans%md;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int md=1e9+7;\\n    int totalStrength(vector<int>& st) {\\n        int n=st.size();\\n        stack<int>s,s1;\\n        vector<long long> nsl(n,-1),nsr(n,n),pr1(n+2),pr2(n+2),sf1(n+2),sf2(n+2);\\n        for(int i=0;i<n;i++){\\n            while(!s.empty() && st[s.top()]>st[i])s.pop();\\n            if(!s.empty())nsl[i]=s.top();\\n            s.push(i);\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            while(!s1.empty() && st[s1.top()]>=st[i])s1.pop();\\n            if(!s1.empty())nsr[i]=s1.top();\\n            s1.push(i);\\n        }\\n        for(int i=1;i<=n;i++){\\n            pr1[i]=(pr1[i-1]+st[i-1])%md;\\n            pr2[i]=(pr2[i-1]+pr1[i])%md;\\n        }\\n        for(int i=n;i>=1;i--){\\n            sf1[i]=(sf1[i+1]+st[i-1])%md;\\n            sf2[i]=(sf2[i+1]+sf1[i])%md;\\n        }\\n        auto lsum=[&](int l,int r){\\n            if(l>r) return 0;\\n            long d=r-l+1,sub=(d*sf1[r+2])%md;\\n            long ans=(sf2[l+1]-sf2[r+2]+md)%md;\\n            ans=(ans-sub+md)%md;\\n            return (int)ans;            \\n        };\\n        auto rsum=[&](int l,int r){\\n            if(l>r) return 0;\\n            long d=r-l+1,sub=(d*pr1[l])%md;\\n            long ans=(pr2[r+1]-pr2[l]+md)%md;\\n            ans=(ans-sub+md)%md;\\n            return (int)ans;            \\n        };\\n        long ans=0;\\n        for(int i=0;i<st.size();i++){\\n            int l=nsl[i]+1,r=nsr[i]-1;\\n            long curr_min=st[i];\\n            long right_sum = rsum(i+1,r);\\n            long left_sum = lsum(l,i);\\n            long curr_sum = (right_sum*(i-l+1))%md;\\n            curr_sum = (curr_sum + (left_sum*(r-i+1))%md)%md;\\n            long curr_ans = (curr_sum*curr_min)%md; \\n            ans = (ans+curr_ans)%md;       \\n        }        \\n        return ans%md;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065928,
                "title": "easy-and-comprehensive-intuition-building",
                "content": "This question was asked in Feb 2022 during Amazon OA and in my opinion this is towards the more difficult side of hard problems, something I personally wouldn\\'t want somebody to ask me :3\\nWhen I saw this question, it took me around 5 sec to know that we\\'ll need to use Contribution here due to previous experience but 5 hours to implement (I suggest solving LC 907, LC 2104 and and lastly LC 828 in that order to gain some insight about how contribution works).\\n\\nWhat makes this question a bit harder to solve than those questions is, instead of calculating contribution of each element to the answer, we calculate \"the contribution of each sum that starts or ends with an element\" to the answer. Quirky, isn\\'t it? and definitely not something very pleasing to code, but the satisfaction and experience you will gain by solving this will wash this all away, make it worth every second. So stick with me okay?\\n\\nLet\\'s work out an example, step by step.\\n[6, 10, 9, 8, 7, 8, 9, 6]\\nThis example makes it a bit easier for me to explain this. \\nOut of all subarrays, let us assume some subarrays will have 7 as mininum value.\\nWhat is the maximum subarray that can do it? It\\'s [10, 9, 8, 7, 8, 9]. Let\\'s all this subarray **x**.\\nThis and all subarrays containing 7 and inside x will have 7 as mininum element. No other subarray will have 7 as mininum element except them. Read this paragraph, slowly this time if you still have some doubts as to why. It\\'s not rocket science, just bear with me.\\n\\nNow, let us create all subarrays where 7 is the end element.\\nThey are, \\na. [10, 9, 8, 7]\\nb. [9, 8, 7]\\nc. [8, 7]\\nd. [7]\\nNow, these subarrays end at 7, and definitely contribute to the answer but do they contribute to a bigger picture? YES!\\nWe can add all subarrays starting with 8 (index 5 in main array) to each of them and they will still make a valid subarray with 7 as minimum!\\nLet\\'s take [10, 9, 8, 7], we can add [8] and [8, 9]\\nSame case for [9, 8, 7] and [8, 7] and [7]!!\\nBasically all subarrays ending at 7 at index *i* can form a combination with subarrays starting at index *i+1* and is a subarray of **x**.\\nPhew! That was a lot to take in, but I tried my best.\\nso basically contribution of (a+b+c+d) is (a+b+c+d) * 3 (for [], [8] and [8, 9])\\nSimilarly if we name\\ne. [8]\\nf. [8, 9]\\nEach of these can contribute to [10, 9, 8, 7], [9, 8, 7], [8, 7], [7].\\nSo contribution of (e+f) is (e+f) * 4.\\n\\nNow, we just need to calculate a+b+c+d and e+f for all elements and we\\'ll be done.\\nThere are a lot of ways to do it, but the one I know uses prefix sum of prefix sum from left to right, and right to left and also prefix sum in both directions ( yes f to me ;D ).\\n\\nTo calculate a+b+c+d calculate prefix sum of prefix sum from left to right and prefix sum from left to right and do\\na+b+c+d = psum_of_psum[l+1] - psum_of_psum[i] - (r-1-i) * prefix_sum[i] where l is index of next smaller element on the left and r is index of next smaller element on the right. Handle edge cases here :3\\n\\ne+f can be calculated in the same way just by reversing direction of prefix sum calculations on both.\\n\\nl and r can be calculated by monotonic stack (search topic do questions, all quesstions have same logic lmao)\\n\\nNow, I can provide the code too, but I think you should pull out your hair on this implementation, it will be worth it. (Some will hate me but trust me, you arent learning if you dont pull your hair while doing questions). I just tried to build your intuition that is all, and I believe that\\'s the most important skill you will need. A solution can help solve one question, a skill can help solve hundred.",
                "solutionTags": [],
                "code": "This question was asked in Feb 2022 during Amazon OA and in my opinion this is towards the more difficult side of hard problems, something I personally wouldn\\'t want somebody to ask me :3\\nWhen I saw this question, it took me around 5 sec to know that we\\'ll need to use Contribution here due to previous experience but 5 hours to implement (I suggest solving LC 907, LC 2104 and and lastly LC 828 in that order to gain some insight about how contribution works).\\n\\nWhat makes this question a bit harder to solve than those questions is, instead of calculating contribution of each element to the answer, we calculate \"the contribution of each sum that starts or ends with an element\" to the answer. Quirky, isn\\'t it? and definitely not something very pleasing to code, but the satisfaction and experience you will gain by solving this will wash this all away, make it worth every second. So stick with me okay?\\n\\nLet\\'s work out an example, step by step.\\n[6, 10, 9, 8, 7, 8, 9, 6]\\nThis example makes it a bit easier for me to explain this. \\nOut of all subarrays, let us assume some subarrays will have 7 as mininum value.\\nWhat is the maximum subarray that can do it? It\\'s [10, 9, 8, 7, 8, 9]. Let\\'s all this subarray **x**.\\nThis and all subarrays containing 7 and inside x will have 7 as mininum element. No other subarray will have 7 as mininum element except them. Read this paragraph, slowly this time if you still have some doubts as to why. It\\'s not rocket science, just bear with me.\\n\\nNow, let us create all subarrays where 7 is the end element.\\nThey are, \\na. [10, 9, 8, 7]\\nb. [9, 8, 7]\\nc. [8, 7]\\nd. [7]\\nNow, these subarrays end at 7, and definitely contribute to the answer but do they contribute to a bigger picture? YES!\\nWe can add all subarrays starting with 8 (index 5 in main array) to each of them and they will still make a valid subarray with 7 as minimum!\\nLet\\'s take [10, 9, 8, 7], we can add [8] and [8, 9]\\nSame case for [9, 8, 7] and [8, 7] and [7]!!\\nBasically all subarrays ending at 7 at index *i* can form a combination with subarrays starting at index *i+1* and is a subarray of **x**.\\nPhew! That was a lot to take in, but I tried my best.\\nso basically contribution of (a+b+c+d) is (a+b+c+d) * 3 (for [], [8] and [8, 9])\\nSimilarly if we name\\ne. [8]\\nf. [8, 9]\\nEach of these can contribute to [10, 9, 8, 7], [9, 8, 7], [8, 7], [7].\\nSo contribution of (e+f) is (e+f) * 4.\\n\\nNow, we just need to calculate a+b+c+d and e+f for all elements and we\\'ll be done.\\nThere are a lot of ways to do it, but the one I know uses prefix sum of prefix sum from left to right, and right to left and also prefix sum in both directions ( yes f to me ;D ).\\n\\nTo calculate a+b+c+d calculate prefix sum of prefix sum from left to right and prefix sum from left to right and do\\na+b+c+d = psum_of_psum[l+1] - psum_of_psum[i] - (r-1-i) * prefix_sum[i] where l is index of next smaller element on the left and r is index of next smaller element on the right. Handle edge cases here :3\\n\\ne+f can be calculated in the same way just by reversing direction of prefix sum calculations on both.\\n\\nl and r can be calculated by monotonic stack (search topic do questions, all quesstions have same logic lmao)\\n\\nNow, I can provide the code too, but I think you should pull out your hair on this implementation, it will be worth it. (Some will hate me but trust me, you arent learning if you dont pull your hair while doing questions). I just tried to build your intuition that is all, and I believe that\\'s the most important skill you will need. A solution can help solve one question, a skill can help solve hundred.",
                "codeTag": "Unknown"
            },
            {
                "id": 2063908,
                "title": "c-monotonic-stack-prefix-sum-solution-o-n",
                "content": "Runtime: 531 ms, faster than 100.00% of C++ online submissions for Sum of Total Strength of Wizards.\\nMemory Usage: 126 MB, less than 100.00% of C++ online submissions for Sum of Total Strength of Wizards.\\n\\n\\n```\\nWe have to calculate the sum of the strength of all subarray.\\n\\nWe can know on how many subarrays each element will contribute as Min Element\\nand we can also know the sum of those subarray elements using Prefix Sum of Prefix Sum.\\n\\nUsing Prefix Sum of Prefix Sum array we can know the all subarray sum in the left and the\\nright. We can get the Total subarry sum using formula \\n\\nTotal Sum = Left Sum * Right Size + Right Sum * Left Size - Current Value * Left Size * Right Size\\n\\nLeft Sum will contribute to the subarrays sum Right Size time and Right Sum will contribute to\\nthe subarrays sum Left Size time and we have to deduct the current value from Total Sum\\nas we considered it extra Left Size * Right Size times. \\n\\nHere Left Sum is the subarrys sums from left index to current index inclusive and same for Left Size. \\nSimilarly Right Sum is the subarray sums from current index to right index inclusive and same for Right Size.\\n\\nLeft Index => Max (Left index till value >= current value, previous index of current value)\\nRight Index => Right index till value >= current value\\n\\nHere we calculate Left Index till the previous index of current value so that we do not\\ncalculate the same subarray twice.\\n\\nWe can easily get the left and right index till value >= current value using Monotonic Stack.\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& strength) {\\n        \\n        int size = strength.size();\\n        \\n        long long MOD = 1000000007L;\\n        \\n        // left to right prefix sum and prefix sum of prefix sum\\n        vector<long long>rightPrefixSum(size);\\n        vector<long long>rightPrefixSumPrefixSum(size);\\n        \\n        rightPrefixSum[0] = strength[0];\\n        rightPrefixSumPrefixSum[0] = strength[0];\\n        \\n        for(int i=1;i<size;i++)\\n        {\\n            rightPrefixSum[i] = rightPrefixSum[i-1] + strength[i];\\n            rightPrefixSumPrefixSum[i] = rightPrefixSumPrefixSum[i-1] + rightPrefixSum[i];\\n        }\\n        \\n        // right to left prefix sum and prefix sum of prefix sum\\n        vector<long long>leftPrefixSum(size);\\n        vector<long long>leftPrefixSumPrefixSum(size);\\n\\n        leftPrefixSum[size-1] = strength[size-1];\\n        leftPrefixSumPrefixSum[size-1] = strength[size-1];\\n        \\n        for(int i=size-2;i>=0;i--)\\n        {\\n            leftPrefixSum[i] = leftPrefixSum[i+1] + strength[i];\\n            leftPrefixSumPrefixSum[i] = leftPrefixSumPrefixSum[i+1] + leftPrefixSum[i];\\n        }\\n        \\n        \\n        // monotonic stack to get the right index with value < current value\\n        stack<int>rstak;        \\n        \\n        // store right index for current index till value >= current index value\\n        vector<int>rightIndexes(size);\\n        \\n        for(int i=size-1;i>=0;i--)\\n        {\\n            // remove values >= current value\\n            while(!rstak.empty() && strength[rstak.top()]>=strength[i])rstak.pop();\\n            \\n            rightIndexes[i] = rstak.empty() ? size-1 : rstak.top() - 1;\\n            \\n            rstak.push(i);\\n        }\\n        \\n\\n\\n        // monotonic stack to get the left index with value < current value\\n        stack<int>lstak;\\n        \\n        // store previous index of current value\\n        unordered_map<int,int>leftIndexes;\\n        \\n        int leftIndex,rightIndex;\\n        long long rightSum, leftSum,totalSum,leftSize,rightSize;\\n        \\n        // sum of all subarray strengths\\n        long long totalStrength = 0L;\\n        \\n        for(int i=0;i<size;i++)\\n        {\\n            leftIndex = leftIndexes.find(strength[i])==leftIndexes.end() ? 0 : leftIndexes[strength[i]] + 1;\\n            \\n            // remove value >= current value\\n            while(!lstak.empty() && strength[lstak.top()]>=strength[i])lstak.pop();\\n            \\n            // left index => max (left index, previous index of current value)\\n            leftIndex = max(leftIndex, lstak.empty() ? 0 : lstak.top() + 1);\\n            rightIndex = rightIndexes[i];\\n            \\n            // get left and right subarray size from current index inclusive\\n            leftSize = i - leftIndex + 1;\\n            rightSize = rightIndex - i + 1;\\n            \\n            lstak.push(i);\\n            leftIndexes[strength[i]]=i;\\n            \\n            // rigth subarrays sum from prefix sum of prefix sum from left to right\\n            rightSum = rightPrefixSumPrefixSum[rightIndex] - (i>0 ? rightPrefixSumPrefixSum[i-1] + (rightPrefixSum[i-1] * rightSize) : 0L);\\n            \\n            // left subarrays sum from prefix sum of prefix sum from right to left\\n            leftSum = leftPrefixSumPrefixSum[leftIndex] - (i<size-1 ? leftPrefixSumPrefixSum[i+1] + (leftPrefixSum[i+1] * leftSize) : 0L);                \\n            \\n            // total subarray sums => left sum * right size + right sum * left size - current value * left size * right size            \\n            totalSum = ((rightSum%MOD * leftSize) + (leftSum%MOD * rightSize) - ((long long)strength[i] * (leftSize * rightSize)) + MOD)%MOD;\\n            \\n            totalStrength = (totalStrength + (totalSum * (long long)strength[i])%MOD ) %MOD;\\n        }\\n        \\n        return totalStrength;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nWe have to calculate the sum of the strength of all subarray.\\n\\nWe can know on how many subarrays each element will contribute as Min Element\\nand we can also know the sum of those subarray elements using Prefix Sum of Prefix Sum.\\n\\nUsing Prefix Sum of Prefix Sum array we can know the all subarray sum in the left and the\\nright. We can get the Total subarry sum using formula \\n\\nTotal Sum = Left Sum * Right Size + Right Sum * Left Size - Current Value * Left Size * Right Size\\n\\nLeft Sum will contribute to the subarrays sum Right Size time and Right Sum will contribute to\\nthe subarrays sum Left Size time and we have to deduct the current value from Total Sum\\nas we considered it extra Left Size * Right Size times. \\n\\nHere Left Sum is the subarrys sums from left index to current index inclusive and same for Left Size. \\nSimilarly Right Sum is the subarray sums from current index to right index inclusive and same for Right Size.\\n\\nLeft Index => Max (Left index till value >= current value, previous index of current value)\\nRight Index => Right index till value >= current value\\n\\nHere we calculate Left Index till the previous index of current value so that we do not\\ncalculate the same subarray twice.\\n\\nWe can easily get the left and right index till value >= current value using Monotonic Stack.\\n```\n```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& strength) {\\n        \\n        int size = strength.size();\\n        \\n        long long MOD = 1000000007L;\\n        \\n        // left to right prefix sum and prefix sum of prefix sum\\n        vector<long long>rightPrefixSum(size);\\n        vector<long long>rightPrefixSumPrefixSum(size);\\n        \\n        rightPrefixSum[0] = strength[0];\\n        rightPrefixSumPrefixSum[0] = strength[0];\\n        \\n        for(int i=1;i<size;i++)\\n        {\\n            rightPrefixSum[i] = rightPrefixSum[i-1] + strength[i];\\n            rightPrefixSumPrefixSum[i] = rightPrefixSumPrefixSum[i-1] + rightPrefixSum[i];\\n        }\\n        \\n        // right to left prefix sum and prefix sum of prefix sum\\n        vector<long long>leftPrefixSum(size);\\n        vector<long long>leftPrefixSumPrefixSum(size);\\n\\n        leftPrefixSum[size-1] = strength[size-1];\\n        leftPrefixSumPrefixSum[size-1] = strength[size-1];\\n        \\n        for(int i=size-2;i>=0;i--)\\n        {\\n            leftPrefixSum[i] = leftPrefixSum[i+1] + strength[i];\\n            leftPrefixSumPrefixSum[i] = leftPrefixSumPrefixSum[i+1] + leftPrefixSum[i];\\n        }\\n        \\n        \\n        // monotonic stack to get the right index with value < current value\\n        stack<int>rstak;        \\n        \\n        // store right index for current index till value >= current index value\\n        vector<int>rightIndexes(size);\\n        \\n        for(int i=size-1;i>=0;i--)\\n        {\\n            // remove values >= current value\\n            while(!rstak.empty() && strength[rstak.top()]>=strength[i])rstak.pop();\\n            \\n            rightIndexes[i] = rstak.empty() ? size-1 : rstak.top() - 1;\\n            \\n            rstak.push(i);\\n        }\\n        \\n\\n\\n        // monotonic stack to get the left index with value < current value\\n        stack<int>lstak;\\n        \\n        // store previous index of current value\\n        unordered_map<int,int>leftIndexes;\\n        \\n        int leftIndex,rightIndex;\\n        long long rightSum, leftSum,totalSum,leftSize,rightSize;\\n        \\n        // sum of all subarray strengths\\n        long long totalStrength = 0L;\\n        \\n        for(int i=0;i<size;i++)\\n        {\\n            leftIndex = leftIndexes.find(strength[i])==leftIndexes.end() ? 0 : leftIndexes[strength[i]] + 1;\\n            \\n            // remove value >= current value\\n            while(!lstak.empty() && strength[lstak.top()]>=strength[i])lstak.pop();\\n            \\n            // left index => max (left index, previous index of current value)\\n            leftIndex = max(leftIndex, lstak.empty() ? 0 : lstak.top() + 1);\\n            rightIndex = rightIndexes[i];\\n            \\n            // get left and right subarray size from current index inclusive\\n            leftSize = i - leftIndex + 1;\\n            rightSize = rightIndex - i + 1;\\n            \\n            lstak.push(i);\\n            leftIndexes[strength[i]]=i;\\n            \\n            // rigth subarrays sum from prefix sum of prefix sum from left to right\\n            rightSum = rightPrefixSumPrefixSum[rightIndex] - (i>0 ? rightPrefixSumPrefixSum[i-1] + (rightPrefixSum[i-1] * rightSize) : 0L);\\n            \\n            // left subarrays sum from prefix sum of prefix sum from right to left\\n            leftSum = leftPrefixSumPrefixSum[leftIndex] - (i<size-1 ? leftPrefixSumPrefixSum[i+1] + (leftPrefixSum[i+1] * leftSize) : 0L);                \\n            \\n            // total subarray sums => left sum * right size + right sum * left size - current value * left size * right size            \\n            totalSum = ((rightSum%MOD * leftSize) + (leftSum%MOD * rightSize) - ((long long)strength[i] * (leftSize * rightSize)) + MOD)%MOD;\\n            \\n            totalStrength = (totalStrength + (totalSum * (long long)strength[i])%MOD ) %MOD;\\n        }\\n        \\n        return totalStrength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063032,
                "title": "python-3-pass-solution",
                "content": "For the sake of variety...\\n\\nMain idea: as the subarray extends from the current index backward, the `min()` of the subarray can only decrease, so use a monotonic stack to keep track of that. In addition, keep track of the sum of these `min()`. It\\'s then trivial to update the `running` contribution of the next value if the input is strictly increasing. When it\\'s not, use the \"prefix sum of the prefix sum\" trick to calculate the correction.\\n\\n```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        mod = 10 ** 9 + 7\\n        ans = 0\\n        min_stack = []\\n        min_total = 0\\n        running = 0\\n        acc = list(itertools.accumulate(strength))\\n        accacc = list(itertools.accumulate(acc))\\n        acc.append(0)\\n        accacc.append(0)\\n        accacc.append(0)\\n        for i, x in enumerate(strength):\\n            left = i\\n            while min_stack and min_stack[-1][0] >= x:\\n                old_min, index = min_stack.pop()\\n                running -= (old_min - x) * (acc[i - 1] * (left - index) - (accacc[left - 2] - accacc[index - 2]))\\n                min_total -= (old_min - x) * (left - index)\\n                left = index\\n            min_stack.append((x, left))\\n            min_total += x\\n            running += min_total * x\\n            ans += running\\n            ans %= mod\\n        return ans   \\n```\\nObviously `O(n)` in both space & time. I attempted this during the contest but couldn\\'t think of the prefix sum of the prefix sum trick\\uD83D\\uDE22",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        mod = 10 ** 9 + 7\\n        ans = 0\\n        min_stack = []\\n        min_total = 0\\n        running = 0\\n        acc = list(itertools.accumulate(strength))\\n        accacc = list(itertools.accumulate(acc))\\n        acc.append(0)\\n        accacc.append(0)\\n        accacc.append(0)\\n        for i, x in enumerate(strength):\\n            left = i\\n            while min_stack and min_stack[-1][0] >= x:\\n                old_min, index = min_stack.pop()\\n                running -= (old_min - x) * (acc[i - 1] * (left - index) - (accacc[left - 2] - accacc[index - 2]))\\n                min_total -= (old_min - x) * (left - index)\\n                left = index\\n            min_stack.append((x, left))\\n            min_total += x\\n            running += min_total * x\\n            ans += running\\n            ans %= mod\\n        return ans   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062581,
                "title": "improvement-to-question-dp-with-one-pass-bottom-up-calculation",
                "content": "Coming up with the formula makes this a trick question; I suggest to reduce the size of the test cases, from 10 million numbers to 10 k or so, and this way, other reasonable code will work. It is hard to imagine any application using such extreme problem size. So, why make this a nightmare and trick question?\\n\\nBelow code solves 68 out of 80 test cases; for the rest of test cases, Time Limit Exceeded, liikely because of size.\\n\\n```\\nclass Solution {\\n    public int totalStrength(int[] strength) {\\n        \\n        int[] sumFromBegin = new int[strength.length + 1];\\n        int sum = 0;\\n        for (int i = 0; i < strength.length; i++) {\\n            sum += strength[i];\\n            sumFromBegin[i+1] = sum;\\n        }\\n        sumFromBegin[0] = 0;\\n        // sum(i , j) start inclusive, end inclusive --> sumFromBegin[j] - sumFromBegin[i]\\n\\n        long grandSum = 0;\\n        int[] mins = new int[strength.length];\\n        int[] work = new int[strength.length];\\n        for (int i = 0; i < strength.length; i++) {\\n            work[i] = strength[i] * strength[i];\\n            grandSum += (int) work[i];\\n            mins[i] = strength[i];\\n        }        \\n\\n        for (int k = 0; k < strength.length - 1; k++) {\\n            for (int j = 1; j < strength.length - k; j++) {\\n                int min = Math.min(mins[j],mins[j-1]);\\n                int localSum = sumFromBegin[j+k+1] - sumFromBegin[j-1];\\n                work[j-1] = min * localSum;\\n                mins[j-1] = min; // overwrite mins for next level\\n            }\\n            for (int i = 0; i < strength.length - k - 1; i++) {\\n                grandSum = (grandSum + work[i]) % 1000000007;\\n            }\\n        }\\n        return (int)(grandSum  % 1000000007);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int totalStrength(int[] strength) {\\n        \\n        int[] sumFromBegin = new int[strength.length + 1];\\n        int sum = 0;\\n        for (int i = 0; i < strength.length; i++) {\\n            sum += strength[i];\\n            sumFromBegin[i+1] = sum;\\n        }\\n        sumFromBegin[0] = 0;\\n        // sum(i , j) start inclusive, end inclusive --> sumFromBegin[j] - sumFromBegin[i]\\n\\n        long grandSum = 0;\\n        int[] mins = new int[strength.length];\\n        int[] work = new int[strength.length];\\n        for (int i = 0; i < strength.length; i++) {\\n            work[i] = strength[i] * strength[i];\\n            grandSum += (int) work[i];\\n            mins[i] = strength[i];\\n        }        \\n\\n        for (int k = 0; k < strength.length - 1; k++) {\\n            for (int j = 1; j < strength.length - k; j++) {\\n                int min = Math.min(mins[j],mins[j-1]);\\n                int localSum = sumFromBegin[j+k+1] - sumFromBegin[j-1];\\n                work[j-1] = min * localSum;\\n                mins[j-1] = min; // overwrite mins for next level\\n            }\\n            for (int i = 0; i < strength.length - k - 1; i++) {\\n                grandSum = (grandSum + work[i]) % 1000000007;\\n            }\\n        }\\n        return (int)(grandSum  % 1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062410,
                "title": "java-divide-and-conquer-need-help-74-80",
                "content": "Update: fixed, but TLE on test case 74\\n\\n![image](https://assets.leetcode.com/users/images/1780a3cb-a0bf-48f6-b154-98fde8be2fe3_1653207808.3808346.png)\\n\\n\\n\\n```java\\nclass Solution {\\n    public int totalStrength(int[] strength) {\\n        int n = strength.length;\\n        return (int) cal(strength, 0, n - 1);\\n    }\\n\\n    private long cal(int[] strength, int start, int end) {\\n        long mod = 1000000007;\\n        if (start > end) {\\n            return 0;\\n        }\\n        if (start == end) {\\n            return (long) strength[start] * strength[end] % mod;\\n        }\\n        int index = start;\\n        int mid = start + (end - start) / 2;\\n        for (int i = start; i <= end; i++) {\\n            if (strength[i] < min) {\\n                min = strength[i];\\n                index = i;\\n            }\\n        }\\n        long res = min % mod * min % mod * (index - start + 1) % mod * (end - index + 1) % mod;\\n        long left = index - start;\\n        long right = end - index;\\n        for (int i = start; i < index; i++) {\\n            long leftGroup = i - start + 1;\\n            long rightGroup = right + 1;\\n            res = (res + strength[i] % mod * leftGroup % mod * rightGroup % mod * min % mod) % mod;\\n        }\\n        for (int i = index + 1; i <= end; i++) {\\n            long leftGroup = left + 1;\\n            long rightGroup = end - i + 1;\\n            res = (res + strength[i] % mod * leftGroup % mod * rightGroup % mod * min % mod) % mod;\\n        }\\n        return ((res + cal(strength, start, index - 1)) % mod + cal(strength, index + 1, end)) % mod;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int totalStrength(int[] strength) {\\n        int n = strength.length;\\n        return (int) cal(strength, 0, n - 1);\\n    }\\n\\n    private long cal(int[] strength, int start, int end) {\\n        long mod = 1000000007;\\n        if (start > end) {\\n            return 0;\\n        }\\n        if (start == end) {\\n            return (long) strength[start] * strength[end] % mod;\\n        }\\n        int index = start;\\n        int mid = start + (end - start) / 2;\\n        for (int i = start; i <= end; i++) {\\n            if (strength[i] < min) {\\n                min = strength[i];\\n                index = i;\\n            }\\n        }\\n        long res = min % mod * min % mod * (index - start + 1) % mod * (end - index + 1) % mod;\\n        long left = index - start;\\n        long right = end - index;\\n        for (int i = start; i < index; i++) {\\n            long leftGroup = i - start + 1;\\n            long rightGroup = right + 1;\\n            res = (res + strength[i] % mod * leftGroup % mod * rightGroup % mod * min % mod) % mod;\\n        }\\n        for (int i = index + 1; i <= end; i++) {\\n            long leftGroup = left + 1;\\n            long rightGroup = end - i + 1;\\n            res = (res + strength[i] % mod * leftGroup % mod * rightGroup % mod * min % mod) % mod;\\n        }\\n        return ((res + cal(strength, start, index - 1)) % mod + cal(strength, index + 1, end)) % mod;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061880,
                "title": "c-2281-sum-of-total-strength-of-wizards",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& strength) {\\n        int MOD = 1\\'000\\'000\\'007, n = strength.size(); \\n        vector<long> pw(1), ps(1); \\n        for (long i = 0; i < n; ++i) {\\n            pw.push_back((pw.back() + (i+1)*strength[i]) % MOD); \\n            ps.push_back((ps.back() + strength[i]) % MOD); \\n        }\\n        \\n        vector<long> sw(1), ss(1); \\n        for (long i = n-1; i >= 0; --i) {\\n            sw.push_back((sw.back() + (n-i)*strength[i]) % MOD); \\n            ss.push_back((ss.back() + strength[i]) % MOD); \\n        }\\n        \\n        reverse(sw.begin(), sw.end()); \\n        reverse(ss.begin(), ss.end()); \\n        \\n        long ans = 0; \\n        stack<int> stk; \\n        strength.push_back(0); \\n        for (int i = 0; i < strength.size(); ++i) {\\n            while (stk.size() && strength[stk.top()] >= strength[i]) {\\n                int mid = stk.top(); stk.pop(); \\n                int lo = -1; \\n                if (stk.size()) lo = stk.top(); \\n                long left = (long) strength[mid] * (pw[mid+1] - pw[lo+1] - (ps[mid+1] - ps[lo+1]) * (lo+1) % MOD) % MOD * (i-mid) % MOD; \\n                long right = (long) strength[mid] * (sw[mid+1] - sw[i] - (ss[mid+1] - ss[i]) * (n-i) % MOD) % MOD * (mid - lo) % MOD; \\n                ans = (ans + left + right) % MOD; \\n            }\\n            stk.push(i); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& strength) {\\n        int MOD = 1\\'000\\'000\\'007, n = strength.size(); \\n        vector<long> pw(1), ps(1); \\n        for (long i = 0; i < n; ++i) {\\n            pw.push_back((pw.back() + (i+1)*strength[i]) % MOD); \\n            ps.push_back((ps.back() + strength[i]) % MOD); \\n        }\\n        \\n        vector<long> sw(1), ss(1); \\n        for (long i = n-1; i >= 0; --i) {\\n            sw.push_back((sw.back() + (n-i)*strength[i]) % MOD); \\n            ss.push_back((ss.back() + strength[i]) % MOD); \\n        }\\n        \\n        reverse(sw.begin(), sw.end()); \\n        reverse(ss.begin(), ss.end()); \\n        \\n        long ans = 0; \\n        stack<int> stk; \\n        strength.push_back(0); \\n        for (int i = 0; i < strength.size(); ++i) {\\n            while (stk.size() && strength[stk.top()] >= strength[i]) {\\n                int mid = stk.top(); stk.pop(); \\n                int lo = -1; \\n                if (stk.size()) lo = stk.top(); \\n                long left = (long) strength[mid] * (pw[mid+1] - pw[lo+1] - (ps[mid+1] - ps[lo+1]) * (lo+1) % MOD) % MOD * (i-mid) % MOD; \\n                long right = (long) strength[mid] * (sw[mid+1] - sw[i] - (ss[mid+1] - ss[i]) * (n-i) % MOD) % MOD * (mid - lo) % MOD; \\n                ans = (ans + left + right) % MOD; \\n            }\\n            stk.push(i); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963794,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int totalStrength(vector<int>& strength) {\\n    constexpr int kMod = 1\\'000\\'000\\'007;\\n    const int n = strength.size();\\n    vector<long> prefix(n);\\n    vector<long> prefixOfPrefix(n + 1);\\n    // left[i] := next index on the left (if any)\\n    //            s.t. nums[left[i]] <= nums[i]\\n    vector<int> left(n, -1);\\n    // right[i] := next index on the right (if any)\\n    //             s.t. nums[right[i]] < nums[i]\\n    vector<int> right(n, n);\\n    stack<int> stack;\\n\\n    for (int i = 0; i < n; ++i)\\n      prefix[i] = i == 0 ? strength[0] : (strength[i] + prefix[i - 1]) % kMod;\\n\\n    for (int i = 0; i < n; ++i)\\n      prefixOfPrefix[i + 1] = (prefixOfPrefix[i] + prefix[i]) % kMod;\\n\\n    for (int i = n - 1; i >= 0; --i) {\\n      while (!stack.empty() && strength[stack.top()] >= strength[i])\\n        left[stack.top()] = i, stack.pop();\\n      stack.push(i);\\n    }\\n\\n    stack = std::stack<int>();\\n\\n    for (int i = 0; i < n; ++i) {\\n      while (!stack.empty() && strength[stack.top()] > strength[i])\\n        right[stack.top()] = i, stack.pop();\\n      stack.push(i);\\n    }\\n\\n    long ans = 0;\\n\\n    // For each strength[i] as minimum, calculate sum.\\n    for (int i = 0; i < n; ++i) {\\n      const int l = left[i];\\n      const int r = right[i];\\n      const long leftSum = prefixOfPrefix[i] - prefixOfPrefix[max(0, l)];\\n      const long rightSum = prefixOfPrefix[r] - prefixOfPrefix[i];\\n      const int leftLen = i - l;\\n      const int rightLen = r - i;\\n      ans += strength[i] *\\n             (rightSum * leftLen % kMod - leftSum * rightLen % kMod + kMod) %\\n             kMod;\\n      ans %= kMod;\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int totalStrength(vector<int>& strength) {\\n    constexpr int kMod = 1\\'000\\'000\\'007;\\n    const int n = strength.size();\\n    vector<long> prefix(n);\\n    vector<long> prefixOfPrefix(n + 1);\\n    // left[i] := next index on the left (if any)\\n    //            s.t. nums[left[i]] <= nums[i]\\n    vector<int> left(n, -1);\\n    // right[i] := next index on the right (if any)\\n    //             s.t. nums[right[i]] < nums[i]\\n    vector<int> right(n, n);\\n    stack<int> stack;\\n\\n    for (int i = 0; i < n; ++i)\\n      prefix[i] = i == 0 ? strength[0] : (strength[i] + prefix[i - 1]) % kMod;\\n\\n    for (int i = 0; i < n; ++i)\\n      prefixOfPrefix[i + 1] = (prefixOfPrefix[i] + prefix[i]) % kMod;\\n\\n    for (int i = n - 1; i >= 0; --i) {\\n      while (!stack.empty() && strength[stack.top()] >= strength[i])\\n        left[stack.top()] = i, stack.pop();\\n      stack.push(i);\\n    }\\n\\n    stack = std::stack<int>();\\n\\n    for (int i = 0; i < n; ++i) {\\n      while (!stack.empty() && strength[stack.top()] > strength[i])\\n        right[stack.top()] = i, stack.pop();\\n      stack.push(i);\\n    }\\n\\n    long ans = 0;\\n\\n    // For each strength[i] as minimum, calculate sum.\\n    for (int i = 0; i < n; ++i) {\\n      const int l = left[i];\\n      const int r = right[i];\\n      const long leftSum = prefixOfPrefix[i] - prefixOfPrefix[max(0, l)];\\n      const long rightSum = prefixOfPrefix[r] - prefixOfPrefix[i];\\n      const int leftLen = i - l;\\n      const int rightLen = r - i;\\n      ans += strength[i] *\\n             (rightSum * leftLen % kMod - leftSum * rightLen % kMod + kMod) %\\n             kMod;\\n      ans %= kMod;\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949034,
                "title": "stack-and-presum-solution",
                "content": "# Approach\\n![Pasted Graphic 72.png](https://assets.leetcode.com/users/images/f312fcd6-d95a-4125-93b5-d7adab2a4b2b_1692777992.887592.png)\\n![Pasted Graphic 73.png](https://assets.leetcode.com/users/images/402a9278-4ab8-4482-accf-446bb6c33ffc_1692778002.273974.png)\\n\\n\\n# Complexity\\n- Time complexity:\\nleft_index:O(n)\\nright_index:O(n)\\nsum of subarrays:O(n)\\n\\n- Space complexity:\\nleft_index:O(n)\\nright_index:O(n)\\ntemp_stack:O(n)\\nO(n)+O(n)+O(n) -> O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        mod,n = 10**9+7,len(strength) \\n        res=0\\n        # index list used for indicate left and right index for S[i] which S[i] is minimal value in S[left_index -> right_index],so S[i] should non-larger than s[index]\\n        # Q: how to indicate if it\\'s large than both left and right? ,just like 4 in [2,3,4,3,2]\\n        left_index=[-1] * n\\n        right_index=[n] * n\\n        #stack used for calculate left and right index\\n        temp_stack=[]\\n        for index in range(n):\\n            #Find the first right index which is non-larger than \\n            while temp_stack and strength[temp_stack[-1]] > strength[index]:\\n                right_index[temp_stack[-1]]=index\\n                temp_stack.pop()\\n            temp_stack.append(index)\\n\\n        temp_stack=[]\\n        for index in range(n-1,-1,-1):\\n            while temp_stack and strength[temp_stack[-1]] >= strength[index]:\\n                left_index[temp_stack[-1]]=index\\n                temp_stack.pop()\\n            temp_stack.append(index)\\n        presum=list(accumulate(strength,initial=0))\\n        prepresum=list(accumulate(presum,initial=0))\\n        for index in range(len(strength)):\\n            left_bound=left_index[index] + 1\\n            right_bound=right_index[index] -1\\n            #calculate sum of any subarray with minimal vaule S[i]\\n            positive_sum=(index-left_bound+1)*(prepresum[right_bound+2]-prepresum[index+1])\\n            negtive_sum = (right_bound-index+1)*(prepresum[index+1]-prepresum[left_bound])\\n            subarray_sum=positive_sum-negtive_sum\\n            res += strength[index]*subarray_sum\\n        return res%mod\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        mod,n = 10**9+7,len(strength) \\n        res=0\\n        # index list used for indicate left and right index for S[i] which S[i] is minimal value in S[left_index -> right_index],so S[i] should non-larger than s[index]\\n        # Q: how to indicate if it\\'s large than both left and right? ,just like 4 in [2,3,4,3,2]\\n        left_index=[-1] * n\\n        right_index=[n] * n\\n        #stack used for calculate left and right index\\n        temp_stack=[]\\n        for index in range(n):\\n            #Find the first right index which is non-larger than \\n            while temp_stack and strength[temp_stack[-1]] > strength[index]:\\n                right_index[temp_stack[-1]]=index\\n                temp_stack.pop()\\n            temp_stack.append(index)\\n\\n        temp_stack=[]\\n        for index in range(n-1,-1,-1):\\n            while temp_stack and strength[temp_stack[-1]] >= strength[index]:\\n                left_index[temp_stack[-1]]=index\\n                temp_stack.pop()\\n            temp_stack.append(index)\\n        presum=list(accumulate(strength,initial=0))\\n        prepresum=list(accumulate(presum,initial=0))\\n        for index in range(len(strength)):\\n            left_bound=left_index[index] + 1\\n            right_bound=right_index[index] -1\\n            #calculate sum of any subarray with minimal vaule S[i]\\n            positive_sum=(index-left_bound+1)*(prepresum[right_bound+2]-prepresum[index+1])\\n            negtive_sum = (right_bound-index+1)*(prepresum[index+1]-prepresum[left_bound])\\n            subarray_sum=positive_sum-negtive_sum\\n            res += strength[index]*subarray_sum\\n        return res%mod\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947193,
                "title": "clean-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& strength) {\\n        int n = strength.size() ; \\n        vector<long long > psum(n+1,0LL),ppsum(n+2,0LL) ; \\n        vector<int>l(n,-1),r(n,n) ; \\n        long long mod = 1e9+7;\\n\\n        //calculating prefix sum as well as prefix of prefix sum \\n        for(int i = 0 ; i<=n; i++)\\n        {\\n            if(i<n) psum[i+1] = (psum[i]+strength[i])%mod ; \\n            ppsum[i+1] = (ppsum[i]+psum[i])%mod;\\n        }\\n\\n        //found left smallest and right smallest  \\n        stack<int>s ;\\n        for(int i = 0 ;i<n;i++)\\n        {\\n            while(s.size() and strength[s.top()] >= strength[i])\\n            {\\n                r[s.top()] = i ; \\n                s.pop();\\n            }\\n            l[i] = s.size()?s.top():-1 ;\\n            s.push(i);\\n        }\\n\\n        /* some maths ,explained here-> [https://leetcode.com/problems/sum-of-total-strength-of-wizards/solutions/2062017/]()c-prefix-monotonic-stack-o-n-solution-with-thought-process/ */\\n\\n        long long ans = 0 ; \\n\\n        for(int i = 0 ; i<n;i++)\\n        {\\n            ans += \\n            (\\n                (\\n                    (ppsum[r[i]+1]-ppsum[i+1]) * (i-l[i]) %mod +\\n                    2*mod -\\n                    (ppsum[i+1]-ppsum[l[i]+1]) * (r[i]-i) %mod\\n                ) \\n                * strength[i] %mod\\n            );\\n\\n            ans %= mod ; \\n        }\\n\\n        return (int) ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& strength) {\\n        int n = strength.size() ; \\n        vector<long long > psum(n+1,0LL),ppsum(n+2,0LL) ; \\n        vector<int>l(n,-1),r(n,n) ; \\n        long long mod = 1e9+7;\\n\\n        //calculating prefix sum as well as prefix of prefix sum \\n        for(int i = 0 ; i<=n; i++)\\n        {\\n            if(i<n) psum[i+1] = (psum[i]+strength[i])%mod ; \\n            ppsum[i+1] = (ppsum[i]+psum[i])%mod;\\n        }\\n\\n        //found left smallest and right smallest  \\n        stack<int>s ;\\n        for(int i = 0 ;i<n;i++)\\n        {\\n            while(s.size() and strength[s.top()] >= strength[i])\\n            {\\n                r[s.top()] = i ; \\n                s.pop();\\n            }\\n            l[i] = s.size()?s.top():-1 ;\\n            s.push(i);\\n        }\\n\\n        /* some maths ,explained here-> [https://leetcode.com/problems/sum-of-total-strength-of-wizards/solutions/2062017/]()c-prefix-monotonic-stack-o-n-solution-with-thought-process/ */\\n\\n        long long ans = 0 ; \\n\\n        for(int i = 0 ; i<n;i++)\\n        {\\n            ans += \\n            (\\n                (\\n                    (ppsum[r[i]+1]-ppsum[i+1]) * (i-l[i]) %mod +\\n                    2*mod -\\n                    (ppsum[i+1]-ppsum[l[i]+1]) * (r[i]-i) %mod\\n                ) \\n                * strength[i] %mod\\n            );\\n\\n            ans %= mod ; \\n        }\\n\\n        return (int) ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907258,
                "title": "sum-of-total-strength-of-wizards-c-monotonic-stack-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& s) {\\n        int n = s.size();\\n        int m = 1e9+7;\\n        vector<int> pref(n+1);\\n        vector<int> dpref(n+2);\\n        for(int i = 1;i<=n;i++){\\n            pref[i]= (pref[i-1] + s[i-1])%m;\\n        }\\n        for(int i = 1;i<=n+1;i++){\\n            dpref[i]=(dpref[i-1] + pref[i-1])%m;\\n        }\\n        stack<int> st;\\n        long long ans = 0;\\n        for(int i =0;i<=n;i++){\\n            while(!st.empty() and (i==n || s[st.top()]>s[i])){\\n                long long mi = st.top();\\n                st.pop();\\n                //fromula - [dpref[right +1] - dpref[i+1]]*(i-Left) - [dpref[i+1] - dpref[left+1]]*(right-i)\\n                long long lb = st.empty()?-1:st.top(); //first term\\n                long long ft = 1L*(dpref[i+1]- dpref[mi+1]) % m; \\n                ft = (ft * (mi-lb) ) % m;\\n                long long st = 1L * (dpref[mi + 1] - dpref[lb+1]) %m;\\n                st = (st * (i - mi)) % m;\\n                long long tans = 1L * ((ft-st) + m)%m;\\n                tans = (tans * s[mi])%m;\\n                ans = (ans + tans)%m;\\n                ans%=m;\\n            }\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& s) {\\n        int n = s.size();\\n        int m = 1e9+7;\\n        vector<int> pref(n+1);\\n        vector<int> dpref(n+2);\\n        for(int i = 1;i<=n;i++){\\n            pref[i]= (pref[i-1] + s[i-1])%m;\\n        }\\n        for(int i = 1;i<=n+1;i++){\\n            dpref[i]=(dpref[i-1] + pref[i-1])%m;\\n        }\\n        stack<int> st;\\n        long long ans = 0;\\n        for(int i =0;i<=n;i++){\\n            while(!st.empty() and (i==n || s[st.top()]>s[i])){\\n                long long mi = st.top();\\n                st.pop();\\n                //fromula - [dpref[right +1] - dpref[i+1]]*(i-Left) - [dpref[i+1] - dpref[left+1]]*(right-i)\\n                long long lb = st.empty()?-1:st.top(); //first term\\n                long long ft = 1L*(dpref[i+1]- dpref[mi+1]) % m; \\n                ft = (ft * (mi-lb) ) % m;\\n                long long st = 1L * (dpref[mi + 1] - dpref[lb+1]) %m;\\n                st = (st * (i - mi)) % m;\\n                long long tans = 1L * ((ft-st) + m)%m;\\n                tans = (tans * s[mi])%m;\\n                ans = (ans + tans)%m;\\n                ans%=m;\\n            }\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848625,
                "title": "prefix-sum-of-prefix-sums",
                "content": "```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        M = 10 ** 9 + 7\\n        n = len(strength)\\n        stack = []\\n        next_smaller = [n] * n\\n        prev_smaller = [-1] * n\\n        for i in range(n):\\n            while len(stack) > 0 and strength[i] < strength[stack[-1]]:\\n                curr = stack.pop()\\n                next_smaller[curr] = i\\n            if len(stack) > 0:\\n                prev_smaller[i] = stack[-1]\\n            stack.append(i)\\n        p = [0] * (n + 1)\\n        for i in range(n):\\n            p[i + 1] += p[i] + strength[i]\\n        pp = [0] * (n + 2)\\n        for i in range(n + 1):\\n            pp[i + 1] += pp[i] + p[i]\\n        res = 0\\n        for i in range(n):\\n            l = prev_smaller[i]\\n            r = next_smaller[i]\\n            res += strength[i] * (i - l) * (pp[r + 1] - pp[i + 1])\\n            res %= M\\n            res -= strength[i] * (r - i) * (pp[i + 1] - pp[l + 1])\\n            res %= M\\n        res = (M + res) % M\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        M = 10 ** 9 + 7\\n        n = len(strength)\\n        stack = []\\n        next_smaller = [n] * n\\n        prev_smaller = [-1] * n\\n        for i in range(n):\\n            while len(stack) > 0 and strength[i] < strength[stack[-1]]:\\n                curr = stack.pop()\\n                next_smaller[curr] = i\\n            if len(stack) > 0:\\n                prev_smaller[i] = stack[-1]\\n            stack.append(i)\\n        p = [0] * (n + 1)\\n        for i in range(n):\\n            p[i + 1] += p[i] + strength[i]\\n        pp = [0] * (n + 2)\\n        for i in range(n + 1):\\n            pp[i + 1] += pp[i] + p[i]\\n        res = 0\\n        for i in range(n):\\n            l = prev_smaller[i]\\n            r = next_smaller[i]\\n            res += strength[i] * (i - l) * (pp[r + 1] - pp[i + 1])\\n            res %= M\\n            res -= strength[i] * (r - i) * (pp[i + 1] - pp[l + 1])\\n            res %= M\\n        res = (M + res) % M\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819355,
                "title": "python-o-n-prefix-sum-of-prefix-sum",
                "content": "Honestly speaking, this was quite a tricky question for me. \\n\\nIt was easy to break this problem into sub-problems because there are several other problems where we do the same thing that we do in this problem.\\n\\nJust for reference, here is one such problem -> https://leetcode.com/problems/sum-of-subarray-minimums/\\nHere is my solution for this problem -> https://leetcode.com/problems/sum-of-subarray-minimums/discuss/3080727/Python-Combination-of-NSL-and-NSR\\n\\nI\\'ll explain later in the optimal solution how we use the same concept that we use in the \"Sum of Subarray Minimums\" problem.\\n\\n# **BRUTE FORCE SOLUTION - O(N^2)**\\n\\nFirst, here, the brute force solution for this problem which obviously fails on large test cases.\\n\\n```\\ndef totalStrength(self, strength: List[int]) -> int:\\n        \\n        # Final Output to return\\n        output = 0\\n        \\n        # Mod\\n        mod = 10**9 + 7\\n        \\n        # Length of the list\\n        n = len(strength)\\n        \\n        # Let\\'s take each element and consider it as the first element of subarray\\n        for i in range(n):\\n            \\n            # Sum of subarray starting with element at index \"i\"\\n            subarraySum = 0\\n            \\n            # Smallest Element of subarray\\n            smallestElement = strength[i]\\n            \\n            # Now, we go through the elements from i to n\\n            # And as we incorporate each element in current subarray, we will keep updating the output\\n            # Since we will keep getting new subarrays as we add new elements\\n            for j in range(i, n):\\n                \\n                # Update the sum of this subarray\\n                subarraySum += strength[j]\\n                \\n                # Update the smallestElement of this subarray\\n                smallestElement = min(smallestElement, strength[j])\\n                \\n                # Update the output\\n                output = (output + ( subarraySum * smallestElement)) % mod\\n\\n        \\n        # Return the output\\n        return output\\n```\\n\\n# **OPTIMAL SOLUTION - O(N)**\\n\\nLet\\'s break down this problem into sub-problems. \\n\\nBasically, in this problem, we want to take each subarray, take its sum and multiply the sum by the minimum element of that subarray.\\n\\n\\tFor example, suppose we have strength = [4,3,1,2]\\n\\t\\n\\tAll the subarrays and their min elements and sum will be \\n\\t[4] => Minimum Element = 4 and Sum = 4\\n\\t[3] => Minimum Element = 3 and Sum = 3\\n\\t[1] => Minimum Element = 1 and Sum = 1\\n\\t[2] => Minimum Element = 2 and Sum = 2\\n\\t[4,3] => Minimum Element = 3 and Sum = 7\\n\\t[3,1] => Minimum Element = 1 and Sum = 4\\n\\t[1,2] => Minimum Element = 1 and Sum = 3\\n\\t[4,3,1] => Minimum Element = 1 and Sum = 8\\n\\t[3,1,2] => Minimum Element = 1 and Sum = 6\\n\\t[4,3,1,2] => Minimum Element = 1 and Sum = 10\\n\\n\\nSo, just to group everything nicely, let\\'s take each element and see what all subarrays are there when it is the minimum element in those subarrays.\\n\\n\\tFor element 4, we have only one subarray where it is the minimum - \\n\\t\\t\\n\\t\\t[4] => Min = 4, Total Sum = 4 => 4 * 4 => 16\\n\\t\\n\\tFor element 3, we have two subarrays where it is the minimum -\\n\\t\\n\\t   [3] and [4,3] => Min = 3, Total Sum = 10 => 3 * 10 => 30\\n\\t   \\n\\tFor element 1, we have 6 subarrays where it is the minimum -\\n\\t\\n\\t [1], [3,1], [1,2], [4,3,1], [3,1,2], [4,3,1,2] => Min = 1, Total Sum = 32 => 1 * 32 => 32\\n\\n\\n\\tFor element 2, we have only one subarray where it is the minimum -\\n\\t\\n\\t[2] => Min = 2 Total Sum = 2 => 2 * 2 => 4\\n\\t\\n\\nSo, Overall total => 16 + 30 + 32 + 4  => 82\\n\\n\\nFrom this example, we see that we can divide this problem in two subproblems - \\n\\n\\t1. First, for each element, find what all subarrays are there in which it is the minimum\\n\\t2. Find the sum for all those subarrays and multiply that sum by the minimum element\\n\\n\\nSolving the subproblem 1 is pretty easy if you have done problems such as https://leetcode.com/problems/sum-of-subarray-minimums/\\n\\nWe will use stack to get the Nearest Smaller on Left & Nearest Smaller on Right data for the input list. And using that, we can then find for every index, what is the boundary.\\n\\n\\tFor example, for strength = [4,3,1,2]\\n\\n\\tNearest Smaller on left data = [-1,-1,-1,2]\\n\\t\\n\\tNearest Smaller on Right Data = [1,2,4,4]\\n\\t\\n\\tEach value in above two lists is an index. \\n\\t-1 basically means there is no smaller element to the left.\\n\\t4 means there is no smaller element to the right.\\n\\t\\n\\tSo, from this data, what can we infer?\\n\\t\\n\\tLet\\'s take the element 1 at index \"2\"\\n\\t\\n\\tFor index = 2, NSL[2] = -1 and NSR[2] = 4\\n\\t\\n\\tIt means, for element 1, there is no smaller element on left or right\\n\\t\\n\\tSo, it basically means all the subarrays that have \"1\" in them will have \"1\" as the minimum element.\\n\\t\\n\\tLet\\'s take the element 3 at index \"1\"\\n\\t\\n\\tFor index = 1, NSL[1] = -1 and NSR[1] = 2\\n\\t\\n\\tWhat it  means is, all the subarrays formed between indices -1 (not including) and 2 (not including) \\n\\twhich have \"3\" in them, will have \"3\" as the minimum element. That is, [4,3] and [3]\\n\\t\\nSo, that\\'s how we define the boundaries for each element. \\n\\n**NOW COMES THE MOST TRICKY PART OF THIS PROBLEM!**\\n\\nNow that we know what are the left and right boundaries, how can we efficiently find the sum of all the subarrays between those boundaries that contain the minimum element at index \"i\"?\\n\\nFor that, we have to take an example and try to find a generalized solution for this sub-problem.\\n\\n\\tstrength = [4,3,1,2]\\n\\tLet\\'s also get the prefix sum = [0,4,7,8,10]\\n\\t\\n\\tLet\\'s take the element 1 at index 2\\n\\t\\n\\tLet\\'s take subarrays that start with index 0 and include the element \"1\"\\n\\tThat is [4,3,1] and [4,3,1,2]\\n\\t\\n\\tSum of subarray from index 0 to index 2 => Sum of [4,3,1] => Prefix[3] - Prefix[0] => 8 - 0 => 8\\n\\tSum of subarray from index 0 to index 3 => Sum of [4,3,1,2] => Prefix[4] - Prefix[0] => 10 - 0 => 10\\n\\t\\n\\tLet\\'s take subarrays that start with index 1 and include the element \"1\", that is [3,1] and [3,1,2]\\n\\n\\tSum of subarray from index 1 to index 2 => Sum of [3,1] => Prefix[3] - Prefix[1] => 8 - 4 => 4\\n\\tSum of subarray from index 1 to index 3 => Sum of [3,1,2] => Prefix[4] - Prefix[1] => 10 - 4 => 6\\n\\n\\tLet\\'s take subarrays that start with index 2 and include the element \"1\", that is [1], [1,2]\\n\\t\\n\\tSum of subarray from index 2 to index 2 => Sum of [1] => Prefix[3] - Prefix[2] => 8 - 7 => 1\\n\\tSum of subarray from index 2 to index 3 => Sum of [1,2] => Prefix[4] - Prefix[2] => 10 - 7 => 3\\n\\t\\n\\t\\nSince we want to get the total sum of all these subarrays, let\\'s sum up all the prefix sum equations. We get - \\n\\n\\tPrefix[3] - Prefix[0] + Prefix[4] - Prefix[0] + Prefix[3] - Prefix[1] + Prefix[4] - Prefix[1] + Prefix[3] - Prefix[2] + Prefix[3] - Prefix[2]\\n\\t\\nWe can rewrite it as - \\n\\n\\t=> (Prefix[3] +  Prefix[4] +  Prefix[3] +  Prefix[4] +  Prefix[3] +  Prefix[4]) - (Prefix[0] + Prefix[0] + Prefix[1] + Prefix[1] + Prefix[2] + Prefix[2])\\n\\n\\t=> 3 * (Prefix[3] +  Prefix[4])  -  2 * (Prefix[0] + Prefix[1] + Prefix[2])\\n\\n\\tLeft part of this equation is 3 * (Prefix[3] +  Prefix[4])\\n\\tRight Part of this equation is 2 * (Prefix[0] + Prefix[1] + Prefix[2])\\n\\t\\nNow, how can we simplify it even further? When we had to get sum of elements between any two or more continuous indices, we used a prefix sum array. But here, we have to get the sum of elements between two or more indices of prefix sum itself. That means, we will need a prefix sum of prefix sum now.\\n\\nThat\\'s the whole reason why we want the Prefix Sum of Prefix Sum.\\n\\n\\tStrength = [4,3,1,2]\\n\\tPrefix sum = [0,4,7,8,10]\\n\\tPrefix of Prefix sum = [0,0,4,11,19,29]\\n\\n Coming back to our equation \\n \\n\\t Left part =>  3 * (Prefix[3] +  Prefix[4])\\n\\t Right Part => 2 * (Prefix[0] + Prefix[1] + Prefix[2])\\n\\n\\t We can rewrite these two parts now as - \\n\\t \\n\\t Left part =>  3 * (PrefixOfPrefix[5] - PrefixOfPrefix[3])\\n\\t Right Part => 2 * (PrefixOfPrefix[3] - PrefixOfPrefix[0])\\n\\t \\nWhat are \"3\" and \"2\" here?\\n\\nThese are simply the number of elements on the left of element 1(including itself) and the number of elements on the right of element 1(including itself).\\n\\n**THE FINAL GENERALIZED FORMULA TO FIND THE SUM OF ALL SUBARRAYS WHERE ELEMENT AT INDEX \"i\" IS THE MINIMUM ELEMENT IS -**\\n\\n\\t Left part =>  leftCount * (PrefixOfPrefix[NSR[i] + 1] - PrefixOfPrefix[i + 1])\\n\\t Right Part => rightCount * (PrefixOfPrefix[i + 1] - PrefixOfPrefix[NSL[i] + 1])\\n\\t\\n\\t Total Sum = leftPart - rightPart\\n\\t\\nAnd all that\\'s left now is to multiply this totalSum with the element at index \"i\" since it will be the smallest element in all the subarrays whose sum we just calculated using the above formula.\\n\\n```\\nclass Solution:\\n    \\n    # Helper method to get the nearest smaller on left\\n    def getNearestSmallerOnLeft(self, nums):\\n        \\n        # Length of nums\\n        n = len(nums)\\n        \\n        # Output to return\\n        NSL = [-1] * n\\n        \\n        # Stack\\n        stack = []\\n        \\n        # Loop\\n        for i in range(n):\\n            \\n            # Remove all greater values from stack\\n            # Note that here, I did not do \">=\" as in getNearestSmallerOnRight because we don\\'t want to have duplicate subarrays\\n            while stack and nums[stack[-1]] > nums[i]: stack.pop()\\n                \\n            # If stack is not empty, the top of stack is the nearest smaller on left\\n            if stack: NSL[i] = stack[-1]\\n            \\n            # Put the current index in stack\\n            stack.append(i)\\n\\n        # Return the NSL data\\n        return NSL\\n    \\n    # Helper method to get the nearest smaller on right\\n    def getNearestSmallerOnRight(self, nums):\\n        \\n        # Length of nums\\n        n = len(nums)\\n        \\n        # Output to return\\n        NSR = [n] * n\\n        \\n        # Stack\\n        stack = []\\n        \\n        # Loop\\n        for i in range(n - 1, -1, -1):\\n            \\n            # Remove all greater/equal values from stack\\n            while stack and nums[stack[-1]] >= nums[i]: stack.pop()\\n                \\n            # If stack is not empty, the top of stack is the nearest smaller on right\\n            if stack: NSR[i] = stack[-1]\\n            \\n            # Put the current index in stack\\n            stack.append(i)\\n\\n        # Return the NSR data\\n        return NSR\\n    \\n    def totalStrength(self, strength: List[int]) -> int:\\n        \\n        # Final Output to return\\n        output = 0\\n        \\n        # Mod\\n        mod = 10**9 + 7\\n        \\n        # Length of the list\\n        n = len(strength)\\n    \\n        \\n        # Data for Nearest Smaller Element on Left\\n        NSL = self.getNearestSmallerOnLeft(strength)\\n        \\n        # Data for Nearest Smaller Element on Right\\n        NSR = self.getNearestSmallerOnRight(strength)\\n        \\n        # Prefix Sum\\n        prefixSum = [0] * (n + 1)\\n        \\n        for i in range(1,n + 1): prefixSum[i] = prefixSum[i - 1] + strength[i - 1]\\n        \\n        # Prefix Sum of Prefix Sum\\n        prefixOfPrefix = [0] * (n + 2)\\n        \\n        for i in range(1,n + 2): prefixOfPrefix[i] = prefixOfPrefix[i - 1] + prefixSum[i - 1]\\n        \\n        \\n        # Main loop\\n        for i in range(n):\\n            \\n            # Left Boundary\\n            leftBoundary = NSL[i]\\n            \\n            # Right Boundary\\n            rightBoundary = NSR[i]\\n            \\n            # Elements between leftBoundary (not including) and i (including)\\n            leftCount = i - leftBoundary\\n            \\n            # Elements between i (including) and rightBoundary (not including)\\n            rightCount = rightBoundary - i\\n            \\n            # Evaluate the left and right parts of the equations\\n            leftPart = (leftCount * (prefixOfPrefix[rightBoundary + 1] - prefixOfPrefix[i + 1])) % mod\\n            rightPart = (rightCount * (prefixOfPrefix[i + 1] - prefixOfPrefix[leftBoundary + 1])) % mod\\n            \\n            # Total Sum of subarrays that contain \"i\" element as the minimum element\\n            totalSubarraySum = leftPart - rightPart\\n            \\n            # Finally, we can multiply this sum by minimum element and add the result to the output\\n            output += strength[i] * totalSubarraySum\\n            \\n            # To handle large values, use mod\\n            output %= mod\\n            \\n            \\n        # Finally return the output\\n        return output\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\ndef totalStrength(self, strength: List[int]) -> int:\\n        \\n        # Final Output to return\\n        output = 0\\n        \\n        # Mod\\n        mod = 10**9 + 7\\n        \\n        # Length of the list\\n        n = len(strength)\\n        \\n        # Let\\'s take each element and consider it as the first element of subarray\\n        for i in range(n):\\n            \\n            # Sum of subarray starting with element at index \"i\"\\n            subarraySum = 0\\n            \\n            # Smallest Element of subarray\\n            smallestElement = strength[i]\\n            \\n            # Now, we go through the elements from i to n\\n            # And as we incorporate each element in current subarray, we will keep updating the output\\n            # Since we will keep getting new subarrays as we add new elements\\n            for j in range(i, n):\\n                \\n                # Update the sum of this subarray\\n                subarraySum += strength[j]\\n                \\n                # Update the smallestElement of this subarray\\n                smallestElement = min(smallestElement, strength[j])\\n                \\n                # Update the output\\n                output = (output + ( subarraySum * smallestElement)) % mod\\n\\n        \\n        # Return the output\\n        return output\\n```\n```\\nclass Solution:\\n    \\n    # Helper method to get the nearest smaller on left\\n    def getNearestSmallerOnLeft(self, nums):\\n        \\n        # Length of nums\\n        n = len(nums)\\n        \\n        # Output to return\\n        NSL = [-1] * n\\n        \\n        # Stack\\n        stack = []\\n        \\n        # Loop\\n        for i in range(n):\\n            \\n            # Remove all greater values from stack\\n            # Note that here, I did not do \">=\" as in getNearestSmallerOnRight because we don\\'t want to have duplicate subarrays\\n            while stack and nums[stack[-1]] > nums[i]: stack.pop()\\n                \\n            # If stack is not empty, the top of stack is the nearest smaller on left\\n            if stack: NSL[i] = stack[-1]\\n            \\n            # Put the current index in stack\\n            stack.append(i)\\n\\n        # Return the NSL data\\n        return NSL\\n    \\n    # Helper method to get the nearest smaller on right\\n    def getNearestSmallerOnRight(self, nums):\\n        \\n        # Length of nums\\n        n = len(nums)\\n        \\n        # Output to return\\n        NSR = [n] * n\\n        \\n        # Stack\\n        stack = []\\n        \\n        # Loop\\n        for i in range(n - 1, -1, -1):\\n            \\n            # Remove all greater/equal values from stack\\n            while stack and nums[stack[-1]] >= nums[i]: stack.pop()\\n                \\n            # If stack is not empty, the top of stack is the nearest smaller on right\\n            if stack: NSR[i] = stack[-1]\\n            \\n            # Put the current index in stack\\n            stack.append(i)\\n\\n        # Return the NSR data\\n        return NSR\\n    \\n    def totalStrength(self, strength: List[int]) -> int:\\n        \\n        # Final Output to return\\n        output = 0\\n        \\n        # Mod\\n        mod = 10**9 + 7\\n        \\n        # Length of the list\\n        n = len(strength)\\n    \\n        \\n        # Data for Nearest Smaller Element on Left\\n        NSL = self.getNearestSmallerOnLeft(strength)\\n        \\n        # Data for Nearest Smaller Element on Right\\n        NSR = self.getNearestSmallerOnRight(strength)\\n        \\n        # Prefix Sum\\n        prefixSum = [0] * (n + 1)\\n        \\n        for i in range(1,n + 1): prefixSum[i] = prefixSum[i - 1] + strength[i - 1]\\n        \\n        # Prefix Sum of Prefix Sum\\n        prefixOfPrefix = [0] * (n + 2)\\n        \\n        for i in range(1,n + 2): prefixOfPrefix[i] = prefixOfPrefix[i - 1] + prefixSum[i - 1]\\n        \\n        \\n        # Main loop\\n        for i in range(n):\\n            \\n            # Left Boundary\\n            leftBoundary = NSL[i]\\n            \\n            # Right Boundary\\n            rightBoundary = NSR[i]\\n            \\n            # Elements between leftBoundary (not including) and i (including)\\n            leftCount = i - leftBoundary\\n            \\n            # Elements between i (including) and rightBoundary (not including)\\n            rightCount = rightBoundary - i\\n            \\n            # Evaluate the left and right parts of the equations\\n            leftPart = (leftCount * (prefixOfPrefix[rightBoundary + 1] - prefixOfPrefix[i + 1])) % mod\\n            rightPart = (rightCount * (prefixOfPrefix[i + 1] - prefixOfPrefix[leftBoundary + 1])) % mod\\n            \\n            # Total Sum of subarrays that contain \"i\" element as the minimum element\\n            totalSubarraySum = leftPart - rightPart\\n            \\n            # Finally, we can multiply this sum by minimum element and add the result to the output\\n            output += strength[i] * totalSubarraySum\\n            \\n            # To handle large values, use mod\\n            output %= mod\\n            \\n            \\n        # Finally return the output\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681769,
                "title": "my-solutions",
                "content": "**1. Use the monotonously-increasing stack**\\n```\\n/**\\n * the algorithm is as following,\\n * 1. employ a monotonously-increasing stack to\\n *    get the index of the first right element, `right[i]`,\\n *    which is less than the current element `strength[i]`,\\n *    the default value is `n`\\n * 2. employ a monotonously-increasing stack to\\n *    get the index of the first left element, `left[i]`,\\n *    which is less than or equal to the current element `strength[i]`,\\n *    the default value is `-1`\\n * 3. for every element `strength[i]`, it\\'s the minimum element of all the ranges,\\n *    whose left bound is from (`left[i]` + 1) to `i`, both inclusive,\\n *    whose right bound is from `i` to (`right[i]` - 1), both inclusive\\n *    so its contribution to answer is as following,\\n *    `strength[i]` * `sum(all ranges mentioned above)`\\n *    `sum(all ranges mentioned above)` is as following,\\n *    1. sum(strength[left[i] + 1, i]) +\\n *       sum(strength[left[i] + 1, i + 1]) +\\n *       ... +\\n *       sum(strength[left[i] + 1, right[i] - 2]) +\\n *       sum(strength[left[i] + 1, right[i] - 1])\\n *    2. sum(strength[left[i] + 2, i]) +\\n *       sum(strength[left[i] + 2, i + 1]) +\\n *       ... +\\n *       sum(strength[left[i] + 2, right[i] - 2]) +\\n *       sum(strength[left[i] + 2, right[i] - 1])\\n *    ...\\n *    `i - left[i]`. sum(strength[i, i]) +\\n *                   sum(strength[i, i + 1]) +\\n *                   ... +\\n *                   sum(strength[i, right[i] - 2]) +\\n *                   sum(strength[i, right[i] - 1])\\n *    where `sum(strength[i, j])` stands for strength[i] + strength[i + 1] + ... + strength[j]\\n *    let `presums[i]` be strength[0] + strength[1] + ... + strength[i - 1],\\n *    where `i` is in the range [1, `n`], and `presums[0]` = 0\\n *    use `presums` to denote the above sum as following\\n *    1. (presums[i + 1] - presums[left[i] + 1]) +\\n *       (presums[i + 2] - presums[left[i] + 1]) +\\n *       ... +\\n *       (presums[right[i] - 1] - presums[left[i] + 1]) +\\n *       (presums[right[i]] - presums[left[i] + 1])\\n *    2. (presums[i + 1] - presums[left[i] + 2]) +\\n *       (presums[i + 2] - presums[left[i] + 2]) +\\n *       ... +\\n *       (presums[right[i] - 1] - presums[left[i] + 2]) +\\n *       (presums[right[i]] - presums[left[i] + 2])\\n *    ...\\n *    `i - left[i]`. (presums[i + 1] - presums[i]) +\\n *                   (presums[i + 2] - presums[i]) +\\n *                   ... +\\n *                   (presums[right[i] - 1] - presums[i]) +\\n *                   (presums[right[i]] - presums[i])\\n *    let `pre_presums[i]` be presums[0] + presums[1] + ... + presums[i - 1],\\n *    where `i` is in the range [1, `n` + 1], and `pre_presums[0]` = 0\\n *    use `pre_presums` to denote the above sum as following\\n *    (i - left[i]) * (pre_presums[right[i] + 1] - pre_presums[i + 1]) -\\n *    (right[i] - i) * (pre_presums[i + 1] - pre_presums[left[i] + 1])\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  int totalStrength(const vector<int> &strength) {\\n    constexpr int mod = 1000000007;\\n    const int n = static_cast<int>(strength.size());\\n    int presums[n + 1];\\n    memset(presums, 0, sizeof(presums));\\n    for (int i = 0; i < n; ++i) {\\n      presums[i + 1] = (presums[i] + strength[i]) % mod;\\n    }\\n    \\n    int pre_presums[n + 2];\\n    memset(pre_presums, 0, sizeof(pre_presums));\\n    for (int i = 0; i < n + 1; ++i) {\\n      pre_presums[i + 1] = (pre_presums[i] + presums[i]) % mod;\\n    }\\n    \\n    int right[n];\\n    fill(right, right + n, n);\\n    int left[n];\\n    memset(left, -1, sizeof(left));\\n    stack<int> st;   // a monotonously-increasing stack\\n    for (int i = 0; i < n; ++i) {\\n      while (!st.empty() && strength[st.top()] > strength[i]) {\\n        right[st.top()] = i;\\n        st.pop();\\n      }\\n      if (!st.empty()) {\\n        left[i] = st.top();\\n      }\\n      st.emplace(i);\\n    }\\n    \\n    int ret = 0;\\n    for (int i = 0; i < n; ++i) {\\n      const int lhs = static_cast<int>(static_cast<long long>(i - left[i]) * ((mod + pre_presums[right[i] + 1] - pre_presums[i + 1]) % mod) % mod);\\n      const int rhs = static_cast<int>(static_cast<long long>(right[i] - i) * ((mod + pre_presums[i + 1] - pre_presums[left[i] + 1]) % mod) % mod);\\n      ret = (ret + static_cast<int>(static_cast<long long>(strength[i]) * ((mod + lhs - rhs) % mod) % mod)) % mod;\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Use the DP**\\n```\\n/**\\n * the algorithm is as following,\\n * 1. employ the dp to get the index of the most right element, `right[i]`,\\n *    such that every element, from `i` to `right[i]`, is greater than or equal to\\n *    the current element `strength[i]`\\n * 2. employ the dp to get the index of the most left element, `left[i]`,\\n *    such that every element, from `left[i]` to `i - 1`, is greater than\\n *    the current element `strength[i]`\\n * 3. for every element `strength[i]`, it\\'s the minimum element of all the ranges,\\n *    whose left bound is from (`left[i]` + 1) to `i`, both inclusive,\\n *    whose right bound is from `i` to (`right[i]` - 1), both inclusive\\n *    so its contribution to answer is as following,\\n *    `strength[i]` * `sum(all ranges mentioned above)`\\n *    `sum(all ranges mentioned above)` is as following,\\n *    1. sum(strength[left[i], i]) +\\n *       sum(strength[left[i], i + 1]) +\\n *       ... +\\n *       sum(strength[left[i], right[i] - 1]) +\\n *       sum(strength[left[i], right[i]])\\n *    2. sum(strength[left[i] + 1, i]) +\\n *       sum(strength[left[i] + 1, i + 1]) +\\n *       ... +\\n *       sum(strength[left[i] + 1, right[i] - 1]) +\\n *       sum(strength[left[i] + 1, right[i]])\\n *    ...\\n *    `i - left[i] + 1`. sum(strength[i, i]) +\\n *                       sum(strength[i, i + 1]) +\\n *                       ... +\\n *                       sum(strength[i, right[i] - 1]) +\\n *                       sum(strength[i, right[i]])\\n *    where `sum(strength[i, j])` stands for strength[i] + strength[i + 1] + ... + strength[j]\\n *    let `presums[i]` be strength[0] + strength[1] + ... + strength[i - 1],\\n *    where `i` is in the range [1, `n`], and `presums[0]` = 0\\n *    use `presums` to denote the above sum as following\\n *    1. (presums[i + 1] - presums[left[i]]) +\\n *       (presums[i + 2] - presums[left[i]]) +\\n *       ... +\\n *       (presums[right[i]] - presums[left[i]]) +\\n *       (presums[right[i] + 1] - presums[left[i]])\\n *    2. (presums[i + 1] - presums[left[i] + 1]) +\\n *       (presums[i + 2] - presums[left[i] + 1]) +\\n *       ... +\\n *       (presums[right[i]] - presums[left[i] + 1]) +\\n *       (presums[right[i] + 1] - presums[left[i] + 1])\\n *    ...\\n *    `i - left[i] + 1`. (presums[i + 1] - presums[i]) +\\n *                       (presums[i + 2] - presums[i]) +\\n *                       ... +\\n *                       (presums[right[i]] - presums[i]) +\\n *                       (presums[right[i] + 1] - presums[i])\\n *    let `pre_presums[i]` be presums[0] + presums[1] + ... + presums[i - 1],\\n *    where `i` is in the range [1, `n` + 1], and `pre_presums[0]` = 0\\n *    use `pre_presums` to denote the above sum as following\\n *    (i - left[i] + 1) * (pre_presums[right[i] + 2] - pre_presums[i + 1]) -\\n *    (right[i] - i + 1) * (pre_presums[i + 1] - pre_presums[left[i]])\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  int totalStrength(const vector<int> &strength) {\\n    constexpr int mod = 1000000007;\\n    const int n = static_cast<int>(strength.size());\\n    int presums[n + 1];\\n    memset(presums, 0, sizeof(presums));\\n    for (int i = 0; i < n; ++i) {\\n      presums[i + 1] = (presums[i] + strength[i]) % mod;\\n    }\\n    \\n    int pre_presums[n + 2];\\n    memset(pre_presums, 0, sizeof(pre_presums));\\n    for (int i = 0; i < n + 1; ++i) {\\n      pre_presums[i + 1] = (pre_presums[i] + presums[i]) % mod;\\n    }\\n    \\n    int left[n];\\n    memset(left, -1, sizeof(left));\\n    for (int i = 0; i < n; ++i) {\\n      left[i] = i;\\n      while (left[i] > 0 && strength[left[i] - 1] > strength[i]) {\\n        left[i] = left[left[i] - 1];\\n      }\\n    }\\n    \\n    int right[n];\\n    memset(right, -1, sizeof(right));\\n    for (int i = n - 1; i > -1; --i) {\\n      right[i] = i;\\n      while (right[i] + 1 < n && strength[right[i] + 1] >= strength[i]) {\\n        right[i] = right[right[i] + 1];\\n      }\\n    }\\n    \\n    int ret = 0;\\n    for (int i = 0; i < n; ++i) {\\n      const int lhs = static_cast<int>(static_cast<long long>(i - left[i] + 1) * ((mod + pre_presums[right[i] + 2] - pre_presums[i + 1]) % mod) % mod);\\n      const int rhs = static_cast<int>(static_cast<long long>(right[i] - i + 1) * ((mod + pre_presums[i + 1] - pre_presums[left[i]]) % mod) % mod);\\n      ret = (ret + static_cast<int>(static_cast<long long>(strength[i]) * ((mod + lhs - rhs) % mod) % mod)) % mod;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * the algorithm is as following,\\n * 1. employ a monotonously-increasing stack to\\n *    get the index of the first right element, `right[i]`,\\n *    which is less than the current element `strength[i]`,\\n *    the default value is `n`\\n * 2. employ a monotonously-increasing stack to\\n *    get the index of the first left element, `left[i]`,\\n *    which is less than or equal to the current element `strength[i]`,\\n *    the default value is `-1`\\n * 3. for every element `strength[i]`, it\\'s the minimum element of all the ranges,\\n *    whose left bound is from (`left[i]` + 1) to `i`, both inclusive,\\n *    whose right bound is from `i` to (`right[i]` - 1), both inclusive\\n *    so its contribution to answer is as following,\\n *    `strength[i]` * `sum(all ranges mentioned above)`\\n *    `sum(all ranges mentioned above)` is as following,\\n *    1. sum(strength[left[i] + 1, i]) +\\n *       sum(strength[left[i] + 1, i + 1]) +\\n *       ... +\\n *       sum(strength[left[i] + 1, right[i] - 2]) +\\n *       sum(strength[left[i] + 1, right[i] - 1])\\n *    2. sum(strength[left[i] + 2, i]) +\\n *       sum(strength[left[i] + 2, i + 1]) +\\n *       ... +\\n *       sum(strength[left[i] + 2, right[i] - 2]) +\\n *       sum(strength[left[i] + 2, right[i] - 1])\\n *    ...\\n *    `i - left[i]`. sum(strength[i, i]) +\\n *                   sum(strength[i, i + 1]) +\\n *                   ... +\\n *                   sum(strength[i, right[i] - 2]) +\\n *                   sum(strength[i, right[i] - 1])\\n *    where `sum(strength[i, j])` stands for strength[i] + strength[i + 1] + ... + strength[j]\\n *    let `presums[i]` be strength[0] + strength[1] + ... + strength[i - 1],\\n *    where `i` is in the range [1, `n`], and `presums[0]` = 0\\n *    use `presums` to denote the above sum as following\\n *    1. (presums[i + 1] - presums[left[i] + 1]) +\\n *       (presums[i + 2] - presums[left[i] + 1]) +\\n *       ... +\\n *       (presums[right[i] - 1] - presums[left[i] + 1]) +\\n *       (presums[right[i]] - presums[left[i] + 1])\\n *    2. (presums[i + 1] - presums[left[i] + 2]) +\\n *       (presums[i + 2] - presums[left[i] + 2]) +\\n *       ... +\\n *       (presums[right[i] - 1] - presums[left[i] + 2]) +\\n *       (presums[right[i]] - presums[left[i] + 2])\\n *    ...\\n *    `i - left[i]`. (presums[i + 1] - presums[i]) +\\n *                   (presums[i + 2] - presums[i]) +\\n *                   ... +\\n *                   (presums[right[i] - 1] - presums[i]) +\\n *                   (presums[right[i]] - presums[i])\\n *    let `pre_presums[i]` be presums[0] + presums[1] + ... + presums[i - 1],\\n *    where `i` is in the range [1, `n` + 1], and `pre_presums[0]` = 0\\n *    use `pre_presums` to denote the above sum as following\\n *    (i - left[i]) * (pre_presums[right[i] + 1] - pre_presums[i + 1]) -\\n *    (right[i] - i) * (pre_presums[i + 1] - pre_presums[left[i] + 1])\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  int totalStrength(const vector<int> &strength) {\\n    constexpr int mod = 1000000007;\\n    const int n = static_cast<int>(strength.size());\\n    int presums[n + 1];\\n    memset(presums, 0, sizeof(presums));\\n    for (int i = 0; i < n; ++i) {\\n      presums[i + 1] = (presums[i] + strength[i]) % mod;\\n    }\\n    \\n    int pre_presums[n + 2];\\n    memset(pre_presums, 0, sizeof(pre_presums));\\n    for (int i = 0; i < n + 1; ++i) {\\n      pre_presums[i + 1] = (pre_presums[i] + presums[i]) % mod;\\n    }\\n    \\n    int right[n];\\n    fill(right, right + n, n);\\n    int left[n];\\n    memset(left, -1, sizeof(left));\\n    stack<int> st;   // a monotonously-increasing stack\\n    for (int i = 0; i < n; ++i) {\\n      while (!st.empty() && strength[st.top()] > strength[i]) {\\n        right[st.top()] = i;\\n        st.pop();\\n      }\\n      if (!st.empty()) {\\n        left[i] = st.top();\\n      }\\n      st.emplace(i);\\n    }\\n    \\n    int ret = 0;\\n    for (int i = 0; i < n; ++i) {\\n      const int lhs = static_cast<int>(static_cast<long long>(i - left[i]) * ((mod + pre_presums[right[i] + 1] - pre_presums[i + 1]) % mod) % mod);\\n      const int rhs = static_cast<int>(static_cast<long long>(right[i] - i) * ((mod + pre_presums[i + 1] - pre_presums[left[i] + 1]) % mod) % mod);\\n      ret = (ret + static_cast<int>(static_cast<long long>(strength[i]) * ((mod + lhs - rhs) % mod) % mod)) % mod;\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * the algorithm is as following,\\n * 1. employ the dp to get the index of the most right element, `right[i]`,\\n *    such that every element, from `i` to `right[i]`, is greater than or equal to\\n *    the current element `strength[i]`\\n * 2. employ the dp to get the index of the most left element, `left[i]`,\\n *    such that every element, from `left[i]` to `i - 1`, is greater than\\n *    the current element `strength[i]`\\n * 3. for every element `strength[i]`, it\\'s the minimum element of all the ranges,\\n *    whose left bound is from (`left[i]` + 1) to `i`, both inclusive,\\n *    whose right bound is from `i` to (`right[i]` - 1), both inclusive\\n *    so its contribution to answer is as following,\\n *    `strength[i]` * `sum(all ranges mentioned above)`\\n *    `sum(all ranges mentioned above)` is as following,\\n *    1. sum(strength[left[i], i]) +\\n *       sum(strength[left[i], i + 1]) +\\n *       ... +\\n *       sum(strength[left[i], right[i] - 1]) +\\n *       sum(strength[left[i], right[i]])\\n *    2. sum(strength[left[i] + 1, i]) +\\n *       sum(strength[left[i] + 1, i + 1]) +\\n *       ... +\\n *       sum(strength[left[i] + 1, right[i] - 1]) +\\n *       sum(strength[left[i] + 1, right[i]])\\n *    ...\\n *    `i - left[i] + 1`. sum(strength[i, i]) +\\n *                       sum(strength[i, i + 1]) +\\n *                       ... +\\n *                       sum(strength[i, right[i] - 1]) +\\n *                       sum(strength[i, right[i]])\\n *    where `sum(strength[i, j])` stands for strength[i] + strength[i + 1] + ... + strength[j]\\n *    let `presums[i]` be strength[0] + strength[1] + ... + strength[i - 1],\\n *    where `i` is in the range [1, `n`], and `presums[0]` = 0\\n *    use `presums` to denote the above sum as following\\n *    1. (presums[i + 1] - presums[left[i]]) +\\n *       (presums[i + 2] - presums[left[i]]) +\\n *       ... +\\n *       (presums[right[i]] - presums[left[i]]) +\\n *       (presums[right[i] + 1] - presums[left[i]])\\n *    2. (presums[i + 1] - presums[left[i] + 1]) +\\n *       (presums[i + 2] - presums[left[i] + 1]) +\\n *       ... +\\n *       (presums[right[i]] - presums[left[i] + 1]) +\\n *       (presums[right[i] + 1] - presums[left[i] + 1])\\n *    ...\\n *    `i - left[i] + 1`. (presums[i + 1] - presums[i]) +\\n *                       (presums[i + 2] - presums[i]) +\\n *                       ... +\\n *                       (presums[right[i]] - presums[i]) +\\n *                       (presums[right[i] + 1] - presums[i])\\n *    let `pre_presums[i]` be presums[0] + presums[1] + ... + presums[i - 1],\\n *    where `i` is in the range [1, `n` + 1], and `pre_presums[0]` = 0\\n *    use `pre_presums` to denote the above sum as following\\n *    (i - left[i] + 1) * (pre_presums[right[i] + 2] - pre_presums[i + 1]) -\\n *    (right[i] - i + 1) * (pre_presums[i + 1] - pre_presums[left[i]])\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  int totalStrength(const vector<int> &strength) {\\n    constexpr int mod = 1000000007;\\n    const int n = static_cast<int>(strength.size());\\n    int presums[n + 1];\\n    memset(presums, 0, sizeof(presums));\\n    for (int i = 0; i < n; ++i) {\\n      presums[i + 1] = (presums[i] + strength[i]) % mod;\\n    }\\n    \\n    int pre_presums[n + 2];\\n    memset(pre_presums, 0, sizeof(pre_presums));\\n    for (int i = 0; i < n + 1; ++i) {\\n      pre_presums[i + 1] = (pre_presums[i] + presums[i]) % mod;\\n    }\\n    \\n    int left[n];\\n    memset(left, -1, sizeof(left));\\n    for (int i = 0; i < n; ++i) {\\n      left[i] = i;\\n      while (left[i] > 0 && strength[left[i] - 1] > strength[i]) {\\n        left[i] = left[left[i] - 1];\\n      }\\n    }\\n    \\n    int right[n];\\n    memset(right, -1, sizeof(right));\\n    for (int i = n - 1; i > -1; --i) {\\n      right[i] = i;\\n      while (right[i] + 1 < n && strength[right[i] + 1] >= strength[i]) {\\n        right[i] = right[right[i] + 1];\\n      }\\n    }\\n    \\n    int ret = 0;\\n    for (int i = 0; i < n; ++i) {\\n      const int lhs = static_cast<int>(static_cast<long long>(i - left[i] + 1) * ((mod + pre_presums[right[i] + 2] - pre_presums[i + 1]) % mod) % mod);\\n      const int rhs = static_cast<int>(static_cast<long long>(right[i] - i + 1) * ((mod + pre_presums[i + 1] - pre_presums[left[i]]) % mod) % mod);\\n      ret = (ret + static_cast<int>(static_cast<long long>(strength[i]) * ((mod + lhs - rhs) % mod) % mod)) % mod;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675298,
                "title": "monotonic-increasing-stack-prepresum",
                "content": "# Intuition\\nSimilar to [907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums) but requires prefix sum of prefix sum arr to find sum of all subarrs.\\nExamples in comments help to understand why prePreSum works.\\n\\n# Code\\n```\\nclass Solution {\\n        // L=4,   R=3\\n        // [7,6,5,4]; [6,7] Diagram to see that left arr cb repeated R times\\n        // [7,6,5,4]; [6  ]\\n        // [7,6,5,4]; [   ] R=3 coz it includes 4, to count this case\\n        // [  6,5,4]; [6,7]\\n        // [  6,5,4]; [6  ]\\n        // [  6,5,4]; [   ] and this\\n        // [    5,4]; [6,7]\\n        // [    5,4]; [6  ]\\n        // [    5,4]; [   ] and this\\n        // [      4]; [6,7]\\n        // [      4]; [6  ]\\n        // [      4]; [   ] and this\\n        // [6,7] * L, [6] * L, [] * L, L=4\\n        // [7,6,5,4] * R, [6,5,4] * R, [5,4] * R, [4] * R, R=3\\n        // i=3, num=4\\n        // Positive: (presumA[i] + presumA[i+1] + ... + presumA[i+R-1]) * L\\n        // Negative: (presumA[left-1] + presumA[left] + ... + presumA[i-1]) * R, where left=1stSmaller+1, i.e. left-most in range where i is min\\n        // Key idea: positive/negative is cumulative sum of presums(all indices sequential) or prePreSum or presumOfPresum :)\\n        //\\n        // Diagram to see that right arr cb repeated L times(same as above just dif order):\\n        //  0 1 2    3 4 5\\n        // [7,6,5]; [4,6,7]\\n        // [  6,5]; [4,6,7]\\n        // [    5]; [4,6,7]\\n        // [     ]; [4,6,7] L=4 coz it includes 4, to count this case\\n        // [7,6,5]; [4,6  ]\\n        // [  6,5]; [4,6  ]\\n        // [    5]; [4,6  ]\\n        // [     ]; [4,6  ] and this\\n        // [7,6,5]; [4   ]\\n        // [  6,5]; [4   ]\\n        // [    5]; [4   ]\\n        // [     ]; [4   ] and this\\n        // [4,6,7] * L, [4,6] * L, [4] * L, L=4\\n        // [7,6,5] * R, [6,5] * R, [5] * R, [] * R, R=3\\n        public int totalStrength(int[] strength) {\\n            int m = (int) 1e9 + 7, n = strength.length;\\n            var st = new Stack<Integer>();\\n\\n            long answer = 0;\\n            this.prePreSum = new long[n];\\n            prePreSum[0] = strength[0];\\n            for (int i = 1; i < n; i++) // Get the prefix sum of the prefix sum array of strength.\\n                prePreSum[i] = (prePreSum[i - 1] + strength[i]) % m;\\n            for (int i = 1; i < n; i++)\\n                prePreSum[i] = (prePreSum[i - 1] + prePreSum[i]) % m;\\n\\n            // For each element in strength, we get the value of R_term - L_term.\\n            for (int j = 0; j <= n; j++) {\\n                while (!st.isEmpty() && (j == n || strength[st.peek()] >= strength[j])) {\\n                    int i = st.pop();\\n                    int rightBound = j;\\n                    int leftBound = st.isEmpty() ? -1 : st.peek();\\n\\n                    // Get the leftCount and rightCount (marked as L and R in the previous slides)\\n                    int leftCount = i - leftBound, rightCount = rightBound - i;\\n\\n                    long negPresum = (prePreSum(i - 1) - prePreSum(leftBound - 1)) % m; // Easier to underst indices\\n                    long posPresum = (prePreSum(rightBound - 1) - prePreSum(i - 1)) % m;\\n\\n                    // Total strength of all subarrays that have strength[i] as minimum\\n                    answer = (answer + (posPresum * leftCount - negPresum * rightCount) % m * strength[i] % m) % m;\\n                }\\n                st.add(j);\\n            }\\n\\n            return (int) (answer + m) % m;\\n        }\\n\\n        long[] prePreSum;\\n\\n        private long prePreSum(int i) {\\n            return i >= 0 ? prePreSum[i] : 0;\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        // L=4,   R=3\\n        // [7,6,5,4]; [6,7] Diagram to see that left arr cb repeated R times\\n        // [7,6,5,4]; [6  ]\\n        // [7,6,5,4]; [   ] R=3 coz it includes 4, to count this case\\n        // [  6,5,4]; [6,7]\\n        // [  6,5,4]; [6  ]\\n        // [  6,5,4]; [   ] and this\\n        // [    5,4]; [6,7]\\n        // [    5,4]; [6  ]\\n        // [    5,4]; [   ] and this\\n        // [      4]; [6,7]\\n        // [      4]; [6  ]\\n        // [      4]; [   ] and this\\n        // [6,7] * L, [6] * L, [] * L, L=4\\n        // [7,6,5,4] * R, [6,5,4] * R, [5,4] * R, [4] * R, R=3\\n        // i=3, num=4\\n        // Positive: (presumA[i] + presumA[i+1] + ... + presumA[i+R-1]) * L\\n        // Negative: (presumA[left-1] + presumA[left] + ... + presumA[i-1]) * R, where left=1stSmaller+1, i.e. left-most in range where i is min\\n        // Key idea: positive/negative is cumulative sum of presums(all indices sequential) or prePreSum or presumOfPresum :)\\n        //\\n        // Diagram to see that right arr cb repeated L times(same as above just dif order):\\n        //  0 1 2    3 4 5\\n        // [7,6,5]; [4,6,7]\\n        // [  6,5]; [4,6,7]\\n        // [    5]; [4,6,7]\\n        // [     ]; [4,6,7] L=4 coz it includes 4, to count this case\\n        // [7,6,5]; [4,6  ]\\n        // [  6,5]; [4,6  ]\\n        // [    5]; [4,6  ]\\n        // [     ]; [4,6  ] and this\\n        // [7,6,5]; [4   ]\\n        // [  6,5]; [4   ]\\n        // [    5]; [4   ]\\n        // [     ]; [4   ] and this\\n        // [4,6,7] * L, [4,6] * L, [4] * L, L=4\\n        // [7,6,5] * R, [6,5] * R, [5] * R, [] * R, R=3\\n        public int totalStrength(int[] strength) {\\n            int m = (int) 1e9 + 7, n = strength.length;\\n            var st = new Stack<Integer>();\\n\\n            long answer = 0;\\n            this.prePreSum = new long[n];\\n            prePreSum[0] = strength[0];\\n            for (int i = 1; i < n; i++) // Get the prefix sum of the prefix sum array of strength.\\n                prePreSum[i] = (prePreSum[i - 1] + strength[i]) % m;\\n            for (int i = 1; i < n; i++)\\n                prePreSum[i] = (prePreSum[i - 1] + prePreSum[i]) % m;\\n\\n            // For each element in strength, we get the value of R_term - L_term.\\n            for (int j = 0; j <= n; j++) {\\n                while (!st.isEmpty() && (j == n || strength[st.peek()] >= strength[j])) {\\n                    int i = st.pop();\\n                    int rightBound = j;\\n                    int leftBound = st.isEmpty() ? -1 : st.peek();\\n\\n                    // Get the leftCount and rightCount (marked as L and R in the previous slides)\\n                    int leftCount = i - leftBound, rightCount = rightBound - i;\\n\\n                    long negPresum = (prePreSum(i - 1) - prePreSum(leftBound - 1)) % m; // Easier to underst indices\\n                    long posPresum = (prePreSum(rightBound - 1) - prePreSum(i - 1)) % m;\\n\\n                    // Total strength of all subarrays that have strength[i] as minimum\\n                    answer = (answer + (posPresum * leftCount - negPresum * rightCount) % m * strength[i] % m) % m;\\n                }\\n                st.add(j);\\n            }\\n\\n            return (int) (answer + m) % m;\\n        }\\n\\n        long[] prePreSum;\\n\\n        private long prePreSum(int i) {\\n            return i >= 0 ? prePreSum[i] : 0;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647185,
                "title": "intuitive-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know that we want to multiply the minimum element in a range by the sum of the elements in that given range. For each element in the array, let\\'s set that as the minimum. We can then iterate through the array with each index as the minimum and multiply by the sum of the valid ranges for a given index. But how do you calculate that?\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find the sum of a given range, we have prefix[end] - prefix[start] using prefix sum array\\nto find all the sums in a given range, we can use prefix sum of prefix sum, call it psum\\n\\nA range(left, right *exclusive*) can either include the index, let\\'s call it i, or start at i. \\n# If it includes i, we have the following:\\nsum(left + 1, i + sum(left + 1, i + 1) + ... + sum(left + 1, right - 1)\\nsum(left + 2, i) + sum(left + 2, i + 1) + ... + sum(left + 2, right - 1)\\n.\\n.\\n.\\nsum(i, i) + ... + sum(i, right - 1)\\n\\n\\npsum end: i\\npsum start: left + 1\\nw/ right - i elements on each line\\n\\nw/ i - left lines\\n\\n# If it starts at i, we have the following:\\nsum(i, i) + sum(i, i + 1) + .... + sum(i, right - 1)\\n\\n\\n**Additional math omitted, please see C++ posts** credits: quantuminfo\\npositive parts:\\n(prefix[i + 1] + prefix[i + 2] + ... + prefix[right]) * (i - left)\\nnegative parts:\\n(prefix[left + 1] + prefix[left + 2] + ... + prefix[i]) * (right - i)\\n\\n\\n\\ntogether, you get this:\\nres += ((psum[right[i] + 1] - psum[i + 1]) * (***i - left[i]***) \\n***-*** (psum[i + 1] - psum[left[i] + 1]) * (***right[i] - i***)) \\n/* strength[i] % MOD\\n\\nCalculate left and right using a monostack\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def totalStrength(self, strength):\\n        MOD = 10 ** 9 + 7\\n\\n        prefix = [0] * (len(strength) + 1)\\n        for i in range(len(strength)):\\n            prefix[i + 1] = prefix[i] + strength[i]\\n        psum = [0] * (len(prefix) + 1)\\n        for i in range(len(prefix)):\\n            psum[i + 1] = psum[i] + prefix[i]\\n\\n        stack = []\\n        left = [i for i in range(len(strength))]\\n        right = [j for j in range(len(strength))]\\n\\n        for i in range(len(strength)):\\n            while stack and strength[stack[-1]] >= strength[i]:\\n                stack.pop()\\n            left[i] = -1  if not stack else stack[-1]\\n            stack.append(i)\\n        stack.clear()\\n        for i in range(len(strength) - 1, -1, -1):\\n            while stack and strength[stack[-1]] > strength[i]:\\n                stack.pop()\\n            right[i] = len(strength) if not stack else stack[-1]\\n            stack.append(i)\\n        res = 0\\n\\n        for i in range(len(strength)):\\n            res += ((psum[right[i] + 1] - psum[i + 1]) * (i - left[i]) - (psum[i + 1] - psum[left[i] + 1]) * (right[i] - i)) * strength[i] % MOD\\n        return res % MOD\\n\\n        \\n\\n\\n        \\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def totalStrength(self, strength):\\n        MOD = 10 ** 9 + 7\\n\\n        prefix = [0] * (len(strength) + 1)\\n        for i in range(len(strength)):\\n            prefix[i + 1] = prefix[i] + strength[i]\\n        psum = [0] * (len(prefix) + 1)\\n        for i in range(len(prefix)):\\n            psum[i + 1] = psum[i] + prefix[i]\\n\\n        stack = []\\n        left = [i for i in range(len(strength))]\\n        right = [j for j in range(len(strength))]\\n\\n        for i in range(len(strength)):\\n            while stack and strength[stack[-1]] >= strength[i]:\\n                stack.pop()\\n            left[i] = -1  if not stack else stack[-1]\\n            stack.append(i)\\n        stack.clear()\\n        for i in range(len(strength) - 1, -1, -1):\\n            while stack and strength[stack[-1]] > strength[i]:\\n                stack.pop()\\n            right[i] = len(strength) if not stack else stack[-1]\\n            stack.append(i)\\n        res = 0\\n\\n        for i in range(len(strength)):\\n            res += ((psum[right[i] + 1] - psum[i + 1]) * (i - left[i]) - (psum[i + 1] - psum[left[i] + 1]) * (right[i] - i)) * strength[i] % MOD\\n        return res % MOD\\n\\n        \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634938,
                "title": "c-o-n-prefix-suffix-prefix-suffix-sums-with-monotonic-stack",
                "content": "- Iterate left to right with monotonic stack of increasing indexed value.\\n  - consider contribution from all sub arrays having stack top as the minimum.\\n  - further consider separately contribution from left side sub array and right side sub array of the minimum.\\n- if worked out example details, one will realize the total strength from sub arrays is related to prefix prefix sum, and symmetrically suffix suffix sum. \\n```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& strength) {\\n        strength.insert(strength.begin(), 0); //add sentinel at front\\n        strength.push_back(0); //add sentinel at back\\n        int ans = 0, mod = 1\\'000\\'000\\'007, sz = strength.size();\\n        \\n        vector<int> ps(sz), pps(sz); //prefix sum, and its prefix sum\\n        partial_sum(strength.begin(), strength.end(), ps.begin(), [mod](int s, int n) { return (s+n) % mod; });\\n        partial_sum(ps.begin(), ps.end(), pps.begin(), [mod](int s, int n) { return (s+n) % mod; });\\n\\n        vector<int> ss(sz), sss(sz); //suffix sum, and its suffix sum\\n        partial_sum(strength.rbegin(), strength.rend(), ss.rbegin(), [mod](int s, int n) { return (s+n) % mod; });\\n        partial_sum(ss.rbegin(), ss.rend(), sss.rbegin(), [mod](int s, int n) { return (s+n) % mod; });\\n\\n        stack<int> indices{ {0} }; // monotonic in increasing indexed value order\\n        for(int j = 1; j < sz; ++j) {\\n            for(long long k = indices.top(); strength[k] > strength[j]; k = indices.top()) {\\n                indices.pop();\\n                int i = indices.top(); // all sub arrays with [k] as minimum and bounded by (i, j)\\n                long long rcontrib = (j == k+1) ? 0 : (k-i) * (pps[j-1] - pps[k] - ps[k] * (j-1-k)) % mod; // from (k, j)\\n                long long lcontrib = (i+1 == k) ? 0 : (j-k) * (sss[i+1] - sss[k] - ss[k] * (k-i-1)) % mod; // from (i, k)\\n                long long mcontrib = (k-i) * (j-k) * strength[k] % mod; // contribution from [k]\\n\\n                ans = (ans + (rcontrib + lcontrib + mcontrib) * strength[k]) % mod;\\n            }\\n            indices.push(j);\\n        }\\n        return (ans + mod) % mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& strength) {\\n        strength.insert(strength.begin(), 0); //add sentinel at front\\n        strength.push_back(0); //add sentinel at back\\n        int ans = 0, mod = 1\\'000\\'000\\'007, sz = strength.size();\\n        \\n        vector<int> ps(sz), pps(sz); //prefix sum, and its prefix sum\\n        partial_sum(strength.begin(), strength.end(), ps.begin(), [mod](int s, int n) { return (s+n) % mod; });\\n        partial_sum(ps.begin(), ps.end(), pps.begin(), [mod](int s, int n) { return (s+n) % mod; });\\n\\n        vector<int> ss(sz), sss(sz); //suffix sum, and its suffix sum\\n        partial_sum(strength.rbegin(), strength.rend(), ss.rbegin(), [mod](int s, int n) { return (s+n) % mod; });\\n        partial_sum(ss.rbegin(), ss.rend(), sss.rbegin(), [mod](int s, int n) { return (s+n) % mod; });\\n\\n        stack<int> indices{ {0} }; // monotonic in increasing indexed value order\\n        for(int j = 1; j < sz; ++j) {\\n            for(long long k = indices.top(); strength[k] > strength[j]; k = indices.top()) {\\n                indices.pop();\\n                int i = indices.top(); // all sub arrays with [k] as minimum and bounded by (i, j)\\n                long long rcontrib = (j == k+1) ? 0 : (k-i) * (pps[j-1] - pps[k] - ps[k] * (j-1-k)) % mod; // from (k, j)\\n                long long lcontrib = (i+1 == k) ? 0 : (j-k) * (sss[i+1] - sss[k] - ss[k] * (k-i-1)) % mod; // from (i, k)\\n                long long mcontrib = (k-i) * (j-k) * strength[k] % mod; // contribution from [k]\\n\\n                ans = (ans + (rcontrib + lcontrib + mcontrib) * strength[k]) % mod;\\n            }\\n            indices.push(j);\\n        }\\n        return (ans + mod) % mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630858,
                "title": "c-o-n-logn-not-a-typical-solution-as-based-on-monotonic-stack",
                "content": "- divide and conquer on minimum. \\n  - consider contribution from all sub arrays having the minimum.\\n  - then divide into left and right sub arrays and recurse\\n  - we presort index to ascending array element order so we can have fixed order of the divide and conquer steps.\\n- if worked out example details, one will realize the total strength is related to prefix sum of prefix sum \\n```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& strength) {\\n        int ans = 0, mod = 1\\'000\\'000\\'007, sz = strength.size();\\n        \\n        vector<pair<int,int>> valindex;\\n        for(int i = 0; i < sz; ++i) \\n            valindex.emplace_back(strength[i], i);\\n        sort(valindex.begin(), valindex.end());\\n        set<int> done({-1, sz});\\n\\n        vector<int> psum, psumsum(sz); //prefix sum, and its prefix sum\\n        for(auto n : strength)\\n            psum.push_back( (psum.empty() ? n : psum.back() + n) % mod );\\n        partial_sum(psum.begin(), psum.end(), psumsum.begin(), [mod](int s, int n) { return (s+n) % mod; });\\n        \\n        vector<int> ssum, ssumsum(sz); //sufix sum, and its suffix sum\\n        for(auto i = strength.rbegin(); i != strength.rend(); ++i)\\n            ssum.push_back( (ssum.empty() ? *i : ssum.back() + *i) % mod );\\n        partial_sum(ssum.begin(), ssum.end(), ssumsum.begin(), [mod](int s, int n) { return (s+n) % mod; });\\n        \\n        function<void(int)> dc = [&dc, &done, &psum, &ssum, &psumsum, &ssumsum, &strength, &ans, mod, sz]\\n            (int k) \\n        {\\n            auto [itr, _] = done.insert(k);\\n            int i = *prev(itr)+1, j = *next(itr); //work on sub array [i, j], with [k] being minimum.\\n\\n            long long lsz = k + 1 - i; //[i, k) + [k]\\n            long long rsz = j - k;     //[k] + (k, j-1] \\n\\n            long long rcontrib = rsz == 1 ? 0 : lsz * (psumsum[j-1] - psumsum[k] - psum[k] * (rsz-1)) % mod;\\n            long long lcontrib = lsz == 1 ? 0 : rsz * (ssumsum[sz-1-i] - ssumsum[sz-1-k] - ssum[sz-1-k] * (lsz-1)) % mod;\\n            long long mcontrib = lsz * rsz * strength[k] % mod;\\n\\n            ans = (ans + (rcontrib + lcontrib + mcontrib) * strength[k]) % mod;\\n        };\\n        for(auto const & [val, index] : valindex) {\\n            dc(index);// divide and conquer at current minimal element\\n        }\\n        return (ans + mod) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& strength) {\\n        int ans = 0, mod = 1\\'000\\'000\\'007, sz = strength.size();\\n        \\n        vector<pair<int,int>> valindex;\\n        for(int i = 0; i < sz; ++i) \\n            valindex.emplace_back(strength[i], i);\\n        sort(valindex.begin(), valindex.end());\\n        set<int> done({-1, sz});\\n\\n        vector<int> psum, psumsum(sz); //prefix sum, and its prefix sum\\n        for(auto n : strength)\\n            psum.push_back( (psum.empty() ? n : psum.back() + n) % mod );\\n        partial_sum(psum.begin(), psum.end(), psumsum.begin(), [mod](int s, int n) { return (s+n) % mod; });\\n        \\n        vector<int> ssum, ssumsum(sz); //sufix sum, and its suffix sum\\n        for(auto i = strength.rbegin(); i != strength.rend(); ++i)\\n            ssum.push_back( (ssum.empty() ? *i : ssum.back() + *i) % mod );\\n        partial_sum(ssum.begin(), ssum.end(), ssumsum.begin(), [mod](int s, int n) { return (s+n) % mod; });\\n        \\n        function<void(int)> dc = [&dc, &done, &psum, &ssum, &psumsum, &ssumsum, &strength, &ans, mod, sz]\\n            (int k) \\n        {\\n            auto [itr, _] = done.insert(k);\\n            int i = *prev(itr)+1, j = *next(itr); //work on sub array [i, j], with [k] being minimum.\\n\\n            long long lsz = k + 1 - i; //[i, k) + [k]\\n            long long rsz = j - k;     //[k] + (k, j-1] \\n\\n            long long rcontrib = rsz == 1 ? 0 : lsz * (psumsum[j-1] - psumsum[k] - psum[k] * (rsz-1)) % mod;\\n            long long lcontrib = lsz == 1 ? 0 : rsz * (ssumsum[sz-1-i] - ssumsum[sz-1-k] - ssum[sz-1-k] * (lsz-1)) % mod;\\n            long long mcontrib = lsz * rsz * strength[k] % mod;\\n\\n            ans = (ans + (rcontrib + lcontrib + mcontrib) * strength[k]) % mod;\\n        };\\n        for(auto const & [val, index] : valindex) {\\n            dc(index);// divide and conquer at current minimal element\\n        }\\n        return (ans + mod) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360654,
                "title": "c-sparse-table-prefix-sum-binary-search-o-n-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nlol\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$\\\\color{pink} O(n \\\\log(n))$$ with some MASSIVE constant overhead\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$\\\\color{pink} O(n \\\\log(n))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef long long ll;\\ntypedef unsigned long long ull;\\ntypedef vector<int> vi;\\ntypedef pair<int, int> pi;\\ntypedef pair<ll, ll> pll;\\nconst ll INF = LONG_LONG_MAX - 1;\\nconst int MOD = 1e9 + 7;\\nconst int MOD2 = 998244353;\\nconst int MAXN = (int) 1e5 + 2;\\nclass Solution {\\npublic:\\ntemplate<ll mod = MOD> struct mint {\\n    ll x;\\n\\n    mint() : x(0) {}\\n    mint(ll _x) {\\n        _x %= mod;\\n        if (_x < 0) _x += mod;\\n        x = _x;\\n    }\\n\\n    mint& operator += (const mint &a) {\\n        x += a.x;\\n        if (x >= mod) x -= mod;\\n        return *this;\\n    }\\n    mint& operator -= (const mint &a) {\\n        x += mod - a.x;\\n        if (x >= mod) x -= mod;\\n        return *this;\\n    }\\n    mint& operator *= (const mint &a) {\\n        x = (ull)x * a.x % mod;\\n        return *this;\\n    }\\n    mint pow(ll pw) const {\\n        mint res = 1;\\n        mint cur = *this;\\n        while(pw) {\\n            if (pw & 1) res *= cur;\\n            cur *= cur;\\n            pw >>= 1;\\n        }\\n        return res;\\n    }\\n    mint inv() const {\\n        assert(x != 0);\\n        ll t = x;\\n        ll res = 1;\\n        while(t != 1) {\\n            ll z = mod / t;\\n            res = (ull)res * (mod - z) % mod;\\n            t = mod - t * z;\\n        }\\n        return res;\\n    }\\n    mint& operator /= (const mint &a) {\\n        return *this *= a.inv();\\n    }\\n    mint operator + (const mint &a) const {\\n        return mint(*this) += a;\\n    }\\n    mint operator - (const mint &a) const {\\n        return mint(*this) -= a;\\n    }\\n    mint operator * (const mint &a) const {\\n        return mint(*this) *= a;\\n    }\\n    mint operator / (const mint &a) const {\\n        return mint(*this) /= a;\\n    }\\n\\n    bool operator == (const mint &a) const {\\n        return x == a.x;\\n    }\\n    bool operator != (const mint &a) const {\\n        return x != a.x;\\n    }\\n    bool operator < (const mint &a) const {\\n        return x < a.x;\\n    }\\n\\n    friend ostream& operator << (ostream &out, const mint& m){\\n        out << m.x;\\n        return out;\\n    }\\n};\\n\\nusing Mint = mint<MOD>;\\n\\nll highestPowerof2LessThanOrEq(ll x) {\\n    // check for the set bits\\n    x |= x >> 1;\\n    x |= x >> 2;\\n    x |= x >> 4;\\n    x |= x >> 8;\\n    x |= x >> 16;\\n    x |= x >> 32;\\n    return x ^ (x >> 1);\\n}\\n\\nint sp[MAXN][30];\\nint query(const vi& a,int l, int r){\\n    if (r == l)\\n        return sp[r][0];\\n    int d = (int) log2(highestPowerof2LessThanOrEq(r-l));\\n    if (a[sp[l][d]] >= a[sp[r-(1<<d)+1][d]])\\n        return sp[r-(1<<d)+1][d];\\n    return sp[l][d];\\n}\\n\\nMint psum[MAXN+1];\\nMint psumi[MAXN+1];\\nMint psumi2[MAXN+1];\\n\\nMint qi(ll L, ll R){\\n    return (psum[R]-psum[L-1])*(1+R-L-L*R) + (psumi[R]-psumi[L-1])*(R+L) - (psumi2[R]-psumi2[L-1]);\\n}\\n\\n\\n    int totalStrength(vector<int>& a) {\\n        psum[0] = psumi[0] = psumi2[0] = 0;\\n        ll n = a.size();\\n    for (ll i = 0; i < n; ++i) {\\n        sp[i][0] = i;\\n        psum[i+1] = psum[i] + a[i];\\n        psumi[i+1] = psumi[i] + (i+1)*a[i];\\n        psumi2[i+1] = psumi2[i] + ((i+1)*(i+1) % MOD)*a[i];\\n    }\\n\\n    int LOGN = ceil(log2(n));\\n    for (int j = 1; j < LOGN; ++j) {\\n        for (int i = 0; i < n - (1 << j) + 1; ++i) {\\n            if (a[sp[i][j-1]] >= a[sp[i+(1<<(j-1))][j-1]])\\n                sp[i][j] = sp[i+(1<<(j-1))][j-1];\\n            else\\n                sp[i][j] = sp[i][j-1];\\n        }\\n    }\\n\\n    Mint ans = 0;\\n    for (int i = 0; i < n; ++i){\\n        int l = i;\\n        int r = n-1;\\n        while ((r-l) > 1){\\n            int m = (l + r)>>1;\\n            if (a[query(a,i+1,m)] > a[i])\\n                l = m;\\n            else\\n                r = m-1;\\n        }\\n        pair<int,int> bnd = {0,0};\\n        if (i + 1 <= r && a[query(a,i+1,r)] > a[i])\\n            bnd.second = r;\\n        else\\n            bnd.second = l;\\n        l = 0;\\n        r = i;\\n        while ((r-l) > 1){\\n            int m = (l + r)>>1;\\n            if (a[query(a,m,i)] == a[i])\\n                r = m;\\n            else\\n                l = m+1;\\n        }\\n        if (a[query(a,l,i)] == a[i])\\n            bnd.first = l;\\n        else\\n            bnd.first = r;\\n\\n        Mint s = qi(bnd.first+1,bnd.second+1) - qi(bnd.first+1,i) - qi(i+2,bnd.second+1);\\n        ans += s*a[i];\\n    }\\n    return ans.x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\ntypedef long long ll;\\ntypedef unsigned long long ull;\\ntypedef vector<int> vi;\\ntypedef pair<int, int> pi;\\ntypedef pair<ll, ll> pll;\\nconst ll INF = LONG_LONG_MAX - 1;\\nconst int MOD = 1e9 + 7;\\nconst int MOD2 = 998244353;\\nconst int MAXN = (int) 1e5 + 2;\\nclass Solution {\\npublic:\\ntemplate<ll mod = MOD> struct mint {\\n    ll x;\\n\\n    mint() : x(0) {}\\n    mint(ll _x) {\\n        _x %= mod;\\n        if (_x < 0) _x += mod;\\n        x = _x;\\n    }\\n\\n    mint& operator += (const mint &a) {\\n        x += a.x;\\n        if (x >= mod) x -= mod;\\n        return *this;\\n    }\\n    mint& operator -= (const mint &a) {\\n        x += mod - a.x;\\n        if (x >= mod) x -= mod;\\n        return *this;\\n    }\\n    mint& operator *= (const mint &a) {\\n        x = (ull)x * a.x % mod;\\n        return *this;\\n    }\\n    mint pow(ll pw) const {\\n        mint res = 1;\\n        mint cur = *this;\\n        while(pw) {\\n            if (pw & 1) res *= cur;\\n            cur *= cur;\\n            pw >>= 1;\\n        }\\n        return res;\\n    }\\n    mint inv() const {\\n        assert(x != 0);\\n        ll t = x;\\n        ll res = 1;\\n        while(t != 1) {\\n            ll z = mod / t;\\n            res = (ull)res * (mod - z) % mod;\\n            t = mod - t * z;\\n        }\\n        return res;\\n    }\\n    mint& operator /= (const mint &a) {\\n        return *this *= a.inv();\\n    }\\n    mint operator + (const mint &a) const {\\n        return mint(*this) += a;\\n    }\\n    mint operator - (const mint &a) const {\\n        return mint(*this) -= a;\\n    }\\n    mint operator * (const mint &a) const {\\n        return mint(*this) *= a;\\n    }\\n    mint operator / (const mint &a) const {\\n        return mint(*this) /= a;\\n    }\\n\\n    bool operator == (const mint &a) const {\\n        return x == a.x;\\n    }\\n    bool operator != (const mint &a) const {\\n        return x != a.x;\\n    }\\n    bool operator < (const mint &a) const {\\n        return x < a.x;\\n    }\\n\\n    friend ostream& operator << (ostream &out, const mint& m){\\n        out << m.x;\\n        return out;\\n    }\\n};\\n\\nusing Mint = mint<MOD>;\\n\\nll highestPowerof2LessThanOrEq(ll x) {\\n    // check for the set bits\\n    x |= x >> 1;\\n    x |= x >> 2;\\n    x |= x >> 4;\\n    x |= x >> 8;\\n    x |= x >> 16;\\n    x |= x >> 32;\\n    return x ^ (x >> 1);\\n}\\n\\nint sp[MAXN][30];\\nint query(const vi& a,int l, int r){\\n    if (r == l)\\n        return sp[r][0];\\n    int d = (int) log2(highestPowerof2LessThanOrEq(r-l));\\n    if (a[sp[l][d]] >= a[sp[r-(1<<d)+1][d]])\\n        return sp[r-(1<<d)+1][d];\\n    return sp[l][d];\\n}\\n\\nMint psum[MAXN+1];\\nMint psumi[MAXN+1];\\nMint psumi2[MAXN+1];\\n\\nMint qi(ll L, ll R){\\n    return (psum[R]-psum[L-1])*(1+R-L-L*R) + (psumi[R]-psumi[L-1])*(R+L) - (psumi2[R]-psumi2[L-1]);\\n}\\n\\n\\n    int totalStrength(vector<int>& a) {\\n        psum[0] = psumi[0] = psumi2[0] = 0;\\n        ll n = a.size();\\n    for (ll i = 0; i < n; ++i) {\\n        sp[i][0] = i;\\n        psum[i+1] = psum[i] + a[i];\\n        psumi[i+1] = psumi[i] + (i+1)*a[i];\\n        psumi2[i+1] = psumi2[i] + ((i+1)*(i+1) % MOD)*a[i];\\n    }\\n\\n    int LOGN = ceil(log2(n));\\n    for (int j = 1; j < LOGN; ++j) {\\n        for (int i = 0; i < n - (1 << j) + 1; ++i) {\\n            if (a[sp[i][j-1]] >= a[sp[i+(1<<(j-1))][j-1]])\\n                sp[i][j] = sp[i+(1<<(j-1))][j-1];\\n            else\\n                sp[i][j] = sp[i][j-1];\\n        }\\n    }\\n\\n    Mint ans = 0;\\n    for (int i = 0; i < n; ++i){\\n        int l = i;\\n        int r = n-1;\\n        while ((r-l) > 1){\\n            int m = (l + r)>>1;\\n            if (a[query(a,i+1,m)] > a[i])\\n                l = m;\\n            else\\n                r = m-1;\\n        }\\n        pair<int,int> bnd = {0,0};\\n        if (i + 1 <= r && a[query(a,i+1,r)] > a[i])\\n            bnd.second = r;\\n        else\\n            bnd.second = l;\\n        l = 0;\\n        r = i;\\n        while ((r-l) > 1){\\n            int m = (l + r)>>1;\\n            if (a[query(a,m,i)] == a[i])\\n                r = m;\\n            else\\n                l = m+1;\\n        }\\n        if (a[query(a,l,i)] == a[i])\\n            bnd.first = l;\\n        else\\n            bnd.first = r;\\n\\n        Mint s = qi(bnd.first+1,bnd.second+1) - qi(bnd.first+1,i) - qi(i+2,bnd.second+1);\\n        ans += s*a[i];\\n    }\\n    return ans.x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232870,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn total_strength(strength: Vec<i32>) -> i32 {\\n        const MOD: i64 = 1_000_000_007;\\n        let strength = strength.into_iter().map(|x| x as i64).collect::<Vec<_>>();\\n        let N = strength.len();\\n        let N_i64 = strength.len() as i64;\\n\\n        let mut ps_l = vec![0; strength.len() + 1];\\n        let mut pm_l = vec![0; strength.len() + 1];\\n\\n        for i in 0..N {\\n            ps_l[i + 1] = (ps_l[i] + strength[i]) % MOD;\\n            let i_64 = i as i64;\\n            pm_l[i + 1] = (pm_l[i] + (i_64 + 1) * strength[i]) % MOD;\\n        }\\n\\n        let mut ps_r = vec![0; strength.len() + 1];\\n        let mut pm_r = vec![0; strength.len() + 1];\\n\\n        for i in (0..N).rev() {\\n            ps_r[i] = (ps_r[i + 1] + strength[i]) % MOD;\\n            let i_64 = i as i64;\\n            pm_r[i] = (pm_r[i + 1] + (N_i64 - i_64) * strength[i]) % MOD;\\n        }\\n\\n        let mut stack = vec![];\\n        let mut ans = 0_i64;\\n\\n        for right in 0..=N {\\n            while !stack.is_empty()\\n                && (right == N || strength[*stack.last().unwrap()] >= strength[right])\\n            {\\n                let pivot = stack.pop().unwrap();\\n                let pivot_i64 = pivot as i64;\\n\\n                let left_i64 = stack.last().map(|x| *x as i64 + 1).unwrap_or(0);\\n                let left = left_i64 as usize;\\n\\n                let right_i64 = right as i64;\\n\\n                let left_sum = (MOD + pm_l[pivot + 1]\\n                    - pm_l[left]\\n                    - left_i64 * (ps_l[pivot + 1] - ps_l[left]) % MOD)\\n                    % MOD;\\n\\n                let right_sum = (MOD + pm_r[pivot + 1]\\n                    - pm_r[right]\\n                    - (N_i64 - right_i64) * (ps_r[pivot + 1] - ps_r[right]))\\n                    % MOD;\\n\\n                let all_sum =\\n                    (left_sum * (right_i64 - pivot_i64) + right_sum * (pivot_i64 - left_i64 + 1)) % MOD;\\n\\n                ans = (ans + all_sum * strength[pivot]) % MOD;\\n            }\\n            stack.push(right);\\n        }\\n        ans as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn total_strength(strength: Vec<i32>) -> i32 {\\n        const MOD: i64 = 1_000_000_007;\\n        let strength = strength.into_iter().map(|x| x as i64).collect::<Vec<_>>();\\n        let N = strength.len();\\n        let N_i64 = strength.len() as i64;\\n\\n        let mut ps_l = vec![0; strength.len() + 1];\\n        let mut pm_l = vec![0; strength.len() + 1];\\n\\n        for i in 0..N {\\n            ps_l[i + 1] = (ps_l[i] + strength[i]) % MOD;\\n            let i_64 = i as i64;\\n            pm_l[i + 1] = (pm_l[i] + (i_64 + 1) * strength[i]) % MOD;\\n        }\\n\\n        let mut ps_r = vec![0; strength.len() + 1];\\n        let mut pm_r = vec![0; strength.len() + 1];\\n\\n        for i in (0..N).rev() {\\n            ps_r[i] = (ps_r[i + 1] + strength[i]) % MOD;\\n            let i_64 = i as i64;\\n            pm_r[i] = (pm_r[i + 1] + (N_i64 - i_64) * strength[i]) % MOD;\\n        }\\n\\n        let mut stack = vec![];\\n        let mut ans = 0_i64;\\n\\n        for right in 0..=N {\\n            while !stack.is_empty()\\n                && (right == N || strength[*stack.last().unwrap()] >= strength[right])\\n            {\\n                let pivot = stack.pop().unwrap();\\n                let pivot_i64 = pivot as i64;\\n\\n                let left_i64 = stack.last().map(|x| *x as i64 + 1).unwrap_or(0);\\n                let left = left_i64 as usize;\\n\\n                let right_i64 = right as i64;\\n\\n                let left_sum = (MOD + pm_l[pivot + 1]\\n                    - pm_l[left]\\n                    - left_i64 * (ps_l[pivot + 1] - ps_l[left]) % MOD)\\n                    % MOD;\\n\\n                let right_sum = (MOD + pm_r[pivot + 1]\\n                    - pm_r[right]\\n                    - (N_i64 - right_i64) * (ps_r[pivot + 1] - ps_r[right]))\\n                    % MOD;\\n\\n                let all_sum =\\n                    (left_sum * (right_i64 - pivot_i64) + right_sum * (pivot_i64 - left_i64 + 1)) % MOD;\\n\\n                ans = (ans + all_sum * strength[pivot]) % MOD;\\n            }\\n            stack.push(right);\\n        }\\n        ans as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3137770,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def totalStrength(self, strength: \\'list[int]\\') -> int:\\n        m = int(1e9 + 7)\\n\\t\\t# left first less\\n        ll = [-1] * len(strength)\\n\\t\\t# right first less\\n        rl = [len(strength)] * len(strength)\\n        \\n        stk = []\\n        for i, n in enumerate(strength):\\n            while stk and strength[stk[-1]] > n: rl[stk.pop()] = i\\n            stk.append(i)\\n        stk = []\\n        for i in range(len(strength) - 1, -1, -1):\\n            n = strength[i]\\n            while stk and strength[stk[-1]] >= n: ll[stk.pop()] = i\\n            stk.append(i)\\n        \\n\\t\\t# presum of strength\\n        ps = [0]\\n        for n in strength: ps.append(ps[-1] + n)\\n\\t\\t# presum of presum\\n        pps = [0]\\n        for n in ps: pps.append(pps[-1] + n)\\n\\n        res = 0\\n        for i, n in enumerate(strength):\\n            j, k = ll[i], rl[i]\\n            res += n * ((i - j) * pps[k + 1] + (k - i) * pps[j + 1] + (j - k) * pps[i + 1])\\n        return res % m\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalStrength(self, strength: \\'list[int]\\') -> int:\\n        m = int(1e9 + 7)\\n\\t\\t# left first less\\n        ll = [-1] * len(strength)\\n\\t\\t# right first less\\n        rl = [len(strength)] * len(strength)\\n        \\n        stk = []\\n        for i, n in enumerate(strength):\\n            while stk and strength[stk[-1]] > n: rl[stk.pop()] = i\\n            stk.append(i)\\n        stk = []\\n        for i in range(len(strength) - 1, -1, -1):\\n            n = strength[i]\\n            while stk and strength[stk[-1]] >= n: ll[stk.pop()] = i\\n            stk.append(i)\\n        \\n\\t\\t# presum of strength\\n        ps = [0]\\n        for n in strength: ps.append(ps[-1] + n)\\n\\t\\t# presum of presum\\n        pps = [0]\\n        for n in ps: pps.append(pps[-1] + n)\\n\\n        res = 0\\n        for i, n in enumerate(strength):\\n            j, k = ll[i], rl[i]\\n            res += n * ((i - j) * pps[k + 1] + (k - i) * pps[j + 1] + (j - k) * pps[i + 1])\\n        return res % m\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107131,
                "title": "single-pass-using-mono-stack-and-dynamic-programming",
                "content": "# Intuition\\n\\nI see others\\' solutions is somewhat different (but probably more intuitive) so contributing mine as well.\\n\\nThis can be solved by dp.\\n\\n# Approach\\n\\nWe keep a mono stack like in other solutions. Assume the new element\\'s index is j and the previous element which is less than a[j] has index i i.e. a[i] < a[j]. \\n\\nExample:\\n```\\n23, 24, 2, 25, 3, 26, 27, 7, 9, 10, 11, 8\\n```\\n\\nAssum j is 8 and i would be 7. Wizard sums (subarrays) ending on the j-th element are:\\n\\n```\\ndelta_j = 8*(10 + 2*11 + 3*8) + 7*(26+ 2*27 + 3*7 + 3*sum(i+1, j)) + ...\\n```\\n\\nsum(i+1, j) is inclusive (see the interval_sum function in the code).\\n\\nI defined `index_sum(j) = a[j]*(j+1) + a[j-1]*j + ...`. Then the first factors in `delta_j` multiplied by 8 would be `index_sum(i+1, j) = index_sum(j) - index_sum(i) - (i+1)*sum(i+1, j)`.\\n\\nI keep `index_sum(i)` in the mono-stack itself.\\n\\nFor the `3*7*sum(i+1, j) + 2*3*sum(i+1, j) + ...` factors in `delta_j`, I defined `A_j = 8*4 + 7*3 + 2*3 + ...`. Breaking this down, `A_j = A_i + a[j]*(j-i)`. So to calculate `A_j` I keep `A_i` in the mono-stack as well.\\n\\nThe remaining factors in `delta_j` are equal to `delta_j`.\\n\\nSo to summarize the equations are:\\n\\n```\\nindex_sum(j) = index_sum(j-1) + (j+1)*a[j]\\nindex_sum(i+1, j) = index_sum(j) - index_sum(i) - (i+1)*sum(i+1, j)\\ndelta_j = delta_i + sum(i+1; j)*A_i + index_sum(i+1, j)*a[j]\\nA_j = A_i + a[j]*(j-i)\\n```\\n\\nIf you check the code you will see this is exactly what I did. And I of course used a prefix sum to calculate the interval sum in O(1). In case, there is no `i` (i.e. the new element is the smallest one), I handled it in a separate if statement but it can probably be coded in a better way.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n\\nO(N)\\n\\n- Space complexity:\\n\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def totalStrength(self, a: List[int]) -> int:\\n        # calc prefix\\n        prefix = []\\n        for i in a:\\n            if prefix:\\n                prefix.append(i + prefix[-1])\\n            else:\\n                prefix.append(i)\\n\\n        def interval_sum(i, j):\\n            # i and j within bounds, inclusive\\n            if i == 0:\\n                return prefix[j]\\n            else:\\n                return prefix[j] - prefix[i-1]\\n\\n        stack = []\\n        index_sum = 0\\n        result = 0\\n\\n        for j, n in enumerate(a):\\n            while stack and stack[-1][0] >= n:\\n                stack.pop()\\n            \\n            index_sum = index_sum + (j+1)*n \\n            if not stack:\\n                delta = index_sum * n \\n                stack.append( (n, j, delta, index_sum, n*(j+1)) )\\n            else:\\n                _, i, delta_i, index_sum_i, A_i = stack[-1]\\n                index_sum_i1_j = index_sum - index_sum_i - (i+1) * interval_sum(i+1, j)\\n                delta = delta_i + interval_sum(i+1, j)*A_i + index_sum_i1_j*n \\n                A_j = A_i + n*(j-i)\\n                stack.append( (n, j, delta, index_sum, A_j) )\\n            \\n            result = (result + delta) % (10**9 + 7)\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n23, 24, 2, 25, 3, 26, 27, 7, 9, 10, 11, 8\\n```\n```\\ndelta_j = 8*(10 + 2*11 + 3*8) + 7*(26+ 2*27 + 3*7 + 3*sum(i+1, j)) + ...\\n```\n```\\nindex_sum(j) = index_sum(j-1) + (j+1)*a[j]\\nindex_sum(i+1, j) = index_sum(j) - index_sum(i) - (i+1)*sum(i+1, j)\\ndelta_j = delta_i + sum(i+1; j)*A_i + index_sum(i+1, j)*a[j]\\nA_j = A_i + a[j]*(j-i)\\n```\n```\\nclass Solution:\\n    def totalStrength(self, a: List[int]) -> int:\\n        # calc prefix\\n        prefix = []\\n        for i in a:\\n            if prefix:\\n                prefix.append(i + prefix[-1])\\n            else:\\n                prefix.append(i)\\n\\n        def interval_sum(i, j):\\n            # i and j within bounds, inclusive\\n            if i == 0:\\n                return prefix[j]\\n            else:\\n                return prefix[j] - prefix[i-1]\\n\\n        stack = []\\n        index_sum = 0\\n        result = 0\\n\\n        for j, n in enumerate(a):\\n            while stack and stack[-1][0] >= n:\\n                stack.pop()\\n            \\n            index_sum = index_sum + (j+1)*n \\n            if not stack:\\n                delta = index_sum * n \\n                stack.append( (n, j, delta, index_sum, n*(j+1)) )\\n            else:\\n                _, i, delta_i, index_sum_i, A_i = stack[-1]\\n                index_sum_i1_j = index_sum - index_sum_i - (i+1) * interval_sum(i+1, j)\\n                delta = delta_i + interval_sum(i+1, j)*A_i + index_sum_i1_j*n \\n                A_j = A_i + n*(j-i)\\n                stack.append( (n, j, delta, index_sum, A_j) )\\n            \\n            result = (result + delta) % (10**9 + 7)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095960,
                "title": "monotonic-stack-and-pre-accumulated-sum",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMonotonic Stack to maintain a raising min stack.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nRef: @lee215 https://leetcode.com/problems/sum-of-total-strength-of-wizards/solutions/2061985/java-c-python-one-pass-solution/?orderBy=most_votes\\n```\\nclass Solution {\\n    public int totalStrength(int[] ss) {\\n        int presum = 0, res = 0, n = ss.length, mod = (int) 1e9 + 7;\\n        Stack<Integer> st = new Stack<>(); // monotonic mins from left;\\n        int[] acc = new int[n + 2];\\n        for (int r = 0; r <= n; r++) {\\n            // append 0 to end of ary. to better sum cases of group ending at tail.\\n            int curr = r < n ? ss[r] : 0; \\n            presum = (presum + curr) % mod;\\n            //acc[r+1] sums all pregroup ends before or at ss[r];\\n            acc[r + 1] = (acc[r] + presum) % mod; \\n            while(!st.isEmpty() && ss[st.peek()] > curr) {\\n                //because we met new min, so we have to sum all groups with prev mins\\n                int i = st.pop(); // new min to calculate;\\n                // l is -1 means group starts from head of ary\\n                int l = st.isEmpty() ? -1 : st.peek();\\n                // all sum of pregroups ending with (l, i), exclusive;\\n                int leftAcc = l < 0 ? acc[i] : acc[i] - acc[l];\\n                // all sum of pregroups ending with (i, r), exclusive;\\n                long rightAcc = acc[r] - acc[i];\\n                long leftCount = i - l, rightCount = r - i;\\n                // all sums of combinations from left subgroup + right subgroup.\\n                // proval is trival. \\n                res = (int) (res + (rightAcc * leftCount - leftAcc * rightCount) % mod * ss[i] % mod) % mod;\\n            }\\n            // now st is empty or curr >= st.peek();\\n            // so push to maintain monotonic stack;\\n            st.push(r);\\n        }\\n        return (res + mod) % mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalStrength(int[] ss) {\\n        int presum = 0, res = 0, n = ss.length, mod = (int) 1e9 + 7;\\n        Stack<Integer> st = new Stack<>(); // monotonic mins from left;\\n        int[] acc = new int[n + 2];\\n        for (int r = 0; r <= n; r++) {\\n            // append 0 to end of ary. to better sum cases of group ending at tail.\\n            int curr = r < n ? ss[r] : 0; \\n            presum = (presum + curr) % mod;\\n            //acc[r+1] sums all pregroup ends before or at ss[r];\\n            acc[r + 1] = (acc[r] + presum) % mod; \\n            while(!st.isEmpty() && ss[st.peek()] > curr) {\\n                //because we met new min, so we have to sum all groups with prev mins\\n                int i = st.pop(); // new min to calculate;\\n                // l is -1 means group starts from head of ary\\n                int l = st.isEmpty() ? -1 : st.peek();\\n                // all sum of pregroups ending with (l, i), exclusive;\\n                int leftAcc = l < 0 ? acc[i] : acc[i] - acc[l];\\n                // all sum of pregroups ending with (i, r), exclusive;\\n                long rightAcc = acc[r] - acc[i];\\n                long leftCount = i - l, rightCount = r - i;\\n                // all sums of combinations from left subgroup + right subgroup.\\n                // proval is trival. \\n                res = (int) (res + (rightAcc * leftCount - leftAcc * rightCount) % mod * ss[i] % mod) % mod;\\n            }\\n            // now st is empty or curr >= st.peek();\\n            // so push to maintain monotonic stack;\\n            st.push(r);\\n        }\\n        return (res + mod) % mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075652,
                "title": "did-i-only-read-the-first-line-yes-did-i-give-the-question-a-like-directly-after-this-also-yes",
                "content": "Did I only read the first line? Yes. Did I give the question a like directly after this? Also yes.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3013614,
                "title": "js-segmenttree-tle",
                "content": "The usage of Segment Tree is quite natural for me for this problem. But it got TLE after 67/82 test \\uD83D\\uDE2B Could anyone be able to solve it with the similar approach?\\n\\n# Code\\n```\\n/**\\n * @param {number[]} strength\\n * @return {number}\\n */\\nconst modulus = Math.pow(10,9) + 7;\\nvar totalStrength = function(strength) {\\n    const segTree = new SegTree(strength);\\n    let l = 0, rInit = 1, r = rInit;\\n    const lastIdx = strength.length - 1;\\n    let result = segTree.getSum();\\n\\n    while (r - l < strength.length) {\\n        const query = segTree.query(l, r);\\n        result += query[0] * query[1];\\n        l++;\\n        r++;\\n        if (r > lastIdx) {\\n            l = 0;\\n            rInit++;\\n            r = rInit;\\n            curMin = Infinity;\\n        }\\n    }\\n\\n    return result % modulus;\\n};\\n\\nclass SegTree {\\n    arr = [];\\n    sum = 0;\\n    constructor(arr) {\\n        const n = arr.length;\\n        this.size = n;\\n        this.lastLevelNodeAmount = 2 ** Math.ceil(Math.log2(n));\\n        this.offset = this.lastLevelNodeAmount - 1;\\n        for (let i = 0; i < n; i++) {\\n            this.sum += arr[i] * arr[i];\\n            this.update(i, arr[i]);\\n        }\\n    }\\n    getSum() {\\n        return this.sum;\\n    }\\n    update(idx, val) {\\n        const old = this.arr[this.offset + idx] ?? 0;\\n        const diff = val - old;\\n        this.arr[this.offset + idx] = [val, val];\\n        this._update(this.offset + idx, diff);\\n    }\\n    _update(idx, diff) {\\n        const parentIdx = Math.ceil(idx / 2) - 1;\\n        if (!this.arr[parentIdx]) this.arr[parentIdx] = [0, Infinity];\\n        const parent = this.arr[parentIdx];\\n\\n        parent[0] = parent[0] + diff;\\n        const leftChild = this.arr[parentIdx * 2 + 1] ?? [Infinity];\\n        const rightChild = this.arr[parentIdx * 2 + 2] ?? [Infinity];\\n        parent[1] = Math.min((leftChild[1] ?? Infinity), (rightChild[1] ?? Infinity));\\n\\n        if (parentIdx > 0) this._update(parentIdx, diff)\\n    }\\n    query = (i, j) => {\\n        return this._query(i, j, 0, this.lastLevelNodeAmount, 0);\\n    }\\n    _query(i, j, l, r, idx) {\\n        if (i > r || j < l) return 0;\\n        if (i <= l && j >= Math.min(this.size, r) - 1) return this.arr[idx];\\n\\n        const mid = l + Math.floor((r - l) / 2);\\n        const firstChildIdx = 2 * idx + 1;\\n        const secondChildIdx = 2 * idx + 2;\\n\\n        if (i >= mid) { // right\\n            return this._query(i, j, mid, r, secondChildIdx);\\n        } else if (j < mid) { // left\\n            return this._query(i, j, l, mid, firstChildIdx);\\n        }\\n\\n        const leftQuery = this._query(i, j, l, mid, firstChildIdx);\\n        const rightQuery = this._query(i, j, mid, r, secondChildIdx);\\n\\n        return [leftQuery[0] + rightQuery[0], Math.min(leftQuery[1], rightQuery[1])];\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Segment Tree"
                ],
                "code": "```\\n/**\\n * @param {number[]} strength\\n * @return {number}\\n */\\nconst modulus = Math.pow(10,9) + 7;\\nvar totalStrength = function(strength) {\\n    const segTree = new SegTree(strength);\\n    let l = 0, rInit = 1, r = rInit;\\n    const lastIdx = strength.length - 1;\\n    let result = segTree.getSum();\\n\\n    while (r - l < strength.length) {\\n        const query = segTree.query(l, r);\\n        result += query[0] * query[1];\\n        l++;\\n        r++;\\n        if (r > lastIdx) {\\n            l = 0;\\n            rInit++;\\n            r = rInit;\\n            curMin = Infinity;\\n        }\\n    }\\n\\n    return result % modulus;\\n};\\n\\nclass SegTree {\\n    arr = [];\\n    sum = 0;\\n    constructor(arr) {\\n        const n = arr.length;\\n        this.size = n;\\n        this.lastLevelNodeAmount = 2 ** Math.ceil(Math.log2(n));\\n        this.offset = this.lastLevelNodeAmount - 1;\\n        for (let i = 0; i < n; i++) {\\n            this.sum += arr[i] * arr[i];\\n            this.update(i, arr[i]);\\n        }\\n    }\\n    getSum() {\\n        return this.sum;\\n    }\\n    update(idx, val) {\\n        const old = this.arr[this.offset + idx] ?? 0;\\n        const diff = val - old;\\n        this.arr[this.offset + idx] = [val, val];\\n        this._update(this.offset + idx, diff);\\n    }\\n    _update(idx, diff) {\\n        const parentIdx = Math.ceil(idx / 2) - 1;\\n        if (!this.arr[parentIdx]) this.arr[parentIdx] = [0, Infinity];\\n        const parent = this.arr[parentIdx];\\n\\n        parent[0] = parent[0] + diff;\\n        const leftChild = this.arr[parentIdx * 2 + 1] ?? [Infinity];\\n        const rightChild = this.arr[parentIdx * 2 + 2] ?? [Infinity];\\n        parent[1] = Math.min((leftChild[1] ?? Infinity), (rightChild[1] ?? Infinity));\\n\\n        if (parentIdx > 0) this._update(parentIdx, diff)\\n    }\\n    query = (i, j) => {\\n        return this._query(i, j, 0, this.lastLevelNodeAmount, 0);\\n    }\\n    _query(i, j, l, r, idx) {\\n        if (i > r || j < l) return 0;\\n        if (i <= l && j >= Math.min(this.size, r) - 1) return this.arr[idx];\\n\\n        const mid = l + Math.floor((r - l) / 2);\\n        const firstChildIdx = 2 * idx + 1;\\n        const secondChildIdx = 2 * idx + 2;\\n\\n        if (i >= mid) { // right\\n            return this._query(i, j, mid, r, secondChildIdx);\\n        } else if (j < mid) { // left\\n            return this._query(i, j, l, mid, firstChildIdx);\\n        }\\n\\n        const leftQuery = this._query(i, j, l, mid, firstChildIdx);\\n        const rightQuery = this._query(i, j, mid, r, secondChildIdx);\\n\\n        return [leftQuery[0] + rightQuery[0], Math.min(leftQuery[1], rightQuery[1])];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802646,
                "title": "o-n-solution-using-monotonic-stack-and-prefix-prefix-sum-and-suffix-suffix-sum",
                "content": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    long long sumsubarray(int k,int i,int j,vector<long long>&suff,vector<long long>&ssuff,vector<long long>&pre,vector<long long>&ppre,vector<int>&nums)\\n    {   \\n        int n=nums.size();\\n        long long s=0;\\n        long long p=ssuff[i+1];\\n        if(k+1<n)\\n         p-=ssuff[k+1]+((k-i)*(suff[k+1]));\\n        p%=mod;\\n        \\n        if(j-k-1)\\n        {p*=j-k;\\n         p%=mod;\\n         s=ppre[j-1]-ppre[k]-(j-k-1)*pre[k];\\n         s%=mod;\\n         s*=k-i;\\n         s%=mod;\\n        }\\n        //cout<<p<<\" \"<<s<<endl;\\n       \\n        p+=s;\\n        p%=mod;\\n        p*=nums[k];\\n       \\n        \\n        return p%=mod;\\n        \\n    }\\n    int totalStrength(vector<int>& nums) {\\n       int n=nums.size();\\n        vector<long long>suff(n,0);\\n        vector<long long>ssuff(n,0);\\n        vector<long long>pre(n,0);\\n        vector<long long>ppre(n,0);\\n        suff[n-1]=nums[n-1];\\n        ssuff[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            suff[i]=nums[i];\\n            suff[i]+=suff[i+1];\\n            ssuff[i]=suff[i];\\n            ssuff[i]+=ssuff[i+1];\\n           // cout<<suff[i]<<\" \"<<ssuff[i]<<endl;\\n        }\\n        pre[0]=nums[0];\\n        ppre[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            pre[i]=nums[i];\\n            pre[i]+=pre[i-1];\\n            ppre[i]=pre[i];\\n            ppre[i]+=ppre[i-1];\\n           // cout<<pre[i]<<\" \"<<ppre[i]<<endl;\\n            \\n        }\\n        \\n        \\n        stack<int>st;\\n        long long ans=0;\\n        for(int i=0;i<=n;i++)\\n        {\\n            while(!st.empty()&&(i==n||nums[i]<=nums[st.top()]))\\n            {\\n                int mid=st.top();\\n                st.pop();\\n                int l=(st.empty())?-1:st.top();\\n                int r=i;\\n                //cout<<l<<\" \"<<mid<<\" \"<<r<<endl;\\n                long long buff=sumsubarray(mid,l,r,suff,ssuff,pre,ppre,nums);\\n                //cout<<buff<<endl;\\n                ans+=buff;\\n                ans%=mod;\\n            }\\n            st.push(i);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    long long sumsubarray(int k,int i,int j,vector<long long>&suff,vector<long long>&ssuff,vector<long long>&pre,vector<long long>&ppre,vector<int>&nums)\\n    {   \\n        int n=nums.size();\\n        long long s=0;\\n        long long p=ssuff[i+1];\\n        if(k+1<n)\\n         p-=ssuff[k+1]+((k-i)*(suff[k+1]));\\n        p%=mod;\\n        \\n        if(j-k-1)\\n        {p*=j-k;\\n         p%=mod;\\n         s=ppre[j-1]-ppre[k]-(j-k-1)*pre[k];\\n         s%=mod;\\n         s*=k-i;\\n         s%=mod;\\n        }\\n        //cout<<p<<\" \"<<s<<endl;\\n       \\n        p+=s;\\n        p%=mod;\\n        p*=nums[k];\\n       \\n        \\n        return p%=mod;\\n        \\n    }\\n    int totalStrength(vector<int>& nums) {\\n       int n=nums.size();\\n        vector<long long>suff(n,0);\\n        vector<long long>ssuff(n,0);\\n        vector<long long>pre(n,0);\\n        vector<long long>ppre(n,0);\\n        suff[n-1]=nums[n-1];\\n        ssuff[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            suff[i]=nums[i];\\n            suff[i]+=suff[i+1];\\n            ssuff[i]=suff[i];\\n            ssuff[i]+=ssuff[i+1];\\n           // cout<<suff[i]<<\" \"<<ssuff[i]<<endl;\\n        }\\n        pre[0]=nums[0];\\n        ppre[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            pre[i]=nums[i];\\n            pre[i]+=pre[i-1];\\n            ppre[i]=pre[i];\\n            ppre[i]+=ppre[i-1];\\n           // cout<<pre[i]<<\" \"<<ppre[i]<<endl;\\n            \\n        }\\n        \\n        \\n        stack<int>st;\\n        long long ans=0;\\n        for(int i=0;i<=n;i++)\\n        {\\n            while(!st.empty()&&(i==n||nums[i]<=nums[st.top()]))\\n            {\\n                int mid=st.top();\\n                st.pop();\\n                int l=(st.empty())?-1:st.top();\\n                int r=i;\\n                //cout<<l<<\" \"<<mid<<\" \"<<r<<endl;\\n                long long buff=sumsubarray(mid,l,r,suff,ssuff,pre,ppre,nums);\\n                //cout<<buff<<endl;\\n                ans+=buff;\\n                ans%=mod;\\n            }\\n            st.push(i);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2761142,
                "title": "rust-came-in-clutch-for-me-with-128-bit-types-and-panic-on-overflow-o-n-solution",
                "content": "This problem really tested my resolve and mathematical abilities.  I\\'d really love to see more problems at this level of difficulty because I think this problem singlehandedly made me a better problem solver.  I was so close to giving up and looking at other\\'s solutions, but I knew that I had to do this for myself.\\n\\n\\nInterestingly, it looks like the formulas I came up with were a little different what others came up with.  I had a hard time understanding what other solutions were doing (but given I had already solved it and it tired me out, I wasn\\'t very motivated lol)- this solution focuses heavily on how popping a stack entry subtracts from how previous wizards synergize with the current wizard.\\n\\n\\nI found it quite useful to draw the contribution of each wizard as a set of 3-dimensional blocks.  And when you have 3d drawings, you know it\\'s a hard problem.\\n\\nAlso, how insane were the amazon people who asked this in an interview?  I think they need to get their heads checked.\\n\\n\\nWhat was definitely the hardest part of this for me to derive is the answer to, \\'how much stuff is each stack entry multiplying?\\'\\n\\nIt\\'s a moving target that changes with every new wizard you iterate over.  I finally figured it out when I reasoned, \"so when a stack entry is covering 3 indices and those indices contain, for example, [3,2,4], that entry is multiplying 1x3, 2x2, and 3x4, and then also 3x every wizard from the end of the indices it covers to the index of the wizard we\\'re currently iterating over\".\\n\\nTurns out you can figure this out in constant time with dp and some interesting series math.  To do this you need a vector (named cardinal_sums in my solution) containing: dp[n] = dp[n - 1] + current_wizard_strength * n.  With the example of:\\n[1,6,3,2,4], the dp[5] is a sum containing 1x1  + 2x6 + 3x3 + 4x2 + 5x4.  So to get 1x3 + 2x2 + 3x4 in constant time, you take dp[5] and subtract dp[2], throwing away the 1x1 and 2x6.  That leaves you with just 3x3 + 4x2 + 5x4.  Then, you need to remove 2x(3 + 2 + 4).  If you keep a second vector containing a running sum, you can get (3 + 2 + 4) with sum[5] - sum[2] in constant time.  Subtract 2x(3 + 2 + 4) and you are left with 1x3 + 2x2 + 3x4.\\n\\nAfter that, add (num_indices_for_stack_entry * (sum[n - 1] - sum[end_of_stack_entry]).\\n\\nSee the line that calculates the aptly named \\'stuff_multiplied\\' variable.\\n\\nIt would have been very nasty if I wasn\\'t able to work with 128 bit types- I calculated that the answer itself could overflow a 128 bit integer, but that no entry in cardinal_sums could overflow a 128 bit type given the constraints.  After doing all that math I was kind like, \\'okay, now it\\'s time for the annoying part\\'.  Rust made it so easy to debug overflows that I wasn\\'t aware of- it tells you the exact line on which it occurs.  I\\'m not sure how other solutions in languages without this handled it- in python you get bignums for free I suppose.  Maybe others found a different solution altogether.  I\\'ll look after I post this. \\n\\n\\n```\\nstruct StackObj {\\n    strength:           u64,\\n    n:                  usize,\\n}\\n\\nimpl StackObj {\\n    fn new(k: u64, iteration: usize) -> Self {\\n        Self {\\n            strength:   k,\\n            n:          iteration,\\n        }\\n    }\\n}\\n\\nfn handle_stack(wizard: u64, stack: &mut Vec<StackObj>, sums: &Vec<u64>,\\n        cardinal_sums: &Vec<u128>, last_diff: u128, multiplicand: &mut u64,\\n        n: usize) -> u128 {\\n\\n    let mut prev_diff = last_diff;\\n    let mut n_before = n - 1;\\n    loop {\\n        let len = stack.len();\\n        if wizard > stack[len - 1].strength {\\n            stack.push(StackObj::new(wizard, (n_before + 1) as usize));\\n            break;\\n        } else if wizard == stack[len - 1].strength {\\n            break;\\n        } else {\\n            let popped = stack.pop().unwrap();\\n            let p_len = n_before - popped.n + 1;\\n            let strength_diff = popped.strength - wizard;\\n\\n            let stuff_multiplied = cardinal_sums[n_before]\\n                - (cardinal_sums[popped.n - 1] + (popped.n as u128 - 1)\\n                   * (sums[n_before] - sums[popped.n - 1]) as u128)\\n                + p_len as u128 * (sums[n - 1] - sums[n_before]) as u128;\\n\\n            let mut moddif = prev_diff as i128\\n                - (stuff_multiplied * strength_diff as u128)as i128;\\n            if moddif < 0 {\\n                let x = 1 + -moddif / 1000000007;\\n                moddif += x * 1000000007;\\n                moddif %= 1000000007;\\n            }\\n            prev_diff = moddif as u128;\\n            *multiplicand -= p_len as u64 * strength_diff;\\n            n_before = popped.n - 1;\\n        }\\n    }\\n    *multiplicand += wizard;\\n    return prev_diff\\n}\\n\\nimpl Solution {\\n    pub fn total_strength(strength: Vec<i32>) -> i32 {\\n        let len = strength.len();\\n        let mut stack:          Vec<StackObj> = Vec::new();\\n        let mut sums:           Vec<u64> = vec![0; len + 1];\\n        let mut cardinal_sums:  Vec<u128> = vec![0; len + 1];\\n        let mut prev_diff:      u128 = 0; \\n        let mut multiplicand:   u64 = 0;\\n        let mut total_strength: u128 = 0;\\n\\n        stack.push(StackObj::new(0, 0));\\n        \\n        for n in 1..=strength.len() {\\n            let wizard = strength[n - 1] as u64;\\n            sums[n] = sums[n - 1] + wizard;\\n            cardinal_sums[n] = cardinal_sums[n - 1] + (wizard * n as u64) as u128;\\n\\n            let mod_diff = handle_stack(wizard, &mut stack, &sums,\\n                &cardinal_sums, prev_diff, &mut multiplicand, n);\\n            let diff = (mod_diff + (multiplicand as u128 * wizard as u128) as u128) % 1000000007;\\n            total_strength = (total_strength + diff) % 1000000007;\\n            prev_diff = diff;\\n        } \\n        return total_strength as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nstruct StackObj {\\n    strength:           u64,\\n    n:                  usize,\\n}\\n\\nimpl StackObj {\\n    fn new(k: u64, iteration: usize) -> Self {\\n        Self {\\n            strength:   k,\\n            n:          iteration,\\n        }\\n    }\\n}\\n\\nfn handle_stack(wizard: u64, stack: &mut Vec<StackObj>, sums: &Vec<u64>,\\n        cardinal_sums: &Vec<u128>, last_diff: u128, multiplicand: &mut u64,\\n        n: usize) -> u128 {\\n\\n    let mut prev_diff = last_diff;\\n    let mut n_before = n - 1;\\n    loop {\\n        let len = stack.len();\\n        if wizard > stack[len - 1].strength {\\n            stack.push(StackObj::new(wizard, (n_before + 1) as usize));\\n            break;\\n        } else if wizard == stack[len - 1].strength {\\n            break;\\n        } else {\\n            let popped = stack.pop().unwrap();\\n            let p_len = n_before - popped.n + 1;\\n            let strength_diff = popped.strength - wizard;\\n\\n            let stuff_multiplied = cardinal_sums[n_before]\\n                - (cardinal_sums[popped.n - 1] + (popped.n as u128 - 1)\\n                   * (sums[n_before] - sums[popped.n - 1]) as u128)\\n                + p_len as u128 * (sums[n - 1] - sums[n_before]) as u128;\\n\\n            let mut moddif = prev_diff as i128\\n                - (stuff_multiplied * strength_diff as u128)as i128;\\n            if moddif < 0 {\\n                let x = 1 + -moddif / 1000000007;\\n                moddif += x * 1000000007;\\n                moddif %= 1000000007;\\n            }\\n            prev_diff = moddif as u128;\\n            *multiplicand -= p_len as u64 * strength_diff;\\n            n_before = popped.n - 1;\\n        }\\n    }\\n    *multiplicand += wizard;\\n    return prev_diff\\n}\\n\\nimpl Solution {\\n    pub fn total_strength(strength: Vec<i32>) -> i32 {\\n        let len = strength.len();\\n        let mut stack:          Vec<StackObj> = Vec::new();\\n        let mut sums:           Vec<u64> = vec![0; len + 1];\\n        let mut cardinal_sums:  Vec<u128> = vec![0; len + 1];\\n        let mut prev_diff:      u128 = 0; \\n        let mut multiplicand:   u64 = 0;\\n        let mut total_strength: u128 = 0;\\n\\n        stack.push(StackObj::new(0, 0));\\n        \\n        for n in 1..=strength.len() {\\n            let wizard = strength[n - 1] as u64;\\n            sums[n] = sums[n - 1] + wizard;\\n            cardinal_sums[n] = cardinal_sums[n - 1] + (wizard * n as u64) as u128;\\n\\n            let mod_diff = handle_stack(wizard, &mut stack, &sums,\\n                &cardinal_sums, prev_diff, &mut multiplicand, n);\\n            let diff = (mod_diff + (multiplicand as u128 * wizard as u128) as u128) % 1000000007;\\n            total_strength = (total_strength + diff) % 1000000007;\\n            prev_diff = diff;\\n        } \\n        return total_strength as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2748119,
                "title": "c-o-n-previous-next-smaller-element-calculating-all-subarray-sums-between-l-r",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKinda heavy maths for getting the subarray sum\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* get the bound for every index\\n* get the subarray sum in this bound\\n* Multiply\\n* Profit\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& a) {\\n        using ll = long long;\\n        ll n=a.size();\\n        vector<ll>pse(n, -1), nse(n, n);\\n        stack<ll>s;\\n        for(ll i=0; i<n; i++){\\n            while(s.size() && a[s.top()]>a[i]){\\n                nse[s.top()] = i;\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n        while(s.size())s.pop();\\n        for(ll i=n-1; i>=0; i--){\\n            while(s.size() && a[s.top()]>=a[i]){\\n                pse[s.top()]=i;\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n        vector<ll>pref(n), incl(n), incls(n), ppref(n);\\n        pref[0]=a[0]; incl[0]=a[0]; ppref[0]=a[0]; incls[n-1] = a[n-1];\\n        const ll M=1e9+7;\\n        for(ll i=1; i<n; i++){\\n            incl[i] = (incl[i-1]+(1ll*a[i]*(i+1))%M)%M;\\n            pref[i] = (pref[i-1] + incl[i])%M;\\n            ppref[i] = (a[i]+ppref[i-1])%M;\\n        }\\n        for(ll i=n-2; i>=0; i--){\\n            incls[i] = (incls[i+1]+(1ll*a[i]*(n-i))%M)%M;\\n        }\\n        auto sum = [&](int l, int r){\\n            if(l>r)return 0ll;\\n            ll ans = ((pref[r] - (l>0?pref[l-1]:0))%M+M)%M;\\n            ll len = r-l+1;\\n            if(l>0){\\n                ll ln = l;\\n                ll rig = n-1-r;\\n                ll subSum = ((ppref[r]-ppref[l-1])%M+M)%M;\\n                ans=((ans - (incl[l-1]*len)%M)%M+M)%M;\\n                ll extra = (ln * incls[l])%M;\\n                if(r+1<n){\\n                    extra = ((extra - (ln*incls[r+1])%M)%M+M)%M;\\n                    extra = ((extra - (ln*subSum*rig)%M)%M+M)%M;\\n                }\\n                ans = ((ans - extra)%M+M)%M;\\n            }\\n            return ans;\\n        };\\n\\n        ll ans=0;\\n        for(int i=0; i<n; i++){\\n            ll lef = pse[i]+1;\\n            ll rig = nse[i]-1;\\n            ll s=((sum(lef, rig) - sum(i+1, rig) - sum(lef, i-1))%M+M)%M;\\n            ans = (ans + (s*1ll*a[i])%M)%M;\\n        }\\n        return ans%M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& a) {\\n        using ll = long long;\\n        ll n=a.size();\\n        vector<ll>pse(n, -1), nse(n, n);\\n        stack<ll>s;\\n        for(ll i=0; i<n; i++){\\n            while(s.size() && a[s.top()]>a[i]){\\n                nse[s.top()] = i;\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n        while(s.size())s.pop();\\n        for(ll i=n-1; i>=0; i--){\\n            while(s.size() && a[s.top()]>=a[i]){\\n                pse[s.top()]=i;\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n        vector<ll>pref(n), incl(n), incls(n), ppref(n);\\n        pref[0]=a[0]; incl[0]=a[0]; ppref[0]=a[0]; incls[n-1] = a[n-1];\\n        const ll M=1e9+7;\\n        for(ll i=1; i<n; i++){\\n            incl[i] = (incl[i-1]+(1ll*a[i]*(i+1))%M)%M;\\n            pref[i] = (pref[i-1] + incl[i])%M;\\n            ppref[i] = (a[i]+ppref[i-1])%M;\\n        }\\n        for(ll i=n-2; i>=0; i--){\\n            incls[i] = (incls[i+1]+(1ll*a[i]*(n-i))%M)%M;\\n        }\\n        auto sum = [&](int l, int r){\\n            if(l>r)return 0ll;\\n            ll ans = ((pref[r] - (l>0?pref[l-1]:0))%M+M)%M;\\n            ll len = r-l+1;\\n            if(l>0){\\n                ll ln = l;\\n                ll rig = n-1-r;\\n                ll subSum = ((ppref[r]-ppref[l-1])%M+M)%M;\\n                ans=((ans - (incl[l-1]*len)%M)%M+M)%M;\\n                ll extra = (ln * incls[l])%M;\\n                if(r+1<n){\\n                    extra = ((extra - (ln*incls[r+1])%M)%M+M)%M;\\n                    extra = ((extra - (ln*subSum*rig)%M)%M+M)%M;\\n                }\\n                ans = ((ans - extra)%M+M)%M;\\n            }\\n            return ans;\\n        };\\n\\n        ll ans=0;\\n        for(int i=0; i<n; i++){\\n            ll lef = pse[i]+1;\\n            ll rig = nse[i]-1;\\n            ll s=((sum(lef, rig) - sum(i+1, rig) - sum(lef, i-1))%M+M)%M;\\n            ans = (ans + (s*1ll*a[i])%M)%M;\\n        }\\n        return ans%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2688217,
                "title": "python-solution-using-presum-and-monotonous-increasing-stack",
                "content": "After scouring multiple sources, I have managed to condense my solution into the following:\\n\\nReference:[ Brilliant solution by @yuanzhi247012 for Leetcode 907](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/284184/Python-Max-Histogram)\\n\\n```\\ndef totalStrength(self, strength: List[int]) -> int:\\n        # Getting list of presums:\\n        presums = [0] * (len(strength) + 2)\\n        curr_sum = 0\\n        \\n        for i in range(len(strength)):\\n            curr_sum += strength[i]\\n            presums[i + 1] = (presums[i] + curr_sum)\\n            \\n        strength.append(-1)\\n        stack = []\\n        total = 0\\n        MOD = 1e9 + 7\\n        \\n        for i in range(len(strength)):\\n            while stack and strength[stack[-1]] > strength[i]:\\n                idx = stack.pop()\\n                left = stack[-1] if stack else -1\\n                total += strength[idx] * ((idx - left) * (presums[i] - presums[idx]) - ((i - idx) * (presums[idx] - presums[left])))\\n            stack.append(i)\\n            \\n        return total % (10 ** 9 + 7)\\n```\\n\\n__Elaborations:__\\n\\n_1. Prefix sum:_\\nReference: [prefix_sum part of the solution to the problem by @Username1604](https://leetcode.com/problems/sum-of-total-strength-of-wizards/discuss/2534592/Python-O(N)-time-and-space)\\n\\nI used the following function to calculate the prefix sum (https://en.wikipedia.org/wiki/Prefix_sum):\\n```\\ndef get_presums(self, strength):\\n        n  = len(strength)\\n        res = [0] * (n + 2)\\n        cur_sum = 0\\n        \\n        for i in range(n):\\n            cur_sum += strength[i]\\n            res[i+1] = (res[i] + cur_sum)\\n                    \\n        return res\\n```\\n\\n_2. Monotonous Increasing Stack:_\\nReference: [Beautiful explanantion by @wxd_sjtu for Leetcode 907](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/178876/stack-solution-with-very-detailed-explanation-step-by-step)\\n\\nThen, I combined the calculation of the __Previous Lesser Element(PLE)__ and the __Next Lesser Element(NLE)__ using __Monotonous Increasing Stack(MIS)__ into one. Individually, the functions would be as follows:\\n\\n_For PLE_\\n```\\n\"\"\"\\nMIS of previous lesser elements. Each element in the PLE stack is the PLE of the element in the input array at the i^th index\\n\"\"\"\\ndef get_ple_stack(arr):\\n\\t\\tidx_stack = []\\n\\t\\tple_stack = [-1] * len(arr)\\n\\t\\t\\'\\'\\' ple_stack[i] = j means arr[j] is PLE of arr[i]\\n\\t\\tple_stack[i] = -1 means arr[i] has no PLE\\'\\'\\'\\n\\t\\t\\n\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\twhile idx_stack and arr[idx_stack[-1]] > a[j]:\\n\\t\\t\\t\\t\\t\\tidx_stack.pop()\\n\\t\\t\\t\\tple_stack[i] = idx_stack[-1] if idx_stack else -1\\n\\t\\t\\t\\tstack.append(i)\\n\\t\\t\\t\\t\\n\\t\\treturn ple_stack\\n```\\n\\n_And for NLE_\\n```\\n\"\"\"\\nMIS of next lesser elements. Each element in the NLE stack is the NLE of the element in the input array at the i^th index\\n\"\"\"\\ndef get_nle_stack(arr):\\n\\t\\tidx_stack = []\\n\\t\\tnle_stack = [-1] * len(arr)\\n\\t\\t\\'\\'\\' nle_stack[i] = j means arr[j] is NLE of arr[i]\\n\\t\\tnle_stack[i] = -1 means arr[i] has no NLE\\'\\'\\'\\n\\t\\t\\n\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\twhile idx_stack and arr[idx_stack[-1]] > a[j]:\\n\\t\\t\\t\\t\\t\\tx = idx_stack.pop()\\n\\t\\t\\t\\t\\t\\tnle_stack[x] = i\\n\\t\\t\\t\\tidx_stack.append(i)\\n\\t\\t\\t\\t\\n\\t\\treturn nle_stack\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\ndef totalStrength(self, strength: List[int]) -> int:\\n        # Getting list of presums:\\n        presums = [0] * (len(strength) + 2)\\n        curr_sum = 0\\n        \\n        for i in range(len(strength)):\\n            curr_sum += strength[i]\\n            presums[i + 1] = (presums[i] + curr_sum)\\n            \\n        strength.append(-1)\\n        stack = []\\n        total = 0\\n        MOD = 1e9 + 7\\n        \\n        for i in range(len(strength)):\\n            while stack and strength[stack[-1]] > strength[i]:\\n                idx = stack.pop()\\n                left = stack[-1] if stack else -1\\n                total += strength[idx] * ((idx - left) * (presums[i] - presums[idx]) - ((i - idx) * (presums[idx] - presums[left])))\\n            stack.append(i)\\n            \\n        return total % (10 ** 9 + 7)\\n```\n```\\ndef get_presums(self, strength):\\n        n  = len(strength)\\n        res = [0] * (n + 2)\\n        cur_sum = 0\\n        \\n        for i in range(n):\\n            cur_sum += strength[i]\\n            res[i+1] = (res[i] + cur_sum)\\n                    \\n        return res\\n```\n```\\n\"\"\"\\nMIS of previous lesser elements. Each element in the PLE stack is the PLE of the element in the input array at the i^th index\\n\"\"\"\\ndef get_ple_stack(arr):\\n\\t\\tidx_stack = []\\n\\t\\tple_stack = [-1] * len(arr)\\n\\t\\t\\'\\'\\' ple_stack[i] = j means arr[j] is PLE of arr[i]\\n\\t\\tple_stack[i] = -1 means arr[i] has no PLE\\'\\'\\'\\n\\t\\t\\n\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\twhile idx_stack and arr[idx_stack[-1]] > a[j]:\\n\\t\\t\\t\\t\\t\\tidx_stack.pop()\\n\\t\\t\\t\\tple_stack[i] = idx_stack[-1] if idx_stack else -1\\n\\t\\t\\t\\tstack.append(i)\\n\\t\\t\\t\\t\\n\\t\\treturn ple_stack\\n```\n```\\n\"\"\"\\nMIS of next lesser elements. Each element in the NLE stack is the NLE of the element in the input array at the i^th index\\n\"\"\"\\ndef get_nle_stack(arr):\\n\\t\\tidx_stack = []\\n\\t\\tnle_stack = [-1] * len(arr)\\n\\t\\t\\'\\'\\' nle_stack[i] = j means arr[j] is NLE of arr[i]\\n\\t\\tnle_stack[i] = -1 means arr[i] has no NLE\\'\\'\\'\\n\\t\\t\\n\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\twhile idx_stack and arr[idx_stack[-1]] > a[j]:\\n\\t\\t\\t\\t\\t\\tx = idx_stack.pop()\\n\\t\\t\\t\\t\\t\\tnle_stack[x] = i\\n\\t\\t\\t\\tidx_stack.append(i)\\n\\t\\t\\t\\t\\n\\t\\treturn nle_stack\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2681659,
                "title": "detialed-solution-with-thougth-process",
                "content": "\\n**Its basically Leetcode hard problem (or harder side dont get demotivate by this problem see what you have learnt from this problem.**\\n\\nlets suppose array is A = [a1 a2 a3 a4 a5 a6 a7]\\n\\nwe basically have to calculate for all subarrays sum(A[l:r])*min(A[l:r]) which basically means for every sum we have to take sum and multiply it by minimum element of that subarray.\\n\\nlets see another prespective of this problem we basically can do is for every element we will find sum of all subarrays in which that element is minimum. now comes the questions how to find that lets take example\\n\\nsuppose for element a4 , a6 is next smaller element of a4, a6 that means first element after a4 that is smaller than a4.\\n\\nsimilarly we can define previous smaller element lets suppose a2 is the previous smaller element.\\n\\ni is index of a2 \\nj is index of a6 \\nk is index of a4\\n[a1 a2 a3 a4 a5 a6 a7]\\n\\nwe have to find sum of all subarrays that include A[k] from subarray of A[i+1:j-1]. because in all that subarray A[k] will be minimum (A[i] and A[j] are right and left closest element greater than a[k])\\n\\nNow to find the sum of all subarrays we need to think how we can compute that\\n\\nwe can basically find the how many times a particular element occurs in all subarray then we can do element*howmanysubarrayitoccurs.\\n\\nlets see a3 how many times it will occur. as a3 is last index of subarray A[i+1:j-1];\\nOccurence of a3 will be (j-k) as we have fixed our left pointer of subarray. h\\nOccurence of a4 will be (j-k) + occurence of a3 (if we are choosing right pointer at a3 a4 is also the part of that subarray) which is 2*(k-j).\\n\\nFrom here we can say that\\nA[i+1] will occur (j-k) times\\nA[i+2] will occur 2*(j-k) times\\nA[i+3] will occur 3*(j-k) times.\\nSo on.\\n\\nSimilarly\\nA[j-1] will occur (k-i) times\\nA[j-2] will occur 2*(k-i) times.\\nSo on\\nA[k] will occur (j-k)*(k-i) times (as there are j-k ways to choose right pointer k-i way for left pointer )\\nSo sum of all subarrays will be\\n\\nA[i+1](j-k) + 2(j-k)A[i+2]..........A[k](j-k)(k-1) + A[j-1](k-i) + A[j-2]*(k-i)*2\\n\\nadding and subtracting A[k](j-k)(k-1) expression will become\\n\\nA[i+1](j-k) + 2(j-k)A[i+2]..........A[k](j-k)(k-i) + A[j-1](k-i) + A[j-2](k-i)2....\\nA[k](j-k)(k-i) - A[k](j-k)(k-i)\\n\\n(j-k)(A[i+1] + 2A[i+2] ..... (k-i)A[k]) + (k-i)(A[j-1] + 2A[j-2] ... A[k](j-k)) - A[k](j-k)) - A[k](j-k)*(k-i)\\n\\nif you observe A[i+1] + 2*A[i+2] ..... (k-i)*A[k] is basically SumSubarr[k:k] + sumSubarr[k-1:K] ..... sumSubarr[i+1:K]\\n\\nsimilarly (A[j-1] + 2A[j-2] ... A[k](j-k)) - A[k]*(j-k)) = SumSubarr[k:k] + sumSubarr[K:K+1] ..... sumSubarr[K:j-1]\\n\\nlets see how to find SumSubarr[k:k] + sumSubarr[k-1:K] ..... sumSubarr[i+1:K] for particular subarray\\n\\nwe can maintain two prefix sum first presum[K] = sumofSubarray A[0:K]\\nsecond is continuousPresumLeft[K] = sum of all subarray sum(A[l:K]) where 0 <= l <= K\\n\\nbut we need to find sum(A[l:K]) where i <= l <= K\\n\\nformula of this is basically\\n\\nsum(A[l:K]) (where i <= l <= K) = continuousPresumLeft[k] - (continuousPresumLeft[i+1] - arr[l+1]) - presum[k] - presum[i])*i;\\n\\n// this i find by manupilating\\n\\nsimilarly you can find\\n\\ncontinuousPresumRight[K] = sum of all subarray sum(A[K:l]) where k <= l <= n-1;\\n\\nsum(A[k:l]) (where k <= l <= j) = ontinuousPresumRight[k] - (continuousPresumRight[j-1] - arr[j-1]) - presum[j-1] - presum[k-1])*(n-2-j)\\n\\nso for particular index k\\nwe will add\\nans += (sum(A[l:K]) (where i <= l <= K) + sum(A[k:l]) (where k <= l <= j) - A[k](k-j)(i-k))*A[k]\\nthis is how i have calculated rest of you can understand by code.\\nthere may be easy way to understand but i came up with this.\\n**\\n```\\n // presum\\n    vector<ll>presum(n);\\n    presum[0] = arr[0];\\n    for (ll i = 1; i < n; i++)\\n    {\\n        presum[i] = arr[i] +  presum[i - 1];\\n        presum[i] %= mod;\\n    }\\n\\n    //PresumRight\\n    vector<ll>continuousPresumRight(n);\\n    continuousPresumRight[n - 1] = arr[n - 1];\\n    for (ll i = n - 2; i >= 0; i--)\\n    {\\n        continuousPresumRight[i] = continuousPresumRight[i + 1] + (arr[i] * (n - i)) % mod;\\n        continuousPresumRight[i] %= mod;\\n    }\\n\\n    //PresumLeft\\n    vector<ll>continuousPresumLeft(n);\\n    continuousPresumLeft[0] = arr[0];\\n    for (ll i = 1; i < n; i++)\\n    {\\n        continuousPresumLeft[i] = continuousPresumLeft[i - 1] + (arr[i] * (i + 1)) % mod;\\n        continuousPresumLeft[i] %= mod;\\n    }\\n\\n\\n\\n\\n    // next Smaller\\n    vector<ll>nextSmaller(n, n);\\n    stack<ll>s;\\n    for (ll i = 0; i < n; i++)\\n    {\\n        while (!s.empty() && arr[i] < arr[s.top()])\\n        {\\n            nextSmaller[s.top()] = i;\\n            s.pop();\\n        }\\n        s.push(i);\\n    }\\n    while (!s.empty())\\n    {\\n        s.pop();\\n    }\\n\\n\\n    // previous Smaller\\n    vector<ll>previousSmaller(n, -1);\\n    for (ll i = n - 1; i >= 0; i--)\\n    {\\n        while (!s.empty() && arr[i] <= arr[s.top()])\\n        {\\n            previousSmaller[s.top()] = i;\\n            s.pop();\\n        }\\n        s.push(i);\\n    }\\n\\n    // finding Answer\\n    ll ans = 0;\\n    for (ll i = 0; i < n; i++)\\n    {\\n        // right ContinousSum\\n        ll right_index = nextSmaller[i] - 1;\\n        ll left_index = i;\\n\\n        ll a_part = continuousPresumRight[right_index] - arr[right_index] + mod;\\n        a_part %= mod;\\n\\n        ll b_part = 0;\\n        if (right_index > 0)\\n        {\\n            b_part += presum[right_index - 1];\\n        }\\n        if (left_index > 0)\\n        {\\n            b_part -= presum[left_index - 1];\\n        }\\n        b_part += mod;\\n        b_part %= mod;\\n\\n        ll sum1 = continuousPresumRight[left_index] - a_part - (b_part * (n - 1 - right_index)) % mod + 2 * mod;\\n        sum1 %= mod;\\n\\n        // left continuous\\n        left_index = previousSmaller[i] + 1;\\n        right_index = i;\\n\\n        a_part = continuousPresumLeft[left_index] - arr[left_index] + mod;\\n        b_part =  presum[right_index] - presum[left_index] + mod;\\n        a_part %= mod;\\n        b_part %= mod;\\n        ll sum2 = continuousPresumLeft[right_index] - a_part - (b_part * (left_index)) % mod + 2 * mod ;\\n        sum2 %= mod;\\n\\n\\n\\n        ll finalvalue = ( (sum1 * (i - previousSmaller[i])) % mod   + (sum2 * (nextSmaller[i] - i)) % mod - ((i - previousSmaller[i]) * (nextSmaller[i] - i)) % mod * arr[i]) % mod * arr[i];\\n        finalvalue %= mod;\\n        cout << finalvalue << \" \";\\n        ans += finalvalue;\\n    }\\n    cout << \"\\\\n\";\\n    cout << ans << \"\\\\n\";\\n\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n // presum\\n    vector<ll>presum(n);\\n    presum[0] = arr[0];\\n    for (ll i = 1; i < n; i++)\\n    {\\n        presum[i] = arr[i] +  presum[i - 1];\\n        presum[i] %= mod;\\n    }\\n\\n    //PresumRight\\n    vector<ll>continuousPresumRight(n);\\n    continuousPresumRight[n - 1] = arr[n - 1];\\n    for (ll i = n - 2; i >= 0; i--)\\n    {\\n        continuousPresumRight[i] = continuousPresumRight[i + 1] + (arr[i] * (n - i)) % mod;\\n        continuousPresumRight[i] %= mod;\\n    }\\n\\n    //PresumLeft\\n    vector<ll>continuousPresumLeft(n);\\n    continuousPresumLeft[0] = arr[0];\\n    for (ll i = 1; i < n; i++)\\n    {\\n        continuousPresumLeft[i] = continuousPresumLeft[i - 1] + (arr[i] * (i + 1)) % mod;\\n        continuousPresumLeft[i] %= mod;\\n    }\\n\\n\\n\\n\\n    // next Smaller\\n    vector<ll>nextSmaller(n, n);\\n    stack<ll>s;\\n    for (ll i = 0; i < n; i++)\\n    {\\n        while (!s.empty() && arr[i] < arr[s.top()])\\n        {\\n            nextSmaller[s.top()] = i;\\n            s.pop();\\n        }\\n        s.push(i);\\n    }\\n    while (!s.empty())\\n    {\\n        s.pop();\\n    }\\n\\n\\n    // previous Smaller\\n    vector<ll>previousSmaller(n, -1);\\n    for (ll i = n - 1; i >= 0; i--)\\n    {\\n        while (!s.empty() && arr[i] <= arr[s.top()])\\n        {\\n            previousSmaller[s.top()] = i;\\n            s.pop();\\n        }\\n        s.push(i);\\n    }\\n\\n    // finding Answer\\n    ll ans = 0;\\n    for (ll i = 0; i < n; i++)\\n    {\\n        // right ContinousSum\\n        ll right_index = nextSmaller[i] - 1;\\n        ll left_index = i;\\n\\n        ll a_part = continuousPresumRight[right_index] - arr[right_index] + mod;\\n        a_part %= mod;\\n\\n        ll b_part = 0;\\n        if (right_index > 0)\\n        {\\n            b_part += presum[right_index - 1];\\n        }\\n        if (left_index > 0)\\n        {\\n            b_part -= presum[left_index - 1];\\n        }\\n        b_part += mod;\\n        b_part %= mod;\\n\\n        ll sum1 = continuousPresumRight[left_index] - a_part - (b_part * (n - 1 - right_index)) % mod + 2 * mod;\\n        sum1 %= mod;\\n\\n        // left continuous\\n        left_index = previousSmaller[i] + 1;\\n        right_index = i;\\n\\n        a_part = continuousPresumLeft[left_index] - arr[left_index] + mod;\\n        b_part =  presum[right_index] - presum[left_index] + mod;\\n        a_part %= mod;\\n        b_part %= mod;\\n        ll sum2 = continuousPresumLeft[right_index] - a_part - (b_part * (left_index)) % mod + 2 * mod ;\\n        sum2 %= mod;\\n\\n\\n\\n        ll finalvalue = ( (sum1 * (i - previousSmaller[i])) % mod   + (sum2 * (nextSmaller[i] - i)) % mod - ((i - previousSmaller[i]) * (nextSmaller[i] - i)) % mod * arr[i]) % mod * arr[i];\\n        finalvalue %= mod;\\n        cout << finalvalue << \" \";\\n        ans += finalvalue;\\n    }\\n    cout << \"\\\\n\";\\n    cout << ans << \"\\\\n\";\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2669322,
                "title": "java-solution-monotonic-stack-w-arraydeque-to-improve-runtime-o-n",
                "content": "# Intuition\\nJava Solution for Sum of Total Strength of Wizards. \\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nBoth where N is the length of the input array $$strength$$.\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int totalStrength(int[] strength) {\\n        // Null or empty check for input\\n        if (strength == null || strength.length == 0) return 0;\\n\\n        int resStrength = 0;                            // Stores the sum of total strengths of all groups of wizards\\n        int mod = (int) Math.pow(10, 9) + 7;            // Modulus used for the answer\\n        int ac = 0;                                     //\\n        int n = strength.length;                        // Length of input\\n\\n        // Init a Monotonic Stack - \\n        // Used ArrayDeque for Stack instead of Stack as ArrayDeque does not require acquiring & releasing thread locks, which is costly in time\\n        Deque<Integer> stack = new ArrayDeque<Integer>();\\n        // Init an int arr to store accumulations\\n        int[] acc = new int[n + 2];\\n\\n        // Iterate through all wizards strengths from the input arr\\n        for (int i = 0; i <= n; i++)\\n        {\\n            int a = i < n ? strength[i] : 0;\\n\\n            ac = (ac + a) % mod;\\n            acc[i + 1] = (ac + acc[i]) % mod;\\n\\n            while (!stack.isEmpty() && strength[stack.peek()] > a)\\n            {\\n                int j = stack.pop();\\n                int l = stack.isEmpty() ? -1 : stack.peek();\\n\\n                long leftAcc = l < 0 ? acc[j] : acc[j] - acc[l];\\n                long rightAcc = acc[i] - acc[j];\\n                \\n                int ln = j - l;\\n                int rn = i - j;\\n\\n                resStrength = (int) (resStrength + (rightAcc * ln - leftAcc * rn) % mod * strength[j] % mod) % mod;\\n            }\\n\\n            stack.push(i);\\n        }\\n\\n        // Return the sum of the total strengths of all contiguous groups of qizards in mod(10^9) + 7\\n        return (resStrength + mod) % mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int totalStrength(int[] strength) {\\n        // Null or empty check for input\\n        if (strength == null || strength.length == 0) return 0;\\n\\n        int resStrength = 0;                            // Stores the sum of total strengths of all groups of wizards\\n        int mod = (int) Math.pow(10, 9) + 7;            // Modulus used for the answer\\n        int ac = 0;                                     //\\n        int n = strength.length;                        // Length of input\\n\\n        // Init a Monotonic Stack - \\n        // Used ArrayDeque for Stack instead of Stack as ArrayDeque does not require acquiring & releasing thread locks, which is costly in time\\n        Deque<Integer> stack = new ArrayDeque<Integer>();\\n        // Init an int arr to store accumulations\\n        int[] acc = new int[n + 2];\\n\\n        // Iterate through all wizards strengths from the input arr\\n        for (int i = 0; i <= n; i++)\\n        {\\n            int a = i < n ? strength[i] : 0;\\n\\n            ac = (ac + a) % mod;\\n            acc[i + 1] = (ac + acc[i]) % mod;\\n\\n            while (!stack.isEmpty() && strength[stack.peek()] > a)\\n            {\\n                int j = stack.pop();\\n                int l = stack.isEmpty() ? -1 : stack.peek();\\n\\n                long leftAcc = l < 0 ? acc[j] : acc[j] - acc[l];\\n                long rightAcc = acc[i] - acc[j];\\n                \\n                int ln = j - l;\\n                int rn = i - j;\\n\\n                resStrength = (int) (resStrength + (rightAcc * ln - leftAcc * rn) % mod * strength[j] % mod) % mod;\\n            }\\n\\n            stack.push(i);\\n        }\\n\\n        // Return the sum of the total strengths of all contiguous groups of qizards in mod(10^9) + 7\\n        return (resStrength + mod) % mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661546,
                "title": "java-tle-but-gives-good-result",
                "content": "EDIT: forgot the Product class so now I added it :facepalm:\\n```\\npublic static class Product {\\n\\tpublic Product(int min, int sum) {\\n\\t\\tthis.min = min;\\n\\t\\tthis.sum = sum;\\n\\t}\\n\\tpublic int min;\\n\\tpublic int sum;\\n}\\n\\npublic static final int MODULO = (int)Math.pow(10, 9) + 7;    \\n\\npublic int totalStrength(int[] strength) {\\n\\tint str = 0;\\n\\tProduct[] previousProducts = new Product[strength.length];\\n\\tfor (int i = 0; i < strength.length; ++i) {\\n\\t\\tint val = strength[i];\\n\\t\\tpreviousProducts[i] = new Product(val, val);\\n\\t\\tstr = (int)(str + ((long)val * val) % MODULO) % MODULO;\\n\\t}\\n\\tfor (int i = 1; i < strength.length; ++i) {\\n\\t\\tfor (int j = i; j < strength.length; ++j) {\\n\\t\\t\\tProduct prevProduct = previousProducts[j - i];\\n\\t\\t\\tprevProduct.min = Math.min(prevProduct.min, strength[j]);\\n\\t\\t\\tprevProduct.sum = (prevProduct.sum + strength[j]) % MODULO;\\n\\t\\t\\tstr = (int)(str + ((long)prevProduct.min * prevProduct.sum) % MODULO) % MODULO;\\n\\t\\t}\\n\\t}\\n\\treturn str;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static class Product {\\n\\tpublic Product(int min, int sum) {\\n\\t\\tthis.min = min;\\n\\t\\tthis.sum = sum;\\n\\t}\\n\\tpublic int min;\\n\\tpublic int sum;\\n}\\n\\npublic static final int MODULO = (int)Math.pow(10, 9) + 7;    \\n\\npublic int totalStrength(int[] strength) {\\n\\tint str = 0;\\n\\tProduct[] previousProducts = new Product[strength.length];\\n\\tfor (int i = 0; i < strength.length; ++i) {\\n\\t\\tint val = strength[i];\\n\\t\\tpreviousProducts[i] = new Product(val, val);\\n\\t\\tstr = (int)(str + ((long)val * val) % MODULO) % MODULO;\\n\\t}\\n\\tfor (int i = 1; i < strength.length; ++i) {\\n\\t\\tfor (int j = i; j < strength.length; ++j) {\\n\\t\\t\\tProduct prevProduct = previousProducts[j - i];\\n\\t\\t\\tprevProduct.min = Math.min(prevProduct.min, strength[j]);\\n\\t\\t\\tprevProduct.sum = (prevProduct.sum + strength[j]) % MODULO;\\n\\t\\t\\tstr = (int)(str + ((long)prevProduct.min * prevProduct.sum) % MODULO) % MODULO;\\n\\t\\t}\\n\\t}\\n\\treturn str;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652805,
                "title": "java-solution",
                "content": "\"\"\"\\nclass Solution {\\n    \\n    private static int fullStrength=0;\\n   \\n    private static int returnMin(int[] minArr) {\\n        Integer[] min_Arr = Arrays.stream( minArr ).boxed().toArray( Integer[]::new );\\n        return Collections.min(Arrays.asList(min_Arr));\\n    }\\n    \\n    private static int returnSum(int[] sumArr) {\\n        int currentSum=0;\\n        for(int i=0;i<sumArr.length;i++) {\\n            currentSum += sumArr[i];\\n        }\\n        return currentSum;\\n    }\\n    \\n    private static int returnAllPlateSizesPossible(int[] completePlate, int numberOfSteps, int maxIndex, int currentLoc, int maxLoc) {\\n       if(maxLoc>=maxIndex) return fullStrength;\\n        else {\\n        maxLoc = currentLoc +  numberOfSteps;\\n        int[] currentArr = new int[numberOfSteps];\\n        int j=currentLoc;\\n        for(int i=0;i<numberOfSteps;i++) {\\n            currentArr[i] = completePlate[j];\\n            j++;\\n        }\\n       fullStrength += returnMin(currentArr) * returnSum(currentArr);\\n      return returnAllPlateSizesPossible(completePlate, numberOfSteps, maxIndex, currentLoc+1,maxLoc);    \\n        }\\n    }\\n    \\n    \\n    public int totalStrength(int[] strength) {\\n        \\n        int fullLength = strength.length;\\n        \\n        for(int i=0;i<strength.length;i++) {\\n        fullStrength += strength[i] * strength[i];    \\n        }\\n        \\n        if(fullLength==1) return fullStrength;\\n        \\n        int minSubArrLength=2;\\n        while(minSubArrLength<=fullLength) {\\n            returnAllPlateSizesPossible(strength,minSubArrLength,fullLength,0,0);\\n            minSubArrLength++;\\n        }\\n       \\n        System.out.println(\"Full Strength: \"+fullStrength);\\n        return fullStrength;\\n    }\\n}\\n\"\"\"",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    private static int fullStrength=0;\\n   \\n    private static int returnMin(int[] minArr) {\\n        Integer[] min_Arr = Arrays.stream( minArr ).boxed().toArray( Integer[]::new );\\n        return Collections.min(Arrays.asList(min_Arr));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2648227,
                "title": "super-detailed-explanation-java-monotonic-stack-prefix-sum-solution",
                "content": "# Intuition\\nThis is a problem that I have to spend so much time to find out the answer.And finally here is my answer\\n\\n# Approach\\nThe problem can be broken down into 2 main parts:\\n- Finding left and right boundaries that each strength[i] is min\\n- Finding how to calculate the sum of all subarrays that strength[i] is min\\nThe hard part is the second one, the first one can be solved just by using stacks. \\nFor the second part, here is an example of how to calculate the sum of all subarrays:\\n```\\nConsider array: 3 2 3 4\\nAll the array that 2 will be min is:\\n3 2\\n3 2 3\\n3 2 3 4\\n2 3\\n2 3 4\\n```\\nSo you can see we have 3, 2 in the left of 2 and we have 3 and 4 in the right of 2. Each elements at j in the left of 2 (2 is at i) will happens (j - left + 1)*(right - i + 1) and each elements in the right will happens (i - left + 1)*(right - j + 1).\\nBreak it down in details will be:\\nFrom left to i:\\n\\n```\\nSUM[(j - left + 1)*(right-i + 1)*strength[j]];\\n= (right - i + 1)*SUM[(j - left + 1)*strength[j]];\\n= (right - i + 1)*[SUM[j*strength[j]] - (left - 1)*SUM[strength[j]]];\\n```\\nFrom i+1 to right:\\n```\\nSUM[(i - left + 1)*(right - j + 1)*strength[j]];\\n= (i - left + 1)*SUM[(right - j + 1)*strength[j]];\\n= (i - left + 1)*[(right+1)*SUM[strength[j]] - SUM[j*strength[j]]];\\n```\\n\\nIf we break it down, we will find out that we need prefixSum (strength[j]) and prefixProd (strength[j]*j) to find out the sum of all subarrays in O(1)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int n;\\n    public long MOD = 1000000007;\\n    public int totalStrength(int[] strength) {\\n        n = strength.length;\\n        \\n        long[] leftBoundaries = new long[n];\\n        long[] rightBoundaries = new long[n];\\n        long[] prefixProd = new long[n];\\n        long[] prefixSum = new long[n];\\n\\n        helperProd(prefixProd, strength);\\n        helperSum(prefixSum, strength);\\n\\n        Arrays.fill(rightBoundaries, n - 1);\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i = 0; i < n; i++){\\n            while(!stack.isEmpty() && strength[stack.peek()] > strength[i]){\\n                rightBoundaries[stack.pop()] = i - 1;\\n            }\\n            stack.push(i);\\n        }\\n        stack.clear();\\n        for(int i = n - 1; i >= 0; i--){\\n            while(!stack.isEmpty() && strength[stack.peek()] >= strength[i]){\\n                leftBoundaries[stack.pop()] = i + 1;\\n            }\\n            stack.push(i);\\n        }\\n        long result = 0;\\n        for(int i = 0; i < n; i++){\\n            long left = leftBoundaries[i];\\n            long right = rightBoundaries[i];\\n            long sum = 0;\\n            sum += addLeft(left, right, i, prefixProd, prefixSum);\\n            sum += addRight(left, right, i, prefixProd, prefixSum);\\n            result += ((sum*(long)strength[i])%MOD);\\n            result %= MOD;\\n        }\\n        return (int) (result%MOD);\\n    }\\n    void helperProd(long[] a, int[] b){\\n        for(int i = 0; i < n; i++){\\n            a[i] = ((long)b[i]*(long)i + (i >= (long)1 ? a[i - 1] : (long)0));\\n        }\\n    }\\n    void helperSum(long[] a, int[] b){\\n        for(int i = 0; i < n; i++){\\n            a[i] = (long)b[i] + (i >= 1 ? a[i - 1] : (long)0);\\n        }\\n    }\\n    long addLeft(long left, long right, int i, long[] prod, long[] sum){\\n        long a = (right - (long) i + 1)%MOD;\\n        long b = (prod[i] - (left >= 1 ? prod[(int)left - 1] : (long) 0) - (left - (long)1)*(sum[i] - (left >= 1 ? sum[(int)left - 1] : (long) 0)))%MOD;\\n        long result = a*b;\\n        return result % MOD;\\n    }\\n    long addRight(long left, long right, int i, long[] prod, long[] sum){\\n        long a = ((long)i - left + 1)%MOD;\\n        long b = ((right + 1)*(sum[(int)right] - sum[i]) - prod[(int)right] + prod[i])%MOD;\\n        long result = a*b;\\n        return result % MOD;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nConsider array: 3 2 3 4\\nAll the array that 2 will be min is:\\n3 2\\n3 2 3\\n3 2 3 4\\n2 3\\n2 3 4\\n```\n```\\nSUM[(j - left + 1)*(right-i + 1)*strength[j]];\\n= (right - i + 1)*SUM[(j - left + 1)*strength[j]];\\n= (right - i + 1)*[SUM[j*strength[j]] - (left - 1)*SUM[strength[j]]];\\n```\n```\\nSUM[(i - left + 1)*(right - j + 1)*strength[j]];\\n= (i - left + 1)*SUM[(right - j + 1)*strength[j]];\\n= (i - left + 1)*[(right+1)*SUM[strength[j]] - SUM[j*strength[j]]];\\n```\n```\\nclass Solution {\\n    public int n;\\n    public long MOD = 1000000007;\\n    public int totalStrength(int[] strength) {\\n        n = strength.length;\\n        \\n        long[] leftBoundaries = new long[n];\\n        long[] rightBoundaries = new long[n];\\n        long[] prefixProd = new long[n];\\n        long[] prefixSum = new long[n];\\n\\n        helperProd(prefixProd, strength);\\n        helperSum(prefixSum, strength);\\n\\n        Arrays.fill(rightBoundaries, n - 1);\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i = 0; i < n; i++){\\n            while(!stack.isEmpty() && strength[stack.peek()] > strength[i]){\\n                rightBoundaries[stack.pop()] = i - 1;\\n            }\\n            stack.push(i);\\n        }\\n        stack.clear();\\n        for(int i = n - 1; i >= 0; i--){\\n            while(!stack.isEmpty() && strength[stack.peek()] >= strength[i]){\\n                leftBoundaries[stack.pop()] = i + 1;\\n            }\\n            stack.push(i);\\n        }\\n        long result = 0;\\n        for(int i = 0; i < n; i++){\\n            long left = leftBoundaries[i];\\n            long right = rightBoundaries[i];\\n            long sum = 0;\\n            sum += addLeft(left, right, i, prefixProd, prefixSum);\\n            sum += addRight(left, right, i, prefixProd, prefixSum);\\n            result += ((sum*(long)strength[i])%MOD);\\n            result %= MOD;\\n        }\\n        return (int) (result%MOD);\\n    }\\n    void helperProd(long[] a, int[] b){\\n        for(int i = 0; i < n; i++){\\n            a[i] = ((long)b[i]*(long)i + (i >= (long)1 ? a[i - 1] : (long)0));\\n        }\\n    }\\n    void helperSum(long[] a, int[] b){\\n        for(int i = 0; i < n; i++){\\n            a[i] = (long)b[i] + (i >= 1 ? a[i - 1] : (long)0);\\n        }\\n    }\\n    long addLeft(long left, long right, int i, long[] prod, long[] sum){\\n        long a = (right - (long) i + 1)%MOD;\\n        long b = (prod[i] - (left >= 1 ? prod[(int)left - 1] : (long) 0) - (left - (long)1)*(sum[i] - (left >= 1 ? sum[(int)left - 1] : (long) 0)))%MOD;\\n        long result = a*b;\\n        return result % MOD;\\n    }\\n    long addRight(long left, long right, int i, long[] prod, long[] sum){\\n        long a = ((long)i - left + 1)%MOD;\\n        long b = ((right + 1)*(sum[(int)right] - sum[i]) - prod[(int)right] + prod[i])%MOD;\\n        long result = a*b;\\n        return result % MOD;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627648,
                "title": "does-this-problem-take-into-account-buff-wizards",
                "content": "Surely we should also consider the maximum squat one rep max of each contiguous group.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2624358,
                "title": "fastest-solution-optimal-c-solution-beats-100-time-488-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    \\n    int totalStrength(vector<int>& strength) {\\n        int n = strength.size(), i;\\n        long long ans = 0;\\n        vector<int> left(n, -1), right(n, n);\\n        vector<long long> psum(n+1, 0), prefix(n+2, 0);\\n        for(i = 0; i < n; i++) psum[i+1] = (strength[i]+psum[i])%mod;\\n        for(i = 0; i <= n; i++) prefix[i+1] = (psum[i]+prefix[i])%mod;\\n        stack<int> store1, store2;\\n        for(i = 0; i < n; i++) {\\n            while(!store1.empty() && strength[store1.top()]>=strength[i]) store1.pop();\\n            if(!store1.empty()) left[i] = store1.top();\\n            store1.push(i);\\n        }\\n        for(i = n-1; i >= 0; i--) {\\n            while(!store2.empty() && strength[store2.top()]>strength[i]) store2.pop();\\n            if(!store2.empty()) right[i] = store2.top();\\n            store2.push(i);\\n        }\\n        for(i = 0; i < n; i++) {\\n            ans += ((prefix[right[i]+1]-prefix[i+1])*(i-left[i])%mod+mod-(prefix[i+1]-prefix[left[i]+1])*(right[i]-i)%mod)%mod*strength[i]%mod;\\n            ans %= mod;\\n        }\\n        return (ans+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    \\n    int totalStrength(vector<int>& strength) {\\n        int n = strength.size(), i;\\n        long long ans = 0;\\n        vector<int> left(n, -1), right(n, n);\\n        vector<long long> psum(n+1, 0), prefix(n+2, 0);\\n        for(i = 0; i < n; i++) psum[i+1] = (strength[i]+psum[i])%mod;\\n        for(i = 0; i <= n; i++) prefix[i+1] = (psum[i]+prefix[i])%mod;\\n        stack<int> store1, store2;\\n        for(i = 0; i < n; i++) {\\n            while(!store1.empty() && strength[store1.top()]>=strength[i]) store1.pop();\\n            if(!store1.empty()) left[i] = store1.top();\\n            store1.push(i);\\n        }\\n        for(i = n-1; i >= 0; i--) {\\n            while(!store2.empty() && strength[store2.top()]>strength[i]) store2.pop();\\n            if(!store2.empty()) right[i] = store2.top();\\n            store2.push(i);\\n        }\\n        for(i = 0; i < n; i++) {\\n            ans += ((prefix[right[i]+1]-prefix[i+1])*(i-left[i])%mod+mod-(prefix[i+1]-prefix[left[i]+1])*(right[i]-i)%mod)%mod*strength[i]%mod;\\n            ans %= mod;\\n        }\\n        return (ans+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618465,
                "title": "c-one-pass-monotonic-stack-but-no-prefix-sum",
                "content": "```cpp\\nstruct mint {\\n  ll v{};\\n  mint(ll vx) : v((vx % M + M) % M) {}\\n  friend mint operator+(const mint &a, const mint &b) { return {(a.v + b.v) % M}; }\\n  friend mint operator+(ll a, const mint &b) { return {(a + b.v) % M}; }\\n  friend mint operator+(const mint &a, ll b) { return {(a.v + b) % M}; }\\n  friend mint operator*(const mint &a, const mint &b) { return {(a.v * b.v) % M}; }\\n  friend mint operator*(ll a, const mint &b) { return {(a * b.v) % M}; }\\n  friend mint operator*(const mint &a, ll b) { return {(a.v * b) % M}; }\\n  mint &operator+=(const mint &a) {\\n    v = (v + a.v) % M;\\n    return *this;\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  int totalStrength(vector<int> &strength) {\\n    strength.push_back(0);\\n    int n = strength.size();\\n    mint ans = 0;\\n\\n    stack<int> values;\\n    stack<mint> left_subsums, right_subsums;\\n    stack<mint> left_sum, right_sum;\\n    stack<mint> left_subsums_cnt, right_subsums_cnt;\\n    for (int i = 0; i < n; i++) {\\n      mint cur_left_subsums = 0, cur_right_subsums = 0;\\n      mint cur_left_sum = 0, cur_right_sum = 0;\\n      mint cur_left_subsums_cnt = 0, cur_right_subsums_cnt = 0;\\n      while (!values.empty() && values.top() >= strength[i]) {\\n        mint sums_without_value = left_subsums.top() + cur_right_subsums + left_subsums.top() * cur_left_subsums_cnt +\\n                                  cur_right_subsums * left_subsums_cnt.top();\\n        mint values_in_sums =\\n            (left_subsums_cnt.top() + cur_left_subsums_cnt + left_subsums_cnt.top() * cur_left_subsums_cnt + 1) *\\n            values.top();\\n        mint res = (sums_without_value + values_in_sums) * values.top();\\n        ans += res;\\n\\n        cur_left_subsums += left_subsums.top() + (left_subsums_cnt.top() + 1) * values.top() +\\n                            (left_subsums_cnt.top() + 1) * cur_left_sum;\\n        cur_left_subsums_cnt += left_subsums_cnt.top() + 1;\\n        cur_right_subsums += right_sum.top() * cur_right_subsums_cnt + right_subsums.top();\\n        cur_right_subsums_cnt += right_subsums_cnt.top();\\n        cur_left_sum += left_sum.top() + values.top();\\n        cur_right_sum += right_sum.top();\\n\\n        values.pop();\\n        left_subsums.pop();\\n        right_subsums.pop();\\n        left_sum.pop();\\n        right_sum.pop();\\n        left_subsums_cnt.pop();\\n        right_subsums_cnt.pop();\\n      }\\n\\n      values.push(strength[i]);\\n      left_subsums.push(cur_left_subsums);\\n      right_subsums.push(cur_right_subsums + cur_right_sum + strength[i]);\\n      left_sum.push(cur_left_sum);\\n      right_sum.push(cur_right_sum + strength[i]);\\n      left_subsums_cnt.push(cur_left_subsums_cnt);\\n      right_subsums_cnt.push(cur_right_subsums_cnt + 1);\\n    }\\n    return ans.v;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```cpp\\nstruct mint {\\n  ll v{};\\n  mint(ll vx) : v((vx % M + M) % M) {}\\n  friend mint operator+(const mint &a, const mint &b) { return {(a.v + b.v) % M}; }\\n  friend mint operator+(ll a, const mint &b) { return {(a + b.v) % M}; }\\n  friend mint operator+(const mint &a, ll b) { return {(a.v + b) % M}; }\\n  friend mint operator*(const mint &a, const mint &b) { return {(a.v * b.v) % M}; }\\n  friend mint operator*(ll a, const mint &b) { return {(a * b.v) % M}; }\\n  friend mint operator*(const mint &a, ll b) { return {(a.v * b) % M}; }\\n  mint &operator+=(const mint &a) {\\n    v = (v + a.v) % M;\\n    return *this;\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  int totalStrength(vector<int> &strength) {\\n    strength.push_back(0);\\n    int n = strength.size();\\n    mint ans = 0;\\n\\n    stack<int> values;\\n    stack<mint> left_subsums, right_subsums;\\n    stack<mint> left_sum, right_sum;\\n    stack<mint> left_subsums_cnt, right_subsums_cnt;\\n    for (int i = 0; i < n; i++) {\\n      mint cur_left_subsums = 0, cur_right_subsums = 0;\\n      mint cur_left_sum = 0, cur_right_sum = 0;\\n      mint cur_left_subsums_cnt = 0, cur_right_subsums_cnt = 0;\\n      while (!values.empty() && values.top() >= strength[i]) {\\n        mint sums_without_value = left_subsums.top() + cur_right_subsums + left_subsums.top() * cur_left_subsums_cnt +\\n                                  cur_right_subsums * left_subsums_cnt.top();\\n        mint values_in_sums =\\n            (left_subsums_cnt.top() + cur_left_subsums_cnt + left_subsums_cnt.top() * cur_left_subsums_cnt + 1) *\\n            values.top();\\n        mint res = (sums_without_value + values_in_sums) * values.top();\\n        ans += res;\\n\\n        cur_left_subsums += left_subsums.top() + (left_subsums_cnt.top() + 1) * values.top() +\\n                            (left_subsums_cnt.top() + 1) * cur_left_sum;\\n        cur_left_subsums_cnt += left_subsums_cnt.top() + 1;\\n        cur_right_subsums += right_sum.top() * cur_right_subsums_cnt + right_subsums.top();\\n        cur_right_subsums_cnt += right_subsums_cnt.top();\\n        cur_left_sum += left_sum.top() + values.top();\\n        cur_right_sum += right_sum.top();\\n\\n        values.pop();\\n        left_subsums.pop();\\n        right_subsums.pop();\\n        left_sum.pop();\\n        right_sum.pop();\\n        left_subsums_cnt.pop();\\n        right_subsums_cnt.pop();\\n      }\\n\\n      values.push(strength[i]);\\n      left_subsums.push(cur_left_subsums);\\n      right_subsums.push(cur_right_subsums + cur_right_sum + strength[i]);\\n      left_sum.push(cur_left_sum);\\n      right_sum.push(cur_right_sum + strength[i]);\\n      left_subsums_cnt.push(cur_left_subsums_cnt);\\n      right_subsums_cnt.push(cur_right_subsums_cnt + 1);\\n    }\\n    return ans.v;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602682,
                "title": "python-increasing-stack-solution-short",
                "content": "```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        N = 10**9 + 7\\n        stack = []                \\n        r = x = y = 0\\n        for i, v in enumerate(strength):\\n            x += v \\n            y += (i+1)*v\\n            while stack and strength[stack[-1][0]] >= v:\\n                stack.pop()\\n            pi, pm, pp, px, py = stack[-1] if stack else (-1, 0, 0, 0, 0)\\n            p = pp + (x - px) * pm + (y - py - (pi + 1) * ((x - px))) * v\\n            stack.append((i, (pm + (i - pi) * v) % N, p % N, x % N, y % N))\\n            r = (r + p) % N                    \\n        return r \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        N = 10**9 + 7\\n        stack = []                \\n        r = x = y = 0\\n        for i, v in enumerate(strength):\\n            x += v \\n            y += (i+1)*v\\n            while stack and strength[stack[-1][0]] >= v:\\n                stack.pop()\\n            pi, pm, pp, px, py = stack[-1] if stack else (-1, 0, 0, 0, 0)\\n            p = pp + (x - px) * pm + (y - py - (pi + 1) * ((x - px))) * v\\n            stack.append((i, (pm + (i - pi) * v) % N, p % N, x % N, y % N))\\n            r = (r + p) % N                    \\n        return r \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592062,
                "title": "finally-solved-time-o-n-space-o-n",
                "content": "```\\ntypedef int64_t LL;\\n\\nclass Solution {\\npublic:\\n    const int MOD = int(1e9 + 7);\\n    \\n    vector<int> nextSmallerElementRight(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> ret(n, n);\\n        stack<int> st;\\n        for (int i = 0; i < n; i++) {\\n            while (!st.empty() && arr[i] < arr[st.top()]) {\\n                ret[st.top()] = i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        return ret;\\n    }\\n    \\n    vector<int> nextSmallerElementLeft(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> ret(n, -1);\\n        stack<int> st;\\n        for (int i = n-1; i >= 0; i--) {\\n            while (!st.empty() && arr[i] <= arr[st.top()]) {\\n                ret[st.top()] = i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        return ret;\\n    }\\n    \\n    vector<LL> makePrefixPrefixSum(vector<int>& arr) {\\n        int n = (int)arr.size();\\n        vector<LL> psum(n);\\n        for (int i = 0; i < n; i++)\\n            psum[i] = ((i-1 >= 0 ? psum[i-1] : 0) + arr[i]) % MOD;\\n        \\n        vector<LL> ppsum(n);\\n        for (int i = 0; i < n; i++)\\n            ppsum[i] = ((i-1 >= 0 ? ppsum[i-1] : 0) + psum[i]) % MOD;\\n        \\n        return ppsum;\\n    }\\n    \\n    int totalStrength(vector<int>& strength) {\\n        int n = strength.size();\\n        \\n        vector<int> right = nextSmallerElementRight(strength);\\n        vector<int> left = nextSmallerElementLeft(strength);\\n        vector<LL> ppsum = makePrefixPrefixSum(strength);\\n        \\n//         for (int& x : right) cout << x << \" \";\\n//         cout << endl;\\n        \\n//         for (int& x : left) cout << x << \" \";\\n//         cout << endl;\\n        \\n//         for (LL& x : ppsum) cout << x << \" \";\\n//         cout << endl;\\n        \\n        LL ret = 0;\\n        for (int i = 0; i < n; i++) {\\n            int l = left[i], r = right[i];\\n            LL sum = (((ppsum[r-1] - (i-1 >= 0 ? ppsum[i-1] : 0)) * (i-l)) % MOD) + MOD;\\n            sum = (sum - (r - i) * ((i-1 >= 0 ? ppsum[i-1] : 0) - (l-1 >= 0 ? ppsum[l-1] : 0))) % MOD;\\n            ret = (ret + (sum * strength[i]) % MOD) % MOD;\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\ntypedef int64_t LL;\\n\\nclass Solution {\\npublic:\\n    const int MOD = int(1e9 + 7);\\n    \\n    vector<int> nextSmallerElementRight(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> ret(n, n);\\n        stack<int> st;\\n        for (int i = 0; i < n; i++) {\\n            while (!st.empty() && arr[i] < arr[st.top()]) {\\n                ret[st.top()] = i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        return ret;\\n    }\\n    \\n    vector<int> nextSmallerElementLeft(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> ret(n, -1);\\n        stack<int> st;\\n        for (int i = n-1; i >= 0; i--) {\\n            while (!st.empty() && arr[i] <= arr[st.top()]) {\\n                ret[st.top()] = i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        return ret;\\n    }\\n    \\n    vector<LL> makePrefixPrefixSum(vector<int>& arr) {\\n        int n = (int)arr.size();\\n        vector<LL> psum(n);\\n        for (int i = 0; i < n; i++)\\n            psum[i] = ((i-1 >= 0 ? psum[i-1] : 0) + arr[i]) % MOD;\\n        \\n        vector<LL> ppsum(n);\\n        for (int i = 0; i < n; i++)\\n            ppsum[i] = ((i-1 >= 0 ? ppsum[i-1] : 0) + psum[i]) % MOD;\\n        \\n        return ppsum;\\n    }\\n    \\n    int totalStrength(vector<int>& strength) {\\n        int n = strength.size();\\n        \\n        vector<int> right = nextSmallerElementRight(strength);\\n        vector<int> left = nextSmallerElementLeft(strength);\\n        vector<LL> ppsum = makePrefixPrefixSum(strength);\\n        \\n//         for (int& x : right) cout << x << \" \";\\n//         cout << endl;\\n        \\n//         for (int& x : left) cout << x << \" \";\\n//         cout << endl;\\n        \\n//         for (LL& x : ppsum) cout << x << \" \";\\n//         cout << endl;\\n        \\n        LL ret = 0;\\n        for (int i = 0; i < n; i++) {\\n            int l = left[i], r = right[i];\\n            LL sum = (((ppsum[r-1] - (i-1 >= 0 ? ppsum[i-1] : 0)) * (i-l)) % MOD) + MOD;\\n            sum = (sum - (r - i) * ((i-1 >= 0 ? ppsum[i-1] : 0) - (l-1 >= 0 ? ppsum[l-1] : 0))) % MOD;\\n            ret = (ret + (sum * strength[i]) % MOD) % MOD;\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2564535,
                "title": "c-time-limit-exceeded-brute-force",
                "content": "Brute force for learning purposes.\\n```\\npublic class Solution {\\n        int MOD = 1000000007;\\n        public int TotalStrength(int[] strength)\\n        {\\n            long result = 0;\\n            int window = 0;\\n            while (window < strength.Length)\\n            {\\n                for (int i = window; i < strength.Length; i++)\\n                {\\n                    long sum = 0;\\n                    int min = Int32.MaxValue;\\n                    int index = window;\\n\\n                    while (i - index >= 0) \\n                    {\\n                        min = Math.Min(min , strength[i - index]);\\n                        sum = (sum + strength[i - index]) % MOD;\\n                        index--;\\n                        if (index < 0)\\n                            break;\\n                    }\\n                    \\n                    result += ((min * sum) % MOD);\\n                }\\n                window++;\\n            }\\n\\n\\n            return (int)(result % MOD);\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n        int MOD = 1000000007;\\n        public int TotalStrength(int[] strength)\\n        {\\n            long result = 0;\\n            int window = 0;\\n            while (window < strength.Length)\\n            {\\n                for (int i = window; i < strength.Length; i++)\\n                {\\n                    long sum = 0;\\n                    int min = Int32.MaxValue;\\n                    int index = window;\\n\\n                    while (i - index >= 0) \\n                    {\\n                        min = Math.Min(min , strength[i - index]);\\n                        sum = (sum + strength[i - index]) % MOD;\\n                        index--;\\n                        if (index < 0)\\n                            break;\\n                    }\\n                    \\n                    result += ((min * sum) % MOD);\\n                }\\n                window++;\\n            }\\n\\n\\n            return (int)(result % MOD);\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438772,
                "title": "time-limit-exceeded",
                "content": "I couldn\\'t find one simplest step to reduce the time\\nIt excceds for 64th Test case which is:\\n[1689,1159,323,348,374,303,782,1816,1455,196,749,1835,70,851,873,1546,1670,132,1438,1576,1864,1532,1816,1672,564,1427,1404,263,724,585,706,309,1869,938,1678,545,1528,1103,748,470,289,207,1197,1208,1120,678,1159,1232,1449,1208,1002,254,1627,1712,1191,1427,1958,1154,1987,1964,1264,1399,1612,52,1513,241,1117,973,1320,1306,302,692,1091,806,1435,99,1770,447,166,1933,1377,1135,25,1559,106,775,615,1455,1479,1247,266,490,1670,1525,462,1951,1070,694,658,390,517,1452,322,714,557,1965,1247,915,1385,298,1101,1409,1382,779,396,1933,1693,685,384,704,101,362,1381,964,1948,1771,1038,1253,730,621,508,1574,377,1218,494,696,695,1780,547,1083,1310,1999,535,1844,75,1184,248,1267,325,1909,772,893,693,556,1949,676,1016,1786,930,1157,1134,1535,170,786,882,1572,1810,1420,1378,142,408,1689,27,1073,1531,960,1529,5,113,302,1840,1960,1585,457,1874,1841,12,1681,1889,1732,1954,172,1787,1216,453,233,245,1676,276,1962,1989,360,1803,1605,308,1654,1850,1359,211,1474,776,1456,1951,643,1065,493,1706,1918,1437,779,1058,453,459,1668,687,705,74,1780,220,994,576,207,271,464,1457,1505,1393,1355,1773,330,1498,199,296,87,1226,988,1177,751,673,365,305,844,782,1943,1215,1351,378,1004,1841,1635,1631,1880,1875,1181,277,1974,665,1944,1873,948,759,1523,1303,660,1455,866,1046,463,941,516,1315,1618,1413,423,973,1665,825,181,1858,594,1737,1658,962,1282,700,922,643,45,20,1876,1324,1341,138,966,867,368,104,1844,1263,809,1741,724,1150,1325,1012,1634,1357,1167,1642,642,629,599,667,1657,1250,1002,714,222,3,872,1488,283,1651,747,1312,36,314,1732,13,378,1977,83,945,399,272,622,1391,1141,1084,693,1404,1354,1995,1310,1194,302,10,737,363,260,406,576,1110,1190,1138,1006,1684,895,1096,1080,316,1903,711,1493,1883,546,534,1442,1526,1064,228,922,188,1538,1692,372,1014,452,1225,194,1698,1666,1420,1031,870,1865,1683,870,1764,223,1341,487,1164,501,915,967,588,85,737,1699,1187,1169,957,1527,283,559,1642,428,1369,936,1030,696,859,1158,274,1895,669,1320,1394,1152,1176,1798,368,1254,46,1412,1466,1128,1361,979,1237,627,615,1856,651,1197,88,522,505,1846,675,1751,1108,238,1722,121,402,1902,1174,1495,1404,1830,1349,809,369,1882,1182,1419,888,1623,1647,311,955,1811,1771,353,45,287,1479,1864,1775,188,775,1776,852,228,471,263,567,688,38,601,595,1563,1502,1089,1312,838,1464,1213,1323,1672,1594,19,1388,453,1928,977,219,277,228,468,1869,1962,237,1749,1515,409,1912,216,1268,201,194,962,1072,1129,1502,1387,1292,569,1289,1440,156,1272,519,1030,636,1012,1438,1802,1838,794,1153,1175,1367,905,567,71,418,151,18,1491,1754,1159,544,1910,291,696,1177,327,1500,1701,649,228,1258,1124,614,67,64,1979,748,1019,1150,904,1582,1125,1819,675,762,283,1657,123,814,1429,1841,1994,1742,173,1976,1790,808,1466,1858,1894,1825,160,1456,370,1909,38,1938,161,1707,1587,474,609,1944,575,1808,1691,1288,313,607,14,189,683,826,1819,713,1918,1283,259,935,158,11,511,834,863,1594,1301,1965,1660,1127,103,1152,1840,250,1305,66,8,748,1506,1988,1526,522,120,830,138,1040,499,733,93,766,1698,139,1731,1774,417,1570,1373,1553,1970,817,888,1978,1734,297,1587,1371,1564,1523,1989,99,774,1063,758,104,1998,1819,1606,817,330,51,1802,459,1026,1331,1486,1566,874,549,96,1639,995,1574,1053,835,1401,1331,641,1910,482,257,1860,1288,648,1305,1482,1979,566,236,1880,866,1047,973,1171,1435,1302,1637,1483,59,176,572,1157,507,87,1200,217,328,1665,1422,414,1427,1377,1041,528,1577,1853,230,491,790,1775,1368,281,207,1494,1299,304,1638,1069,1156,421,784,1737,1376,911,988,1485,543,807,275,1343,842,211,464,277,584,1516,1700,316,724,1111,540,404,1636,1608,332,1210,253,1889,299,444,645,1570,1362,1371,942,550,1891,966,1788,187,356,75,950,1129,1,545,288,1558,299,872,1501,498,455,1065,1944,101,1989,996,1974,1065,332,1246,1119,170,1269,1857,1128,1380,1420,1102,1818,1609,1392,1543,1643,23,1978,1424,230,820,337,790,390,878,481,29,189,1126,243,1665,128,1387,1268,593,1837,747,1340,1293,1755,1761,505,1511,996,1056,1001,614,1770,1225,1277,396,1727,500,1418,1560,14,272,239,1422,85,1590,595,1820,973,1465,1762,1743,1621,1304,1529,824,1922,1286,1748,215,1955,1551,459,684,1410,1989,133,938,586,273,588,1803,163,53,1742,282,220,599,827,546,376,1172,490,1135,879,147,50,528,1590,1229,268,740,1011,196,1045,1163,334,32,713,1924,386,721,1023,1947,1218,1642,1118,668,398,948,1104,1457,1425,313,610,201,1571,1685,1806,1242,915,1538,2000,1433,566,1093,1827,780,620,1471,881,974,697,66,843,1636,612,996,23,1387,183,1086,71,1208,836,1417,50,664,1082,1565,592,478,1058,1850,246,893,144,909,1410,237,1627,1557,1600,1676,1179,1428,307,689,1328,1263,1687,94,753,1224,1175,1369,352,1140,1019,311,1820,1771,659,793,288,817,712,1238,217,796,1811,1975,981,1368,1422,1596,1815,1199,401,63,1304,1247,1534,153,1380,956,1303,949,1929,247,1282,1890,1066,219,1054,171,1129,1834,53,584,863,1908,578,75,1047,1132,1283,669,1473,1488,1482,266,1323,950,517,1262,1915,1241,1662,998,345,466,1046,87,43,426,680,249,1507,8,1635,128,38,1822,1296,567,678,198,616,1675,1071,913,1935,1686,57,782,1626,572,1790,1529,1135,1103,1196,178,1594,1598,2,1781,705,29,722,1915,1745,504,1156,1249,1030,1527,1164,825,1675,1730,1286,1855,1544,529,111,335,906,1738,157,1017,1401,198,1737,1726,283,1240,1799,1661,1035,1376,456,1460,111,89,497,1041,1152,1216,356,246,286,766,1163,595,530,901,278,1351,1555,175,1660,1433,485,1285,1865,650,1099,836,1119,736,156,1819,1167,697,1034,1440,733,442,608,1963,1247,1400,1164,918,1369,738,1523,624,1632,845,445,553,1264,1711,1267,1370,205,864,316,1902,1113,885,1011,375,1708,845,248,85,1220,930,1516,681,927,1305,100,1786,720,807,875,1735,402,429,1745,737,774,1198,642,1979,767,1578,1614,895,1650,962,839,673,802,1123,1243,1343,731,1197,491,1505,549,574,1147,1662,1426,1669,1053,1309,1864,936,1512,209,541,1919,1137,716,1400,1025,157,818,1226,1133,1329,581,1255,1843,672,916,529,106,1940,1815,1219,1556,192,1950,193,697,673,2000,1742,1944,1940,1296,1374,1929,653,1852,1492,1286,573,1083,440,447,492,1975,1129,325,96,1194,759,698,658,758,1146,1746,694,1963,1543,1980,167,422,1728,1797,323,1334,91,1918,1775,1804,203,16,1074,1023,607,768,905,944,510,1959,464,226,1118,555,1200,569,57,1140,1502,1995,741,956,435,1071,1582,73,1784,1397,1818,1175,1134,1818,1695,1115,51,1214,1965,1213,289,1717,887,1440,259,1646,1011,1082,869,131,505,1381,1010,1766,719,1500,1477,1186,1807,1328,314,1378,1301,74,1439,1922,769,39,968,1279,603,1834,1910,1235,1767,1177,1801,1518,1282,1067,1005,1469,836,1522,32,263,1040,408,979,770,1345,1879,368,1827,866,1801,1845,614,1819,642,271,1377,1513,1266,1895,629,1282,1763,920,689,742,1123,1855,149,848,1097,633,1721,86,577,1849,1163,1782,459,423,1115,489,1081,408,436,1095,651,818,49,85,331,629,1359,136,1615,1449,574,1664,1755,287,1401,318,1400,876,410,1109,92,1446,1728,1450,1692,1022,810,1320,1855,256,431,1214,1552,463,984,1902,75,1010,1869,63,351,1760,1844,569,1864,591,1702,1483,1478,597,767,210,1796,1081,1232,1803,192,1991,918,565,1846,414,1205,1002,1412,80,591,890,569,1310,1681,369,940,877,534,569,1276,1220,894,743,1664,688,1870,417,1291,119,1072,411,1862,1725,1258,1441,1494,1008,885,377,504,1650,1913,1812,1416,417,810,1257,1247,1670,1629,569,1570,724,619,1565,597,330,886,1079,223,1246,368,22,699,891,313,896,1216,40,1361,285,1294,76,1682,1013,521,1857,1618,837,268,745,1744,50,884,1942,1871,1127,388,1668,1250,973,693,124,899,1793,619,545,1213,186,877,533,700,385,1429,1362,1021,1781,1378,413,888,590,779,1020,1006,1525,398,1599,749,472,244,772,626,395,1057,271,1593,680,513,591,463,580,1932,144,1569,814,1706,1113,920,1696,1535,1037,612,188,1114,317,1312,202,931,780,1323,1225,1261,447,858,960,1059,1664,1148,1092,1567,28,854,1912,286,1394,597,1591,784,1993,1149,1184,191,1279,1204,1162,1415,914,396,742,1182,1451,101,446,1549,1253,1047,630,1770,1306,1272,1562,745,1783,642,375,684,437,1041,1533,1358,1404,1566,1846,1624,1960,1149,1095,50,1706,1280,979,739,1139,1691,1212,498,932,682,1104,919,1891,973,1103,1470,463,1097,1104,1932,1795,1305,1061,443,1241,809,510,1996,217,1165,1198,244,694,1398,609,408,326,1481,681,131,648,1262,418,434,1714,1590,1396,682,732,1151,910,480,583,1084,267,172,1411,696,750,1977,1264,1690,1604,448,22,764,1777,1697,246,736,1709,1228,1741,391,1668,1947,1979,1965,1822,1356,1844,437,1507,90,360,1727,122,591,1217,1143,244,582,1935,325,535,1248,654,1371,1039,1299,273,1329,225,1657,1436,784,430,1761,1470,662,1431,1968,783,1019,1642,434,518,1575,1682,146,1002,1713,430,2000,518,1659,1224,684,1624,1557,256,741,1427,348,1075,1375,1556,1956,486,607,596,458,438,1121,1971,838,147,767,1470,1527,529,1663,192,349,147,818,938,1962,1661,1033,461,1798,1762,359,1300,38,1317,1376,384,1550,1579,1653,1930,72,872,505,1602,621,486,1356,1785,1000,1703,1928,1828,1912,939,185,1039,1080,1371,330,1355,1916,642,1559,439,1428,301,322,783,969,19,1321,1785,538,537,1035,237,1250,1641,1319,1622,1406,1330,1227,32,1922,723,201,1133,133,544,387,230,344,1844,1056,519,1194,1200,946,1857,1960,358,1474,811,731,1618,240,12,951,387,1889,1686,1267,236,790,1852,512,264,1923,253,575,992,1544,1851,618,1278,897,777,1467,515,160,922,363,1985,859,1510,860,539,1736,1410,1219,635,988,1524,1894,1975,1044,568,23,1336,810,296,344,583,868,143,1815,1223,61,1031,97,331,969,1819,1047,1487,697,1017,191,1030,643,1442,662,785,161,439,237,1091,1192,1080,1715,1718,893,207,396,120,1482,330,1235,1450,677,393,879,340,850,666,1758,1526,1655,1197,664,264,1456,587,386,1189,1295,681,673,752,320,599,517,1048,1433,486,615,1134,125,1300,798,1068,56,813,1058,559,6,982,1751,1845,1060,1872,930,153,49,1528,81,1749,1739,1529,573,1804,362,403,590,982,1677,1981,137,190,1613,1143,193,786,1207,1164,150,1081,353,448,1144,82,1446,1904,745,1020,1972,1563,729,495,422,1097,57,1400,1811,475,1148,343,1054,491,252,630,285,1692,1303,782,283,186,385,620,1951,1192,1986,342,1348,1517,901,1645,768,1836,1776,50,873,1163,1937,1001,1998,1680,1286,1105,1117,1217,1565,1129,1726,1519,1952,1539,487,1839,665,260,566,692,916,207,18,1691,1231,98,578,91,1512,1265,1261,327,924,234,1167,1339,47,692,1710,151,1147,919,888,501,1540,1436,450,127,547,1203,497,101,640,1471,1316,1416,1209,137,1798,304,952,1373,1596,173,615,848,284,1579,1770,1610,1706,980,1176,291,1352,549,1504,1802,1550,466,106,275,82,1498,381,691,1435,279,188,1069,1689,967,1716,1126,1459,662,493,1577,992,1746,856,1181,1640,1459,1910,981,1804,1964,1058,167,989,1961,1716,1410,1165,241,830,1645,607,930,1787,439,1605,489,546,1225,126,1488,220,286,1679,1857,1629,1599,1324,391,1634,951,458,537,1401,1992,1152,1753,1259,536,1356,926,889,375,1528,461,1892,1814,1086,1433,390,1504,398,298,1149,1822,1522,1898,458,388,1488,1462,1596,609,1837,1557,164,661,246,1817,1756,1263,1977,1007,1763,1078,1072,1777,507,1632,903,902,1027,949,1595,574,169,351,1960,889,309,1080,1725,1027,1157,1525,12,1829,402,802,1782,266,190,1849,1046,130,799,841,1059,1591,962,1583,33,1986,653,1389,496,1563,103,1590,296,1499,1624,509,147,1910,1770,925,389,95,1630,401,402,1290,867,997,1789,1790,1633,1404,1842,811,1739,686,1126,1323,317,813,666,800,1332,56,1136,1259,953,180,369,383,575,1786,1609,1354,940,720,315,510,603,1397,129,1141,1247,367,698,1653,54,458,979,540,1821,1941,1226,1374,1444,292,1560,663,3,1298,1908,185,96,1216,753,1028,1634,431,1597,1903,836,459,1272,1409,134,1328,696,1001,402,1218,1394,1892,1692,1015,1100,36,1726,1457,1113,1238,1898,1079,1439,882,1780,677,913,266,1955,589,1803,1832,1144,1804,940,1796,1966,1438,1562,1777,721,407,1914,1657,1766,1778,1949,804,1130,124,688,1932,1628,1361,479,798,888,1266,1442,1483,1547,986,1886,376,1575,1915,242,423,81,1339,1741,1569,1140,844,170,1521,59,1153,1448,1481,429,1303,962,1817,1062,1390,389,985,296,1085,1377,876,1671,541,1865,481,643,959,740,1738,1801,1301,451,37,1845,1413,1664,351,68,440,1903,967,404,739,117,1938,82,53,1446,1374,1148,1288,319,471,1971,1662,1219,545,134,421,588,1868,1665,363,1424,15,138,822,1785,722,446,347,1402,845,433,1929,501,1589,855,1560,129,1558,376,685,1335,729,915,1553,385,1866,345,1911,1537,965,822,644,351,1999,1001,1520,931,1108,1097,1302,790,1026,1586,292,392,1265,1163,1971,253,1672,1139,888,1371,1330,698,598,335,370,790,1046,827,1642,738,1846,1477,459,1293,401,1092,384,1241,1060,1130,439,724,1000,1657,600,453,1801,942,619,1218,1781,620,825,756,1514,504,1004,1048,733,1494,1029,682,1547,1072,789,300,712,1904,149,197,1596,770,971,120,1086,800,1936,1954,457,1724,1828,1733,1255,270,1762,177,499,1802,643,628,1812,1788,10,1204,704,724,1219,1366,559,1357,174,1880,1100,348,1970,1511,1603,556,57,1502,31,1465,1820,862,84,485,494,1547,1052,1386,1040,498,1245,1222,1847,1875,591,1431,1487,1548,1881,1325,636,1052,1841,1539,122,1445,1231,565,1319,1985,866,1659,1606,785,619,1232,250,402,1537,1554,914,786,1590,1988,976,1960,1179,750,861,1863,1918,1409,1036,812,538,872,605,1456,1364,462,1499,1027,1810,98,524,1147,561,1592,900,52,1284,408,1567,1569,1735,1247,630,1,713,1262,457,843,1944,57,1634,418,229,1761,813,1265,1788,1465,1142,1291,1649,998,693,13,831,1038,188,1925,533,1232,1417,797,711,822,226,716,1010,1901,1693,1929,1332,250,1967,656,700,91,240,855,1808,415,673,679,1164,1458,260,1071,1951,1074,1865,1958,1499,820,1529,1222,1587,1141,454,1176,277,1898,1701,1410,797,778,542,1768,1005,596,895,1596,312,311,982,159,1790,1987,1580,554,1878,1255,414,382,1106,442,40,227,1725,1279,380,1272,1705,100,1027,996,1575,855,838,1332,170,784,1926,52,1340,1845,1805,1725,1334,772,876,1279,659,1683,1379,1840,272,1857,1762,1231,1325,1453,947,697,852,562,1978,374,1523,1051,239,774,919,721,1248,1446,1872,1923,1845,881,1670,647,554,751,1779,711,163,1460,1329,1302,341,1152,677,806,1059,1115,761,1885,1167,1087,915,951,1013,772,1036,596,1717,350,437,1158,854,1221,726,1738,1018,1107,75,257,1567,209,1540,550,410,238,1137,1995,1934,1494,1170,1907,318,1522,36,745,1808,1444,1877,671,890,827,1882,809,1174,1103,1725,1153,1106,1812,1160,612,416,1572,1676,1392,1364,76,1408,316,1171,70,1975,1055,803,722,1890,490,1731,228,484,1506,1215,136,606,1648,1703,581,1658,1503,390,1897,1038,806,1460,440,1175,806,486,1950,846,1173,615,97,1480,1535,1750,1610,946,511,733,1968,764,1284,474,1795,200,1433,533,1184,524,1522,1112,149,937,783,1649,320,701,1047,544,331,1948,457,1463,1453,665,315,141,1073,350,571,1311,947,491,1171,1809,385,1775,1324,1750,2,415,1976,619,320,793,1483,1982,877,332,1746,755,1053,1074,879,1155,1825,91,1810,185,1907,1934,363,1445,96,972,1972,1714,1859,90,1110,1538,1608,1965,470,409,871,1974,1030,692,88,1249,727,1548,1194,1879,1362,366,1791,919,1500,916,869,565,898,180,294,594,1655,848,810,22,129,28,660,23,438,1425,838,1341,363,301,848,1670,1573,273,209,1355,422,1443,610,90,777,277,1782,844,966,1226,852,1251,65,97,1072,1516,620,1322,705,1717,758,923,641,1408,855,926,797,614,681,437,865,245,117,551,1288,659,381,112,1326,1761,1082,32,726,1013,1913,1516,784,1884,54,598,1750,377,655,774,65,464,717,912,1839,1305,1955,661,673,609,527,91,122,1417,6,1233,1723,161,1819,1166,1350,683,1140,153,1674,1124,527,928,1576,835,840,676,849,1830,1300,448,1459,840,1849,1583,1662,1975,1202,1616,964,1950,1482,1344,839,1946,1012,808,894,487,1480,525,445,912,729,1172,945,711,1253,1285,489,1833,1637,1534,971,157,162,183,70,1581,1120,1215,1017,570,555,1070,1495,296,827,481,1815,1278,989,89,1681,1635,515,1036,1139,1210,144,551,983,1642,631,456,883,1642,1271,1478,1444,167,818,1521,311,1496,1939,1664,257,240,520,1368,1117,1380,429,903,540,1466,1940,567,1042,135,1796,317,1340,706,1138,26,981,881,1052,1390,1555,1630,511,425,105,860,702,1253,1087,702,227,1943,519,1851,987,737,292,242,233,267,785,1521,556,1716,223,1021,21,1609,1781,1589,533,308,1041,1569,1477,1686,1145,1362,258,1337,1915,1238,898,1341,424,448,1496,1738,1060,1095,54,769,1361,468,548,834,707,382,1731,972,140,1715,1994,1540,1792,1878,400,1882,343,333,1435,1921,1326,953,340,1191,7,1492,590,1049,1757,1343,1165,1417,1925,222,1637,873,1760,1543,402,1129,1315,1049,48,243,967,747,121,1409,452,507,458,1785,56,1990,1965,1161,603,1338,1413,1368,13,539,71,1360,707,1588,1646,1127,931,169,1223,862,1408,1997,1160,1953,1915,542,173,277,1482,1310,132,704,854,1283,584,822,559,248,652,1985,787,358,764,104,418,681,1640,1861,538,409,1537,1347,884,1192,253,446,1443,131,1208,123,724,1915,1460,301,1470,614,1119,1648,842,45,40,1117,301,549,801,304,850,556,634,885,874,640,131,1136,98,1899,539,991,63,1385,386,679,480,1768,1494,539,1761,1628,1686,121,1301,198,887,1815,1531,1589,1597,106,1426,640,1604,1831,935,1894,1009,609,1971,326,743,1056,782,373,1533,529,157,495,1252,1090,185,735,433,830,1088,1325,1635,642,1453,125,356,561,951,440,1852,1573,271,1675,716,901,1135,835,1801,118,1543,812,845,1210,62,1722,1949,334,1200,1461,1867,635,383,1224,639,356,1132,1976,996,1900,359,751,1839,335,581,1089,248,770,995,777,109,1185,753,953,95,748,1373,1706,1234,965,370,441,422,670,1049,797,1024,1598,351,425,1053,244,263,968,1919,430,995,240,738,576,618,206,304,1672,683,1736,1389,1284,1338,214,659,1080,821,1731,1073,332,1780,1590,1671,1162,51,905,874,1492,781,1042,1064,520,282,799,707,217,588,45,147,406,1040,69,1391,1544,1614,1318,79,1518,958,703,1717,979,1257,1760,874,161,938,1908,192,1029,218,107,426,494,496,1012,97,1936,751,1906,1540,1480,1630,1613,1741,1346,210,1674,1714,1044,1033,148,1471,1161,1865,287,1803,1801,1009,502,937,578,625,147,1594,572,1597,745,306,1509,450,1022,608,357,685,1421,926,1304,321,1600,1223,1771,513,1938,1491,720,1219,1538,1597,1034,1897,1380,34,1407,1222,1942,1222,1727,865,1166,866,1461,95,1600,1115,1231,376,50,467,1047,156,1250,1950,990,799,1786,100,1991,165,108,1038,1661,1970,919,947,596,881,162,565,1987,105,1366,696,314,1881,1987,457,1558,1647,360,1443,1237,440,1960,1621,771,1117,965,546,903,519,583,1205,991,1913,375,845,304,90,1483,888,315,1927,774,680,537,1118,133,292,1094,473,790,1944,1369,760,1822,195,1737,847,5,1792,1866,8,1049,98,1378,312,1221,1411,1117,1841,320,1969,1086,1557,1721,658,1150,335,1523,1350,55,1802,932,857,1189,768,248,553,469,1929,880,347,1297,986,653,779,242,488,1162,1675,195,1608,627,1672,1582,1195,1374,1060,194,51,995,299,945,890,1921,311,1095,116,860,106,1907,1149,1515,707,1038,595,1389,1668,1285,71,1074,1148,596,872,545,608,157,1534,1769,1386,1694,1381,1200,939,1816,411,1349,1728,190,1751,1936,267,966,1320,1117,246,494,1643,331,1994,1472,1360,1878,1672,314,376,28,1805,1248,1053,729,1384,122,698,1582,564,1589,683,275,12,1044,734,716,270,110,854,446,1140,1074,994,953,1588,399,711,101,624,1601,935,191,1209,964,1220,184,1503,1523,1966,1577,708,588,510,1288,388,1839,843,1960,1822,1112,327,456,1624,831,1904,1531,538,450,714,1930,1239,999,1916,1881,673,1748,589,1674,1767,1282,1069,1154,87,1216,1726,1264,310,684,764,745,769,156,243,1788,1738,172,311,1970,1730,810,65,344,561,589,640,754,1131,231,661,84,425,1504,106,1605,778,1295,756,209,857,434,544,770,1698,1570,48,135,466,1686,513,1949,1687,30,1282,1545,571,438,1360,1149,1139,862,184,426,287,215,1128,339,936,490,487,614,1014,348,1487,1132,889]\\nMy solution being\\n\\'\\'\\'\\nclass Solution {\\n    public int totalStrength(int[] strength) {\\n        return wizStrength(strength);\\n    }\\n\\n    public int wizStrength(int[] strength) {\\n        int length = strength.length;\\n        int  k,min,next,finalStrengthOfThisRow,sum,result =0;\\n        for (int j = 0; j < length; j++) {\\n            next = 0;\\n            while ( (next+j)<length) {\\n                min = strength[next]; \\n                sum=0;\\n                for (k = 0; k <= j; k++) {\\n                    if(min> strength[next]){\\n                        min = strength[next];\\n                    }\\n                    sum= sum+ strength[next];\\n                    next++;\\n                }\\n                finalStrengthOfThisRow = min* sum;\\n                result = (result +finalStrengthOfThisRow)% 1000000007;\\n                next = next - (k -1);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\'\\'\\'\\nCan any like minded person point out the issue in my solution and what I can necessarily do to reduce time complexity?\\nThanks in advance.\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int totalStrength(int[] strength) {\\n        return wizStrength(strength);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2417486,
                "title": "java-preifxsum-monotonic-stack",
                "content": "```java\\nclass Solution {\\n    public int totalStrength(int[] strength) {\\n        int length = strength.length;\\n        long[][] prefixSumArr = new long[length + 1][2]; // 0 for prefixSum for prefixSum, 1 for prefixSum;\\n        final int MOD = (int)(1e9 + 7);\\n        for (int i = 1; i <= length; i++) {\\n            prefixSumArr[i][1] = (strength[i - 1] + prefixSumArr[i - 1][1]) % MOD;\\n            prefixSumArr[i][0] = (prefixSumArr[i - 1][0] + prefixSumArr[i][1]) % MOD;\\n        }\\n        Deque<int[]> minStack = new LinkedList<>();\\n        long res = 0;\\n        long[][] subArr = new long[length][2];\\n        for (int i = 0; i < length; i++) {\\n            while (!minStack.isEmpty() && minStack.peek()[0] >= strength[i]) {\\n                minStack.pollFirst();\\n            }\\n            if (minStack.isEmpty()) {\\n                subArr[i][0] = ((long)(i + 1) * prefixSumArr[i + 1][1] - prefixSumArr[i][0]) % MOD;\\n                subArr[i][1] = i + 1;\\n            } else {\\n                int k = minStack.peek()[1];\\n                subArr[i][0] = ((long)(i - k) * prefixSumArr[i + 1][1] - (prefixSumArr[i][0] - prefixSumArr[k][0])) % MOD;\\n                subArr[i][1] = i - k;\\n            }\\n            minStack.addFirst(new int[]{strength[i], i});\\n        }\\n        minStack.clear();\\n        for (int i = length - 1; i >= 0; i--) {\\n            while (!minStack.isEmpty() && minStack.peek()[0] > strength[i]) {\\n                minStack.pollFirst();\\n            }\\n            if (minStack.isEmpty()) {\\n                long right = (prefixSumArr[length][0] - prefixSumArr[i + 1][0] - (length - 1 - i) * prefixSumArr[i + 1][1]) % MOD;\\n                long totSum = (subArr[i][0] * (length - i) + right * subArr[i][1]) % MOD;\\n                res = (res + totSum * strength[i]) % MOD;\\n            } else {\\n                int k = minStack.peek()[1];\\n                long right = 0;\\n                if (k - i > 1) {\\n                    right = (prefixSumArr[k][0] - prefixSumArr[i + 1][0] - (k - i - 1) * prefixSumArr[i + 1][1]) % MOD;\\n                }\\n                long totSum = (subArr[i][0] * (k - i) + right * subArr[i][1]) % MOD;\\n                res = (res + totSum * strength[i]) % MOD;\\n            }\\n            minStack.addFirst(new int[]{strength[i], i});\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum",
                    "Monotonic Queue"
                ],
                "code": "```java\\nclass Solution {\\n    public int totalStrength(int[] strength) {\\n        int length = strength.length;\\n        long[][] prefixSumArr = new long[length + 1][2]; // 0 for prefixSum for prefixSum, 1 for prefixSum;\\n        final int MOD = (int)(1e9 + 7);\\n        for (int i = 1; i <= length; i++) {\\n            prefixSumArr[i][1] = (strength[i - 1] + prefixSumArr[i - 1][1]) % MOD;\\n            prefixSumArr[i][0] = (prefixSumArr[i - 1][0] + prefixSumArr[i][1]) % MOD;\\n        }\\n        Deque<int[]> minStack = new LinkedList<>();\\n        long res = 0;\\n        long[][] subArr = new long[length][2];\\n        for (int i = 0; i < length; i++) {\\n            while (!minStack.isEmpty() && minStack.peek()[0] >= strength[i]) {\\n                minStack.pollFirst();\\n            }\\n            if (minStack.isEmpty()) {\\n                subArr[i][0] = ((long)(i + 1) * prefixSumArr[i + 1][1] - prefixSumArr[i][0]) % MOD;\\n                subArr[i][1] = i + 1;\\n            } else {\\n                int k = minStack.peek()[1];\\n                subArr[i][0] = ((long)(i - k) * prefixSumArr[i + 1][1] - (prefixSumArr[i][0] - prefixSumArr[k][0])) % MOD;\\n                subArr[i][1] = i - k;\\n            }\\n            minStack.addFirst(new int[]{strength[i], i});\\n        }\\n        minStack.clear();\\n        for (int i = length - 1; i >= 0; i--) {\\n            while (!minStack.isEmpty() && minStack.peek()[0] > strength[i]) {\\n                minStack.pollFirst();\\n            }\\n            if (minStack.isEmpty()) {\\n                long right = (prefixSumArr[length][0] - prefixSumArr[i + 1][0] - (length - 1 - i) * prefixSumArr[i + 1][1]) % MOD;\\n                long totSum = (subArr[i][0] * (length - i) + right * subArr[i][1]) % MOD;\\n                res = (res + totSum * strength[i]) % MOD;\\n            } else {\\n                int k = minStack.peek()[1];\\n                long right = 0;\\n                if (k - i > 1) {\\n                    right = (prefixSumArr[k][0] - prefixSumArr[i + 1][0] - (k - i - 1) * prefixSumArr[i + 1][1]) % MOD;\\n                }\\n                long totSum = (subArr[i][0] * (k - i) + right * subArr[i][1]) % MOD;\\n                res = (res + totSum * strength[i]) % MOD;\\n            }\\n            minStack.addFirst(new int[]{strength[i], i});\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2412929,
                "title": "optimized-javascript-solution",
                "content": "This is my javascript solution, works perfect with most of the testcases, but wasn\\'t able to trigger why it\\'s not working with extremly large data!\\nanyone?\\n\\n```\\n/**\\n * @param {number[]} strength\\n * @return {number}\\n */\\nvar totalStrength = function(strength) {\\n    \\n    let groupSize=1,leng=strength.length,sum=0;\\n    \\n    for(let i=0,j=0;i<leng;j++)\\n        {\\n            let temp=j+groupSize;\\n            sum+=minValue(strength.slice(j,temp))*sumValue(strength.slice(j,temp));\\n\\n               if(temp>=leng)\\n                {\\n                    groupSize+=1;\\n                    i+=1;\\n                    j=-1;\\n                }\\n        }\\n    \\n    return sum;\\n    \\n};\\n    \\n    \\n    function minValue(arr)\\n    {\\n        if(arr.length===1)return arr[0];\\n     \\n        const half = Math.ceil(arr.length / 2);    \\n\\n        return Math.min(minValue(arr.splice(0, half)),minValue(arr.splice(-half)));\\n            \\n    }\\n    \\n    function sumValue(arr)\\n    {\\n         if(arr.length===1)return arr[0];\\n        const half = Math.ceil(arr.length / 2);  \\n        return sumValue(arr.splice(0, half))+sumValue(arr.splice(-half));\\n    }\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number[]} strength\\n * @return {number}\\n */\\nvar totalStrength = function(strength) {\\n    \\n    let groupSize=1,leng=strength.length,sum=0;\\n    \\n    for(let i=0,j=0;i<leng;j++)\\n        {\\n            let temp=j+groupSize;\\n            sum+=minValue(strength.slice(j,temp))*sumValue(strength.slice(j,temp));\\n\\n               if(temp>=leng)\\n                {\\n                    groupSize+=1;\\n                    i+=1;\\n                    j=-1;\\n                }\\n        }\\n    \\n    return sum;\\n    \\n};\\n    \\n    \\n    function minValue(arr)\\n    {\\n        if(arr.length===1)return arr[0];\\n     \\n        const half = Math.ceil(arr.length / 2);    \\n\\n        return Math.min(minValue(arr.splice(0, half)),minValue(arr.splice(-half)));\\n            \\n    }\\n    \\n    function sumValue(arr)\\n    {\\n         if(arr.length===1)return arr[0];\\n        const half = Math.ceil(arr.length / 2);  \\n        return sumValue(arr.splice(0, half))+sumValue(arr.splice(-half));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2361195,
                "title": "java-solution-presum-of-presum-and-monotonic-stack-only-code",
                "content": "````\\n public int totalStrength(int[] strength) {\\n        int n = strength.length;\\n        int MOD = 1_000_000_007;\\n\\n        long[] preSum = new long[n + 1];\\n        long[] preMul = new long[n + 2];\\n        for (int i = 0; i < n; i++) {\\n            preSum[i + 1] = (preSum[i] + strength[i]) % MOD;\\n        }\\n        for (int i = 0; i <= n; i++) {\\n            preMul[i + 1] = (preMul[i] + preSum[i]) % MOD;\\n        }\\n\\n        int[] left = new int[n];\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        for (int i = 0; i < strength.length; i++) {\\n            while (!stack.isEmpty() && strength[i] <= strength[stack.peek()]) {\\n                stack.pop();\\n            }\\n            left[i] = stack.isEmpty() ? -1 : stack.peek();\\n            stack.push(i);\\n        }\\n\\n        int[] right = new int[n];\\n        stack = new ArrayDeque<>();\\n        for (int i = strength.length - 1; i >= 0 ; i--) {\\n            while (!stack.isEmpty() && strength[i] < strength[stack.peek()]) {\\n                stack.pop();\\n            }\\n            right[i] = stack.isEmpty() ? n : stack.peek();\\n            stack.push(i);\\n        }\\n\\n\\n        long ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            ans += ((preMul[right[i] + 1] - preMul[i + 1]) * (i - left[i]) % MOD + MOD * 2 -\\n                    (preMul[i + 1] - preMul[left[i] + 1]) * (right[i] - i) % MOD) * strength[i];\\n            ans %= MOD;\\n        }\\n        return (int) ans;\\n\\n    }\\n````",
                "solutionTags": [],
                "code": "````\\n public int totalStrength(int[] strength) {\\n        int n = strength.length;\\n        int MOD = 1_000_000_007;\\n\\n        long[] preSum = new long[n + 1];\\n        long[] preMul = new long[n + 2];\\n        for (int i = 0; i < n; i++) {\\n            preSum[i + 1] = (preSum[i] + strength[i]) % MOD;\\n        }\\n        for (int i = 0; i <= n; i++) {\\n            preMul[i + 1] = (preMul[i] + preSum[i]) % MOD;\\n        }\\n\\n        int[] left = new int[n];\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        for (int i = 0; i < strength.length; i++) {\\n            while (!stack.isEmpty() && strength[i] <= strength[stack.peek()]) {\\n                stack.pop();\\n            }\\n            left[i] = stack.isEmpty() ? -1 : stack.peek();\\n            stack.push(i);\\n        }\\n\\n        int[] right = new int[n];\\n        stack = new ArrayDeque<>();\\n        for (int i = strength.length - 1; i >= 0 ; i--) {\\n            while (!stack.isEmpty() && strength[i] < strength[stack.peek()]) {\\n                stack.pop();\\n            }\\n            right[i] = stack.isEmpty() ? n : stack.peek();\\n            stack.push(i);\\n        }\\n\\n\\n        long ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            ans += ((preMul[right[i] + 1] - preMul[i + 1]) * (i - left[i]) % MOD + MOD * 2 -\\n                    (preMul[i + 1] - preMul[left[i] + 1]) * (right[i] - i) % MOD) * strength[i];\\n            ans %= MOD;\\n        }\\n        return (int) ans;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2280417,
                "title": "one-pass-solution-java",
                "content": "```\\nprivate final int MOD = 1_000_000_007;\\n    \\n    public int totalStrength(int[] strength) {\\n        int n = strength.length;\\n        int prefixSum = 0;\\n        int sum = 0;\\n        Stack<Integer> monoStk = new Stack<Integer>();\\n        int[] prefixMul = new int[n+2];\\n        \\n        \\n        for(int r = 0; r <= n; r++){\\n            int current = r < n ? strength[r] : 0;\\n            prefixSum = (prefixSum + current) % MOD;\\n            prefixMul[r+1] = (prefixSum + prefixMul[r]) % MOD;\\n            while(!monoStk.isEmpty() && current < strength[monoStk.peek()]){\\n                int elementIndex = monoStk.pop();\\n                int prevSmallerIndex = monoStk.isEmpty() ? -1 : monoStk.peek();\\n                int nextSmallerIndex = r;\\n                \\n                long leftPrefixMul = prevSmallerIndex < 0 ? prefixMul[elementIndex] : \\n                                                            prefixMul[elementIndex]-prefixMul[prevSmallerIndex];\\n                \\n                long rightPrefixMul = prefixMul[nextSmallerIndex]-prefixMul[elementIndex];\\n                \\n                int leftSubArrLen =  elementIndex-prevSmallerIndex;\\n                int rightSubArrLen = nextSmallerIndex-elementIndex;\\n                \\n                sum = (int)(sum + \\n                            (rightPrefixMul*leftSubArrLen - leftPrefixMul*rightSubArrLen) % MOD * \\n                            strength[elementIndex] % MOD) % MOD;\\n            }\\n            monoStk.push(r);\\n        }\\n        return (sum + MOD) % MOD;\\n    }\\n```\\nCredits: Idea taken from this post https://leetcode.com/problems/sum-of-total-strength-of-wizards/discuss/2061985/JavaC%2B%2BPython-One-Pass-Solution\\n",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nprivate final int MOD = 1_000_000_007;\\n    \\n    public int totalStrength(int[] strength) {\\n        int n = strength.length;\\n        int prefixSum = 0;\\n        int sum = 0;\\n        Stack<Integer> monoStk = new Stack<Integer>();\\n        int[] prefixMul = new int[n+2];\\n        \\n        \\n        for(int r = 0; r <= n; r++){\\n            int current = r < n ? strength[r] : 0;\\n            prefixSum = (prefixSum + current) % MOD;\\n            prefixMul[r+1] = (prefixSum + prefixMul[r]) % MOD;\\n            while(!monoStk.isEmpty() && current < strength[monoStk.peek()]){\\n                int elementIndex = monoStk.pop();\\n                int prevSmallerIndex = monoStk.isEmpty() ? -1 : monoStk.peek();\\n                int nextSmallerIndex = r;\\n                \\n                long leftPrefixMul = prevSmallerIndex < 0 ? prefixMul[elementIndex] : \\n                                                            prefixMul[elementIndex]-prefixMul[prevSmallerIndex];\\n                \\n                long rightPrefixMul = prefixMul[nextSmallerIndex]-prefixMul[elementIndex];\\n                \\n                int leftSubArrLen =  elementIndex-prevSmallerIndex;\\n                int rightSubArrLen = nextSmallerIndex-elementIndex;\\n                \\n                sum = (int)(sum + \\n                            (rightPrefixMul*leftSubArrLen - leftPrefixMul*rightSubArrLen) % MOD * \\n                            strength[elementIndex] % MOD) % MOD;\\n            }\\n            monoStk.push(r);\\n        }\\n        return (sum + MOD) % MOD;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2260726,
                "title": "help-monotonic-stack-o-n-python",
                "content": "Can someone help me with the solution ? I\\'m not getting correct answer.\\n\\n```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        res = 0\\n        prefix = [0]\\n        stack = []\\n        \\n        for n in strength:\\n            prefix.append(prefix[-1] + n)\\n            \\n        for i , n in enumerate(strength):\\n            newStart = i\\n            while stack and stack[-1][1] > n:\\n                start, val = stack.pop()\\n                total = prefix[i] - prefix[start]\\n                res = res + (val*total)\\n                newStart = start\\n            stack.append([newStart,n])\\n        \\n        for start , val in stack:\\n            total = (prefix[len(strength)]- prefix[start])\\n            res = res + (val*total)\\n        return res % (10**9 + 7)\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        res = 0\\n        prefix = [0]\\n        stack = []\\n        \\n        for n in strength:\\n            prefix.append(prefix[-1] + n)\\n            \\n        for i , n in enumerate(strength):\\n            newStart = i\\n            while stack and stack[-1][1] > n:\\n                start, val = stack.pop()\\n                total = prefix[i] - prefix[start]\\n                res = res + (val*total)\\n                newStart = start\\n            stack.append([newStart,n])\\n        \\n        for start , val in stack:\\n            total = (prefix[len(strength)]- prefix[start])\\n            res = res + (val*total)\\n        return res % (10**9 + 7)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2258826,
                "title": "follow-up-query",
                "content": "Can we get the subarray sum of all the subarrays between index i and j in a similar way( O(n) preprocessing and O(1) retrieval)?\\n\\nExample: [a0, a1, a2, a3, a4, a5, a6]\\ni=2, j=4\\n\\nreturn sum[a2] + sum[a2, a3] + sum[a2, a3, a4] + sum[a3] + sum[a3, a4] + sum[a4]",
                "solutionTags": [],
                "code": "Can we get the subarray sum of all the subarrays between index i and j in a similar way( O(n) preprocessing and O(1) retrieval)?\\n\\nExample: [a0, a1, a2, a3, a4, a5, a6]\\ni=2, j=4\\n\\nreturn sum[a2] + sum[a2, a3] + sum[a2, a3, a4] + sum[a3] + sum[a3, a4] + sum[a4]",
                "codeTag": "Unknown"
            },
            {
                "id": 2234281,
                "title": "whats-wrong-with-this-code",
                "content": "It doesn\\'t work for large inputs. Is there a way to optimize it without doing it a completely different way?\\n\\nclass Solution:\\n    def totalStrength(self, strength: list[int]) -> int:\\n\\n        total_strength = 0\\n        length_sub = 1\\n        while length_sub <= len(strength):\\n            for i in range(len(strength) - length_sub+1):\\n                total_strength += sum(strength[i:i+length_sub])*min(strength[i:i+length_sub])\\n                print(\"length_sub: \" + str(length_sub) + \"     i: \" + str(i) + \"      total_strength: \" + str(total_strength))\\n            length_sub += 1\\n        return total_strength",
                "solutionTags": [
                    "Python"
                ],
                "code": "It doesn\\'t work for large inputs. Is there a way to optimize it without doing it a completely different way?\\n\\nclass Solution:\\n    def totalStrength(self, strength: list[int]) -> int:\\n\\n        total_strength = 0\\n        length_sub = 1\\n        while length_sub <= len(strength):\\n            for i in range(len(strength) - length_sub+1):\\n                total_strength += sum(strength[i:i+length_sub])*min(strength[i:i+length_sub])\\n                print(\"length_sub: \" + str(length_sub) + \"     i: \" + str(i) + \"      total_strength: \" + str(total_strength))\\n            length_sub += 1\\n        return total_strength",
                "codeTag": "Java"
            },
            {
                "id": 2209152,
                "title": "c-prefix-sum-prefix-sum-of-prefix-sum-monotonic-stack-very-hard-problem",
                "content": "to get the understanding of the solution just dry run it\\nyou will understand\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint totalStrength(vector<int>& strength) {\\n\\t\\t\\tint n = strength.size(), mod = 1e9 + 7;\\n\\n\\t\\t\\tvector<long long> rightPref(n), rightPrefSum(n);\\n\\t\\t\\tvector<long long> leftPref(n), leftPrefSum(n);\\n\\n\\t\\t\\trightPref[0] = strength[0];\\n\\t\\t\\trightPrefSum[0] = strength[0];\\n\\t\\t\\tfor(auto i = 1; i < n; i++){\\n\\t\\t\\t\\trightPref[i] = rightPref[i - 1] + strength[i];\\n\\t\\t\\t\\trightPrefSum[i] = rightPrefSum[i - 1] + rightPref[i];\\n\\t\\t\\t}\\n\\n\\t\\t\\tleftPref[n - 1] = strength[n - 1];\\n\\t\\t\\tleftPrefSum[n - 1] = strength[n - 1];\\n\\t\\t\\tfor(auto i = n - 2; i >= 0; i--){\\n\\t\\t\\t\\tleftPref[i] = leftPref[i + 1] + strength[i];\\n\\t\\t\\t\\tleftPrefSum[i] = leftPrefSum[i + 1] + leftPref[i];\\n\\t\\t\\t}\\n\\n\\t\\t\\tstack<int> st;\\n\\t\\t\\tvector<int> rightIndex(n); //right lowest index the current\\n\\t\\t\\tst.push(n);\\n\\t\\t\\tfor(auto i = n - 1; i >= 0; i--){   \\n\\t\\t\\t\\twhile(st.top() != n && strength[st.top()] >= strength[i]) st.pop();\\n\\n\\t\\t\\t\\trightIndex[i] = st.top() - 1;\\n\\t\\t\\t\\tst.push(i);\\n\\t\\t\\t}\\n\\n\\t\\t\\tstack<int> lst;\\n\\t\\t\\tlst.push(-1);\\n\\t\\t\\tlong long totalStrength = 0;\\n\\n\\t\\t\\tfor(auto i = 0; i < n; i++){\\n\\t\\t\\t\\twhile(lst.size() > 1 && strength[lst.top()] > strength[i]) lst.pop();\\n\\n\\t\\t\\t\\tint left = lst.top() + 1;\\n\\t\\t\\t\\tlst.push(i);\\n\\t\\t\\t\\tint right = rightIndex[i];\\n\\t\\t\\t\\tint lsize = i - left + 1;\\n\\t\\t\\t\\tint rsize = right - i + 1;\\n\\n\\t\\t\\t\\tlong long rightSum = rightPrefSum[right] - (i > 0 ? rightPrefSum[i - 1] + rightPref[i - 1] * rsize : 0) % mod;\\n\\t\\t\\t\\tlong long leftSum = leftPrefSum[left] - (i < n - 1 ? leftPrefSum[i + 1] + leftPref[i + 1] * lsize : 0) % mod;\\n\\n\\t\\t\\t\\tlong long totalSum = (rightSum % mod * lsize) % mod + (leftSum % mod * rsize) % mod - ((long long)strength[i] * lsize * rsize) % mod;\\n\\n\\t\\t\\t\\ttotalStrength = (totalStrength + (totalSum % mod * strength[i]) % mod) % mod;   \\n\\t\\t\\t}\\n\\n\\t\\t\\treturn totalStrength;  \\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint totalStrength(vector<int>& strength) {\\n\\t\\t\\tint n = strength.size(), mod = 1e9 + 7;\\n\\n\\t\\t\\tvector<long long> rightPref(n), rightPrefSum(n);\\n\\t\\t\\tvector<long long> leftPref(n), leftPrefSum(n);\\n\\n\\t\\t\\trightPref[0] = strength[0];\\n\\t\\t\\trightPrefSum[0] = strength[0];\\n\\t\\t\\tfor(auto i = 1; i < n; i++){\\n\\t\\t\\t\\trightPref[i] = rightPref[i - 1] + strength[i];\\n\\t\\t\\t\\trightPrefSum[i] = rightPrefSum[i - 1] + rightPref[i];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2202145,
                "title": "problem-same-as-1856",
                "content": "This questions seems exactly the same as https://leetcode.com/problems/maximum-subarray-min-product/, but instead of returning the maximim we accumulate the result, but using the same solution and just aggregating the value doesnt work. Why is that?\\n\\nThis is my adapted code from the maximum subarray min-product problem:\\n```\\nprefix = [0] * len(strength)\\nprefix[0] = strength[0]\\nfor i in range(1, len(strength)):\\n\\tprefix[i] = prefix[i-1] + strength[i]\\n\\nstrength = strength + [float(\\'-inf\\')]\\nprefix = [0] + prefix\\nstack = []\\nres = 0\\nfor ind, wizard in enumerate(strength):\\n\\tif not stack:\\n\\t\\tstack.append(ind)\\n\\telse:\\n\\t\\trightB = ind\\n\\n\\t\\twhile stack and wizard <= strength[stack[-1]]:\\n\\t\\t\\tminInd = stack.pop()\\n\\n\\t\\t\\tleftB = stack[-1] if stack else -1\\n\\n\\t\\t\\twizSum = prefix[rightB] - prefix[leftB+1]\\n\\n\\t\\t\\tres += strength[minInd] * wizSum\\n\\n\\t\\tstack.append(ind)\\n\\nreturn res\\n```",
                "solutionTags": [],
                "code": "```\\nprefix = [0] * len(strength)\\nprefix[0] = strength[0]\\nfor i in range(1, len(strength)):\\n\\tprefix[i] = prefix[i-1] + strength[i]\\n\\nstrength = strength + [float(\\'-inf\\')]\\nprefix = [0] + prefix\\nstack = []\\nres = 0\\nfor ind, wizard in enumerate(strength):\\n\\tif not stack:\\n\\t\\tstack.append(ind)\\n\\telse:\\n\\t\\trightB = ind\\n\\n\\t\\twhile stack and wizard <= strength[stack[-1]]:\\n\\t\\t\\tminInd = stack.pop()\\n\\n\\t\\t\\tleftB = stack[-1] if stack else -1\\n\\n\\t\\t\\twizSum = prefix[rightB] - prefix[leftB+1]\\n\\n\\t\\t\\tres += strength[minInd] * wizSum\\n\\n\\t\\tstack.append(ind)\\n\\nreturn res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2173274,
                "title": "why-tle-similar-to-sum-of-subarray-ranges",
                "content": "```java\\nclass Solution {\\n    public int totalStrength(int[] strength) {\\n        int result = 0;\\n        for(int i = 0; i < strength.length; i++) {\\n            int min = strength[i];\\n            int sum = 0;\\n            \\n            for(int j = i; j < strength.length; j++) {\\n                min = Math.min(min, strength[j]);\\n                sum += strength[j];\\n                result = ( result + min * sum) % 1000000007;\\n                \\n            }\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int totalStrength(int[] strength) {\\n        int result = 0;\\n        for(int i = 0; i < strength.length; i++) {\\n            int min = strength[i];\\n            int sum = 0;\\n            \\n            for(int j = i; j < strength.length; j++) {\\n                min = Math.min(min, strength[j]);\\n                sum += strength[j];\\n                result = ( result + min * sum) % 1000000007;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2166561,
                "title": "whats-wrong-here",
                "content": "```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        def make_sub_list(lst):\\n            lists = list()\\n            for i in range(len(lst) + 1):\\n                for j in range(i):\\n                    lists.append(lst[j: i])\\n            return lists\\n        sub_lists = make_sub_list(strength)\\n        res = 0\\n        for i in range(len(sub_lists)):\\n            temp = (min(sub_lists[i]) * sum(sub_lists[i]))\\n            res += temp\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        def make_sub_list(lst):\\n            lists = list()\\n            for i in range(len(lst) + 1):\\n                for j in range(i):\\n                    lists.append(lst[j: i])\\n            return lists\\n        sub_lists = make_sub_list(strength)\\n        res = 0\\n        for i in range(len(sub_lists)):\\n            temp = (min(sub_lists[i]) * sum(sub_lists[i]))\\n            res += temp\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155690,
                "title": "python-monotone-stack-pre-multiplication-sum-and-presum-of-presum",
                "content": "ideas:\\n(1) use mono-increasing stack to infer the left and right smaller item\\'s index;\\n(2) for each item, create the prefix sum as well as the prefix multiplication sum;\\n\\n\\n```\\ndef totalStrength(self, s: List[int]) -> int:\\n        n=len(s)\\n        mod=10**9+7\\n        left=[-1]*n\\n        right=[n]*n\\n        st=[]\\n        for i,c in enumerate(s):\\n            while st and s[st[-1]]>=c:\\n                right[st[-1]]=i\\n                st.pop()\\n            if st:\\n                left[i]=st[-1]\\n            st.append(i)\\n        ##presum: left and right\\n        ps=[0]*(n+1)\\n        psr=[0]*(n+1)\\n        ## pre-multiplication-sum: left and right\\n        pm=[0]*(n+1)\\n        pmr=[0]*(n+1)\\n        for i,c in enumerate(s):\\n            ps[i+1]=(ps[i]+c)%mod\\n            pm[i+1]=(pm[i]+(i+1)*c)%mod\\n        for i in range(n-1,-1,-1):\\n            psr[i]=(psr[i+1]+s[i])%mod\\n            pmr[i]=(pmr[i+1]+(n-i)*s[i])%mod\\n        ## loop and sum\\n        res=0\\n        for i,c in enumerate(s):\\n            leftsum=(mod+pm[i+1]-pm[left[i]+1]-(1+left[i])*(ps[i+1]-ps[left[i]+1]))%mod\\n            rightsum=(mod+pmr[i+1]-pmr[right[i]]-(n-right[i])*(psr[i+1]-psr[right[i]]))%mod\\n            sm=(leftsum*(right[i]-i)+rightsum*(i-left[i]))%mod\\n            res=(res+sm*c)%mod\\n        return res\\n\\t\\t\\n## us prefix sum of presum\\n\\ndef totalStrength(self, s: List[int]) -> int:\\n        n=len(s)\\n        mod=10**9+7\\n        left=[-1]*n\\n        right=[n]*n\\n        st=[]\\n        for i,c in enumerate(s):\\n            while st and s[st[-1]]>=c:\\n               # right[st[-1]]=i\\n                st.pop()\\n            if st:\\n                left[i]=st[-1]\\n            st.append(i)\\n        st=[]\\n        for i in range(n-1,-1,-1):\\n            while st and s[st[-1]]>s[i]:\\n                st.pop()\\n            if st:\\n                right[i]=st[-1]\\n            st.append(i)\\n        \\n        ##presum: left and right\\n        ps=[0]*(n+1)\\n        ps2=[0]*(n+2)\\n        for i,c in enumerate(s):\\n            ps[i+1]=(ps[i]+c)%mod\\n        for i in range(n+1):\\n            ps2[i+1]=(ps2[i]+ps[i])%mod\\n          \\n        ## loop and sum\\n        res=0\\n        for i,c in enumerate(s):\\n            sm=(mod+ps2[right[i]+1]-ps2[i+1])*(i-left[i])%mod\\n            sm-=(ps2[i+1]-ps2[left[i]+1])*(right[i]-i)%mod\\n            res=(res+sm*c)%mod\\n        return res",
                "solutionTags": [],
                "code": "ideas:\\n(1) use mono-increasing stack to infer the left and right smaller item\\'s index;\\n(2) for each item, create the prefix sum as well as the prefix multiplication sum;\\n\\n\\n```\\ndef totalStrength(self, s: List[int]) -> int:\\n        n=len(s)\\n        mod=10**9+7\\n        left=[-1]*n\\n        right=[n]*n\\n        st=[]\\n        for i,c in enumerate(s):\\n            while st and s[st[-1]]>=c:\\n                right[st[-1]]=i\\n                st.pop()\\n            if st:\\n                left[i]=st[-1]\\n            st.append(i)\\n        ##presum: left and right\\n        ps=[0]*(n+1)\\n        psr=[0]*(n+1)\\n        ## pre-multiplication-sum: left and right\\n        pm=[0]*(n+1)\\n        pmr=[0]*(n+1)\\n        for i,c in enumerate(s):\\n            ps[i+1]=(ps[i]+c)%mod\\n            pm[i+1]=(pm[i]+(i+1)*c)%mod\\n        for i in range(n-1,-1,-1):\\n            psr[i]=(psr[i+1]+s[i])%mod\\n            pmr[i]=(pmr[i+1]+(n-i)*s[i])%mod\\n        ## loop and sum\\n        res=0\\n        for i,c in enumerate(s):\\n            leftsum=(mod+pm[i+1]-pm[left[i]+1]-(1+left[i])*(ps[i+1]-ps[left[i]+1]))%mod\\n            rightsum=(mod+pmr[i+1]-pmr[right[i]]-(n-right[i])*(psr[i+1]-psr[right[i]]))%mod\\n            sm=(leftsum*(right[i]-i)+rightsum*(i-left[i]))%mod\\n            res=(res+sm*c)%mod\\n        return res\\n\\t\\t\\n## us prefix sum of presum\\n\\ndef totalStrength(self, s: List[int]) -> int:\\n        n=len(s)\\n        mod=10**9+7\\n        left=[-1]*n\\n        right=[n]*n\\n        st=[]\\n        for i,c in enumerate(s):\\n            while st and s[st[-1]]>=c:\\n               # right[st[-1]]=i\\n                st.pop()\\n            if st:\\n                left[i]=st[-1]\\n            st.append(i)\\n        st=[]\\n        for i in range(n-1,-1,-1):\\n            while st and s[st[-1]]>s[i]:\\n                st.pop()\\n            if st:\\n                right[i]=st[-1]\\n            st.append(i)\\n        \\n        ##presum: left and right\\n        ps=[0]*(n+1)\\n        ps2=[0]*(n+2)\\n        for i,c in enumerate(s):\\n            ps[i+1]=(ps[i]+c)%mod\\n        for i in range(n+1):\\n            ps2[i+1]=(ps2[i]+ps[i])%mod\\n          \\n        ## loop and sum\\n        res=0\\n        for i,c in enumerate(s):\\n            sm=(mod+ps2[right[i]+1]-ps2[i+1])*(i-left[i])%mod\\n            sm-=(ps2[i+1]-ps2[left[i]+1])*(right[i]-i)%mod\\n            res=(res+sm*c)%mod\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2144694,
                "title": "elegant-python-solution-with-o-n",
                "content": "Let us examine a string `s` with length `n`. We denote its power up until index `i` as `P[i]`.\\n```\\nP[0] = s[0]\\nP[1] = s[0] + s[1] + min(s[0], s[1]) * sum(s[0], s[1])\\nP[2] = s[0] + s[1] + s[2] + min(s[0], s[1]) * sum(s[0], s[1]) + min(s[1], s[2]) * sum(s[1], s[2]) + min(s[0], s[1], s[2]) * sum(s[0], s[1], s[2])\\n```\\nWith induction we can prove that:\\n```\\nP[k] = P[k-1] + SUM_{i=0}^{k-1} [min(s[i:k]) * sum(s[i:k])]\\nwhere P[-1] = 0\\n```\\nAll we have to do it to add the power of the sub string s[0:n-1] to the sum of the expressions above. The code is very simple: \\n\\n```\\nclass Solution(object):\\n    @staticmethod\\n    def calcCumPower(substr):\\n        ret = 0\\n        n = len(substr)\\n        for i in range(n):\\n            ret += min(substr[i:n]) * sum(substr[i:n])\\n        return ret\\n    \\n    def totalStrength(self, strength: List[int]) -> int:\\n        n = len(strength)\\n        if n == 0:\\n            return 0\\n        \\n        return (self.totalStrength(strength[0:n-1]) + self.calcCumPower(strength)) % (10**9 + 7)\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nP[0] = s[0]\\nP[1] = s[0] + s[1] + min(s[0], s[1]) * sum(s[0], s[1])\\nP[2] = s[0] + s[1] + s[2] + min(s[0], s[1]) * sum(s[0], s[1]) + min(s[1], s[2]) * sum(s[1], s[2]) + min(s[0], s[1], s[2]) * sum(s[0], s[1], s[2])\\n```\n```\\nP[k] = P[k-1] + SUM_{i=0}^{k-1} [min(s[i:k]) * sum(s[i:k])]\\nwhere P[-1] = 0\\n```\n```\\nclass Solution(object):\\n    @staticmethod\\n    def calcCumPower(substr):\\n        ret = 0\\n        n = len(substr)\\n        for i in range(n):\\n            ret += min(substr[i:n]) * sum(substr[i:n])\\n        return ret\\n    \\n    def totalStrength(self, strength: List[int]) -> int:\\n        n = len(strength)\\n        if n == 0:\\n            return 0\\n        \\n        return (self.totalStrength(strength[0:n-1]) + self.calcCumPower(strength)) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086217,
                "title": "python-o-n",
                "content": "So excited when coming up with the idea.\\nBut index issue really bothers when it comes to \"sum of sum\". Sorry for the terrible code style.\\n```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        MOD = int(1e9+7)\\n        prev_equalsmaller, next_smaller = [-1]*len(strength), [len(strength)]*len(strength)\\n        stack = []\\n        for i in range(len(strength)):\\n            while stack and strength[stack[-1]] > strength[i]:\\n                x = stack.pop()\\n                next_smaller[x] = i\\n            if stack:\\n                prev_equalsmaller[i] = stack[-1]\\n            stack.append(i)\\n            \\n        subSum = [0]*(len(strength)+1) # subSum[x]:[0:x) -- [i:j) = subSum[j] - subSum[i]\\n        for i in range(1, len(strength)+1):\\n            subSum[i] = subSum[i-1] + strength[i-1]\\n        subSumSum = [0]*(len(subSum)+1) # subSumSum[x]:[0:x) -- [i:j) = subSumSum[j] - subSumSum[i]\\n        for i in range(1, len(subSum)+1):\\n            subSumSum[i] = (subSumSum[i-1] + subSum[i-1]) % MOD\\n        \\n        ans = 0\\n        for x in range(len(strength)):\\n            i, j = prev_equalsmaller[x], next_smaller[x]\\n            m, n = x - i, j - x \\n            # (i,x] --> -[i,x) subSum[i+1]~subSum[x] subSumSum[x+1] - subSumSum[i+1]\\n            # [x, j) --> subSum[x+1] ~ subSum[j] subSumSum[j+1] - subSumSum[x+1]\\n            total = (subSumSum[j+1] - subSumSum[x+1]) * (x - i) - (subSumSum[x+1] - subSumSum[i+1]) * (j - x)\\n            total = (total % MOD)*strength[x] % MOD\\n            ans = (ans + total) % MOD\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        MOD = int(1e9+7)\\n        prev_equalsmaller, next_smaller = [-1]*len(strength), [len(strength)]*len(strength)\\n        stack = []\\n        for i in range(len(strength)):\\n            while stack and strength[stack[-1]] > strength[i]:\\n                x = stack.pop()\\n                next_smaller[x] = i\\n            if stack:\\n                prev_equalsmaller[i] = stack[-1]\\n            stack.append(i)\\n            \\n        subSum = [0]*(len(strength)+1) # subSum[x]:[0:x) -- [i:j) = subSum[j] - subSum[i]\\n        for i in range(1, len(strength)+1):\\n            subSum[i] = subSum[i-1] + strength[i-1]\\n        subSumSum = [0]*(len(subSum)+1) # subSumSum[x]:[0:x) -- [i:j) = subSumSum[j] - subSumSum[i]\\n        for i in range(1, len(subSum)+1):\\n            subSumSum[i] = (subSumSum[i-1] + subSum[i-1]) % MOD\\n        \\n        ans = 0\\n        for x in range(len(strength)):\\n            i, j = prev_equalsmaller[x], next_smaller[x]\\n            m, n = x - i, j - x \\n            # (i,x] --> -[i,x) subSum[i+1]~subSum[x] subSumSum[x+1] - subSumSum[i+1]\\n            # [x, j) --> subSum[x+1] ~ subSum[j] subSumSum[j+1] - subSumSum[x+1]\\n            total = (subSumSum[j+1] - subSumSum[x+1]) * (x - i) - (subSumSum[x+1] - subSumSum[i+1]) * (j - x)\\n            total = (total % MOD)*strength[x] % MOD\\n            ans = (ans + total) % MOD\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076924,
                "title": "racket-solution-and-explanation",
                "content": "Explanation\\n\\n![image](https://assets.leetcode.com/users/images/b0798aed-c2fe-40fb-a17d-a567ade23137_1653589261.7779553.png)\\n![image](https://assets.leetcode.com/users/images/67bbe428-498c-40d1-9804-8f52a0e4b5c1_1653589280.2554514.png)\\n![image](https://assets.leetcode.com/users/images/ee6adc7d-bad8-49cb-92da-7dfc9b7074d6_1653589291.030931.png)\\n\\nRacket code\\n\\n```scheme\\n(define/contract (total-strength strength)\\n  (-> (listof exact-integer?) exact-integer?)\\n\\n  (define len (length strength))\\n\\n  (define prev-smaller-lst\\n    (let ([stk \\'()]\\n          [get-strength (lst-ith strength #f)])\\n      (for/list ([i len]\\n                 [v strength])\\n        (let ([remain (dropf stk (lambda (j) (>= (get-strength j) v)))])\\n          (set! stk (cons i remain))\\n          (if (null? remain)\\n              -1\\n              (car remain))))))\\n\\n  (let* ([psum (get-prefixsum strength)]\\n         [fpsum (lst-ith psum 0)]\\n         [ppsum (get-prefixsum psum)]\\n         [fppsum (lst-ith ppsum 0)]\\n         [eq1s (make-vector len)]\\n         [eq2s (make-vector len)]\\n         [results\\n          (for/list ([i len]\\n                     [v strength]\\n                     [k prev-smaller-lst])\\n            (let ([eq1 (mod (+ (if (= k -1) 0 (vector-ref eq1s k))\\n                               (mod (* (- i k) v))))]\\n                  [eq2 (mod (+ (if (= k -1) 0 (vector-ref eq2s k))\\n                               (mod (* v (- (fppsum (- i 1))\\n                                            (fppsum (- k 1)))))))])\\n              (vector-set! eq1s i eq1)\\n              (vector-set! eq2s i eq2)\\n              (mod (- (mod (* (fpsum i) eq1)) eq2))))])\\n    (foldl (compose mod +) 0 results)))\\n\\n(define (mod x) (modulo x (+ #e1e9 7)))\\n\\n;; helpers ;;\\n\\n(define (lst-ith lst default)\\n  (let ([vec (list->vector lst)])\\n    (lambda (i)\\n      (if (< i 0)\\n          default\\n          (vector-ref vec i)))))\\n\\n(define (get-prefixsum lst)\\n  (scanl (compose mod +) 0 lst))\\n\\n(define (scanl f init lst)\\n  (let ([acc init])\\n    (for/list ([v lst])\\n      (set! acc (f v acc))\\n      acc)))\\n```",
                "solutionTags": [
                    "Racket"
                ],
                "code": "```scheme\\n(define/contract (total-strength strength)\\n  (-> (listof exact-integer?) exact-integer?)\\n\\n  (define len (length strength))\\n\\n  (define prev-smaller-lst\\n    (let ([stk \\'()]\\n          [get-strength (lst-ith strength #f)])\\n      (for/list ([i len]\\n                 [v strength])\\n        (let ([remain (dropf stk (lambda (j) (>= (get-strength j) v)))])\\n          (set! stk (cons i remain))\\n          (if (null? remain)\\n              -1\\n              (car remain))))))\\n\\n  (let* ([psum (get-prefixsum strength)]\\n         [fpsum (lst-ith psum 0)]\\n         [ppsum (get-prefixsum psum)]\\n         [fppsum (lst-ith ppsum 0)]\\n         [eq1s (make-vector len)]\\n         [eq2s (make-vector len)]\\n         [results\\n          (for/list ([i len]\\n                     [v strength]\\n                     [k prev-smaller-lst])\\n            (let ([eq1 (mod (+ (if (= k -1) 0 (vector-ref eq1s k))\\n                               (mod (* (- i k) v))))]\\n                  [eq2 (mod (+ (if (= k -1) 0 (vector-ref eq2s k))\\n                               (mod (* v (- (fppsum (- i 1))\\n                                            (fppsum (- k 1)))))))])\\n              (vector-set! eq1s i eq1)\\n              (vector-set! eq2s i eq2)\\n              (mod (- (mod (* (fpsum i) eq1)) eq2))))])\\n    (foldl (compose mod +) 0 results)))\\n\\n(define (mod x) (modulo x (+ #e1e9 7)))\\n\\n;; helpers ;;\\n\\n(define (lst-ith lst default)\\n  (let ([vec (list->vector lst)])\\n    (lambda (i)\\n      (if (< i 0)\\n          default\\n          (vector-ref vec i)))))\\n\\n(define (get-prefixsum lst)\\n  (scanl (compose mod +) 0 lst))\\n\\n(define (scanl f init lst)\\n  (let ([acc init])\\n    (for/list ([v lst])\\n      (set! acc (f v acc))\\n      acc)))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2075499,
                "title": "what-am-i-doin-wrong",
                "content": "\\tclass Solution:\\n\\t\\tdef totalStrength(self, strength: List[int]) -> int:\\n\\t\\t\\tL=len(strength)\\n\\t\\t\\tcou=0\\n\\n\\t\\t\\tfor a in range (L):\\n\\t\\t\\t\\tfor b in range(L-a):\\n\\t\\t\\t\\t\\tli=strength[b:a+b+1]\\n\\t\\t\\t\\t\\tcou+=sum(li)*min(li)\\n\\n\\t\\t\\treturn cou%(10**9)\\n\\t\\t\\nThis is what I\\'ve been able to come up with till now. It works for smaller arrays but bigger arrays are coming incorrect. Can anyone tell me what I can do to fix this?",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef totalStrength(self, strength: List[int]) -> int:\\n\\t\\t\\tL=len(strength)\\n\\t\\t\\tcou=0\\n\\n\\t\\t\\tfor a in range (L):\\n\\t\\t\\t\\tfor b in range(L-a):\\n\\t\\t\\t\\t\\tli=strength[b:a+b+1]\\n\\t\\t\\t\\t\\tcou+=sum(li)*min(li)\\n\\n\\t\\t\\treturn cou%(10**9)\\n\\t\\t\\nThis is what I\\'ve been able to come up with till now. It works for smaller arrays but bigger arrays are coming incorrect. Can anyone tell me what I can do to fix this?",
                "codeTag": "Java"
            },
            {
                "id": 2075034,
                "title": "stacks-and-prefix-sums-with-python",
                "content": "Hello! Admittedly, my solution is not very efficient (max was >54%), but it is one that I understand what I\\'m typing, so I hope it is helpful. And it was approved, so I won\\'t complain too much.\\n\\nAnyhow, do scroll down all the way for the python code, below is the explanation first\\n\\nMy first solution was to have a layer of [min, sum] for each element, and then add them rightwards. The layers would get increasingly smaller until it is of length 1. So the time complexity of n!, which isn\\'t fast enough. But this n! algorithm, and the other solutions posted here on discussion, helped me realise that many of the sums can share a common minimum element.\\n\\nThis leads to the next idea: from which index to which index is the element at my current index the minimum of every subarray (including the *current element*)? First, we initialise two arrays, onTheLeft and onTheRight, to track how many indices, on the left and on the right respectively, reference an element larger than my current element (i.e. which my current element is the minimum). Their initial values will be their own index.\\n\\nOur target at the end is to get the following information for every index: start, anchor, end.\\n* anchor: the current index\\n* start: The starting index of the subarray in which my anchor is the minimum\\n* end: The final index (inclusive) of the subarray in which my anchor is the minimum\\nTo get the indices we want, when we iterate through the strengths, we will make use of a stack. Let\\'s say we are searching for the start indices of each index (i.e. using the onTheLeft list). When we use the stack, we will:\\n1. first check that it is not empty\\n2. Let the current index be x. take a look at the index of the top stack, let\\'s call this index y. if the strength of  index y is larger than the strength of index x, I will set the starting index of x to the *start index of the index y*. Think about it like this: If the strength at index x is smaller than the strength at index y, remember that the strength of index y is the smallest of it\\'s own subarray. Therefore the strength of index x is also smaller than the strength at the starting index of index y.\\n3. remove index y\\n4. append index x\\nnote that index y\\'s starting index is not lost. it is captured as index x\\'s starting index!\\n\\nfor the case of the ending index, using the onTheRight, it is essentially the reverse of onTheLeft, so using negative indexing.\\n\\nbefore computing the contiguous sums, we will need some helpful prefix sums to make life slightly easier. the first prefix sum is just the sum of strengths until the index you are at (i.e. if you use sum(strength[:idx])) you would get the same as prefix[idx]). The second prefix sum list is the sum of those prefix sums. Using the test case example [1, 3, 1, 2]:\\nprefix = [1, 1+3, 1+3+1, 1+3+1+2]\\nprefixPrefix = [(1), (1) + (1+3), (1) + (1+3) + (1+3+1), (1) + (1+3) + (1+3+1) + (1+3+1+2)] \\nwe append 0s to the end of each arrays in the event where we get a -1 index, we don\\'t want it to affect our calculations\\n\\nNext up is to get the contiguous sums of every subarray of each index. To know what contiguous sums to compute, we will need to generalise how we use the start, anchor and end indices. Let\\'s consider two portions in every contiguous sum, the start-to-anchor (startAnchor) and anchor-to-end (anchorEnd) portions. i will talk about what each expression is doing:\\n\\nanchorEnd\\n- **prefixPrefix[end] - prefixPrefix[anchor - 1]**: This leaves behind the sum of sums of subarrays from the start (of the strength list) to each index from the anchor to end, inclusive. (i.e. sum( strength[anchor:end+1] + strength[anchor+1:end] + ... + strength[anchor] )\\n-  **- prefix[anchor - 1] * (end - anchor + 1)**: This removes the sum of elements from the start (of the strength list) to just before the anchor (i.e. sum(strength[:anchor-1])). For each of the subarrays, we will need to remove this sum(strength[:anchor-1]), which is obtained from (end - anchor + 1)\\n-  **times (anchor - start + 1)**: From our last two steps, we have obtained the contiguous sum of subarrays from strength[anchor:end+1]. We will need to take this sum and multiply it by the number of indices from start to anchor, + 1. Each of these contiguous sums can be seen as attached to each contiguous array from strength[start:anchor]. The +1 is for the contiguous sum that is not attached to any subarray.\\n\\nstartAnchor\\n- First, an observation. If we were to write out the elements of subarrays involved in calculating anchorEnd, with the longest one on top to the shortest one below (which would just be the anchor itself), we would notice a slant of elements (like y = x line). But if we were to do this for the subarrays in startAnchor, it would be in a different direction (like a y = -x line). Remember that the anchor is the lowest value in the subarrays, so we are decreasing the index from the left to the right (i.e. if our start to anchor is [4,3,2,1], with 4 being the start and 1 being the anchor, our subarrays are [4,3,2], [3,2], [2] (also note that 1 is calculated in anchorEnd, so do not double count here). )\\n- **(prefix[anchor - 1] - prefix[start - 1]) * (anchor - start + 1)**: This gives us the sum of the subarray strength[start: anchor], times the number of indices between start and anchor. Think about it like a rectangle, and we are going to chop off a triangle at the bottom left\\n- **(prefixPrefix[anchor - 1] - prefixPrefix[start - 1] - prefix[start - 1] * (anchor - start))**: This is almost the same steps as in anchorEnd, but the triangle obtained (if you were to draw out the elements) is one index shorter. This is because this sum is the sum we are going to use as the triangle to chop off our rectangle\\n- **times (end - anchor + 1)**: lastly, we repeat this sum for the number of indices between the end and anchor, same reasoning as for anchorEnd\\n\\nand so we have everything we neeed, just one last loop through the strengths, retrieve your values for start, anchor and end, plug those values for the contiguous sum and add it to your result.\\n\\n\\n**Python**\\n```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        MOD = 10 ** 9 + 7    \\n        res = 0\\n        \\n        stackLeft, stackRight = [], []\\n        onTheLeft = [i for i in range(len(strength))]\\n        onTheRight = [j for j in range(-len(strength), 0)]\\n        prefix, prefixPrefix = [strength[0]], [strength[0]]\\n        for i in range(len(strength)):\\n            while stackLeft and strength[i] < strength[stackLeft[-1]]:\\n                onTheLeft[i] = onTheLeft[stackLeft[-1]]\\n                stackLeft.pop()\\n            stackLeft.append(i)\\n            \\n            while stackRight and strength[-i-1] <= strength[stackRight[-1]]:\\n                onTheRight[-i-1] = onTheRight[stackRight[-1]]\\n                stackRight.pop()\\n            stackRight.append(-i-1)\\n            \\n            if i == 0:\\n                continue\\n            prefix.append(prefix[-1] + strength[i])\\n            prefixPrefix.append(prefix[-1] + prefixPrefix[-1])\\n        \\n        prefix += [0]\\n        prefixPrefix += [0]\\n        \\n        for k in range(len(strength)):\\n            start, end = onTheLeft[k], onTheRight[k] + len(strength)\\n            sums = self.contiguousSums(prefix, prefixPrefix, start, k, end)\\n            res += (sums * strength[k]) % MOD\\n        return res % MOD\\n\\n    def contiguousSums(self, prefix, prefixPrefix, start, anchor, end):\\n        anchorEnd = (prefixPrefix[end] - prefixPrefix[anchor-1] - prefix[anchor - 1] * (end - anchor + 1)) * (anchor - start + 1)\\n        startAnchor = ((prefix[anchor - 1] - prefix[start - 1]) * (anchor - start + 1) - (prefixPrefix[anchor - 1] - prefixPrefix[start - 1] - prefix[start - 1] * (anchor - start))) * (end - anchor + 1)\\n        return (anchorEnd + startAnchor)\\n```\\n\\nwill I remember how to do this? probably not.",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        MOD = 10 ** 9 + 7    \\n        res = 0\\n        \\n        stackLeft, stackRight = [], []\\n        onTheLeft = [i for i in range(len(strength))]\\n        onTheRight = [j for j in range(-len(strength), 0)]\\n        prefix, prefixPrefix = [strength[0]], [strength[0]]\\n        for i in range(len(strength)):\\n            while stackLeft and strength[i] < strength[stackLeft[-1]]:\\n                onTheLeft[i] = onTheLeft[stackLeft[-1]]\\n                stackLeft.pop()\\n            stackLeft.append(i)\\n            \\n            while stackRight and strength[-i-1] <= strength[stackRight[-1]]:\\n                onTheRight[-i-1] = onTheRight[stackRight[-1]]\\n                stackRight.pop()\\n            stackRight.append(-i-1)\\n            \\n            if i == 0:\\n                continue\\n            prefix.append(prefix[-1] + strength[i])\\n            prefixPrefix.append(prefix[-1] + prefixPrefix[-1])\\n        \\n        prefix += [0]\\n        prefixPrefix += [0]\\n        \\n        for k in range(len(strength)):\\n            start, end = onTheLeft[k], onTheRight[k] + len(strength)\\n            sums = self.contiguousSums(prefix, prefixPrefix, start, k, end)\\n            res += (sums * strength[k]) % MOD\\n        return res % MOD\\n\\n    def contiguousSums(self, prefix, prefixPrefix, start, anchor, end):\\n        anchorEnd = (prefixPrefix[end] - prefixPrefix[anchor-1] - prefix[anchor - 1] * (end - anchor + 1)) * (anchor - start + 1)\\n        startAnchor = ((prefix[anchor - 1] - prefix[start - 1]) * (anchor - start + 1) - (prefixPrefix[anchor - 1] - prefixPrefix[start - 1] - prefix[start - 1] * (anchor - start))) * (end - anchor + 1)\\n        return (anchorEnd + startAnchor)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074578,
                "title": "python-o-n-dp-using-spans-and-cumulative-sums",
                "content": "```\\nclass Solution:\\n  def totalStrength(self, strength: List[int]) -> int:\\n    n = len(strength)\\n    spans = [[-1, n] for _ in range(n)]\\n    stack = deque()\\n    for i in range(n):\\n      while len(stack) > 0 and strength[i] < strength[stack[-1]]:\\n        spans[stack[-1]][1] = i\\n        stack.pop()\\n      if len(stack) > 0:  \\n        spans[i][0] = stack[-1]\\n      stack.append(i)\\n      \\n    s = 0\\n    cumSum = [0 for _ in range(n)]\\n    for i in range(n):\\n      s += strength[i]\\n      cumSum[i] = s\\n      \\n    s = 0\\n    cumCumSum = [0 for _ in range(n)]\\n    for i in range(n):\\n      s += cumSum[i]\\n      cumCumSum[i] = s\\n      \\n    s = 0\\n    reverseCumSum = [0 for _ in range(n)]\\n    for i in range(n - 1, -1, -1):\\n      s += strength[i]\\n      reverseCumSum[i] = s\\n      \\n    s = 0\\n    reverseCumCumSum = [0 for _ in range(n)]\\n    for i in range(n - 1, -1, -1):\\n      s += reverseCumSum[i]\\n      reverseCumCumSum[i] = s\\n      \\n    tot = 0\\n    m = 1000000007\\n    for i in range(n):\\n      st = strength[i]\\n      sp = spans[i]\\n      l = i - sp[0] - 1\\n      r = sp[1] - i - 1\\n      s = 0\\n      s += (l + 1) * ((r * st) + cumCumSum[sp[1] - 1] - cumCumSum[i] - (r * cumSum[i]))\\n      s += (r + 1) * ((l * st) + reverseCumCumSum[sp[0] + 1] - reverseCumCumSum[i] - (l * reverseCumSum[i]))\\n      s -= ((l * r) - 1) * st\\n      tot += (st * s)\\n      tot %= m\\n      \\n    return tot\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def totalStrength(self, strength: List[int]) -> int:\\n    n = len(strength)\\n    spans = [[-1, n] for _ in range(n)]\\n    stack = deque()\\n    for i in range(n):\\n      while len(stack) > 0 and strength[i] < strength[stack[-1]]:\\n        spans[stack[-1]][1] = i\\n        stack.pop()\\n      if len(stack) > 0:  \\n        spans[i][0] = stack[-1]\\n      stack.append(i)\\n      \\n    s = 0\\n    cumSum = [0 for _ in range(n)]\\n    for i in range(n):\\n      s += strength[i]\\n      cumSum[i] = s\\n      \\n    s = 0\\n    cumCumSum = [0 for _ in range(n)]\\n    for i in range(n):\\n      s += cumSum[i]\\n      cumCumSum[i] = s\\n      \\n    s = 0\\n    reverseCumSum = [0 for _ in range(n)]\\n    for i in range(n - 1, -1, -1):\\n      s += strength[i]\\n      reverseCumSum[i] = s\\n      \\n    s = 0\\n    reverseCumCumSum = [0 for _ in range(n)]\\n    for i in range(n - 1, -1, -1):\\n      s += reverseCumSum[i]\\n      reverseCumCumSum[i] = s\\n      \\n    tot = 0\\n    m = 1000000007\\n    for i in range(n):\\n      st = strength[i]\\n      sp = spans[i]\\n      l = i - sp[0] - 1\\n      r = sp[1] - i - 1\\n      s = 0\\n      s += (l + 1) * ((r * st) + cumCumSum[sp[1] - 1] - cumCumSum[i] - (r * cumSum[i]))\\n      s += (r + 1) * ((l * st) + reverseCumCumSum[sp[0] + 1] - reverseCumCumSum[i] - (l * reverseCumSum[i]))\\n      s -= ((l * r) - 1) * st\\n      tot += (st * s)\\n      tot %= m\\n      \\n    return tot\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2073630,
                "title": "swift-o-n",
                "content": "\\n\\n\\n```\\nclass Solution {\\n    func totalStrength(_ strength: [Int]) -> Int {\\n        guard !strength.isEmpty else { return 0 }\\n        \\n        let MOD = 1_000_000_007\\n        let N = strength.count\\n        \\n        \\n        var prefixSum = Array(repeating: 0, count: N + 1)\\n        for i in 0..<N {\\n            prefixSum[i + 1] = (prefixSum[i] + strength[i]) % MOD\\n        }\\n        \\n        // prefixSum of prefixSum\\n        var prefixPrefixSum = Array(repeating: 0, count: N + 2)\\n        for i in 0...N {\\n            prefixPrefixSum[i + 1] = (prefixPrefixSum[i] + prefixSum[i]) % MOD\\n        }\\n        \\n        // left[i]: \\n        var left = Array(repeating: -1, count: N)\\n        \\n        var stk: [Int] = []\\n        \\n        for i in 0..<N {\\n            while !stk.isEmpty && strength[i] <= strength[stk.last!] {\\n                stk.removeLast()\\n            }\\n            \\n            left[i] = stk.last ?? -1\\n            stk.append(i)\\n        }\\n        \\n        stk.removeAll()\\n        var right = Array(repeating: N, count: N)\\n        \\n        for i in (0..<N).reversed() {\\n            while !stk.isEmpty && strength[i] < strength[stk.last!] {\\n                stk.removeLast()\\n            }\\n            right[i] = stk.last ?? N\\n            stk.append(i)\\n        }\\n        \\n        var res = 0\\n        for i in 0..<N {\\n            res += ((prefixPrefixSum[right[i] + 1] - prefixPrefixSum[i + 1]) * (i - left[i]) % MOD + MOD * 2 - (prefixPrefixSum[i + 1] - prefixPrefixSum[left[i] + 1]) * (right[i] - i) % MOD) % MOD * strength[i] % MOD;\\n            res %= MOD\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func totalStrength(_ strength: [Int]) -> Int {\\n        guard !strength.isEmpty else { return 0 }\\n        \\n        let MOD = 1_000_000_007\\n        let N = strength.count\\n        \\n        \\n        var prefixSum = Array(repeating: 0, count: N + 1)\\n        for i in 0..<N {\\n            prefixSum[i + 1] = (prefixSum[i] + strength[i]) % MOD\\n        }\\n        \\n        // prefixSum of prefixSum\\n        var prefixPrefixSum = Array(repeating: 0, count: N + 2)\\n        for i in 0...N {\\n            prefixPrefixSum[i + 1] = (prefixPrefixSum[i] + prefixSum[i]) % MOD\\n        }\\n        \\n        // left[i]: \\n        var left = Array(repeating: -1, count: N)\\n        \\n        var stk: [Int] = []\\n        \\n        for i in 0..<N {\\n            while !stk.isEmpty && strength[i] <= strength[stk.last!] {\\n                stk.removeLast()\\n            }\\n            \\n            left[i] = stk.last ?? -1\\n            stk.append(i)\\n        }\\n        \\n        stk.removeAll()\\n        var right = Array(repeating: N, count: N)\\n        \\n        for i in (0..<N).reversed() {\\n            while !stk.isEmpty && strength[i] < strength[stk.last!] {\\n                stk.removeLast()\\n            }\\n            right[i] = stk.last ?? N\\n            stk.append(i)\\n        }\\n        \\n        var res = 0\\n        for i in 0..<N {\\n            res += ((prefixPrefixSum[right[i] + 1] - prefixPrefixSum[i + 1]) * (i - left[i]) % MOD + MOD * 2 - (prefixPrefixSum[i + 1] - prefixPrefixSum[left[i] + 1]) * (right[i] - i) % MOD) % MOD * strength[i] % MOD;\\n            res %= MOD\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072417,
                "title": "java-solution-using-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int totalStrength(int[] stren) {\\n        long MOD = 1000000007;\\n        \\n        int N = stren.length;\\n        \\n        long[] p1 = new long[N];\\n        long[] p2 = new long[N];\\n        \\n        p1[0] = stren[0];\\n        p2[0] = stren[0];\\n        \\n        for(int i=1;i<N;i++) {\\n            \\n            p1[i] = p1[i-1] + stren[i];\\n            p2[i] = p2[i-1] + p1[i];\\n        }\\n        \\n        Stack<Long> stk = new Stack<Long>();\\n        long result = 0;\\n        \\n        int i = 0;\\n        \\n        // both right and left excluded\\n        // p1[right-1] - p1[left] + p1[right-2] - p1[left] + ... p1[current] - p1[left]\\n        // p2[right-1] - p2[curr-1] - p1[left]*(right - 1 - curr + 1)\\n        // for all left to current-1\\n        // (p2[right-1] - p2[current-1])*(current - left) - (p1[left] + p1[left+1] + .. p1[current -1])(right - curr)\\n        \\n        while(i <= N) {\\n            \\n            while(! stk.empty() && (i==N || stren[stk.peek().intValue()] >= stren[i])) {\\n                int cur = stk.pop().intValue();\\n                \\n                int left = -1;\\n                \\n                if(! stk.empty()) {\\n                    left = stk.peek().intValue();\\n                }\\n                \\n                int right = i;\\n                \\n                long pr = right > 0 ? p2[right - 1] : 0;\\n                long pl = left > 0 ? p2[left - 1] : 0;\\n                long pc = cur > 0 ? p2[cur - 1] : 0;\\n                \\n                //exluded right and left index\\n                long count1 = cur - 1 - left + 1;\\n                long count2 = right - 1 - cur + 1;\\n                \\n                long pp1 = (pr - pc)%MOD;\\n                long pp2 = (pc - pl)%MOD;\\n                \\n                long res = (stren[cur]) * ((pp1*count1)%MOD - (pp2*count2)%MOD + 2*MOD)%MOD;\\n                \\n                res = (res + MOD)%MOD;\\n                result = (result + res)%MOD;\\n                \\n            }\\n            \\n            stk.push((long)i++);\\n        }\\n        \\n        return (int)result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalStrength(int[] stren) {\\n        long MOD = 1000000007;\\n        \\n        int N = stren.length;\\n        \\n        long[] p1 = new long[N];\\n        long[] p2 = new long[N];\\n        \\n        p1[0] = stren[0];\\n        p2[0] = stren[0];\\n        \\n        for(int i=1;i<N;i++) {\\n            \\n            p1[i] = p1[i-1] + stren[i];\\n            p2[i] = p2[i-1] + p1[i];\\n        }\\n        \\n        Stack<Long> stk = new Stack<Long>();\\n        long result = 0;\\n        \\n        int i = 0;\\n        \\n        // both right and left excluded\\n        // p1[right-1] - p1[left] + p1[right-2] - p1[left] + ... p1[current] - p1[left]\\n        // p2[right-1] - p2[curr-1] - p1[left]*(right - 1 - curr + 1)\\n        // for all left to current-1\\n        // (p2[right-1] - p2[current-1])*(current - left) - (p1[left] + p1[left+1] + .. p1[current -1])(right - curr)\\n        \\n        while(i <= N) {\\n            \\n            while(! stk.empty() && (i==N || stren[stk.peek().intValue()] >= stren[i])) {\\n                int cur = stk.pop().intValue();\\n                \\n                int left = -1;\\n                \\n                if(! stk.empty()) {\\n                    left = stk.peek().intValue();\\n                }\\n                \\n                int right = i;\\n                \\n                long pr = right > 0 ? p2[right - 1] : 0;\\n                long pl = left > 0 ? p2[left - 1] : 0;\\n                long pc = cur > 0 ? p2[cur - 1] : 0;\\n                \\n                //exluded right and left index\\n                long count1 = cur - 1 - left + 1;\\n                long count2 = right - 1 - cur + 1;\\n                \\n                long pp1 = (pr - pc)%MOD;\\n                long pp2 = (pc - pl)%MOD;\\n                \\n                long res = (stren[cur]) * ((pp1*count1)%MOD - (pp2*count2)%MOD + 2*MOD)%MOD;\\n                \\n                res = (res + MOD)%MOD;\\n                result = (result + res)%MOD;\\n                \\n            }\\n            \\n            stk.push((long)i++);\\n        }\\n        \\n        return (int)result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071671,
                "title": "easy-prefix-sum-next-greater-element-o-n-solution",
                "content": "This is my code, however I can\\'t seem to get correct answer when I use mod in it.\\nCan someone please help where to put the mod in the code?\\nThankyou\\n\\n\\n```\\n\\n\\n\\n#define endl \\'\\\\n\\'\\n#define pb push_back\\n#define mp make_pair\\n#define ll long long \\n#define mod (int)1e9+7\\n\\nvector<int> nextSmallerElement(vector<int> & v ) {\\n\\tint n=v.size();\\n\\tvector<int> next(n);\\n\\tfor(int i=n-1;i>=0;i--) {\\n\\t\\tnext[i]=i+1;\\n\\t\\twhile(next[i]!=n && v[i]<=v[next[i]]) { // stop if element is < curr\\n\\t\\t\\tnext[i]=next[next[i]];\\n\\t\\t}\\n\\t}\\n\\treturn next;\\n\\n}\\nvector<int> prevSmaller(vector<int> & v) {\\n\\tint n=v.size();\\n\\tvector<int> prev(n);\\n\\tfor(int i=0;i<n;i++) {\\n\\t\\tprev[i]=i-1;\\n\\t\\twhile(prev[i]!=-1 && v[i] < v[prev[i]]) { // stop if element is <= curr\\n\\t\\t\\tprev[i]=prev[prev[i]];\\n\\t\\t}\\n\\t}\\n\\treturn prev;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& v) {\\n        int n=v.size();\\n       auto next=nextSmallerElement(v);\\n\\tauto prev=prevSmaller(v);\\n        \\n        // for(auto it: prev) cout<<it<<\" \";\\n        // cout<<endl;\\n        // for(auto it: next) cout<<it<<\" \";\\n        // cout<<endl;\\n        \\n        ll ans=0;\\n        vector<ll> prefixSum;\\n        prefixSum.pb(0);\\n        for(int i=0;i<n;i++) {\\n            prefixSum.pb(v[i]+prefixSum[i]);\\n        }\\n        // cout<<\"prefix sum : \"<<endl;\\n        // for(auto it: prefixSum) cout<<it<<\" \";\\n        // cout<<endl;\\n        \\n        \\n        for(int i=0;i<n;i++) {\\n\\n            int l=prev[i];\\n\\n            int r=next[i];\\n            ll temp=0;\\n            int j=max(0,l+1);\\n            // cout<<\"i : \"<<i<<endl;\\n            while(j<=i) {\\n            int k=r;                \\n            \\twhile(k>=i+1) {\\n                    // cout<<\"Calculating prefix sum contribution of elements from index \"<<j+1<<\" to index \"<<k<<endl;\\n            \\t\\ttemp=temp+ (v[i] * ((prefixSum[k]-prefixSum[j])) );\\n            \\t\\tk--;\\n            \\t}\\n            \\tj++;\\n            }\\n            // cout<<\"Contribution of \"<<i<< \" is : \"<<temp<<endl;\\n            ans=ans+temp;\\n        }\\n        return ans;\\n    }\\n};\\n// j ko +1 karing\\n// k ko -1\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\n\\n\\n#define endl \\'\\\\n\\'\\n#define pb push_back\\n#define mp make_pair\\n#define ll long long \\n#define mod (int)1e9+7\\n\\nvector<int> nextSmallerElement(vector<int> & v ) {\\n\\tint n=v.size();\\n\\tvector<int> next(n);\\n\\tfor(int i=n-1;i>=0;i--) {\\n\\t\\tnext[i]=i+1;\\n\\t\\twhile(next[i]!=n && v[i]<=v[next[i]]) { // stop if element is < curr\\n\\t\\t\\tnext[i]=next[next[i]];\\n\\t\\t}\\n\\t}\\n\\treturn next;\\n\\n}\\nvector<int> prevSmaller(vector<int> & v) {\\n\\tint n=v.size();\\n\\tvector<int> prev(n);\\n\\tfor(int i=0;i<n;i++) {\\n\\t\\tprev[i]=i-1;\\n\\t\\twhile(prev[i]!=-1 && v[i] < v[prev[i]]) { // stop if element is <= curr\\n\\t\\t\\tprev[i]=prev[prev[i]];\\n\\t\\t}\\n\\t}\\n\\treturn prev;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& v) {\\n        int n=v.size();\\n       auto next=nextSmallerElement(v);\\n\\tauto prev=prevSmaller(v);\\n        \\n        // for(auto it: prev) cout<<it<<\" \";\\n        // cout<<endl;\\n        // for(auto it: next) cout<<it<<\" \";\\n        // cout<<endl;\\n        \\n        ll ans=0;\\n        vector<ll> prefixSum;\\n        prefixSum.pb(0);\\n        for(int i=0;i<n;i++) {\\n            prefixSum.pb(v[i]+prefixSum[i]);\\n        }\\n        // cout<<\"prefix sum : \"<<endl;\\n        // for(auto it: prefixSum) cout<<it<<\" \";\\n        // cout<<endl;\\n        \\n        \\n        for(int i=0;i<n;i++) {\\n\\n            int l=prev[i];\\n\\n            int r=next[i];\\n            ll temp=0;\\n            int j=max(0,l+1);\\n            // cout<<\"i : \"<<i<<endl;\\n            while(j<=i) {\\n            int k=r;                \\n            \\twhile(k>=i+1) {\\n                    // cout<<\"Calculating prefix sum contribution of elements from index \"<<j+1<<\" to index \"<<k<<endl;\\n            \\t\\ttemp=temp+ (v[i] * ((prefixSum[k]-prefixSum[j])) );\\n            \\t\\tk--;\\n            \\t}\\n            \\tj++;\\n            }\\n            // cout<<\"Contribution of \"<<i<< \" is : \"<<temp<<endl;\\n            ans=ans+temp;\\n        }\\n        return ans;\\n    }\\n};\\n// j ko +1 karing\\n// k ko -1\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2071186,
                "title": "time-limit-exceeded",
                "content": "hey,i am new here i am trying to solve this question it is passed 68 test but i am getting and error of time limit exceeded is there any way to optimize \\n\\n\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        lis = strength\\n        n = len(lis)\\n        nums = []\\n        l = n\\n        f = 0\\n        s = 0\\n        for i in range(n):\\n            w = n - l + 1\\n            f = w\\n    \\n            for i in range(l):\\n                ls = []\\n                ls.append(lis[i:f])\\n                f += 1\\n                a = min(ls[0])\\n                b = sum(ls[0])\\n                s += a*b\\n            l -= 1\\n        return(s%(10**9+7))",
                "solutionTags": [
                    "Python"
                ],
                "code": "hey,i am new here i am trying to solve this question it is passed 68 test but i am getting and error of time limit exceeded is there any way to optimize \\n\\n\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        lis = strength\\n        n = len(lis)\\n        nums = []\\n        l = n\\n        f = 0\\n        s = 0\\n        for i in range(n):\\n            w = n - l + 1\\n            f = w\\n    \\n            for i in range(l):\\n                ls = []\\n                ls.append(lis[i:f])\\n                f += 1\\n                a = min(ls[0])\\n                b = sum(ls[0])\\n                s += a*b\\n            l -= 1\\n        return(s%(10**9+7))",
                "codeTag": "Java"
            },
            {
                "id": 2068307,
                "title": "python-o-nlogn-presum-of-presum-and-binary-search-easy-understand",
                "content": "For strength array [*a0,a1, ..., a(n-1)*],  we mark its presum as [*0, p0, p1, ..p(n-1)*], let *ai* is the minimal value in the range[*al,ar*], where *l <= i <= r*, so contribution of *ai* to answer is:\\n*ai * (pi - p(l-1)) + (pi - pl) +...+(pi-p(i-1)) + (p(i + 1) -p(l-1)) + (p(i + 1) - pl) +...+(p(i+ 1)-p(i-1)) +...+ (p(i + 1)-p(i-1)) + ... + (p(r + 1) - p(l-1)) + ( p(r + 1) - pl) +...+( p(r + 1)-p(i-1)) = (r - l + 1)  (pi + p(i + 1) +...+p(r + 1) - (i - left + 1) * (pl + p(l + 1) + ...p(i - 1))*. \\nWe can find its another accumate sum, we mark presum of [*0, p0, p1, ..pn-1*] as [*0, 0, acc0,acc1, ..., acc(n-1)*], so last equation tunrns to:\\n*ai  * ((r - i + 1)  (acc(r + 1) - acc(i)) - (i - left + 1)  * (acc[i] - acc[left - 1]))*\\nAfter this, we need to get the range[*al,ar*],  one way is to use monotonic stack; here we deal with it from least value to most value so we can use bianry search and insert to find left and right bound, in the code we use *idxs* to store value index used in order.\\n```\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        n = len(strength) + 1\\n        idxs, ans, MOD = [], 0, 10 ** 9 + 7\\n        presum, accsum = [0] * n, [0] * (n + 1)\\n        for i in range(n - 1):\\n            presum[i + 1] = (presum[i] + strength[i])\\n            accsum[i + 2] = (accsum[i + 1] + presum[i + 1]) % MOD\\n        for v, p in sorted((v, p + 1) for p, v in enumerate(strength)):\\n            pos = bisect(idxs, p)\\n            left = 0 if not idxs or pos == 0 else idxs[pos - 1]\\n            right = n if not idxs or pos == len(idxs) else idxs[pos]\\n            ans = (ans + v * ((p - left) * (accsum[right] - accsum[p]) - (right - p) * (accsum[p] - accsum[left]))) % MOD\\n            idxs[pos:pos] = [p]\\n        return ans\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        n = len(strength) + 1\\n        idxs, ans, MOD = [], 0, 10 ** 9 + 7\\n        presum, accsum = [0] * n, [0] * (n + 1)\\n        for i in range(n - 1):\\n            presum[i + 1] = (presum[i] + strength[i])\\n            accsum[i + 2] = (accsum[i + 1] + presum[i + 1]) % MOD\\n        for v, p in sorted((v, p + 1) for p, v in enumerate(strength)):\\n            pos = bisect(idxs, p)\\n            left = 0 if not idxs or pos == 0 else idxs[pos - 1]\\n            right = n if not idxs or pos == len(idxs) else idxs[pos]\\n            ans = (ans + v * ((p - left) * (accsum[right] - accsum[p]) - (right - p) * (accsum[p] - accsum[left]))) % MOD\\n            idxs[pos:pos] = [p]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067993,
                "title": "no-more-presum-of-presum",
                "content": "I see enough of presum of presum solution. Here I\\'m sharing my solution without presum of presum.\\n\\n# The presum of presum solution is done by:\\n1. for a number nums[i], find the range[l,r] where nums[i] is a minimum;\\n2. You can get all subarrays with nums[i] as a minimum;\\n3. Sum each subarray, and sum all the sums. That\\'s why you need presum of presum.\\n\\n# What if you think the way around?\\n1. for any number nums[i], we do not require it to be a minimum.\\n2. We find all subarrays containing nums[i];\\n3. we sum the minimums of all the subarrays.\\n\\n# Example:\\npower = [2, 3, 2, 1]\\nPower[0,0] = min([2]) * sum([2]) = 4\\nPower[0,1]= min([2, 3]) * sum([2, 3]) = 10\\nPower[0, 2]= min([2, 3, 2]) * sum([2, 3, 2]) = 14\\nPower[0,3] = min([2, 3, 2, 1]) * sum([2, 3, 2, 1]) = 8\\nPower[1,1] = min([3]) * sum([3]) = 9\\nPower[1,2]= min([3, 2]) * sum([3, 2]) = 10\\nPower[1, 3] = min([3, 2, 1])* sum ([3, 2, 1]) = 6\\nPower[2, 2] = min([2]) * sum ([2]) = 4\\nPower[2,3] = min([2, 1]) * sum([2, 1]) = 3\\nPower[3,3] = min([1]) * sum([1]) = 1\\nTotal Power = 69\\nThe contribution of 3 using the first way is: 3 * 3 = 9\\nThe contribution of 3 using my way is: (min([2, 3]) + min([2, 3, 2]) + min([2, 3, 2, 1]) + min([3]) + min([3, 2]) + min([3, 2, 1])) * 3 = 33 This is done by break down the \"sum\"\\nYou can verify the method gives the same final result.\\n\\n# Algorithm\\nCheck this solution https://leetcode.com/problems/sum-of-subarray-minimums/discuss/257811/Python-O(n)-slightly-easier-to-grasp-solution-(explained) To 907. Sum of Subarray Minimums.\\nWe can obtain left[i], which means the sum of minimums(SOM) for all subarrays ending at index i.\\nSimilarly, we can obtain right[i], SOM for all subarrays starting at index i.\\nThe contribution of nums[i] is\\n\\nnums[i] * (SOM of subarrays containing nums[i])  \\n= nums[i]\\\\*(total SOM - SOM of subarrays without nums[i]) \\n= nums[i]\\\\*(total SOM - SOM of subarrays ending before index i - SOM of subarrays starting after index i) \\n\\nObviously, total SOM = sum(left) = sum(right)\\n*SOM of subarrays ending before index i* and *SOM of subarrays starting after index i* is the sum of a range on left and right, which can be obtained easily by preprocess presum of left and right\\n\\n# Code\\n```python []\\nclass Solution:\\n    def totalStrength(self, arr: List[int]) -> int:\\n        N = len(arr)\\n        stack = []\\n        left = [0] * len(arr)\\n        for i in range(len(arr)):\\n            while stack and arr[stack[-1]] > arr[i]:\\n                stack.pop()\\n            left[i] = left[stack[-1]]+(i-stack[-1])*arr[i] if stack else (i+1)*arr[i]\\n            stack.append(i)\\n\\n        stack = []\\n        right = [0] * len(arr)\\n        for i in range(len(arr)-1,-1,-1):\\n            while stack and arr[stack[-1]] > arr[i]:\\n                stack.pop()\\n            right[i] = right[stack[-1]]+(stack[-1]-i)*arr[i] if stack else (N-i)*arr[i]\\n            stack.append(i)\\n\\n        leftAcc = [0] + list(itertools.accumulate(left))\\n        rightAcc = [0] + list(itertools.accumulate(reversed(right)))\\n\\n        total, ans = leftAcc[-1], 0\\n        for i in range(N):\\n            ans += (total - leftAcc[i] - rightAcc[N-(i+1)])*arr[i]\\n        return ans % int(1e9+7)\\n```\\n```cpp []\\nconst int mod=1e9+7, N=1e5+5;\\nclass Solution {\\npublic:\\n    long long left[N], right[N];\\n    long long leftAcc[N], rightAcc[N];\\n    long long stack[N];\\n    int top;\\n    int totalStrength(vector<int>& strength) {\\n        int n=strength.size();\\n        for(int i=0; i<n; i++) {\\n            while(top && strength[stack[top-1]]>strength[i]) {\\n                top--;\\n            }\\n            left[i]=top==0?1LL*(i+1)*strength[i]:1LL*left[stack[top-1]]+(i-stack[top-1])*strength[i];\\n            stack[top++] = i;\\n        }\\n        top = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            while(top && strength[stack[top-1]]>strength[i]) {\\n                top--;\\n            }\\n            right[i]=top==0?1LL*(n-i)*strength[i]:1LL*right[stack[top-1]]+(stack[top-1]-i)*strength[i];\\n            stack[top++] = i;\\n        }\\n        for(int i=0; i<n; i++) {\\n            leftAcc[i+1]=(leftAcc[i]+left[i]) % mod;\\n            rightAcc[i+1]=(rightAcc[i]+right[n-i-1]) % mod;\\n        }\\n        long long total=leftAcc[n], ans=0;\\n        for(int i=0; i<n; i++) {\\n            long long f = (total-leftAcc[i]-rightAcc[n-i-1] + mod) % mod;\\n            ans = (ans+f*strength[i]) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```python []\\nclass Solution:\\n    def totalStrength(self, arr: List[int]) -> int:\\n        N = len(arr)\\n        stack = []\\n        left = [0] * len(arr)\\n        for i in range(len(arr)):\\n            while stack and arr[stack[-1]] > arr[i]:\\n                stack.pop()\\n            left[i] = left[stack[-1]]+(i-stack[-1])*arr[i] if stack else (i+1)*arr[i]\\n            stack.append(i)\\n\\n        stack = []\\n        right = [0] * len(arr)\\n        for i in range(len(arr)-1,-1,-1):\\n            while stack and arr[stack[-1]] > arr[i]:\\n                stack.pop()\\n            right[i] = right[stack[-1]]+(stack[-1]-i)*arr[i] if stack else (N-i)*arr[i]\\n            stack.append(i)\\n\\n        leftAcc = [0] + list(itertools.accumulate(left))\\n        rightAcc = [0] + list(itertools.accumulate(reversed(right)))\\n\\n        total, ans = leftAcc[-1], 0\\n        for i in range(N):\\n            ans += (total - leftAcc[i] - rightAcc[N-(i+1)])*arr[i]\\n        return ans % int(1e9+7)\\n```\n```cpp []\\nconst int mod=1e9+7, N=1e5+5;\\nclass Solution {\\npublic:\\n    long long left[N], right[N];\\n    long long leftAcc[N], rightAcc[N];\\n    long long stack[N];\\n    int top;\\n    int totalStrength(vector<int>& strength) {\\n        int n=strength.size();\\n        for(int i=0; i<n; i++) {\\n            while(top && strength[stack[top-1]]>strength[i]) {\\n                top--;\\n            }\\n            left[i]=top==0?1LL*(i+1)*strength[i]:1LL*left[stack[top-1]]+(i-stack[top-1])*strength[i];\\n            stack[top++] = i;\\n        }\\n        top = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            while(top && strength[stack[top-1]]>strength[i]) {\\n                top--;\\n            }\\n            right[i]=top==0?1LL*(n-i)*strength[i]:1LL*right[stack[top-1]]+(stack[top-1]-i)*strength[i];\\n            stack[top++] = i;\\n        }\\n        for(int i=0; i<n; i++) {\\n            leftAcc[i+1]=(leftAcc[i]+left[i]) % mod;\\n            rightAcc[i+1]=(rightAcc[i]+right[n-i-1]) % mod;\\n        }\\n        long long total=leftAcc[n], ans=0;\\n        for(int i=0; i<n; i++) {\\n            long long f = (total-leftAcc[i]-rightAcc[n-i-1] + mod) % mod;\\n            ans = (ans+f*strength[i]) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064545,
                "title": "java-comments-debug-many-hints-o-n-2-to-o-n-stack-prefix-of-prefix-sum",
                "content": "The initial commented code is what I could come up in the contest.\\nI could find the problem: https://leetcode.com/submissions/detail/704911289/ but couldnt find sum of left and right subarrays in O(n) during contest. However, the video linked is quite useful to understand the last part.\\n\\nFor [1,3,1,2] example,\\nmy prefix is [0,1,4,5,7]\\nand preprefix is [0,1,5,10,17]\\n\\nNow, the monotonic stack will ensure that it will give all indexes [variable j] and their corresponding leftptr[variable k] and rightptr [variable i].\\n\\nHence the count of elements in leftside of j is left = j-k;\\nand count of elements in rightside of j is right = i-j\\n\\nWith that, we can find the terms to be minus and plus from the prefix_of_prefix sum\\n[Refer : https://www.youtube.com/watch?v=HYCMvFxWO7w&t=1660s]\\n![image](https://assets.leetcode.com/users/images/f253cd5f-7704-45ba-b439-ba9103c3c7ac_1653242603.9380913.png)\\n\\nPS : Be careful with MODs -> I try to do at every LONG manipulation step and if there is  subtraction, I just add MOD to avoid numbers being negative. \\n\\nHope below helps!\\n\\n```\\nclass Solution {\\n    public int totalStrength(int[] arr) {\\n        \\n        long MOD = 1000000007;\\n        int n = arr.length;\\n        long[] prefix = new long[n+1];\\n        long[] preprefix = new long[n+1];\\n        \\n        for(int i=1;i<=n;i++) {\\n            prefix[i] = prefix[i-1]+arr[i-1];\\n            preprefix[i] = preprefix[i-1]+prefix[i]; //creating prefix of prefix\\n        }\\n        \\n        long ans=0;\\n        \\n        //BELOW IS O(N^2) - GIVES TLE\\n//         for(int b=1;b<=n;b++) {\\n//             long min=Long.MAX_VALUE;\\n//             for( int l=0;l<n && b+l<=n;l++) {\\n//                 min = Math.min(min, strength[b+l-1]);\\n//                 long sum = prefix[b+l]-prefix[b-1];\\n                \\n//                 ans = (ans + (min*sum)%MOD)%MOD;\\n//                 // System.out.println(\"Begin:\"+(b-1)+ \"End:\" + (b+l-1)+\":\"+ min+\":\" + sum);\\n//             }\\n//         }\\n        \\n        //THIS IS O(N) -> Monotonic stack + prefix sum + prefix_of_prefix sum\\n        // Took hints from https://www.youtube.com/watch?v=HYCMvFxWO7w&t=1660s and https://leetcode.com/submissions/detail/704911289/\\n        Stack<Integer> stack = new Stack<>();\\n        int j, k;\\n         \\n        for (int i = 0; i <= n; i++) {\\n            // System.out.println(\"i is \"+i);\\n            //  System.out.println(\"Stack is \"+stack.toString());\\n            while (!stack.isEmpty() && arr[stack.peek()] > (i == n ? Integer.MIN_VALUE : arr[i])) {\\n                j = stack.pop();\\n                k = stack.isEmpty() ? -1 : stack.peek();\\n                int left = j-k;\\n                int right = i-j;\\n                \\n                // if j is the min index\\n                // preprefix[j] -> preprefix till before it till prevptr\\'s prefix [not including itself]\\n                \\n                long minus = preprefix[j] -  (k==-1? 0: preprefix[k]); // how many ends before i\\n                minus = (minus%MOD+MOD)%MOD;\\n                \\n                // preprefix[i] -> preprefix till nextptr\\'s prefix till before j\\'s prefix [since we want to count from j each time]\\n                long plus = preprefix[i] - preprefix[j]; // how many ends after i\\n                plus = (plus%MOD+MOD)%MOD;\\n                \\n                // min_value -> left_count : right_count -> prevptr : curr : nextptr -> minus: plus\\n                // System.out.println(arr[j] +\":\" +(j-k) +\":\" + (i-j) + \" OK \" + k +\":\" +j+\":\"+i + \" OK \" + minus +\":\" + plus);\\n                \\n                \\n                // SUM OF ALL SUBARRAYS   *   MINIMUM \\n                // Adding MOD as we dont want it to be negative in sum of subarrays\\n                \\n                ans += (((plus*left)%MOD - (minus*right)%MOD + MOD )%MOD) * arr[j] ;\\n                ans %=MOD;\\n            }\\n            stack.push(i);\\n        }\\n        \\n        return (int)(ans%MOD);\\n    }\\n}",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\n    public int totalStrength(int[] arr) {\\n        \\n        long MOD = 1000000007;\\n        int n = arr.length;\\n        long[] prefix = new long[n+1];\\n        long[] preprefix = new long[n+1];\\n        \\n        for(int i=1;i<=n;i++) {\\n            prefix[i] = prefix[i-1]+arr[i-1];\\n            preprefix[i] = preprefix[i-1]+prefix[i]; //creating prefix of prefix\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2063740,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& strength) {\\n        const int mod = 1e9 + 7;\\n        int len = strength.size();\\n        vector<long long> prefix(len);\\n        int i, j;\\n        \\n        prefix[0] = strength[0];\\n        for(i = 1; i < len; i++){\\n            prefix[i] = prefix[i - 1] + strength[i];\\n            prefix[i] %= mod;\\n        }\\n        \\n        for(i = 1; i < len; i++){\\n            prefix[i] = prefix[i - 1] + prefix[i];\\n            prefix[i] %= mod;\\n        }\\n        \\n        vector<pair<int, int>> stack;\\n        vector<int> right(len);\\n        vector<int> left(len);\\n        \\n        for(i = 0; i < len; i++){\\n            while(!stack.empty() && stack.back().first > strength[i]){\\n                right[stack.back().second] = i - stack.back().second - 1;\\n                stack.pop_back();\\n            }\\n            stack.push_back(make_pair(strength[i], i));\\n        }\\n        while(!stack.empty()){\\n            right[stack.back().second] = len - 1 - stack.back().second;\\n            stack.pop_back();\\n        }\\n        \\n        for(i = len - 1; i >= 0; i--){\\n            while(!stack.empty() && stack.back().first >= strength[i]){\\n                left[stack.back().second] = stack.back().second - i - 1;\\n                stack.pop_back();\\n            }\\n            stack.push_back(make_pair(strength[i], i));\\n        }\\n        for(i = stack.size() - 1; i >= 0; i--){\\n            left[stack[i].second] = stack[i].second;\\n        }\\n        \\n        long long ans = 0;\\n        \\n        for(i = 0; i < len; i++){\\n            long long minim = strength[i];\\n            int l = i - left[i];\\n            int r = i + right[i];\\n            long long s = i >= 1 ? prefix[i - 1] : 0;\\n            long long p = (prefix[r] - s) * (i - l + 1);\\n            p %= mod;\\n            long long q;\\n            if(i == 0){\\n                q = 0;\\n            }\\n            else{\\n                if(l >= 2){\\n                    q = prefix[i - 1] - prefix[l - 2];\\n                }\\n                else{\\n                    q = prefix[i - 1];\\n                }\\n            }\\n            q = q * (r - i + 1);\\n            q %= mod;\\n            p = p - q;\\n            if(p < 0){\\n                p += mod;\\n            }\\n            p *= minim;\\n            p %= mod;\\n            ans += p;\\n            ans %= mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& strength) {\\n        const int mod = 1e9 + 7;\\n        int len = strength.size();\\n        vector<long long> prefix(len);\\n        int i, j;\\n        \\n        prefix[0] = strength[0];\\n        for(i = 1; i < len; i++){\\n            prefix[i] = prefix[i - 1] + strength[i];\\n            prefix[i] %= mod;\\n        }\\n        \\n        for(i = 1; i < len; i++){\\n            prefix[i] = prefix[i - 1] + prefix[i];\\n            prefix[i] %= mod;\\n        }\\n        \\n        vector<pair<int, int>> stack;\\n        vector<int> right(len);\\n        vector<int> left(len);\\n        \\n        for(i = 0; i < len; i++){\\n            while(!stack.empty() && stack.back().first > strength[i]){\\n                right[stack.back().second] = i - stack.back().second - 1;\\n                stack.pop_back();\\n            }\\n            stack.push_back(make_pair(strength[i], i));\\n        }\\n        while(!stack.empty()){\\n            right[stack.back().second] = len - 1 - stack.back().second;\\n            stack.pop_back();\\n        }\\n        \\n        for(i = len - 1; i >= 0; i--){\\n            while(!stack.empty() && stack.back().first >= strength[i]){\\n                left[stack.back().second] = stack.back().second - i - 1;\\n                stack.pop_back();\\n            }\\n            stack.push_back(make_pair(strength[i], i));\\n        }\\n        for(i = stack.size() - 1; i >= 0; i--){\\n            left[stack[i].second] = stack[i].second;\\n        }\\n        \\n        long long ans = 0;\\n        \\n        for(i = 0; i < len; i++){\\n            long long minim = strength[i];\\n            int l = i - left[i];\\n            int r = i + right[i];\\n            long long s = i >= 1 ? prefix[i - 1] : 0;\\n            long long p = (prefix[r] - s) * (i - l + 1);\\n            p %= mod;\\n            long long q;\\n            if(i == 0){\\n                q = 0;\\n            }\\n            else{\\n                if(l >= 2){\\n                    q = prefix[i - 1] - prefix[l - 2];\\n                }\\n                else{\\n                    q = prefix[i - 1];\\n                }\\n            }\\n            q = q * (r - i + 1);\\n            q %= mod;\\n            p = p - q;\\n            if(p < 0){\\n                p += mod;\\n            }\\n            p *= minim;\\n            p %= mod;\\n            ans += p;\\n            ans %= mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063581,
                "title": "o-n-solution-with-mono-stack",
                "content": "```\\nclass Solution {\\n    public int totalStrength(int[] arr) {\\n        int n = arr.length;\\n        Stack<Integer> stk = new Stack<>();\\n        int[] next = new int[n];\\n        int[] s = new int[n + 1];\\n        int[] sum = new int[n + 1];\\n        for (int i = 0; i < n; i++) {\\n            next[i] = -1;\\n            s[i + 1] = add(s[i], arr[i]);\\n            sum[i + 1] = add(sum[i], s[i + 1]);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (stk.size() == 0) {\\n                stk.add(i);\\n            } else {\\n                int t = 0; \\n                while (stk.size() > 0 && arr[stk.peek()] > arr[i]) {\\n                    int j = stk.pop(); \\n                    next[j] = i;\\n                }\\n                stk.add(i);\\n            }\\n        }\\n        int[] prev = new int[n];\\n        int res = 0;\\n        int[] t = new int[n];\\n        for (int i = n - 1; i >= 0; i--) {\\n            int nextSmaller = next[i];\\n            int cur;\\n            if (nextSmaller != -1) {\\n                int d = minus(s[nextSmaller], s[i]);\\n                cur = add(prev[nextSmaller], \\n                          mul(d, t[nextSmaller]), \\n                          mul(arr[i], calc(sum, s, nextSmaller - 1, i)));\\n                t[i] = add(t[nextSmaller], mul(arr[i], nextSmaller - i));\\n            }  else {\\n                cur = mul(arr[i], calc(sum, s, n - 1, i));\\n                t[i] = add(0, mul(arr[i], n - i));\\n            }\\n            prev[i] = cur;\\n            res = add(res, cur);\\n        }\\n        return res;\\n    }\\n    \\n    private int calc(int[] sum, int[] s, int a, int b) {\\n        return minus(minus(sum[a + 1], sum[b]), mul(a + 1 - b, s[b]));\\n    }\\n    \\n    private int minus(int a, int b) {\\n        int mod = 1000000007;\\n        return (int) ((a*1L - b*1L + mod)%mod);\\n    }\\n    \\n    private int add(int a, int b, int c) {\\n        int mod = 1000000007;\\n        return (int) ((a*1L + b*1L + c*1L)%mod);\\n    }\\n    \\n    private int add(int a, int b) {\\n        int mod = 1000000007;\\n        return (int) ((a*1L + b*1L)%mod);\\n    }\\n    \\n    private int mul(int a, int b) {\\n        int mod = 1000000007;\\n        return (int) ((a*1L*b)%mod);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalStrength(int[] arr) {\\n        int n = arr.length;\\n        Stack<Integer> stk = new Stack<>();\\n        int[] next = new int[n];\\n        int[] s = new int[n + 1];\\n        int[] sum = new int[n + 1];\\n        for (int i = 0; i < n; i++) {\\n            next[i] = -1;\\n            s[i + 1] = add(s[i], arr[i]);\\n            sum[i + 1] = add(sum[i], s[i + 1]);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (stk.size() == 0) {\\n                stk.add(i);\\n            } else {\\n                int t = 0; \\n                while (stk.size() > 0 && arr[stk.peek()] > arr[i]) {\\n                    int j = stk.pop(); \\n                    next[j] = i;\\n                }\\n                stk.add(i);\\n            }\\n        }\\n        int[] prev = new int[n];\\n        int res = 0;\\n        int[] t = new int[n];\\n        for (int i = n - 1; i >= 0; i--) {\\n            int nextSmaller = next[i];\\n            int cur;\\n            if (nextSmaller != -1) {\\n                int d = minus(s[nextSmaller], s[i]);\\n                cur = add(prev[nextSmaller], \\n                          mul(d, t[nextSmaller]), \\n                          mul(arr[i], calc(sum, s, nextSmaller - 1, i)));\\n                t[i] = add(t[nextSmaller], mul(arr[i], nextSmaller - i));\\n            }  else {\\n                cur = mul(arr[i], calc(sum, s, n - 1, i));\\n                t[i] = add(0, mul(arr[i], n - i));\\n            }\\n            prev[i] = cur;\\n            res = add(res, cur);\\n        }\\n        return res;\\n    }\\n    \\n    private int calc(int[] sum, int[] s, int a, int b) {\\n        return minus(minus(sum[a + 1], sum[b]), mul(a + 1 - b, s[b]));\\n    }\\n    \\n    private int minus(int a, int b) {\\n        int mod = 1000000007;\\n        return (int) ((a*1L - b*1L + mod)%mod);\\n    }\\n    \\n    private int add(int a, int b, int c) {\\n        int mod = 1000000007;\\n        return (int) ((a*1L + b*1L + c*1L)%mod);\\n    }\\n    \\n    private int add(int a, int b) {\\n        int mod = 1000000007;\\n        return (int) ((a*1L + b*1L)%mod);\\n    }\\n    \\n    private int mul(int a, int b) {\\n        int mod = 1000000007;\\n        return (int) ((a*1L*b)%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063217,
                "title": "o-n-c-solution",
                "content": "```\\n#define M 1000000007\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& strength) {\\n        stack<pair<int, int>> st;\\n        ll ans = 0;\\n        vector<ll> psum(strength.size()+2);\\n        for(int i = 0; i < strength.size(); i++)\\n            psum[i+2] = (2*psum[i+1]-psum[i]+strength[i])%M;\\n        st.push({-1, 1});\\n        strength.push_back(0);\\n        for(int i = 0; i < strength.size(); i++) {\\n            while(st.top().first >= strength[i]) {\\n                auto [power, k] = st.top();\\n                st.pop();\\n                auto [_1, j] = st.top();\\n                auto currentSum = (k*(psum[i+1]-psum[j-1])+(i+2)*(psum[j-1]-psum[k-1])+j*(psum[k-1]-psum[i+1]))%M;\\n                ans = (ans + currentSum * power)%M;\\n            }\\n            st.push({strength[i], i+2});\\n        }\\n        return (ans+M)%M;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define M 1000000007\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& strength) {\\n        stack<pair<int, int>> st;\\n        ll ans = 0;\\n        vector<ll> psum(strength.size()+2);\\n        for(int i = 0; i < strength.size(); i++)\\n            psum[i+2] = (2*psum[i+1]-psum[i]+strength[i])%M;\\n        st.push({-1, 1});\\n        strength.push_back(0);\\n        for(int i = 0; i < strength.size(); i++) {\\n            while(st.top().first >= strength[i]) {\\n                auto [power, k] = st.top();\\n                st.pop();\\n                auto [_1, j] = st.top();\\n                auto currentSum = (k*(psum[i+1]-psum[j-1])+(i+2)*(psum[j-1]-psum[k-1])+j*(psum[k-1]-psum[i+1]))%M;\\n                ans = (ans + currentSum * power)%M;\\n            }\\n            st.push({strength[i], i+2});\\n        }\\n        return (ans+M)%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062973,
                "title": "c-o-n-stack-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& nums) {\\n        long long re = 0, mod = 1e9+7;\\n        int n = nums.size();\\n        stack<int> st;\\n        vector<long> left(n,0),right(n,0),pl(n,0),pr(n,0),suml(n,0),sumr(n,0);\\n        map<int,int> mp; \\n        mp[nums[0]] = 0; \\n        st.push(0); left[0] = 0;\\n        suml[0]=pl[0] = nums[0];\\n        for(int i = 1; i<n; ++i){\\n            pl[i] = (pl[i-1]+nums[i])%mod;\\n            suml[i] = (suml[i-1]+pl[i])%mod;\\n            while(!st.empty() && nums[st.top()]>=nums[i]) {\\n                if(nums[st.top()]==nums[i] && mp.find(nums[i])!=mp.end()) break;\\n                st.pop();\\n            }\\n            left[i] = 0;\\n            if(st.size()) left[i] = st.top()+1;\\n            st.push(i);\\n            if(mp.find(nums[i])==mp.end()) mp[nums[i]] = i;\\n        }\\n        \\n        while(!st.empty()) st.pop();\\n        right[n-1] = n-1;\\n        st.push(n-1);\\n        sumr[n-1]=pr[n-1] = nums[n-1];\\n        for(int i = n-2;i>=0;--i){\\n            pr[i] = (pr[i+1]+nums[i])%mod;\\n            sumr[i] = (sumr[i+1]+pr[i])%mod;\\n            while(!st.empty() && nums[st.top()]>=nums[i]){ \\n                st.pop();\\n            }\\n            right[i] = n-1;\\n            if(st.size()) right[i] = st.top()-1;\\n            st.push(i);\\n        }\\n        for(int i = 0; i<nums.size();++i){\\n            long long temp = 0;\\n            long l = i-left[i]+1, r = right[i]-i+1;\\n\\t\\t\\t\\n            long sumright = suml[right[i]];\\n            if(i-1>=0) sumright = (sumright -suml[i-1] - r*pl[i-1] + mod)%mod;\\n            temp = (temp+l*sumright +mod )%mod;\\n\\t\\t\\t\\n            long sumleft = sumr[left[i]];\\n            if(i+1<n) sumleft = (sumleft - sumr[i+1] - pr[i+1]*l + mod)%mod;\\n            sumleft = (sumleft - l*nums[i] +mod)%mod;\\n            temp = (temp+ r*sumleft)%mod;\\n\\t\\t\\t\\n            re = (re + nums[i]*temp)%mod;\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalStrength(vector<int>& nums) {\\n        long long re = 0, mod = 1e9+7;\\n        int n = nums.size();\\n        stack<int> st;\\n        vector<long> left(n,0),right(n,0),pl(n,0),pr(n,0),suml(n,0),sumr(n,0);\\n        map<int,int> mp; \\n        mp[nums[0]] = 0; \\n        st.push(0); left[0] = 0;\\n        suml[0]=pl[0] = nums[0];\\n        for(int i = 1; i<n; ++i){\\n            pl[i] = (pl[i-1]+nums[i])%mod;\\n            suml[i] = (suml[i-1]+pl[i])%mod;\\n            while(!st.empty() && nums[st.top()]>=nums[i]) {\\n                if(nums[st.top()]==nums[i] && mp.find(nums[i])!=mp.end()) break;\\n                st.pop();\\n            }\\n            left[i] = 0;\\n            if(st.size()) left[i] = st.top()+1;\\n            st.push(i);\\n            if(mp.find(nums[i])==mp.end()) mp[nums[i]] = i;\\n        }\\n        \\n        while(!st.empty()) st.pop();\\n        right[n-1] = n-1;\\n        st.push(n-1);\\n        sumr[n-1]=pr[n-1] = nums[n-1];\\n        for(int i = n-2;i>=0;--i){\\n            pr[i] = (pr[i+1]+nums[i])%mod;\\n            sumr[i] = (sumr[i+1]+pr[i])%mod;\\n            while(!st.empty() && nums[st.top()]>=nums[i]){ \\n                st.pop();\\n            }\\n            right[i] = n-1;\\n            if(st.size()) right[i] = st.top()-1;\\n            st.push(i);\\n        }\\n        for(int i = 0; i<nums.size();++i){\\n            long long temp = 0;\\n            long l = i-left[i]+1, r = right[i]-i+1;\\n\\t\\t\\t\\n            long sumright = suml[right[i]];\\n            if(i-1>=0) sumright = (sumright -suml[i-1] - r*pl[i-1] + mod)%mod;\\n            temp = (temp+l*sumright +mod )%mod;\\n\\t\\t\\t\\n            long sumleft = sumr[left[i]];\\n            if(i+1<n) sumleft = (sumleft - sumr[i+1] - pr[i+1]*l + mod)%mod;\\n            sumleft = (sumleft - l*nums[i] +mod)%mod;\\n            temp = (temp+ r*sumleft)%mod;\\n\\t\\t\\t\\n            re = (re + nums[i]*temp)%mod;\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062957,
                "title": "c-monotonic-stack-solution-with-very-detailed-math-formulas-to-show-thinking-process",
                "content": "\\nThe problem is hard, but it\\'s a good problem. \\nYou have to write down on paper to solve the problem, or you may have really really great memory LOL \\nAfter the ends of codes, there\\'re two images to show thinking process. The pictures might blurry, you can download pdf [here](https://github.com/HanzhouTang/HanzhouTang.github.io/blob/master/lc_2281_solution.pdf)\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7; \\n    int totalStrength(vector<int>& a) {\\n        vector<long long> ss(a.begin(),a.end());\\n        vector<long long> sums(ss.size());\\n        sums[0] = ss[0];\\n        for(int i = 1;i<ss.size();i++) {\\n            sums[i] = sums[i-1] + ss[i];\\n        }\\n        auto sum = [&](int l, int r) {\\n            long long ret = 0; \\n            ret = sums[r] - sums[l] + ss[l];\\n            return ret % mod; \\n        };\\n\\n        vector<long long> fs(a.size() + 1);\\n        long long x = 0; \\n        for(int i = a.size()-1;i>=0;i--) {\\n            x += a[i];\\n            fs[i] = fs[i+1] + x; \\n        }\\n        auto f = [&](int l, int r) {\\n            if(r == ss.size() - 1) {\\n                return fs[l] % mod;\\n            }\\n            long long ret = fs[l] - fs[r+1];\\n            ret -= ((r - l + 1) * sum(r+1, ss.size()-1)) % mod; \\n            ret += mod; \\n            ret %= mod; \\n            return ret; \\n        };\\n        stack<int> s; \\n        s.push(-1);\\n        long long v = 0; \\n        long long tmp = 0; \\n        long long ret = 0; \\n        for(int i = 0;i<ss.size();i++) {\\n            while(s.top() != -1 && ss[s.top()] >= ss[i]) {\\n                int t = s.top(); \\n                s.pop(); \\n                long long delta = f(s.top()+1,t);\\n                tmp -= (delta * ss[t]) % mod; \\n                tmp += mod; \\n                v -= ((t - s.top()) * ss[t]) % mod; \\n                v += mod; \\n                v %= mod; \\n                tmp -= (v * sum(s.top()+1,t)) % mod;\\n                tmp += mod; \\n                tmp %= mod; \\n            }\\n            long long delta = f(s.top()+1,i);\\n            tmp = tmp + v * sum(s.top()+1,i) + delta * ss[i];\\n            v += (ss[i] * (i - s.top())) % mod;\\n            v %= mod; \\n            s.push(i);\\n            tmp %= mod; \\n            ret += tmp; \\n            ret %= mod; \\n        }\\n        return ret % mod; \\n        \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/1e6d4212-2336-415e-8f70-02e743dd3b0c_1653247035.9942179.jpeg)\\n![image](https://assets.leetcode.com/users/images/902d32cf-d8bc-498f-aa53-a0840d739349_1653247035.9394026.jpeg)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7; \\n    int totalStrength(vector<int>& a) {\\n        vector<long long> ss(a.begin(),a.end());\\n        vector<long long> sums(ss.size());\\n        sums[0] = ss[0];\\n        for(int i = 1;i<ss.size();i++) {\\n            sums[i] = sums[i-1] + ss[i];\\n        }\\n        auto sum = [&](int l, int r) {\\n            long long ret = 0; \\n            ret = sums[r] - sums[l] + ss[l];\\n            return ret % mod; \\n        };\\n\\n        vector<long long> fs(a.size() + 1);\\n        long long x = 0; \\n        for(int i = a.size()-1;i>=0;i--) {\\n            x += a[i];\\n            fs[i] = fs[i+1] + x; \\n        }\\n        auto f = [&](int l, int r) {\\n            if(r == ss.size() - 1) {\\n                return fs[l] % mod;\\n            }\\n            long long ret = fs[l] - fs[r+1];\\n            ret -= ((r - l + 1) * sum(r+1, ss.size()-1)) % mod; \\n            ret += mod; \\n            ret %= mod; \\n            return ret; \\n        };\\n        stack<int> s; \\n        s.push(-1);\\n        long long v = 0; \\n        long long tmp = 0; \\n        long long ret = 0; \\n        for(int i = 0;i<ss.size();i++) {\\n            while(s.top() != -1 && ss[s.top()] >= ss[i]) {\\n                int t = s.top(); \\n                s.pop(); \\n                long long delta = f(s.top()+1,t);\\n                tmp -= (delta * ss[t]) % mod; \\n                tmp += mod; \\n                v -= ((t - s.top()) * ss[t]) % mod; \\n                v += mod; \\n                v %= mod; \\n                tmp -= (v * sum(s.top()+1,t)) % mod;\\n                tmp += mod; \\n                tmp %= mod; \\n            }\\n            long long delta = f(s.top()+1,i);\\n            tmp = tmp + v * sum(s.top()+1,i) + delta * ss[i];\\n            v += (ss[i] * (i - s.top())) % mod;\\n            v %= mod; \\n            s.push(i);\\n            tmp %= mod; \\n            ret += tmp; \\n            ret %= mod; \\n        }\\n        return ret % mod; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062716,
                "title": "python-solution-o-n",
                "content": "```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        KMAX = 10 ** 9 + 7\\n        res, N = 0, len(strength)\\n        presum, total, tt, pl2r = [], 0, 0, []\\n        for i, v in enumerate(strength):\\n            total += v\\n            presum.append(total)\\n            tt += total\\n            pl2r.append(tt)\\n        \\n        pr2l, total, tt = [], 0, 0\\n        for i in range(N - 1, -1, -1):\\n            total += strength[i]\\n            tt += total\\n            pr2l.append(tt)\\n        pr2l.reverse()\\n            \\n        def complexsum(l, m, r):\\n\\t\\t\\t# use triangle to find the subarray sum between l and r (inclusive).\\n            res = (m - l + 1) * (r - m + 1) * strength[m]\\n            res += (m - l + 1) * ((total - presum[m]) * (r - m) - (pr2l[m + 2] if m < N - 2 else 0) + (pr2l[r+2] if r < N - 2 else 0))\\n            res += (r - m + 1) * ((presum[m-1] if m > 0 else 0) * (m - l) - (pl2r[m-2] if m > 1 else 0) + (pl2r[l-2] if l > 1 else 0))\\n            return res % KMAX\\n    \\n\\t\\t# this is the same as in 907.\\n        stk = []\\n        for i in range(N):\\n            while stk and strength[stk[-1]] > strength[i]:\\n                idx = stk.pop()\\n                res += strength[idx] * complexsum((stk[-1] + 1) if stk else 0, idx, i - 1)\\n                res %= KMAX\\n            stk.append(i)\\n        while stk:\\n            idx = stk.pop()\\n            res += strength[idx] * complexsum((stk[-1] + 1) if stk else 0, idx, N - 1)\\n            res %= KMAX\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        KMAX = 10 ** 9 + 7\\n        res, N = 0, len(strength)\\n        presum, total, tt, pl2r = [], 0, 0, []\\n        for i, v in enumerate(strength):\\n            total += v\\n            presum.append(total)\\n            tt += total\\n            pl2r.append(tt)\\n        \\n        pr2l, total, tt = [], 0, 0\\n        for i in range(N - 1, -1, -1):\\n            total += strength[i]\\n            tt += total\\n            pr2l.append(tt)\\n        pr2l.reverse()\\n            \\n        def complexsum(l, m, r):\\n\\t\\t\\t# use triangle to find the subarray sum between l and r (inclusive).\\n            res = (m - l + 1) * (r - m + 1) * strength[m]\\n            res += (m - l + 1) * ((total - presum[m]) * (r - m) - (pr2l[m + 2] if m < N - 2 else 0) + (pr2l[r+2] if r < N - 2 else 0))\\n            res += (r - m + 1) * ((presum[m-1] if m > 0 else 0) * (m - l) - (pl2r[m-2] if m > 1 else 0) + (pl2r[l-2] if l > 1 else 0))\\n            return res % KMAX\\n    \\n\\t\\t# this is the same as in 907.\\n        stk = []\\n        for i in range(N):\\n            while stk and strength[stk[-1]] > strength[i]:\\n                idx = stk.pop()\\n                res += strength[idx] * complexsum((stk[-1] + 1) if stk else 0, idx, i - 1)\\n                res %= KMAX\\n            stk.append(i)\\n        while stk:\\n            idx = stk.pop()\\n            res += strength[idx] * complexsum((stk[-1] + 1) if stk else 0, idx, N - 1)\\n            res %= KMAX\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062640,
                "title": "my-code-runs-correctly-for-small-cases-but-for-a-large-test-case-there-is-overflow-error",
                "content": "int totalStrength(vector<int>& strength) {\\n         unsigned long long int total=0;\\n        for(long long int j=strength.size()-1;j>=0;j--)\\n        {\\n             unsigned long long int min=INT_MAX;\\n            total=total+(strength[j]*strength[j]);\\n            long long int sum=strength[j];\\n            if(min>strength[j])\\n            {\\n                min=strength[j];\\n            }\\n           for(int i=j-1;i>=0;i--)\\n           {\\n               sum=sum+strength[i];\\n               if(min>strength[i])\\n               {\\n                   min=strength[i];\\n               }\\n               total=total+sum*min;\\n           }\\n}\\n        return total%1000000007;\\n    }",
                "solutionTags": [],
                "code": "int totalStrength(vector<int>& strength) {\\n         unsigned long long int total=0;\\n        for(long long int j=strength.size()-1;j>=0;j--)\\n        {\\n             unsigned long long int min=INT_MAX;\\n            total=total+(strength[j]*strength[j]);\\n            long long int sum=strength[j];\\n            if(min>strength[j])\\n            {\\n                min=strength[j];\\n            }\\n           for(int i=j-1;i>=0;i--)\\n           {\\n               sum=sum+strength[i];\\n               if(min>strength[i])\\n               {\\n                   min=strength[i];\\n               }\\n               total=total+sum*min;\\n           }\\n}\\n        return total%1000000007;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2062574,
                "title": "simple-python-solution-time-limit-exceeded",
                "content": "```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        s = []\\n        mod = 10 ** 9 + 7\\n        length = len(strength) \\n        \\n        for j in range(1, length+1):\\n            for i in range (length):\\n                if i+j <= length:\\n                    min_num = min(strength[i:i+j])\\n                    sum_num = sum(strength[i:j+i])\\n                    s.append(min_num * sum_num)\\n                else:\\n                    continue\\n\\n        return (sum(s) % mod)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        s = []\\n        mod = 10 ** 9 + 7\\n        length = len(strength) \\n        \\n        for j in range(1, length+1):\\n            for i in range (length):\\n                if i+j <= length:\\n                    min_num = min(strength[i:i+j])\\n                    sum_num = sum(strength[i:j+i])\\n                    s.append(min_num * sum_num)\\n                else:\\n                    continue\\n\\n        return (sum(s) % mod)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2062519,
                "title": "can-someone-please-help",
                "content": "**Hii, I have been trying to solve this problem without using extra memory and have come up with a solution. The following code passed most of the test cases and is working fine. However, it gives a Runtime Error when the input is comparable to 10e9, as it fails to handle the bigger numbers. Can someone please help ????? If you can help me with an idea to get past this, it would be of great help!!\\nHere\\'s the code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\nint totalStrength(vector& strength)\\n{\\nunsigned long long int MOD = 1000000007;\\nunsigned long long int a = strength[0], b;\\na = (a*a)%MOD;\\n\\n    for(int i=1;i<strength.size();i++)\\n    {\\n        int total = 0,sum = 0, mini = INT_MAX;\\n        for(int k = i;k>=0;k--)\\n        {\\n            sum = (sum + strength[k])%MOD;\\n            mini = min(mini,strength[k]);\\n            total = (total + (mini * sum))%MOD;\\n        }   \\n        b = (a + total)%(MOD);\\n        a = b;\\n    }\\n    return a;\\n}\\n};\\n```\\n\\n***Please help!!!!***",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\nint totalStrength(vector& strength)\\n{\\nunsigned long long int MOD = 1000000007;\\nunsigned long long int a = strength[0], b;\\na = (a*a)%MOD;\\n\\n    for(int i=1;i<strength.size();i++)\\n    {\\n        int total = 0,sum = 0, mini = INT_MAX;\\n        for(int k = i;k>=0;k--)\\n        {\\n            sum = (sum + strength[k])%MOD;\\n            mini = min(mini,strength[k]);\\n            total = (total + (mini * sum))%MOD;\\n        }   \\n        b = (a + total)%(MOD);\\n        a = b;\\n    }\\n    return a;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062358,
                "title": "c-twice-prefix-sum-and-monotonic-stack",
                "content": "```\\nclass Solution {\\n    using integer = long long;\\n    static constexpr integer kMod = 1E9 + 7;\\npublic:\\n    int totalStrength(vector<int>& vals) {\\n        vals.push_back(0);\\n        std::vector<integer> prefix_sum(vals.size() + 1, 0);\\n        for (int i = 0; i < vals.size(); ++i) {\\n            prefix_sum[i + 1] = (prefix_sum[i] + vals[i]) % kMod;\\n        }\\n\\n        std::vector<integer> double_prefix_sum(prefix_sum.size() + 1, 0);\\n        for (int i = 0; i < prefix_sum.size(); ++i) {\\n            double_prefix_sum[i + 1] = (prefix_sum[i] + double_prefix_sum[i]) % kMod;\\n        }        \\n\\n        integer total = 0;\\n        const auto increment_total = [&total](const integer val) {\\n            total = (total + val % kMod) % kMod;\\n        };\\n        \\n        std::deque<int> inds_ord;\\n        for (int i = 0; i < vals.size(); ++i) {\\n            const int curr = vals[i];\\n            while (!inds_ord.empty()) {\\n                const int mid = inds_ord.back();\\n                if (vals[mid] < curr) {\\n                    break;\\n                }\\n                inds_ord.pop_back();\\n                const int lhs = inds_ord.empty() ? 0 : (inds_ord.back() + 1);\\n                const int rhs = i - 1;\\n                const integer lhs_cnts = mid - lhs + 1;\\n                const integer rhs_cnts = rhs - mid + 1;\\n                const integer minimal = vals[mid];\\n                increment_total(((minimal * minimal) % kMod) * ((lhs_cnts * rhs_cnts) % kMod));\\n\\n                {\\n                    const auto window_sum = \\n                        ((prefix_sum[mid] * (lhs_cnts - 1)) % kMod + kMod\\n                        - ((double_prefix_sum[mid] - double_prefix_sum[lhs]) % kMod)) % kMod;\\n                    increment_total(((window_sum * minimal) % kMod) * rhs_cnts);\\n                }\\n    \\n                {\\n                    const auto window_sum = \\n                        ((double_prefix_sum[rhs + 2] - double_prefix_sum[mid + 2]) % kMod + kMod\\n                        - ((prefix_sum[mid + 1] * (rhs_cnts - 1)) % kMod)) % kMod;\\n                    increment_total(((window_sum * minimal) % kMod) * lhs_cnts);\\n                }\\n            }\\n            inds_ord.push_back(i);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    using integer = long long;\\n    static constexpr integer kMod = 1E9 + 7;\\npublic:\\n    int totalStrength(vector<int>& vals) {\\n        vals.push_back(0);\\n        std::vector<integer> prefix_sum(vals.size() + 1, 0);\\n        for (int i = 0; i < vals.size(); ++i) {\\n            prefix_sum[i + 1] = (prefix_sum[i] + vals[i]) % kMod;\\n        }\\n\\n        std::vector<integer> double_prefix_sum(prefix_sum.size() + 1, 0);\\n        for (int i = 0; i < prefix_sum.size(); ++i) {\\n            double_prefix_sum[i + 1] = (prefix_sum[i] + double_prefix_sum[i]) % kMod;\\n        }        \\n\\n        integer total = 0;\\n        const auto increment_total = [&total](const integer val) {\\n            total = (total + val % kMod) % kMod;\\n        };\\n        \\n        std::deque<int> inds_ord;\\n        for (int i = 0; i < vals.size(); ++i) {\\n            const int curr = vals[i];\\n            while (!inds_ord.empty()) {\\n                const int mid = inds_ord.back();\\n                if (vals[mid] < curr) {\\n                    break;\\n                }\\n                inds_ord.pop_back();\\n                const int lhs = inds_ord.empty() ? 0 : (inds_ord.back() + 1);\\n                const int rhs = i - 1;\\n                const integer lhs_cnts = mid - lhs + 1;\\n                const integer rhs_cnts = rhs - mid + 1;\\n                const integer minimal = vals[mid];\\n                increment_total(((minimal * minimal) % kMod) * ((lhs_cnts * rhs_cnts) % kMod));\\n\\n                {\\n                    const auto window_sum = \\n                        ((prefix_sum[mid] * (lhs_cnts - 1)) % kMod + kMod\\n                        - ((double_prefix_sum[mid] - double_prefix_sum[lhs]) % kMod)) % kMod;\\n                    increment_total(((window_sum * minimal) % kMod) * rhs_cnts);\\n                }\\n    \\n                {\\n                    const auto window_sum = \\n                        ((double_prefix_sum[rhs + 2] - double_prefix_sum[mid + 2]) % kMod + kMod\\n                        - ((prefix_sum[mid + 1] * (rhs_cnts - 1)) % kMod)) % kMod;\\n                    increment_total(((window_sum * minimal) % kMod) * lhs_cnts);\\n                }\\n            }\\n            inds_ord.push_back(i);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062156,
                "title": "python3-fix-weakest-strength-and-find-corresponding-substrings",
                "content": "Key steps:\\n\\n1. Iterate through the strength list and take every strength value as the current weakest one, then find all the substrings taking this current value as its weakest strength. If there are multiple weakest strength in a substring, we always take the left-most one. With this rule, we can find the left and right index bound of such substrings.\\n2. Calculate the sum of substrings within the left and right bounds and ending at / starting from the current strength (but not inclusive) respectively, named as as **sum_l** and **sum_r**. Accelerate the calculation by a trick of computing the \"**sum of sums**\" in advance, please read the code on the bottom for the detail(calculating sum2_list).\\n3. Assume **i**, **s** are the current index and strength while lb, rb are the index of current left / right bound (left close right open), **nl**, **nr** = i - lb, rb - 1 - i are the number of strength values within the bounds and on the left / right of the current strength s at index i.\\n4. Finally we have **inc** = (sum_l * (nr + 1) + sum_r * (nl + 1) + s * (nl + 1) * (nr + 1)) * s, where inc is the total strength of all substrings taking the current strength as the weakest one.\\n5. Sum the inc value of all elements in the strength list and mod it by 10 ** 9 + 7, then we get the answer.\\n\\nThe overall time complexity is **O(N)**.\\n\\nHere is the code:\\n```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        MOD = 10 ** 9 + 7\\n        N = len(strength)\\n        bounds = [[0, N] for _ in range(N)]\\n        \\n        # cal bounds\\n        # (ind, strength)\\n        stack = []\\n        for i, s in enumerate(strength):\\n            while stack and stack[-1][1] > s:\\n                bounds[stack[-1][0]][1] = i\\n                stack.pop()\\n            stack.append((i, s))\\n        \\n        while stack:\\n            bounds[stack[-1][0]][1] = N\\n            stack.pop()\\n            \\n        for i in range(N-1, -1, -1):\\n            s = strength[i]\\n            while stack and stack[-1][1] >= s:\\n                bounds[stack[-1][0]][0] = i + 1\\n                stack.pop()\\n            stack.append((i, s))\\n        \\n        while stack:\\n            bounds[stack[-1][0]][0] = 0\\n            stack.pop()\\n        \\n        # cal sum_list\\n        sum_list = [0]\\n        for s in strength:\\n            sum_list.append(sum_list[-1] + s)\\n            \\n        sum2_list = [0]\\n        for s in sum_list:\\n            sum2_list.append(sum2_list[-1] + s)\\n        \\n        # cal ans\\n        ans = 0\\n        for i, s in enumerate(strength):\\n            lb, rb = bounds[i]\\n            assert lb <= i < rb\\n            nl, nr = i - lb, rb - 1 - i\\n            \\n            sum_l = sum_list[i] * nl - (sum2_list[i] - sum2_list[i-nl])\\n\\t\\t\\t# sum_l = 0\\n            # for j in range(i-nl, i):\\n            #    sum_l += sum_list[i] - sum_list[j]\\n            \\n            sum_r = (sum2_list[i+nr+2] - sum2_list[i+2]) - sum_list[i+1] * nr\\n\\t\\t\\t# sum_r = 0\\n            # for j in range(i+2, i+nr+2):\\n            #     sum_r += sum_list[j] - sum_list[i+1]\\n            \\n            inc = (sum_l * (nr + 1) + sum_r * (nl + 1) + s * (nl + 1) * (nr + 1)) * s\\n            inc %= MOD\\n            \\n            ans = (ans + inc) % MOD\\n        return ans\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalStrength(self, strength: List[int]) -> int:\\n        MOD = 10 ** 9 + 7\\n        N = len(strength)\\n        bounds = [[0, N] for _ in range(N)]\\n        \\n        # cal bounds\\n        # (ind, strength)\\n        stack = []\\n        for i, s in enumerate(strength):\\n            while stack and stack[-1][1] > s:\\n                bounds[stack[-1][0]][1] = i\\n                stack.pop()\\n            stack.append((i, s))\\n        \\n        while stack:\\n            bounds[stack[-1][0]][1] = N\\n            stack.pop()\\n            \\n        for i in range(N-1, -1, -1):\\n            s = strength[i]\\n            while stack and stack[-1][1] >= s:\\n                bounds[stack[-1][0]][0] = i + 1\\n                stack.pop()\\n            stack.append((i, s))\\n        \\n        while stack:\\n            bounds[stack[-1][0]][0] = 0\\n            stack.pop()\\n        \\n        # cal sum_list\\n        sum_list = [0]\\n        for s in strength:\\n            sum_list.append(sum_list[-1] + s)\\n            \\n        sum2_list = [0]\\n        for s in sum_list:\\n            sum2_list.append(sum2_list[-1] + s)\\n        \\n        # cal ans\\n        ans = 0\\n        for i, s in enumerate(strength):\\n            lb, rb = bounds[i]\\n            assert lb <= i < rb\\n            nl, nr = i - lb, rb - 1 - i\\n            \\n            sum_l = sum_list[i] * nl - (sum2_list[i] - sum2_list[i-nl])\\n\\t\\t\\t# sum_l = 0\\n            # for j in range(i-nl, i):\\n            #    sum_l += sum_list[i] - sum_list[j]\\n            \\n            sum_r = (sum2_list[i+nr+2] - sum2_list[i+2]) - sum_list[i+1] * nr\\n\\t\\t\\t# sum_r = 0\\n            # for j in range(i+2, i+nr+2):\\n            #     sum_r += sum_list[j] - sum_list[i+1]\\n            \\n            inc = (sum_l * (nr + 1) + sum_r * (nl + 1) + s * (nl + 1) * (nr + 1)) * s\\n            inc %= MOD\\n            \\n            ans = (ans + inc) % MOD\\n        return ans\\n        \\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566059,
                "content": [
                    {
                        "username": "DugMJD",
                        "content": "![image](https://assets.leetcode.com/users/images/94ac9010-57fc-44e5-93b3-e3ceda88a3cb_1653193278.7448575.jpeg)\\n\\n1. https://leetcode.com/discuss/interview-question/1729637/amazon-new-grad-role-2022/\\n2. https://leetcode.com/discuss/interview-question/1736639/Solution-to-Amazon-OA-2022-problem-Sum-of-Scores-of-Subarray"
                    },
                    {
                        "username": "jinyang_deng",
                        "content": "[Original Post](https://leetcode.com/problems/sum-of-total-strength-of-wizards/discuss/2061985/Python-Solution-O(n))\\n\\nThe monotonic stack is self-explanatory. Just explaining \"(racc * ln - lacc * rn)\" in greater detail:\\n\\nSay our input is [5,3,1,2]\\n\\nUsing monotonic stack, Left is [-1, -1, -1, 2], Right is [1, 2, 4, 4].\\n\\nNow look at the 1 (at input array, index 2), it is the minimum for the [1], [3, 1], [5, 3, 1], [1, 2], [3, 1, 2], [5, 3, 1, 2]. So its \\u201Ccontribution\\u201D to the final result will be as follows:\\n1 * (sum([1]) + sum([3,1]) + sum([5,3,1]) + sum([1,2]) + sum([3,1,2]) + sum([5,3,1,2]))\\n\\nSo how do we find this \\u201Csum of sums\\u201D, given that we know the left most element that < 1 is at index -1 (means non-existent), and the rightmost element that is \\u2264 1 is at index 4 (means non-existent)?\\n\\nLee\\u2019s Solution: prefix of prefix sums, which is the \\u201Cacc\\u201D variable in his code.\\nFor our example, \\u201Cacc\\u201D is [0, 5, 13, 22, 33]. Let\\u2019s see which each element really means:\\n5 = (5)\\n13 = (5) + (5+3)\\n22 = (5) + (5+3) + (5+3+1)\\n33 = (5) + (5+3) + (5+3+1) + (5+3+1+2)\\n\\nSo how do we tie these parts together?\\nNote that in our example, there is a 2 larger numbers to 1\\u2019s left, and 1 larger number to 1\\u2019s right. This can be generalized into a pattern: if there are x larger numbers to the left to 1, and y larger numbers to its right: when we fix x, there can be y + 1 combinations on the right, or when we fix y, there can be x + 1 combinations on the left.\\n\\nKey: The way I understand it is that we are trying to build a \\u201Ctemplate\\u201D first, then cancel out some of numbers.\\n\\nFirst we do 33 \\u2013 13. Why? Look at the underlying.\\n33 \\u2013 13 = [(5) + (5+3) + (5+3+1) + (5+3+1+2)] \\u2013 [(5) + (5+3)] = [(5+3+1) + (5+3+1+2)]\\nWe are looking at 1 right now, so we don\\u2019t want to consider any subarray that doesn\\u2019t contain 1. Note this 20 is sum of 2 subarray sums.\\n\\nNext, we use 20 * 3. Why? Because we are trying to create a \\u201Ctemplate\\u201D here. Notice how because of the generalized pattern above, we will have 6 combinations (we can fix x to be 0 / 1 / 2, and y can be 0 / 1. For example, when x=0 and y=0, our combination is [1], or when x=2, y=0, our combination is [5,3,1]). Since 20 is sum of 2 subarray sums, and we want 6 combinations, we duplicate 20 3 times. So we now have:\\n[(5+3+1) + (5+3+1+2)]\\n[(5+3+1) + (5+3+1+2)]\\n[(5+3+1) + (5+3+1+2)]\\n\\nNext, we do 13 \\u2013 0. Look at the underlying.\\n13 \\u2013 0 = (5) + (5+3)\\n\\nThen 13 * 2. Now you might think why 2 not 3 (because 13 is sum of 2 subarrays), right? Proceed and I will explain it later:\\n\\nFinally, 20 * 3 - 13 * 2. Visually, this can be understood as follows:\\n[(<s>**5+3**</s>+1) + (<s>**5+3**</s>+1+2)]\\n[(<s>**5**</s>+3+1) + (<s>**5**</s>+3+1+2)]\\n[(5+3+1) + (5+3+1+2)].\\nNote that while the same cancellation strategy is applied horizontally, each 13 is the group of subarrays used for cancellation vertically. So how many 13 will we use? Depends on how many columns we have, which in turn 1 + number of bigger numbers to its right.\\n\\nThen you might ask, if we do \\u201Cracc * ln - lacc * rn\\u201D, does that mean \\u201Cln\\u201D always has to be \\u2265 \\u201Crn\\u201D? No, repeat the above for [5,1,3,2], and we can get the following cancellation outcome.\\n[(<s>**5**</s>+1) + (<s>**5**</s>+1+3) + (<s>**5**</s>+1+3+2)]\\n[(5+1) + (5+1+3) + (5+1+3+2)]\\n"
                    },
                    {
                        "username": "aalmos",
                        "content": "Am I the only one who thinks this problem is ridiculously hard? How the hell I\\'m supposed to figure out during a live interview session that the sum of all subarrays between `i` and `j` can be derived from a dual rolling sum?"
                    },
                    {
                        "username": "who_rules",
                        "content": "if the guy from google with 800 solved problems thinks so, I feel safe"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Finesse](/Finesse) this question is in Amazon interviews with high frequency."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is basically calculating the space of a shape under a function using the integral. Something from school math. The function is the prefix/suffix sum, the second prefix/suffix sum is its integral.\\n\\nBut I agree that this question is very hard. For this reason it\\'s very unlikely to be asked on an interview. And nobody claims that every LeetCode problem is asked on interviews."
                    },
                    {
                        "username": "entitled_american",
                        "content": "savant difficulty"
                    },
                    {
                        "username": "Mike1498",
                        "content": "This is one of the hardest hard problems i have come across. Yikes "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "I\\'ll literally cry if this problem appears in an interview/OA. Took me 3 hours. "
                    },
                    {
                        "username": "shuhulkaul",
                        "content": "How is output for testcase [2000000] is 999972007?"
                    },
                    {
                        "username": "Finesse",
                        "content": "`2000000^2 % 1000000007`"
                    },
                    {
                        "username": "shuhulkaul",
                        "content": "stupid modulo!"
                    },
                    {
                        "username": "mkahraman82",
                        "content": "why the test code is not passing? \n1- found all the subarrays\n2-multiplied min value and total value of sub arrays and found total value\n \n`class Solution:\n    def totalStrength(self, strength: List[int]) -> int:\n        l=[[]]\n        res=[]\n        #find all sub-arrays\n        for i in range(len(strength)+1):\n            for j in range(i):\n                l.append(strength[j:i])\n\n        #min value * total value of subarrays       \n        for i in range(1,len(l)):\n            res.append(min(l[i])*sum(l[i]))\n\n\n        return sum(res)`"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it takes `O(n³)` time. It's too much for 10⁵ input elements. On LeetCode, input size 10⁵ implies a solution that takes `O(n)` or `O(n*ln(n))` time."
                    },
                    {
                        "username": "Finesse",
                        "content": "Solution for this problem requires a crazy 4D imagination. I managed to solve it by myself, but my brain almost exploded \\uD83E\\uDD2F"
                    }
                ]
            },
            {
                "id": 1570887,
                "content": [
                    {
                        "username": "DugMJD",
                        "content": "![image](https://assets.leetcode.com/users/images/94ac9010-57fc-44e5-93b3-e3ceda88a3cb_1653193278.7448575.jpeg)\\n\\n1. https://leetcode.com/discuss/interview-question/1729637/amazon-new-grad-role-2022/\\n2. https://leetcode.com/discuss/interview-question/1736639/Solution-to-Amazon-OA-2022-problem-Sum-of-Scores-of-Subarray"
                    },
                    {
                        "username": "jinyang_deng",
                        "content": "[Original Post](https://leetcode.com/problems/sum-of-total-strength-of-wizards/discuss/2061985/Python-Solution-O(n))\\n\\nThe monotonic stack is self-explanatory. Just explaining \"(racc * ln - lacc * rn)\" in greater detail:\\n\\nSay our input is [5,3,1,2]\\n\\nUsing monotonic stack, Left is [-1, -1, -1, 2], Right is [1, 2, 4, 4].\\n\\nNow look at the 1 (at input array, index 2), it is the minimum for the [1], [3, 1], [5, 3, 1], [1, 2], [3, 1, 2], [5, 3, 1, 2]. So its \\u201Ccontribution\\u201D to the final result will be as follows:\\n1 * (sum([1]) + sum([3,1]) + sum([5,3,1]) + sum([1,2]) + sum([3,1,2]) + sum([5,3,1,2]))\\n\\nSo how do we find this \\u201Csum of sums\\u201D, given that we know the left most element that < 1 is at index -1 (means non-existent), and the rightmost element that is \\u2264 1 is at index 4 (means non-existent)?\\n\\nLee\\u2019s Solution: prefix of prefix sums, which is the \\u201Cacc\\u201D variable in his code.\\nFor our example, \\u201Cacc\\u201D is [0, 5, 13, 22, 33]. Let\\u2019s see which each element really means:\\n5 = (5)\\n13 = (5) + (5+3)\\n22 = (5) + (5+3) + (5+3+1)\\n33 = (5) + (5+3) + (5+3+1) + (5+3+1+2)\\n\\nSo how do we tie these parts together?\\nNote that in our example, there is a 2 larger numbers to 1\\u2019s left, and 1 larger number to 1\\u2019s right. This can be generalized into a pattern: if there are x larger numbers to the left to 1, and y larger numbers to its right: when we fix x, there can be y + 1 combinations on the right, or when we fix y, there can be x + 1 combinations on the left.\\n\\nKey: The way I understand it is that we are trying to build a \\u201Ctemplate\\u201D first, then cancel out some of numbers.\\n\\nFirst we do 33 \\u2013 13. Why? Look at the underlying.\\n33 \\u2013 13 = [(5) + (5+3) + (5+3+1) + (5+3+1+2)] \\u2013 [(5) + (5+3)] = [(5+3+1) + (5+3+1+2)]\\nWe are looking at 1 right now, so we don\\u2019t want to consider any subarray that doesn\\u2019t contain 1. Note this 20 is sum of 2 subarray sums.\\n\\nNext, we use 20 * 3. Why? Because we are trying to create a \\u201Ctemplate\\u201D here. Notice how because of the generalized pattern above, we will have 6 combinations (we can fix x to be 0 / 1 / 2, and y can be 0 / 1. For example, when x=0 and y=0, our combination is [1], or when x=2, y=0, our combination is [5,3,1]). Since 20 is sum of 2 subarray sums, and we want 6 combinations, we duplicate 20 3 times. So we now have:\\n[(5+3+1) + (5+3+1+2)]\\n[(5+3+1) + (5+3+1+2)]\\n[(5+3+1) + (5+3+1+2)]\\n\\nNext, we do 13 \\u2013 0. Look at the underlying.\\n13 \\u2013 0 = (5) + (5+3)\\n\\nThen 13 * 2. Now you might think why 2 not 3 (because 13 is sum of 2 subarrays), right? Proceed and I will explain it later:\\n\\nFinally, 20 * 3 - 13 * 2. Visually, this can be understood as follows:\\n[(<s>**5+3**</s>+1) + (<s>**5+3**</s>+1+2)]\\n[(<s>**5**</s>+3+1) + (<s>**5**</s>+3+1+2)]\\n[(5+3+1) + (5+3+1+2)].\\nNote that while the same cancellation strategy is applied horizontally, each 13 is the group of subarrays used for cancellation vertically. So how many 13 will we use? Depends on how many columns we have, which in turn 1 + number of bigger numbers to its right.\\n\\nThen you might ask, if we do \\u201Cracc * ln - lacc * rn\\u201D, does that mean \\u201Cln\\u201D always has to be \\u2265 \\u201Crn\\u201D? No, repeat the above for [5,1,3,2], and we can get the following cancellation outcome.\\n[(<s>**5**</s>+1) + (<s>**5**</s>+1+3) + (<s>**5**</s>+1+3+2)]\\n[(5+1) + (5+1+3) + (5+1+3+2)]\\n"
                    },
                    {
                        "username": "aalmos",
                        "content": "Am I the only one who thinks this problem is ridiculously hard? How the hell I\\'m supposed to figure out during a live interview session that the sum of all subarrays between `i` and `j` can be derived from a dual rolling sum?"
                    },
                    {
                        "username": "who_rules",
                        "content": "if the guy from google with 800 solved problems thinks so, I feel safe"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Finesse](/Finesse) this question is in Amazon interviews with high frequency."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is basically calculating the space of a shape under a function using the integral. Something from school math. The function is the prefix/suffix sum, the second prefix/suffix sum is its integral.\\n\\nBut I agree that this question is very hard. For this reason it\\'s very unlikely to be asked on an interview. And nobody claims that every LeetCode problem is asked on interviews."
                    },
                    {
                        "username": "entitled_american",
                        "content": "savant difficulty"
                    },
                    {
                        "username": "Mike1498",
                        "content": "This is one of the hardest hard problems i have come across. Yikes "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "I\\'ll literally cry if this problem appears in an interview/OA. Took me 3 hours. "
                    },
                    {
                        "username": "shuhulkaul",
                        "content": "How is output for testcase [2000000] is 999972007?"
                    },
                    {
                        "username": "Finesse",
                        "content": "`2000000^2 % 1000000007`"
                    },
                    {
                        "username": "shuhulkaul",
                        "content": "stupid modulo!"
                    },
                    {
                        "username": "mkahraman82",
                        "content": "why the test code is not passing? \n1- found all the subarrays\n2-multiplied min value and total value of sub arrays and found total value\n \n`class Solution:\n    def totalStrength(self, strength: List[int]) -> int:\n        l=[[]]\n        res=[]\n        #find all sub-arrays\n        for i in range(len(strength)+1):\n            for j in range(i):\n                l.append(strength[j:i])\n\n        #min value * total value of subarrays       \n        for i in range(1,len(l)):\n            res.append(min(l[i])*sum(l[i]))\n\n\n        return sum(res)`"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it takes `O(n³)` time. It's too much for 10⁵ input elements. On LeetCode, input size 10⁵ implies a solution that takes `O(n)` or `O(n*ln(n))` time."
                    },
                    {
                        "username": "Finesse",
                        "content": "Solution for this problem requires a crazy 4D imagination. I managed to solve it by myself, but my brain almost exploded \\uD83E\\uDD2F"
                    }
                ]
            },
            {
                "id": 1856575,
                "content": [
                    {
                        "username": "DugMJD",
                        "content": "![image](https://assets.leetcode.com/users/images/94ac9010-57fc-44e5-93b3-e3ceda88a3cb_1653193278.7448575.jpeg)\\n\\n1. https://leetcode.com/discuss/interview-question/1729637/amazon-new-grad-role-2022/\\n2. https://leetcode.com/discuss/interview-question/1736639/Solution-to-Amazon-OA-2022-problem-Sum-of-Scores-of-Subarray"
                    },
                    {
                        "username": "jinyang_deng",
                        "content": "[Original Post](https://leetcode.com/problems/sum-of-total-strength-of-wizards/discuss/2061985/Python-Solution-O(n))\\n\\nThe monotonic stack is self-explanatory. Just explaining \"(racc * ln - lacc * rn)\" in greater detail:\\n\\nSay our input is [5,3,1,2]\\n\\nUsing monotonic stack, Left is [-1, -1, -1, 2], Right is [1, 2, 4, 4].\\n\\nNow look at the 1 (at input array, index 2), it is the minimum for the [1], [3, 1], [5, 3, 1], [1, 2], [3, 1, 2], [5, 3, 1, 2]. So its \\u201Ccontribution\\u201D to the final result will be as follows:\\n1 * (sum([1]) + sum([3,1]) + sum([5,3,1]) + sum([1,2]) + sum([3,1,2]) + sum([5,3,1,2]))\\n\\nSo how do we find this \\u201Csum of sums\\u201D, given that we know the left most element that < 1 is at index -1 (means non-existent), and the rightmost element that is \\u2264 1 is at index 4 (means non-existent)?\\n\\nLee\\u2019s Solution: prefix of prefix sums, which is the \\u201Cacc\\u201D variable in his code.\\nFor our example, \\u201Cacc\\u201D is [0, 5, 13, 22, 33]. Let\\u2019s see which each element really means:\\n5 = (5)\\n13 = (5) + (5+3)\\n22 = (5) + (5+3) + (5+3+1)\\n33 = (5) + (5+3) + (5+3+1) + (5+3+1+2)\\n\\nSo how do we tie these parts together?\\nNote that in our example, there is a 2 larger numbers to 1\\u2019s left, and 1 larger number to 1\\u2019s right. This can be generalized into a pattern: if there are x larger numbers to the left to 1, and y larger numbers to its right: when we fix x, there can be y + 1 combinations on the right, or when we fix y, there can be x + 1 combinations on the left.\\n\\nKey: The way I understand it is that we are trying to build a \\u201Ctemplate\\u201D first, then cancel out some of numbers.\\n\\nFirst we do 33 \\u2013 13. Why? Look at the underlying.\\n33 \\u2013 13 = [(5) + (5+3) + (5+3+1) + (5+3+1+2)] \\u2013 [(5) + (5+3)] = [(5+3+1) + (5+3+1+2)]\\nWe are looking at 1 right now, so we don\\u2019t want to consider any subarray that doesn\\u2019t contain 1. Note this 20 is sum of 2 subarray sums.\\n\\nNext, we use 20 * 3. Why? Because we are trying to create a \\u201Ctemplate\\u201D here. Notice how because of the generalized pattern above, we will have 6 combinations (we can fix x to be 0 / 1 / 2, and y can be 0 / 1. For example, when x=0 and y=0, our combination is [1], or when x=2, y=0, our combination is [5,3,1]). Since 20 is sum of 2 subarray sums, and we want 6 combinations, we duplicate 20 3 times. So we now have:\\n[(5+3+1) + (5+3+1+2)]\\n[(5+3+1) + (5+3+1+2)]\\n[(5+3+1) + (5+3+1+2)]\\n\\nNext, we do 13 \\u2013 0. Look at the underlying.\\n13 \\u2013 0 = (5) + (5+3)\\n\\nThen 13 * 2. Now you might think why 2 not 3 (because 13 is sum of 2 subarrays), right? Proceed and I will explain it later:\\n\\nFinally, 20 * 3 - 13 * 2. Visually, this can be understood as follows:\\n[(<s>**5+3**</s>+1) + (<s>**5+3**</s>+1+2)]\\n[(<s>**5**</s>+3+1) + (<s>**5**</s>+3+1+2)]\\n[(5+3+1) + (5+3+1+2)].\\nNote that while the same cancellation strategy is applied horizontally, each 13 is the group of subarrays used for cancellation vertically. So how many 13 will we use? Depends on how many columns we have, which in turn 1 + number of bigger numbers to its right.\\n\\nThen you might ask, if we do \\u201Cracc * ln - lacc * rn\\u201D, does that mean \\u201Cln\\u201D always has to be \\u2265 \\u201Crn\\u201D? No, repeat the above for [5,1,3,2], and we can get the following cancellation outcome.\\n[(<s>**5**</s>+1) + (<s>**5**</s>+1+3) + (<s>**5**</s>+1+3+2)]\\n[(5+1) + (5+1+3) + (5+1+3+2)]\\n"
                    },
                    {
                        "username": "aalmos",
                        "content": "Am I the only one who thinks this problem is ridiculously hard? How the hell I\\'m supposed to figure out during a live interview session that the sum of all subarrays between `i` and `j` can be derived from a dual rolling sum?"
                    },
                    {
                        "username": "who_rules",
                        "content": "if the guy from google with 800 solved problems thinks so, I feel safe"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Finesse](/Finesse) this question is in Amazon interviews with high frequency."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is basically calculating the space of a shape under a function using the integral. Something from school math. The function is the prefix/suffix sum, the second prefix/suffix sum is its integral.\\n\\nBut I agree that this question is very hard. For this reason it\\'s very unlikely to be asked on an interview. And nobody claims that every LeetCode problem is asked on interviews."
                    },
                    {
                        "username": "entitled_american",
                        "content": "savant difficulty"
                    },
                    {
                        "username": "Mike1498",
                        "content": "This is one of the hardest hard problems i have come across. Yikes "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "I\\'ll literally cry if this problem appears in an interview/OA. Took me 3 hours. "
                    },
                    {
                        "username": "shuhulkaul",
                        "content": "How is output for testcase [2000000] is 999972007?"
                    },
                    {
                        "username": "Finesse",
                        "content": "`2000000^2 % 1000000007`"
                    },
                    {
                        "username": "shuhulkaul",
                        "content": "stupid modulo!"
                    },
                    {
                        "username": "mkahraman82",
                        "content": "why the test code is not passing? \n1- found all the subarrays\n2-multiplied min value and total value of sub arrays and found total value\n \n`class Solution:\n    def totalStrength(self, strength: List[int]) -> int:\n        l=[[]]\n        res=[]\n        #find all sub-arrays\n        for i in range(len(strength)+1):\n            for j in range(i):\n                l.append(strength[j:i])\n\n        #min value * total value of subarrays       \n        for i in range(1,len(l)):\n            res.append(min(l[i])*sum(l[i]))\n\n\n        return sum(res)`"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it takes `O(n³)` time. It's too much for 10⁵ input elements. On LeetCode, input size 10⁵ implies a solution that takes `O(n)` or `O(n*ln(n))` time."
                    },
                    {
                        "username": "Finesse",
                        "content": "Solution for this problem requires a crazy 4D imagination. I managed to solve it by myself, but my brain almost exploded \\uD83E\\uDD2F"
                    }
                ]
            },
            {
                "id": 1986670,
                "content": [
                    {
                        "username": "DugMJD",
                        "content": "![image](https://assets.leetcode.com/users/images/94ac9010-57fc-44e5-93b3-e3ceda88a3cb_1653193278.7448575.jpeg)\\n\\n1. https://leetcode.com/discuss/interview-question/1729637/amazon-new-grad-role-2022/\\n2. https://leetcode.com/discuss/interview-question/1736639/Solution-to-Amazon-OA-2022-problem-Sum-of-Scores-of-Subarray"
                    },
                    {
                        "username": "jinyang_deng",
                        "content": "[Original Post](https://leetcode.com/problems/sum-of-total-strength-of-wizards/discuss/2061985/Python-Solution-O(n))\\n\\nThe monotonic stack is self-explanatory. Just explaining \"(racc * ln - lacc * rn)\" in greater detail:\\n\\nSay our input is [5,3,1,2]\\n\\nUsing monotonic stack, Left is [-1, -1, -1, 2], Right is [1, 2, 4, 4].\\n\\nNow look at the 1 (at input array, index 2), it is the minimum for the [1], [3, 1], [5, 3, 1], [1, 2], [3, 1, 2], [5, 3, 1, 2]. So its \\u201Ccontribution\\u201D to the final result will be as follows:\\n1 * (sum([1]) + sum([3,1]) + sum([5,3,1]) + sum([1,2]) + sum([3,1,2]) + sum([5,3,1,2]))\\n\\nSo how do we find this \\u201Csum of sums\\u201D, given that we know the left most element that < 1 is at index -1 (means non-existent), and the rightmost element that is \\u2264 1 is at index 4 (means non-existent)?\\n\\nLee\\u2019s Solution: prefix of prefix sums, which is the \\u201Cacc\\u201D variable in his code.\\nFor our example, \\u201Cacc\\u201D is [0, 5, 13, 22, 33]. Let\\u2019s see which each element really means:\\n5 = (5)\\n13 = (5) + (5+3)\\n22 = (5) + (5+3) + (5+3+1)\\n33 = (5) + (5+3) + (5+3+1) + (5+3+1+2)\\n\\nSo how do we tie these parts together?\\nNote that in our example, there is a 2 larger numbers to 1\\u2019s left, and 1 larger number to 1\\u2019s right. This can be generalized into a pattern: if there are x larger numbers to the left to 1, and y larger numbers to its right: when we fix x, there can be y + 1 combinations on the right, or when we fix y, there can be x + 1 combinations on the left.\\n\\nKey: The way I understand it is that we are trying to build a \\u201Ctemplate\\u201D first, then cancel out some of numbers.\\n\\nFirst we do 33 \\u2013 13. Why? Look at the underlying.\\n33 \\u2013 13 = [(5) + (5+3) + (5+3+1) + (5+3+1+2)] \\u2013 [(5) + (5+3)] = [(5+3+1) + (5+3+1+2)]\\nWe are looking at 1 right now, so we don\\u2019t want to consider any subarray that doesn\\u2019t contain 1. Note this 20 is sum of 2 subarray sums.\\n\\nNext, we use 20 * 3. Why? Because we are trying to create a \\u201Ctemplate\\u201D here. Notice how because of the generalized pattern above, we will have 6 combinations (we can fix x to be 0 / 1 / 2, and y can be 0 / 1. For example, when x=0 and y=0, our combination is [1], or when x=2, y=0, our combination is [5,3,1]). Since 20 is sum of 2 subarray sums, and we want 6 combinations, we duplicate 20 3 times. So we now have:\\n[(5+3+1) + (5+3+1+2)]\\n[(5+3+1) + (5+3+1+2)]\\n[(5+3+1) + (5+3+1+2)]\\n\\nNext, we do 13 \\u2013 0. Look at the underlying.\\n13 \\u2013 0 = (5) + (5+3)\\n\\nThen 13 * 2. Now you might think why 2 not 3 (because 13 is sum of 2 subarrays), right? Proceed and I will explain it later:\\n\\nFinally, 20 * 3 - 13 * 2. Visually, this can be understood as follows:\\n[(<s>**5+3**</s>+1) + (<s>**5+3**</s>+1+2)]\\n[(<s>**5**</s>+3+1) + (<s>**5**</s>+3+1+2)]\\n[(5+3+1) + (5+3+1+2)].\\nNote that while the same cancellation strategy is applied horizontally, each 13 is the group of subarrays used for cancellation vertically. So how many 13 will we use? Depends on how many columns we have, which in turn 1 + number of bigger numbers to its right.\\n\\nThen you might ask, if we do \\u201Cracc * ln - lacc * rn\\u201D, does that mean \\u201Cln\\u201D always has to be \\u2265 \\u201Crn\\u201D? No, repeat the above for [5,1,3,2], and we can get the following cancellation outcome.\\n[(<s>**5**</s>+1) + (<s>**5**</s>+1+3) + (<s>**5**</s>+1+3+2)]\\n[(5+1) + (5+1+3) + (5+1+3+2)]\\n"
                    },
                    {
                        "username": "aalmos",
                        "content": "Am I the only one who thinks this problem is ridiculously hard? How the hell I\\'m supposed to figure out during a live interview session that the sum of all subarrays between `i` and `j` can be derived from a dual rolling sum?"
                    },
                    {
                        "username": "who_rules",
                        "content": "if the guy from google with 800 solved problems thinks so, I feel safe"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Finesse](/Finesse) this question is in Amazon interviews with high frequency."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is basically calculating the space of a shape under a function using the integral. Something from school math. The function is the prefix/suffix sum, the second prefix/suffix sum is its integral.\\n\\nBut I agree that this question is very hard. For this reason it\\'s very unlikely to be asked on an interview. And nobody claims that every LeetCode problem is asked on interviews."
                    },
                    {
                        "username": "entitled_american",
                        "content": "savant difficulty"
                    },
                    {
                        "username": "Mike1498",
                        "content": "This is one of the hardest hard problems i have come across. Yikes "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "I\\'ll literally cry if this problem appears in an interview/OA. Took me 3 hours. "
                    },
                    {
                        "username": "shuhulkaul",
                        "content": "How is output for testcase [2000000] is 999972007?"
                    },
                    {
                        "username": "Finesse",
                        "content": "`2000000^2 % 1000000007`"
                    },
                    {
                        "username": "shuhulkaul",
                        "content": "stupid modulo!"
                    },
                    {
                        "username": "mkahraman82",
                        "content": "why the test code is not passing? \n1- found all the subarrays\n2-multiplied min value and total value of sub arrays and found total value\n \n`class Solution:\n    def totalStrength(self, strength: List[int]) -> int:\n        l=[[]]\n        res=[]\n        #find all sub-arrays\n        for i in range(len(strength)+1):\n            for j in range(i):\n                l.append(strength[j:i])\n\n        #min value * total value of subarrays       \n        for i in range(1,len(l)):\n            res.append(min(l[i])*sum(l[i]))\n\n\n        return sum(res)`"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it takes `O(n³)` time. It's too much for 10⁵ input elements. On LeetCode, input size 10⁵ implies a solution that takes `O(n)` or `O(n*ln(n))` time."
                    },
                    {
                        "username": "Finesse",
                        "content": "Solution for this problem requires a crazy 4D imagination. I managed to solve it by myself, but my brain almost exploded \\uD83E\\uDD2F"
                    }
                ]
            },
            {
                "id": 2048495,
                "content": [
                    {
                        "username": "DugMJD",
                        "content": "![image](https://assets.leetcode.com/users/images/94ac9010-57fc-44e5-93b3-e3ceda88a3cb_1653193278.7448575.jpeg)\\n\\n1. https://leetcode.com/discuss/interview-question/1729637/amazon-new-grad-role-2022/\\n2. https://leetcode.com/discuss/interview-question/1736639/Solution-to-Amazon-OA-2022-problem-Sum-of-Scores-of-Subarray"
                    },
                    {
                        "username": "jinyang_deng",
                        "content": "[Original Post](https://leetcode.com/problems/sum-of-total-strength-of-wizards/discuss/2061985/Python-Solution-O(n))\\n\\nThe monotonic stack is self-explanatory. Just explaining \"(racc * ln - lacc * rn)\" in greater detail:\\n\\nSay our input is [5,3,1,2]\\n\\nUsing monotonic stack, Left is [-1, -1, -1, 2], Right is [1, 2, 4, 4].\\n\\nNow look at the 1 (at input array, index 2), it is the minimum for the [1], [3, 1], [5, 3, 1], [1, 2], [3, 1, 2], [5, 3, 1, 2]. So its \\u201Ccontribution\\u201D to the final result will be as follows:\\n1 * (sum([1]) + sum([3,1]) + sum([5,3,1]) + sum([1,2]) + sum([3,1,2]) + sum([5,3,1,2]))\\n\\nSo how do we find this \\u201Csum of sums\\u201D, given that we know the left most element that < 1 is at index -1 (means non-existent), and the rightmost element that is \\u2264 1 is at index 4 (means non-existent)?\\n\\nLee\\u2019s Solution: prefix of prefix sums, which is the \\u201Cacc\\u201D variable in his code.\\nFor our example, \\u201Cacc\\u201D is [0, 5, 13, 22, 33]. Let\\u2019s see which each element really means:\\n5 = (5)\\n13 = (5) + (5+3)\\n22 = (5) + (5+3) + (5+3+1)\\n33 = (5) + (5+3) + (5+3+1) + (5+3+1+2)\\n\\nSo how do we tie these parts together?\\nNote that in our example, there is a 2 larger numbers to 1\\u2019s left, and 1 larger number to 1\\u2019s right. This can be generalized into a pattern: if there are x larger numbers to the left to 1, and y larger numbers to its right: when we fix x, there can be y + 1 combinations on the right, or when we fix y, there can be x + 1 combinations on the left.\\n\\nKey: The way I understand it is that we are trying to build a \\u201Ctemplate\\u201D first, then cancel out some of numbers.\\n\\nFirst we do 33 \\u2013 13. Why? Look at the underlying.\\n33 \\u2013 13 = [(5) + (5+3) + (5+3+1) + (5+3+1+2)] \\u2013 [(5) + (5+3)] = [(5+3+1) + (5+3+1+2)]\\nWe are looking at 1 right now, so we don\\u2019t want to consider any subarray that doesn\\u2019t contain 1. Note this 20 is sum of 2 subarray sums.\\n\\nNext, we use 20 * 3. Why? Because we are trying to create a \\u201Ctemplate\\u201D here. Notice how because of the generalized pattern above, we will have 6 combinations (we can fix x to be 0 / 1 / 2, and y can be 0 / 1. For example, when x=0 and y=0, our combination is [1], or when x=2, y=0, our combination is [5,3,1]). Since 20 is sum of 2 subarray sums, and we want 6 combinations, we duplicate 20 3 times. So we now have:\\n[(5+3+1) + (5+3+1+2)]\\n[(5+3+1) + (5+3+1+2)]\\n[(5+3+1) + (5+3+1+2)]\\n\\nNext, we do 13 \\u2013 0. Look at the underlying.\\n13 \\u2013 0 = (5) + (5+3)\\n\\nThen 13 * 2. Now you might think why 2 not 3 (because 13 is sum of 2 subarrays), right? Proceed and I will explain it later:\\n\\nFinally, 20 * 3 - 13 * 2. Visually, this can be understood as follows:\\n[(<s>**5+3**</s>+1) + (<s>**5+3**</s>+1+2)]\\n[(<s>**5**</s>+3+1) + (<s>**5**</s>+3+1+2)]\\n[(5+3+1) + (5+3+1+2)].\\nNote that while the same cancellation strategy is applied horizontally, each 13 is the group of subarrays used for cancellation vertically. So how many 13 will we use? Depends on how many columns we have, which in turn 1 + number of bigger numbers to its right.\\n\\nThen you might ask, if we do \\u201Cracc * ln - lacc * rn\\u201D, does that mean \\u201Cln\\u201D always has to be \\u2265 \\u201Crn\\u201D? No, repeat the above for [5,1,3,2], and we can get the following cancellation outcome.\\n[(<s>**5**</s>+1) + (<s>**5**</s>+1+3) + (<s>**5**</s>+1+3+2)]\\n[(5+1) + (5+1+3) + (5+1+3+2)]\\n"
                    },
                    {
                        "username": "aalmos",
                        "content": "Am I the only one who thinks this problem is ridiculously hard? How the hell I\\'m supposed to figure out during a live interview session that the sum of all subarrays between `i` and `j` can be derived from a dual rolling sum?"
                    },
                    {
                        "username": "who_rules",
                        "content": "if the guy from google with 800 solved problems thinks so, I feel safe"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Finesse](/Finesse) this question is in Amazon interviews with high frequency."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is basically calculating the space of a shape under a function using the integral. Something from school math. The function is the prefix/suffix sum, the second prefix/suffix sum is its integral.\\n\\nBut I agree that this question is very hard. For this reason it\\'s very unlikely to be asked on an interview. And nobody claims that every LeetCode problem is asked on interviews."
                    },
                    {
                        "username": "entitled_american",
                        "content": "savant difficulty"
                    },
                    {
                        "username": "Mike1498",
                        "content": "This is one of the hardest hard problems i have come across. Yikes "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "I\\'ll literally cry if this problem appears in an interview/OA. Took me 3 hours. "
                    },
                    {
                        "username": "shuhulkaul",
                        "content": "How is output for testcase [2000000] is 999972007?"
                    },
                    {
                        "username": "Finesse",
                        "content": "`2000000^2 % 1000000007`"
                    },
                    {
                        "username": "shuhulkaul",
                        "content": "stupid modulo!"
                    },
                    {
                        "username": "mkahraman82",
                        "content": "why the test code is not passing? \n1- found all the subarrays\n2-multiplied min value and total value of sub arrays and found total value\n \n`class Solution:\n    def totalStrength(self, strength: List[int]) -> int:\n        l=[[]]\n        res=[]\n        #find all sub-arrays\n        for i in range(len(strength)+1):\n            for j in range(i):\n                l.append(strength[j:i])\n\n        #min value * total value of subarrays       \n        for i in range(1,len(l)):\n            res.append(min(l[i])*sum(l[i]))\n\n\n        return sum(res)`"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it takes `O(n³)` time. It's too much for 10⁵ input elements. On LeetCode, input size 10⁵ implies a solution that takes `O(n)` or `O(n*ln(n))` time."
                    },
                    {
                        "username": "Finesse",
                        "content": "Solution for this problem requires a crazy 4D imagination. I managed to solve it by myself, but my brain almost exploded \\uD83E\\uDD2F"
                    }
                ]
            },
            {
                "id": 1975583,
                "content": [
                    {
                        "username": "DugMJD",
                        "content": "![image](https://assets.leetcode.com/users/images/94ac9010-57fc-44e5-93b3-e3ceda88a3cb_1653193278.7448575.jpeg)\\n\\n1. https://leetcode.com/discuss/interview-question/1729637/amazon-new-grad-role-2022/\\n2. https://leetcode.com/discuss/interview-question/1736639/Solution-to-Amazon-OA-2022-problem-Sum-of-Scores-of-Subarray"
                    },
                    {
                        "username": "jinyang_deng",
                        "content": "[Original Post](https://leetcode.com/problems/sum-of-total-strength-of-wizards/discuss/2061985/Python-Solution-O(n))\\n\\nThe monotonic stack is self-explanatory. Just explaining \"(racc * ln - lacc * rn)\" in greater detail:\\n\\nSay our input is [5,3,1,2]\\n\\nUsing monotonic stack, Left is [-1, -1, -1, 2], Right is [1, 2, 4, 4].\\n\\nNow look at the 1 (at input array, index 2), it is the minimum for the [1], [3, 1], [5, 3, 1], [1, 2], [3, 1, 2], [5, 3, 1, 2]. So its \\u201Ccontribution\\u201D to the final result will be as follows:\\n1 * (sum([1]) + sum([3,1]) + sum([5,3,1]) + sum([1,2]) + sum([3,1,2]) + sum([5,3,1,2]))\\n\\nSo how do we find this \\u201Csum of sums\\u201D, given that we know the left most element that < 1 is at index -1 (means non-existent), and the rightmost element that is \\u2264 1 is at index 4 (means non-existent)?\\n\\nLee\\u2019s Solution: prefix of prefix sums, which is the \\u201Cacc\\u201D variable in his code.\\nFor our example, \\u201Cacc\\u201D is [0, 5, 13, 22, 33]. Let\\u2019s see which each element really means:\\n5 = (5)\\n13 = (5) + (5+3)\\n22 = (5) + (5+3) + (5+3+1)\\n33 = (5) + (5+3) + (5+3+1) + (5+3+1+2)\\n\\nSo how do we tie these parts together?\\nNote that in our example, there is a 2 larger numbers to 1\\u2019s left, and 1 larger number to 1\\u2019s right. This can be generalized into a pattern: if there are x larger numbers to the left to 1, and y larger numbers to its right: when we fix x, there can be y + 1 combinations on the right, or when we fix y, there can be x + 1 combinations on the left.\\n\\nKey: The way I understand it is that we are trying to build a \\u201Ctemplate\\u201D first, then cancel out some of numbers.\\n\\nFirst we do 33 \\u2013 13. Why? Look at the underlying.\\n33 \\u2013 13 = [(5) + (5+3) + (5+3+1) + (5+3+1+2)] \\u2013 [(5) + (5+3)] = [(5+3+1) + (5+3+1+2)]\\nWe are looking at 1 right now, so we don\\u2019t want to consider any subarray that doesn\\u2019t contain 1. Note this 20 is sum of 2 subarray sums.\\n\\nNext, we use 20 * 3. Why? Because we are trying to create a \\u201Ctemplate\\u201D here. Notice how because of the generalized pattern above, we will have 6 combinations (we can fix x to be 0 / 1 / 2, and y can be 0 / 1. For example, when x=0 and y=0, our combination is [1], or when x=2, y=0, our combination is [5,3,1]). Since 20 is sum of 2 subarray sums, and we want 6 combinations, we duplicate 20 3 times. So we now have:\\n[(5+3+1) + (5+3+1+2)]\\n[(5+3+1) + (5+3+1+2)]\\n[(5+3+1) + (5+3+1+2)]\\n\\nNext, we do 13 \\u2013 0. Look at the underlying.\\n13 \\u2013 0 = (5) + (5+3)\\n\\nThen 13 * 2. Now you might think why 2 not 3 (because 13 is sum of 2 subarrays), right? Proceed and I will explain it later:\\n\\nFinally, 20 * 3 - 13 * 2. Visually, this can be understood as follows:\\n[(<s>**5+3**</s>+1) + (<s>**5+3**</s>+1+2)]\\n[(<s>**5**</s>+3+1) + (<s>**5**</s>+3+1+2)]\\n[(5+3+1) + (5+3+1+2)].\\nNote that while the same cancellation strategy is applied horizontally, each 13 is the group of subarrays used for cancellation vertically. So how many 13 will we use? Depends on how many columns we have, which in turn 1 + number of bigger numbers to its right.\\n\\nThen you might ask, if we do \\u201Cracc * ln - lacc * rn\\u201D, does that mean \\u201Cln\\u201D always has to be \\u2265 \\u201Crn\\u201D? No, repeat the above for [5,1,3,2], and we can get the following cancellation outcome.\\n[(<s>**5**</s>+1) + (<s>**5**</s>+1+3) + (<s>**5**</s>+1+3+2)]\\n[(5+1) + (5+1+3) + (5+1+3+2)]\\n"
                    },
                    {
                        "username": "aalmos",
                        "content": "Am I the only one who thinks this problem is ridiculously hard? How the hell I\\'m supposed to figure out during a live interview session that the sum of all subarrays between `i` and `j` can be derived from a dual rolling sum?"
                    },
                    {
                        "username": "who_rules",
                        "content": "if the guy from google with 800 solved problems thinks so, I feel safe"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Finesse](/Finesse) this question is in Amazon interviews with high frequency."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is basically calculating the space of a shape under a function using the integral. Something from school math. The function is the prefix/suffix sum, the second prefix/suffix sum is its integral.\\n\\nBut I agree that this question is very hard. For this reason it\\'s very unlikely to be asked on an interview. And nobody claims that every LeetCode problem is asked on interviews."
                    },
                    {
                        "username": "entitled_american",
                        "content": "savant difficulty"
                    },
                    {
                        "username": "Mike1498",
                        "content": "This is one of the hardest hard problems i have come across. Yikes "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "I\\'ll literally cry if this problem appears in an interview/OA. Took me 3 hours. "
                    },
                    {
                        "username": "shuhulkaul",
                        "content": "How is output for testcase [2000000] is 999972007?"
                    },
                    {
                        "username": "Finesse",
                        "content": "`2000000^2 % 1000000007`"
                    },
                    {
                        "username": "shuhulkaul",
                        "content": "stupid modulo!"
                    },
                    {
                        "username": "mkahraman82",
                        "content": "why the test code is not passing? \n1- found all the subarrays\n2-multiplied min value and total value of sub arrays and found total value\n \n`class Solution:\n    def totalStrength(self, strength: List[int]) -> int:\n        l=[[]]\n        res=[]\n        #find all sub-arrays\n        for i in range(len(strength)+1):\n            for j in range(i):\n                l.append(strength[j:i])\n\n        #min value * total value of subarrays       \n        for i in range(1,len(l)):\n            res.append(min(l[i])*sum(l[i]))\n\n\n        return sum(res)`"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it takes `O(n³)` time. It's too much for 10⁵ input elements. On LeetCode, input size 10⁵ implies a solution that takes `O(n)` or `O(n*ln(n))` time."
                    },
                    {
                        "username": "Finesse",
                        "content": "Solution for this problem requires a crazy 4D imagination. I managed to solve it by myself, but my brain almost exploded \\uD83E\\uDD2F"
                    }
                ]
            },
            {
                "id": 1852278,
                "content": [
                    {
                        "username": "DugMJD",
                        "content": "![image](https://assets.leetcode.com/users/images/94ac9010-57fc-44e5-93b3-e3ceda88a3cb_1653193278.7448575.jpeg)\\n\\n1. https://leetcode.com/discuss/interview-question/1729637/amazon-new-grad-role-2022/\\n2. https://leetcode.com/discuss/interview-question/1736639/Solution-to-Amazon-OA-2022-problem-Sum-of-Scores-of-Subarray"
                    },
                    {
                        "username": "jinyang_deng",
                        "content": "[Original Post](https://leetcode.com/problems/sum-of-total-strength-of-wizards/discuss/2061985/Python-Solution-O(n))\\n\\nThe monotonic stack is self-explanatory. Just explaining \"(racc * ln - lacc * rn)\" in greater detail:\\n\\nSay our input is [5,3,1,2]\\n\\nUsing monotonic stack, Left is [-1, -1, -1, 2], Right is [1, 2, 4, 4].\\n\\nNow look at the 1 (at input array, index 2), it is the minimum for the [1], [3, 1], [5, 3, 1], [1, 2], [3, 1, 2], [5, 3, 1, 2]. So its \\u201Ccontribution\\u201D to the final result will be as follows:\\n1 * (sum([1]) + sum([3,1]) + sum([5,3,1]) + sum([1,2]) + sum([3,1,2]) + sum([5,3,1,2]))\\n\\nSo how do we find this \\u201Csum of sums\\u201D, given that we know the left most element that < 1 is at index -1 (means non-existent), and the rightmost element that is \\u2264 1 is at index 4 (means non-existent)?\\n\\nLee\\u2019s Solution: prefix of prefix sums, which is the \\u201Cacc\\u201D variable in his code.\\nFor our example, \\u201Cacc\\u201D is [0, 5, 13, 22, 33]. Let\\u2019s see which each element really means:\\n5 = (5)\\n13 = (5) + (5+3)\\n22 = (5) + (5+3) + (5+3+1)\\n33 = (5) + (5+3) + (5+3+1) + (5+3+1+2)\\n\\nSo how do we tie these parts together?\\nNote that in our example, there is a 2 larger numbers to 1\\u2019s left, and 1 larger number to 1\\u2019s right. This can be generalized into a pattern: if there are x larger numbers to the left to 1, and y larger numbers to its right: when we fix x, there can be y + 1 combinations on the right, or when we fix y, there can be x + 1 combinations on the left.\\n\\nKey: The way I understand it is that we are trying to build a \\u201Ctemplate\\u201D first, then cancel out some of numbers.\\n\\nFirst we do 33 \\u2013 13. Why? Look at the underlying.\\n33 \\u2013 13 = [(5) + (5+3) + (5+3+1) + (5+3+1+2)] \\u2013 [(5) + (5+3)] = [(5+3+1) + (5+3+1+2)]\\nWe are looking at 1 right now, so we don\\u2019t want to consider any subarray that doesn\\u2019t contain 1. Note this 20 is sum of 2 subarray sums.\\n\\nNext, we use 20 * 3. Why? Because we are trying to create a \\u201Ctemplate\\u201D here. Notice how because of the generalized pattern above, we will have 6 combinations (we can fix x to be 0 / 1 / 2, and y can be 0 / 1. For example, when x=0 and y=0, our combination is [1], or when x=2, y=0, our combination is [5,3,1]). Since 20 is sum of 2 subarray sums, and we want 6 combinations, we duplicate 20 3 times. So we now have:\\n[(5+3+1) + (5+3+1+2)]\\n[(5+3+1) + (5+3+1+2)]\\n[(5+3+1) + (5+3+1+2)]\\n\\nNext, we do 13 \\u2013 0. Look at the underlying.\\n13 \\u2013 0 = (5) + (5+3)\\n\\nThen 13 * 2. Now you might think why 2 not 3 (because 13 is sum of 2 subarrays), right? Proceed and I will explain it later:\\n\\nFinally, 20 * 3 - 13 * 2. Visually, this can be understood as follows:\\n[(<s>**5+3**</s>+1) + (<s>**5+3**</s>+1+2)]\\n[(<s>**5**</s>+3+1) + (<s>**5**</s>+3+1+2)]\\n[(5+3+1) + (5+3+1+2)].\\nNote that while the same cancellation strategy is applied horizontally, each 13 is the group of subarrays used for cancellation vertically. So how many 13 will we use? Depends on how many columns we have, which in turn 1 + number of bigger numbers to its right.\\n\\nThen you might ask, if we do \\u201Cracc * ln - lacc * rn\\u201D, does that mean \\u201Cln\\u201D always has to be \\u2265 \\u201Crn\\u201D? No, repeat the above for [5,1,3,2], and we can get the following cancellation outcome.\\n[(<s>**5**</s>+1) + (<s>**5**</s>+1+3) + (<s>**5**</s>+1+3+2)]\\n[(5+1) + (5+1+3) + (5+1+3+2)]\\n"
                    },
                    {
                        "username": "aalmos",
                        "content": "Am I the only one who thinks this problem is ridiculously hard? How the hell I\\'m supposed to figure out during a live interview session that the sum of all subarrays between `i` and `j` can be derived from a dual rolling sum?"
                    },
                    {
                        "username": "who_rules",
                        "content": "if the guy from google with 800 solved problems thinks so, I feel safe"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Finesse](/Finesse) this question is in Amazon interviews with high frequency."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is basically calculating the space of a shape under a function using the integral. Something from school math. The function is the prefix/suffix sum, the second prefix/suffix sum is its integral.\\n\\nBut I agree that this question is very hard. For this reason it\\'s very unlikely to be asked on an interview. And nobody claims that every LeetCode problem is asked on interviews."
                    },
                    {
                        "username": "entitled_american",
                        "content": "savant difficulty"
                    },
                    {
                        "username": "Mike1498",
                        "content": "This is one of the hardest hard problems i have come across. Yikes "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "I\\'ll literally cry if this problem appears in an interview/OA. Took me 3 hours. "
                    },
                    {
                        "username": "shuhulkaul",
                        "content": "How is output for testcase [2000000] is 999972007?"
                    },
                    {
                        "username": "Finesse",
                        "content": "`2000000^2 % 1000000007`"
                    },
                    {
                        "username": "shuhulkaul",
                        "content": "stupid modulo!"
                    },
                    {
                        "username": "mkahraman82",
                        "content": "why the test code is not passing? \n1- found all the subarrays\n2-multiplied min value and total value of sub arrays and found total value\n \n`class Solution:\n    def totalStrength(self, strength: List[int]) -> int:\n        l=[[]]\n        res=[]\n        #find all sub-arrays\n        for i in range(len(strength)+1):\n            for j in range(i):\n                l.append(strength[j:i])\n\n        #min value * total value of subarrays       \n        for i in range(1,len(l)):\n            res.append(min(l[i])*sum(l[i]))\n\n\n        return sum(res)`"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it takes `O(n³)` time. It's too much for 10⁵ input elements. On LeetCode, input size 10⁵ implies a solution that takes `O(n)` or `O(n*ln(n))` time."
                    },
                    {
                        "username": "Finesse",
                        "content": "Solution for this problem requires a crazy 4D imagination. I managed to solve it by myself, but my brain almost exploded \\uD83E\\uDD2F"
                    }
                ]
            },
            {
                "id": 1721228,
                "content": [
                    {
                        "username": "DugMJD",
                        "content": "![image](https://assets.leetcode.com/users/images/94ac9010-57fc-44e5-93b3-e3ceda88a3cb_1653193278.7448575.jpeg)\\n\\n1. https://leetcode.com/discuss/interview-question/1729637/amazon-new-grad-role-2022/\\n2. https://leetcode.com/discuss/interview-question/1736639/Solution-to-Amazon-OA-2022-problem-Sum-of-Scores-of-Subarray"
                    },
                    {
                        "username": "jinyang_deng",
                        "content": "[Original Post](https://leetcode.com/problems/sum-of-total-strength-of-wizards/discuss/2061985/Python-Solution-O(n))\\n\\nThe monotonic stack is self-explanatory. Just explaining \"(racc * ln - lacc * rn)\" in greater detail:\\n\\nSay our input is [5,3,1,2]\\n\\nUsing monotonic stack, Left is [-1, -1, -1, 2], Right is [1, 2, 4, 4].\\n\\nNow look at the 1 (at input array, index 2), it is the minimum for the [1], [3, 1], [5, 3, 1], [1, 2], [3, 1, 2], [5, 3, 1, 2]. So its \\u201Ccontribution\\u201D to the final result will be as follows:\\n1 * (sum([1]) + sum([3,1]) + sum([5,3,1]) + sum([1,2]) + sum([3,1,2]) + sum([5,3,1,2]))\\n\\nSo how do we find this \\u201Csum of sums\\u201D, given that we know the left most element that < 1 is at index -1 (means non-existent), and the rightmost element that is \\u2264 1 is at index 4 (means non-existent)?\\n\\nLee\\u2019s Solution: prefix of prefix sums, which is the \\u201Cacc\\u201D variable in his code.\\nFor our example, \\u201Cacc\\u201D is [0, 5, 13, 22, 33]. Let\\u2019s see which each element really means:\\n5 = (5)\\n13 = (5) + (5+3)\\n22 = (5) + (5+3) + (5+3+1)\\n33 = (5) + (5+3) + (5+3+1) + (5+3+1+2)\\n\\nSo how do we tie these parts together?\\nNote that in our example, there is a 2 larger numbers to 1\\u2019s left, and 1 larger number to 1\\u2019s right. This can be generalized into a pattern: if there are x larger numbers to the left to 1, and y larger numbers to its right: when we fix x, there can be y + 1 combinations on the right, or when we fix y, there can be x + 1 combinations on the left.\\n\\nKey: The way I understand it is that we are trying to build a \\u201Ctemplate\\u201D first, then cancel out some of numbers.\\n\\nFirst we do 33 \\u2013 13. Why? Look at the underlying.\\n33 \\u2013 13 = [(5) + (5+3) + (5+3+1) + (5+3+1+2)] \\u2013 [(5) + (5+3)] = [(5+3+1) + (5+3+1+2)]\\nWe are looking at 1 right now, so we don\\u2019t want to consider any subarray that doesn\\u2019t contain 1. Note this 20 is sum of 2 subarray sums.\\n\\nNext, we use 20 * 3. Why? Because we are trying to create a \\u201Ctemplate\\u201D here. Notice how because of the generalized pattern above, we will have 6 combinations (we can fix x to be 0 / 1 / 2, and y can be 0 / 1. For example, when x=0 and y=0, our combination is [1], or when x=2, y=0, our combination is [5,3,1]). Since 20 is sum of 2 subarray sums, and we want 6 combinations, we duplicate 20 3 times. So we now have:\\n[(5+3+1) + (5+3+1+2)]\\n[(5+3+1) + (5+3+1+2)]\\n[(5+3+1) + (5+3+1+2)]\\n\\nNext, we do 13 \\u2013 0. Look at the underlying.\\n13 \\u2013 0 = (5) + (5+3)\\n\\nThen 13 * 2. Now you might think why 2 not 3 (because 13 is sum of 2 subarrays), right? Proceed and I will explain it later:\\n\\nFinally, 20 * 3 - 13 * 2. Visually, this can be understood as follows:\\n[(<s>**5+3**</s>+1) + (<s>**5+3**</s>+1+2)]\\n[(<s>**5**</s>+3+1) + (<s>**5**</s>+3+1+2)]\\n[(5+3+1) + (5+3+1+2)].\\nNote that while the same cancellation strategy is applied horizontally, each 13 is the group of subarrays used for cancellation vertically. So how many 13 will we use? Depends on how many columns we have, which in turn 1 + number of bigger numbers to its right.\\n\\nThen you might ask, if we do \\u201Cracc * ln - lacc * rn\\u201D, does that mean \\u201Cln\\u201D always has to be \\u2265 \\u201Crn\\u201D? No, repeat the above for [5,1,3,2], and we can get the following cancellation outcome.\\n[(<s>**5**</s>+1) + (<s>**5**</s>+1+3) + (<s>**5**</s>+1+3+2)]\\n[(5+1) + (5+1+3) + (5+1+3+2)]\\n"
                    },
                    {
                        "username": "aalmos",
                        "content": "Am I the only one who thinks this problem is ridiculously hard? How the hell I\\'m supposed to figure out during a live interview session that the sum of all subarrays between `i` and `j` can be derived from a dual rolling sum?"
                    },
                    {
                        "username": "who_rules",
                        "content": "if the guy from google with 800 solved problems thinks so, I feel safe"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Finesse](/Finesse) this question is in Amazon interviews with high frequency."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is basically calculating the space of a shape under a function using the integral. Something from school math. The function is the prefix/suffix sum, the second prefix/suffix sum is its integral.\\n\\nBut I agree that this question is very hard. For this reason it\\'s very unlikely to be asked on an interview. And nobody claims that every LeetCode problem is asked on interviews."
                    },
                    {
                        "username": "entitled_american",
                        "content": "savant difficulty"
                    },
                    {
                        "username": "Mike1498",
                        "content": "This is one of the hardest hard problems i have come across. Yikes "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "I\\'ll literally cry if this problem appears in an interview/OA. Took me 3 hours. "
                    },
                    {
                        "username": "shuhulkaul",
                        "content": "How is output for testcase [2000000] is 999972007?"
                    },
                    {
                        "username": "Finesse",
                        "content": "`2000000^2 % 1000000007`"
                    },
                    {
                        "username": "shuhulkaul",
                        "content": "stupid modulo!"
                    },
                    {
                        "username": "mkahraman82",
                        "content": "why the test code is not passing? \n1- found all the subarrays\n2-multiplied min value and total value of sub arrays and found total value\n \n`class Solution:\n    def totalStrength(self, strength: List[int]) -> int:\n        l=[[]]\n        res=[]\n        #find all sub-arrays\n        for i in range(len(strength)+1):\n            for j in range(i):\n                l.append(strength[j:i])\n\n        #min value * total value of subarrays       \n        for i in range(1,len(l)):\n            res.append(min(l[i])*sum(l[i]))\n\n\n        return sum(res)`"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it takes `O(n³)` time. It's too much for 10⁵ input elements. On LeetCode, input size 10⁵ implies a solution that takes `O(n)` or `O(n*ln(n))` time."
                    },
                    {
                        "username": "Finesse",
                        "content": "Solution for this problem requires a crazy 4D imagination. I managed to solve it by myself, but my brain almost exploded \\uD83E\\uDD2F"
                    }
                ]
            },
            {
                "id": 1942022,
                "content": [
                    {
                        "username": "DugMJD",
                        "content": "![image](https://assets.leetcode.com/users/images/94ac9010-57fc-44e5-93b3-e3ceda88a3cb_1653193278.7448575.jpeg)\\n\\n1. https://leetcode.com/discuss/interview-question/1729637/amazon-new-grad-role-2022/\\n2. https://leetcode.com/discuss/interview-question/1736639/Solution-to-Amazon-OA-2022-problem-Sum-of-Scores-of-Subarray"
                    },
                    {
                        "username": "jinyang_deng",
                        "content": "[Original Post](https://leetcode.com/problems/sum-of-total-strength-of-wizards/discuss/2061985/Python-Solution-O(n))\\n\\nThe monotonic stack is self-explanatory. Just explaining \"(racc * ln - lacc * rn)\" in greater detail:\\n\\nSay our input is [5,3,1,2]\\n\\nUsing monotonic stack, Left is [-1, -1, -1, 2], Right is [1, 2, 4, 4].\\n\\nNow look at the 1 (at input array, index 2), it is the minimum for the [1], [3, 1], [5, 3, 1], [1, 2], [3, 1, 2], [5, 3, 1, 2]. So its \\u201Ccontribution\\u201D to the final result will be as follows:\\n1 * (sum([1]) + sum([3,1]) + sum([5,3,1]) + sum([1,2]) + sum([3,1,2]) + sum([5,3,1,2]))\\n\\nSo how do we find this \\u201Csum of sums\\u201D, given that we know the left most element that < 1 is at index -1 (means non-existent), and the rightmost element that is \\u2264 1 is at index 4 (means non-existent)?\\n\\nLee\\u2019s Solution: prefix of prefix sums, which is the \\u201Cacc\\u201D variable in his code.\\nFor our example, \\u201Cacc\\u201D is [0, 5, 13, 22, 33]. Let\\u2019s see which each element really means:\\n5 = (5)\\n13 = (5) + (5+3)\\n22 = (5) + (5+3) + (5+3+1)\\n33 = (5) + (5+3) + (5+3+1) + (5+3+1+2)\\n\\nSo how do we tie these parts together?\\nNote that in our example, there is a 2 larger numbers to 1\\u2019s left, and 1 larger number to 1\\u2019s right. This can be generalized into a pattern: if there are x larger numbers to the left to 1, and y larger numbers to its right: when we fix x, there can be y + 1 combinations on the right, or when we fix y, there can be x + 1 combinations on the left.\\n\\nKey: The way I understand it is that we are trying to build a \\u201Ctemplate\\u201D first, then cancel out some of numbers.\\n\\nFirst we do 33 \\u2013 13. Why? Look at the underlying.\\n33 \\u2013 13 = [(5) + (5+3) + (5+3+1) + (5+3+1+2)] \\u2013 [(5) + (5+3)] = [(5+3+1) + (5+3+1+2)]\\nWe are looking at 1 right now, so we don\\u2019t want to consider any subarray that doesn\\u2019t contain 1. Note this 20 is sum of 2 subarray sums.\\n\\nNext, we use 20 * 3. Why? Because we are trying to create a \\u201Ctemplate\\u201D here. Notice how because of the generalized pattern above, we will have 6 combinations (we can fix x to be 0 / 1 / 2, and y can be 0 / 1. For example, when x=0 and y=0, our combination is [1], or when x=2, y=0, our combination is [5,3,1]). Since 20 is sum of 2 subarray sums, and we want 6 combinations, we duplicate 20 3 times. So we now have:\\n[(5+3+1) + (5+3+1+2)]\\n[(5+3+1) + (5+3+1+2)]\\n[(5+3+1) + (5+3+1+2)]\\n\\nNext, we do 13 \\u2013 0. Look at the underlying.\\n13 \\u2013 0 = (5) + (5+3)\\n\\nThen 13 * 2. Now you might think why 2 not 3 (because 13 is sum of 2 subarrays), right? Proceed and I will explain it later:\\n\\nFinally, 20 * 3 - 13 * 2. Visually, this can be understood as follows:\\n[(<s>**5+3**</s>+1) + (<s>**5+3**</s>+1+2)]\\n[(<s>**5**</s>+3+1) + (<s>**5**</s>+3+1+2)]\\n[(5+3+1) + (5+3+1+2)].\\nNote that while the same cancellation strategy is applied horizontally, each 13 is the group of subarrays used for cancellation vertically. So how many 13 will we use? Depends on how many columns we have, which in turn 1 + number of bigger numbers to its right.\\n\\nThen you might ask, if we do \\u201Cracc * ln - lacc * rn\\u201D, does that mean \\u201Cln\\u201D always has to be \\u2265 \\u201Crn\\u201D? No, repeat the above for [5,1,3,2], and we can get the following cancellation outcome.\\n[(<s>**5**</s>+1) + (<s>**5**</s>+1+3) + (<s>**5**</s>+1+3+2)]\\n[(5+1) + (5+1+3) + (5+1+3+2)]\\n"
                    },
                    {
                        "username": "aalmos",
                        "content": "Am I the only one who thinks this problem is ridiculously hard? How the hell I\\'m supposed to figure out during a live interview session that the sum of all subarrays between `i` and `j` can be derived from a dual rolling sum?"
                    },
                    {
                        "username": "who_rules",
                        "content": "if the guy from google with 800 solved problems thinks so, I feel safe"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Finesse](/Finesse) this question is in Amazon interviews with high frequency."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is basically calculating the space of a shape under a function using the integral. Something from school math. The function is the prefix/suffix sum, the second prefix/suffix sum is its integral.\\n\\nBut I agree that this question is very hard. For this reason it\\'s very unlikely to be asked on an interview. And nobody claims that every LeetCode problem is asked on interviews."
                    },
                    {
                        "username": "entitled_american",
                        "content": "savant difficulty"
                    },
                    {
                        "username": "Mike1498",
                        "content": "This is one of the hardest hard problems i have come across. Yikes "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "I\\'ll literally cry if this problem appears in an interview/OA. Took me 3 hours. "
                    },
                    {
                        "username": "shuhulkaul",
                        "content": "How is output for testcase [2000000] is 999972007?"
                    },
                    {
                        "username": "Finesse",
                        "content": "`2000000^2 % 1000000007`"
                    },
                    {
                        "username": "shuhulkaul",
                        "content": "stupid modulo!"
                    },
                    {
                        "username": "mkahraman82",
                        "content": "why the test code is not passing? \n1- found all the subarrays\n2-multiplied min value and total value of sub arrays and found total value\n \n`class Solution:\n    def totalStrength(self, strength: List[int]) -> int:\n        l=[[]]\n        res=[]\n        #find all sub-arrays\n        for i in range(len(strength)+1):\n            for j in range(i):\n                l.append(strength[j:i])\n\n        #min value * total value of subarrays       \n        for i in range(1,len(l)):\n            res.append(min(l[i])*sum(l[i]))\n\n\n        return sum(res)`"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it takes `O(n³)` time. It's too much for 10⁵ input elements. On LeetCode, input size 10⁵ implies a solution that takes `O(n)` or `O(n*ln(n))` time."
                    },
                    {
                        "username": "Finesse",
                        "content": "Solution for this problem requires a crazy 4D imagination. I managed to solve it by myself, but my brain almost exploded \\uD83E\\uDD2F"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Profit From Trading Stocks",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 2009091,
                "content": [
                    {
                        "username": "DivisionAgent",
                        "content": "Remove all data that profit less than or equal 0 first made me passed the MLE."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "**Question:** The following python code is giving MLE. \n\n<details><summary> On clicking here, a correct code will appear which isn't memory efficient </summary>\n\n<p>\n<br>\n\n```python3\nclass Solution:\n    def maximumProfit(self, present: List[int], future: List[int], budget: int) -> int:\n        \n        N = len(present)\n\n        dp = {}\n\n        def profit(idx, currentMoney):\n            \n            if idx == N or currentMoney < 0:\n                return 0\n            \n            if (idx, currentMoney) in dp:\n                return dp[(idx, currentMoney)]\n\n            notBuy = profit(idx + 1, currentMoney)\n            if currentMoney >= present[idx]:\n                buy = future[idx] - present[idx] + profit(idx + 1, currentMoney - present[idx])\n            else:\n                buy = 0\n            \n            dp[(idx, currentMoney)] = max(buy, notBuy)\n            return dp[(idx, currentMoney)] \n        \n        return profit(0, budget)\n```\n</p></details><br>\n\nAny advice on how to **optimize** it further? Using `cache` and `lru_cache(None)` are also giving MLE. The iterative version of the same was accepted.\n\n"
                    },
                    {
                        "username": "beninbf",
                        "content": "Try using a dynammic programming approach"
                    }
                ]
            },
            {
                "id": 1941488,
                "content": [
                    {
                        "username": "DivisionAgent",
                        "content": "Remove all data that profit less than or equal 0 first made me passed the MLE."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "**Question:** The following python code is giving MLE. \n\n<details><summary> On clicking here, a correct code will appear which isn't memory efficient </summary>\n\n<p>\n<br>\n\n```python3\nclass Solution:\n    def maximumProfit(self, present: List[int], future: List[int], budget: int) -> int:\n        \n        N = len(present)\n\n        dp = {}\n\n        def profit(idx, currentMoney):\n            \n            if idx == N or currentMoney < 0:\n                return 0\n            \n            if (idx, currentMoney) in dp:\n                return dp[(idx, currentMoney)]\n\n            notBuy = profit(idx + 1, currentMoney)\n            if currentMoney >= present[idx]:\n                buy = future[idx] - present[idx] + profit(idx + 1, currentMoney - present[idx])\n            else:\n                buy = 0\n            \n            dp[(idx, currentMoney)] = max(buy, notBuy)\n            return dp[(idx, currentMoney)] \n        \n        return profit(0, budget)\n```\n</p></details><br>\n\nAny advice on how to **optimize** it further? Using `cache` and `lru_cache(None)` are also giving MLE. The iterative version of the same was accepted.\n\n"
                    },
                    {
                        "username": "beninbf",
                        "content": "Try using a dynammic programming approach"
                    }
                ]
            }
        ]
    }
]