[
    {
        "title": "Spiral Matrix II",
        "question_content": "Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.\n&nbsp;\nExample 1:\n\nInput: n = 3\nOutput: [[1,2,3],[8,9,4],[7,6,5]]\n\nExample 2:\n\nInput: n = 1\nOutput: [[1]]\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 20",
        "solutions": [
            {
                "id": 22282,
                "title": "4-9-lines-python-solutions",
                "content": "**Solution 1: *Build it inside-out*** - 44 ms, 5 lines\\n\\nStart with the empty matrix, add the numbers in reverse order until we added the number 1. Always rotate the matrix clockwise and add a top row:\\n\\n        ||  =>  |9|  =>  |8|      |6 7|      |4 5|      |1 2 3|\\n                         |9|  =>  |9 8|  =>  |9 6|  =>  |8 9 4|\\n                                             |8 7|      |7 6 5|\\n\\nThe code:\\n\\n    def generateMatrix(self, n):\\n        A, lo = [], n*n+1\\n        while lo > 1:\\n            lo, hi = lo - len(A), lo\\n            A = [range(lo, hi)] + zip(*A[::-1])\\n        return A\\n\\nWhile this isn't O(n^2), it's actually quite fast, presumably due to me not doing much in Python but relying on `zip` and `range` and `+` being fast. I got it accepted in 44 ms, matching the fastest time for recent Python submissions (according to the submission detail page).\\n\\n---\\n\\n**Solution 2: *Ugly inside-out*** - 48 ms, 4 lines\\n\\nSame as solution 1, but without helper variables. Saves a line, but makes it ugly. Also, because I access A[0][0], I had to handle the n=0 case differently.\\n\\n    def generateMatrix(self, n):\\n        A = [[n*n]]\\n        while A[0][0] > 1:\\n            A = [range(A[0][0] - len(A), A[0][0])] + zip(*A[::-1])\\n        return A * (n>0)\\n\\n---\\n\\n**Solution 3: *Walk the spiral*** - 52 ms, 9 lines\\n\\nInitialize the matrix with zeros, then walk the spiral path and write the numbers 1 to n*n. Make a right turn when the cell ahead is already non-zero.\\n\\n    def generateMatrix(self, n):\\n        A = [[0] * n for _ in range(n)]\\n        i, j, di, dj = 0, 0, 0, 1\\n        for k in xrange(n*n):\\n            A[i][j] = k + 1\\n            if A[(i+di)%n][(j+dj)%n]:\\n                di, dj = dj, -di\\n            i += di\\n            j += dj\\n        return A",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Solution 1: *Build it inside-out*** - 44 ms, 5 lines\\n\\nStart with the empty matrix, add the numbers in reverse order until we added the number 1. Always rotate the matrix clockwise and add a top row:\\n\\n        ||  =>  |9|  =>  |8|      |6 7|      |4 5|      |1 2 3|\\n                         |9|  =>  |9 8|  =>  |9 6|  =>  |8 9 4|\\n                                             |8 7|      |7 6 5|\\n\\nThe code:\\n\\n    def generateMatrix(self, n):\\n        A, lo = [], n*n+1\\n        while lo > 1:\\n            lo, hi = lo - len(A), lo\\n            A = [range(lo, hi)] + zip(*A[::-1])\\n        return A\\n\\nWhile this isn't O(n^2), it's actually quite fast, presumably due to me not doing much in Python but relying on `zip` and `range` and `+` being fast. I got it accepted in 44 ms, matching the fastest time for recent Python submissions (according to the submission detail page).\\n\\n---\\n\\n**Solution 2: *Ugly inside-out*** - 48 ms, 4 lines\\n\\nSame as solution 1, but without helper variables. Saves a line, but makes it ugly. Also, because I access A[0][0], I had to handle the n=0 case differently.\\n\\n    def generateMatrix(self, n):\\n        A = [[n*n]]\\n        while A[0][0] > 1:\\n            A = [range(A[0][0] - len(A), A[0][0])] + zip(*A[::-1])\\n        return A * (n>0)\\n\\n---\\n\\n**Solution 3: *Walk the spiral*** - 52 ms, 9 lines\\n\\nInitialize the matrix with zeros, then walk the spiral path and write the numbers 1 to n*n. Make a right turn when the cell ahead is already non-zero.\\n\\n    def generateMatrix(self, n):\\n        A = [[0] * n for _ in range(n)]\\n        i, j, di, dj = 0, 0, 0, 1\\n        for k in xrange(n*n):\\n            A[i][j] = k + 1\\n            if A[(i+di)%n][(j+dj)%n]:\\n                di, dj = dj, -di\\n            i += di\\n            j += dj\\n        return A",
                "codeTag": "Python3"
            },
            {
                "id": 22289,
                "title": "my-super-simple-solution-can-be-used-for-both-spiral-matrix-i-and-ii",
                "content": "This is my solution for Spiral Matrix I, [https://oj.leetcode.com/discuss/12228/super-simple-and-easy-to-understand-solution][1]. If you can understand that, this one is a no brainer :)\\n\\nGuess what? I just made several lines of change (with comment \"//change\") from that and I have the following AC code:\\n\\n    public class Solution {\\n        public int[][] generateMatrix(int n) {\\n            // Declaration\\n            int[][] matrix = new int[n][n];\\n            \\n            // Edge Case\\n            if (n == 0) {\\n                return matrix;\\n            }\\n            \\n            // Normal Case\\n            int rowStart = 0;\\n            int rowEnd = n-1;\\n            int colStart = 0;\\n            int colEnd = n-1;\\n            int num = 1; //change\\n            \\n            while (rowStart <= rowEnd && colStart <= colEnd) {\\n                for (int i = colStart; i <= colEnd; i ++) {\\n                    matrix[rowStart][i] = num ++; //change\\n                }\\n                rowStart ++;\\n                \\n                for (int i = rowStart; i <= rowEnd; i ++) {\\n                    matrix[i][colEnd] = num ++; //change\\n                }\\n                colEnd --;\\n                \\n                for (int i = colEnd; i >= colStart; i --) {\\n                    if (rowStart <= rowEnd)\\n                        matrix[rowEnd][i] = num ++; //change\\n                }\\n                rowEnd --;\\n                \\n                for (int i = rowEnd; i >= rowStart; i --) {\\n                    if (colStart <= colEnd)\\n                        matrix[i][colStart] = num ++; //change\\n                }\\n                colStart ++;\\n            }\\n            \\n            return matrix;\\n        }\\n    }\\n\\nObviously, you could merge colStart and colEnd into rowStart and rowEnd because it is a square matrix. But this is easily extensible to matrices that are m*n.\\n\\nHope this helps :)\\n\\n\\n  [1]: https://oj.leetcode.com/discuss/12228/super-simple-and-easy-to-understand-solution",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int[][] generateMatrix(int n) {\\n            // Declaration\\n            int[][] matrix = new int[n][n];\\n            \\n            // Edge Case\\n            if (n == 0) {\\n                return matrix;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 963128,
                "title": "python-rotate-when-need-explained",
                "content": "Let us notice one clue property about our spiral matrix: first we need to go to the right and rotate clockwise 90 degrees, then we go down and again when we reached bottom, we rotate 90 degrees clockwise and so on. So, all we need to do is to rotate 90 degrees clockwise when we need:\\n1. When we reached border of our matrix\\n2. When we reached cell which is already filled.\\n\\nLet `x, y` be coordinates on our `grid` and `dx, dy` is current direction we need to move. In geometrical sense, rotate by `90` degrees clockwise is written as `dx, dy = -dy, dx`.\\n\\nNote, that `matrix[y][x]` is cell with coordinates `(x,y)`, which is not completely obvious.\\n\\n**Complexity**: time complexity is `O(n^2)`, we process each element once. Space complexity is `O(n^2)` as well.\\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n):\\n        matrix = [[0] * n for _ in range(n)]\\n        x, y, dx, dy = 0, 0, 1, 0\\n        for i in range(n*n):\\n            matrix[y][x] = i + 1\\n            if not 0 <= x + dx < n or not 0 <= y + dy < n or matrix[y+dy][x+dx] != 0:\\n                dx, dy = -dy, dx\\n            x, y = x + dx, y + dy\\n        return matrix\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n):\\n        matrix = [[0] * n for _ in range(n)]\\n        x, y, dx, dy = 0, 0, 1, 0\\n        for i in range(n*n):\\n            matrix[y][x] = i + 1\\n            if not 0 <= x + dx < n or not 0 <= y + dy < n or matrix[y+dy][x+dx] != 0:\\n                dx, dy = -dy, dx\\n            x, y = x + dx, y + dy\\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22309,
                "title": "simple-c-solution-with-explaination",
                "content": "   \\n    class Solution {\\n        public:\\n            vector<vector<int> > generateMatrix(int n) {\\n                vector<vector<int> > ret( n, vector<int>(n) );\\n            \\tint k = 1, i = 0;\\n            \\twhile( k <= n * n )\\n            \\t{\\n            \\t\\tint j = i;\\n                        // four steps\\n            \\t\\twhile( j < n - i )             // 1. horizonal, left to right\\n            \\t\\t\\tret[i][j++] = k++;\\n            \\t\\tj = i + 1;\\n            \\t\\twhile( j < n - i )             // 2. vertical, top to bottom\\n            \\t\\t\\tret[j++][n-i-1] = k++;\\n            \\t\\tj = n - i - 2;\\n            \\t\\twhile( j > i )                  // 3. horizonal, right to left \\n            \\t\\t\\tret[n-i-1][j--] = k++;\\n            \\t\\tj = n - i - 1;\\n            \\t\\twhile( j > i )                  // 4. vertical, bottom to  top \\n            \\t\\t\\tret[j--][i] = k++;\\n            \\t\\ti++;      // next loop\\n            \\t}\\n            \\treturn ret;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            vector<vector<int> > generateMatrix(int n) {\\n                vector<vector<int> > ret( n, vector<int>(n) );\\n            \\tint k = 1, i = 0;\\n            \\twhile( k <= n * n )\\n            \\t{\\n            \\t\\tint j = i;\\n                        // four steps\\n            \\t\\twhile( j < n - i )             // 1. horizonal, left to right\\n            \\t\\t\\tret[i][j++] = k++;\\n            \\t\\tj = i + 1;\\n            \\t\\twhile( j < n - i )             // 2. vertical, top to bottom\\n            \\t\\t\\tret[j++][n-i-1] = k++;\\n            \\t\\tj = n - i - 2;\\n            \\t\\twhile( j > i )                  // 3. horizonal, right to left \\n            \\t\\t\\tret[n-i-1][j--] = k++;\\n            \\t\\tj = n - i - 1;\\n            \\t\\twhile( j > i )                  // 4. vertical, bottom to  top \\n            \\t\\t\\tret[j--][i] = k++;\\n            \\t\\ti++;      // next loop\\n            \\t}",
                "codeTag": "Java"
            },
            {
                "id": 1941068,
                "title": "c-0ms-100-easy-to-understand",
                "content": "# 59. Spiral Matrix II\\n**KNOCKCAT**\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Please Upvote if it helps\\u2B06\\uFE0F\\n5. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t//\\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n\\n[LeetCode](http://github.com/knockcat/Leetcode) **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**ALGORITHM**\\n* We **have to fill the matrix layer by layer in four direction**.\\n* From **left to right** \\u27A1\\uFE0F:\\n\\t*  the **row will remain constant** while **column is updated till reaches n-1**.\\n* From **Top to bottom** \\u2B07\\uFE0F(moving down)\\n\\t* The **column will remain constant as n-1** and **we will start filling from r1 + 1**, as first row is filled in previous step & row will be updated.\\n* From **right to left** \\u2B05\\uFE0F\\n\\t* we will **start filling from c2 - 1 because c2 is filled in previous step**.\\n\\t* so the **row will be fixed** and c2 will be updated from c2-1 till its greater than c1.\\n* From **botom to up** \\u2B06\\uFE0F (move up)\\n\\t* the **column will be fixed as c1** while row will be updated form r2 till it greater than r1.\\n* After that we will **updates the row and column pointers, as now we will have to fill the inner layers.**\\n\\n**ANALYSIS -:**\\n* TIME COMPLEXITY = **O(N^2)**\\n* SPACE COMPLEXITY = **O(1)**\\n\\n**CODE WITH EXPLANATION**\\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int r1 = 0, r2 = n-1;\\n        int c1 = 0, c2 = n-1;\\n        int val = 0;\\n\\t\\t\\n\\t\\t// result matrix\\n        vector<vector<int>> v(n, vector<int> (n));\\n        while(r1 <= r2 && c1 <= c2)\\n        {\\n            // left to right (row will be fixed)\\n            for(int i = c1; i <= c2; ++i)\\n                v[r1][i] = ++val;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// move down(col will be fixed)\\n            for(int i = r1+1; i <= r2; ++i)\\n                v[i][c2] = ++val;\\n\\t\\t\\t\\t\\n            // move right to left\\n            // move  up\\n            if(r1 < r2 && c1 < c2)\\n            {\\n                // move right to left (row will be fixed)\\n                for(int i = c2-1; i>c1; --i)\\n                    v[r2][i] = ++val;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// move up (col will be fixed)\\n\\t\\t\\t\\t\\tfor(int i = r2; i>r1; --i) \\n                    v[i][c1] = ++val;\\n            }\\n            ++r1;\\n            --r2;\\n            ++c1;\\n            --c2;\\n        }\\n        return v;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Please Upvote if it helps\\u2B06\\uFE0F\\n5. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t//\\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int r1 = 0, r2 = n-1;\\n        int c1 = 0, c2 = n-1;\\n        int val = 0;\\n\\t\\t\\n\\t\\t// result matrix\\n        vector<vector<int>> v(n, vector<int> (n));\\n        while(r1 <= r2 && c1 <= c2)\\n        {\\n            // left to right (row will be fixed)\\n            for(int i = c1; i <= c2; ++i)\\n                v[r1][i] = ++val;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// move down(col will be fixed)\\n            for(int i = r1+1; i <= r2; ++i)\\n                v[i][c2] = ++val;\\n\\t\\t\\t\\t\\n            // move right to left\\n            // move  up\\n            if(r1 < r2 && c1 < c2)\\n            {\\n                // move right to left (row will be fixed)\\n                for(int i = c2-1; i>c1; --i)\\n                    v[r2][i] = ++val;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// move up (col will be fixed)\\n\\t\\t\\t\\t\\tfor(int i = r2; i>r1; --i) \\n                    v[i][c1] = ++val;\\n            }\\n            ++r1;\\n            --r2;\\n            ++c1;\\n            --c2;\\n        }\\n        return v;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22290,
                "title": "python-easy-to-follow-solution",
                "content": "        \\n    def generateMatrix(self, n):\\n        if not n:\\n            return []\\n        res = [[0 for _ in xrange(n)] for _ in xrange(n)]\\n        left, right, top, down, num = 0, n-1, 0, n-1, 1\\n        while left <= right and top <= down:\\n            for i in xrange(left, right+1):\\n                res[top][i] = num \\n                num += 1\\n            top += 1\\n            for i in xrange(top, down+1):\\n                res[i][right] = num\\n                num += 1\\n            right -= 1\\n            for i in xrange(right, left-1, -1):\\n                res[down][i] = num\\n                num += 1\\n            down -= 1\\n            for i in xrange(down, top-1, -1):\\n                res[i][left] = num\\n                num += 1\\n            left += 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def generateMatrix(self, n):\\n        if not n:\\n            return []\\n        res = [[0 for _ in xrange(n)] for _ in xrange(n)]\\n        left, right, top, down, num = 0, n-1, 0, n-1, 1\\n        while left <= right and top <= down:\\n            for i in xrange(left, right+1):\\n                res[top][i] = num \\n                num += 1\\n            top += 1\\n            for i in xrange(top, down+1):\\n                res[i][right] = num\\n                num += 1\\n            right -= 1\\n            for i in xrange(right, left-1, -1):\\n                res[down][i] = num\\n                num += 1\\n            down -= 1\\n            for i in xrange(down, top-1, -1):\\n                res[i][left] = num\\n                num += 1\\n            left += 1\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 22292,
                "title": "share-my-java-solution",
                "content": "    public static int[][] generateMatrix(int n) {\\n\\t\\tint[][] ret = new int[n][n];\\n\\t\\tint left = 0,top = 0;\\n\\t\\tint right = n -1,down = n - 1;\\n\\t\\tint count = 1;\\n\\t\\twhile (left <= right) {\\n\\t\\t\\tfor (int j = left; j <= right; j ++) {\\n\\t\\t\\t\\tret[top][j] = count++;\\n\\t\\t\\t}\\n\\t\\t\\ttop ++;\\n\\t\\t\\tfor (int i = top; i <= down; i ++) {\\n\\t\\t\\t\\tret[i][right] = count ++;\\n\\t\\t\\t}\\n\\t\\t\\tright --;\\n\\t\\t\\tfor (int j = right; j >= left; j --) {\\n\\t\\t\\t\\tret[down][j] = count ++;\\n\\t\\t\\t}\\n\\t\\t\\tdown --;\\n\\t\\t\\tfor (int i = down; i >= top; i --) {\\n\\t\\t\\t\\tret[i][left] = count ++;\\n\\t\\t\\t}\\n\\t\\t\\tleft ++;\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public static int[][] generateMatrix(int n) {\\n\\t\\tint[][] ret = new int[n][n];\\n\\t\\tint left = 0,top = 0;\\n\\t\\tint right = n -1,down = n - 1;\\n\\t\\tint count = 1;\\n\\t\\twhile (left <= right) {\\n\\t\\t\\tfor (int j = left; j <= right; j ++) {\\n\\t\\t\\t\\tret[top][j] = count++;\\n\\t\\t\\t}\\n\\t\\t\\ttop ++;\\n\\t\\t\\tfor (int i = top; i <= down; i ++) {\\n\\t\\t\\t\\tret[i][right] = count ++;\\n\\t\\t\\t}\\n\\t\\t\\tright --;\\n\\t\\t\\tfor (int j = right; j >= left; j --) {\\n\\t\\t\\t\\tret[down][j] = count ++;\\n\\t\\t\\t}\\n\\t\\t\\tdown --;\\n\\t\\t\\tfor (int i = down; i >= top; i --) {\\n\\t\\t\\t\\tret[i][left] = count ++;\\n\\t\\t\\t}\\n\\t\\t\\tleft ++;\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 22454,
                "title": "simple-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int> > generateMatrix(int n) {\\n            vector<vector<int> > vv(n, vector<int>(n));\\n        \\n            int rowStart = 0, rowEnd = n - 1;\\n            int colStart = 0, colEnd = n - 1;\\n            int cnt = 1;\\n        \\n            while(rowStart <= rowEnd && colStart <= colEnd)\\n            {\\n                for(int i = colStart; i<= colEnd; i++)\\n                    vv[rowStart][i] = cnt++;\\n                rowStart++;\\n            \\n                for(int i = rowStart; i<= rowEnd; i++)\\n                    vv[i][colEnd] = cnt++;\\n                colEnd--;\\n            \\n                for(int i = colEnd; i>= colStart; i--)\\n                    vv[rowEnd][i] = cnt++;\\n                rowEnd--;\\n            \\n                for(int i = rowEnd; i>= rowStart; i--)\\n                    vv[i][colStart] = cnt++;\\n                colStart++;\\n            }\\n        \\n            return vv;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > generateMatrix(int n) {\\n            vector<vector<int> > vv(n, vector<int>(n));\\n        \\n            int rowStart = 0, rowEnd = n - 1;\\n            int colStart = 0, colEnd = n - 1;\\n            int cnt = 1;\\n        \\n            while(rowStart <= rowEnd && colStart <= colEnd)\\n            {\\n                for(int i = colStart; i<= colEnd; i++)\\n                    vv[rowStart][i] = cnt++;\\n                rowStart++;\\n            \\n                for(int i = rowStart; i<= rowEnd; i++)\\n                    vv[i][colEnd] = cnt++;\\n                colEnd--;\\n            \\n                for(int i = colEnd; i>= colStart; i--)\\n                    vv[rowEnd][i] = cnt++;\\n                rowEnd--;\\n            \\n                for(int i = rowEnd; i>= rowStart; i--)\\n                    vv[i][colStart] = cnt++;\\n                colStart++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3506445,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers. I planned to give for next 10,000 Subscribers as well. If you\\'re interested **DON\\'T FORGET** to Subscribe\\n\\n# Search \\uD83D\\uDC49 `Tech Wired Leetcode` to Subscribe\\n\\n\\n# or\\n\\n# Click the Link in my Profile\\n\\n# Approach:\\n\\n- Initialize an empty matrix of size n x n with all elements set to zero.\\n- Define variables left, right, top, bottom, and num.\\n- Use a while loop to iterate over the matrix in a spiral order.\\n- In each iteration, fill in the top row, right column, bottom row, and left column of the remaining submatrix, in that order.\\n- Increment/decrement the values of left, right, top, and bottom accordingly after each iteration, and update the value of num to be filled in the next iteration.\\n- Return the generated matrix.\\n# Intuition:\\n\\nThe code generates the matrix by filling in its elements in a spiral order, starting from the top-left corner and moving clockwise. It uses the variables left, right, top, and bottom to keep track of the current submatrix being filled in, and the variable num to keep track of the next number to be filled in the matrix. The algorithm fills in the matrix in four steps:\\n\\n- Fill in the top row from left to right.\\n- Fill in the right column from top to bottom.\\n- Fill in the bottom row from right to left.\\n- Fill in the left column from bottom to top.\\n\\nAfter each step, the corresponding variable (left, right, top, or bottom) is incremented or decremented to exclude the already filled elements in the next iteration. The algorithm stops when the submatrix being filled in becomes empty, i.e., left > right or top > bottom. Finally, the generated matrix is returned.\\n\\n\\n```Python []\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        if not n:\\n            return []\\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\\n        left, right, top, bottom, num = 0, n-1, 0, n-1, 1\\n        while left <= right and top <= bottom:\\n            for i in range(left, right+1):\\n                matrix[top][i] = num \\n                num += 1\\n            top += 1\\n            for i in range(top, bottom+1):\\n                matrix[i][right] = num\\n                num += 1\\n            right -= 1\\n            if top <= bottom:\\n                for i in range(right, left-1, -1):\\n                    matrix[bottom][i] = num\\n                    num += 1\\n                bottom -= 1\\n            if left <= right:\\n                for i in range(bottom, top-1, -1):\\n                    matrix[i][left] = num\\n                    num += 1\\n                left += 1\\n        return matrix\\n\\n```\\n```Java []\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n == 0) {\\n            return new int[0][0];\\n        }\\n        int[][] matrix = new int[n][n];\\n        int left = 0, right = n-1, top = 0, bottom = n-1, num = 1;\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = num++;\\n            }\\n            top++;\\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = num++;\\n            }\\n            right--;\\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = num++;\\n                }\\n                bottom--;\\n            }\\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = num++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        if (n == 0) {\\n            return {};\\n        }\\n        vector<vector<int>> matrix(n, vector<int>(n, 0));\\n        int left = 0, right = n-1, top = 0, bottom = n-1, num = 1;\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = num++;\\n            }\\n            top++;\\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = num++;\\n            }\\n            right--;\\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = num++;\\n                }\\n                bottom--;\\n            }\\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = num++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```\\n# An Upvote will be encouraging \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array"
                ],
                "code": "```Python []\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        if not n:\\n            return []\\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\\n        left, right, top, bottom, num = 0, n-1, 0, n-1, 1\\n        while left <= right and top <= bottom:\\n            for i in range(left, right+1):\\n                matrix[top][i] = num \\n                num += 1\\n            top += 1\\n            for i in range(top, bottom+1):\\n                matrix[i][right] = num\\n                num += 1\\n            right -= 1\\n            if top <= bottom:\\n                for i in range(right, left-1, -1):\\n                    matrix[bottom][i] = num\\n                    num += 1\\n                bottom -= 1\\n            if left <= right:\\n                for i in range(bottom, top-1, -1):\\n                    matrix[i][left] = num\\n                    num += 1\\n                left += 1\\n        return matrix\\n\\n```\n```Java []\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n == 0) {\\n            return new int[0][0];\\n        }\\n        int[][] matrix = new int[n][n];\\n        int left = 0, right = n-1, top = 0, bottom = n-1, num = 1;\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = num++;\\n            }\\n            top++;\\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = num++;\\n            }\\n            right--;\\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = num++;\\n                }\\n                bottom--;\\n            }\\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = num++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        if (n == 0) {\\n            return {};\\n        }\\n        vector<vector<int>> matrix(n, vector<int>(n, 0));\\n        int left = 0, right = n-1, top = 0, bottom = n-1, num = 1;\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = num++;\\n            }\\n            top++;\\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = num++;\\n            }\\n            right--;\\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = num++;\\n                }\\n                bottom--;\\n            }\\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = num++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1468207,
                "title": "python-smart-simulate-by-marking-as-visited-super-clean-concise",
                "content": "**Idea**\\n- Initially, we move by the RIGHT direction.\\n- If we meet the boundary or we meet visited cell then we change to the next direction.\\n- Directions are in order [RIGHT, DOWN, LEFT, TOP].\\n- We iterate `n^2` times to fill `n^2` values to our answer.\\n\\n![image](https://assets.leetcode.com/users/images/8cc7cea1-b48b-48d2-9dfb-fbf541631d25_1631860276.5949159.png)\\n\\n```python\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        ans = [[0] * n for _ in range(n)]\\n        DIR = [0, 1, 0, -1, 0]  # (r + DIR[i], c + DIR[i+1]) corresponding to move [RIGHT, DOWN, LEFT, TOP]\\n        r, c = 0, 0  # start at cell (0, 0)\\n        d = 0  # start with RIGHT direction\\n        for num in range(1, n*n+1):\\n            nr, nc = r + DIR[d], c + DIR[d+1]\\n            if not 0 <= nr < n or not 0 <= nc < n or ans[nr][nc] != 0:  # If out of bound or already visited\\n                d = (d + 1) % 4  # Change next direction\\n                nr, nc = r + DIR[d], c + DIR[d+1]\\n                \\n            ans[r][c] = num\\n            r, c = nr, nc\\n        \\n        return ans\\n```\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 20` is length of side of the square matrix.\\n- Extra space (without couting output as space): `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        ans = [[0] * n for _ in range(n)]\\n        DIR = [0, 1, 0, -1, 0]  # (r + DIR[i], c + DIR[i+1]) corresponding to move [RIGHT, DOWN, LEFT, TOP]\\n        r, c = 0, 0  # start at cell (0, 0)\\n        d = 0  # start with RIGHT direction\\n        for num in range(1, n*n+1):\\n            nr, nc = r + DIR[d], c + DIR[d+1]\\n            if not 0 <= nr < n or not 0 <= nc < n or ans[nr][nc] != 0:  # If out of bound or already visited\\n                d = (d + 1) % 4  # Change next direction\\n                nr, nc = r + DIR[d], c + DIR[d+1]\\n                \\n            ans[r][c] = num\\n            r, c = nr, nc\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506760,
                "title": "day-405-brute-better-optimal-3-liner-0ms-100-python-java-c-explained",
                "content": "\\n\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n![image.png](https://assets.leetcode.com/users/images/6c06c3b7-3f00-49f3-8e49-5c21b8ef8460_1683686244.3385067.png)\\n\\n\\n# BRUTE\\nThe brute force solution to generate a matrix in spiral order is to simulate the process of filling the matrix in a spiral order. We can start by initializing the matrix with zeros and then fill the matrix in a spiral order by moving right, down, left, and up. We keep track of the current position in the matrix and the direction of movement. Whenever we reach the boundary of the matrix or encounter a non-zero element, we change the direction of movement. We continue this process until all the elements in the matrix are filled.\\n\\n```java []\\npublic int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int num = 1;\\n        int row = 0;\\n        int col = 0;\\n        int direction = 0;\\n        int[] dr = {0, 1, 0, -1};\\n        int[] dc = {1, 0, -1, 0};\\n        while (num <= n * n) {\\n            matrix[row][col] = num;\\n            num++;\\n            int nextRow = row + dr[direction];\\n            int nextCol = col + dc[direction];\\n            if (nextRow < 0 || nextRow >= n || nextCol < 0 || nextCol >= n || matrix[nextRow][nextCol] != 0) {\\n                direction = (direction + 1) % 4;\\n            }\\n            row += dr[direction];\\n            col += dc[direction];\\n        }\\n        return matrix;\\n    }\\n```\\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    int num = 1;\\n    int row = 0;\\n    int col = 0;\\n    int direction = 0;\\n    vector<int> dr = {0, 1, 0, -1};\\n    vector<int> dc = {1, 0, -1, 0};\\n    while (num <= n * n) {\\n        matrix[row][col] = num;\\n        num++;\\n        int nextRow = row + dr[direction];\\n        int nextCol = col + dc[direction];\\n        if (nextRow < 0 || nextRow >= n || nextCol < 0 || nextCol >= n || matrix[nextRow][nextCol] != 0) {\\n            direction = (direction + 1) % 4;\\n        }\\n        row += dr[direction];\\n        col += dc[direction];\\n    }\\n    return matrix;\\n}\\n```\\n```python []\\ndef generateMatrix(n: int) -> List[List[int]]:\\n    matrix = [[0] * n for _ in range(n)]\\n    num = 1\\n    row = 0\\n    col = 0\\n    direction = 0\\n    dr = [0, 1, 0, -1]\\n    dc = [1, 0, -1, 0]\\n    while num <= n * n:\\n        matrix[row][col] = num\\n        num += 1\\n        nextRow = row + dr[direction]\\n        nextCol = col + dc[direction]\\n        if nextRow < 0 or nextRow >= n or nextCol < 0 or nextCol >= n or matrix[nextRow][nextCol] != 0:\\n            direction = (direction + 1) % 4\\n        row += dr[direction]\\n        col += dc[direction]\\n    return matrix\\n```\\n# Complexity\\nThe time complexity of the brute force solution is O(n^2) because we need to fill all the elements in the matrix. The space complexity is also O(n^2)+2*O(1D) because we need to create a matrix of size n x n to store the elements and two direction 1D arrays.\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Better Solution:\\n\\nA better solution to generate a matrix in spiral order is to use a recursive approach. We can divide the matrix into four sub-matrices and fill each sub-matrix in a spiral order recursively. We start by filling the top row of the matrix, then fill the right column, then the bottom row, and finally the left column. We repeat this process for the remaining sub-matrix until all the elements in the matrix are filled.\\n\\n```java []\\npublic  int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        fillMatrix(matrix, 0, n - 1, 0, n - 1, 1);\\n        return matrix;\\n    }\\n\\n    public  void fillMatrix(int[][] matrix, int top, int bottom, int left, int right, int num) {\\n        if (top > bottom || left > right) {\\n            return;\\n        }\\n        for (int i = left; i <= right; i++) {\\n            matrix[top][i] = num;\\n            num++;\\n        }\\n        for (int i = top + 1; i <= bottom; i++) {\\n            matrix[i][right] = num;\\n            num++;\\n        }\\n        if (top < bottom && left < right) {\\n            for (int i = right - 1; i >= left; i--) {\\n                matrix[bottom][i] = num;\\n                num++;\\n            }\\n            for (int i = bottom - 1; i > top; i--) {\\n                matrix[i][left] = num;\\n                num++;\\n            }\\n        }\\n        fillMatrix(matrix, top + 1, bottom - 1, left + 1, right - 1, num);\\n    }\\n\\n```\\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    fillMatrix(matrix, 0, n - 1, 0, n - 1, 1);\\n    return matrix;\\n}\\n\\nvoid fillMatrix(vector<vector<int>>& matrix, int top, int bottom, int left, int right, int num) {\\n    if (top > bottom || left > right) {\\n        return;\\n    }\\n    for (int i = left; i <= right; i++) {\\n        matrix[top][i] = num;\\n        num++;\\n    }\\n    for (int i = top + 1; i <= bottom; i++) {\\n        matrix[i][right] = num;\\n        num++;\\n    }\\n    if (top < bottom && left < right) {\\n        for (int i = right - 1; i >= left; i--) {\\n            matrix[bottom][i] = num;\\n            num++;\\n        }\\n        for (int i = bottom - 1; i > top; i--) {\\n            matrix[i][left] = num;\\n            num++;\\n        }\\n    }\\n    fillMatrix(matrix, top + 1, bottom - 1, left + 1, right - 1, num);\\n}\\n```\\n```python []\\ndef generateMatrix(n: int) -> List[List[int]]:\\n    matrix = [[0] * n for _ in range(n)]\\n    fillMatrix(matrix, 0, n - 1, 0, n - 1, 1)\\n    return matrix\\n\\ndef fillMatrix(matrix: List[List[int]], top: int, bottom: int, left: int, right: int, num: int) -> None:\\n    if top > bottom or left > right:\\n        return\\n    for i in range(left, right + 1):\\n        matrix[top][i] = num\\n        num += 1\\n    for i in range(top + 1, bottom + 1):\\n        matrix[i][right] = num\\n        num += 1\\n    if top < bottom and left < right:\\n        for i in range(right - 1, left - 1, -1):\\n            matrix[bottom][i] = num\\n            num += 1\\n        for i in range(bottom - 1, top, -1):\\n            matrix[i][left] = num\\n            num += 1\\n    fillMatrix(matrix, top + 1, bottom - 1, left + 1, right - 1, num)\\n```\\n# Complexity\\nThe time complexity of the better solution is O(n^2) because we need to fill all the elements in the matrix. The space complexity is also O(n^2) because we need to create a matrix of size n x n to store the elements. However, the space complexity of the recursive approach is O(n2)+o(log n) because we use the call stack to store the recursive calls, which has a maximum depth of log n.\\n\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n\\n# optimal\\n\\n```java []\\npublic int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int top = 0;\\n        int bottom = n - 1;\\n        int left = 0;\\n        int right = n - 1;\\n        int num = 1;\\n        while (top <= bottom && left <= right) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = num;\\n                num++;\\n            }\\n            top++;\\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = num;\\n                num++;\\n            }\\n            right--;\\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = num;\\n                    num++;\\n                }\\n                bottom--;\\n            }\\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = num;\\n                    num++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n```\\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    int top = 0;\\n    int bottom = n - 1;\\n    int left = 0;\\n    int right = n - 1;\\n    int num = 1;\\n    while (top <= bottom && <= right) {\\n        for (int i = left; i <= right; i++) {\\n            matrix[top][i] = num;\\n            num++;\\n        }\\n        top++;\\n        for (int i = top; i <= bottom; i++) {\\n            matrix[i][right] = num;\\n            num++;\\n        }\\n        right--;\\n        if (top <= bottom) {\\n            for (int i = right; i >= left; i--) {\\n                matrix[bottom][i] = num;\\n                num++;\\n            }\\n            bottom--;\\n        }\\n        if (left <= right) {\\n            for (int i = bottom; i >= top; i--) {\\n                matrix[i][left] = num;\\n                num++;\\n            }\\n            left++;\\n        }\\n    }\\n    return matrix;\\n}\\n```\\n```python []\\ndef generateMatrix(n: int) -> List[List[int]]:\\n    matrix = [[0] * n for _ in range(n)]\\n    top = 0\\n    bottom = n - 1\\n    left = 0\\n    right = n - 1\\n    num = 1\\n    while top <= bottom and left <= right:\\n        for i in range(left, right + 1):\\n            matrix[top][i] = num\\n            num += 1\\n        top += 1\\n        for i in range(top, bottom + 1):\\n            matrix[i][right] = num\\n            num += 1\\n        right -= 1\\n        if top <= bottom:\\n            for i in range(right, left - 1, -1):\\n                matrix[bottom][i] = num\\n                num += 1\\n            bottom -= 1\\n        if left <= right:\\n            for i in range(bottom, top - 1, -1):\\n                matrix[i][left] = num\\n                num += 1\\n            left += 1\\n    return matrix\\n```\\n# Complexity\\nThe time complexity of the optimal solution is O(n^2) because we need to fill all the elements in the matrix. The space complexity is o(n2)+ O(1) because we only need to create a constant number of variables to store the boundaries of the matrix and the current number to fill.\\n\\nIn terms of time complexity, the optimal solution is the best because it has the same time complexity as the other two solutions but uses a single loop instead of recursion or simulating the process of filling the matrix. In terms of space complexity, the optimal solution is the best because it only uses a constant amount of space, whereas the other two solutions use a matrix of size n x n or a call stack of size log n.\\n\\n# concise code\\n# Algorithm\\n##### \\u2022\\tUse four variables i, j, di, and dj to keep track of the current position and direction\\n##### \\u2022\\tThen starts by initializing the matrix with all zeros\\n##### \\u2022\\tIt then fills the matrix in a spiral order by moving in the current direction and changing direction when it encounters a non-zero element\\n##### \\u2022\\tThe loop variable k starts from 1 and goes up to n * n\\n##### \\u2022\\tIn each iteration, then sets the value of the current position (i, j) to k\\n##### \\u2022\\tIt then checks if the next position in the current direction (i + di, j + dj) is already filled with a non-zero value\\n##### \\u2022\\tIf it is, changes the direction by swapping di and dj and negating one of them\\n##### \\u2022\\tFinally, updates the current position by adding di to i and dj to j\\n##### \\u2022\\tOnce the loop is complete, the matrix is filled in a spiral order and returns the matrix\\n\\n```java []\\npublic int[][] generateMatrix(int n) {\\n    int matrix[][] = new int[n][n],i = 0, j = 0, di = 0, dj = 1;\\n    for (int k = 1; k <= n * n; k++) {\\n        matrix[i][j] = k;\\n        if (matrix[(i + di + n) % n][(j + dj + n) % n] != 0) {\\n            int temp = di;\\n            di = dj;\\n            dj = -temp;\\n        }\\n        i += di;\\n        j += dj;\\n    } return matrix;\\n}\\n```\\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    int i = 0, j = 0, di = 0, dj = 1;\\n    for (int k = 1; k <= n * n; k++) {\\n        matrix[i][j] = k;\\n        if (matrix[(i + di + n) % n][(j + dj + n) % n] != 0) {\\n            int temp = di;\\n            di = dj;\\n            dj = -temp;\\n        }\\n        i += di;\\n        j += dj;\\n    }\\n    return matrix;\\n}\\n```\\n```python []\\ndef generateMatrix(self, n):\\n    A = [[0] * n for _ in range(n)]\\n    i, j, di, dj = 0, 0, 0, 1\\n    for k in xrange(n*n):\\n        A[i][j] = k + 1\\n        if A[(i+di)%n][(j+dj)%n]:\\n            di, dj = dj, -di\\n        i += di\\n        j += dj\\n    return A\\n```\\n\\n# dry run for n=3\\n##### \\u2022\\tInitially, we create a new n x n matrix filled with zeros\\n##### \\u2022\\tWe also initialize i and j to 0, and di and dj to 0 and 1 respectively\\n##### \\u2022\\tWe then enter a loop that runs from k=1 to k=n*n\\n##### \\u2022\\tIn each iteration of the loop, we do the following:We set the value of the current cell to k\\n##### \\u2022\\tWe check if the next cell in the direction of (di, dj) is already filled\\n##### \\u2022\\tIf it is, we change the direction of motion by swapping di and dj and negating the new value of dj\\n##### \\u2022\\tWe update the values of i and j by adding di and dj respectively\\n##### \\u2022\\tAfter the loop completes, we return the filled matrix\\n##### \\u2022\\tThe final matrix is:\\n```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\\n# 3 LINES code\\n# Algorithm\\n##### \\u2022\\tFirst initializes an empty list A and a variable lo to n*n+1\\n##### \\u2022\\tIt then enters a loop that continues until lo is less than or equal to 1\\n##### \\u2022\\tIn each iteration, set hi to the current value of lo and updates lo to lo - len(A)\\n##### \\u2022\\tIt then creates a new list of integers from lo to hi and appends it to the beginning of A\\n##### \\u2022\\tThen reverses the order of the remaining elements in A and transposes the resulting list of lists using the zip() function\\n##### \\u2022\\tThis effectively rotates the matrix by 90 degrees counterclockwise\\n##### \\u2022\\tThe loop continues until lo is less than or equal to 1, at which point the matrix is filled in a spiral order and  returns A\\n\\n```PYTHON []\\ndef generateMatrix(self, n):\\n    A = [[n*n]]\\n    while A[0][0] > 1:\\n        A = [range(A[0][0] - len(A), A[0][0])] + zip(*A[::-1])\\n    return A * (n>0)\\n```\\n```PYTHON []\\ndef generateMatrix(self, n):\\n    A, lo = [], n*n+1\\n    while lo > 1:\\n        lo, hi = lo - len(A), lo\\n        A = [range(lo, hi)] + zip(*A[::-1])\\n    return A\\n```\\n# dry run for n=3\\n##### \\u2022\\tInitially, A is set to [[9]]\\n##### \\u2022\\tIn the while loop, we check if the first element of A is greater than 1\\n##### \\u2022\\tSince it is, we perform the following steps:We create a new list B containing a range of numbers from A[0][0] - len(A) to A[0][0] - 1\\n##### \\u2022\\tIn this case, B is equal to range(7, 9)\\n##### \\u2022\\tWe then take the transpose of A using zip(*A[::-1])\\n##### \\u2022\\tThe [::-1] reverses the order of the elements in A, and the * unpacks the elements of A as arguments to zip\\n##### \\u2022\\tThe zip function then groups the elements of each sub-list of A with the corresponding elements of B, effectively rotating the matrix by 90 degrees counterclockwise\\n##### \\u2022\\tWe concatenate B with the result of step 2 to form a new matrix A\\n##### \\u2022\\tWe repeat steps 1-3 until the first element of A is equal to 1\\n##### \\u2022\\tFinally, we return A multiplied by (n>0), which is equivalent to returning A if n is positive and an empty list if n is zero\\n\\nAt each iteration, the code fills in one element of the matrix in a spiral order. The final matrix is filled in the following order:\\n1 2 3\\n8 9 4\\n7 6 5\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```java []\\npublic int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int num = 1;\\n        int row = 0;\\n        int col = 0;\\n        int direction = 0;\\n        int[] dr = {0, 1, 0, -1};\\n        int[] dc = {1, 0, -1, 0};\\n        while (num <= n * n) {\\n            matrix[row][col] = num;\\n            num++;\\n            int nextRow = row + dr[direction];\\n            int nextCol = col + dc[direction];\\n            if (nextRow < 0 || nextRow >= n || nextCol < 0 || nextCol >= n || matrix[nextRow][nextCol] != 0) {\\n                direction = (direction + 1) % 4;\\n            }\\n            row += dr[direction];\\n            col += dc[direction];\\n        }\\n        return matrix;\\n    }\\n```\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    int num = 1;\\n    int row = 0;\\n    int col = 0;\\n    int direction = 0;\\n    vector<int> dr = {0, 1, 0, -1};\\n    vector<int> dc = {1, 0, -1, 0};\\n    while (num <= n * n) {\\n        matrix[row][col] = num;\\n        num++;\\n        int nextRow = row + dr[direction];\\n        int nextCol = col + dc[direction];\\n        if (nextRow < 0 || nextRow >= n || nextCol < 0 || nextCol >= n || matrix[nextRow][nextCol] != 0) {\\n            direction = (direction + 1) % 4;\\n        }\\n        row += dr[direction];\\n        col += dc[direction];\\n    }\\n    return matrix;\\n}\\n```\n```python []\\ndef generateMatrix(n: int) -> List[List[int]]:\\n    matrix = [[0] * n for _ in range(n)]\\n    num = 1\\n    row = 0\\n    col = 0\\n    direction = 0\\n    dr = [0, 1, 0, -1]\\n    dc = [1, 0, -1, 0]\\n    while num <= n * n:\\n        matrix[row][col] = num\\n        num += 1\\n        nextRow = row + dr[direction]\\n        nextCol = col + dc[direction]\\n        if nextRow < 0 or nextRow >= n or nextCol < 0 or nextCol >= n or matrix[nextRow][nextCol] != 0:\\n            direction = (direction + 1) % 4\\n        row += dr[direction]\\n        col += dc[direction]\\n    return matrix\\n```\n```java []\\npublic  int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        fillMatrix(matrix, 0, n - 1, 0, n - 1, 1);\\n        return matrix;\\n    }\\n\\n    public  void fillMatrix(int[][] matrix, int top, int bottom, int left, int right, int num) {\\n        if (top > bottom || left > right) {\\n            return;\\n        }\\n        for (int i = left; i <= right; i++) {\\n            matrix[top][i] = num;\\n            num++;\\n        }\\n        for (int i = top + 1; i <= bottom; i++) {\\n            matrix[i][right] = num;\\n            num++;\\n        }\\n        if (top < bottom && left < right) {\\n            for (int i = right - 1; i >= left; i--) {\\n                matrix[bottom][i] = num;\\n                num++;\\n            }\\n            for (int i = bottom - 1; i > top; i--) {\\n                matrix[i][left] = num;\\n                num++;\\n            }\\n        }\\n        fillMatrix(matrix, top + 1, bottom - 1, left + 1, right - 1, num);\\n    }\\n\\n```\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    fillMatrix(matrix, 0, n - 1, 0, n - 1, 1);\\n    return matrix;\\n}\\n\\nvoid fillMatrix(vector<vector<int>>& matrix, int top, int bottom, int left, int right, int num) {\\n    if (top > bottom || left > right) {\\n        return;\\n    }\\n    for (int i = left; i <= right; i++) {\\n        matrix[top][i] = num;\\n        num++;\\n    }\\n    for (int i = top + 1; i <= bottom; i++) {\\n        matrix[i][right] = num;\\n        num++;\\n    }\\n    if (top < bottom && left < right) {\\n        for (int i = right - 1; i >= left; i--) {\\n            matrix[bottom][i] = num;\\n            num++;\\n        }\\n        for (int i = bottom - 1; i > top; i--) {\\n            matrix[i][left] = num;\\n            num++;\\n        }\\n    }\\n    fillMatrix(matrix, top + 1, bottom - 1, left + 1, right - 1, num);\\n}\\n```\n```python []\\ndef generateMatrix(n: int) -> List[List[int]]:\\n    matrix = [[0] * n for _ in range(n)]\\n    fillMatrix(matrix, 0, n - 1, 0, n - 1, 1)\\n    return matrix\\n\\ndef fillMatrix(matrix: List[List[int]], top: int, bottom: int, left: int, right: int, num: int) -> None:\\n    if top > bottom or left > right:\\n        return\\n    for i in range(left, right + 1):\\n        matrix[top][i] = num\\n        num += 1\\n    for i in range(top + 1, bottom + 1):\\n        matrix[i][right] = num\\n        num += 1\\n    if top < bottom and left < right:\\n        for i in range(right - 1, left - 1, -1):\\n            matrix[bottom][i] = num\\n            num += 1\\n        for i in range(bottom - 1, top, -1):\\n            matrix[i][left] = num\\n            num += 1\\n    fillMatrix(matrix, top + 1, bottom - 1, left + 1, right - 1, num)\\n```\n```java []\\npublic int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int top = 0;\\n        int bottom = n - 1;\\n        int left = 0;\\n        int right = n - 1;\\n        int num = 1;\\n        while (top <= bottom && left <= right) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = num;\\n                num++;\\n            }\\n            top++;\\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = num;\\n                num++;\\n            }\\n            right--;\\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = num;\\n                    num++;\\n                }\\n                bottom--;\\n            }\\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = num;\\n                    num++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n```\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    int top = 0;\\n    int bottom = n - 1;\\n    int left = 0;\\n    int right = n - 1;\\n    int num = 1;\\n    while (top <= bottom && <= right) {\\n        for (int i = left; i <= right; i++) {\\n            matrix[top][i] = num;\\n            num++;\\n        }\\n        top++;\\n        for (int i = top; i <= bottom; i++) {\\n            matrix[i][right] = num;\\n            num++;\\n        }\\n        right--;\\n        if (top <= bottom) {\\n            for (int i = right; i >= left; i--) {\\n                matrix[bottom][i] = num;\\n                num++;\\n            }\\n            bottom--;\\n        }\\n        if (left <= right) {\\n            for (int i = bottom; i >= top; i--) {\\n                matrix[i][left] = num;\\n                num++;\\n            }\\n            left++;\\n        }\\n    }\\n    return matrix;\\n}\\n```\n```python []\\ndef generateMatrix(n: int) -> List[List[int]]:\\n    matrix = [[0] * n for _ in range(n)]\\n    top = 0\\n    bottom = n - 1\\n    left = 0\\n    right = n - 1\\n    num = 1\\n    while top <= bottom and left <= right:\\n        for i in range(left, right + 1):\\n            matrix[top][i] = num\\n            num += 1\\n        top += 1\\n        for i in range(top, bottom + 1):\\n            matrix[i][right] = num\\n            num += 1\\n        right -= 1\\n        if top <= bottom:\\n            for i in range(right, left - 1, -1):\\n                matrix[bottom][i] = num\\n                num += 1\\n            bottom -= 1\\n        if left <= right:\\n            for i in range(bottom, top - 1, -1):\\n                matrix[i][left] = num\\n                num += 1\\n            left += 1\\n    return matrix\\n```\n```java []\\npublic int[][] generateMatrix(int n) {\\n    int matrix[][] = new int[n][n],i = 0, j = 0, di = 0, dj = 1;\\n    for (int k = 1; k <= n * n; k++) {\\n        matrix[i][j] = k;\\n        if (matrix[(i + di + n) % n][(j + dj + n) % n] != 0) {\\n            int temp = di;\\n            di = dj;\\n            dj = -temp;\\n        }\\n        i += di;\\n        j += dj;\\n    } return matrix;\\n}\\n```\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    int i = 0, j = 0, di = 0, dj = 1;\\n    for (int k = 1; k <= n * n; k++) {\\n        matrix[i][j] = k;\\n        if (matrix[(i + di + n) % n][(j + dj + n) % n] != 0) {\\n            int temp = di;\\n            di = dj;\\n            dj = -temp;\\n        }\\n        i += di;\\n        j += dj;\\n    }\\n    return matrix;\\n}\\n```\n```python []\\ndef generateMatrix(self, n):\\n    A = [[0] * n for _ in range(n)]\\n    i, j, di, dj = 0, 0, 0, 1\\n    for k in xrange(n*n):\\n        A[i][j] = k + 1\\n        if A[(i+di)%n][(j+dj)%n]:\\n            di, dj = dj, -di\\n        i += di\\n        j += dj\\n    return A\\n```\n```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\n```PYTHON []\\ndef generateMatrix(self, n):\\n    A = [[n*n]]\\n    while A[0][0] > 1:\\n        A = [range(A[0][0] - len(A), A[0][0])] + zip(*A[::-1])\\n    return A * (n>0)\\n```\n```PYTHON []\\ndef generateMatrix(self, n):\\n    A, lo = [], n*n+1\\n    while lo > 1:\\n        lo, hi = lo - len(A), lo\\n        A = [range(lo, hi)] + zip(*A[::-1])\\n    return A\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 460726,
                "title": "python-easy-to-understand-solution-with-fully-commented-code-ref-caikehe-s-solution",
                "content": "NOTE: this solution is an adaption of @caikehe\\'s [brilliant and clean solution](https://leetcode.com/problems/spiral-matrix-ii/discuss/22290/Python-easy-to-follow-solution).\\n\\nintuition:\\n\\n- initialize a matrix of zeros\\n- fill in the numbers in a spiral order layer-by-layer\\n\\nie. if n =3, initialize a 3-by-3 matrix\\n```\\n[\\n [ 0, 0, 0 ],\\n [ 0, 0, 0 ],\\n [ 0, 0, 0 ]\\n]\\n```\\ndivide up the matrix into 4 types of layers\\n```python\\n        top = 0 # top layer: top row index\\n        right = n - 1 # right layer: right col index\\n        down = n - 1 # bottom layer: bottom row index\\n        left = 0 # left layer: left col index\\n```\\n\\n```\\n[  \\n [ X, 0, 0 ], <-- you start filling in numbers at the top-left position\\n [ 0, 0, 0 ],\\n [ 0, 0, 0 ]\\n]\\n```\\n\\nwhen filling the top layer (horizontal row), fix the row index and increment the col index.\\nafter you are done with the top layer (horizontal row), move the top layer inward(downward) \\n\\n```python\\n for i in range(left, right+1): # from left to right. right + 1 to reach the last position in a row\\n\\t matrix[top][i] = num # to fill top row, fix the top row index and increment the col position\\n     num += 1 # update num\\n top += 1 # after traversing top row, move top row index inward(downward) by one unit\\n```\\n\\nyour matrix will be\\n\\n\\n```\\n[\\n [ 1, 2, 3 ],\\n [ 0, 0, X ], <--- since you increment the top layer by 1, you will start fillin in the next number here at the \\'x\\' position\\n [ 0, 0, 0 ]\\n]\\n```\\n\\nrepeat for the right col (vertical layer going down), bottom row (horizontal layer going right to left), left col (vertical layer going from bottom up)\\n```\\n[\\n [ 1, 2, 3 ],\\n [ 0, 0, 4 ], \\n [ 0, X, 5 ] <--- since you increment the right layer by -1, you will start fillin in the next number here at the \\'x\\' position\\n]\\n```\\n\\n```\\n[\\n [ 1, 2, 3 ],\\n [ X, 0, 4 ], <--- since you increment the bottom layer by -1, you will start fillin in the next number here at the \\'x\\' position\\n [ 7, 6, 5 ]\\n]\\n```\\n\\ntime O(n by n)\\nspace O(n by n)\\n\\n```python\\n# 59 Spiral Matrix II\\nclass Solution:\\n    def generateMatrix(self, n):\\n        matrix = []\\n        if not n: return matrix\\n\\n        # construct a matrix of zeros\\n        for row in range(n):\\n            rowArray = []\\n            for col in range(n):\\n                rowArray.append(0)\\n            matrix.append(rowArray)\\n\\n        # layer by layer strategy\\n        num = 1\\n        top = 0 # top layer: top row index\\n        right = n - 1 # right layer: right col index\\n        down = n - 1 # bottom layer: bottom row index\\n        left = 0 # left layer: left col index\\n\\t\\t \\n\\t\\t # while layers closing inward but not overlapping. if overlap = reached end of spiral matrix\\n        while left <= right and top <= down: \\n            # top row\\n            for i in range(left, right+1): # from left to right. right + 1 to reach the last position in a row\\n                matrix[top][i] = num # to fill top row, fix the top row index and increment the col position\\n                num += 1 # update num\\n            top += 1 # after traversing top row, move top row index inward(downward) by one unit\\n\\n            # right col\\n            for i in range(top, down+1): # from top to bottom. bottom + 1 to reach the last positin in a col\\n                matrix[i][right] = num # to fill the right col, fix the right col index and increment the row position\\n                num += 1 # update num\\n            right -= 1 # after traversing right col, move right col index inward(towards the left) by one unit\\n\\n            # bottom row\\n            for i in range(right, left-1, -1): # from left to right, in reverse order. left-1 to reach the leftmost position in a row\\n                matrix[down][i] = num\\n                num += 1 # update num\\n            down -= 1 # after traversing bottom row, move bottom row index inward(upward) by one unit\\n\\n            # left col\\n            for i in range(down, top-1, -1): # from bottom to top, in reverse order. top-1 to reach the topmost position in a col\\n                matrix[i][left] = num # to fill the left col, fix the left col index and increment the row position\\n                num += 1\\n            left += 1 # after traversing left col, move left col index inward(towards the right) by one unit\\n\\n            # repeat until top-bottom or left-right indices collide (ie. have completed all layers)\\n        return matrix\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n[\\n [ 0, 0, 0 ],\\n [ 0, 0, 0 ],\\n [ 0, 0, 0 ]\\n]\\n```\n```python\\n        top = 0 # top layer: top row index\\n        right = n - 1 # right layer: right col index\\n        down = n - 1 # bottom layer: bottom row index\\n        left = 0 # left layer: left col index\\n```\n```\\n[  \\n [ X, 0, 0 ], <-- you start filling in numbers at the top-left position\\n [ 0, 0, 0 ],\\n [ 0, 0, 0 ]\\n]\\n```\n```python\\n for i in range(left, right+1): # from left to right. right + 1 to reach the last position in a row\\n\\t matrix[top][i] = num # to fill top row, fix the top row index and increment the col position\\n     num += 1 # update num\\n top += 1 # after traversing top row, move top row index inward(downward) by one unit\\n```\n```\\n[\\n [ 1, 2, 3 ],\\n [ 0, 0, X ], <--- since you increment the top layer by 1, you will start fillin in the next number here at the \\'x\\' position\\n [ 0, 0, 0 ]\\n]\\n```\n```\\n[\\n [ 1, 2, 3 ],\\n [ 0, 0, 4 ], \\n [ 0, X, 5 ] <--- since you increment the right layer by -1, you will start fillin in the next number here at the \\'x\\' position\\n]\\n```\n```\\n[\\n [ 1, 2, 3 ],\\n [ X, 0, 4 ], <--- since you increment the bottom layer by -1, you will start fillin in the next number here at the \\'x\\' position\\n [ 7, 6, 5 ]\\n]\\n```\n```python\\n# 59 Spiral Matrix II\\nclass Solution:\\n    def generateMatrix(self, n):\\n        matrix = []\\n        if not n: return matrix\\n\\n        # construct a matrix of zeros\\n        for row in range(n):\\n            rowArray = []\\n            for col in range(n):\\n                rowArray.append(0)\\n            matrix.append(rowArray)\\n\\n        # layer by layer strategy\\n        num = 1\\n        top = 0 # top layer: top row index\\n        right = n - 1 # right layer: right col index\\n        down = n - 1 # bottom layer: bottom row index\\n        left = 0 # left layer: left col index\\n\\t\\t \\n\\t\\t # while layers closing inward but not overlapping. if overlap = reached end of spiral matrix\\n        while left <= right and top <= down: \\n            # top row\\n            for i in range(left, right+1): # from left to right. right + 1 to reach the last position in a row\\n                matrix[top][i] = num # to fill top row, fix the top row index and increment the col position\\n                num += 1 # update num\\n            top += 1 # after traversing top row, move top row index inward(downward) by one unit\\n\\n            # right col\\n            for i in range(top, down+1): # from top to bottom. bottom + 1 to reach the last positin in a col\\n                matrix[i][right] = num # to fill the right col, fix the right col index and increment the row position\\n                num += 1 # update num\\n            right -= 1 # after traversing right col, move right col index inward(towards the left) by one unit\\n\\n            # bottom row\\n            for i in range(right, left-1, -1): # from left to right, in reverse order. left-1 to reach the leftmost position in a row\\n                matrix[down][i] = num\\n                num += 1 # update num\\n            down -= 1 # after traversing bottom row, move bottom row index inward(upward) by one unit\\n\\n            # left col\\n            for i in range(down, top-1, -1): # from bottom to top, in reverse order. top-1 to reach the topmost position in a col\\n                matrix[i][left] = num # to fill the left col, fix the left col index and increment the row position\\n                num += 1\\n            left += 1 # after traversing left col, move left col index inward(towards the right) by one unit\\n\\n            # repeat until top-bottom or left-right indices collide (ie. have completed all layers)\\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941112,
                "title": "python3-straightforward-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nWe use helper function here that fills only one circle at the time.\\n\\nTime: **O(n^2)**\\nSpace: **O(1)**\\n\\nRuntime: 35 ms, faster than **82.95%** of Python3 online submissions for Spiral Matrix II.\\nMemory Usage: 13.9 MB, less than **85.84%** of Python3 online submissions for Spiral Matrix II.\\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        res = [[0] * n for _ in range(n)]\\n        \\n        def fill_circle(el, start, n):\\n            i, j = start, start            \\n            for k in range(j, j + n): \\n                res[i][k], el = el, el + 1\\n            for k in range(i + 1, i + n): \\n                res[k][j + n - 1], el = el, el + 1\\n            for k in reversed(range(j, j + n - 1)): \\n                res[i + n - 1][k], el = el, el + 1\\n            for k in reversed(range(i + 1, i + n - 1)): \\n                res[k][j], el = el, el + 1\\n        \\n        el, start = 1, 0\\n        while n > 0:\\n            fill_circle(el, start, n)\\n            el = el + 4*(n - 1)\\n            n, start = n - 2, start + 1\\n            \\n        return res\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        res = [[0] * n for _ in range(n)]\\n        \\n        def fill_circle(el, start, n):\\n            i, j = start, start            \\n            for k in range(j, j + n): \\n                res[i][k], el = el, el + 1\\n            for k in range(i + 1, i + n): \\n                res[k][j + n - 1], el = el, el + 1\\n            for k in reversed(range(j, j + n - 1)): \\n                res[i + n - 1][k], el = el, el + 1\\n            for k in reversed(range(i + 1, i + n - 1)): \\n                res[k][j], el = el, el + 1\\n        \\n        el, start = 1, 0\\n        while n > 0:\\n            fill_circle(el, start, n)\\n            el = el + 4*(n - 1)\\n            n, start = n - 2, start + 1\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22443,
                "title": "9-lines-python-solution",
                "content": "(1) Create a matrix to store the coordinates\\n> (0,0) (0,1) (0,2)\\n\\n> (1,0) (1,1) (1,2)\\n\\n> (2,0) (2,1) (2,2)\\n\\n(2) Read it out using the trick of \"[Spiral Matrix I][1]\"\\n\\n> (0,0) (0,1) (0,2) (1,2) (2,2) ...\\n\\n(3) Put 1, 2, 3, ... n**2 at these coordinates sequentially.  Done.\\n\\n    def generateMatrix(self, n):\\n        \\n        result = [[0 for i in range(n)] for j in range(n)]\\n        coord = [[(i,j) for j in range(n)] for i in range(n)]\\n        \\n        count = 1\\n        \\n        while coord:\\n            for x, y in coord.pop(0):\\n                result[x][y] = count\\n                count += 1\\n            coord = zip(*coord)[::-1]\\n\\n        return result\\n\\n\\n  [1]: https://leetcode.com/discuss/46516/lines-recursive-python-solution-lines-solution-recursion",
                "solutionTags": [
                    "Python"
                ],
                "code": "(1) Create a matrix to store the coordinates\\n> (0,0) (0,1) (0,2)\\n\\n> (1,0) (1,1) (1,2)\\n\\n> (2,0) (2,1) (2,2)\\n\\n(2) Read it out using the trick of \"[Spiral Matrix I][1]\"\\n\\n> (0,0) (0,1) (0,2) (1,2) (2,2) ...\\n\\n(3) Put 1, 2, 3, ... n**2 at these coordinates sequentially.  Done.\\n\\n    def generateMatrix(self, n):\\n        \\n        result = [[0 for i in range(n)] for j in range(n)]\\n        coord = [[(i,j) for j in range(n)] for i in range(n)]\\n        \\n        count = 1\\n        \\n        while coord:\\n            for x, y in coord.pop(0):\\n                result[x][y] = count\\n                count += 1\\n            coord = zip(*coord)[::-1]\\n\\n        return result\\n\\n\\n  [1]: https://leetcode.com/discuss/46516/lines-recursive-python-solution-lines-solution-recursion",
                "codeTag": "Python3"
            },
            {
                "id": 22469,
                "title": "if-we-can-t-write-data-to-the-matrix-we-change-the-direction-a-simple-python-solution",
                "content": "    class Solution:\\n    # @return a list of lists of integer\\n    def generateMatrix(self, n):\\n        matrix = [[0]*n for _ in range(n)]\\n        directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n        d = 0\\n        y, x = 0, 0\\n        for i in range(1, n*n+1):\\n            matrix[y][x] = i\\n            dy, dx = directions[d % 4]\\n            if -1 < y+dy < n and -1 < x+dx < n and matrix[y+dy][x+dx] == 0:\\n                y, x = y+dy, x+dx\\n            else:\\n                d += 1\\n                dy, dx = directions[d % 4]\\n                y, x = y+dy, x+dx\\n        return matrix\\n\\nChange the direction If the we can't write to the matrix",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @return a list of lists of integer\\n    def generateMatrix(self, n):\\n        matrix = [[0]*n for _ in range(n)]\\n        directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n        d = 0\\n        y, x = 0, 0\\n        for i in range(1, n*n+1):\\n            matrix[y][x] = i\\n            dy, dx = directions[d % 4]\\n            if -1 < y+dy < n and -1 < x+dx < n and matrix[y+dy][x+dx] == 0:\\n                y, x = y+dy, x+dx\\n            else:\\n                d += 1\\n                dy, dx = directions[d % 4]\\n                y, x = y+dy, x+dx\\n        return matrix\\n\\nChange the direction If the we can't write to the matrix",
                "codeTag": "Java"
            },
            {
                "id": 1511479,
                "title": "java-tc-o-n-2-sc-o-1-multiple-optimized-ways-to-solve-this-question",
                "content": "**Using Switch-Case - Simulating the spiral traversal**\\n```java\\n/**\\n * Using Switch-Case: Traverse Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1) excluding the result space.\\n */\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        int[][] result = new int[n][n];\\n        if (n == 0) {\\n            return result;\\n        }\\n\\n        int top = 0;\\n        int bottom = n - 1;\\n        int left = 0;\\n        int right = n - 1;\\n        int num = 1;\\n        int dir = 0;\\n\\n        while (top <= bottom && left <= right) {\\n            switch (dir) {\\n                case 0: // Left\\n                    for (int i = left; i <= right; i++) {\\n                        result[top][i] = num++;\\n                    }\\n                    top++;\\n                    break;\\n                case 1: // Down\\n                    for (int i = top; i <= bottom; i++) {\\n                        result[i][right] = num++;\\n                    }\\n                    right--;\\n                    break;\\n                case 2: // Right\\n                    for (int i = right; i >= left; i--) {\\n                        result[bottom][i] = num++;\\n                    }\\n                    bottom--;\\n                    break;\\n                case 3: // Up\\n                    for (int i = bottom; i >= top; i--) {\\n                        result[i][left] = num++;\\n                    }\\n                    left++;\\n            }\\n            dir = (dir + 1) % 4;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n**Without using Switch-Case - Simulating the spiral traversal**\\n\\n```java\\n/**\\n * Traverse Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1) excluding the result space.\\n */\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        int[][] result = new int[n][n];\\n        if (n == 0) {\\n            return result;\\n        }\\n\\n        int rowBegin = 0;\\n        int rowEnd = n - 1;\\n        int colBegin = 0;\\n        int colEnd = n - 1;\\n        int num = 1;\\n\\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            // Traverse Right\\n            for (int i = colBegin; i <= colEnd; i++) {\\n                result[rowBegin][i] = num++;\\n            }\\n            rowBegin++;\\n            // Traverse Down\\n            for (int i = rowBegin; i <= rowEnd; i++) {\\n                result[i][colEnd] = num++;\\n            }\\n            colEnd--;\\n            // Traverse Left\\n            if (rowBegin <= rowEnd) {\\n                for (int i = colEnd; i >= colBegin; i--) {\\n                    result[rowEnd][i] = num++;\\n                }\\n                rowEnd--;\\n            }\\n            // Traverse Up\\n            if (colBegin <= colEnd) {\\n                for (int i = rowEnd; i >= rowBegin; i--) {\\n                    result[i][colBegin] = num++;\\n                }\\n                colBegin++;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n**Using 2D Directions array to calculate the next valid position - Simulating the spiral traversal**\\n\\n```java\\n/**\\n * Using 2D Directions array to calculate the next valid position. Traverse\\n * Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1) excluding the result space.\\n */\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        int[][] result = new int[n][n];\\n        if (n == 0) {\\n            return result;\\n        }\\n\\n        int[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n        int row = 0;\\n        int col = 0;\\n        int dirIdx = 0;\\n        int num = 1;\\n\\n        while (num <= n * n) {\\n            result[row][col] = num++;\\n            row += dirs[dirIdx][0];\\n            col += dirs[dirIdx][1];\\n\\n            if (row < 0 || row >= n || col < 0 || col >= n || result[row][col] != 0) {\\n                // Moving back from invalid position\\n                row -= dirs[dirIdx][0];\\n                col -= dirs[dirIdx][1];\\n                // Going to next dir\\n                dirIdx = (dirIdx + 1) % 4;\\n                // Updating row and col to valid next position\\n                row += dirs[dirIdx][0];\\n                col += dirs[dirIdx][1];\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Spiral Matrix question on LeetCode:\\n- [54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/discuss/1511476/Java-or-TC:-O(M*N)-or-SC:-O(1)-or-Optimized-solution-using-Switch-Case)\\n- [885. Spiral Matrix III](https://leetcode.com/problems/spiral-matrix-iii/discuss/1511489/Java-or-TC:-O(max(R-C)2)-or-SC:-O(1)-or-Simulating-a-Spiral-Walk)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```java\\n/**\\n * Using Switch-Case: Traverse Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1) excluding the result space.\\n */\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        int[][] result = new int[n][n];\\n        if (n == 0) {\\n            return result;\\n        }\\n\\n        int top = 0;\\n        int bottom = n - 1;\\n        int left = 0;\\n        int right = n - 1;\\n        int num = 1;\\n        int dir = 0;\\n\\n        while (top <= bottom && left <= right) {\\n            switch (dir) {\\n                case 0: // Left\\n                    for (int i = left; i <= right; i++) {\\n                        result[top][i] = num++;\\n                    }\\n                    top++;\\n                    break;\\n                case 1: // Down\\n                    for (int i = top; i <= bottom; i++) {\\n                        result[i][right] = num++;\\n                    }\\n                    right--;\\n                    break;\\n                case 2: // Right\\n                    for (int i = right; i >= left; i--) {\\n                        result[bottom][i] = num++;\\n                    }\\n                    bottom--;\\n                    break;\\n                case 3: // Up\\n                    for (int i = bottom; i >= top; i--) {\\n                        result[i][left] = num++;\\n                    }\\n                    left++;\\n            }\\n            dir = (dir + 1) % 4;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```java\\n/**\\n * Traverse Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1) excluding the result space.\\n */\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        int[][] result = new int[n][n];\\n        if (n == 0) {\\n            return result;\\n        }\\n\\n        int rowBegin = 0;\\n        int rowEnd = n - 1;\\n        int colBegin = 0;\\n        int colEnd = n - 1;\\n        int num = 1;\\n\\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            // Traverse Right\\n            for (int i = colBegin; i <= colEnd; i++) {\\n                result[rowBegin][i] = num++;\\n            }\\n            rowBegin++;\\n            // Traverse Down\\n            for (int i = rowBegin; i <= rowEnd; i++) {\\n                result[i][colEnd] = num++;\\n            }\\n            colEnd--;\\n            // Traverse Left\\n            if (rowBegin <= rowEnd) {\\n                for (int i = colEnd; i >= colBegin; i--) {\\n                    result[rowEnd][i] = num++;\\n                }\\n                rowEnd--;\\n            }\\n            // Traverse Up\\n            if (colBegin <= colEnd) {\\n                for (int i = rowEnd; i >= rowBegin; i--) {\\n                    result[i][colBegin] = num++;\\n                }\\n                colBegin++;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```java\\n/**\\n * Using 2D Directions array to calculate the next valid position. Traverse\\n * Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1) excluding the result space.\\n */\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        int[][] result = new int[n][n];\\n        if (n == 0) {\\n            return result;\\n        }\\n\\n        int[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n        int row = 0;\\n        int col = 0;\\n        int dirIdx = 0;\\n        int num = 1;\\n\\n        while (num <= n * n) {\\n            result[row][col] = num++;\\n            row += dirs[dirIdx][0];\\n            col += dirs[dirIdx][1];\\n\\n            if (row < 0 || row >= n || col < 0 || col >= n || result[row][col] != 0) {\\n                // Moving back from invalid position\\n                row -= dirs[dirIdx][0];\\n                col -= dirs[dirIdx][1];\\n                // Going to next dir\\n                dirIdx = (dirIdx + 1) % 4;\\n                // Updating row and col to valid next position\\n                row += dirs[dirIdx][0];\\n                col += dirs[dirIdx][1];\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941264,
                "title": "runtime-0-ms-faster-than-100-00-0-easy-to-understand",
                "content": "***Runtime: 0 ms, faster than 100.00% of Java online submissions for Spiral Matrix II.***\\n\\n***LOGIC***=We have to keep insering the number while moving in a particular direction and changing the direction when `certain condtion` occur:\\n\\n* next row index is -1\\n* next col index is -1\\n* next col index is n\\n* next row index is n\\n* next cell in current direction is already filled.\\n\\nIf `any one` of the following conditions arise, the direction should be changed\\n\\nThere is a `proper order` which we have to follow while `changing the direction`:\\n\\n* initial: right -> new: down\\n* initial: down -> new: left\\n* initial: left -> new: up\\n* initial: up -> new: right\\n\\n\\n\\n```\\nclass Solution {\\n    Integer rowDir = 0, colDir = 1;\\n    \\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int num = 1;\\n        int row =0, col=0;\\n        \\n        \\n        while(num<= n*n) {\\n            matrix[row][col] = num;\\n            \\n            int tempRow = row+rowDir;\\n            int tempCol = col+colDir;\\n\\t\\t\\t\\n\\t\\t\\t//Condition to change direction \\n            if(tempRow < 0 || tempCol <0 || tempRow == n || tempCol == n || matrix[tempRow][tempCol] != 0) {\\n                changeDirection();\\n            }\\n            \\n            row += rowDir;\\n            col += colDir;\\n            \\n            num++;\\n        }\\n        \\n        return matrix;\\n    }\\n    \\n    public void changeDirection() {\\n\\t\\t\\n        if(rowDir == 0 && colDir ==1) {\\n\\t\\t\\t// initial: right -> new: down\\n            colDir = 0;\\n            rowDir = 1;\\n        } else if (colDir == 0 && rowDir ==1) {\\n\\t\\t\\t// initial: down -> new: left\\n            rowDir = 0;\\n            colDir = -1;\\n        } else if (colDir == -1 && rowDir == 0) {\\n\\t\\t\\t// initial: left -> new: up\\n            rowDir = -1;\\n            colDir = 0;\\n        } else if (rowDir == -1 && colDir == 0) {\\n\\t\\t\\t// initial: up -> new: right\\n            colDir = 1;\\n            rowDir = 0;\\n        }\\n    }\\n}\\n```\\n<hr>\\n<hr>\\n\\n**Time Complexity =O(N*N)**\\n**Space Complexity = O(N)**\\n\\n<hr>\\n<hr>\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Integer rowDir = 0, colDir = 1;\\n    \\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int num = 1;\\n        int row =0, col=0;\\n        \\n        \\n        while(num<= n*n) {\\n            matrix[row][col] = num;\\n            \\n            int tempRow = row+rowDir;\\n            int tempCol = col+colDir;\\n\\t\\t\\t\\n\\t\\t\\t//Condition to change direction \\n            if(tempRow < 0 || tempCol <0 || tempRow == n || tempCol == n || matrix[tempRow][tempCol] != 0) {\\n                changeDirection();\\n            }\\n            \\n            row += rowDir;\\n            col += colDir;\\n            \\n            num++;\\n        }\\n        \\n        return matrix;\\n    }\\n    \\n    public void changeDirection() {\\n\\t\\t\\n        if(rowDir == 0 && colDir ==1) {\\n\\t\\t\\t// initial: right -> new: down\\n            colDir = 0;\\n            rowDir = 1;\\n        } else if (colDir == 0 && rowDir ==1) {\\n\\t\\t\\t// initial: down -> new: left\\n            rowDir = 0;\\n            colDir = -1;\\n        } else if (colDir == -1 && rowDir == 0) {\\n\\t\\t\\t// initial: left -> new: up\\n            rowDir = -1;\\n            colDir = 0;\\n        } else if (rowDir == -1 && colDir == 0) {\\n\\t\\t\\t// initial: up -> new: right\\n            colDir = 1;\\n            rowDir = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22409,
                "title": "c-concise-solution",
                "content": "        \\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> res(n, vector<int> (n, 1));\\n        int left, right, top, down, index;\\n        left = top = index = 0, right = down = n-1;\\n        while (left <= right && top <= down) {\\n            for (unsigned int j = left; j <= right; j++)\\n                res[top][j] = ++index;\\n            top++;\\n            for (unsigned int i = top; i <= down; i++)\\n                res[i][right] = ++index;\\n            right--;\\n            for (int j = right; j >= left; j--)\\n                res[down][j] = ++index;\\n            down--;\\n            for (int i = down; i >= top; i--)\\n                res[i][left] = ++index;\\n            left++;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        \\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> res(n, vector<int> (n, 1));\\n        int left, right, top, down, index;\\n        left = top = index = 0, right = down = n-1;\\n        while (left <= right && top <= down) {\\n            for (unsigned int j = left; j <= right; j++)\\n                res[top][j] = ++index;\\n            top++;\\n            for (unsigned int i = top; i <= down; i++)\\n                res[i][right] = ++index;\\n            right--;\\n            for (int j = right; j >= left; j--)\\n                res[down][j] = ++index;\\n            down--;\\n            for (int i = down; i >= top; i--)\\n                res[i][left] = ++index;\\n            left++;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1804819,
                "title": "c-0ms-fastest-solution",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>m(n,vector<int>(n,0));\\n        int c=1;\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            \\n                for(int i=left;i<=right;i++){\\n                    m[top][i]=c;\\n                    c++;\\n                }\\n                top++;\\n            \\n                for(int i=top;i<=bottom;i++){\\n                   m[i][right]=c;\\n                    c++; \\n                }\\n                right--;\\n            \\n                for(int i=right;i>=left;i--){\\n                    m[bottom][i]=c;\\n                    c++;\\n                }\\n                bottom--;\\n            \\n             \\n                for(int i=bottom;i>=top;i--){\\n                   m[i][left]=c;\\n                    c++; \\n                }\\n                left++;\\n            \\n        }\\n        return m;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>m(n,vector<int>(n,0));\\n        int c=1;\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            \\n                for(int i=left;i<=right;i++){\\n                    m[top][i]=c;\\n                    c++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 22466,
                "title": "my-ac-solution-with-using-direction-variable",
                "content": "      \\n     vector<vector<int> > generateMatrix(int n) {\\n                int dir = 0;\\n                vector< vector<int> > matrix(n, vector<int> (n, 0));\\n                int i = 0, j = 0, k = 1;\\n                while (k <= n * n) {\\n                    matrix[i][j] = k++;\\n                    if (dir == 0){\\n                        j++;\\n                        if (j == n || matrix[i][j] != 0) dir = 1, j--, i++;\\n                    } else\\n                    if (dir == 1) {\\n                        i++;\\n                        if (i == n || matrix[i][j] != 0) dir = 2, i--, j--;\\n                    } else\\n                    if (dir == 2) {\\n                        j--;\\n                        if (j < 0 || matrix[i][j] != 0) dir = 3, j++, i--;\\n                    } else\\n                    if (dir == 3) {\\n                        i--;\\n                        if (i < 0 || matrix[i][j] != 0) dir = 0, i++, j++;\\n                    }\\n                }\\n                return matrix;\\n            }",
                "solutionTags": [],
                "code": "      \\n     vector<vector<int> > generateMatrix(int n) {\\n                int dir = 0;\\n                vector< vector<int> > matrix(n, vector<int> (n, 0));\\n                int i = 0, j = 0, k = 1;\\n                while (k <= n * n) {\\n                    matrix[i][j] = k++;\\n                    if (dir == 0){\\n                        j++;\\n                        if (j == n || matrix[i][j] != 0) dir = 1, j--, i++;\\n                    } else\\n                    if (dir == 1) {\\n                        i++;\\n                        if (i == n || matrix[i][j] != 0) dir = 2, i--, j--;\\n                    } else\\n                    if (dir == 2) {\\n                        j--;\\n                        if (j < 0 || matrix[i][j] != 0) dir = 3, j++, i--;\\n                    } else\\n                    if (dir == 3) {\\n                        i--;\\n                        if (i < 0 || matrix[i][j] != 0) dir = 0, i++, j++;\\n                    }\\n                }\\n                return matrix;\\n            }",
                "codeTag": "Unknown"
            },
            {
                "id": 3506464,
                "title": "easy-c-java-code-beats-100-step-by-step-explanattion-begginers-freindly",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe matrix is initialized with all elements set to 0.\\n\\nThe goal is to fill the matrix with integers from 1 to n x n in a spiral order. \\nFor example, for n = 3, the matrix should look like this:\\n```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\\nInitialize the matrix with all elements set to 0.\\n```\\n0 0 0\\n0 0 0\\n0 0 0\\n```\\nInitialize variables to keep track of the starting and ending rows and columns. Initially, the starting row and column are both 0, and the ending row and column are both n - 1.\\n```\\nstartingrow = 0\\nstartingcol = 0\\nendingrow = 2\\nendingcol = 2\\n```\\nStart filling the matrix in a clockwise spiral order. The first step is to fill the top row from left to right. The count variable keeps track of the current number being filled in the matrix. After each number is placed in the matrix, count is incremented.\\n```\\n1 2 3\\n0 0 0\\n0 0 0\\ncount = 1\\n```\\nMove the starting row down by one, so that the next step will fill the right column from top to bottom.\\n```\\n0 0 0\\n0 0 0\\n0 0 0\\ncount = 1\\nstartingrow = 1\\n```\\nFill the right column from top to bottom.\\n```\\n1 2 3\\n0 0 4\\n0 0 5\\ncount = 3\\n```\\nMove the ending column left by one, so that the next step will fill the bottom row from right to left.\\n```\\n1 2 3\\n0 0 4\\n0 0 5\\ncount = 3\\nendingcol = 1\\n```\\nFill the bottom row from right to left.\\n```\\n1 2 3\\n0 0 4\\n6 7 5\\ncount = 6\\n```\\nMove the ending row up by one, so that the next step will fill the left column from bottom to top.\\n```\\n1 2 3\\n0 0 4\\n6 7 5\\ncount = 6\\nendingrow = 1\\n```\\nFill the left column from bottom to top.\\n```\\n1 2 3\\n8 0 4\\n6 7 5\\ncount = 9\\n```\\nMove the starting column right by one, so that the next step will fill the top row from left to right again.\\n```\\n1 2 3\\n8 0 4\\n6 7 5\\ncount = 9\\nstartingcol = 1\\n```\\nRepeat steps 3 through 10 until the entire matrix is filled with numbers.\\n```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\\nThe matrix filled with integers from 1 to n x n in a clockwise spiral order.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# ---------------------------------------------------------\\n# Please Upvote If It helps You\\n# ---------------------------------------------------------\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        // creating a vector of n*n\\n        \\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        \\n        //int row=matrix.size();\\n        //int col =matrix[0].size();\\n        int count =0;\\n        int total =n*n;\\n        \\n        //// all index \\n        \\n        int startingrow=0;\\n        int startingcol=0;\\n        int endingrow=n-1;\\n        int endingcol=n-1;\\n        \\n        while(count<total)\\n        {\\n            for(int i=startingcol;count<total && i<=endingcol; i++)\\n            {\\n                count++;\\n                ans[startingrow][i]=count;\\n                \\n            }\\n            startingrow++;\\n            \\n            for(int i=startingrow;count<total && i<=endingrow; i++)\\n            {\\n            \\n                count++;\\n                ans[i][endingcol]=count;\\n            }\\n            endingcol--;\\n            \\n            for(int i=endingcol;count<total && i>=startingcol; i--)\\n            {\\n                 count++;\\n                ans[endingrow][i]=count;\\n            }\\n            endingrow--;\\n            \\n            for(int i=endingrow;count<total && i>=startingrow; i--)\\n            {\\n                 count++;\\n                ans[i][startingcol]=count;\\n            \\n            }\\n            startingcol++;\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n# java code \\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        \\n        // creating a matrix of n x n\\n        \\n        int[][] ans = new int[n][n];\\n        \\n        int count = 1;\\n        int total = n * n;\\n        \\n        // initialize variables for keeping track of starting and ending rows and columns\\n        int startingRow = 0;\\n        int endingRow = n - 1;\\n        int startingCol = 0;\\n        int endingCol = n - 1;\\n        \\n        while (count <= total) {\\n            \\n            // fill in the top row from left to right\\n            for (int i = startingCol; i <= endingCol; i++) {\\n                ans[startingRow][i] = count;\\n                count++;\\n            }\\n            startingRow++;\\n            \\n            // fill in the right column from top to bottom\\n            for (int i = startingRow; i <= endingRow; i++) {\\n                ans[i][endingCol] = count;\\n                count++;\\n            }\\n            endingCol--;\\n            \\n            // fill in the bottom row from right to left\\n            for (int i = endingCol; i >= startingCol; i--) {\\n                ans[endingRow][i] = count;\\n                count++;\\n            }\\n            endingRow--;\\n            \\n            // fill in the left column from bottom to top\\n            for (int i = endingRow; i >= startingRow; i--) {\\n                ans[i][startingCol] = count;\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Matrix"
                ],
                "code": "```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\n```\\n0 0 0\\n0 0 0\\n0 0 0\\n```\n```\\nstartingrow = 0\\nstartingcol = 0\\nendingrow = 2\\nendingcol = 2\\n```\n```\\n1 2 3\\n0 0 0\\n0 0 0\\ncount = 1\\n```\n```\\n0 0 0\\n0 0 0\\n0 0 0\\ncount = 1\\nstartingrow = 1\\n```\n```\\n1 2 3\\n0 0 4\\n0 0 5\\ncount = 3\\n```\n```\\n1 2 3\\n0 0 4\\n0 0 5\\ncount = 3\\nendingcol = 1\\n```\n```\\n1 2 3\\n0 0 4\\n6 7 5\\ncount = 6\\n```\n```\\n1 2 3\\n0 0 4\\n6 7 5\\ncount = 6\\nendingrow = 1\\n```\n```\\n1 2 3\\n8 0 4\\n6 7 5\\ncount = 9\\n```\n```\\n1 2 3\\n8 0 4\\n6 7 5\\ncount = 9\\nstartingcol = 1\\n```\n```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        // creating a vector of n*n\\n        \\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        \\n        //int row=matrix.size();\\n        //int col =matrix[0].size();\\n        int count =0;\\n        int total =n*n;\\n        \\n        //// all index \\n        \\n        int startingrow=0;\\n        int startingcol=0;\\n        int endingrow=n-1;\\n        int endingcol=n-1;\\n        \\n        while(count<total)\\n        {\\n            for(int i=startingcol;count<total && i<=endingcol; i++)\\n            {\\n                count++;\\n                ans[startingrow][i]=count;\\n                \\n            }\\n            startingrow++;\\n            \\n            for(int i=startingrow;count<total && i<=endingrow; i++)\\n            {\\n            \\n                count++;\\n                ans[i][endingcol]=count;\\n            }\\n            endingcol--;\\n            \\n            for(int i=endingcol;count<total && i>=startingcol; i--)\\n            {\\n                 count++;\\n                ans[endingrow][i]=count;\\n            }\\n            endingrow--;\\n            \\n            for(int i=endingrow;count<total && i>=startingrow; i--)\\n            {\\n                 count++;\\n                ans[i][startingcol]=count;\\n            \\n            }\\n            startingcol++;\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        \\n        // creating a matrix of n x n\\n        \\n        int[][] ans = new int[n][n];\\n        \\n        int count = 1;\\n        int total = n * n;\\n        \\n        // initialize variables for keeping track of starting and ending rows and columns\\n        int startingRow = 0;\\n        int endingRow = n - 1;\\n        int startingCol = 0;\\n        int endingCol = n - 1;\\n        \\n        while (count <= total) {\\n            \\n            // fill in the top row from left to right\\n            for (int i = startingCol; i <= endingCol; i++) {\\n                ans[startingRow][i] = count;\\n                count++;\\n            }\\n            startingRow++;\\n            \\n            // fill in the right column from top to bottom\\n            for (int i = startingRow; i <= endingRow; i++) {\\n                ans[i][endingCol] = count;\\n                count++;\\n            }\\n            endingCol--;\\n            \\n            // fill in the bottom row from right to left\\n            for (int i = endingCol; i >= startingCol; i--) {\\n                ans[endingRow][i] = count;\\n                count++;\\n            }\\n            endingRow--;\\n            \\n            // fill in the left column from bottom to top\\n            for (int i = endingRow; i >= startingRow; i--) {\\n                ans[i][startingCol] = count;\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978960,
                "title": "0ms-faster-than-100-easy-to-understand-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> res(n,vector<int>(n));\\n        int top = 0, bottom = n-1, left = 0, right = n-1;\\n        int val = 1,direction=1;\\n        while(left<=right && top<=bottom)\\n        {\\n            if(direction == 1)    \\n            {   \\n                for(int i=left;i<=right;i++)\\n                {\\n                    res[top][i]=val++;\\n                }\\n                top++;\\n                direction=2;\\n            }\\n            else if(direction == 2)\\n            {\\n                for(int i = top;i<=bottom;i++)\\n                {\\n                    res[i][right]=val++;\\n                }\\n                right--;\\n                direction = 3;\\n            }\\n            else if(direction == 3)\\n            {\\n                for(int i = right;i>=left;i--)\\n                {\\n                    res[bottom][i]=val++;\\n                }\\n                bottom--;\\n                direction=4;\\n            }\\n            else if(direction == 4)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                    res[i][left]=val++;\\n                }\\n                left++;\\n                direction = 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> res(n,vector<int>(n));\\n        int top = 0, bottom = n-1, left = 0, right = n-1;\\n        int val = 1,direction=1;\\n        while(left<=right && top<=bottom)\\n        {\\n            if(direction == 1)    \\n            {   \\n                for(int i=left;i<=right;i++)\\n                {\\n                    res[top][i]=val++;\\n                }\\n                top++;\\n                direction=2;\\n            }\\n            else if(direction == 2)\\n            {\\n                for(int i = top;i<=bottom;i++)\\n                {\\n                    res[i][right]=val++;\\n                }\\n                right--;\\n                direction = 3;\\n            }\\n            else if(direction == 3)\\n            {\\n                for(int i = right;i>=left;i--)\\n                {\\n                    res[bottom][i]=val++;\\n                }\\n                bottom--;\\n                direction=4;\\n            }\\n            else if(direction == 4)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                    res[i][left]=val++;\\n                }\\n                left++;\\n                direction = 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941099,
                "title": "python3-solution-using-spiral-traversal-in-o-n-n-time",
                "content": "I have seen some of the solutions to this problem in the discussion section which is mostly related to checking the matrix bounds or validating if the current cell is zero to determine the change of direction. \\n\\nI have actually solved a similar problem before -> https://leetcode.com/problems/spiral-matrix/ and I will try to explain the same approach that I used there as I think its easier to comprehend and seemed more intuitive.\\n\\nThe main idea here is that we initialize **bounds** for four directions: **up**, **down**, **left** and **right**. For each iteration, we **traverse the complete spiral** i.e in all 4 directions. At the end, we just need to **increment or decrement the bounds** accordingly. The code has an extra check after traversing right and down directions to determine if it has landed on same row or column. \\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        up, down, left, right = 0, n-1, 0, n-1\\n        \\n        num = 1\\n        while num <= (n * n):\\n            for idx in range(left, right + 1):\\n                matrix[up][idx] = num\\n                num+=1\\n            \\n            for idx in range(up + 1, down + 1):\\n                matrix[idx][right] = num\\n                num+=1\\n            \\n            # not the same row\\n            if up != down:\\n                for idx in range(right - 1, left - 1, -1):\\n                    matrix[down][idx] = num\\n                    num+=1\\n            #not the same column\\n            if left != right:\\n                for idx in range(down - 1, up, -1):\\n                    matrix[idx][left] = num\\n                    num+=1\\n            \\n            left+=1\\n            up+=1\\n            right-=1\\n            down-=1\\n        return matrix\\n```\\n\\nPlease upvote if you find it useful\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        up, down, left, right = 0, n-1, 0, n-1\\n        \\n        num = 1\\n        while num <= (n * n):\\n            for idx in range(left, right + 1):\\n                matrix[up][idx] = num\\n                num+=1\\n            \\n            for idx in range(up + 1, down + 1):\\n                matrix[idx][right] = num\\n                num+=1\\n            \\n            # not the same row\\n            if up != down:\\n                for idx in range(right - 1, left - 1, -1):\\n                    matrix[down][idx] = num\\n                    num+=1\\n            #not the same column\\n            if left != right:\\n                for idx in range(down - 1, up, -1):\\n                    matrix[idx][left] = num\\n                    num+=1\\n            \\n            left+=1\\n            up+=1\\n            right-=1\\n            down-=1\\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471809,
                "title": "javascript-simple",
                "content": "Runtime: 68 ms, faster than 90.62% of JavaScript online submissions for Spiral Matrix II.\\nMemory Usage: 38.7 MB, less than 83.38% of JavaScript online submissions for Spiral Matrix II.\\n\\n```\\nvar generateMatrix = function(n) {\\n    \\n    let output = new Array(n).fill(0).map(() => new Array(n).fill(0))\\n    \\n    let count = 0;\\n    \\n    let size = n * n;\\n    \\n    let left = 0;\\n    \\n    let right = n - 1;\\n    \\n    let top = 0;\\n    \\n    let bottom = n -1;\\n    \\n    while(count < size){\\n        \\n        //going left\\n        for(let i = left; i <= right; i++){\\n            count++;\\n            output[top][i] = count;\\n        }\\n        top++;\\n                \\n        // going down\\n        for(let i = top; i <= bottom; i++){\\n            count++;\\n            output[i][right] = count;\\n        }\\n        right--;\\n        \\n        //going left\\n        for(let i = right; i >= left; i--){\\n            count++;\\n            output[bottom][i] = count;\\n        }\\n        bottom--;\\n        \\n        //going up\\n        for(let i = bottom; i >= top; i--){\\n            count++;\\n            output[i][left] = count;\\n        }\\n        left++;\\n    }\\n    \\n    return output;\\n    \\n};\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generateMatrix = function(n) {\\n    \\n    let output = new Array(n).fill(0).map(() => new Array(n).fill(0))\\n    \\n    let count = 0;\\n    \\n    let size = n * n;\\n    \\n    let left = 0;\\n    \\n    let right = n - 1;\\n    \\n    let top = 0;\\n    \\n    let bottom = n -1;\\n    \\n    while(count < size){\\n        \\n        //going left\\n        for(let i = left; i <= right; i++){\\n            count++;\\n            output[top][i] = count;\\n        }\\n        top++;\\n                \\n        // going down\\n        for(let i = top; i <= bottom; i++){\\n            count++;\\n            output[i][right] = count;\\n        }\\n        right--;\\n        \\n        //going left\\n        for(let i = right; i >= left; i--){\\n            count++;\\n            output[bottom][i] = count;\\n        }\\n        bottom--;\\n        \\n        //going up\\n        for(let i = bottom; i >= top; i--){\\n            count++;\\n            output[i][left] = count;\\n        }\\n        left++;\\n    }\\n    \\n    return output;\\n    \\n};\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 22295,
                "title": "java-simple-and-clear-easy-understood",
                "content": "```\\npublic class Solution {\\n    public int[][] generateMatrix(int n) {\\n        // similar to spiral matrix I,done by myself\\n        int[][] rs = new int[n][n];\\n        int top = 0,bottom = n-1,left = 0,right = n-1;\\n        int num = 1;\\n        \\n        while(left<=right && top <=bottom){\\n            for(int i=left;i<=right;i++){\\n                rs[top][i] = num++;\\n            }\\n            top++;\\n            for(int i= top;i<=bottom;i++){\\n                rs[i][right] = num++;\\n            }\\n            right--;\\n            for(int i= right;i>=left;i-- ){\\n                rs[bottom][i] = num++;\\n            }\\n            bottom--;\\n            for(int i = bottom;i>=top;i--){\\n                rs[i][left] = num++;\\n            }\\n            left++;\\n        }\\n        return rs;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[][] generateMatrix(int n) {\\n        // similar to spiral matrix I,done by myself\\n        int[][] rs = new int[n][n];\\n        int top = 0,bottom = n-1,left = 0,right = n-1;\\n        int num = 1;\\n        \\n        while(left<=right && top <=bottom){\\n            for(int i=left;i<=right;i++){\\n                rs[top][i] = num++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1738824,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {\\n        let map = [Int](repeating: -1, count: n)\\n        var res = [[Int]](repeating: map, count: n)\\n        let grid = (n * n)\\n        var top = 0, btm = n - 1, lhs = 0, rhs = (n - 1)\\n        var elm = 1\\n        \\n        while elm <= grid {\\n            if lhs <= rhs && elm <= grid { // left -> right\\n                for i in lhs...rhs {\\n                    res[top][i] = elm\\n                    elm += 1\\n                }\\n                top += 1\\n            }\\n            if top <= btm && elm <= grid { // top -> bottom\\n                for i in top...btm {\\n                    res[i][rhs] =  elm\\n                    elm += 1\\n                }\\n                rhs -= 1\\n            }\\n            if lhs <= rhs && elm <= grid { // right -> left\\n                for i in (lhs...rhs).reversed() {\\n                    res[btm][i] = elm\\n                    elm +=  1\\n                }\\n                btm -= 1\\n            }\\n            if top <= btm && elm <= grid { // bottom -> top\\n                for i in (top...btm).reversed() {\\n                    res[i][lhs] = elm\\n                    elm += 1\\n                }\\n                lhs += 1\\n            }\\n        }\\n        return res\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.012 (0.014) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.generateMatrix(3)\\n        XCTAssertEqual(value, [[1,2,3],[8,9,4],[7,6,5]])\\n    }\\n    \\n    func test1() {\\n        let value = solution.generateMatrix(1)\\n        XCTAssertEqual(value, [[1]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {\\n        let map = [Int](repeating: -1, count: n)\\n        var res = [[Int]](repeating: map, count: n)\\n        let grid = (n * n)\\n        var top = 0, btm = n - 1, lhs = 0, rhs = (n - 1)\\n        var elm = 1\\n        \\n        while elm <= grid {\\n            if lhs <= rhs && elm <= grid { // left -> right\\n                for i in lhs...rhs {\\n                    res[top][i] = elm\\n                    elm += 1\\n                }\\n                top += 1\\n            }\\n            if top <= btm && elm <= grid { // top -> bottom\\n                for i in top...btm {\\n                    res[i][rhs] =  elm\\n                    elm += 1\\n                }\\n                rhs -= 1\\n            }\\n            if lhs <= rhs && elm <= grid { // right -> left\\n                for i in (lhs...rhs).reversed() {\\n                    res[btm][i] = elm\\n                    elm +=  1\\n                }\\n                btm -= 1\\n            }\\n            if top <= btm && elm <= grid { // bottom -> top\\n                for i in (top...btm).reversed() {\\n                    res[i][lhs] = elm\\n                    elm += 1\\n                }\\n                lhs += 1\\n            }\\n        }\\n        return res\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.generateMatrix(3)\\n        XCTAssertEqual(value, [[1,2,3],[8,9,4],[7,6,5]])\\n    }\\n    \\n    func test1() {\\n        let value = solution.generateMatrix(1)\\n        XCTAssertEqual(value, [[1]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941149,
                "title": "c-easy-to-understand-solved-live-on-stream",
                "content": "Pretty straight forward.  No special algo.  \\nWe solve problems EVERYDAY 6pm PT.  There are dozens of us.\\n**Link in profile**\\n\\n```\\nclass Solution {\\n    \\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n, 0));\\n        \\n        int top = 0;\\n        int bot = n - 1;\\n        int left = 0;\\n        int right = n - 1;\\n        int dir = 0; \\n        int num = 1;\\n        \\n        while(top <= bot && left <= right) {\\n            if(dir == 0) {\\n                for(int c = left; c <= right; c++) {\\n                    matrix[top][c] = num++;\\n                }\\n                dir++;\\n                top++;\\n            } else if (dir == 1) {\\n                for(int r = top; r <= bot; r++) {\\n                    matrix[r][right] = num++;\\n                }\\n                dir++;\\n                right--;\\n            } else if (dir == 2) {\\n                for(int c = right; c >= left; c--) {\\n                    matrix[bot][c] = num++;\\n                }\\n                dir++;\\n                bot--;\\n            } else if (dir == 3) {\\n                for(int r = bot; r >= top; r--){\\n                    matrix[r][left] = num++;\\n                }\\n                dir = 0;\\n                left++;\\n            }\\n        }      \\n        return matrix;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n, 0));\\n        \\n        int top = 0;\\n        int bot = n - 1;\\n        int left = 0;\\n        int right = n - 1;\\n        int dir = 0; \\n        int num = 1;\\n        \\n        while(top <= bot && left <= right) {\\n            if(dir == 0) {\\n                for(int c = left; c <= right; c++) {\\n                    matrix[top][c] = num++;\\n                }\\n                dir++;\\n                top++;\\n            } else if (dir == 1) {\\n                for(int r = top; r <= bot; r++) {\\n                    matrix[r][right] = num++;\\n                }\\n                dir++;\\n                right--;\\n            } else if (dir == 2) {\\n                for(int c = right; c >= left; c--) {\\n                    matrix[bot][c] = num++;\\n                }\\n                dir++;\\n                bot--;\\n            } else if (dir == 3) {\\n                for(int r = bot; r >= top; r--){\\n                    matrix[r][left] = num++;\\n                }\\n                dir = 0;\\n                left++;\\n            }\\n        }      \\n        return matrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912550,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {\\n        var matrix: [[Int]] = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        let count = n / 2\\n        var num = 1\\n        \\n        for i in 0..<count {\\n            var index = 0\\n            for j in i..<(n - i - 1) {\\n                \\n                let i1 = i\\n                let j1 = j\\n                matrix[i1][j1] =  num + j - i\\n                \\n                let i2 = j\\n                let j2 = n - i - 1\\n                matrix[i2][j2] =  num + j + (n - i * 2 - 1) * 1 - i\\n                \\n                let i3 = n - i - 1\\n                let j3 = n - j - 1\\n                matrix[i3][j3] =  num + j + (n - i * 2 - 1) * 2 - i\\n                \\n                let i4 = n - j - 1\\n                let j4 = i\\n                matrix[i4][j4] =  num + j + (n - i * 2 - 1) * 3 - i\\n                index += 4\\n            }\\n            num += index\\n        }\\n        \\n        if n % 2 == 1 { matrix[(n - 1) / 2][(n - 1) / 2] = n * n }\\n        return matrix\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {\\n        var matrix: [[Int]] = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        let count = n / 2\\n        var num = 1\\n        \\n        for i in 0..<count {\\n            var index = 0\\n            for j in i..<(n - i - 1) {\\n                \\n                let i1 = i\\n                let j1 = j\\n                matrix[i1][j1] =  num + j - i\\n                \\n                let i2 = j\\n                let j2 = n - i - 1\\n                matrix[i2][j2] =  num + j + (n - i * 2 - 1) * 1 - i\\n                \\n                let i3 = n - i - 1\\n                let j3 = n - j - 1\\n                matrix[i3][j3] =  num + j + (n - i * 2 - 1) * 2 - i\\n                \\n                let i4 = n - j - 1\\n                let j4 = i\\n                matrix[i4][j4] =  num + j + (n - i * 2 - 1) * 3 - i\\n                index += 4\\n            }\\n            num += index\\n        }\\n        \\n        if n % 2 == 1 { matrix[(n - 1) / 2][(n - 1) / 2] = n * n }\\n        return matrix\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705624,
                "title": "java-dfs-recursive",
                "content": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        var m = new int[n][n];\\n        dfs(m, 0, 0, false, 1);\\n        return m;\\n    }\\n    private void dfs(int[][] m, int row, int col, boolean goup,int count) {\\n        if (row < 0 || col < 0 || col >= m[0].length || row >= m.length || m[row][col] != 0) return;\\n        m[row][col] = count;\\n        count++;\\n        if (goup) dfs(m, row-1, col, true, count);\\n        dfs(m, row, col+1, false, count);\\n        dfs(m, row + 1, col, false, count);\\n        dfs(m, row, col-1, false, count);\\n        dfs(m, row-1, col, true, count);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        var m = new int[n][n];\\n        dfs(m, 0, 0, false, 1);\\n        return m;\\n    }\\n    private void dfs(int[][] m, int row, int col, boolean goup,int count) {\\n        if (row < 0 || col < 0 || col >= m[0].length || row >= m.length || m[row][col] != 0) return;\\n        m[row][col] = count;\\n        count++;\\n        if (goup) dfs(m, row-1, col, true, count);\\n        dfs(m, row, col+1, false, count);\\n        dfs(m, row + 1, col, false, count);\\n        dfs(m, row, col-1, false, count);\\n        dfs(m, row-1, col, true, count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507200,
                "title": "single-loop-java-solution-easy-to-understand-0-ms",
                "content": "# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int x = 1,cnt = 0;\\n        int[][] ans = new int[n][n];\\n        int i = 0,j = 0,k = 0;\\n        while(cnt < (n * n)){\\n            i(ans[i][j] == 0){\\n                ans[i][j] = x++;\\n                if(i == k && j < n - 1 - k) j++;\\n                else if(j == n - 1 - k && i < n - 1 - k) i++;\\n                else if(i == n - 1 - k && j <= n - 1 - k && j != k) j--;\\n                else if(i <= n - 1 - k && j == k) i--;\\n                cnt++;\\n            }else{ \\n                k++;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int x = 1,cnt = 0;\\n        int[][] ans = new int[n][n];\\n        int i = 0,j = 0,k = 0;\\n        while(cnt < (n * n)){\\n            i(ans[i][j] == 0){\\n                ans[i][j] = x++;\\n                if(i == k && j < n - 1 - k) j++;\\n                else if(j == n - 1 - k && i < n - 1 - k) i++;\\n                else if(i == n - 1 - k && j <= n - 1 - k && j != k) j--;\\n                else if(i <= n - 1 - k && j == k) i--;\\n                cnt++;\\n            }else{ \\n                k++;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941021,
                "title": "javascript-neat-3-methods-elegant-math-no-if",
                "content": "## 1. Elegant (optimized 2nd approach)\\n\\n```js\\nconst generateMatrix = (n) => {\\n  const M = [...Array(n)].map(() => Array(n).fill(0));\\n  let x = 0, y = 0, dx = 1, dy = 0;\\n  for (let i = 1, nn = n**2; i <= nn; ++i) {\\n    M[y][x] = i;\\n    if (!M[y + dy] || M[y + dy][x + dx] !== 0)\\n      [dx, dy] = [-dy, dx];\\n    x += dx;\\n    y += dy;\\n  }\\n  return M;\\n};\\n```\\n\\n## 2. Math power\\n\\n```js\\nconst generateMatrix = (n) => {\\n  const {max, abs, floor} = Math;\\n  const num = (x, y) => {\\n    x += x - n + 1;\\n    y += y - n + 1;\\n    const m = max(abs(x), abs(y));\\n    let p = floor((x + y) / 2);\\n    if (x < y) p = 2 * m - p;\\n    return n * n - m * m - m + p;\\n  }\\n    \\n  const M = [];\\n  for (let y = 0; y < n; ++y) {\\n    M[y] = [];\\n    for (let x = 0; x < n; ++x)\\n      M[y][x] = num(x, y);\\n  }\\n  return M;\\n};\\n```\\n\\n## 3. Without IF\\n\\nThere are the steps in each direction in the spiral for n = 5.\\n`[0, 5, 4, 4, 3, 3, 2, 2, 1, 1]` and for any n `[0, n,  n - 1, n - 1,  ..., 3, 3, 2, 2, 1, 1]`\\nUpdate signs of directions.\\n`[0, 5, 4, -4, -3, 3, 2, -2, -1, 1]`\\n\\n```js\\nconst generateMatrix = (n) => {    \\n  const M = [...Array(n)].map(() => Array(n));\\n  let v = 0, x = -1, y = 0;\\n  for (let i = 0, m, s, dx, dy; i < 2*n; ++i) {\\n    m = i && (2*n - i + 1) / 2|0;\\n    s = (-1)**((i - 1)/2|0);\\n    dx = s * (i % 2);\\n    dy = s * ((i + 1) % 2);\\n    for (let j = 0; j < m; ++j) {\\n      x += dx;\\n      y += dy;\\n      M[y][x] = ++v;\\n    }\\n  }\\n  return M;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst generateMatrix = (n) => {\\n  const M = [...Array(n)].map(() => Array(n).fill(0));\\n  let x = 0, y = 0, dx = 1, dy = 0;\\n  for (let i = 1, nn = n**2; i <= nn; ++i) {\\n    M[y][x] = i;\\n    if (!M[y + dy] || M[y + dy][x + dx] !== 0)\\n      [dx, dy] = [-dy, dx];\\n    x += dx;\\n    y += dy;\\n  }\\n  return M;\\n};\\n```\n```js\\nconst generateMatrix = (n) => {\\n  const {max, abs, floor} = Math;\\n  const num = (x, y) => {\\n    x += x - n + 1;\\n    y += y - n + 1;\\n    const m = max(abs(x), abs(y));\\n    let p = floor((x + y) / 2);\\n    if (x < y) p = 2 * m - p;\\n    return n * n - m * m - m + p;\\n  }\\n    \\n  const M = [];\\n  for (let y = 0; y < n; ++y) {\\n    M[y] = [];\\n    for (let x = 0; x < n; ++x)\\n      M[y][x] = num(x, y);\\n  }\\n  return M;\\n};\\n```\n```js\\nconst generateMatrix = (n) => {    \\n  const M = [...Array(n)].map(() => Array(n));\\n  let v = 0, x = -1, y = 0;\\n  for (let i = 0, m, s, dx, dy; i < 2*n; ++i) {\\n    m = i && (2*n - i + 1) / 2|0;\\n    s = (-1)**((i - 1)/2|0);\\n    dx = s * (i % 2);\\n    dy = s * ((i + 1) % 2);\\n    for (let j = 0; j < m; ++j) {\\n      x += dx;\\n      y += dy;\\n      M[y][x] = ++v;\\n    }\\n  }\\n  return M;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 963337,
                "title": "c-100-simple-walk-the-spiral-solution",
                "content": "My C++ walk the spiral solution going clockwise from outside to inside\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        // create n * n vector of vectors we will populate and return at the end\\n        vector<vector<int>> result(n, vector<int>(n));\\n        \\n        // calculate how many levels deep the spiral is and keep count of walking the spiral\\n        int level = ceil(n / 2), count = 1;\\n        \\n        // start from outside level moving inside\\n        for (int l = 0; l <= level; ++l) {\\n            // populate top row from left to right\\n            for (int a = l; a < n - l; ++a) result[l][a] = count++;\\n            \\n            // populate right column from top to bottom\\n            for (int b = l + 1; b < n - l; ++b) result[b][n - l - 1] = count++;\\n            \\n            // populate bottom row from right to left\\n            for (int c = l + 1; c < n - l; ++c) result[n - l - 1][n - c - 1] = count++;\\n            \\n            // populate left column from bottom to top\\n            for (int d = l + 1; d < n - l - 1; ++d) result[n - d - 1][l] = count++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        // create n * n vector of vectors we will populate and return at the end\\n        vector<vector<int>> result(n, vector<int>(n));\\n        \\n        // calculate how many levels deep the spiral is and keep count of walking the spiral\\n        int level = ceil(n / 2), count = 1;\\n        \\n        // start from outside level moving inside\\n        for (int l = 0; l <= level; ++l) {\\n            // populate top row from left to right\\n            for (int a = l; a < n - l; ++a) result[l][a] = count++;\\n            \\n            // populate right column from top to bottom\\n            for (int b = l + 1; b < n - l; ++b) result[b][n - l - 1] = count++;\\n            \\n            // populate bottom row from right to left\\n            for (int c = l + 1; c < n - l; ++c) result[n - l - 1][n - c - 1] = count++;\\n            \\n            // populate left column from bottom to top\\n            for (int d = l + 1; d < n - l - 1; ++d) result[n - d - 1][l] = count++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22473,
                "title": "share-my-simple-solution-with-graphical-explanation-java",
                "content": "If n is odd, only the first direction will cover it (top left -> right, shown as # in the graph), because the other three direction all start from the next position( +1 or -1).\\n\\n    /**\\n    \\t * -> -> ->\\n    \\t * ^      |\\n    \\t * |      |\\n    \\t * <- <-- V\\n    \\t * \\n    \\t * # # # #\\n    \\t * %     $\\n    \\t * %     $\\n    \\t * & & & $\\n    \\t *     \\n    \\t */\\n        public static int[][] generateMatrix(int n) {\\n        \\tint[][] res = new int[n][n];\\n        \\t\\n        \\tint num = 1;\\n        \\tint level = (int) Math.ceil(n / 2.);\\n        \\t\\n        \\tfor(int i = 0; i < level; i++) {\\n        \\t\\t\\n        \\t\\t// top left -> right, shown as #\\n        \\t\\tfor(int j = i; j < n - i; j++)\\n        \\t\\t\\tres[i][j] = num++;\\n        \\t\\t\\n        \\t\\t// top right + 1 -> bot, shown as $\\n        \\t\\tfor(int j = i + 1; j < n - i; j++)\\n        \\t\\t\\tres[j][n - i - 1] = num++;\\n        \\t\\t\\n        \\t\\t// bot right - 1 -> left, shown as &\\n        \\t\\tfor(int j = n - i - 2; j >= i; j--)\\n        \\t\\t\\tres[n - i - 1][j] = num++;\\n        \\t\\t\\n        \\t\\t// bot left -1 -> top + 1, shown as %\\n        \\t\\tfor(int j = n - i - 2; j > i; j--)\\n        \\t\\t\\tres[j][i] = num++;\\n        \\t}\\n        \\treturn res;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "If n is odd, only the first direction will cover it (top left -> right, shown as # in the graph), because the other three direction all start from the next position( +1 or -1).\\n\\n    /**\\n    \\t * -> -> ->\\n    \\t * ^      |\\n    \\t * |      |\\n    \\t * <- <-- V\\n    \\t * \\n    \\t * # # # #\\n    \\t * %     $\\n    \\t * %     $\\n    \\t * & & & $\\n    \\t *     \\n    \\t */\\n        public static int[][] generateMatrix(int n) {\\n        \\tint[][] res = new int[n][n];\\n        \\t\\n        \\tint num = 1;\\n        \\tint level = (int) Math.ceil(n / 2.);\\n        \\t\\n        \\tfor(int i = 0; i < level; i++) {\\n        \\t\\t\\n        \\t\\t// top left -> right, shown as #\\n        \\t\\tfor(int j = i; j < n - i; j++)\\n        \\t\\t\\tres[i][j] = num++;\\n        \\t\\t\\n        \\t\\t// top right + 1 -> bot, shown as $\\n        \\t\\tfor(int j = i + 1; j < n - i; j++)\\n        \\t\\t\\tres[j][n - i - 1] = num++;\\n        \\t\\t\\n        \\t\\t// bot right - 1 -> left, shown as &\\n        \\t\\tfor(int j = n - i - 2; j >= i; j--)\\n        \\t\\t\\tres[n - i - 1][j] = num++;\\n        \\t\\t\\n        \\t\\t// bot left -1 -> top + 1, shown as %\\n        \\t\\tfor(int j = n - i - 2; j > i; j--)\\n        \\t\\t\\tres[j][i] = num++;\\n        \\t}\\n        \\treturn res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3507105,
                "title": "simple-java-solution-beginner-friendly-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStarting from the top left corner and moving clockwise. It traverse by filling the top row, right column, bottom row, and left column of the matrix in sequence until the entire matrix is filled.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize a 2D array of size n x n with all elements set to 0.\\n- Use four variables l, t, b, and r to keep track of the boundaries of the matrix.\\n- Use a while loop that continues until either t becomes greater than b or l becomes greater than r, indicating that the entire matrix has been filled.\\n- Use four nested if statements, each of which generates a segment of the spiral by iterating through the appropriate row or column and assigning values to the matrix elements.\\n- After each segment is generated, update the corresponding boundary variables to exclude the row or column that has been filled.\\n- Return the resulting matrix.\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int [][] a = new int[n][n];\\n        int l=0,t=0,b=n-1,r=n-1,v=1;\\n        while(t<=b||l<=r){\\n         if(t<=b){\\n             for(int i=l;i<=r;i++)\\n                a[t][i]=v++;\\n             t++;\\n         }\\n         if(l<=r){\\n             for(int i=t;i<=b;i++)\\n                 a[i][r]=v++;\\n             r--;\\n         }\\n         if(t<=b){\\n             for(int i=r;i>=l;i--)\\n             a[b][i]=v++;\\n             b--;\\n         }\\n         if(t<=b){\\n             for(int i=b;i>=t;i--)\\n             a[i][l]=v++;\\n         }\\n         l++;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int [][] a = new int[n][n];\\n        int l=0,t=0,b=n-1,r=n-1,v=1;\\n        while(t<=b||l<=r){\\n         if(t<=b){\\n             for(int i=l;i<=r;i++)\\n                a[t][i]=v++;\\n             t++;\\n         }\\n         if(l<=r){\\n             for(int i=t;i<=b;i++)\\n                 a[i][r]=v++;\\n             r--;\\n         }\\n         if(t<=b){\\n             for(int i=r;i>=l;i--)\\n             a[b][i]=v++;\\n             b--;\\n         }\\n         if(t<=b){\\n             for(int i=b;i>=t;i--)\\n             a[i][l]=v++;\\n         }\\n         l++;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506353,
                "title": "c-beats-100-solution-t-c-o-n-n-fully-explained-step-by-step",
                "content": "\\n# Approach\\n1.Here we have a sqare matrix of size n*n;\\n2.declare variables like starting top=0, right= n-1, left=0, bottom= n-1 and a =1.\\n3.declare count=0 and check it at every moment that it is less than and equal to end.\\nfirst we will print first row, by moving from left to right. and increase top by 1, so that we can print next row in second iteration and insert value in vector and increase by 1.\\nThen, we will print last column, by moving from top to bottom and decrease right by 1 so that we can to next inner col and insert value in vector and increase by 1.\\nthen we will print last row, by moving from right to left. and decrease bottom by 1, so that we can move to next inner row in next iteration and insert value in vector and increase by 1.\\nthen we will print first col, by moving from bottom to top, and increase left by 1, so that we can move to next col in next iteration and insert value in vector and increase by 1.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>res(n,vector<int>(n));\\n        int top=0;int left=0;\\n        int right=n-1;int bottom=n-1;\\n        int a=1;\\n        while(top<=bottom && left<=right){\\n            for(int i=left;i<=right;i++){//top\\n                \\n                res[top][i]=a;\\n                a++;\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){//right\\n                res[i][right]=a;\\n                a++;\\n            }\\n            right--;\\n            if(top<=bottom){\\n                for(int i=right;i>=left;i--){//bottom in reverse\\n                res[bottom][i]=a;\\n                a++;\\n            }\\n            bottom--;\\n            }\\n            if(left<=right){\\n                for(int i=bottom;i>=top;i--){//left in reverse\\n                res[i][left]=a;\\n                a++;\\n            }\\n            left++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>res(n,vector<int>(n));\\n        int top=0;int left=0;\\n        int right=n-1;int bottom=n-1;\\n        int a=1;\\n        while(top<=bottom && left<=right){\\n            for(int i=left;i<=right;i++){//top\\n                \\n                res[top][i]=a;\\n                a++;\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){//right\\n                res[i][right]=a;\\n                a++;\\n            }\\n            right--;\\n            if(top<=bottom){\\n                for(int i=right;i>=left;i--){//bottom in reverse\\n                res[bottom][i]=a;\\n                a++;\\n            }\\n            bottom--;\\n            }\\n            if(left<=right){\\n                for(int i=bottom;i>=top;i--){//left in reverse\\n                res[i][left]=a;\\n                a++;\\n            }\\n            left++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202560,
                "title": "spiral-matrix-i-ii-iii-iv-solutions",
                "content": "# Explaination\\n- This is a very simple and easy to understand solution. I have traversed RIGHT and incremented TOP, then traverse DOWN and decrement RIGHT, then I traverse LEFT and decrement BOTTOM, and finally I have traversed UP and increment LEFT.\\n\\n- The only tricky part is that when I traverse left or up I have to check whether the row or col still exists to prevent duplicates. \\nAny comments greatly appreciated.\\n\\n# Complexity\\n- Time Complexity: O(m*n)\\n- Space Complexity: O(1)\\n\\n# Spiral Matrix I\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> v;\\n        if (matrix.size() == 0) \\n            return v;\\n        \\n        int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size()- 1;\\n        \\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                v.push_back(matrix[top][i]);\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                v.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            for (int i = right; top <= bottom && i >= left; i--) {\\n                v.push_back(matrix[bottom][i]);\\n            }\\n            bottom--;\\n            \\n            for (int i = bottom; left <= right && i >= top; i--) {\\n                v.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return v;\\n    }\\n};\\n```\\n# Spiral Matrix II\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int> (n, 0));\\n        \\n        int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size()- 1;\\n        int count = 1;\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = count;\\n                count++;\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = count;\\n                count++;\\n            }\\n            right--;\\n            \\n            for (int i = right; top <= bottom && i >= left; i--) {\\n                matrix[bottom][i] = count;\\n                count++;\\n            }\\n            bottom--;\\n            \\n            for (int i = bottom; left <= right && i >= top; i--) {\\n                matrix[i][left] = count;\\n                count++;\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n};\\n```\\n# Spiral Matrix III\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> matrix;\\n        int count = 0, step = 1;\\n        \\n        while(count < rows*cols){\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                cStart++;\\n            }\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                rStart++;\\n            }\\n            step++;\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                cStart--;\\n            }\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                rStart--;\\n            }\\n            step++;\\n        }\\n        return matrix;\\n    }\\n};\\n```\\n# Sprial Matrix IV\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> matrix(m, vector<int> (n, -1));\\n        int left = 0, right = n-1, top = 0, bottom = m-1;\\n        while(left<=right and top<=bottom){\\n            for(int i = left; i<=right; i++){\\n                if(head){\\n                    matrix[top][i] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            top++;\\n            for(int i = top; i<=bottom; i++){\\n                if(head){\\n                    matrix[i][right] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            right--;\\n            for(int i = right; top<=bottom && i>=left; i--){ \\n                if(head){\\n                    matrix[bottom][i] = head->val;\\n                    head = head->next;\\n                }\\n            }   \\n            bottom--;\\n            for(int i = bottom; left<=right && i>=top; i--){\\n                if(head){\\n                    matrix[i][left] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> v;\\n        if (matrix.size() == 0) \\n            return v;\\n        \\n        int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size()- 1;\\n        \\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                v.push_back(matrix[top][i]);\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                v.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            for (int i = right; top <= bottom && i >= left; i--) {\\n                v.push_back(matrix[bottom][i]);\\n            }\\n            bottom--;\\n            \\n            for (int i = bottom; left <= right && i >= top; i--) {\\n                v.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int> (n, 0));\\n        \\n        int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size()- 1;\\n        int count = 1;\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = count;\\n                count++;\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = count;\\n                count++;\\n            }\\n            right--;\\n            \\n            for (int i = right; top <= bottom && i >= left; i--) {\\n                matrix[bottom][i] = count;\\n                count++;\\n            }\\n            bottom--;\\n            \\n            for (int i = bottom; left <= right && i >= top; i--) {\\n                matrix[i][left] = count;\\n                count++;\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> matrix;\\n        int count = 0, step = 1;\\n        \\n        while(count < rows*cols){\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                cStart++;\\n            }\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                rStart++;\\n            }\\n            step++;\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                cStart--;\\n            }\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                rStart--;\\n            }\\n            step++;\\n        }\\n        return matrix;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> matrix(m, vector<int> (n, -1));\\n        int left = 0, right = n-1, top = 0, bottom = m-1;\\n        while(left<=right and top<=bottom){\\n            for(int i = left; i<=right; i++){\\n                if(head){\\n                    matrix[top][i] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            top++;\\n            for(int i = top; i<=bottom; i++){\\n                if(head){\\n                    matrix[i][right] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            right--;\\n            for(int i = right; top<=bottom && i>=left; i--){ \\n                if(head){\\n                    matrix[bottom][i] = head->val;\\n                    head = head->next;\\n                }\\n            }   \\n            bottom--;\\n            for(int i = bottom; left<=right && i>=top; i--){\\n                if(head){\\n                    matrix[i][left] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309475,
                "title": "easy-java-solution-beats-100-online-java-submissions",
                "content": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n       int[][] ans=new int[n][n];\\n       \\n        int rowBegin=0;\\n        int rowEnd=n-1;\\n        int columnBegin=0;\\n        int columnEnd=n-1;\\n        int counter=0;\\n      \\n        while(rowBegin<=rowEnd && columnBegin<=columnEnd && counter<=n*n){\\n            \\n            for(int i=columnBegin;i<=columnEnd;i++){\\n                counter++;\\n                ans[rowBegin][i]=counter;\\n            }\\n            rowBegin++;\\n            for(int i=rowBegin;i<=rowEnd;i++){\\n                counter++;\\n                ans[i][columnEnd]=counter;\\n            }\\n            columnEnd--;\\n            if(rowBegin<=rowEnd){\\n                for(int i=columnEnd;i>=columnBegin;i--){\\n                counter++;\\n                ans[rowEnd][i]=counter;\\n            }\\n           \\n            }\\n             rowEnd--;\\n            if(columnBegin<=columnEnd){\\n                for(int i=rowEnd;i>=rowBegin;i--){\\n                counter++;    \\n                ans[i][columnBegin]=counter;\\n            }\\n            \\n            }\\n            columnBegin++;\\n           \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n       int[][] ans=new int[n][n];\\n       \\n        int rowBegin=0;\\n        int rowEnd=n-1;\\n        int columnBegin=0;\\n        int columnEnd=n-1;\\n        int counter=0;\\n      \\n        while(rowBegin<=rowEnd && columnBegin<=columnEnd && counter<=n*n){\\n            \\n            for(int i=columnBegin;i<=columnEnd;i++){\\n                counter++;\\n                ans[rowBegin][i]=counter;\\n            }\\n            rowBegin++;\\n            for(int i=rowBegin;i<=rowEnd;i++){\\n                counter++;\\n                ans[i][columnEnd]=counter;\\n            }\\n            columnEnd--;\\n            if(rowBegin<=rowEnd){\\n                for(int i=columnEnd;i>=columnBegin;i--){\\n                counter++;\\n                ans[rowEnd][i]=counter;\\n            }\\n           \\n            }\\n             rowEnd--;\\n            if(columnBegin<=columnEnd){\\n                for(int i=rowEnd;i>=rowBegin;i--){\\n                counter++;    \\n                ans[i][columnBegin]=counter;\\n            }\\n            \\n            }\\n            columnBegin++;\\n           \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941152,
                "title": "c-two-pointer-approach",
                "content": "```\\nAlgorithm\\n---------\\n* Step1: Initialize beg = 0 and end  = n - 1\\n* Step2: Repeat Step3 to Step7 while beg < end\\n* Step3: Fill current first row(beg) from left-right\\n* Step4: Fill current last column(end) from top-bottom\\n* Step5: Fill current last row(end) from right-left\\n* Step6: Fill current first column(beg) from bottom-top\\n* Step7: Increment beg and decrement end\\n* Step8: Go to Step2\\n* Step9: Fill the cell[beg][end] if beg == end\\n* Step10: Return matrix\\n\\nComplexities\\n------------\\n* Time: O(n*n)\\n* Space: O(1)\\n\\nNote: Since, the matrix is square, we can traverse it spirally by using just 2 pointers.\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n        \\n        int beg = 0, end = n - 1, temp = -1, ptr = 1;\\n        while(beg < end) {\\n            // fill left to right\\n            temp = beg;\\n            while(temp < end) {\\n                matrix[beg][temp++] = ptr++;\\n            }\\n            \\n            // fill top to bottom\\n            temp = beg;\\n            while(temp < end) {\\n                matrix[temp++][end] = ptr++;\\n            }\\n            \\n            //fill right to left\\n            temp = end;\\n            while(temp > beg) {\\n                matrix[end][temp--] = ptr++;\\n            }\\n            \\n            //fill bottom to top\\n            temp = end;\\n            while(temp > beg) {\\n                matrix[temp--][beg] = ptr++;\\n            }\\n            beg++;\\n            end--;\\n        }\\n        \\n        // for odd n\\n        if(beg == end) matrix[beg][end] = ptr;\\n        return matrix;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nAlgorithm\\n---------\\n* Step1: Initialize beg = 0 and end  = n - 1\\n* Step2: Repeat Step3 to Step7 while beg < end\\n* Step3: Fill current first row(beg) from left-right\\n* Step4: Fill current last column(end) from top-bottom\\n* Step5: Fill current last row(end) from right-left\\n* Step6: Fill current first column(beg) from bottom-top\\n* Step7: Increment beg and decrement end\\n* Step8: Go to Step2\\n* Step9: Fill the cell[beg][end] if beg == end\\n* Step10: Return matrix\\n\\nComplexities\\n------------\\n* Time: O(n*n)\\n* Space: O(1)\\n\\nNote: Since, the matrix is square, we can traverse it spirally by using just 2 pointers.\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n        \\n        int beg = 0, end = n - 1, temp = -1, ptr = 1;\\n        while(beg < end) {\\n            // fill left to right\\n            temp = beg;\\n            while(temp < end) {\\n                matrix[beg][temp++] = ptr++;\\n            }\\n            \\n            // fill top to bottom\\n            temp = beg;\\n            while(temp < end) {\\n                matrix[temp++][end] = ptr++;\\n            }\\n            \\n            //fill right to left\\n            temp = end;\\n            while(temp > beg) {\\n                matrix[end][temp--] = ptr++;\\n            }\\n            \\n            //fill bottom to top\\n            temp = end;\\n            while(temp > beg) {\\n                matrix[temp--][beg] = ptr++;\\n            }\\n            beg++;\\n            end--;\\n        }\\n        \\n        // for odd n\\n        if(beg == end) matrix[beg][end] = ptr;\\n        return matrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791511,
                "title": "python-simple-logic",
                "content": "We can move in 4 directions:\\nIf direction == 0: Move from left to right in top row\\nIf direction == 1: Move from top to bottom in right column\\nIf direction == 2: Move from right to left in bottom row\\nIf direction == 3: Move from bottom to top in left column\\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        if not n:\\n            return []\\n        if n == 1:\\n            return [[1]]\\n        \\n        ans = [[0]* n for _ in range(n)]\\n        \\n        left, right = 0, n-1\\n        top, bottom = 0, n-1\\n        \\n        k = 1\\n        direction = 0\\n        \\n        while left <= right and top <= bottom:\\n            # from left to right in top row\\n            if direction == 0:\\n                for j in range(left, right+1):\\n                    ans[top][j] = k\\n                    k += 1\\n                top += 1\\n                direction = 1\\n            elif direction == 1:\\n                # from top to bottom in right column\\n                for i in range(top, bottom+1):\\n                    ans[i][right] = k\\n                    k += 1\\n                right -= 1\\n                direction = 2\\n            elif direction == 2:\\n                # from right to left in bottom row\\n                for j in range(right, left-1, -1):\\n                    ans[bottom][j] = k\\n                    k += 1\\n                bottom -= 1\\n                direction = 3\\n            else:\\n                # bottom to top in left column\\n                for i in range(bottom, top-1, -1):\\n                    ans[i][left] = k\\n                    k += 1\\n                left += 1\\n                direction = 0\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "We can move in 4 directions:\\nIf direction == 0: Move from left to right in top row\\nIf direction == 1: Move from top to bottom in right column\\nIf direction == 2: Move from right to left in bottom row\\nIf direction == 3: Move from bottom to top in left column\\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        if not n:\\n            return []\\n        if n == 1:\\n            return [[1]]\\n        \\n        ans = [[0]* n for _ in range(n)]\\n        \\n        left, right = 0, n-1\\n        top, bottom = 0, n-1\\n        \\n        k = 1\\n        direction = 0\\n        \\n        while left <= right and top <= bottom:\\n            # from left to right in top row\\n            if direction == 0:\\n                for j in range(left, right+1):\\n                    ans[top][j] = k\\n                    k += 1\\n                top += 1\\n                direction = 1\\n            elif direction == 1:\\n                # from top to bottom in right column\\n                for i in range(top, bottom+1):\\n                    ans[i][right] = k\\n                    k += 1\\n                right -= 1\\n                direction = 2\\n            elif direction == 2:\\n                # from right to left in bottom row\\n                for j in range(right, left-1, -1):\\n                    ans[bottom][j] = k\\n                    k += 1\\n                bottom -= 1\\n                direction = 3\\n            else:\\n                # bottom to top in left column\\n                for i in range(bottom, top-1, -1):\\n                    ans[i][left] = k\\n                    k += 1\\n                left += 1\\n                direction = 0\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 22381,
                "title": "7-line-python-solution-step-pattern-is-n-n-1-n-1-n-2-n-2-2-2-1-1",
                "content": "If `n` is 5, `step` list will be [5, 4, 4, 3, 3, 2, 2, 1, 1], it means move forward 5 steps, turn right, move forward 4 steps, turn right, move forward 4 steps, turn right and so on. `x` axis is from left to right, `y` axis is from top to bottom, we start from point `(-1, 0)`.\\n\\n    def generateMatrix(self, n):\\n        mat, x, y, dx, dy, number = [[0] * n for i in xrange(n)], -1, 0, 1, 0, 0\\n        for step in [i / 2 for i in xrange(2 * n, 1, -1)]:\\n            for j in xrange(step):\\n                x, y, number = x + dx, y + dy, number + 1\\n                mat[y][x] = number\\n            dx, dy = -dy, dx # turn right\\n        return mat",
                "solutionTags": [
                    "Python"
                ],
                "code": "If `n` is 5, `step` list will be [5, 4, 4, 3, 3, 2, 2, 1, 1], it means move forward 5 steps, turn right, move forward 4 steps, turn right, move forward 4 steps, turn right and so on. `x` axis is from left to right, `y` axis is from top to bottom, we start from point `(-1, 0)`.\\n\\n    def generateMatrix(self, n):\\n        mat, x, y, dx, dy, number = [[0] * n for i in xrange(n)], -1, 0, 1, 0, 0\\n        for step in [i / 2 for i in xrange(2 * n, 1, -1)]:\\n            for j in xrange(step):\\n                x, y, number = x + dx, y + dy, number + 1\\n                mat[y][x] = number\\n            dx, dy = -dy, dx # turn right\\n        return mat",
                "codeTag": "Python3"
            },
            {
                "id": 3516518,
                "title": "easy-java-solution-with-proper-explanation-beats-100-in-tc",
                "content": "![Screenshot 2023-05-12 at 18.46.26.png](https://assets.leetcode.com/users/images/bb2248b9-f6b1-48ee-92ec-27c3e3612f5b_1683902818.4458783.png)\\n\\n\\n\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis code initializes an n x n matrix with all elements set to zero. It then uses four variables t, b, l, and r to keep track of the boundaries of the current spiral. It starts filling the matrix by traversing from left to right along the top boundary, then from top to bottom along the right boundary, then from right to left along the bottom boundary, and finally from bottom to top along the left boundary. It repeats this process until all elements have been filled in the matrix. Finally, it returns the filled matrix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N*N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        int[][] arr = new int[n][n];\\n        int b = n, r = n;\\n        int t = 0, l = 0, size = b*r,s=1;\\n        while(t<=b && l<=r){\\n            for (int i = l; i < r; i++) {\\n                arr[t][i]=s++;\\n            }\\n            t++;\\n            for (int i = t; i < b; i++) {\\n                arr[i][r-1] = s++;\\n            }\\n            r--;\\n\\n            for (int i = r-1; i >= l; i--) {\\n                arr[b-1][i] = s++;\\n            }\\n            b--;\\n\\n            for (int i = b-1; i >= t; i--) {\\n                arr[i][l]=s++;\\n            }\\n            l++;\\n\\n\\n        }\\n        return arr;\\n\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        int[][] arr = new int[n][n];\\n        int b = n, r = n;\\n        int t = 0, l = 0, size = b*r,s=1;\\n        while(t<=b && l<=r){\\n            for (int i = l; i < r; i++) {\\n                arr[t][i]=s++;\\n            }\\n            t++;\\n            for (int i = t; i < b; i++) {\\n                arr[i][r-1] = s++;\\n            }\\n            r--;\\n\\n            for (int i = r-1; i >= l; i--) {\\n                arr[b-1][i] = s++;\\n            }\\n            b--;\\n\\n            for (int i = b-1; i >= t; i--) {\\n                arr[i][l]=s++;\\n            }\\n            l++;\\n\\n\\n        }\\n        return arr;\\n\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509960,
                "title": "java-spiral-matrix-2",
                "content": "\\n```\\nclass Solution {\\n    public static void spiralOrder(int[][] matrix) {\\n        int move[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n        int x = 0;\\n        int y = -1;\\n        int i = 0;\\n        boolean finish = false;\\n        int ch = 1;\\n        while (!finish) {\\n            finish = true;\\n            while (true) {\\n                int tmpX = x;\\n                int tmpY = y;\\n                if (x + move[i % 4][0] < matrix.length && x + move[i % 4][0] > -1) x += move[i % 4][0];\\n                if (y + move[i % 4][1] < matrix[0].length && y + move[i % 4][1] > -1) y += move[i % 4][1];\\n                if (x < matrix.length && y < matrix[0].length && matrix[x][y] == 0) {\\n                    matrix[x][y] = ch++;\\n                    finish = false;\\n                }\\n                else {\\n                    x = tmpX;\\n                    y = tmpY;\\n                    break;\\n                }\\n            }\\n            i++;\\n        }\\n    }\\n\\n    public static int[][] generateMatrix(int n) {\\n        int matrix[][] = new int[n][n];\\n        spiralOrder(matrix);\\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static void spiralOrder(int[][] matrix) {\\n        int move[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n        int x = 0;\\n        int y = -1;\\n        int i = 0;\\n        boolean finish = false;\\n        int ch = 1;\\n        while (!finish) {\\n            finish = true;\\n            while (true) {\\n                int tmpX = x;\\n                int tmpY = y;\\n                if (x + move[i % 4][0] < matrix.length && x + move[i % 4][0] > -1) x += move[i % 4][0];\\n                if (y + move[i % 4][1] < matrix[0].length && y + move[i % 4][1] > -1) y += move[i % 4][1];\\n                if (x < matrix.length && y < matrix[0].length && matrix[x][y] == 0) {\\n                    matrix[x][y] = ch++;\\n                    finish = false;\\n                }\\n                else {\\n                    x = tmpX;\\n                    y = tmpY;\\n                    break;\\n                }\\n            }\\n            i++;\\n        }\\n    }\\n\\n    public static int[][] generateMatrix(int n) {\\n        int matrix[][] = new int[n][n];\\n        spiralOrder(matrix);\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506563,
                "title": "simple-clean-beats-100",
                "content": "# Intuition\\nSimple brute force\\n\\n# Approach\\nWe use left , right , top , bottom pointers to represent the configuration of the matrix.\\nSTEPS of traversal:\\n\\n1. Traverse from left to right , then update top=top+1, AS topmost row is filled.\\n\\n2. Traverse from top to bottom, then update right=right-1, AS rightmost column is filled.\\n\\n3. Traverse from right to left, then update bottom= bottom-1 , AS \\nbottomMost row is filled.\\n\\n 4. Traverse from bottom to top, then update left=left+1, \\n  AS leftmost column is filled.\\n\\n# Complexity\\n- Time complexity:\\n  O(N*N) for traversing the matrix.\\n\\n- Space complexity:\\n  O(N*N) for storing the matrix.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int num=1,left=0,right=n-1,top=0,bottom=n-1;\\n        vector<vector<int>>matrix(n,vector<int>(n));\\n\\n        while(left<=right && top<=bottom){\\n            for(int i=left; i<=right; i++){\\n                matrix[top][i]=num++;\\n            }\\n            top++;\\n\\n            for(int i=top;i<=bottom;i++){\\n                matrix[i][right]=num++;\\n            }\\n            right--;\\n\\n            for(int i=right;i>=left;i--){\\n                matrix[bottom][i]=num++;\\n            }\\n            bottom--;\\n\\n            for(int i=bottom;i>=top;i--){\\n                matrix[i][left]=num++;\\n            }\\n            left++;\\n        }\\n\\n        return matrix;\\n    }\\n};\\n\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int num=1,left=0,right=n-1,top=0,bottom=n-1;\\n        vector<vector<int>>matrix(n,vector<int>(n));\\n\\n        while(left<=right && top<=bottom){\\n            for(int i=left; i<=right; i++){\\n                matrix[top][i]=num++;\\n            }\\n            top++;\\n\\n            for(int i=top;i<=bottom;i++){\\n                matrix[i][right]=num++;\\n            }\\n            right--;\\n\\n            for(int i=right;i>=left;i--){\\n                matrix[bottom][i]=num++;\\n            }\\n            bottom--;\\n\\n            for(int i=bottom;i>=top;i--){\\n                matrix[i][left]=num++;\\n            }\\n            left++;\\n        }\\n\\n        return matrix;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506487,
                "title": "99-6-javascript-easy-to-understand",
                "content": "Visit my youtube! Thank you!\\nhttps://www.youtube.com/channel/UCkhEaNAOO8tig5NHqqxXIeg\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar generateMatrix = function(n) {\\n    let save = Array.from(Array(n),()=>new Array(n).fill(0))\\n    let count =1;\\n    let left =0;\\n    let right =n-1;\\n    let bottom = n-1;\\n    let top = 0;\\n    let dir = 0;\\n\\n    while(count <= n*n){\\n        if(dir == 0){\\n            for(let i =left; i<=right; i++){\\n                save[top][i] = count;\\n                count++\\n            }\\n            top++\\n            dir++\\n        }\\n        if(dir == 1){\\n            for(let i =top; i<=bottom; i++){\\n                save[i][right] = count;\\n                count++\\n            }\\n            right--\\n            dir++        \\n        }\\n        if(dir == 2){\\n            for(let i =right; i>=left; i--){\\n                save[bottom][i] = count;\\n                count++\\n            }\\n            bottom--\\n            dir++        \\n        }\\n        if(dir == 3){\\n            for(let i =bottom; i>=top; i--){\\n                save[i][left] = count;\\n                count++\\n            }\\n            left++\\n            dir++        \\n        }\\n        dir = 0;\\n    }\\n\\n    return save;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar generateMatrix = function(n) {\\n    let save = Array.from(Array(n),()=>new Array(n).fill(0))\\n    let count =1;\\n    let left =0;\\n    let right =n-1;\\n    let bottom = n-1;\\n    let top = 0;\\n    let dir = 0;\\n\\n    while(count <= n*n){\\n        if(dir == 0){\\n            for(let i =left; i<=right; i++){\\n                save[top][i] = count;\\n                count++\\n            }\\n            top++\\n            dir++\\n        }\\n        if(dir == 1){\\n            for(let i =top; i<=bottom; i++){\\n                save[i][right] = count;\\n                count++\\n            }\\n            right--\\n            dir++        \\n        }\\n        if(dir == 2){\\n            for(let i =right; i>=left; i--){\\n                save[bottom][i] = count;\\n                count++\\n            }\\n            bottom--\\n            dir++        \\n        }\\n        if(dir == 3){\\n            for(let i =bottom; i>=top; i--){\\n                save[i][left] = count;\\n                count++\\n            }\\n            left++\\n            dir++        \\n        }\\n        dir = 0;\\n    }\\n\\n    return save;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1942901,
                "title": "cpp-easy",
                "content": "class Solution {\\npublic:\\n\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> res(n,vector<int>(n,0));\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        int x=1;\\n        while(x<=n*n){\\n            for(int i=left;i<=right;i++)\\n                res[top][i]=x++;\\n            top++;\\n            for(int i=top;i<=bottom;i++)\\n                res[i][right]=x++;\\n            right--;\\n            for(int i=right;i>=left;i--)\\n                res[bottom][i]=x++;\\n            bottom--;\\n            for(int i=bottom;i>=top;i--)\\n                res[i][left]=x++;\\n            left++;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> res(n,vector<int>(n,0));\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        int x=1;\\n        while(x<=n*n){\\n            for(int i=left;i<=right;i++)\\n                res[top][i]=x++;\\n            top++;\\n            for(int i=top;i<=bottom;i++)\\n                res[i][right]=x++;\\n            right--;\\n            for(int i=right;i>=left;i--)\\n                res[bottom][i]=x++;\\n            bottom--;\\n            for(int i=bottom;i>=top;i--)\\n                res[i][left]=x++;\\n            left++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1855638,
                "title": "simple-c-solution-with-explanation-commented-faster-than-100-00-of-c-online-submissions",
                "content": "Algorithm:\\n\\n* Enter value in starting row (horizonal, left to right)\\n* Enter value in ending column (vertical, top to bottom)\\n* Enter value in ending row (horizonal, right to left)\\n* Enter value in starting column (vertical, bottom to top)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,1));\\n        //index intialisation\\n        int strow=0, stcol=0;\\n        int endrow=n-1,endcol=n-1;\\n        //counters\\n        int cnt=n*n;\\n        int a=1;\\n        \\n        while(a<=cnt){\\n            \\n            //enter value in starting row\\n            for(int i=stcol;i<=endcol&&a<=cnt;i++){\\n                ans[strow][i]=a;\\n                a++;\\n            }\\n            strow++;\\n            \\n            //enter value in ending col\\n            for(int i=strow;i<=endrow&&a<=cnt;i++){\\n                ans[i][endcol]=a;\\n                a++;\\n            }\\n            endcol--;\\n            \\n            //enter value in ending row\\n            for(int i=endcol;i>=stcol&&a<=cnt;i--){\\n                ans[endrow][i]=a;\\n                a++;\\n            }\\n            endrow--;\\n            \\n            //enter value in starting col\\n            for(int i=endrow;i>=strow&&a<=cnt;i--){\\n                ans[i][stcol]=a;\\n                a++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Upvote ++ (if it helps)***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,1));\\n        //index intialisation\\n        int strow=0, stcol=0;\\n        int endrow=n-1,endcol=n-1;\\n        //counters\\n        int cnt=n*n;\\n        int a=1;\\n        \\n        while(a<=cnt){\\n            \\n            //enter value in starting row\\n            for(int i=stcol;i<=endcol&&a<=cnt;i++){\\n                ans[strow][i]=a;\\n                a++;\\n            }\\n            strow++;\\n            \\n            //enter value in ending col\\n            for(int i=strow;i<=endrow&&a<=cnt;i++){\\n                ans[i][endcol]=a;\\n                a++;\\n            }\\n            endcol--;\\n            \\n            //enter value in ending row\\n            for(int i=endcol;i>=stcol&&a<=cnt;i--){\\n                ans[endrow][i]=a;\\n                a++;\\n            }\\n            endrow--;\\n            \\n            //enter value in starting col\\n            for(int i=endrow;i>=strow&&a<=cnt;i--){\\n                ans[i][stcol]=a;\\n                a++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999515,
                "title": "python-simple-and-easy-solution",
                "content": "The approach is inspired by [ \"Stefan Pochmann\"](https://leetcode.com/StefanPochmann/)\\n\\nfirst we will push an element in the array\\nthen, rotate the array.\\n\\n(We will start from the 9 upto 1)\\ne.g. for n = 3\\n\\n|9|\\nrotate and push new element\\n|8|\\n|9|\\n\\nrotate and push new elements\\n|6  7|\\n|9  8|\\n\\nrotate and push new elements\\n|4  5|\\n|9  6|\\n|8  7|\\n\\nrotate and push new elements\\n\\n|1  2  3|\\n|8  9  4|\\n|7  6  5|\\n\\n\\n\\n\\n```\\ndef generateMatrix(n):\\n#n = 3 for example\\n    result = []\\n    current = n*n -1  # =  8, for n = 3  \\n    #current will hold the value for inserting\\n    result.append([current + 1]) # first case, Handling first element explicitly result = [[9]]\\n    while current > 1:\\n        result = list(zip(*result[::-1])) # will rotate the array\\n        temp = len(result[0])\\n        # temp will hold the length of the first element of the result i.e. len([9]) i.e. 1\\n        # from temp we would know how many elements we have to push\\n        \\n        result.insert(0,list(range(current-temp+1,current+1)))\\n        #inserting the values on the top of the array\\n        \\n        current = current -temp\\n    return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef generateMatrix(n):\\n#n = 3 for example\\n    result = []\\n    current = n*n -1  # =  8, for n = 3  \\n    #current will hold the value for inserting\\n    result.append([current + 1]) # first case, Handling first element explicitly result = [[9]]\\n    while current > 1:\\n        result = list(zip(*result[::-1])) # will rotate the array\\n        temp = len(result[0])\\n        # temp will hold the length of the first element of the result i.e. len([9]) i.e. 1\\n        # from temp we would know how many elements we have to push\\n        \\n        result.insert(0,list(range(current-temp+1,current+1)))\\n        #inserting the values on the top of the array\\n        \\n        current = current -temp\\n    return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 22337,
                "title": "simplest-c-solution-easy-and-clear-have-a-look",
                "content": "comments will be highly appreciated . \\n\\n    vector<vector<int>> generateMatrix(int n) {\\n            // 2d vector initialization  vector<vector<int>> myvec(rowsize,vector<int>(colsize,0));\\n            vector<vector<int>> res(n,vector<int>(n,0));\\n            if(!n) return res;\\n            \\n            int l=0,r=n-1,t=0,b=n-1,limit=n*n+1;  // l=left column , r=right column , t=top row, b=bottom row \\n            int count=1;\\n            \\n            while(count<limit){         // loop until count == n*n \\n                for(int i=l;i<=r;i++) res[t][i]=count++; // process top row\\n                t++;\\n                for(int i=t;i<=b;i++) res[i][r]=count++; // process right column\\n                r--;\\n                if(count==limit) break;         // termination condition to avoid overwritting          \\n                for(int i=r; i>=l;i--) res[b][i]=count++; // process bottom row\\n                b--;\\n                for(int i=b;i>=t;i--) res[i][l]=count++;  //process left column\\n                l++;\\n            }\\n            \\n           return res;\\n        }",
                "solutionTags": [],
                "code": "comments will be highly appreciated . \\n\\n    vector<vector<int>> generateMatrix(int n) {\\n            // 2d vector initialization  vector<vector<int>> myvec(rowsize,vector<int>(colsize,0));\\n            vector<vector<int>> res(n,vector<int>(n,0));\\n            if(!n) return res;\\n            \\n            int l=0,r=n-1,t=0,b=n-1,limit=n*n+1;  // l=left column , r=right column , t=top row, b=bottom row \\n            int count=1;\\n            \\n            while(count<limit){         // loop until count == n*n \\n                for(int i=l;i<=r;i++) res[t][i]=count++; // process top row\\n                t++;\\n                for(int i=t;i<=b;i++) res[i][r]=count++; // process right column\\n                r--;\\n                if(count==limit) break;         // termination condition to avoid overwritting          \\n                for(int i=r; i>=l;i--) res[b][i]=count++; // process bottom row\\n                b--;\\n                for(int i=b;i>=t;i--) res[i][l]=count++;  //process left column\\n                l++;\\n            }\\n            \\n           return res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3510009,
                "title": "c-spiral-arrangement-of-the-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int i, j, o, k, num;\\n        vector<vector<int>> vec(n, vector<int>(n));\\n        for (i = j = o = 0 , num = 1; num <= (n * n) && i < n - o; o++, i++, j++) {\\n            cout << vec[i][j] << endl;\\n            while (j < n - o) {\\n                if (num > n*n) break;\\n                vec[i][j++] = num++;\\n            }\\n            j--;\\n            for (k = i + 1; k < n - o; k++) {\\n                if (num > n*n) break;\\n                vec[k][j] = num++;\\n            }\\n            k--;\\n            while (j > o) {\\n                if (num > n*n) break;\\n                vec[k][--j] = num++;\\n            }\\n            while (k > i + 1) {\\n                if (num > n*n) break;\\n                vec[--k][o] = num++;\\n            }\\n            \\n        }\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int i, j, o, k, num;\\n        vector<vector<int>> vec(n, vector<int>(n));\\n        for (i = j = o = 0 , num = 1; num <= (n * n) && i < n - o; o++, i++, j++) {\\n            cout << vec[i][j] << endl;\\n            while (j < n - o) {\\n                if (num > n*n) break;\\n                vec[i][j++] = num++;\\n            }\\n            j--;\\n            for (k = i + 1; k < n - o; k++) {\\n                if (num > n*n) break;\\n                vec[k][j] = num++;\\n            }\\n            k--;\\n            while (j > o) {\\n                if (num > n*n) break;\\n                vec[k][--j] = num++;\\n            }\\n            while (k > i + 1) {\\n                if (num > n*n) break;\\n                vec[--k][o] = num++;\\n            }\\n            \\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3508950,
                "title": "best-and-easy-approach-for-solving-competitive-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsoc=starting of column\\nsor=starting of row\\neor=end of column\\neoc=end of coloumn\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>finaldata(n,vector<int>(n,0));\\n        int soc=0,sor=0,eor=n-1,eoc=n-1,count=1;\\n        while(soc<=eoc && sor<=eor)\\n        {\\n            for(int x=soc;x<=eoc;x++)\\n            {\\n                finaldata[sor][x]=count;\\n                count++;\\n            }\\n            sor++;\\n            for(int x=sor;x<=eor;x++)\\n            {\\n                finaldata[x][eoc]=count;\\n                count++;\\n            }\\n            eoc--;\\n            for(int x=eoc;x>=soc;x--)\\n            {\\n                finaldata[eor][x]=count;\\n                count++;\\n            }\\n            eor--;\\n            for(int x=eor;x>=sor;x--)\\n            {\\n                finaldata[x][soc]=count;\\n                count++;\\n            }\\n            soc++;\\n        }\\n        return finaldata;\\n    }\\n};\\nIF YOU LOVE YOUR MOTHER UPVOTE!!!\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>finaldata(n,vector<int>(n,0));\\n        int soc=0,sor=0,eor=n-1,eoc=n-1,count=1;\\n        while(soc<=eoc && sor<=eor)\\n        {\\n            for(int x=soc;x<=eoc;x++)\\n            {\\n                finaldata[sor][x]=count;\\n                count++;\\n            }\\n            sor++;\\n            for(int x=sor;x<=eor;x++)\\n            {\\n                finaldata[x][eoc]=count;\\n                count++;\\n            }\\n            eoc--;\\n            for(int x=eoc;x>=soc;x--)\\n            {\\n                finaldata[eor][x]=count;\\n                count++;\\n            }\\n            eor--;\\n            for(int x=eor;x>=sor;x--)\\n            {\\n                finaldata[x][soc]=count;\\n                count++;\\n            }\\n            soc++;\\n        }\\n        return finaldata;\\n    }\\n};\\nIF YOU LOVE YOUR MOTHER UPVOTE!!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507369,
                "title": "java-simulation-beats-100-15-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int[][] generateMatrix(int n) {\\n    int x = 0, y = -1, cnt = 1;\\n    var xMoves = new int[] {n};\\n    var yMoves = new int[] {n+1};\\n    var mat = new int[n][n];\\n\\n    for (var d = 0; cnt <= n*n; d = (d+1) % 4) {\\n      var moves = d % 2 == 0 ? yMoves : xMoves;\\n      moves[0]--;\\n\\n      for (var i = 0; i < moves[0]; i++) {\\n        switch(d) {\\n          case 0 : y++; break;\\n          case 1 : x++; break;\\n          case 2 : y--; break;\\n          case 3 : x--; break;\\n        }\\n        mat[x][y] = cnt++;\\n      }\\n    }\\n    return mat;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n  public int[][] generateMatrix(int n) {\\n    int x = 0, y = -1, cnt = 1;\\n    var xMoves = new int[] {n};\\n    var yMoves = new int[] {n+1};\\n    var mat = new int[n][n];\\n\\n    for (var d = 0; cnt <= n*n; d = (d+1) % 4) {\\n      var moves = d % 2 == 0 ? yMoves : xMoves;\\n      moves[0]--;\\n\\n      for (var i = 0; i < moves[0]; i++) {\\n        switch(d) {\\n          case 0 : y++; break;\\n          case 1 : x++; break;\\n          case 2 : y--; break;\\n          case 3 : x--; break;\\n        }\\n        mat[x][y] = cnt++;\\n      }\\n    }\\n    return mat;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507016,
                "title": "easy-java-code-beats-100",
                "content": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] ans = new int[n][n];\\n        //right -> bottom -> left -> top\\n        int top = 0, left = 0;\\n        int bottom = n-1, right = n-1;\\n        int k = 1;\\n        while(top<=bottom && left<=right){\\n            //right\\n            for(int i=left;i<=right;i++){\\n                ans[top][i] = k++ ;\\n            }\\n            top++;\\n            //bottom\\n            for(int i=top;i<=bottom;i++){\\n                ans[i][right] = k++;\\n            }\\n            right--;\\n            if(top<=bottom){\\n                //left\\n                for(int i=right;i>=left;i--){\\n                    ans[bottom][i] = k++;\\n                  }\\n                 bottom--;\\n            }\\n            if(left<=right){\\n                //top\\n                for(int i=bottom;i>=top;i--){\\n                    ans[i][left] = k++;\\n                }  \\n                left++;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] ans = new int[n][n];\\n        //right -> bottom -> left -> top\\n        int top = 0, left = 0;\\n        int bottom = n-1, right = n-1;\\n        int k = 1;\\n        while(top<=bottom && left<=right){\\n            //right\\n            for(int i=left;i<=right;i++){\\n                ans[top][i] = k++ ;\\n            }\\n            top++;\\n            //bottom\\n            for(int i=top;i<=bottom;i++){\\n                ans[i][right] = k++;\\n            }\\n            right--;\\n            if(top<=bottom){\\n                //left\\n                for(int i=right;i>=left;i--){\\n                    ans[bottom][i] = k++;\\n                  }\\n                 bottom--;\\n            }\\n            if(left<=right){\\n                //top\\n                for(int i=bottom;i>=top;i--){\\n                    ans[i][left] = k++;\\n                }  \\n                left++;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506521,
                "title": "simple-spiral-traversing-c-98-efficient",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter initializing a new 2-d Array, simply traverse the array from the outer spiral towards inner spiral and place the incrementing numbers\\n\\n![Screenshot 2023-05-10 062834.png](https://assets.leetcode.com/users/images/0f78400f-bde1-46d9-912d-955e0b0787a5_1683680327.0288699.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2) - as we need to place (n^2) items in the array of size (n*n), given n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) - as we do not use any extra memory other than the resulting 2-d array\\n\\n## Please upvote if you like the simplicity of the approach\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] GenerateMatrix(int n) {\\n        int[][] result = Initialize(n);\\n        int num = 1;\\n        for (int i = 0, j = n - 1; i <= j; i++, j--)\\n        {\\n            for (int x = i; x <= j; x++)\\n            {\\n                result[i][x] = num++;\\n            }\\n            \\n            for (int x = i + 1; x <= j; x++)\\n            {\\n                result[x][j] = num++;\\n            }\\n            \\n            for (int x = j - 1; x >= i; x--)\\n            {\\n                result[j][x] = num++;\\n            }\\n            \\n            for (int x = j - 1; x > i; x--)\\n            {\\n                result[x][i] = num++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int[][] Initialize(int n)\\n    {\\n        int[][] result = new int[n][];\\n        for (int i = 0; i < n; i++)\\n        {\\n            result[i] = new int[n];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n\\n## Please upvote if you like the simplicity of the approach",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] GenerateMatrix(int n) {\\n        int[][] result = Initialize(n);\\n        int num = 1;\\n        for (int i = 0, j = n - 1; i <= j; i++, j--)\\n        {\\n            for (int x = i; x <= j; x++)\\n            {\\n                result[i][x] = num++;\\n            }\\n            \\n            for (int x = i + 1; x <= j; x++)\\n            {\\n                result[x][j] = num++;\\n            }\\n            \\n            for (int x = j - 1; x >= i; x--)\\n            {\\n                result[j][x] = num++;\\n            }\\n            \\n            for (int x = j - 1; x > i; x--)\\n            {\\n                result[x][i] = num++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int[][] Initialize(int n)\\n    {\\n        int[][] result = new int[n][];\\n        for (int i = 0; i < n; i++)\\n        {\\n            result[i] = new int[n];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941775,
                "title": "javascript-easy-to-understand-intuition-explained",
                "content": "**Intuition** -> This problem is similar to [Spiral matrix I](https://leetcode.com/problems/spiral-matrix/) in which we take 4 pointers and move them as per the condition, in this problem the pointer part in same only thing that has been changed is how many times the outer loop will run and how efficiently we can manage , below is the code hope it helps.\\n```\\nvar generateMatrix = function(n) {\\n    let c1=0;\\n    let c2=n-1;\\n    let r1=0;\\n    let r2=n-1;\\n    \\n    let arr=Array.from(Array(n),()=>Array(n));\\n    let i=1;\\n    while(i<=n*n){\\n        \\n        for(let c=c1;c<=c2;c++){\\n            arr[r1][c]=i;\\n            i++;\\n        }\\n        r1++;\\n        for(let r=r1;r<=r2;r++){\\n            arr[r][c2]=i;\\n            i++;\\n        }\\n        c2--;\\n        for(let c=c2;c>=c1;c--){\\n            arr[r2][c]=i;\\n            i++;\\n        }\\n        r2--;\\n        for(let r=r2;r>=r1;r--){\\n            arr[r][c1]=i;\\n            i++;\\n        }\\n        c1++;        \\n    }\\n    return arr;\\n};\\n```\\n\\n***Please upvote if you like the solution \\uD83D\\uDE80***",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar generateMatrix = function(n) {\\n    let c1=0;\\n    let c2=n-1;\\n    let r1=0;\\n    let r2=n-1;\\n    \\n    let arr=Array.from(Array(n),()=>Array(n));\\n    let i=1;\\n    while(i<=n*n){\\n        \\n        for(let c=c1;c<=c2;c++){\\n            arr[r1][c]=i;\\n            i++;\\n        }\\n        r1++;\\n        for(let r=r1;r<=r2;r++){\\n            arr[r][c2]=i;\\n            i++;\\n        }\\n        c2--;\\n        for(let c=c2;c>=c1;c--){\\n            arr[r2][c]=i;\\n            i++;\\n        }\\n        r2--;\\n        for(let r=r2;r>=r1;r--){\\n            arr[r][c1]=i;\\n            i++;\\n        }\\n        c1++;        \\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1941159,
                "title": "java-simple-reuse-lc-54",
                "content": "**Idea:** \\n* This question is near identical to [LC 54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/discuss/3502622/Java-or-Simple-or-Explained) and the solution can be reused. \\n* Fill the matrix in this order: First Row \\u279D Last Column \\u279D Last Row \\u279D First Column\\n* Repeat till a cross-over happends between rows or columns\\n>**T/S:** O(n\\xB2)/O(1)\\n```\\npublic int[][] generateMatrix(int n) {\\n\\tvar matrix = new int[n][n];\\n\\tvar firstRow = 0;\\n\\tvar firstCol = 0;\\n\\tvar lastRow = n - 1;\\n\\tvar lastCol = n - 1;\\n\\tvar x = 1;\\n\\n\\twhile (firstRow <= lastRow && firstCol <= lastCol) {\\n\\t\\t// first row\\n\\t\\tfor (var j = firstCol; j <= lastCol; j++)\\n\\t\\t\\tmatrix[firstRow][j] = x++;\\n\\t\\tfirstRow++;\\n\\n\\t\\t// last col\\n\\t\\tfor (var i = firstRow; i <= lastRow; i++)\\n\\t\\t\\tmatrix[i][lastCol] = x++;\\n\\t\\tlastCol--;\\n\\n\\t\\tif (firstRow > lastRow || firstCol > lastCol)\\n\\t\\t\\tbreak;\\n\\n\\t\\t// last row\\n\\t\\tfor (var j = lastCol; j >= firstCol; j--)\\n\\t\\t\\tmatrix[lastRow][j] = x++;\\n\\t\\tlastRow--;\\n\\n\\t\\t// first col\\n\\t\\tfor (var i = lastRow; i >= firstRow; i--)\\n\\t\\t\\tmatrix[i][firstCol] = x++;\\n\\t\\tfirstCol++;\\n\\t}\\n\\n\\treturn matrix;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] generateMatrix(int n) {\\n\\tvar matrix = new int[n][n];\\n\\tvar firstRow = 0;\\n\\tvar firstCol = 0;\\n\\tvar lastRow = n - 1;\\n\\tvar lastCol = n - 1;\\n\\tvar x = 1;\\n\\n\\twhile (firstRow <= lastRow && firstCol <= lastCol) {\\n\\t\\t// first row\\n\\t\\tfor (var j = firstCol; j <= lastCol; j++)\\n\\t\\t\\tmatrix[firstRow][j] = x++;\\n\\t\\tfirstRow++;\\n\\n\\t\\t// last col\\n\\t\\tfor (var i = firstRow; i <= lastRow; i++)\\n\\t\\t\\tmatrix[i][lastCol] = x++;\\n\\t\\tlastCol--;\\n\\n\\t\\tif (firstRow > lastRow || firstCol > lastCol)\\n\\t\\t\\tbreak;\\n\\n\\t\\t// last row\\n\\t\\tfor (var j = lastCol; j >= firstCol; j--)\\n\\t\\t\\tmatrix[lastRow][j] = x++;\\n\\t\\tlastRow--;\\n\\n\\t\\t// first col\\n\\t\\tfor (var i = lastRow; i >= firstRow; i--)\\n\\t\\t\\tmatrix[i][firstCol] = x++;\\n\\t\\tfirstCol++;\\n\\t}\\n\\n\\treturn matrix;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1941009,
                "title": "golang-simple-solution-with-rotation",
                "content": "We basically need to walk through the matrix, changing direction if we either a) got out of bounds, or b) got previously filled cell.\\n\\n```go\\nfunc generateMatrix(n int) [][]int {\\n    res := make([][]int, n)\\n    for i := 0; i < n; i++ { res[i] = make([]int, n) }\\n    \\n    dirs := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\\n    \\n    i, j, d := 0, 0, 0 \\n    for k := 1; k <= n*n; k++ {\\n        res[i][j] = k\\n        \\n        di, dj := dirs[d%4][0], dirs[d%4][1]\\n        if i+di < 0 || i+di >= n || j+dj < 0 || j+dj >= n || res[i+di][j+dj] != 0 {\\n            d++\\n            di, dj = dirs[d%4][0], dirs[d%4][1]\\n        }\\n        \\n        i, j = i+di, j+dj\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc generateMatrix(n int) [][]int {\\n    res := make([][]int, n)\\n    for i := 0; i < n; i++ { res[i] = make([]int, n) }\\n    \\n    dirs := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\\n    \\n    i, j, d := 0, 0, 0 \\n    for k := 1; k <= n*n; k++ {\\n        res[i][j] = k\\n        \\n        di, dj := dirs[d%4][0], dirs[d%4][1]\\n        if i+di < 0 || i+di >= n || j+dj < 0 || j+dj >= n || res[i+di][j+dj] != 0 {\\n            d++\\n            di, dj = dirs[d%4][0], dirs[d%4][1]\\n        }\\n        \\n        i, j = i+di, j+dj\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 963937,
                "title": "spiral-matrix-ii-python-o-n2-simple-offset",
                "content": "The following solution keeps track of an x-y position (location in the resulting array) and an offset (used to move spiral toward the center).\\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        spiral = [[0]*n for i in range(n)]\\n        x, y, off = 0, 0, 0\\n        \\n        for i in range(1, n*n +1):\\n            spiral[y][x] = i\\n      \\n            if x == (n-1-off) and y < (n-1-off): y += 1 # Right Edge\\n            elif y == (n-1-off) and x > off: x -=1 # Bottom Edge\\n            elif x == off and y > off: # Left Edge\\n                y -= 1\\n                if y == off+1: off += 1\\n            else: x += 1 # Top Edge\\n\\n        return spiral\\n```\\n\\nThe above solution runs in *`O(n2)`* time. \\nThe above solution takes *`O(n2)`* space.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        spiral = [[0]*n for i in range(n)]\\n        x, y, off = 0, 0, 0\\n        \\n        for i in range(1, n*n +1):\\n            spiral[y][x] = i\\n      \\n            if x == (n-1-off) and y < (n-1-off): y += 1 # Right Edge\\n            elif y == (n-1-off) and x > off: x -=1 # Bottom Edge\\n            elif x == off and y > off: # Left Edge\\n                y -= 1\\n                if y == off+1: off += 1\\n            else: x += 1 # Top Edge\\n\\n        return spiral\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963514,
                "title": "c-simulation-self-explained-without-comment",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n, vector<int>(n));\\n        int begX = 0, endX = n - 1;\\n        int begY = 0, endY = n - 1;\\n        int counter = 0;\\n        while(true){\\n            for(int j = begX; j <= endX; j++) ans[begY][j] = ++counter;\\n            if(++begY>endY) break;\\n            for(int j = begY; j <= endY; j++) ans[j][endX] = ++counter;\\n            if(begX>--endX) break;\\n            for(int j = endX; j >= begX; j--) ans[endY][j] = ++counter;\\n            if(begY>--endY) break;\\n            for(int j = endY; j >= begY; j--) ans[j][begX] = ++counter;\\n            if(++begX>endY) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n, vector<int>(n));\\n        int begX = 0, endX = n - 1;\\n        int begY = 0, endY = n - 1;\\n        int counter = 0;\\n        while(true){\\n            for(int j = begX; j <= endX; j++) ans[begY][j] = ++counter;\\n            if(++begY>endY) break;\\n            for(int j = begY; j <= endY; j++) ans[j][endX] = ++counter;\\n            if(begX>--endX) break;\\n            for(int j = endX; j >= begX; j--) ans[endY][j] = ++counter;\\n            if(begY>--endY) break;\\n            for(int j = endY; j >= begY; j--) ans[j][begX] = ++counter;\\n            if(++begX>endY) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552710,
                "title": "c-minimalizm",
                "content": "Track the direction (left, down, right, and up). When your next position is out of bouds, or there is already a number, we change the direction.\\n\\n```cpp\\nint ds[4][2] = {{0,1}, {1,0}, {0,-1}, {-1,0}};\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> res(n, vector<int>(n));\\n    for (auto i = 0, j = 0, k = 1, d = 0; k <= n * n; i += ds[d][0], j += ds[d][1]) {\\n        res[i][j] = k++;\\n        auto ni = i + ds[d][0], nj = j + ds[d][1];\\n        if (ni < 0 || ni == n || nj < 0 || nj == n || res[ni][nj] != 0)\\n            d = (++d) % 4;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint ds[4][2] = {{0,1}, {1,0}, {0,-1}, {-1,0}};\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> res(n, vector<int>(n));\\n    for (auto i = 0, j = 0, k = 1, d = 0; k <= n * n; i += ds[d][0], j += ds[d][1]) {\\n        res[i][j] = k++;\\n        auto ni = i + ds[d][0], nj = j + ds[d][1];\\n        if (ni < 0 || ni == n || nj < 0 || nj == n || res[ni][nj] != 0)\\n            d = (++d) % 4;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 408699,
                "title": "clean-javascript-solution",
                "content": "Reference from a similar question https://leetcode.com/problems/spiral-matrix/discuss/20573/A-concise-C++-implementation-based-on-Directions\\n\\n```\\n// When traversing the matrix in the spiral order, at any time we follow one out of the following four directions:\\n// RIGHT DOWN LEFT UP. Suppose we are working on a 5 x 3 matrix as such:\\n// 0  1  2  3  4  5\\n//    6  7  8  9 10\\n//   11 12 13 14 15\\n//\\n// Imagine a cursor starts off at (0, -1), i.e. the position at \\'0\\', then we can achieve the spiral order by doing\\n// the following:\\n// 1. Go right 5 times\\n// 2. Go down 2 times\\n// 3. Go left 4 times\\n// 4. Go up 1 times.\\n// 5. Go right 3 times\\n// 6. Go down 0 times -> quit\\n\\nconst generateMatrix = (n) => {\\n  const matrix = [...Array(n)].map(() => Array(n).fill(null));\\n  const dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]; // right, down, left, up\\n  const steps = [n, n - 1];\\n\\n  let num = 1;\\n  let dir = 0;\\n  let x = 0;\\n  let y = -1;\\n\\n  while (steps[dir % 2] > 0) {\\n    for (let i = 0; i < steps[dir % 2]; i++) {\\n      x += dirs[dir][0];\\n      y += dirs[dir][1];\\n      matrix[x][y] = num++;\\n    }\\n\\n    steps[dir % 2]--;\\n    dir = (dir + 1) % 4;\\n  }\\n  return matrix;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// When traversing the matrix in the spiral order, at any time we follow one out of the following four directions:\\n// RIGHT DOWN LEFT UP. Suppose we are working on a 5 x 3 matrix as such:\\n// 0  1  2  3  4  5\\n//    6  7  8  9 10\\n//   11 12 13 14 15\\n//\\n// Imagine a cursor starts off at (0, -1), i.e. the position at \\'0\\', then we can achieve the spiral order by doing\\n// the following:\\n// 1. Go right 5 times\\n// 2. Go down 2 times\\n// 3. Go left 4 times\\n// 4. Go up 1 times.\\n// 5. Go right 3 times\\n// 6. Go down 0 times -> quit\\n\\nconst generateMatrix = (n) => {\\n  const matrix = [...Array(n)].map(() => Array(n).fill(null));\\n  const dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]; // right, down, left, up\\n  const steps = [n, n - 1];\\n\\n  let num = 1;\\n  let dir = 0;\\n  let x = 0;\\n  let y = -1;\\n\\n  while (steps[dir % 2] > 0) {\\n    for (let i = 0; i < steps[dir % 2]; i++) {\\n      x += dirs[dir][0];\\n      y += dirs[dir][1];\\n      matrix[x][y] = num++;\\n    }\\n\\n    steps[dir % 2]--;\\n    dir = (dir + 1) % 4;\\n  }\\n  return matrix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 123723,
                "title": "beat-100-java-code",
                "content": "Hi all, this code divides the whole construction into n/2 loops. In each loop, it finishes one spiral. If n is an odd number, add an extra number in the center before return.\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n==1)\\n            return new int [][] {{1}};\\n        int[][] result=new int[n][n];\\n        int col=0, row=0, min=0, max=n-1, i=1, loop=0;\\n        while(loop<n/2) {\\n            result[row][col]=i++;\\n            if (row==min && col!=max) \\n                col++;\\n            else if(col==max && row!=max)\\n                row++;\\n            else if(row==max && col!=min) \\n                col--;\\n            else if(col==min && row!=min+1)\\n                row--;\\n            else {\\n                min++;\\n                max--;\\n                col=min;\\n                row=min;\\n                loop++;\\n            }\\n        }\\n        if (n%2==1) \\n            result[n/2][n/2]=i;\\n        return result;    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n==1)\\n            return new int [][] {{1}};\\n        int[][] result=new int[n][n];\\n        int col=0, row=0, min=0, max=n-1, i=1, loop=0;\\n        while(loop<n/2) {\\n            result[row][col]=i++;\\n            if (row==min && col!=max) \\n                col++;\\n            else if(col==max && row!=max)\\n                row++;\\n            else if(row==max && col!=min) \\n                col--;\\n            else if(col==min && row!=min+1)\\n                row--;\\n            else {\\n                min++;\\n                max--;\\n                col=min;\\n                row=min;\\n                loop++;\\n            }\\n        }\\n        if (n%2==1) \\n            result[n/2][n/2]=i;\\n        return result;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22488,
                "title": "a-better-solution-than-switching-directions",
                "content": "Rotate the Matrix is more easier :)\\n\\n\\tpublic class Solution {\\n\\t\\tint[][] step = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\t\\tint cnt = 1;\\n\\t\\tvoid vortex(int[][] res, int len, int wid, int x, int y, int sg){\\n\\t\\t\\tif(len == 0) return;\\n\\t\\t\\tfor(int i = 0; i < len; ++i){\\n\\t\\t\\t\\tx += step[sg][0];\\n\\t\\t\\t\\ty += step[sg][1];\\n\\t\\t\\t\\tres[x][y] = cnt++;\\n\\t\\t\\t}\\n\\t\\t\\tsg = (sg+1)%4;\\n\\t\\t\\tvortex(res,--wid,len, x, y, sg);\\n\\t\\t}\\n\\t    public int[][] generateMatrix(int n) {\\n\\t        int[][] res = new int[n][n];\\n\\t        vortex(res,n,n,0,-1,0);\\n\\t        return res;\\n\\t    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tint[][] step = {{0,1}",
                "codeTag": "Java"
            },
            {
                "id": 4084193,
                "title": "best-o-n-2-solution",
                "content": "# Approach\\nTraversal\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat (n, vector<int>(n));\\n        int num = 1;\\n        int r1 = 0, r2 = n - 1, c1 = n - 1, c2 = 0;\\n        while (num <= n * n) {\\n            for (int i = r1; i <= r2; i++) {\\n                mat[r1][i] = num;\\n                num++;\\n            }\\n            r1++;\\n            for (int i = c2 + 1; i <= c1; i++) {\\n                mat[i][c1] = num;\\n                num++;\\n            }\\n            c1--;\\n            for (int i = r2 - 1; i >= r1 - 1; i--) {\\n                mat[r2][i] = num;\\n                num++;\\n            }\\n            r2--;\\n            for (int i = c1; i >= c2 + 1; i--) {\\n                mat[i][c2] = num;\\n                num++;\\n            }\\n            c2++;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat (n, vector<int>(n));\\n        int num = 1;\\n        int r1 = 0, r2 = n - 1, c1 = n - 1, c2 = 0;\\n        while (num <= n * n) {\\n            for (int i = r1; i <= r2; i++) {\\n                mat[r1][i] = num;\\n                num++;\\n            }\\n            r1++;\\n            for (int i = c2 + 1; i <= c1; i++) {\\n                mat[i][c1] = num;\\n                num++;\\n            }\\n            c1--;\\n            for (int i = r2 - 1; i >= r1 - 1; i--) {\\n                mat[r2][i] = num;\\n                num++;\\n            }\\n            r2--;\\n            for (int i = c1; i >= c2 + 1; i--) {\\n                mat[i][c2] = num;\\n                num++;\\n            }\\n            c2++;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652362,
                "title": "beats-100-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntraverse through matrix hit right when you hit a visited node or go out of limits. break when count goes to n^2 +1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmaintain n*n matrix. change direction when you hit a visited node or go out of limits. increment count after every insertion \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N2)\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> visited(n, vector<int>(n, 0)); int c = 1; \\n        vector<vector<int>> res(n, vector<int>(n, 0));  int x = 0; int y = 0;   char d = \\'r\\'; \\n        while( c != n*n+1){\\n            if(d == \\'r\\'){\\n                res[x][y] = c;  visited[x][y] = 1; y++; c++; \\n                if(y>=n||visited[x][y] == 1) {y--; x++; d = \\'d\\'; continue;  }\\n            }\\n            else if(d == \\'d\\'){\\n                res[x][y] = c; visited[x][y] = 1; x++; c++; \\n                if(x>=n || visited[x][y] == 1) {x--; y--; d = \\'l\\'; continue; }\\n            }\\n            else if(d == \\'l\\'){\\n                res[x][y] = c; visited[x][y] = 1; y--; c++;\\n                if(y<0 || visited[x][y] == 1) { y++; x--; d = \\'u\\'; continue; }\\n            }\\n            else if(d == \\'u\\'){\\n                res[x][y] = c; visited[x][y] = 1; x--; c++;\\n                if(x<0 || visited[x][y] == 1) {x++; y++; d = \\'r\\'; continue; }\\n            }\\n        }\\n\\n        // cout << x << y << d ; \\n\\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> visited(n, vector<int>(n, 0)); int c = 1; \\n        vector<vector<int>> res(n, vector<int>(n, 0));  int x = 0; int y = 0;   char d = \\'r\\'; \\n        while( c != n*n+1){\\n            if(d == \\'r\\'){\\n                res[x][y] = c;  visited[x][y] = 1; y++; c++; \\n                if(y>=n||visited[x][y] == 1) {y--; x++; d = \\'d\\'; continue;  }\\n            }\\n            else if(d == \\'d\\'){\\n                res[x][y] = c; visited[x][y] = 1; x++; c++; \\n                if(x>=n || visited[x][y] == 1) {x--; y--; d = \\'l\\'; continue; }\\n            }\\n            else if(d == \\'l\\'){\\n                res[x][y] = c; visited[x][y] = 1; y--; c++;\\n                if(y<0 || visited[x][y] == 1) { y++; x--; d = \\'u\\'; continue; }\\n            }\\n            else if(d == \\'u\\'){\\n                res[x][y] = c; visited[x][y] = 1; x--; c++;\\n                if(x<0 || visited[x][y] == 1) {x++; y++; d = \\'r\\'; continue; }\\n            }\\n        }\\n\\n        // cout << x << y << d ; \\n\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3508409,
                "title": "c-beats-100-easy-like-if-it-helps-you-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMatrix Simulation type question.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n#Define a N*N vector initiated with value 0. And then move forward in the matrix in the directions of top->bottom, right->left, left->right, bottom->top. \\n\\n#The loop runs till we reach number limit of n^2. \\n\\n#Looking for openions for optimizing my solution.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n         vector<vector<int>> grid(n, vector<int> (n,0));\\n         int dir=1;\\n         int num=1;\\n         int top=0,bottom=n-1,right=n-1,left=0;\\n         while(num<=pow(n,2))\\n         {\\n             if(dir==1)\\n             {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    grid[top][i]=num;\\n                    num++;\\n                }\\n                top++;\\n                dir=2;\\n             }\\n\\n             else if(dir==2)\\n             {\\n                 for(int i=top;i<=bottom;i++)\\n                 {\\n                     grid[i][right]=num;\\n                     num++;\\n                 }\\n                 right--;\\n                 dir=3;\\n             }\\n             else if(dir==3)\\n             {\\n                 for(int i=right;i>=left;i--)\\n                 {\\n                    grid[bottom][i]=num;\\n                    num++;\\n                 }\\n                 bottom--;\\n                 dir=4;\\n             }\\n\\n             else if(dir==4)\\n             {\\n                 for(int i=bottom;i>=top;i--)\\n                 {\\n                     grid[i][left]=num;\\n                     num++;\\n                 }\\n                 left++;\\n                 dir=1;\\n             }\\n         }\\n          return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n         vector<vector<int>> grid(n, vector<int> (n,0));\\n         int dir=1;\\n         int num=1;\\n         int top=0,bottom=n-1,right=n-1,left=0;\\n         while(num<=pow(n,2))\\n         {\\n             if(dir==1)\\n             {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    grid[top][i]=num;\\n                    num++;\\n                }\\n                top++;\\n                dir=2;\\n             }\\n\\n             else if(dir==2)\\n             {\\n                 for(int i=top;i<=bottom;i++)\\n                 {\\n                     grid[i][right]=num;\\n                     num++;\\n                 }\\n                 right--;\\n                 dir=3;\\n             }\\n             else if(dir==3)\\n             {\\n                 for(int i=right;i>=left;i--)\\n                 {\\n                    grid[bottom][i]=num;\\n                    num++;\\n                 }\\n                 bottom--;\\n                 dir=4;\\n             }\\n\\n             else if(dir==4)\\n             {\\n                 for(int i=bottom;i>=top;i--)\\n                 {\\n                     grid[i][left]=num;\\n                     num++;\\n                 }\\n                 left++;\\n                 dir=1;\\n             }\\n         }\\n          return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507313,
                "title": "c-easy-to-understand-matrix",
                "content": "sr : starting of row\\ner : end of row\\nsc : starting of row\\nec : end of columns\\n\\n{first traverse first row increment starting row by one\\nsecond traversal for insert last columns decrement last columns by 1\\nthird time insert last row decrement last row by one\\nfourth time insert first row increment 1st column by row}\\nrepeat these all four steps untill sr <= er && sc <= ec.\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int sr = 0, sc = 0, er = n-1,ec = n-1,x=1,i;\\n        vector<vector<int>> v(n,vector<int>(n));\\n        while(sr<=er && sc <= ec){\\n            for(i = sc; i <= ec && sr<=er; i++){\\n                v[sr][i] = x++;\\n            }\\n            sr++;\\n            for(i = sr; i <= er &&  sc<=ec; i++){\\n                v[i][ec] = x++;\\n            }\\n            ec--;\\n            for(i = ec; i >= sc &&  sr<=er; i--){\\n                v[er][i] = x++;\\n            }\\n            er--;\\n            for(i = er; i >= sr && sc<=ec; i--){\\n                v[i][sc] = x++;\\n            }\\n            sc++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int sr = 0, sc = 0, er = n-1,ec = n-1,x=1,i;\\n        vector<vector<int>> v(n,vector<int>(n));\\n        while(sr<=er && sc <= ec){\\n            for(i = sc; i <= ec && sr<=er; i++){\\n                v[sr][i] = x++;\\n            }\\n            sr++;\\n            for(i = sr; i <= er &&  sc<=ec; i++){\\n                v[i][ec] = x++;\\n            }\\n            ec--;\\n            for(i = ec; i >= sc &&  sr<=er; i--){\\n                v[er][i] = x++;\\n            }\\n            er--;\\n            for(i = er; i >= sr && sc<=ec; i--){\\n                v[i][sc] = x++;\\n            }\\n            sc++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506683,
                "title": "c-best-solution-o-n-n-easy-to-understand",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we have total n*n element for making n*n matrix in spiral order.\\nSo we can follow this **4 step**\\n\\n***Step-1*** : printing the starting row\\n***Step-2*** : printing the ending column\\n***Step-3*** : printing the ending row\\n***Step-4*** : printing the starting column\\n\\n# Dry Run\\nlet n=3\\nSo we have total 3*3 = 9 elements\\ninitial our matrix is : \\n>0 0 0\\n0 0 0\\n0 0 0\\n\\n**step-1:** *starting row*\\n>1 2 3\\n0 0 0\\n0 0 0\\n\\n**step-2:** *ending column*\\n>1 2 3\\n0 0 4\\n0 0 5\\n\\n**step-3:** *ending row*\\n>1 2 3\\n0 0 4\\n7 6 5\\n\\n**step-4:** *starting column*\\n>1 2 3\\n8 0 4\\n7 6 5\\n\\n**HERE 4 STEP IS COMPLETED BUT THE MATRIX IS NOT FILLED BY N*N ELEMENTS SO WE HAVE TO REPET THIS 4 STAPES AGAIN WHILE THERE IS LESS THEN N*N ELEMENTS**\\n\\n**step-1:** *starting row*\\n>1 2 3\\n8 9 4\\n7 6 5\\nThis is our answer\\n\\n# Complexity\\n- Time complexity: $$O(n*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n, vector<int>(n));\\n        int srow = 0, erow = n-1, scol = 0, ecol = n-1, element = 1, total = n*n;\\n        while(element <= total)    {\\n            // step-1 : starting row\\n            for(int i=scol; i<=ecol && element<=total; i++)   {\\n                ans[srow][i] = element++;\\n            }\\n            srow++;\\n\\n            // step-2 : ending column\\n            for(int i=srow; i<=erow && element<=total; i++)   {\\n                ans[i][ecol] = element++;\\n            }\\n            ecol--;\\n\\n            // step-3 : ending row\\n            for(int i=ecol; i>=scol && element<=total; i--)   {\\n                ans[erow][i] = element++;\\n            }\\n            erow--;\\n\\n            // step-4 : starting column\\n            for(int i=erow; i>=srow && element<=total; i--)   {\\n                ans[i][scol] = element++;\\n            }\\n            scol++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Matrix",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n, vector<int>(n));\\n        int srow = 0, erow = n-1, scol = 0, ecol = n-1, element = 1, total = n*n;\\n        while(element <= total)    {\\n            // step-1 : starting row\\n            for(int i=scol; i<=ecol && element<=total; i++)   {\\n                ans[srow][i] = element++;\\n            }\\n            srow++;\\n\\n            // step-2 : ending column\\n            for(int i=srow; i<=erow && element<=total; i++)   {\\n                ans[i][ecol] = element++;\\n            }\\n            ecol--;\\n\\n            // step-3 : ending row\\n            for(int i=ecol; i>=scol && element<=total; i--)   {\\n                ans[erow][i] = element++;\\n            }\\n            erow--;\\n\\n            // step-4 : starting column\\n            for(int i=erow; i>=srow && element<=total; i--)   {\\n                ans[i][scol] = element++;\\n            }\\n            scol++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089593,
                "title": "python-beginner-friendly-similar-to-spiral-matrix-1",
                "content": "Please upvote if you like the post\\n\\n```\\n   class Solution:\\n       def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        matrix_size = n * n\\n        up = left = value = 0\\n        right = n - 1\\n        down = n - 1\\n        \\n        while value != matrix_size:\\n            \\n            for col in range(left, right + 1):\\n                value += 1\\n                matrix[up][col] = value\\n            \\n            for row in range(up + 1, down + 1):\\n                value += 1\\n                matrix[row][right] = value\\n                \\n            if up != down:\\n                for col in range(right - 1, left - 1, -1):\\n                    value += 1\\n                    matrix[down][col] = value\\n            \\n            if left != right:\\n                for row in range(down - 1, up, -1):\\n                    value += 1\\n                    matrix[row][left] = value\\n        \\n            left += 1\\n            right -= 1\\n            up += 1\\n            down -= 1\\n\\n        return matrix\\n             \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n   class Solution:\\n       def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        matrix_size = n * n\\n        up = left = value = 0\\n        right = n - 1\\n        down = n - 1\\n        \\n        while value != matrix_size:\\n            \\n            for col in range(left, right + 1):\\n                value += 1\\n                matrix[up][col] = value\\n            \\n            for row in range(up + 1, down + 1):\\n                value += 1\\n                matrix[row][right] = value\\n                \\n            if up != down:\\n                for col in range(right - 1, left - 1, -1):\\n                    value += 1\\n                    matrix[down][col] = value\\n            \\n            if left != right:\\n                for row in range(down - 1, up, -1):\\n                    value += 1\\n                    matrix[row][left] = value\\n        \\n            left += 1\\n            right -= 1\\n            up += 1\\n            down -= 1\\n\\n        return matrix\\n             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942288,
                "title": "python-optimized-spiral-traversal-in-a-few-lines-explained",
                "content": "We fill the matrix following a spiral pattern, changing direction when going outside of the matrix or when encountering a non-zero value.\\nUsing `next`on an `itertools.cycle` is far easier to read than using modulos IMO.\\n\\n```python\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        directions = cycle([(0, 1), (1, 0), (0, -1), (-1, 0)])\\n        row, col = 0, 0\\n        x, y = next(directions)\\n        for i in range(1, n ** 2 + 1):\\n            matrix[row][col] = i\\n            if not (0 <= row + x < n and 0 <= col + y < n and matrix[row + x][col + y] == 0):\\n                x, y = next(directions)\\n            row += x\\n            col += y  \\n        return matrix\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        directions = cycle([(0, 1), (1, 0), (0, -1), (-1, 0)])\\n        row, col = 0, 0\\n        x, y = next(directions)\\n        for i in range(1, n ** 2 + 1):\\n            matrix[row][col] = i\\n            if not (0 <= row + x < n and 0 <= col + y < n and matrix[row + x][col + y] == 0):\\n                x, y = next(directions)\\n            row += x\\n            col += y  \\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941795,
                "title": "c-100-simple-solution-o-n-2",
                "content": "```\\nint** generateMatrix(int n, int* returnSize, int** returnColumnSizes)\\n{\\n    *returnSize = n;\\n    *returnColumnSizes = malloc(sizeof(int) * n);\\n    int **res = malloc(sizeof(int*) * n);\\n    for (int i = 0; i < n; i++) {\\n        (*returnColumnSizes)[i] = n;\\n        res[i] = malloc(sizeof(int) * n);\\n    }\\n    \\n    int top = 0;\\n    int bot = n - 1;\\n    int left = 0;\\n    int right = n - 1;\\n    \\n    int j = 1;\\n    while (j <= n * n) {\\n        for (int i = left; i <= right; i++, j++)\\n            res[top][i] = j;\\n        top++;\\n\\n        for (int i = top; i <= bot; i++, j++)\\n            res[i][right] = j;\\n        right--;\\n\\n        for (int i = right; i >= left; i--, j++)\\n            res[bot][i] = j;\\n        bot--;\\n\\n        for (int i = bot; i >= top; i--, j++)\\n            res[i][left] = j;\\n        left++;\\n    }\\n\\n    return res;\\n}\\n```\\n\\n**If this was helpful, don\\'t hesitate to upvote! :)**\\nHave a nice day!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint** generateMatrix(int n, int* returnSize, int** returnColumnSizes)\\n{\\n    *returnSize = n;\\n    *returnColumnSizes = malloc(sizeof(int) * n);\\n    int **res = malloc(sizeof(int*) * n);\\n    for (int i = 0; i < n; i++) {\\n        (*returnColumnSizes)[i] = n;\\n        res[i] = malloc(sizeof(int) * n);\\n    }\\n    \\n    int top = 0;\\n    int bot = n - 1;\\n    int left = 0;\\n    int right = n - 1;\\n    \\n    int j = 1;\\n    while (j <= n * n) {\\n        for (int i = left; i <= right; i++, j++)\\n            res[top][i] = j;\\n        top++;\\n\\n        for (int i = top; i <= bot; i++, j++)\\n            res[i][right] = j;\\n        right--;\\n\\n        for (int i = right; i >= left; i--, j++)\\n            res[bot][i] = j;\\n        bot--;\\n\\n        for (int i = bot; i >= top; i--, j++)\\n            res[i][left] = j;\\n        left++;\\n    }\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1941360,
                "title": "easy-c-solution-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        // Defining the boundaries of the matrix.\\n        int top = 0, bottom = n-1, right = n-1, left = 0;\\n        // Defining the direction in which the array is to be traversed.\\n        int dir = 1, val = 1;\\n        vector<vector<int>> matirx (n, vector<int>(n, 0));\\n        while( top <= bottom && left <= right){\\n            // moving left->right\\n            if(dir == 1){\\n                for(int i=left; i <= right; i++){\\n                    matirx[top][i]=val;\\n                    val++;\\n                }\\n            }\\n            // Since we have traversed the whole first\\n            // row, move down to the next row.\\n            dir = 2;\\n            top++;\\n            // moving top->bottom\\n            if(dir == 2){\\n                for(int i=top; i <= bottom; i++){\\n                    matirx[i][right]=val;\\n                    val++;\\n                }\\n            }\\n            // Since we have traversed the whole last\\n            // column, move left to the previous column.\\n            dir = 3;\\n            right--;\\n            // moving right->left\\n            if(dir == 3){\\n                for(int i=right; i >= left; i--){\\n                    matirx[bottom][i] = val;\\n                    val++;\\n                }\\n            }\\n            // Since we have traversed the whole last\\n            // row, move up to the previous row.\\n            dir = 4;\\n            bottom--;\\n            // moving bottom->up\\n            if(dir == 4){\\n                for(int i=bottom; i>= top; i--){\\n                    matirx[i][left]=val;\\n                    val++;\\n                }\\n            }\\n            // Since we have traversed the whole first\\n            // col, move right to the next column.\\n            dir = 1;\\n            left ++;\\n            \\n        }\\n        \\n        return matirx;\\n        \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        // Defining the boundaries of the matrix.\\n        int top = 0, bottom = n-1, right = n-1, left = 0;\\n        // Defining the direction in which the array is to be traversed.\\n        int dir = 1, val = 1;\\n        vector<vector<int>> matirx (n, vector<int>(n, 0));\\n        while( top <= bottom && left <= right){\\n            // moving left->right\\n            if(dir == 1){\\n                for(int i=left; i <= right; i++){\\n                    matirx[top][i]=val;\\n                    val++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1941154,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N * N)***\\n* ***Space Complexity : O(1), because space taken for outputing the result doesn\\'t count as space complexity***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> mat(n, vector<int> (n, 0));\\n        \\n        int k = 1;\\n        \\n        int top = 0;\\n        \\n        int bottom = n - 1;\\n        \\n        int left = 0;\\n        \\n        int right = n - 1;\\n        \\n        while(left <= right && top <= bottom)\\n        {\\n            if(top <= bottom)\\n            {\\n                for(int i = left; i <= right; i++)\\n                {\\n                    mat[top][i] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                top++;\\n            }\\n            \\n            if(left <= right)\\n            {\\n                for(int i = top; i <= bottom; i++)\\n                {\\n                    mat[i][right] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                right--;\\n            }\\n            \\n            if(top <= bottom)\\n            {\\n                for(int i = right; i >= left; i--)\\n                {\\n                    mat[bottom][i] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                bottom--;\\n            }\\n            \\n            if(left <= right)\\n            {\\n                for(int i = bottom; i >= top; i--)\\n                {\\n                    mat[i][left] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                left++;\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> mat(n, vector<int> (n, 0));\\n        \\n        int k = 1;\\n        \\n        int top = 0;\\n        \\n        int bottom = n - 1;\\n        \\n        int left = 0;\\n        \\n        int right = n - 1;\\n        \\n        while(left <= right && top <= bottom)\\n        {\\n            if(top <= bottom)\\n            {\\n                for(int i = left; i <= right; i++)\\n                {\\n                    mat[top][i] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                top++;\\n            }\\n            \\n            if(left <= right)\\n            {\\n                for(int i = top; i <= bottom; i++)\\n                {\\n                    mat[i][right] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                right--;\\n            }\\n            \\n            if(top <= bottom)\\n            {\\n                for(int i = right; i >= left; i--)\\n                {\\n                    mat[bottom][i] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                bottom--;\\n            }\\n            \\n            if(left <= right)\\n            {\\n                for(int i = bottom; i >= top; i--)\\n                {\\n                    mat[i][left] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                left++;\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767351,
                "title": "python-solution",
                "content": "Need to be careful for the corner element traversal. \\n```\\nclass Solution(object):\\n    def generateMatrix(self, n):\\n        top, bottom, left, right = 0, n-1, 0, n-1\\n        num = 1 \\n        if not n:\\n            return \\n        matrix = [[0]*n for _ in xrange(n)]\\n        while left <= right and top <= bottom:\\n            for i in xrange(left, right+1):\\n                matrix[top][i] = num\\n                num += 1\\n            top += 1 \\n            \\n            for i in xrange(top, bottom+1):\\n                matrix[i][right] = num\\n                num += 1 \\n            right -= 1 \\n            \\n            for i in xrange(right, left-1, -1):\\n                matrix[bottom][i] = num\\n                num += 1\\n            bottom -= 1 \\n            \\n            for i in xrange(bottom, top-1, -1):\\n                matrix[i][left] = num\\n                num += 1 \\n            left += 1\\n            \\n        return matrix",
                "solutionTags": [
                    "Python"
                ],
                "code": "Need to be careful for the corner element traversal. \\n```\\nclass Solution(object):\\n    def generateMatrix(self, n):\\n        top, bottom, left, right = 0, n-1, 0, n-1\\n        num = 1 \\n        if not n:\\n            return \\n        matrix = [[0]*n for _ in xrange(n)]\\n        while left <= right and top <= bottom:\\n            for i in xrange(left, right+1):\\n                matrix[top][i] = num\\n                num += 1\\n            top += 1 \\n            \\n            for i in xrange(top, bottom+1):\\n                matrix[i][right] = num\\n                num += 1 \\n            right -= 1 \\n            \\n            for i in xrange(right, left-1, -1):\\n                matrix[bottom][i] = num\\n                num += 1\\n            bottom -= 1 \\n            \\n            for i in xrange(bottom, top-1, -1):\\n                matrix[i][left] = num\\n                num += 1 \\n            left += 1\\n            \\n        return matrix",
                "codeTag": "Java"
            },
            {
                "id": 1500943,
                "title": "c-100-each-and-every-steps-explained-easy-efficient",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int val=1,r=0,c=0,m=n,i;\\n       \\n \\n    /*  r - starting row index\\n        m - ending row index\\n        c - starting column index\\n        n - ending column index\\n        i - iterator\\n    */\\n \\n    while (r < m && c < n) {\\n        /* Assigning value to first row from\\n               the remaining rows */\\n        for (i = c; i < n; ++i) {\\n            a[r][i] = val++;\\n        }\\n        r++;\\n \\n        /* Assigning value to last column\\n         from the remaining columns */\\n        for (i = r; i < m; ++i) {\\n            a[i][n - 1] = val++;\\n        }\\n        n--;\\n \\n        /* Assigning value to last row from\\n                the remaining rows */\\n        if (r < m) {\\n            for (i = n - 1; i >= c; --i) {\\n                a[m - 1][i] = val++;\\n            }\\n            m--;\\n        }\\n \\n        /* Assigning value to first column from\\n                   the remaining columns */\\n        if (c < n) {\\n            for (i = m - 1; i >= r; --i) {\\n                a[i][c] = val++;\\n            }\\n            c++;\\n        }\\n    }\\n        return a;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int val=1,r=0,c=0,m=n,i;\\n       \\n \\n    /*  r - starting row index\\n        m - ending row index\\n        c - starting column index\\n        n - ending column index\\n        i - iterator\\n    */\\n \\n    while (r < m && c < n) {\\n        /* Assigning value to first row from\\n               the remaining rows */\\n        for (i = c; i < n; ++i) {\\n            a[r][i] = val++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 969392,
                "title": "faster-than-100-00-beginner-friendly-easy-understanding",
                "content": "```\\n//Runtime: 0 ms, faster than 100.00%\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int cnt=0;\\n        int rs=0,re=n-1;\\n        int cs=0,ce=n-1;\\n        int j=1;\\n        vector<vector<int>>res(n,vector<int>(n,0));\\n        while(rs <= re && cs <= ce){\\n            for(int i=cs;i<=ce;i++){\\n                res[rs][i]=j++;\\n            }\\n            rs++;\\n            for(int i=rs;i<=re;i++){\\n                res[i][ce]=j++;\\n            }\\n            ce--;\\n             if (rs <= re)\\n            for(int i=ce;i>=cs;i--){\\n                res[re][i]=j++;\\n            }\\n            re--;\\n            if (cs <= ce)\\n            for(int i=re;i>=rs;i--){\\n                res[i][cs]=j++;\\n            }\\n            cs++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//Runtime: 0 ms, faster than 100.00%\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int cnt=0;\\n        int rs=0,re=n-1;\\n        int cs=0,ce=n-1;\\n        int j=1;\\n        vector<vector<int>>res(n,vector<int>(n,0));\\n        while(rs <= re && cs <= ce){\\n            for(int i=cs;i<=ce;i++){\\n                res[rs][i]=j++;\\n            }\\n            rs++;\\n            for(int i=rs;i<=re;i++){\\n                res[i][ce]=j++;\\n            }\\n            ce--;\\n             if (rs <= re)\\n            for(int i=ce;i>=cs;i--){\\n                res[re][i]=j++;\\n            }\\n            re--;\\n            if (cs <= ce)\\n            for(int i=re;i>=rs;i--){\\n                res[i][cs]=j++;\\n            }\\n            cs++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964177,
                "title": "c-0ms-solution-easy-to-understand",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>v(n,vector<int>(n));\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j<n-i;j++){   //left to right\\n                v[i][j]=++count;\\n            }\\n            for(int k=i+1;k<n-i-1;k++){   //top to bottom\\n                v[k][n-i-1]=++count;\\n            }\\n            for(int l=n-1-i;l>i;l--){            // right to left\\n                v[n-i-1][l]=++count;\\n            }\\n            for(int m=n-1-i;m>i;m--){      //bottom to top\\n                v[m][i]=++count;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>v(n,vector<int>(n));\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j<n-i;j++){   //left to right\\n                v[i][j]=++count;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 963097,
                "title": "python",
                "content": "We do as told and construct the matrix via traversing the spiral.\\n\\n```python\\nclass Solution:\\n    def generateMatrix(self, n):\\n        ans = [[0]*n for _ in range(n)]\\n        x = y = j = 0\\n        dirs = [(0,1),(1,0),(0,-1),(-1,0)]\\n        for i in range(1,n**2+1):\\n            ans[x][y] = i\\n            dx, dy = dirs[j]\\n            if 0<=x+dx<=n-1 and 0<=y+dy<=n-1 and ans[x+dx][y+dy]==0:\\n                x, y = x+dx, y+dy\\n            else:\\n                j = (j+1)%4\\n                dx, dy = dirs[j]\\n                x, y = x+dx, y+dy   \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def generateMatrix(self, n):\\n        ans = [[0]*n for _ in range(n)]\\n        x = y = j = 0\\n        dirs = [(0,1),(1,0),(0,-1),(-1,0)]\\n        for i in range(1,n**2+1):\\n            ans[x][y] = i\\n            dx, dy = dirs[j]\\n            if 0<=x+dx<=n-1 and 0<=y+dy<=n-1 and ans[x+dx][y+dy]==0:\\n                x, y = x+dx, y+dy\\n            else:\\n                j = (j+1)%4\\n                dx, dy = dirs[j]\\n                x, y = x+dx, y+dy   \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394596,
                "title": "javascript-solution-beats-60",
                "content": "Here is my solution to solve this problem in JS.\\n\\n```\\n\\n/*         startColumn         endColumn\\n  startRow  1           2           3\\n            4           5           6\\n  endRow    7           8           9\\n */\\nconst spiral = n => {\\n    const results = [];\\n\\n    for (let i = 0; i < n; i++) {\\n        results.push([]);\\n    }\\n\\n    let startRow = 0,\\n        endRow = n - 1,\\n        startColumn = 0,\\n        endColumn = n - 1,\\n        count = 1;\\n\\n    while (startRow <= endRow && startColumn <= endColumn) {\\n        //Top Row\\n        for (let i = startColumn; i <= endColumn; i++) {\\n            results[startRow][i] = count;\\n            count++;\\n        }\\n        startRow++;\\n\\n        //Right Column\\n        for (let i = startRow; i <= endRow; i++) {\\n            results[i][endColumn] = count;\\n            count++;\\n        }\\n        endColumn--;\\n\\n        //bottom row\\n        for (let i = endColumn; i >= startColumn; i--) {\\n            results[endRow][i] = count;\\n            count++;\\n        }\\n        endRow--;\\n\\n        //Left Column\\n        for (let i = endRow; i >= startRow; i--) {\\n            results[i][startColumn] = count;\\n            count++;\\n        }\\n        startColumn++;\\n    }\\n    return results;\\n};\\n\\nconsole.log(spiral(3));\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/*         startColumn         endColumn\\n  startRow  1           2           3\\n            4           5           6\\n  endRow    7           8           9\\n */\\nconst spiral = n => {\\n    const results = [];\\n\\n    for (let i = 0; i < n; i++) {\\n        results.push([]);\\n    }\\n\\n    let startRow = 0,\\n        endRow = n - 1,\\n        startColumn = 0,\\n        endColumn = n - 1,\\n        count = 1;\\n\\n    while (startRow <= endRow && startColumn <= endColumn) {\\n        //Top Row\\n        for (let i = startColumn; i <= endColumn; i++) {\\n            results[startRow][i] = count;\\n            count++;\\n        }\\n        startRow++;\\n\\n        //Right Column\\n        for (let i = startRow; i <= endRow; i++) {\\n            results[i][endColumn] = count;\\n            count++;\\n        }\\n        endColumn--;\\n\\n        //bottom row\\n        for (let i = endColumn; i >= startColumn; i--) {\\n            results[endRow][i] = count;\\n            count++;\\n        }\\n        endRow--;\\n\\n        //Left Column\\n        for (let i = endRow; i >= startRow; i--) {\\n            results[i][startColumn] = count;\\n            count++;\\n        }\\n        startColumn++;\\n    }\\n    return results;\\n};\\n\\nconsole.log(spiral(3));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 384461,
                "title": "c-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) \\n    {\\n        if(!n)\\n            return {};\\n        int rowStart = 0, rowEnd = n - 1, colStart = 0, colEnd = n - 1;\\n        int count = 1;\\n        vector<vector<int>> result(n, vector<int>(n));\\n        while(count <= n * n)\\n        {\\n            for(int i = colStart; i <= colEnd && count <= n * n; result[rowStart][i++] = count++);\\n            for(int i = ++rowStart; i <= rowEnd && count <=  n * n; result[i++][colEnd] = count++);\\n            for(int i = --colEnd; i >= colStart && count <=  n * n; result[rowEnd][i--] = count++);\\n            for(int i = --rowEnd; i >= rowStart && count <= n * n; result[i--][colStart] = count++);\\n            ++colStart;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) \\n    {\\n        if(!n)\\n            return {};\\n        int rowStart = 0, rowEnd = n - 1, colStart = 0, colEnd = n - 1;\\n        int count = 1;\\n        vector<vector<int>> result(n, vector<int>(n));\\n        while(count <= n * n)\\n        {\\n            for(int i = colStart; i <= colEnd && count <= n * n; result[rowStart][i++] = count++);\\n            for(int i = ++rowStart; i <= rowEnd && count <=  n * n; result[i++][colEnd] = count++);\\n            for(int i = --colEnd; i >= colStart && count <=  n * n; result[rowEnd][i--] = count++);\\n            for(int i = --rowEnd; i >= rowStart && count <= n * n; result[i--][colStart] = count++);\\n            ++colStart;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309573,
                "title": "swift-beating-all-linear-solution-kewl-lewpz-hacker-rank-scared-money",
                "content": "```\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {\\n        \\n        var m = [[Int]](repeating: [Int](repeating: 0, count: n), count: n)\\n        \\n        var l = 0, r = n - 1, t = 0, b = n - 1, x = 0, y = 0, val = 1\\n        \\n        while t <= b {\\n            \\n            x = l; y = t\\n            while x <= r { m[t][x] = val; val += 1; x += 1 }\\n            \\n            t += 1; y = t\\n            while y <= b { m[y][r] = val; val += 1; y += 1 }\\n            \\n            r -= 1; x = r\\n            while x >= l { m[b][x] = val; val += 1; x -= 1 }\\n            \\n            b -= 1; y = b\\n            while y >= t { m[y][l] = val; val += 1; y -= 1 }\\n            \\n            l += 1\\n        }\\n        \\n        return m\\n    }\\n}\\n```\\n\\nBig big big big big big big big man.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {\\n        \\n        var m = [[Int]](repeating: [Int](repeating: 0, count: n), count: n)\\n        \\n        var l = 0, r = n - 1, t = 0, b = n - 1, x = 0, y = 0, val = 1\\n        \\n        while t <= b {\\n            \\n            x = l; y = t\\n            while x <= r { m[t][x] = val; val += 1; x += 1 }\\n            \\n            t += 1; y = t\\n            while y <= b { m[y][r] = val; val += 1; y += 1 }\\n            \\n            r -= 1; x = r\\n            while x >= l { m[b][x] = val; val += 1; x -= 1 }\\n            \\n            b -= 1; y = b\\n            while y >= t { m[y][l] = val; val += 1; y -= 1 }\\n            \\n            l += 1\\n        }\\n        \\n        return m\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238780,
                "title": "ruby-solution",
                "content": "the solution learns from the discuss, here is the code:\\n\\n```ruby\\n\\ndef generate_matrix(n)\\n  arr = Array.new(n){ Array.new(n) }\\n  \\n  i, j, di, dj = 0, 0, 0, 1\\n  (0...n*n).each do |k|\\n    arr[i][j] = k + 1  \\n    \\n    di, dj = dj, -di if arr[(i+di)%n][(j+dj)%n]\\n    \\n    i += di\\n    j += dj\\n  end\\n  \\n  arr\\nend\\n",
                "solutionTags": [],
                "code": "the solution learns from the discuss, here is the code:\\n\\n```ruby\\n\\ndef generate_matrix(n)\\n  arr = Array.new(n){ Array.new(n) }\\n  \\n  i, j, di, dj = 0, 0, 0, 1\\n  (0...n*n).each do |k|\\n    arr[i][j] = k + 1  \\n    \\n    di, dj = dj, -di if arr[(i+di)%n][(j+dj)%n]\\n    \\n    i += di\\n    j += dj\\n  end\\n  \\n  arr\\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 22392,
                "title": "c-template-for-spiral-matrix-spiral-matrix-ii",
                "content": "Spiral Matrix II code:\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> generateMatrix(int n) {\\n            vector<vector<int>> result(n, vector<int>(n, 0));\\n            int l=0, r=n-1, u=0, d=n-1;\\n            int k=1;\\n            while(true){\\n                for(int i=l; i<=r; i++)  result[u][i]=k++;\\n                if(++u>d) break;\\n                \\n                for(int i=u; i<=d; i++)  result[i][r]=k++;\\n                if(r--<l) break;\\n                \\n                for(int i=r; i>=l; i--)  result[d][i]=k++;\\n                if(--d<u) break;\\n                \\n                for(int i=d; i>=u; i--)  result[i][l]=k++;\\n                if(++l>r) break;\\n            }\\n            return result;\\n        }\\n    };\\n\\nSpiral Matrix Code:\\n\\n    class Solution {\\n    public:\\n        vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n            if(matrix.empty())  return {};\\n            int m=matrix.size(), n=matrix[0].size();\\n            vector<int> spiral(m*n);\\n            int u=0, d=m-1, l=0, r=n-1, k=0;\\n            while(true){\\n                /** up **/\\n                for(int col=l; col<=r; col++)  spiral[k++]=matrix[u][col];\\n                if(++u>d) break;\\n                /** right **/\\n                for(int row=u; row<=d; row++)  spiral[k++]=matrix[row][r];\\n                if(--r<l) break;\\n                /** down **/\\n                for(int col=r; col>=l; col--)  spiral[k++]=matrix[d][col];\\n                if(--d<u) break;\\n                /** left **/\\n                for(int row=d; row>=u; row--)  spiral[k++]=matrix[row][l];\\n                if(++l>r) break;\\n            }\\n            return spiral;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> generateMatrix(int n) {\\n            vector<vector<int>> result(n, vector<int>(n, 0));\\n            int l=0, r=n-1, u=0, d=n-1;\\n            int k=1;\\n            while(true){\\n                for(int i=l; i<=r; i++)  result[u][i]=k++;\\n                if(++u>d) break;\\n                \\n                for(int i=u; i<=d; i++)  result[i][r]=k++;\\n                if(r--<l) break;\\n                \\n                for(int i=r; i>=l; i--)  result[d][i]=k++;\\n                if(--d<u) break;\\n                \\n                for(int i=d; i>=u; i--)  result[i][l]=k++;\\n                if(++l>r) break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3510253,
                "title": "algorithmic-approach-in-python-beginner-friendly",
                "content": "# Algorithmic Approach\\n* This problem makes more sense when you have solved the Spiral Matrix.\\n* This problem is to **generate a square matrix** **fil**led with **ele**ments from **`1 to n^2 in spiral order`**. \\n* The approach used in the code is to **kee**p **tra**ck of the `current top, bottom, left and right boundaries of the matrix`. \\n* The **alg**orithm **sta**rts from the `top left corner` and **moves** **tow**ards the `right boundary` while **fil**ling the **top row**. \\n* Once it **rea**ches the `right boundary`, it **moves down** **tow**ards the `bottom boundary` while **fil**ling the **rightmost column**.\\n*  Once it **rea**ches the `bottom boundary`, it **moves towards** the `left boundary` while **fil**ling the `bottom row`. \\n* Once it **rea**ches the `left boundary`, it **moves up tow**ards the `top boundary` while **fil**ling the `leftmost column`. \\n* After completing `one full cycle`, it `updates the top, bottom, left and right boundaries` and **rep**eats the **pro**cess **unt**il **all ele**ments have been **fil**led.\\n\\n![Image showing the initial values for top, bottom, left, and right](https://assets.leetcode.com/users/images/0cdc3ae1-62eb-4b85-86eb-50b0a72c3a94_1683755756.0455143.png)\\n\\n\\n# Time and Space Complexity: $O(n^2)$\\n\\n# Code\\n``` Python []\\n\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        # Initialize the top, bottom, right and left boundaries of the matrix\\n        top = 0\\n        bottom = n - 1\\n        right = n - 1\\n        left = 0\\n\\n        # Initialize a counter to keep track of the numbers to fill in the matrix\\n        count = 1\\n\\n        # Initialize an empty matrix of size n by n filled with zeros\\n        res = [[0 for _ in range(n)] for _ in range(n)]\\n\\n        # Loop until the row and column boundaries cross each other\\n        while top <= bottom and left <= right:\\n            \\n            # Left to right with top as constant\\n            for i in range(left, right + 1):\\n                res[top][i] = count\\n                count += 1\\n            # Move the top boundary down by one\\n            top += 1\\n\\n            # Top to bottom with right as constant\\n            for i in range(top, bottom + 1):\\n                res[i][right] = count\\n                count += 1\\n            # Move the right boundary left by one\\n            right -= 1\\n\\n            # Check if the top boundary is still below the bottom boundary\\n            # Right to left with bottom as constant\\n            if top <= bottom:\\n                for i in range(right, left - 1, -1):\\n                    res[bottom][i] = count\\n                    count += 1\\n                # Move the bottom boundary up by one\\n                bottom -= 1\\n\\n            # Check if the left boundary is still below the right boundary\\n            # Bottom to top with left as constant\\n            if left <= right:\\n                for i in range(bottom, top - 1, -1):\\n                    res[i][left] = count\\n                    count += 1\\n                # Move the left boundary right by one\\n                left += 1\\n\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "``` Python []\\n\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        # Initialize the top, bottom, right and left boundaries of the matrix\\n        top = 0\\n        bottom = n - 1\\n        right = n - 1\\n        left = 0\\n\\n        # Initialize a counter to keep track of the numbers to fill in the matrix\\n        count = 1\\n\\n        # Initialize an empty matrix of size n by n filled with zeros\\n        res = [[0 for _ in range(n)] for _ in range(n)]\\n\\n        # Loop until the row and column boundaries cross each other\\n        while top <= bottom and left <= right:\\n            \\n            # Left to right with top as constant\\n            for i in range(left, right + 1):\\n                res[top][i] = count\\n                count += 1\\n            # Move the top boundary down by one\\n            top += 1\\n\\n            # Top to bottom with right as constant\\n            for i in range(top, bottom + 1):\\n                res[i][right] = count\\n                count += 1\\n            # Move the right boundary left by one\\n            right -= 1\\n\\n            # Check if the top boundary is still below the bottom boundary\\n            # Right to left with bottom as constant\\n            if top <= bottom:\\n                for i in range(right, left - 1, -1):\\n                    res[bottom][i] = count\\n                    count += 1\\n                # Move the bottom boundary up by one\\n                bottom -= 1\\n\\n            # Check if the left boundary is still below the right boundary\\n            # Bottom to top with left as constant\\n            if left <= right:\\n                for i in range(bottom, top - 1, -1):\\n                    res[i][left] = count\\n                    count += 1\\n                # Move the left boundary right by one\\n                left += 1\\n\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509833,
                "title": "easy-java-solution-0ms-100-faster-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int num[][] = new int[n][n];\\n        int count = 1;\\n        int top = 0,left = 0,bottom = n -1,right = n - 1;\\n        while(top <= bottom && left <= right){\\n            for(int i = left ; i <= right ; i++){\\n                num[top][i] = count++;\\n            }\\n            top++;\\n            for(int i = top ; i <= bottom; i++){\\n                num[i][right] = count++;\\n            }\\n            right--;\\n            if(top <= bottom){\\n                for(int i = right; i >= left; i --){\\n                    num[bottom][i] = count++;\\n                }\\n                bottom--;\\n            }\\n            if(left <= right){\\n                for(int i = bottom; i >= top; i --){\\n                    num[i][left] = count++;\\n                }\\n                left++;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int num[][] = new int[n][n];\\n        int count = 1;\\n        int top = 0,left = 0,bottom = n -1,right = n - 1;\\n        while(top <= bottom && left <= right){\\n            for(int i = left ; i <= right ; i++){\\n                num[top][i] = count++;\\n            }\\n            top++;\\n            for(int i = top ; i <= bottom; i++){\\n                num[i][right] = count++;\\n            }\\n            right--;\\n            if(top <= bottom){\\n                for(int i = right; i >= left; i --){\\n                    num[bottom][i] = count++;\\n                }\\n                bottom--;\\n            }\\n            if(left <= right){\\n                for(int i = bottom; i >= top; i --){\\n                    num[i][left] = count++;\\n                }\\n                left++;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508134,
                "title": "kotlin-2d-array-easy-solution-with-great-explanation",
                "content": "# Intuition\\nI solved this task yesterday lol, i just need to advance it :)\\n\\n# Approach\\nSo, we need to initialize `n * n` matrix/grid with zeroes on each position(which is our result, we need to edit this matrix/grid)\\n\\nNext we need to declare `direction` variable, which is equal to `\\'R\\'`, because start direction is `\"Right\"`.\\n\\nAfter that we can declare our borders on each side:\\n`borderLeft`, `borderUp` and etc.\\nNotice, that `borderUp` is equal to 1, because on start we already fill first line, so we need to move border.\\n\\nI used to `matrix[i][j]`, so i created iterables `i` which is a **Column**, and `j` which is a **Row**!\\n\\nNow we can start to travel in Matrix from `0` to `n * n` because we need to fill each cell from `1` to `n * n`, so in each step we are going to `matrix[i][j] = k + 1`(we could start from `1` to `n * n + 1`, because `until` works like: `1 <= until < (n * n + 1)`).\\n\\nI hope you understand =)\\nLet\\'s continue!\\n\\nIn Kotlin we have `when` statement, it\\'s equals to `switch`, but in my opinion much better :)\\nWe could do `when (direction) { /* TODO */ }`, but if we needed to write some `if` statements in `when` -> we can\\'t use mentioned before expression.\\n\\nWe\\'ll use `when` statement to check `direction` each time we go to somewhere. And so, if `direction == \\'R\\'`, we are going to move to the right with `j`(like `matrix[i][j++]`). And each time we are checking if we contact the `border` with `j`, if we contacted -> we are switching our direction according to statement to `\\'D\\'` and decrease possible `border`.\\n\\nNow we need to do the same with all directions. After `for` just return our edited matrix :)\\n\\n**If u liked my explanation please vote for this solution, its important to me!**\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```kotlin []\\nclass Solution {\\n    fun generateMatrix(n: Int): Array<IntArray> {\\n        var matrix = Array(n) { IntArray(n) }\\n        var direction = \\'R\\'\\n        var borderLeft = 0\\n        var borderRight = n - 1\\n        var borderUp = 1\\n        var borderDown = n - 1\\n        var i = 0\\n        var j = 0\\n        for (k in 0 until n * n) {\\n            matrix[i][j] = k + 1\\n            when {\\n                direction == \\'R\\' -> {\\n                    j++\\n                    if (j == borderRight) {\\n                        direction = \\'D\\'\\n                        borderRight--\\n                    }\\n                }\\n                direction == \\'D\\' -> {\\n                    i++\\n                    if (i == borderDown) {\\n                        direction = \\'L\\'\\n                        borderDown--\\n                    }\\n                }\\n                direction == \\'L\\' -> {\\n                    j--\\n                    if (j == borderLeft) {\\n                        direction = \\'U\\'\\n                        borderLeft++\\n                    }\\n                }\\n                direction == \\'U\\' -> {\\n                    i--\\n                    if (i == borderUp) {\\n                        direction = \\'R\\'\\n                        borderUp++\\n                    }\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Array",
                    "Matrix"
                ],
                "code": "```kotlin []\\nclass Solution {\\n    fun generateMatrix(n: Int): Array<IntArray> {\\n        var matrix = Array(n) { IntArray(n) }\\n        var direction = \\'R\\'\\n        var borderLeft = 0\\n        var borderRight = n - 1\\n        var borderUp = 1\\n        var borderDown = n - 1\\n        var i = 0\\n        var j = 0\\n        for (k in 0 until n * n) {\\n            matrix[i][j] = k + 1\\n            when {\\n                direction == \\'R\\' -> {\\n                    j++\\n                    if (j == borderRight) {\\n                        direction = \\'D\\'\\n                        borderRight--\\n                    }\\n                }\\n                direction == \\'D\\' -> {\\n                    i++\\n                    if (i == borderDown) {\\n                        direction = \\'L\\'\\n                        borderDown--\\n                    }\\n                }\\n                direction == \\'L\\' -> {\\n                    j--\\n                    if (j == borderLeft) {\\n                        direction = \\'U\\'\\n                        borderLeft++\\n                    }\\n                }\\n                direction == \\'U\\' -> {\\n                    i--\\n                    if (i == borderUp) {\\n                        direction = \\'R\\'\\n                        borderUp++\\n                    }\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507852,
                "title": "simple-java-beats-100-runtime-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to create a 2-dimensional matrix of size n x n such that the elements are filled in spiral form.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Follow the code below to understand the solution.**\\n\\n      **If this solution helped you, give it an up-vote to help others** \\n\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        \\n\\n        int [][] arr = new int[n][n];\\n\\n        int i = 0;      //starting row index\\n        int j = 0;      //starting col index\\n\\n        int k = n;    //ending row index\\n        int l = n;    //ending col index\\n\\n        int count = 0;\\n\\n        boolean flag = true;\\n\\n        while(flag) {\\n\\n            flag = false;\\n\\n\\n            //--------------LEFT --->> RIGHT------------//\\n            while(j < l)\\n            {\\n              arr[i][j] = ++count;\\n              j++;\\n                flag = true;\\n            }\\n            j--;\\n            i++;\\n\\n\\n            //-------------TOP --->> BOTTOM-------------//\\n\\n            while (i < k) {\\n                arr[i][j] = ++count;\\n                i++;\\n                flag = true;\\n            }\\n            j--;\\n            i--;\\n            k--;\\n\\n            //-----------RIGHT --->> LEFT---------//\\n            while (j >= n - l) {\\n                arr[i][j] = ++count;\\n                j--;\\n                flag = true;\\n            }\\n            j++;\\n            l--;\\n            i--;\\n\\n            //----------BOTTOM --->> TOP-------------//\\n            while (i >= n - k) {\\n                arr[i][j] = ++count;\\n                i--;\\n                flag = true;\\n            }\\n            i++;\\n            j++;\\n        }\\n\\n\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        \\n\\n        int [][] arr = new int[n][n];\\n\\n        int i = 0;      //starting row index\\n        int j = 0;      //starting col index\\n\\n        int k = n;    //ending row index\\n        int l = n;    //ending col index\\n\\n        int count = 0;\\n\\n        boolean flag = true;\\n\\n        while(flag) {\\n\\n            flag = false;\\n\\n\\n            //--------------LEFT --->> RIGHT------------//\\n            while(j < l)\\n            {\\n              arr[i][j] = ++count;\\n              j++;\\n                flag = true;\\n            }\\n            j--;\\n            i++;\\n\\n\\n            //-------------TOP --->> BOTTOM-------------//\\n\\n            while (i < k) {\\n                arr[i][j] = ++count;\\n                i++;\\n                flag = true;\\n            }\\n            j--;\\n            i--;\\n            k--;\\n\\n            //-----------RIGHT --->> LEFT---------//\\n            while (j >= n - l) {\\n                arr[i][j] = ++count;\\n                j--;\\n                flag = true;\\n            }\\n            j++;\\n            l--;\\n            i--;\\n\\n            //----------BOTTOM --->> TOP-------------//\\n            while (i >= n - k) {\\n                arr[i][j] = ++count;\\n                i--;\\n                flag = true;\\n            }\\n            i++;\\n            j++;\\n        }\\n\\n\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507748,
                "title": "o-1-space-easy-c-beats-100-explanation-beginner-friendly",
                "content": "# Explanation\\nThe given code is used to generate a matrix of size n by n, where n is a positive integer. The generated matrix follows a specific pattern: starting from the top-left corner, the elements of the matrix are filled in a clockwise spiral order until the center is reached.\\n\\nHere\\'s the intuition behind the code:\\n\\n1) Initialize the 2D vector v of size n by n with all elements set to 0. This vector will store the generated matrix.\\n\\n2) Initialize variables left, right, top, and bottom to keep track of the boundaries of the current spiral.\\n\\n3) Initialize a variable val to keep track of the value to be filled in the matrix. It starts from 1 and increments as we fill in the elements.\\n\\n4) While the element at the center of the matrix is not filled (i.e., v[n/2][n/2] == 0), continue the spiral filling process.\\n\\n5) Fill the top row of the current spiral from left to right with values from val and increment val.\\n\\n6) Increment top to exclude the filled top row from future iterations.\\n\\n7) Fill the right column of the current spiral from top to bottom with values from val and increment val.\\n\\n8) Decrement right to exclude the filled right column from future iterations.\\n\\n9) Fill the bottom row of the current spiral from right to left with values from val and increment val.\\n\\n10) Decrement bottom to exclude the filled bottom row from future iterations.\\n\\n11) Fill the left column of the current spiral from bottom to top with values from val and increment val.\\n\\n12) Increment left to exclude the filled left column from future iterations.\\n\\n13) Repeat steps 5 to 12 until the center element of the matrix is filled.\\n\\nFinally, return the generated matrix v.\\n\\nThe code utilizes the four variables left, right, top, and bottom to keep track of the current boundaries of the spiral. By incrementing or decrementing these boundaries, the code ensures that the next spiral is filled correctly.\\n\\nThe val variable is used to keep track of the value to be filled in the matrix. It starts from 1 and increments after each element is filled.\\n\\nBy following this spiral pattern and updating the boundaries accordingly, the code generates the desired matrix.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1), this is because we are not using any extra space other than what is asked in the question to return as the final answer.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUPVOTE if you like the solution. Glad to help. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> v(n, vector<int>(n,0));\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        int val=1;\\n        while(v[n/2][n/2]==0){\\n            for(int i=left;i<=right;i++) v[top][i]=val++;\\n            top++;\\n            for(int i=top;i<=bottom;i++) v[i][right]=val++;\\n            right--;\\n            for(int i=right;i>=left;i--) v[bottom][i]=val++;\\n            bottom--;\\n            for(int i=bottom;i>=top;i--) v[i][left]=val++;\\n            left++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> v(n, vector<int>(n,0));\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        int val=1;\\n        while(v[n/2][n/2]==0){\\n            for(int i=left;i<=right;i++) v[top][i]=val++;\\n            top++;\\n            for(int i=top;i<=bottom;i++) v[i][right]=val++;\\n            right--;\\n            for(int i=right;i>=left;i--) v[bottom][i]=val++;\\n            bottom--;\\n            for(int i=bottom;i>=top;i--) v[i][left]=val++;\\n            left++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507281,
                "title": "easiest-and-fast-c-soln-beats-100",
                "content": "**Please upvote if it helps.**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int leftrow = 0,rightrow = n-1,leftcol = 0,rightcol = n-1;\\n        int count = 1,total = n*n;\\n        vector<vector<int>> ans(n,vector<int>(n));\\n\\n        while(count<=total)\\n        {\\n            for(int i=leftcol; i<=rightcol; i++)\\n            {\\n                ans[leftrow][i] = count;\\n                count++;\\n            }\\n            leftrow++;\\n\\n            if(count > total)\\n                break;\\n            for(int i=leftrow; i<=rightrow; i++)\\n            {\\n                ans[i][rightcol] = count;\\n                count++;\\n            }\\n            rightcol--;\\n\\n            if(count > total)\\n                break;\\n            for(int i=rightcol; i>=leftcol; i--)\\n            {\\n                ans[rightrow][i] = count;\\n                count++;\\n            }\\n            rightrow--;\\n\\n            if(count > total)\\n                break;\\n            for(int i=rightrow; i>=leftrow; i--)\\n            {\\n                ans[i][leftcol] = count;\\n                count++;\\n            }\\n            leftcol++;\\n            if(count > total)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int leftrow = 0,rightrow = n-1,leftcol = 0,rightcol = n-1;\\n        int count = 1,total = n*n;\\n        vector<vector<int>> ans(n,vector<int>(n));\\n\\n        while(count<=total)\\n        {\\n            for(int i=leftcol; i<=rightcol; i++)\\n            {\\n                ans[leftrow][i] = count;\\n                count++;\\n            }\\n            leftrow++;\\n\\n            if(count > total)\\n                break;\\n            for(int i=leftrow; i<=rightrow; i++)\\n            {\\n                ans[i][rightcol] = count;\\n                count++;\\n            }\\n            rightcol--;\\n\\n            if(count > total)\\n                break;\\n            for(int i=rightcol; i>=leftcol; i--)\\n            {\\n                ans[rightrow][i] = count;\\n                count++;\\n            }\\n            rightrow--;\\n\\n            if(count > total)\\n                break;\\n            for(int i=rightrow; i>=leftrow; i--)\\n            {\\n                ans[i][leftcol] = count;\\n                count++;\\n            }\\n            leftcol++;\\n            if(count > total)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507022,
                "title": "c-beats-100-only-few-changes-in-spiral-matrix-1",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- $$O(n*n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- $$O(n*n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n\\n        int top = 0;\\n        int left = 0;\\n        int bottom = n - 1;\\n        int right = n - 1;\\n        int k = 1;\\n\\n        while(top <= bottom && left <= right) {\\n            // Traversing right\\n            for(int i = left; i <= right; i++) {\\n                matrix[top][i] = k;\\n                k++;\\n            }\\n            top++;\\n            // Traversing down\\n            for(int i = top; i <= bottom; i++) {\\n                matrix[i][right] = k;\\n                k++;\\n            }\\n            right--;\\n            // Traversing left\\n            if(top <= bottom) {\\n                for(int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = k;\\n                    k++;\\n                }\\n                bottom--;\\n            }\\n            // Traversing up\\n            if(left <= right) {\\n                for(int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = k;\\n                    k++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n\\n        int top = 0;\\n        int left = 0;\\n        int bottom = n - 1;\\n        int right = n - 1;\\n        int k = 1;\\n\\n        while(top <= bottom && left <= right) {\\n            // Traversing right\\n            for(int i = left; i <= right; i++) {\\n                matrix[top][i] = k;\\n                k++;\\n            }\\n            top++;\\n            // Traversing down\\n            for(int i = top; i <= bottom; i++) {\\n                matrix[i][right] = k;\\n                k++;\\n            }\\n            right--;\\n            // Traversing left\\n            if(top <= bottom) {\\n                for(int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = k;\\n                    k++;\\n                }\\n                bottom--;\\n            }\\n            // Traversing up\\n            if(left <= right) {\\n                for(int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = k;\\n                    k++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506965,
                "title": "100-faster-c-solution-with-explanations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to generate a square matrix of size n with elements from 1 to n^2 in spiral order. To generate the matrix in spiral order, we can start by filling in the top row from left to right, then the right column from top to bottom, then the bottom row from right to left, and finally the left column from bottom to top. We can repeat this process until all the elements of the matrix have been filled in.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Create an n x n matrix with all elements initialized to 0.\\n2.Initialize variables startingRow, endingRow, startingCol, and endingCol to keep track of the current boundaries of the matrix.\\n3.Initialize k to 1, which represents the current element to be filled in the matrix.\\n4.Use a while loop to iterate over the matrix until all elements have been filled.\\n5.Within the while loop, use four for loops to fill in the elements of the matrix in spiral order:\\n6.The first loop fills in the top row of the matrix from left to right.\\n7.The second loop fills in the right column of the matrix from top to bottom.\\n8.The third loop fills in the bottom row of the matrix from right to left.\\n9.The fourth loop fills in the left column of the matrix from bottom to top.\\n10.After each loop, update the boundaries of the matrix by incrementing or decrementing the appropriate variables.\\n11.Increment k after each element is filled in the matrix.\\n12.Return the resulting matrix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the given code is O(n^2) because the while loop iterates over all n^2 elements of the matrix, and each element is filled in exactly once.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the given code is O(n^2) because we create an n x n matrix to store the resulting elements.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n\\n        int startingRow=0;\\n        int endingRow=n-1;\\n        int startingCol=0;\\n        int endingCol=n-1;\\n        int k=1;\\n        int last=n*n;\\n    while(k<=last){\\n        for(int i=startingCol;k<=last,i<=endingCol;i++){\\n            mat[startingRow][i]=k++;\\n        }\\n        startingRow++;\\n        for(int i=startingRow;k<=last,i<=endingRow;i++){\\n            mat[i][endingCol]=k++;\\n        }\\n\\n        endingCol--;\\n        for(int i=endingCol;k<=last,i>=startingCol;i--){\\n            mat[endingRow][i]=k++;\\n        }\\n        endingRow--;\\n        for(int i=endingRow;k<=last, i>=startingRow;i--){\\n            mat[i][startingCol]=k++;\\n        }\\n        startingCol++;\\n     }\\n     return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n\\n        int startingRow=0;\\n        int endingRow=n-1;\\n        int startingCol=0;\\n        int endingCol=n-1;\\n        int k=1;\\n        int last=n*n;\\n    while(k<=last){\\n        for(int i=startingCol;k<=last,i<=endingCol;i++){\\n            mat[startingRow][i]=k++;\\n        }\\n        startingRow++;\\n        for(int i=startingRow;k<=last,i<=endingRow;i++){\\n            mat[i][endingCol]=k++;\\n        }\\n\\n        endingCol--;\\n        for(int i=endingCol;k<=last,i>=startingCol;i--){\\n            mat[endingRow][i]=k++;\\n        }\\n        endingRow--;\\n        for(int i=endingRow;k<=last, i>=startingRow;i--){\\n            mat[i][startingCol]=k++;\\n        }\\n        startingCol++;\\n     }\\n     return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506689,
                "title": "simple-bfs-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<vector<int>> generateMatrix(int n)\\n{\\n    int rr[] = {0, 1, 0, -1};\\n    int cc[] = {1, 0, -1, 0};\\n\\n    vector<vector<int>> visited(n, vector<int>(n, 0));\\n    vector<vector<int>> ans(n, vector<int>(n, 0));\\n    visited[0][0] = 1;\\n    ans[0][0] = 1;\\n\\n    int index = 0;\\n    int count = 1;\\n\\n    int row = 0;\\n    int col = 0;\\n\\n    while (count < n * n)\\n    {\\n        int r = row + rr[index];\\n        int c = col + cc[index];\\n\\n        if (r < n and c < n and r >= 0 and c >= 0 and !visited[r][c])\\n        {\\n            count++;\\n            ans[r][c] = count;\\n            visited[r][c] = 1;\\n            row = r;\\n            col = c;\\n        }\\n        else\\n        {\\n            index = (index + 1) % 4;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<vector<int>> generateMatrix(int n)\\n{\\n    int rr[] = {0, 1, 0, -1};\\n    int cc[] = {1, 0, -1, 0};\\n\\n    vector<vector<int>> visited(n, vector<int>(n, 0));\\n    vector<vector<int>> ans(n, vector<int>(n, 0));\\n    visited[0][0] = 1;\\n    ans[0][0] = 1;\\n\\n    int index = 0;\\n    int count = 1;\\n\\n    int row = 0;\\n    int col = 0;\\n\\n    while (count < n * n)\\n    {\\n        int r = row + rr[index];\\n        int c = col + cc[index];\\n\\n        if (r < n and c < n and r >= 0 and c >= 0 and !visited[r][c])\\n        {\\n            count++;\\n            ans[r][c] = count;\\n            visited[r][c] = 1;\\n            row = r;\\n            col = c;\\n        }\\n        else\\n        {\\n            index = (index + 1) % 4;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506597,
                "title": "beats-100-java-c-python-fast-and-elegant",
                "content": "> \\u26A0\\uFE0F **Disclaimer**: The original solution was crafted in Java. Thus, when we mention \"Beats 100%\" it applies specifically to Java submissions. The performance may vary for other languages.\\n\\nDon\\'t forget to upvote if you find the content below helpful. \\uD83D\\uDE43\\n\\n## Problem\\nThe problem is to generate a square matrix filled with elements from 1 to n\\xB2 in a spiral order.\\n\\n## Similarity to Previous Problem\\nThis solution is very similar to [my solution of Spiral Matrix problem](https://leetcode.com/problems/spiral-matrix/solutions/3503165/beats-100-java-c-python-elegant-solution-explained/), where we traverse a 2D matrix in a spiral order. The key difference is that in the current problem, we are generating the matrix, while in the previous one we are traversing it.\\n\\n## Approach\\nWe initialize a 2D matrix of size $$n \\\\times n$$. We keep track of the current cell that we are in using `(r, c)`, and the direction in which we are moving using `(dr, dc)`. \\n\\nInitially, we start from the cell `(0,0)` and move towards the right. For each cell, we assign a number starting from `1`. If the next cell in the current direction is out of bounds or already assigned, we turn `90` degrees to the right.\\n\\n# Complexity Analysis\\n- Time complexity: The time complexity is $$O(n\\xB2)$$, where $$n$$ is the input number. This is because we have to fill up $$n\\xB2$$ cells in the matrix.\\n\\n- Space Complexity: The space complexity is also $$O(n\\xB2)$$, as we need to allocate a 2D array of size $$n \\\\times n$$ to store the resulting matrix.\\n\\n## Code\\n```java []\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int r = 0, c = 0, dr = 0, dc = 1;\\n        for (int current = 1; current <= n * n; current++) {\\n            matrix[r][c] = current;\\n            if (r + dr >= matrix.length || r + dr < 0\\n                    || c + dc >= matrix[0].length || c + dc < 0\\n                    || matrix[r + dr][c + dc] != 0\\n            ) {\\n                int temp = dc;\\n                dc = -dr;\\n                dr = temp;\\n            }\\n            r += dr;\\n            c += dc;\\n        }\\n        return matrix;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n        int r = 0, c = 0, dr = 0, dc = 1;\\n        for (int current = 1; current <= n * n; ++current) {\\n            matrix[r][c] = current;\\n            if (r + dr >= n || r + dr < 0 || c + dc >= n || c + dc < 0 || matrix[r + dr][c + dc] != 0) {\\n                swap(dr, dc);\\n                dr = -dr;\\n            }\\n            r += dr;\\n            c += dc;\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```\\n``` python3 []\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0]*n for _ in range(n)]\\n        r, c, dr, dc = 0, 0, 0, 1\\n        for current in range(1, n*n + 1):\\n            matrix[r][c] = current\\n            if not (0 <= r + dr < n and 0 <= c + dc < n and matrix[r + dr][c + dc] == 0):\\n                dr, dc = dc, -dr\\n            r += dr\\n            c += dc\\n        return matrix\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int r = 0, c = 0, dr = 0, dc = 1;\\n        for (int current = 1; current <= n * n; current++) {\\n            matrix[r][c] = current;\\n            if (r + dr >= matrix.length || r + dr < 0\\n                    || c + dc >= matrix[0].length || c + dc < 0\\n                    || matrix[r + dr][c + dc] != 0\\n            ) {\\n                int temp = dc;\\n                dc = -dr;\\n                dr = temp;\\n            }\\n            r += dr;\\n            c += dc;\\n        }\\n        return matrix;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n        int r = 0, c = 0, dr = 0, dc = 1;\\n        for (int current = 1; current <= n * n; ++current) {\\n            matrix[r][c] = current;\\n            if (r + dr >= n || r + dr < 0 || c + dc >= n || c + dc < 0 || matrix[r + dr][c + dc] != 0) {\\n                swap(dr, dc);\\n                dr = -dr;\\n            }\\n            r += dr;\\n            c += dc;\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```\n``` python3 []\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0]*n for _ in range(n)]\\n        r, c, dr, dc = 0, 0, 0, 1\\n        for current in range(1, n*n + 1):\\n            matrix[r][c] = current\\n            if not (0 <= r + dr < n and 0 <= c + dc < n and matrix[r + dr][c + dc] == 0):\\n                dr, dc = dc, -dr\\n            r += dr\\n            c += dc\\n        return matrix\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464037,
                "title": "java-solution-for-spiral-matrix-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code generates a 2D matrix of size n x n with numbers from 1 to n*n in spiral order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt uses a loop to iterate over all the elements in the matrix and keeps track of the current position (x, y) in the matrix. It also keeps track of the current step in the spiral using the variable step.\\n\\nThe code then iterates through the four sides of the matrix in a spiral order, filling in the numbers as it goes along. The while loops are used to fill in each side of the matrix.\\n\\nOnce all the numbers have been filled in, the resulting 2D matrix is returned.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2) since it needs to fill in each of the n^2 elements in the matrix\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2) since it needs to create a 2D matrix of size n x n to store the result.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int total = n*n;\\n        int[][] result= new int[n][n];\\n        int x=0;\\n        int y=0;\\n        int step = 0;\\n        for(int i=0;i<total;)\\n        {\\n            while(y+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y++;\\n            }\\n            y--;\\n            x++;\\n            while(x+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x++;\\n            }\\n            x--;\\n            y--;\\n            while(y>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y--;\\n            }\\n            y++;\\n            x--;\\n            step++;\\n            while(x>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x--;\\n            }\\n            x++;\\n            y++;\\n        }\\n        return result;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int total = n*n;\\n        int[][] result= new int[n][n];\\n        int x=0;\\n        int y=0;\\n        int step = 0;\\n        for(int i=0;i<total;)\\n        {\\n            while(y+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y++;\\n            }\\n            y--;\\n            x++;\\n            while(x+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x++;\\n            }\\n            x--;\\n            y--;\\n            while(y>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y--;\\n            }\\n            y++;\\n            x--;\\n            step++;\\n            while(x>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x--;\\n            }\\n            x++;\\n            y++;\\n        }\\n        return result;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214880,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>m(n,vector<int>(n,0));\\n        int c=1;\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            \\n                for(int i=left;i<=right;i++){\\n                    m[top][i]=c;\\n                    c++;\\n                }\\n                top++;\\n                for(int i=top;i<=bottom;i++){\\n                   m[i][right]=c;\\n                    c++; \\n                }\\n                right--;\\n                for(int i=right;i>=left;i--){\\n                    m[bottom][i]=c;\\n                    c++;\\n                }\\n                bottom--;\\n                for(int i=bottom;i>=top;i--){\\n                   m[i][left]=c;\\n                    c++; \\n                }\\n                left++;\\n        }\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>m(n,vector<int>(n,0));\\n        int c=1;\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            \\n                for(int i=left;i<=right;i++){\\n                    m[top][i]=c;\\n                    c++;\\n                }\\n                top++;\\n                for(int i=top;i<=bottom;i++){\\n                   m[i][right]=c;\\n                    c++; \\n                }\\n                right--;\\n                for(int i=right;i>=left;i--){\\n                    m[bottom][i]=c;\\n                    c++;\\n                }\\n                bottom--;\\n                for(int i=bottom;i>=top;i--){\\n                   m[i][left]=c;\\n                    c++; \\n                }\\n                left++;\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176492,
                "title": "59-spiral-matrix-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create a 2D list matrix with size n x n filled with zeros.\\n2. Create a list direction that contains the possible direction of movement.\\n3. Initialize the variables curr_dir to keep track of the current direction, x and y for the current position.\\n4. Use a for loop to fill the matrix with elements from 1 to n * n.\\n5. On each iteration, calculate the next position next_x and next_y by adding the current position with the corresponding direction.\\n6. If the next position is within the bounds of the matrix and the value at the next position is 0, update the current position to the next position.\\n7. If the next position is not valid, change the direction by using curr_dir = (curr_dir + 1) % 4.\\n8. Repeat steps 5-7 until all elements from 1 to n * n are filled in the matrix.\\n9. Return the filled matrix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        direction = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        curr_dir = 0\\n        x, y = 0, 0\\n        for num in range(1, n * n + 1):\\n            matrix[x][y] = num\\n            next_x, next_y = x + direction[curr_dir][0], y + direction[curr_dir][1]\\n            if 0 <= next_x < n and 0 <= next_y < n and matrix[next_x][next_y] == 0:\\n                x, y = next_x, next_y\\n            else:\\n                curr_dir = (curr_dir + 1) % 4\\n                x, y = x + direction[curr_dir][0], y + direction[curr_dir][1]\\n        return matrix\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        direction = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        curr_dir = 0\\n        x, y = 0, 0\\n        for num in range(1, n * n + 1):\\n            matrix[x][y] = num\\n            next_x, next_y = x + direction[curr_dir][0], y + direction[curr_dir][1]\\n            if 0 <= next_x < n and 0 <= next_y < n and matrix[next_x][next_y] == 0:\\n                x, y = next_x, next_y\\n            else:\\n                curr_dir = (curr_dir + 1) % 4\\n                x, y = x + direction[curr_dir][0], y + direction[curr_dir][1]\\n        return matrix\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117990,
                "title": "c-python3-solution-clean-concise",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n^2)$$\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> M(n, vector<int>(n));\\n        int val = 1;\\n        for(int i = 0; i < (n + 1) / 2; i++) {\\n            for(int j = i; j < n - i; j++) M[i][j] = val++;\\n            for(int j = i + 1; j < n - i; j++) M[j][n - i - 1] = val++;\\n            for(int j = n - i - 2; j >= i; j--) M[n - i - 1][j] = val++;\\n            for(int j = n - i - 2; j > i; j--) M[j][i] = val++;\\n        }\\n        return M;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def generateMatrix(self, n):\\n        M = [[0] * n for _ in range(n)]\\n        val = 0\\n        for i in range((n + 1) // 2):\\n            for j in range(i, n - i): M[i][j] = (val := val + 1)\\n            for j in range(i + 1, n - i): M[j][n - i - 1] = (val := val + 1)\\n            for j in range(n - i - 2, i - 1, -1): M[n - i - 1][j] = (val := val + 1)\\n            for j in range(n - i - 2, i, -1): M[j][i] = (val := val + 1)\\n        return M\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> M(n, vector<int>(n));\\n        int val = 1;\\n        for(int i = 0; i < (n + 1) / 2; i++) {\\n            for(int j = i; j < n - i; j++) M[i][j] = val++;\\n            for(int j = i + 1; j < n - i; j++) M[j][n - i - 1] = val++;\\n            for(int j = n - i - 2; j >= i; j--) M[n - i - 1][j] = val++;\\n            for(int j = n - i - 2; j > i; j--) M[j][i] = val++;\\n        }\\n        return M;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def generateMatrix(self, n):\\n        M = [[0] * n for _ in range(n)]\\n        val = 0\\n        for i in range((n + 1) // 2):\\n            for j in range(i, n - i): M[i][j] = (val := val + 1)\\n            for j in range(i + 1, n - i): M[j][n - i - 1] = (val := val + 1)\\n            for j in range(n - i - 2, i - 1, -1): M[n - i - 1][j] = (val := val + 1)\\n            for j in range(n - i - 2, i, -1): M[j][i] = (val := val + 1)\\n        return M\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072223,
                "title": "0-ms-beats-100-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] arr = new int[n][n];\\n        int counter = 1 , up = 0 , left = 0 , right = n-1 , \\n            down = n-1 ;\\n        while(counter <= n*n){\\n            for(int i = left ; i<= right ; i++){\\n                arr[up][i] = counter++;\\n            }\\n            up++;\\n            for(int i = up ; i<=down  ; i++){\\n                arr[i][right] = counter++;\\n            }\\n            right--;\\n            for(int i = right ; i>= left ; i--){\\n                arr[down][i] = counter++;\\n            }\\n            down--;\\n            for(int i = down ; i>= up ; i--){\\n                arr[i][left] = counter++;\\n            }\\n            left++;\\n\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] arr = new int[n][n];\\n        int counter = 1 , up = 0 , left = 0 , right = n-1 , \\n            down = n-1 ;\\n        while(counter <= n*n){\\n            for(int i = left ; i<= right ; i++){\\n                arr[up][i] = counter++;\\n            }\\n            up++;\\n            for(int i = up ; i<=down  ; i++){\\n                arr[i][right] = counter++;\\n            }\\n            right--;\\n            for(int i = right ; i>= left ; i--){\\n                arr[down][i] = counter++;\\n            }\\n            down--;\\n            for(int i = down ; i>= up ; i--){\\n                arr[i][left] = counter++;\\n            }\\n            left++;\\n\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679788,
                "title": "java-easy-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n      int[][] result = new int[n][n];\\n        int k = 0;\\n        int rowStart = 0, rowEnd = n;\\n        int colStart = 0, colEnd = n;\\n        while (k < n * n) {\\n\\n            // right\\n            for(int i = rowStart; k < n * n && i < colEnd; i ++) {\\n                result[rowStart][i] = ++ k;\\n            }\\n            rowStart ++;\\n\\n            // down\\n            for(int i = rowStart; k < n * n && i < rowEnd; i ++) {\\n                result[i][colEnd - 1] = ++ k;\\n            }\\n            colEnd --;\\n\\n            // left\\n            for(int i = colEnd - 1; k < n * n && i >= colStart; i --) {\\n                result[rowEnd - 1][i] = ++ k;\\n            }\\n            rowEnd --;\\n\\n            // up\\n            for(int i = rowEnd - 1; k < n * n && i >= rowStart; i --) {\\n                result[i][colStart] = ++ k;\\n            }\\n            colStart ++;\\n\\n        }\\n        return result;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n      int[][] result = new int[n][n];\\n        int k = 0;\\n        int rowStart = 0, rowEnd = n;\\n        int colStart = 0, colEnd = n;\\n        while (k < n * n) {\\n\\n            // right\\n            for(int i = rowStart; k < n * n && i < colEnd; i ++) {\\n                result[rowStart][i] = ++ k;\\n            }\\n            rowStart ++;\\n\\n            // down\\n            for(int i = rowStart; k < n * n && i < rowEnd; i ++) {\\n                result[i][colEnd - 1] = ++ k;\\n            }\\n            colEnd --;\\n\\n            // left\\n            for(int i = colEnd - 1; k < n * n && i >= colStart; i --) {\\n                result[rowEnd - 1][i] = ++ k;\\n            }\\n            rowEnd --;\\n\\n            // up\\n            for(int i = rowEnd - 1; k < n * n && i >= rowStart; i --) {\\n                result[i][colStart] = ++ k;\\n            }\\n            colStart ++;\\n\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664720,
                "title": "0ms-c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n));\\n        int k = 1,rs = 0,cs = 0,ce = n-1,re = n-1,i;\\n        while(rs<=re && cs <= ce){\\n            for(i = cs; i<= ce; i++){\\n                ans[rs][i] = k++;\\n            }\\n            rs++;\\n            for(i = rs; i<= re; i++){\\n                ans[i][ce] = k++;\\n            }\\n            ce--;\\n            for(i = ce; i>= cs; i--){\\n                ans[re][i] = k++;\\n            }\\n            re--;\\n            for(i = re; i>=rs; i--){\\n                ans[i][cs] = k++;\\n            }\\n            cs++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n));\\n        int k = 1,rs = 0,cs = 0,ce = n-1,re = n-1,i;\\n        while(rs<=re && cs <= ce){\\n            for(i = cs; i<= ce; i++){\\n                ans[rs][i] = k++;\\n            }\\n            rs++;\\n            for(i = rs; i<= re; i++){\\n                ans[i][ce] = k++;\\n            }\\n            ce--;\\n            for(i = ce; i>= cs; i--){\\n                ans[re][i] = k++;\\n            }\\n            re--;\\n            for(i = re; i>=rs; i--){\\n                ans[i][cs] = k++;\\n            }\\n            cs++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162072,
                "title": "fastest-explained-easy-simple-clean-code-0ms",
                "content": "**Total number of iteration** through the matrix to get all the elements in spiral order is : **\"K= (n*2)-1 \"**\\nwhere **n : number of rows** (or *number of colums* as the matrix is **n *x* n**)\\n\\nThis formula can be understood by taking example of 3x3 *(5 iterations)*, 4x4 *(7 iterations)* , 5x5 *(9 iterations)* .... matrix (just to get the idea).\\nWe are basically iterating in the four directions through the matrix.\\ni.e. \\n*1)left to right in a particular row (i.e. iterating through columns in a particular row)\\n2)up to bottom in the particular column (i.e. iterating through rows in a particular column)\\n3)right to left in the particular row (i.e. iterating through columns in a particular row)\\n4)bottom to up in the particular column (i.e. iterating through rows in a particular column)*\\n\\n```\\n\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int c=0,r=1,k=(n*2)-1;\\n        while (c<k){\\n            for (int j = c; j < n; ++j) {\\n                matrix[c][j]=r;\\n                ++r;\\n            }\\n            for (int i = c +1; i <n; ++i) {\\n                matrix[i][n-1]=r;\\n                ++r;\\n            }\\n            for (int j = n-2; j >= c; --j) {\\n                matrix[n-1][j]=r;\\n                ++r;\\n            }\\n            for (int i = n-2; i > c; --i) {\\n                matrix[i][c]=r;\\n                ++r;\\n            }\\n            --n;\\n            ++c;\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int c=0,r=1,k=(n*2)-1;\\n        while (c<k){\\n            for (int j = c; j < n; ++j) {\\n                matrix[c][j]=r;\\n                ++r;\\n            }\\n            for (int i = c +1; i <n; ++i) {\\n                matrix[i][n-1]=r;\\n                ++r;\\n            }\\n            for (int j = n-2; j >= c; --j) {\\n                matrix[n-1][j]=r;\\n                ++r;\\n            }\\n            for (int i = n-2; i > c; --i) {\\n                matrix[i][c]=r;\\n                ++r;\\n            }\\n            --n;\\n            ++c;\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033042,
                "title": "c-simple-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int k = 0;                   //number of steps\\n        vector<vector<int>> res;     //to store the matrix\\n        \\n        //maybe you can find some better way to initialize the matrix array, but I decided to fill it with zeros))\\n        for(int i = 0; i < n; i++){\\n            vector<int> v;\\n            for(int j = 0; j < n; j++){\\n                v.push_back(0);\\n            }\\n            res.push_back(v);\\n        }\\n        \\n        //these variables will be used as pointers\\n        int r = n - 1;      //right bound \\n        int l = 0;          //left bound\\n        int u = 0;          //up bound\\n        int d = n - 1;      //down bound\\n        int i = 0;          //vertical position\\n        int j = 0;          //horizontal position\\n        \\n        while(k++ < n * n){       //we should make n*n steps to fill all the matrix\\n            res[i][j] = k;\\n            \\n            if(i == u && j < r) {    //move right\\n                j++;\\n                if(j == r) u++;      //if the bound is reached, shift the bound\\n            }\\n            else if(i < d && j == r) {       //move down\\n                i++;\\n                if(i == d) r--;\\n            }\\n            else if(i == d && j > l) {     //move left\\n                j--;\\n                if(j == l) d--;\\n            }\\n            else if(i > u && j == l) {     //move right\\n                i--;\\n                if(i == u) l++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int k = 0;                   //number of steps\\n        vector<vector<int>> res;     //to store the matrix\\n        \\n        //maybe you can find some better way to initialize the matrix array, but I decided to fill it with zeros))\\n        for(int i = 0; i < n; i++){\\n            vector<int> v;\\n            for(int j = 0; j < n; j++){\\n                v.push_back(0);\\n            }\\n            res.push_back(v);\\n        }\\n        \\n        //these variables will be used as pointers\\n        int r = n - 1;      //right bound \\n        int l = 0;          //left bound\\n        int u = 0;          //up bound\\n        int d = n - 1;      //down bound\\n        int i = 0;          //vertical position\\n        int j = 0;          //horizontal position\\n        \\n        while(k++ < n * n){       //we should make n*n steps to fill all the matrix\\n            res[i][j] = k;\\n            \\n            if(i == u && j < r) {    //move right\\n                j++;\\n                if(j == r) u++;      //if the bound is reached, shift the bound\\n            }\\n            else if(i < d && j == r) {       //move down\\n                i++;\\n                if(i == d) r--;\\n            }\\n            else if(i == d && j > l) {     //move left\\n                j--;\\n                if(j == l) d--;\\n            }\\n            else if(i > u && j == l) {     //move right\\n                i--;\\n                if(i == u) l++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943878,
                "title": "simple-solution-with-only-one-for-loop",
                "content": "```\\n\\npublic class Solution {\\n    public int[][] GenerateMatrix(int n) \\n    {\\n        int[][] matrix = new int[n][];\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            matrix[i] = Enumerable.Repeat(0, n).ToArray();\\n        }\\n        \\n        int[] directionX = new int[] { 0, 1, 0, -1 };\\n        int[] directionY = new int[] { 1, 0, -1, 0 };\\n        int x = 0;\\n        int y = 0;\\n        int direction = 0;\\n        \\n        for (int i = 1; i <= n * n; i++)\\n        {\\n            matrix[x][y] = i;\\n            \\n            //do not need this on the last step\\n            if (i != n * n)\\n            {\\n                x += directionX[direction];\\n                y += directionY[direction];\\n\\n                //if we are out of bounds or on the already visited cell then change the direction\\n                if (x < 0 || y < 0 || x > n-1 || y > n-1 || matrix[x][y] != 0)\\n                {\\n                    x -= directionX[direction];\\n                    y -= directionY[direction];\\n\\n                    direction = (direction + 1) % 4;\\n\\n                    x += directionX[direction];\\n                    y += directionY[direction];\\n                }\\n            }\\n        }\\n        \\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public int[][] GenerateMatrix(int n) \\n    {\\n        int[][] matrix = new int[n][];\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            matrix[i] = Enumerable.Repeat(0, n).ToArray();\\n        }\\n        \\n        int[] directionX = new int[] { 0, 1, 0, -1 };\\n        int[] directionY = new int[] { 1, 0, -1, 0 };\\n        int x = 0;\\n        int y = 0;\\n        int direction = 0;\\n        \\n        for (int i = 1; i <= n * n; i++)\\n        {\\n            matrix[x][y] = i;\\n            \\n            //do not need this on the last step\\n            if (i != n * n)\\n            {\\n                x += directionX[direction];\\n                y += directionY[direction];\\n\\n                //if we are out of bounds or on the already visited cell then change the direction\\n                if (x < 0 || y < 0 || x > n-1 || y > n-1 || matrix[x][y] != 0)\\n                {\\n                    x -= directionX[direction];\\n                    y -= directionY[direction];\\n\\n                    direction = (direction + 1) % 4;\\n\\n                    x += directionX[direction];\\n                    y += directionY[direction];\\n                }\\n            }\\n        }\\n        \\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942034,
                "title": "java-100-solution",
                "content": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n]; \\n        \\n        int ele = 1; // the element to store in the matrix\\n        \\n        int[][] dir = new int[][]{{0,1},{1,0},{0,-1},{-1,0}}; //direction in which we traverse the matrix\\n        \\n        int flag = 0; // will take the values 0,1,2,3 to change direction according to increment values in dir array\\n        \\n        int row = 0, col = 0; //current row and column\\n        \\n        int rowinc = dir[flag % 4][0], colinc = dir[flag % 4][1]; //row increment, column increment\\n        \\n        while(ele <= Math.pow(n,2)){\\n            matrix[row][col] = ele;\\n            \\n            if(row + rowinc >= n || row + rowinc < 0 || col + colinc >= n || col + colinc < 0 || matrix[row + rowinc][col + colinc] != 0){\\n                //change direction\\n                \\n                flag++;\\n                rowinc = dir[flag % 4][0];\\n                colinc = dir[flag % 4][1];\\n            }\\n            \\n            ele++;\\n            row += rowinc;\\n            col += colinc;\\n        }\\n        \\n        return matrix;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n]; \\n        \\n        int ele = 1; // the element to store in the matrix\\n        \\n        int[][] dir = new int[][]{{0,1}",
                "codeTag": "Java"
            },
            {
                "id": 1942019,
                "title": "java-0ms-100-faster-simple-logic",
                "content": "```class Solution {\\n    public int[][] generateMatrix(int n) {\\n        int result[][]=new int[n][n];\\n        if(n==1){\\n            result[0][0]=1;\\n            return result;\\n        }\\n        int rowBegin=0;\\n        int rowEnd=n-1;\\n        int colBegin=0;\\n        int colEnd=n-1;\\n        int k=1;\\n        \\n        while(colBegin<=colEnd && rowBegin<=rowEnd){\\n            for(int i=colBegin;i<=colEnd;i++){\\n                result[rowBegin][i]=k++;\\n            }\\n            rowBegin++;\\n            for(int i=rowBegin;i<=rowEnd;i++){\\n                result[i][colEnd]=k++;\\n            }\\n            colEnd--;\\n            if(rowBegin<=rowEnd){\\n                for(int i=colEnd;i>=colBegin;i--){\\n                    result[rowEnd][i]=k++;\\n                }\\n            }\\n            rowEnd--;\\n            if(colBegin<=colEnd){\\n                for(int i=rowEnd;i>=rowBegin;i--){\\n                    result[i][colBegin]=k++;\\n                }\\n            }\\n            colBegin++;\\n            \\n        }\\n            \\n        \\n        \\n        return result;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[][] generateMatrix(int n) {\\n        int result[][]=new int[n][n];\\n        if(n==1){\\n            result[0][0]=1;\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1941759,
                "title": "python-3-intuitive-6-lines-solution",
                "content": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:       \\n        A, S, D, X, Y =[[0]*n for _ in range(n)], 0, [[1,0],[0,1],[-1,0],[0,-1]], 0, 0\\n\\t\\t# - A:  Answer\\n\\t\\t# - S:  Status. 0: right, 1: up, 2: left, 3: down\\n\\t\\t# - D:  Direction list\\n\\t\\t# - X,Y: location\\n        valid = lambda x,y: 0<=x<n and 0<=y<n and A[y][x] == 0\\n        for i  in range(1,n*n+1):\\n            A[Y][X], S = i, (S + (not valid(X+D[S][0],Y+D[S][1]))*1) % 4\\n            X,Y = X+D[S][0], Y+D[S][1]\\n        return A\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:       \\n        A, S, D, X, Y =[[0]*n for _ in range(n)], 0, [[1,0],[0,1],[-1,0],[0,-1]], 0, 0\\n\\t\\t# - A:  Answer\\n\\t\\t# - S:  Status. 0: right, 1: up, 2: left, 3: down\\n\\t\\t# - D:  Direction list\\n\\t\\t# - X,Y: location\\n        valid = lambda x,y: 0<=x<n and 0<=y<n and A[y][x] == 0\\n        for i  in range(1,n*n+1):\\n            A[Y][X], S = i, (S + (not valid(X+D[S][0],Y+D[S][1]))*1) % 4\\n            X,Y = X+D[S][0], Y+D[S][1]\\n        return A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941530,
                "title": "c-0ms-100-faster-easy-and-simple",
                "content": "Here, we just have to understand the trend of matrix.\\nLike how we are filling the matrix.\\nfirst we are doing first column to last column,\\nthen first row +1 to last row then again last column to  first column and same with last row to first row...this way we can approach this question.\\n\\nyou will have more understanding after viewing the code.\\n\\nhope you like it.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> v(n,vector<int>(n,0));\\n        if(n==0)\\n        {\\n            return v;\\n        }\\n        int firstRow=0;\\n        int firstColumn=0;\\n        int lastRow=n-1;\\n        int lastColumn=n-1;\\n        int i=1;\\n        int num=n*n;\\n       \\n        while(firstRow<=lastRow && firstColumn<=lastColumn)\\n        {\\n            for(int j=firstColumn;j<=lastColumn;j++)\\n            { \\n                v[firstRow][j]=i;\\n                i++;\\n            }\\n            if(i>num)break;\\n            for(int j=firstRow+1;j<=lastRow;j++)\\n            {\\n                v[j][lastColumn]=i;\\n                i++;\\n            }\\n            if(i>num)break;\\n            for(int j=lastColumn-1;j>=firstColumn;j--)\\n            { \\n                v[lastRow][j]=i;\\n                i++;  \\n            }\\n            if(i>num)break;   \\n            for(int j=lastRow-1;j>firstRow;j--)\\n            {\\n                v[j][firstColumn]=i;\\n                i++;  \\n            }\\n            if(i>num)break;\\n            firstRow++;\\n            firstColumn++;\\n            lastRow--;\\n            lastColumn--;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> v(n,vector<int>(n,0));\\n        if(n==0)\\n        {\\n            return v;\\n        }\\n        int firstRow=0;\\n        int firstColumn=0;\\n        int lastRow=n-1;\\n        int lastColumn=n-1;\\n        int i=1;\\n        int num=n*n;\\n       \\n        while(firstRow<=lastRow && firstColumn<=lastColumn)\\n        {\\n            for(int j=firstColumn;j<=lastColumn;j++)\\n            { \\n                v[firstRow][j]=i;\\n                i++;\\n            }\\n            if(i>num)break;\\n            for(int j=firstRow+1;j<=lastRow;j++)\\n            {\\n                v[j][lastColumn]=i;\\n                i++;\\n            }\\n            if(i>num)break;\\n            for(int j=lastColumn-1;j>=firstColumn;j--)\\n            { \\n                v[lastRow][j]=i;\\n                i++;  \\n            }\\n            if(i>num)break;   \\n            for(int j=lastRow-1;j>firstRow;j--)\\n            {\\n                v[j][firstColumn]=i;\\n                i++;  \\n            }\\n            if(i>num)break;\\n            firstRow++;\\n            firstColumn++;\\n            lastRow--;\\n            lastColumn--;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941518,
                "title": "c-easy-to-understand-with-comments",
                "content": "```\\npublic class Solution \\n{\\n    public int[][] GenerateMatrix(int n) \\n    {\\n        int[][] mat = new int[n][];\\n        for (int i = 0; i < n; i++)\\n            mat[i] = new int[n];\\n        \\n        (int top, int bottom, int left, int right) = (0, n - 1, 0, n - 1);\\n        \\n        int val = 1;\\n        while (true) \\n        {\\n            //left to right, colms are changing\\n            for (int i = left; i <= right; i++)\\n                mat[top][i] = val++;\\n            \\n            top++; //row covered, bring it down\\n           \\n            if (top > bottom)\\n                break;\\n            \\n            //top to bottom, rows are changing\\n            for (int i = top; i <= bottom; i++)\\n                mat[i][right] = val++;\\n\\n            right--; //colm covered, shrink the column window\\n            \\n            if (left > right)\\n                break;\\n            \\n            //right to left, colms are changing\\n            for (int i = right; i >= left; i--)\\n                mat[bottom][i] = val++;\\n            \\n            bottom--; //row covered, shrink the row window\\n            \\n            //bottom to top, rows are changing\\n            for (int i = bottom; i >= top; i--)\\n                mat[i][left] = val++;\\n            \\n            left++; //col covered, shrink the colm window\\n            \\n        }\\n        \\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int[][] GenerateMatrix(int n) \\n    {\\n        int[][] mat = new int[n][];\\n        for (int i = 0; i < n; i++)\\n            mat[i] = new int[n];\\n        \\n        (int top, int bottom, int left, int right) = (0, n - 1, 0, n - 1);\\n        \\n        int val = 1;\\n        while (true) \\n        {\\n            //left to right, colms are changing\\n            for (int i = left; i <= right; i++)\\n                mat[top][i] = val++;\\n            \\n            top++; //row covered, bring it down\\n           \\n            if (top > bottom)\\n                break;\\n            \\n            //top to bottom, rows are changing\\n            for (int i = top; i <= bottom; i++)\\n                mat[i][right] = val++;\\n\\n            right--; //colm covered, shrink the column window\\n            \\n            if (left > right)\\n                break;\\n            \\n            //right to left, colms are changing\\n            for (int i = right; i >= left; i--)\\n                mat[bottom][i] = val++;\\n            \\n            bottom--; //row covered, shrink the row window\\n            \\n            //bottom to top, rows are changing\\n            for (int i = bottom; i >= top; i--)\\n                mat[i][left] = val++;\\n            \\n            left++; //col covered, shrink the colm window\\n            \\n        }\\n        \\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877702,
                "title": "python-easy-simulation-solution",
                "content": "### **Spiral Matrix II**\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:    \\n        r, c = 0, 0\\n        dr, dc = 0, 1\\n        res = [[0] * n for _ in range(n)]\\n        \\n        for i in range(1, n*n + 1):\\n            res[r][c] = i   \\n            \\n            # at most one right turn\\n            tmpR, tmpC = r + dr, c + dc\\n            if (\\n                tmpR < 0 or tmpR >= n or\\n                tmpC < 0 or tmpC >= n or \\n                res[tmpR][tmpC] != 0\\n            ):\\n                dr, dc = dc, -dr # 90 degree clockwise\\n            \\n            r, c = r + dr, c + dc\\n         \\n        return res\\n```\\nMy Solutions of Related Problems:\\n* 54. Spiral Matrix: [Python, easy simulation solution]( https://leetcode.com/problems/spiral-matrix/discuss/1875750/python-lazy-simulation)\\n* 885. Spiral Matrix III: [Python, easy simulation solution with explanation.](https://leetcode.com/problems/spiral-matrix-iii/discuss/1877691/python-easy-solution-with-explanation)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:    \\n        r, c = 0, 0\\n        dr, dc = 0, 1\\n        res = [[0] * n for _ in range(n)]\\n        \\n        for i in range(1, n*n + 1):\\n            res[r][c] = i   \\n            \\n            # at most one right turn\\n            tmpR, tmpC = r + dr, c + dc\\n            if (\\n                tmpR < 0 or tmpR >= n or\\n                tmpC < 0 or tmpC >= n or \\n                res[tmpR][tmpC] != 0\\n            ):\\n                dr, dc = dc, -dr # 90 degree clockwise\\n            \\n            r, c = r + dr, c + dc\\n         \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1862754,
                "title": "java-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int top=0;\\n        int bottom=n-1;\\n        int left=0;\\n        int right=n-1;\\n        int count=1;\\n        int matrix[][]=new int[n][n];\\n        while(left<=right){\\n            for(int i=left;i<=right;i++){\\n                matrix[top][i]=count++;\\n            }\\n            top++;\\n            \\n            for(int i=top;i<=bottom;i++){\\n                matrix[i][right]=count++;\\n            }\\n            right--;\\n            \\n            \\n            for(int i=right;i>=left;i--){\\n                matrix[bottom][i]=count++;\\n            }\\n                bottom--;\\n            \\n            for(int i=bottom;i>=top;i--){\\n                matrix[i][left]=count++;\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int top=0;\\n        int bottom=n-1;\\n        int left=0;\\n        int right=n-1;\\n        int count=1;\\n        int matrix[][]=new int[n][n];\\n        while(left<=right){\\n            for(int i=left;i<=right;i++){\\n                matrix[top][i]=count++;\\n            }\\n            top++;\\n            \\n            for(int i=top;i<=bottom;i++){\\n                matrix[i][right]=count++;\\n            }\\n            right--;\\n            \\n            \\n            for(int i=right;i>=left;i--){\\n                matrix[bottom][i]=count++;\\n            }\\n                bottom--;\\n            \\n            for(int i=bottom;i>=top;i--){\\n                matrix[i][left]=count++;\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1810692,
                "title": "easy-understanding-java-solution",
                "content": "```\\nprivate int[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\tprivate int direction = 0;\\n\\tpublic int[][] generateMatrix(int n) {\\n\\t\\tint[][] res = new int[n][n];\\n\\t\\tres[0][0] = 1;\\n\\t\\tint row = 0;\\n\\t\\tint col = 0;\\n\\t\\tint count = 2;\\n\\t\\twhile (count <= n * n) {\\n\\t\\t\\tif (canGo(row + dirs[direction][0], col + dirs[direction][1],res)){\\n\\t\\t\\t\\trow += dirs[direction][0];\\n\\t\\t\\t\\tcol += dirs[direction][1];\\n\\t\\t\\t\\tres[row][col] = count;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdirection++;\\n\\t\\t\\t\\tdirection = direction % 4;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\tprivate boolean canGo(int i, int j, int[][] res) {\\n\\t\\tif (i > res.length - 1 || i < 0 || j > res[0].length - 1 || j < 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif(res[i][j] != 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprivate int[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\tprivate int direction = 0;\\n\\tpublic int[][] generateMatrix(int n) {\\n\\t\\tint[][] res = new int[n][n];\\n\\t\\tres[0][0] = 1;\\n\\t\\tint row = 0;\\n\\t\\tint col = 0;\\n\\t\\tint count = 2;\\n\\t\\twhile (count <= n * n) {\\n\\t\\t\\tif (canGo(row + dirs[direction][0], col + dirs[direction][1],res)){\\n\\t\\t\\t\\trow += dirs[direction][0];\\n\\t\\t\\t\\tcol += dirs[direction][1];\\n\\t\\t\\t\\tres[row][col] = count;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdirection++;\\n\\t\\t\\t\\tdirection = direction % 4;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\tprivate boolean canGo(int i, int j, int[][] res) {\\n\\t\\tif (i > res.length - 1 || i < 0 || j > res[0].length - 1 || j < 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif(res[i][j] != 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1657189,
                "title": "c-100-faster-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) \\n    {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int num = 1,r1 =0,r2 = n-1,c1 =0,c2 = n-1;\\n        while(r1<=r2 && c1<=c2)\\n        {\\n            //For first row\\n            for(int i = c1;i<=c2;i++)\\n            {\\n                ans[r1][i] = num++;\\n            }\\n            //For last column\\n            for(int j =r1+1;j<=r2;j++)\\n            {\\n                ans[j][c2] = num++;\\n            }\\n            //For last row\\n            if(r1 != r2)\\n            {\\n                for(int i = c2-1;i>=c1;i--)\\n                {\\n                    ans[r2][i] = num++;\\n                }\\n            }\\n            //For first column\\n            if(c1 != c2)\\n            {\\n                for(int i = r2-1;i>r1;i--)\\n                {\\n                    ans[i][c1] = num++;\\n                }\\n            }\\n            r1++;\\n            r2--;\\n            c1++;\\n            c2--;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) \\n    {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int num = 1,r1 =0,r2 = n-1,c1 =0,c2 = n-1;\\n        while(r1<=r2 && c1<=c2)\\n        {\\n            //For first row\\n            for(int i = c1;i<=c2;i++)\\n            {\\n                ans[r1][i] = num++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1620082,
                "title": "99-faster-python-code",
                "content": "Feel free to ask any question !\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        ans = [[0]*n for i in range(n)]\\n        i,j = 0, 0\\n        dire = [0,1,0,-1,0]\\n        po = 0\\n        for a in range(1,n*n+1):\\n            ans[i][j] = a\\n            ni,nj = i+dire[po],j+dire[po+1]\\n            if (not 0<=ni<n) or (not 0<=nj<n) or ans[ni][nj]!=0:\\n                po+=1\\n                po%=4\\n                ni,nj = i+dire[po],j+dire[po+1]\\n            i,j = ni,nj\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        ans = [[0]*n for i in range(n)]\\n        i,j = 0, 0\\n        dire = [0,1,0,-1,0]\\n        po = 0\\n        for a in range(1,n*n+1):\\n            ans[i][j] = a\\n            ni,nj = i+dire[po],j+dire[po+1]\\n            if (not 0<=ni<n) or (not 0<=nj<n) or ans[ni][nj]!=0:\\n                po+=1\\n                po%=4\\n                ni,nj = i+dire[po],j+dire[po+1]\\n            i,j = ni,nj\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424885,
                "title": "0-ms-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int p=1;\\n        int i=0,j=0,r=n,c=n;\\n        vector<vector<int>> v(n,vector<int>(n));\\n        while(i<r && j<c){\\n            for(int k=j;k<c;k++) v[i][k]=p++;\\n            i++;\\n            for(int k=i;k<r;k++) v[k][c-1]=p++;\\n            c--;\\n            if(j<c){\\n                for(int k=c-1;k>=j;k--) v[r-1][k]=p++;\\n                r--;\\n            }\\n            if(i<r){\\n                for(int k=r-1;k>=i;k--) v[k][j]=p++;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int p=1;\\n        int i=0,j=0,r=n,c=n;\\n        vector<vector<int>> v(n,vector<int>(n));\\n        while(i<r && j<c){\\n            for(int k=j;k<c;k++) v[i][k]=p++;\\n            i++;\\n            for(int k=i;k<r;k++) v[k][c-1]=p++;\\n            c--;\\n            if(j<c){\\n                for(int k=c-1;k>=j;k--) v[r-1][k]=p++;\\n                r--;\\n            }\\n            if(i<r){\\n                for(int k=r-1;k>=i;k--) v[k][j]=p++;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137794,
                "title": "java-explained-with-images-easy-intuitive-solution",
                "content": "We just need to iterate over the outer boundaries and do it for every inner squares \\n![image](https://assets.leetcode.com/users/images/abecb707-c10a-4c21-9f1f-626793445486_1617302946.2052238.jpeg)\\n\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        \\n        int k=0;int[][] matrix = new int[n][n];int val=1;\\n        while( k <= n/2 )\\n        {\\n            for( int j = k; j < n-k; j++)\\n               matrix[k][j] = val++;\\n        \\n            for( int  i = k+1; i < n-k-1; i++ )\\n                matrix[i][n-k-1] = val++;\\n        \\n            for( int  j = n-k-1; j > k; j-- )\\n                matrix[n-k-1][j] = val++;\\n        \\n            for( int  i = n-k-1; i > k; i-- )\\n               matrix[i][k] = val++;\\n        k++;\\n        }        \\n     return matrix;   \\n    }\\n}\\nComplexity is O(n2) as we are iterating over all the cells in the matrix.\\nPlease upvote if you like the explanation.\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] generateMatrix(int n) {\\n        \\n        int k=0;int[][] matrix = new int[n][n];int val=1;\\n        while( k <= n/2 )\\n        {\\n            for( int j = k; j < n-k; j++)\\n               matrix[k][j] = val++;\\n        \\n            for( int  i = k+1; i < n-k-1; i++ )\\n                matrix[i][n-k-1] = val++;\\n        \\n            for( int  j = n-k-1; j > k; j-- )\\n                matrix[n-k-1][j] = val++;\\n        \\n            for( int  i = n-k-1; i > k; i-- )\\n               matrix[i][k] = val++;\\n        k++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1106288,
                "title": "100-fast-simple-easy-understanding-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int left=0,right=n-1,top=0,bottom=n-1,c=1;\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n        while(1){\\n            if(left>right){\\n                break;\\n            }\\n            for(int i=left;i<=right;i++){\\n                mat[top][i]=c;\\n                c++;\\n            }\\n            top++;\\n            if(top>bottom){\\n                break;\\n            }\\n            for(int i=top;i<=bottom;i++){\\n                mat[i][right]=c;\\n                c++;\\n            }\\n            right--;\\n            if(left>right){\\n                break;\\n            }\\n            for(int i=right;i>=left;i--){\\n                mat[bottom][i]=c;\\n                c++;\\n            }\\n            bottom--;\\n            if(top>bottom){\\n                break;\\n            }\\n            for(int i=bottom;i>=top;i--){\\n                mat[i][left]=c;\\n                c++;\\n            }\\n            left++;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int left=0,right=n-1,top=0,bottom=n-1,c=1;\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n        while(1){\\n            if(left>right){\\n                break;\\n            }\\n            for(int i=left;i<=right;i++){\\n                mat[top][i]=c;\\n                c++;\\n            }\\n            top++;\\n            if(top>bottom){\\n                break;\\n            }\\n            for(int i=top;i<=bottom;i++){\\n                mat[i][right]=c;\\n                c++;\\n            }\\n            right--;\\n            if(left>right){\\n                break;\\n            }\\n            for(int i=right;i>=left;i--){\\n                mat[bottom][i]=c;\\n                c++;\\n            }\\n            bottom--;\\n            if(top>bottom){\\n                break;\\n            }\\n            for(int i=bottom;i>=top;i--){\\n                mat[i][left]=c;\\n                c++;\\n            }\\n            left++;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081014,
                "title": "spiral-matrix-ii-js-solution-beats-100",
                "content": "```\\nvar generateMatrix = function (n) {\\n    let dr = [0, 1, 0, -1],\\n        dc = [1, 0, -1, 0],\\n        dir = 0,\\n        board = [],\\n        row = 0,\\n        col = 0;\\n    for (let i = 0; i < n; i++) {\\n        board[i] = Array(n).fill(0)\\n    }\\n    for (i = 1; i <= n * n; i++) {\\n        board[row][col] = i\\n        let nRow = row + dr[dir % 4],\\n            nCol = col + dc[dir % 4]\\n        if (nRow >= 0 && nRow < n && nCol >= 0 && nCol < n && board[nRow] && board[nRow][nCol] == 0) {\\n            row = nRow\\n            col = nCol\\n        } else {\\n            dir++\\n            row += dr[dir % 4]\\n            col += dc[dir % 4]\\n        }\\n    }\\n    return board\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generateMatrix = function (n) {\\n    let dr = [0, 1, 0, -1],\\n        dc = [1, 0, -1, 0],\\n        dir = 0,\\n        board = [],\\n        row = 0,\\n        col = 0;\\n    for (let i = 0; i < n; i++) {\\n        board[i] = Array(n).fill(0)\\n    }\\n    for (i = 1; i <= n * n; i++) {\\n        board[row][col] = i\\n        let nRow = row + dr[dir % 4],\\n            nCol = col + dc[dir % 4]\\n        if (nRow >= 0 && nRow < n && nCol >= 0 && nCol < n && board[nRow] && board[nRow][nCol] == 0) {\\n            row = nRow\\n            col = nCol\\n        } else {\\n            dir++\\n            row += dr[dir % 4]\\n            col += dc[dir % 4]\\n        }\\n    }\\n    return board\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 963724,
                "title": "c-super-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isNextValid(int x, int y, int direction_x, int direction_y, int n, vector<vector<int>> mat) {\\n        if ((x + direction_x < 0) || (x + direction_x >= n))\\n            return false;\\n        if ((y + direction_y < 0) || (y + direction_y >= n))\\n            return false;\\n        if (mat[y + direction_y][x + direction_x] != 0)\\n            return false;\\n        return true;\\n    }\\n    \\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat(n, vector<int>(n));\\n        int direction_x = 1, direction_y = 0;\\n        int curr_x = 0, curr_y = 0;\\n        int count = 1;\\n        \\n        while (count <= pow(n, 2)) {\\n            mat[curr_y][curr_x] = count;\\n\\t\\t\\t\\n            // If next cell is out of range or filled already - change direction:\\n            if (!isNextValid(curr_x, curr_y, direction_x, direction_y, n, mat)) {\\n                swap(direction_x, direction_y);\\n                direction_x *= -1;\\n            }\\n            curr_x += direction_x;\\n            curr_y += direction_y;\\n            count++;\\n        }\\n        return mat;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isNextValid(int x, int y, int direction_x, int direction_y, int n, vector<vector<int>> mat) {\\n        if ((x + direction_x < 0) || (x + direction_x >= n))\\n            return false;\\n        if ((y + direction_y < 0) || (y + direction_y >= n))\\n            return false;\\n        if (mat[y + direction_y][x + direction_x] != 0)\\n            return false;\\n        return true;\\n    }\\n    \\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat(n, vector<int>(n));\\n        int direction_x = 1, direction_y = 0;\\n        int curr_x = 0, curr_y = 0;\\n        int count = 1;\\n        \\n        while (count <= pow(n, 2)) {\\n            mat[curr_y][curr_x] = count;\\n\\t\\t\\t\\n            // If next cell is out of range or filled already - change direction:\\n            if (!isNextValid(curr_x, curr_y, direction_x, direction_y, n, mat)) {\\n                swap(direction_x, direction_y);\\n                direction_x *= -1;\\n            }\\n            curr_x += direction_x;\\n            curr_y += direction_y;\\n            count++;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819134,
                "title": "python-easy-to-understand-fast-o-n-2-time-and-space-complexity-explained",
                "content": "Objective is to traverse matrix in spiral order and assign values in ascending order. \\n\\nSo we can use directions 0 being left to right, 1 being right to down, 2 being down to left and 3 being down to up left corner. \\n\\nTo keep track of how much data we have fiiled we will use 4 variables **sr** (starting row/rows filled), **sc**(starting column/columns filled), **er** (ending row till which rows are filled), **ec** (ending column till which column are filled)\\n\\nEach time we go from upper left to right we increment sr (starting row) count by 1 denoting that we have filled that row. \\nThen we go from right corner up to down and we decrement ec (ending column) by 1 denoting that we filled right most column. \\nThen we go from bottom right to bottom left and fill the bottom row and decrement er (ending row) count by 1 denoting we have filled that row.\\nAnd same with the left most column going from bottom to up and incrementing sc (starting column) count by 1.\\n\\nWe will use these 4 variables into our program to navigate each direction from sc to ec, sr to er, ec to sc, er to sr.\\n\\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\\n        sr, sc, er, ec = 0, 0, n-1, n-1\\n        \\n        direction = 0\\n        counter = 1\\n        \\n        while sr <= er and sc <= ec:\\n            if direction == 0:\\n                for i in range(sc, ec+1):\\n                    matrix[sr][i] = counter\\n                    counter+=1\\n                sr+=1\\n                direction = 1\\n            elif direction==1:\\n                for i in range(sr, er+1):\\n                    matrix[i][ec] = counter\\n                    counter+=1\\n                ec-=1\\n                direction = 2\\n            elif direction==2:\\n                for i in range(ec, sc-1, -1):\\n                    matrix[er][i] = counter\\n                    counter+=1\\n                er-=1\\n                direction = 3\\n            else:\\n                for i in range(er, sr-1, -1):\\n                    matrix[i][sc] = counter\\n                    counter+=1\\n                sc+=1\\n                direction = 0\\n        \\n        return matrix\\n```\\n\\nSimplifying the code further. If you notice properly, we donot really need direction variable at all. Reason being that we have a square matrix and hence sr, sc, er, ec all would meet at the center. If the matrix was not square we would not be able to do this simplification. We can eliminate whole if else structure.\\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\\n        sr, sc, er, ec = 0, 0, n-1, n-1\\n        counter = 1\\n        \\n        while sr <= er and sc <= ec:\\n\\n            for i in range(sc, ec+1):\\n                matrix[sr][i] = counter\\n                counter+=1\\n            sr+=1\\n\\n            for i in range(sr, er+1):\\n                matrix[i][ec] = counter\\n                counter+=1\\n            ec-=1\\n\\n            for i in range(ec, sc-1, -1):\\n                matrix[er][i] = counter\\n                counter+=1\\n            er-=1\\n\\n            for i in range(er, sr-1, -1):\\n                matrix[i][sc] = counter\\n                counter+=1\\n            sc+=1\\n        \\n        return matrix\\n```\\n\\nTime Complexity: O(N^2)\\nSpace Complexity: O(N^2)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\\n        sr, sc, er, ec = 0, 0, n-1, n-1\\n        \\n        direction = 0\\n        counter = 1\\n        \\n        while sr <= er and sc <= ec:\\n            if direction == 0:\\n                for i in range(sc, ec+1):\\n                    matrix[sr][i] = counter\\n                    counter+=1\\n                sr+=1\\n                direction = 1\\n            elif direction==1:\\n                for i in range(sr, er+1):\\n                    matrix[i][ec] = counter\\n                    counter+=1\\n                ec-=1\\n                direction = 2\\n            elif direction==2:\\n                for i in range(ec, sc-1, -1):\\n                    matrix[er][i] = counter\\n                    counter+=1\\n                er-=1\\n                direction = 3\\n            else:\\n                for i in range(er, sr-1, -1):\\n                    matrix[i][sc] = counter\\n                    counter+=1\\n                sc+=1\\n                direction = 0\\n        \\n        return matrix\\n```\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\\n        sr, sc, er, ec = 0, 0, n-1, n-1\\n        counter = 1\\n        \\n        while sr <= er and sc <= ec:\\n\\n            for i in range(sc, ec+1):\\n                matrix[sr][i] = counter\\n                counter+=1\\n            sr+=1\\n\\n            for i in range(sr, er+1):\\n                matrix[i][ec] = counter\\n                counter+=1\\n            ec-=1\\n\\n            for i in range(ec, sc-1, -1):\\n                matrix[er][i] = counter\\n                counter+=1\\n            er-=1\\n\\n            for i in range(er, sr-1, -1):\\n                matrix[i][sc] = counter\\n                counter+=1\\n            sc+=1\\n        \\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732201,
                "title": "a-different-and-quick-approach-in-rust-but-explained",
                "content": "The most common approach is simulating, but actually we can write a function that maps `(n, x, y)` to `cell value`.\\n\\nFor example:\\n```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\\nIf we can write a function that maps `n=3, x=1, y = 2` to `6`, the problem will be easily solved.\\n\\n#### How to write it?\\n\\nWell, people may have different approaches, but mine is regarding the map as an onion which consists of several circles like this:\\n\\n```\\n[2, 2, 2, 2, 2, 2], \\n[2, 1, 1, 1, 1, 2], \\n[2, 1, 0, 0, 1, 2],\\n[2, 1, 0, 0, 1, 2], \\n[2, 1, 1, 1, 1, 2], \\n[2, 2, 2, 2, 2, 2]\\n```\\n\\nWith the circle numer(0-2), we calculate the base(the number current circle begins with):\\n\\n```\\n[0, 0,  0,  0,  0,  0],\\n[0, 20, 20, 20, 20, 0],\\n[0, 20, 32, 32, 20, 0],\\n[0, 20, 32, 32, 20, 0],\\n[0, 20, 20, 20, 20, 0],\\n[0, 0,  0,  0,  0,  0]]\\n```\\n\\nThen we calculates the offset(position of the cell locates on the circle):\\n\\n```\\n[0,  1,  2,  3,  4,  5 ], \\n[19, 0,  1,  2,  3,  6 ], \\n[18, 11, 0,  1,  4,  7 ], \\n[17, 10, 3,  2,  5,  8 ], \\n[16, 9,  8,  7,  6,  9 ], \\n[15, 14, 13, 12, 11, 10]\\n```\\n\\nThen we add it together:\\n\\n```\\n[0,  1,  2,  3,  4,  5 ], \\n[19, 20, 21, 22, 23, 6 ], \\n[18, 31, 32, 33, 24, 7 ], \\n[17, 30, 35, 34, 25, 8 ],\\n[16, 29, 28, 27, 26, 9 ],\\n[15, 14, 13, 12, 11, 10]\\n```\\n\\nThat\\'s all. Don\\'t forget to add 1. LOL. I wrote it in Rust:\\n\\n```\\nRuntime: 0 ms, faster than 100.00% of Rust online submissions for Spiral Matrix II.\\n```\\n\\n```Rust\\nfn spiral(n: usize, x: usize, y: usize) -> usize {\\n    let loop_max = (n - 1) / 2;\\n\\n    let tmp = |x| {\\n        if x <= loop_max {\\n            loop_max - x\\n        } else {\\n            x + loop_max + 1 - n\\n        }\\n    };\\n\\n    let loop_count = tmp(x).max(tmp(y));\\n\\n    let circle_len: fn(usize) -> usize = if n % 2 == 0 {\\n        |x| 8 * x + 4\\n    } else {\\n        |x| if x == 0 { 1 } else { 8 * x }\\n    };\\n\\n    let base = (loop_max - loop_count) * (circle_len(loop_max) + circle_len(loop_count + 1)) / 2;\\n\\n    let current_circle_len = circle_len(loop_count);\\n\\n    let diff = loop_max - loop_count;\\n\\n    let offset = if y == diff {\\n        x - y\\n    } else if x == n - 1 - diff {\\n        current_circle_len / 4 + (y - diff)\\n    } else if y == n - 1 - diff {\\n        3 * current_circle_len / 4 - (x - diff)\\n    } else if x == diff {\\n        current_circle_len - (y - diff)\\n    } else {\\n        unreachable!()\\n    };\\n\\n    base + offset\\n}\\n\\npub fn generate_matrix(n: i32) -> Vec<Vec<i32>> {\\n    if n == 0 {\\n        return vec![];\\n    }\\n    let n = n as usize;\\n    let mut result = vec![Vec::with_capacity(n); n];\\n    for y in 0..n {\\n        for x in 0..n {\\n            result[y].push(spiral(n, x, y) as i32 + 1);\\n        }\\n    }\\n    result\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\n```\\n[2, 2, 2, 2, 2, 2], \\n[2, 1, 1, 1, 1, 2], \\n[2, 1, 0, 0, 1, 2],\\n[2, 1, 0, 0, 1, 2], \\n[2, 1, 1, 1, 1, 2], \\n[2, 2, 2, 2, 2, 2]\\n```\n```\\n[0, 0,  0,  0,  0,  0],\\n[0, 20, 20, 20, 20, 0],\\n[0, 20, 32, 32, 20, 0],\\n[0, 20, 32, 32, 20, 0],\\n[0, 20, 20, 20, 20, 0],\\n[0, 0,  0,  0,  0,  0]]\\n```\n```\\n[0,  1,  2,  3,  4,  5 ], \\n[19, 0,  1,  2,  3,  6 ], \\n[18, 11, 0,  1,  4,  7 ], \\n[17, 10, 3,  2,  5,  8 ], \\n[16, 9,  8,  7,  6,  9 ], \\n[15, 14, 13, 12, 11, 10]\\n```\n```\\n[0,  1,  2,  3,  4,  5 ], \\n[19, 20, 21, 22, 23, 6 ], \\n[18, 31, 32, 33, 24, 7 ], \\n[17, 30, 35, 34, 25, 8 ],\\n[16, 29, 28, 27, 26, 9 ],\\n[15, 14, 13, 12, 11, 10]\\n```\n```\\nRuntime: 0 ms, faster than 100.00% of Rust online submissions for Spiral Matrix II.\\n```\n```Rust\\nfn spiral(n: usize, x: usize, y: usize) -> usize {\\n    let loop_max = (n - 1) / 2;\\n\\n    let tmp = |x| {\\n        if x <= loop_max {\\n            loop_max - x\\n        } else {\\n            x + loop_max + 1 - n\\n        }\\n    };\\n\\n    let loop_count = tmp(x).max(tmp(y));\\n\\n    let circle_len: fn(usize) -> usize = if n % 2 == 0 {\\n        |x| 8 * x + 4\\n    } else {\\n        |x| if x == 0 { 1 } else { 8 * x }\\n    };\\n\\n    let base = (loop_max - loop_count) * (circle_len(loop_max) + circle_len(loop_count + 1)) / 2;\\n\\n    let current_circle_len = circle_len(loop_count);\\n\\n    let diff = loop_max - loop_count;\\n\\n    let offset = if y == diff {\\n        x - y\\n    } else if x == n - 1 - diff {\\n        current_circle_len / 4 + (y - diff)\\n    } else if y == n - 1 - diff {\\n        3 * current_circle_len / 4 - (x - diff)\\n    } else if x == diff {\\n        current_circle_len - (y - diff)\\n    } else {\\n        unreachable!()\\n    };\\n\\n    base + offset\\n}\\n\\npub fn generate_matrix(n: i32) -> Vec<Vec<i32>> {\\n    if n == 0 {\\n        return vec![];\\n    }\\n    let n = n as usize;\\n    let mut result = vec![Vec::with_capacity(n); n];\\n    for y in 0..n {\\n        for x in 0..n {\\n            result[y].push(spiral(n, x, y) as i32 + 1);\\n        }\\n    }\\n    result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 726326,
                "title": "java-simple-and-easy-to-read",
                "content": "The approach is similar to other ones but I liked how clean my solution looked and thougth I would share! :)\\n\\nTime: O(n) where n is the total number of spaces to fill in the grid\\n```\\npublic int[][] generateMatrix(int n) {\\n        // Go around until im done and while I can\\n        \\n        int total = n*n;\\n        int[][] grid = new int[n][n]; // This will initialize every element with 0\\n        \\n        int i = 1;\\n        int r = 0, c = -1;\\n        while (i <= total) {\\n            // Go right as long as I can aka the next space is 0\\n            while (c < n - 1 && grid[r][c+1] == 0) {\\n                grid[r][++c] = i++;\\n            }\\n            \\n            // Go down\\n            while (r < n - 1 && grid[r+1][c] == 0) {\\n                grid[++r][c] = i++;\\n            }\\n            \\n            // Go left\\n            while (c > 0 && grid[r][c-1] == 0) {\\n                grid[r][--c] = i++;\\n            }\\n            // Go up\\n            while (r > 0 && grid[r-1][c] == 0) {\\n                grid[--r][c] = i++;\\n            }\\n        }\\n        \\n        return grid;\\n        \\n    }",
                "solutionTags": [],
                "code": "The approach is similar to other ones but I liked how clean my solution looked and thougth I would share! :)\\n\\nTime: O(n) where n is the total number of spaces to fill in the grid\\n```\\npublic int[][] generateMatrix(int n) {\\n        // Go around until im done and while I can\\n        \\n        int total = n*n;\\n        int[][] grid = new int[n][n]; // This will initialize every element with 0\\n        \\n        int i = 1;\\n        int r = 0, c = -1;\\n        while (i <= total) {\\n            // Go right as long as I can aka the next space is 0\\n            while (c < n - 1 && grid[r][c+1] == 0) {\\n                grid[r][++c] = i++;\\n            }\\n            \\n            // Go down\\n            while (r < n - 1 && grid[r+1][c] == 0) {\\n                grid[++r][c] = i++;\\n            }\\n            \\n            // Go left\\n            while (c > 0 && grid[r][c-1] == 0) {\\n                grid[r][--c] = i++;\\n            }\\n            // Go up\\n            while (r > 0 && grid[r-1][c] == 0) {\\n                grid[--r][c] = i++;\\n            }\\n        }\\n        \\n        return grid;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 547692,
                "title": "short-and-clean-dfs",
                "content": "```\\npublic class Solution \\n{\\n    private int count = 0;\\n    \\n    public int[][] GenerateMatrix(int n) \\n    {\\n        int[][] mat = new int[n][];\\n        \\n        for(int i = 0; i < n; i++)\\n            mat[i] = new int[n];\\n        \\n        DFS(mat, 0, 0, n, Direction.RIGHT);\\n        \\n        return mat;\\n    }\\n    \\n    private void DFS(int[][] mat, int r, int c, int n, Direction direction)\\n    {\\n        if(r < 0 || c < 0 || r > n - 1 || c > n - 1 || mat[r][c] > 0)\\n            return;\\n        \\n        mat[r][c] = ++count;\\n        \\n        switch(direction)\\n        {\\n            case Direction.RIGHT:\\n                DFS(mat, r, c + 1, n, Direction.RIGHT);\\n                DFS(mat, r + 1, c, n, Direction.DOWN);\\n                break;\\n            case Direction.DOWN:\\n                DFS(mat, r + 1, c, n, Direction.DOWN);\\n                DFS(mat, r, c - 1, n, Direction.LEFT);\\n                break;\\n            case Direction.LEFT:\\n                DFS(mat, r, c - 1, n, Direction.LEFT);\\n                DFS(mat, r - 1, c, n, Direction.UP);\\n                break;\\n            case Direction.UP:\\n                DFS(mat, r - 1, c, n, Direction.UP);\\n                DFS(mat, r, c + 1, n, Direction.RIGHT);\\n                break;\\n            default:\\n                break;\\n        }\\n    }\\n}\\n\\npublic enum Direction\\n{\\n    RIGHT,\\n    DOWN,\\n    LEFT,\\n    UP\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution \\n{\\n    private int count = 0;\\n    \\n    public int[][] GenerateMatrix(int n) \\n    {\\n        int[][] mat = new int[n][];\\n        \\n        for(int i = 0; i < n; i++)\\n            mat[i] = new int[n];\\n        \\n        DFS(mat, 0, 0, n, Direction.RIGHT);\\n        \\n        return mat;\\n    }\\n    \\n    private void DFS(int[][] mat, int r, int c, int n, Direction direction)\\n    {\\n        if(r < 0 || c < 0 || r > n - 1 || c > n - 1 || mat[r][c] > 0)\\n            return;\\n        \\n        mat[r][c] = ++count;\\n        \\n        switch(direction)\\n        {\\n            case Direction.RIGHT:\\n                DFS(mat, r, c + 1, n, Direction.RIGHT);\\n                DFS(mat, r + 1, c, n, Direction.DOWN);\\n                break;\\n            case Direction.DOWN:\\n                DFS(mat, r + 1, c, n, Direction.DOWN);\\n                DFS(mat, r, c - 1, n, Direction.LEFT);\\n                break;\\n            case Direction.LEFT:\\n                DFS(mat, r, c - 1, n, Direction.LEFT);\\n                DFS(mat, r - 1, c, n, Direction.UP);\\n                break;\\n            case Direction.UP:\\n                DFS(mat, r - 1, c, n, Direction.UP);\\n                DFS(mat, r, c + 1, n, Direction.RIGHT);\\n                break;\\n            default:\\n                break;\\n        }\\n    }\\n}\\n\\npublic enum Direction\\n{\\n    RIGHT,\\n    DOWN,\\n    LEFT,\\n    UP\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508440,
                "title": "java-my-easy-solution",
                "content": "```\\npublic int[][] generateMatrix(int n) {\\n\\tint sol[][] = new int[n][n], count = 1;\\n\\tint rowMin = 0, colMin = 0, rowMax = n-1, colMax = n-1;\\n\\twhile(rowMin <= rowMax && colMin <= colMax) {\\n\\t\\tfor(int i = colMin; i <= colMax; i++) \\n\\t\\t\\tsol[rowMin][i] = count++;\\n\\t\\trowMin++;\\n\\t\\tfor(int i = rowMin; i <= rowMax; i++) \\n\\t\\t\\tsol[i][colMax] = count++;\\n\\t\\tcolMax--;\\n\\t\\tfor(int i = colMax; i >= colMin; i--)\\n\\t\\t\\tsol[rowMax][i] = count++;\\n\\t\\trowMax--;\\n\\t\\tfor(int i = rowMax; i >= rowMin; i--)\\n\\t\\t\\tsol[i][colMin] = count++;\\n\\t\\tcolMin++;\\n\\t}\\n\\treturn sol;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] generateMatrix(int n) {\\n\\tint sol[][] = new int[n][n], count = 1;\\n\\tint rowMin = 0, colMin = 0, rowMax = n-1, colMax = n-1;\\n\\twhile(rowMin <= rowMax && colMin <= colMax) {\\n\\t\\tfor(int i = colMin; i <= colMax; i++) \\n\\t\\t\\tsol[rowMin][i] = count++;\\n\\t\\trowMin++;\\n\\t\\tfor(int i = rowMin; i <= rowMax; i++) \\n\\t\\t\\tsol[i][colMax] = count++;\\n\\t\\tcolMax--;\\n\\t\\tfor(int i = colMax; i >= colMin; i--)\\n\\t\\t\\tsol[rowMax][i] = count++;\\n\\t\\trowMax--;\\n\\t\\tfor(int i = rowMax; i >= rowMin; i--)\\n\\t\\t\\tsol[i][colMin] = count++;\\n\\t\\tcolMin++;\\n\\t}\\n\\treturn sol;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 477625,
                "title": "c",
                "content": "```\\npublic int[][] GenerateMatrix(int n) {\\n      \\n        int[][] result = new int[n][];\\n        for(int i = 0 ; i < result.Length; i++){\\n            result[i] = new int[n];\\n        }\\n        \\n        int count = 1;\\n        int rLowerEnd = 0, rHigherEnd = result.Length - 1;\\n        int cLowerEnd = 0, cHigherEnd = result[0].Length - 1;\\n        \\n        \\n        while (rLowerEnd <= rHigherEnd && cLowerEnd <= cHigherEnd) {\\n            for (int c = cLowerEnd; c <= cHigherEnd; c++) \\n                result[rLowerEnd][c] = count++;\\n            for (int r = rLowerEnd + 1; r <= rHigherEnd; r++) \\n                result[r][cHigherEnd] = count++;\\n            \\n            if (rLowerEnd < rHigherEnd && cLowerEnd < cHigherEnd) {\\n                for (int c = cHigherEnd - 1; c > cLowerEnd; c--) \\n                    result[rHigherEnd][c] = count++;\\n                for (int r = rHigherEnd; r > rLowerEnd; r--) \\n                    result[r][cLowerEnd] = count++;\\n            }\\n            // Move one row down \\n            rLowerEnd++;\\n            // move one row up\\n            rHigherEnd--;\\n            // move one column inside \\n            cLowerEnd++;\\n             // move one column inside \\n            cHigherEnd--;\\n        }        \\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] GenerateMatrix(int n) {\\n      \\n        int[][] result = new int[n][];\\n        for(int i = 0 ; i < result.Length; i++){\\n            result[i] = new int[n];\\n        }\\n        \\n        int count = 1;\\n        int rLowerEnd = 0, rHigherEnd = result.Length - 1;\\n        int cLowerEnd = 0, cHigherEnd = result[0].Length - 1;\\n        \\n        \\n        while (rLowerEnd <= rHigherEnd && cLowerEnd <= cHigherEnd) {\\n            for (int c = cLowerEnd; c <= cHigherEnd; c++) \\n                result[rLowerEnd][c] = count++;\\n            for (int r = rLowerEnd + 1; r <= rHigherEnd; r++) \\n                result[r][cHigherEnd] = count++;\\n            \\n            if (rLowerEnd < rHigherEnd && cLowerEnd < cHigherEnd) {\\n                for (int c = cHigherEnd - 1; c > cLowerEnd; c--) \\n                    result[rHigherEnd][c] = count++;\\n                for (int r = rHigherEnd; r > rLowerEnd; r--) \\n                    result[r][cLowerEnd] = count++;\\n            }\\n            // Move one row down \\n            rLowerEnd++;\\n            // move one row up\\n            rHigherEnd--;\\n            // move one column inside \\n            cLowerEnd++;\\n             // move one column inside \\n            cHigherEnd--;\\n        }        \\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 309040,
                "title": "c-100-beat-using-smart-loops-smart-memories-super-hack-video-rental-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> aResult(n, vector<int>(n));\\n        \\n        int _U = 0, _R = n - 1, _D = n - 1, _L = 0, x = 0, y = 0, VAL = 1;\\n        \\n        while (_L <= _R) {\\n            \\n            x = _L; y = _U;\\n            \\n            //Sweep right across the top.\\n            while (x <= _R) { aResult[y][x++] = VAL++; }\\n            _U += 1; y = _U;\\n            \\n            //Sweep down the right side.\\n            while (y <= _D) { aResult[y++][_R] = VAL++; }\\n            _R -= 1; x = _R;\\n            \\n            //Swipe left across the bottom.\\n            while (x >= _L) { aResult[_D][x--] = VAL++; }\\n            _D -= 1; y = _D;\\n            \\n            //Sweep up the left side.\\n            while (y >= _U) { aResult[y--][_L] = VAL++; }\\n            _L += 1;\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n\\nDecided to try with all the variables being named in terrible ways. I am not sure how you can clock more speed given that the result needs to be a vector of vectors.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> aResult(n, vector<int>(n));\\n        \\n        int _U = 0, _R = n - 1, _D = n - 1, _L = 0, x = 0, y = 0, VAL = 1;\\n        \\n        while (_L <= _R) {\\n            \\n            x = _L; y = _U;\\n            \\n            //Sweep right across the top.\\n            while (x <= _R) { aResult[y][x++] = VAL++; }\\n            _U += 1; y = _U;\\n            \\n            //Sweep down the right side.\\n            while (y <= _D) { aResult[y++][_R] = VAL++; }\\n            _R -= 1; x = _R;\\n            \\n            //Swipe left across the bottom.\\n            while (x >= _L) { aResult[_D][x--] = VAL++; }\\n            _D -= 1; y = _D;\\n            \\n            //Sweep up the left side.\\n            while (y >= _U) { aResult[y--][_L] = VAL++; }\\n            _L += 1;\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285553,
                "title": "java-solution-beating-100-of-java-submissions-in-both-runtime-and-memory-usage",
                "content": "```\\npublic int[][] generateMatrix(int n) {\\n    int[][] rs = new int[n][n];\\n    \\n    int r1 = 0;\\n\\tint r2 = n - 1;\\n\\tint c1 = 0;\\n\\tint c2 = n - 1;\\n\\tint num = 1;\\n\\twhile (r1 <= r2 && c1 <= c2) {\\n\\t\\tfor (int c = c1; c <= c2; c++)\\n\\t\\t\\trs[r1][c] = num++;\\n\\t\\t\\n\\t\\tfor (int r = r1 + 1; r <= r2; r++)\\n\\t\\t\\trs[r][c2] = num++;\\n\\t\\t\\n\\t\\tif (r1 < r2 && c1 < c2) {\\n\\t\\t\\tfor (int c = c2 - 1; c > c1; c--)\\n\\t\\t\\t\\trs[r2][c] = num++;\\n\\t\\t\\t\\n\\t\\t\\tfor (int r = r2; r > r1; r--)\\n\\t\\t\\t\\trs[r][c1] = num++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tr1++;\\n\\t\\tc1++;\\n\\t\\tr2--;\\n\\t\\tc2--;\\n\\t}\\n\\treturn rs;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] generateMatrix(int n) {\\n    int[][] rs = new int[n][n];\\n    \\n    int r1 = 0;\\n\\tint r2 = n - 1;\\n\\tint c1 = 0;\\n\\tint c2 = n - 1;\\n\\tint num = 1;\\n\\twhile (r1 <= r2 && c1 <= c2) {\\n\\t\\tfor (int c = c1; c <= c2; c++)\\n\\t\\t\\trs[r1][c] = num++;\\n\\t\\t\\n\\t\\tfor (int r = r1 + 1; r <= r2; r++)\\n\\t\\t\\trs[r][c2] = num++;\\n\\t\\t\\n\\t\\tif (r1 < r2 && c1 < c2) {\\n\\t\\t\\tfor (int c = c2 - 1; c > c1; c--)\\n\\t\\t\\t\\trs[r2][c] = num++;\\n\\t\\t\\t\\n\\t\\t\\tfor (int r = r2; r > r1; r--)\\n\\t\\t\\t\\trs[r][c1] = num++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tr1++;\\n\\t\\tc1++;\\n\\t\\tr2--;\\n\\t\\tc2--;\\n\\t}\\n\\treturn rs;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 131432,
                "title": "simple-javascript-solution-beating-100",
                "content": "```\\nvar generateMatrix = function(n) {\\n    let square = Array(n).fill(0).map(el => Array(n).fill(0));\\n    let count, row, col;\\n    count = row = col = 0;\\n    while (count < n * n) {\\n        while (square[row][col] === 0) {\\n            square[row][col++] = ++count;\\n        }\\n        col--;\\n        row++;\\n        while (square[row] && square[row][col] === 0) {\\n            square[row++][col] = ++count;\\n        }\\n        row--;\\n        col--;\\n        while (square[row][col] === 0) {\\n            square[row][col--] = ++count;\\n        }\\n        col++;\\n        row--;\\n        while (square[row] && square[row][col] === 0) {\\n            square[row--][col] = ++count;\\n        }\\n        row++;\\n        col++;\\n    }\\n    return square;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar generateMatrix = function(n) {\\n    let square = Array(n).fill(0).map(el => Array(n).fill(0));\\n    let count, row, col;\\n    count = row = col = 0;\\n    while (count < n * n) {\\n        while (square[row][col] === 0) {\\n            square[row][col++] = ++count;\\n        }\\n        col--;\\n        row++;\\n        while (square[row] && square[row][col] === 0) {\\n            square[row++][col] = ++count;\\n        }\\n        row--;\\n        col--;\\n        while (square[row][col] === 0) {\\n            square[row][col--] = ++count;\\n        }\\n        col++;\\n        row--;\\n        while (square[row] && square[row][col] === 0) {\\n            square[row--][col] = ++count;\\n        }\\n        row++;\\n        col++;\\n    }\\n    return square;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 22322,
                "title": "golang-3-ms",
                "content": "```\\nfunc generateMatrix(n int) [][]int {\\n        matrix := make([][]int, n)\\n        for i := range matrix {\\n            matrix[i] = make([]int, n)\\n        }\\n        \\n        if n==0 {\\n            return matrix\\n        }\\n        \\n        rowStart := 0\\n        rowEnd := n - 1\\n        colStart := 0\\n        colEnd := n - 1\\n        num := 1\\n        \\n        for rowStart <= rowEnd && colStart <= colEnd {\\n            for i := colStart; i <= colEnd; i++ {\\n                matrix[rowStart][i] = num\\n                num++\\n            }\\n            rowStart++\\n            \\n            for i := rowStart;i<=rowEnd; i++ {\\n                matrix[i][colEnd] = num\\n                num++\\n            }\\n            colEnd--\\n            for  i:= colEnd; i >= colStart; i-- {\\n                if rowStart <= rowEnd {\\n                    matrix[rowEnd][i] = num\\n                    num++\\n                }\\n            }\\n            rowEnd--\\n            for  i:= rowEnd; i >= rowStart; i-- {\\n                if colStart <= colEnd {\\n                    matrix[i][colStart] = num\\n                    num++\\n                }\\n            }\\n            colStart++\\n        }\\n        return matrix\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc generateMatrix(n int) [][]int {\\n        matrix := make([][]int, n)\\n        for i := range matrix {\\n            matrix[i] = make([]int, n)\\n        }\\n        \\n        if n==0 {\\n            return matrix\\n        }\\n        \\n        rowStart := 0\\n        rowEnd := n - 1\\n        colStart := 0\\n        colEnd := n - 1\\n        num := 1\\n        \\n        for rowStart <= rowEnd && colStart <= colEnd {\\n            for i := colStart; i <= colEnd; i++ {\\n                matrix[rowStart][i] = num\\n                num++\\n            }\\n            rowStart++\\n            \\n            for i := rowStart;i<=rowEnd; i++ {\\n                matrix[i][colEnd] = num\\n                num++\\n            }\\n            colEnd--\\n            for  i:= colEnd; i >= colStart; i-- {\\n                if rowStart <= rowEnd {\\n                    matrix[rowEnd][i] = num\\n                    num++\\n                }\\n            }\\n            rowEnd--\\n            for  i:= rowEnd; i >= rowStart; i-- {\\n                if colStart <= colEnd {\\n                    matrix[i][colStart] = num\\n                    num++\\n                }\\n            }\\n            colStart++\\n        }\\n        return matrix\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050368,
                "title": "spiral-matrix-ii-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n\\n        int startingRow=0;\\n        int endingRow=n-1;\\n        int startingCol=0;\\n        int endingCol=n-1;\\n        int k=1;\\n        int last=n*n;\\n    while(k<=last){\\n        for(int i=startingCol;k<=last,i<=endingCol;i++){\\n            mat[startingRow][i]=k++;\\n        }\\n        startingRow++;\\n        for(int i=startingRow;k<=last,i<=endingRow;i++){\\n            mat[i][endingCol]=k++;\\n        }\\n\\n        endingCol--;\\n        for(int i=endingCol;k<=last,i>=startingCol;i--){\\n            mat[endingRow][i]=k++;\\n        }\\n        endingRow--;\\n        for(int i=endingRow;k<=last, i>=startingRow;i--){\\n            mat[i][startingCol]=k++;\\n        }\\n        startingCol++;\\n     }\\n     return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n\\n        int startingRow=0;\\n        int endingRow=n-1;\\n        int startingCol=0;\\n        int endingCol=n-1;\\n        int k=1;\\n        int last=n*n;\\n    while(k<=last){\\n        for(int i=startingCol;k<=last,i<=endingCol;i++){\\n            mat[startingRow][i]=k++;\\n        }\\n        startingRow++;\\n        for(int i=startingRow;k<=last,i<=endingRow;i++){\\n            mat[i][endingCol]=k++;\\n        }\\n\\n        endingCol--;\\n        for(int i=endingCol;k<=last,i>=startingCol;i--){\\n            mat[endingRow][i]=k++;\\n        }\\n        endingRow--;\\n        for(int i=endingRow;k<=last, i>=startingRow;i--){\\n            mat[i][startingCol]=k++;\\n        }\\n        startingCol++;\\n     }\\n     return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757828,
                "title": "spiral-matrix-ii-o-m-n-javascript-memory-95-45-meaningful-vars",
                "content": "```\\nfunction getNeighbors(array, rowIndex, columnIndex, storage) {\\n    const neighbors = {};\\n    if (\\n        array[rowIndex] &&\\n        array[rowIndex][columnIndex + 1] !== undefined &&\\n        !storage[`${rowIndex}_${columnIndex + 1}`]\\n    ) {\\n        neighbors.right = { rowIndex: rowIndex, columnIndex: columnIndex + 1 };\\n    }\\n\\n    if (\\n        array[rowIndex] &&\\n        array[rowIndex][columnIndex - 1] !== undefined &&\\n        !storage[`${rowIndex}_${columnIndex - 1}`]\\n    ) {\\n        neighbors.left = { rowIndex: rowIndex, columnIndex: columnIndex - 1 };\\n    }\\n    if (\\n        array[rowIndex + 1] &&\\n        array[rowIndex + 1][columnIndex] !== undefined &&\\n        !storage[`${rowIndex + 1}_${columnIndex}`]\\n    ) {\\n        neighbors.down = { rowIndex: rowIndex + 1, columnIndex: columnIndex };\\n    }\\n    if (\\n        array[rowIndex - 1] &&\\n        array[rowIndex - 1][columnIndex] !== undefined &&\\n        !storage[`${rowIndex - 1}_${columnIndex}`]\\n    ) {\\n        neighbors.up = { rowIndex: rowIndex - 1, columnIndex: columnIndex };\\n    }\\n    return neighbors;\\n}\\n\\nvar generateMatrix = function(size) {\\n    const output = [];\\n    const storage = {};\\n    let count = 2;\\n    let movement = `row`;\\n    let rowIndex = 0;\\n    let columnIndex = 0;\\n    let tempSize = size * size;\\n    for (let rowIndex = 0; rowIndex < size; rowIndex++) {\\n        output[rowIndex] = [];\\n        for (let columnIndex = 0; columnIndex < size; columnIndex++) {\\n            output[rowIndex][columnIndex] = 1;\\n        }\\n    }\\n    while (tempSize--) {\\n        storage[`${rowIndex}_${columnIndex}`] = true;\\n        const neighbors = getNeighbors(output, rowIndex, columnIndex, storage);\\n        if (Object.keys(neighbors).length === 0) {\\n            break;\\n        }\\n        if (Object.keys(neighbors).length === 1) {\\n            if (neighbors.right) {\\n                rowIndex = neighbors.right.rowIndex;\\n                columnIndex = neighbors.right.columnIndex;\\n                if (!output[neighbors.right.columnIndex]) {\\n                    output[neighbors.right.columnIndex] = [];\\n                }\\n                output[neighbors.right.rowIndex][neighbors.right.columnIndex] = count++;\\n                movement = `row`;\\n            } else if (neighbors.left) {\\n                rowIndex = neighbors.left.rowIndex;\\n                columnIndex = neighbors.left.columnIndex;\\n                if (!output[neighbors.left.columnIndex]) {\\n                    output[neighbors.left.columnIndex] = [];\\n                }\\n                output[neighbors.left.rowIndex][neighbors.left.columnIndex] = count++;\\n                movement = `row`;\\n            } else if (neighbors.down) {\\n                rowIndex = neighbors.down.rowIndex;\\n                columnIndex = neighbors.down.columnIndex;\\n                if (!output[neighbors.down.columnIndex]) {\\n                    output[neighbors.down.columnIndex] = [];\\n                }\\n                output[neighbors.down.rowIndex][neighbors.down.columnIndex] = count++;\\n                movement = `column`;\\n            } else {\\n                rowIndex = neighbors.up.rowIndex;\\n                columnIndex = neighbors.up.columnIndex;\\n                if (!output[neighbors.up.columnIndex]) {\\n                    output[neighbors.up.columnIndex] = [];\\n                }\\n                output[neighbors.up.rowIndex][neighbors.up.columnIndex] = count++;\\n                movement = `column`;\\n            }\\n        } else {\\n            if (movement === `row`) {\\n                if (neighbors.right) {\\n                    rowIndex = neighbors.right.rowIndex;\\n                    columnIndex = neighbors.right.columnIndex;\\n                    if (!output[neighbors.right.columnIndex]) {\\n                        output[neighbors.right.columnIndex] = [];\\n                    }\\n                    output[neighbors.right.rowIndex][neighbors.right.columnIndex] = count++;\\n                } else {\\n                    rowIndex = neighbors.left.rowIndex;\\n                    columnIndex = neighbors.left.columnIndex;\\n                    if (!output[neighbors.left.columnIndex]) {\\n                        output[neighbors.left.columnIndex] = [];\\n                    }\\n                    output[neighbors.left.rowIndex][neighbors.left.columnIndex] = count++;\\n                }\\n            } else {\\n                if (neighbors.up) {\\n                    rowIndex = neighbors.up.rowIndex;\\n                    columnIndex = neighbors.up.columnIndex;\\n                    if (!output[neighbors.up.columnIndex]) {\\n                        output[neighbors.up.columnIndex] = [];\\n                    }\\n                    output[neighbors.up.rowIndex][neighbors.up.columnIndex] = count++;\\n                } else {\\n                    rowIndex = neighbors.down.rowIndex;\\n                    columnIndex = neighbors.down.columnIndex;\\n                    if (!output[neighbors.down.columnIndex]) {\\n                        output[neighbors.down.columnIndex] = [];\\n                    }\\n                    output[neighbors.down.rowIndex][neighbors.down.columnIndex] = count++;\\n                }\\n            }\\n        }\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction getNeighbors(array, rowIndex, columnIndex, storage) {\\n    const neighbors = {};\\n    if (\\n        array[rowIndex] &&\\n        array[rowIndex][columnIndex + 1] !== undefined &&\\n        !storage[`${rowIndex}_${columnIndex + 1}`]\\n    ) {\\n        neighbors.right = { rowIndex: rowIndex, columnIndex: columnIndex + 1 };\\n    }\\n\\n    if (\\n        array[rowIndex] &&\\n        array[rowIndex][columnIndex - 1] !== undefined &&\\n        !storage[`${rowIndex}_${columnIndex - 1}`]\\n    ) {\\n        neighbors.left = { rowIndex: rowIndex, columnIndex: columnIndex - 1 };\\n    }\\n    if (\\n        array[rowIndex + 1] &&\\n        array[rowIndex + 1][columnIndex] !== undefined &&\\n        !storage[`${rowIndex + 1}_${columnIndex}`]\\n    ) {\\n        neighbors.down = { rowIndex: rowIndex + 1, columnIndex: columnIndex };\\n    }\\n    if (\\n        array[rowIndex - 1] &&\\n        array[rowIndex - 1][columnIndex] !== undefined &&\\n        !storage[`${rowIndex - 1}_${columnIndex}`]\\n    ) {\\n        neighbors.up = { rowIndex: rowIndex - 1, columnIndex: columnIndex };\\n    }\\n    return neighbors;\\n}\\n\\nvar generateMatrix = function(size) {\\n    const output = [];\\n    const storage = {};\\n    let count = 2;\\n    let movement = `row`;\\n    let rowIndex = 0;\\n    let columnIndex = 0;\\n    let tempSize = size * size;\\n    for (let rowIndex = 0; rowIndex < size; rowIndex++) {\\n        output[rowIndex] = [];\\n        for (let columnIndex = 0; columnIndex < size; columnIndex++) {\\n            output[rowIndex][columnIndex] = 1;\\n        }\\n    }\\n    while (tempSize--) {\\n        storage[`${rowIndex}_${columnIndex}`] = true;\\n        const neighbors = getNeighbors(output, rowIndex, columnIndex, storage);\\n        if (Object.keys(neighbors).length === 0) {\\n            break;\\n        }\\n        if (Object.keys(neighbors).length === 1) {\\n            if (neighbors.right) {\\n                rowIndex = neighbors.right.rowIndex;\\n                columnIndex = neighbors.right.columnIndex;\\n                if (!output[neighbors.right.columnIndex]) {\\n                    output[neighbors.right.columnIndex] = [];\\n                }\\n                output[neighbors.right.rowIndex][neighbors.right.columnIndex] = count++;\\n                movement = `row`;\\n            } else if (neighbors.left) {\\n                rowIndex = neighbors.left.rowIndex;\\n                columnIndex = neighbors.left.columnIndex;\\n                if (!output[neighbors.left.columnIndex]) {\\n                    output[neighbors.left.columnIndex] = [];\\n                }\\n                output[neighbors.left.rowIndex][neighbors.left.columnIndex] = count++;\\n                movement = `row`;\\n            } else if (neighbors.down) {\\n                rowIndex = neighbors.down.rowIndex;\\n                columnIndex = neighbors.down.columnIndex;\\n                if (!output[neighbors.down.columnIndex]) {\\n                    output[neighbors.down.columnIndex] = [];\\n                }\\n                output[neighbors.down.rowIndex][neighbors.down.columnIndex] = count++;\\n                movement = `column`;\\n            } else {\\n                rowIndex = neighbors.up.rowIndex;\\n                columnIndex = neighbors.up.columnIndex;\\n                if (!output[neighbors.up.columnIndex]) {\\n                    output[neighbors.up.columnIndex] = [];\\n                }\\n                output[neighbors.up.rowIndex][neighbors.up.columnIndex] = count++;\\n                movement = `column`;\\n            }\\n        } else {\\n            if (movement === `row`) {\\n                if (neighbors.right) {\\n                    rowIndex = neighbors.right.rowIndex;\\n                    columnIndex = neighbors.right.columnIndex;\\n                    if (!output[neighbors.right.columnIndex]) {\\n                        output[neighbors.right.columnIndex] = [];\\n                    }\\n                    output[neighbors.right.rowIndex][neighbors.right.columnIndex] = count++;\\n                } else {\\n                    rowIndex = neighbors.left.rowIndex;\\n                    columnIndex = neighbors.left.columnIndex;\\n                    if (!output[neighbors.left.columnIndex]) {\\n                        output[neighbors.left.columnIndex] = [];\\n                    }\\n                    output[neighbors.left.rowIndex][neighbors.left.columnIndex] = count++;\\n                }\\n            } else {\\n                if (neighbors.up) {\\n                    rowIndex = neighbors.up.rowIndex;\\n                    columnIndex = neighbors.up.columnIndex;\\n                    if (!output[neighbors.up.columnIndex]) {\\n                        output[neighbors.up.columnIndex] = [];\\n                    }\\n                    output[neighbors.up.rowIndex][neighbors.up.columnIndex] = count++;\\n                } else {\\n                    rowIndex = neighbors.down.rowIndex;\\n                    columnIndex = neighbors.down.columnIndex;\\n                    if (!output[neighbors.down.columnIndex]) {\\n                        output[neighbors.down.columnIndex] = [];\\n                    }\\n                    output[neighbors.down.rowIndex][neighbors.down.columnIndex] = count++;\\n                }\\n            }\\n        }\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3692221,
                "title": "easiest-c-solution-faster-than-100",
                "content": "vector<vector<int>> generateMatrix(int n) {\\n     vector<vector<int>> ans(n,vector<int>(n));\\n        int sr=0;\\n        int sc=0;\\n        int er=n-1;\\n        int ec =n-1;\\n        int c=1;\\n        while(sr<=er && sc<=ec){\\n        for(int i=sc;i<=ec;i++ ){\\n          ans[sr][i]= c;\\n            c++;\\n        }\\n        sr++;\\n    for(int i=sr;i<=er;i++ ){\\n          ans[i][ec]= c;\\n            c++;\\n        }\\n        ec--;\\n    for(int i=ec;i>=sc;i-- ){\\n          ans[er][i]= c;\\n            c++;\\n        }\\n        er--;\\n      for(int i=er;i>=sr;i-- ){\\n          ans[i][sc]= c;\\n            c++;\\n        }\\n        sc++; \\n    }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "vector<vector<int>> generateMatrix(int n) {\\n     vector<vector<int>> ans(n,vector<int>(n));\\n        int sr=0;\\n        int sc=0;\\n        int er=n-1;\\n        int ec =n-1;\\n        int c=1;\\n        while(sr<=er && sc<=ec){\\n        for(int i=sc;i<=ec;i++ ){\\n          ans[sr][i]= c;\\n            c++;\\n        }\\n        sr++;\\n    for(int i=sr;i<=er;i++ ){\\n          ans[i][ec]= c;\\n            c++;\\n        }\\n        ec--;\\n    for(int i=ec;i>=sc;i-- ){\\n          ans[er][i]= c;\\n            c++;\\n        }\\n        er--;\\n      for(int i=er;i>=sr;i-- ){\\n          ans[i][sc]= c;\\n            c++;\\n        }\\n        sc++; \\n    }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3524776,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        // creating a vector of n*n\\n        \\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        \\n        //int row=matrix.size();\\n        //int col =matrix[0].size();\\n        int count =0;\\n        int total =n*n;\\n        \\n        //// all index \\n        \\n        int startingrow=0;\\n        int startingcol=0;\\n        int endingrow=n-1;\\n        int endingcol=n-1;\\n        \\n        while(count<total)\\n        {\\n            for(int i=startingcol;count<total && i<=endingcol; i++)\\n            {\\n                count++;\\n                ans[startingrow][i]=count;\\n                \\n            }\\n            startingrow++;\\n            \\n            for(int i=startingrow;count<total && i<=endingrow; i++)\\n            {\\n            \\n                count++;\\n                ans[i][endingcol]=count;\\n            }\\n            endingcol--;\\n            \\n            for(int i=endingcol;count<total && i>=startingcol; i--)\\n            {\\n                 count++;\\n                ans[endingrow][i]=count;\\n            }\\n            endingrow--;\\n            \\n            for(int i=endingrow;count<total && i>=startingrow; i--)\\n            {\\n                 count++;\\n                ans[i][startingcol]=count;\\n            \\n            }\\n            startingcol++;\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        // creating a vector of n*n\\n        \\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        \\n        //int row=matrix.size();\\n        //int col =matrix[0].size();\\n        int count =0;\\n        int total =n*n;\\n        \\n        //// all index \\n        \\n        int startingrow=0;\\n        int startingcol=0;\\n        int endingrow=n-1;\\n        int endingcol=n-1;\\n        \\n        while(count<total)\\n        {\\n            for(int i=startingcol;count<total && i<=endingcol; i++)\\n            {\\n                count++;\\n                ans[startingrow][i]=count;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3509821,
                "title": "java-super-easy-to-understand-code-with-comments",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        //create a matrix of nxn size\\n        int[][] arr  = new int[n][n];\\n        //Initialized variables \\n        int top = 0 , bottom = n-1;\\n        int left = 0 , right = n-1;\\n        //Maintain counter to add elements in matrix \\n        int cnt =1;\\n        while(left <=  right && top<=bottom){\\n            //traverse left to right\\n            for (int i = left; i <= right; i++) {\\n                arr[top][i] = cnt++;\\n            }\\n            top++;\\n            //traverse top to bottom\\n            for(int i = top; i<=bottom;i++){\\n                arr[i][right] = cnt++;\\n            }\\n            right--;\\n            //traverse right to left\\n            if(top<=bottom){\\n                for (int i = right; i >=left; i--) {\\n                    arr[bottom][i] = cnt++;\\n                }\\n            }\\n            bottom--;\\n            //traverse bottom to top\\n            if(left<=right){\\n                for (int i = bottom; i >=top ; i--) {\\n                    arr[i][left] = cnt++;\\n                }\\n            }\\n            left++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        //create a matrix of nxn size\\n        int[][] arr  = new int[n][n];\\n        //Initialized variables \\n        int top = 0 , bottom = n-1;\\n        int left = 0 , right = n-1;\\n        //Maintain counter to add elements in matrix \\n        int cnt =1;\\n        while(left <=  right && top<=bottom){\\n            //traverse left to right\\n            for (int i = left; i <= right; i++) {\\n                arr[top][i] = cnt++;\\n            }\\n            top++;\\n            //traverse top to bottom\\n            for(int i = top; i<=bottom;i++){\\n                arr[i][right] = cnt++;\\n            }\\n            right--;\\n            //traverse right to left\\n            if(top<=bottom){\\n                for (int i = right; i >=left; i--) {\\n                    arr[bottom][i] = cnt++;\\n                }\\n            }\\n            bottom--;\\n            //traverse bottom to top\\n            if(left<=right){\\n                for (int i = bottom; i >=top ; i--) {\\n                    arr[i][left] = cnt++;\\n                }\\n            }\\n            left++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509654,
                "title": "easy-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n\\xB2)\\n\\n- Space complexity:\\nO(n\\xB2)\\n\\n# Code\\n```\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {    \\n        var matrix = [[Int]](repeating: [Int](repeating: 0, count: n), count: n) \\n        var top = 0, bottom = n - 1\\n        var left = 0, right = n - 1\\n        var num = 1\\n        while top <= bottom && left <= right {\\n            for i in stride(from: left, to: right + 1, by: 1) {\\n                matrix[top][i] = num\\n                num += 1\\n            }\\n            top += 1\\n            \\n            for i in stride(from: top, to: bottom + 1, by: 1) {\\n                matrix[i][right] = num\\n                num += 1\\n            }\\n            right -= 1\\n            \\n            if top <= bottom {\\n                for i in stride(from: right, to: left - 1, by: -1) {\\n                    matrix[bottom][i] = num\\n                    num += 1\\n                }\\n            }\\n            bottom -= 1\\n            \\n            if left <= right {\\n                for i in stride(from: bottom, to: top - 1, by: -1) {\\n                    matrix[i][left] = num \\n                    num += 1\\n                }\\n            }\\n            left += 1\\n        }\\n        return matrix\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {    \\n        var matrix = [[Int]](repeating: [Int](repeating: 0, count: n), count: n) \\n        var top = 0, bottom = n - 1\\n        var left = 0, right = n - 1\\n        var num = 1\\n        while top <= bottom && left <= right {\\n            for i in stride(from: left, to: right + 1, by: 1) {\\n                matrix[top][i] = num\\n                num += 1\\n            }\\n            top += 1\\n            \\n            for i in stride(from: top, to: bottom + 1, by: 1) {\\n                matrix[i][right] = num\\n                num += 1\\n            }\\n            right -= 1\\n            \\n            if top <= bottom {\\n                for i in stride(from: right, to: left - 1, by: -1) {\\n                    matrix[bottom][i] = num\\n                    num += 1\\n                }\\n            }\\n            bottom -= 1\\n            \\n            if left <= right {\\n                for i in stride(from: bottom, to: top - 1, by: -1) {\\n                    matrix[i][left] = num \\n                    num += 1\\n                }\\n            }\\n            left += 1\\n        }\\n        return matrix\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508767,
                "title": "java-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int [][] arr = new int[n][n];\\n        int size = 1;\\n        int rs=0, re=n-1, cs=0, ce=n-1;\\n        while(size <= n*n){\\n            for(int i=cs; i<=ce; i++){\\n                arr[rs][i] = size++;\\n            }\\n            rs++;\\n            for(int i=rs; i<=re; i++){\\n                arr[i][ce] = size++;\\n            }\\n            ce--;\\n            if(rs<=re){\\n                for(int i=ce; i>=cs; i--){\\n                    arr[re][i] = size++;\\n                }\\n                re--;\\n            }\\n            if(cs<=ce){\\n                for(int i=re; i>=rs; i--){\\n                    arr[i][cs] = size++;\\n                }\\n                cs++;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int [][] arr = new int[n][n];\\n        int size = 1;\\n        int rs=0, re=n-1, cs=0, ce=n-1;\\n        while(size <= n*n){\\n            for(int i=cs; i<=ce; i++){\\n                arr[rs][i] = size++;\\n            }\\n            rs++;\\n            for(int i=rs; i<=re; i++){\\n                arr[i][ce] = size++;\\n            }\\n            ce--;\\n            if(rs<=re){\\n                for(int i=ce; i>=cs; i--){\\n                    arr[re][i] = size++;\\n                }\\n                re--;\\n            }\\n            if(cs<=ce){\\n                for(int i=re; i>=rs; i--){\\n                    arr[i][cs] = size++;\\n                }\\n                cs++;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508582,
                "title": "c-simulation-solution-with-optimized-time-complexity",
                "content": "\\n\\n# Approach\\nThe given solution uses a simulation approach, where we keep track of the boundaries of the matrix using four variables: rowBegin, rowEnd, colBegin, and colEnd. We initialize these variables to 0 and n-1, as the first row and column are the boundaries of the matrix.\\n\\nWe then use a while loop to traverse the matrix in a spiral order. In each iteration of the loop, we traverse the matrix in four directions: right, down, left, and up. We use four for loops for this purpose, each of which increments or decrements one of the boundary variables, depending on the direction of traversal.\\n\\nAs we traverse the matrix, we fill in the elements with the values from 1 to n^2 in the order specified by the problem. We use a variable num to keep track of the value to be filled in each element. We increment this variable after each element is filled.\\n\\nOnce we have filled in all the elements of the matrix, we return the matrix as the final output.\\n\\n# Complexity\\n- Time complexity:\\n O(n^2) because we need to fill all n^2 elements of the matrix\\n\\n- Space complexity:\\nO(n^2) because we need to store the entire matrix.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n        int rowBegin = 0, rowEnd = n-1, colBegin = 0, colEnd = n-1;\\n        int num = 1;\\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            // traverse right\\n            for (int i = colBegin; i <= colEnd; ++i) {\\n                matrix[rowBegin][i] = num++;\\n            }\\n            ++rowBegin;\\n            \\n            // traverse down\\n            for (int i = rowBegin; i <= rowEnd; ++i) {\\n                matrix[i][colEnd] = num++;\\n            }\\n            --colEnd;\\n            \\n            // traverse left\\n            if (rowBegin <= rowEnd) {\\n                for (int i = colEnd; i >= colBegin; --i) {\\n                    matrix[rowEnd][i] = num++;\\n                }\\n            }\\n            --rowEnd;\\n            \\n            // traverse up\\n            if (colBegin <= colEnd) {\\n                for (int i = rowEnd; i >= rowBegin; --i) {\\n                    matrix[i][colBegin] = num++;\\n                }\\n            }\\n            ++colBegin;\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n        int rowBegin = 0, rowEnd = n-1, colBegin = 0, colEnd = n-1;\\n        int num = 1;\\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            // traverse right\\n            for (int i = colBegin; i <= colEnd; ++i) {\\n                matrix[rowBegin][i] = num++;\\n            }\\n            ++rowBegin;\\n            \\n            // traverse down\\n            for (int i = rowBegin; i <= rowEnd; ++i) {\\n                matrix[i][colEnd] = num++;\\n            }\\n            --colEnd;\\n            \\n            // traverse left\\n            if (rowBegin <= rowEnd) {\\n                for (int i = colEnd; i >= colBegin; --i) {\\n                    matrix[rowEnd][i] = num++;\\n                }\\n            }\\n            --rowEnd;\\n            \\n            // traverse up\\n            if (colBegin <= colEnd) {\\n                for (int i = rowEnd; i >= rowBegin; --i) {\\n                    matrix[i][colBegin] = num++;\\n                }\\n            }\\n            ++colBegin;\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507935,
                "title": "beats-100-c",
                "content": "![image.png](https://assets.leetcode.com/users/images/9885d1be-a40b-42c1-87b9-34306fc0e161_1683707490.7883291.png)\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n));\\n        int data=1;\\n        int top=0,bottom=n-1,left=0,right=n-1;\\n        while(left<=right && top<=bottom)\\n        {\\n            for(int i=left;i<=right;i++) {\\n                ans[top][i] = data++;\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++) {\\n                ans[i][right] = data++;\\n            }\\n            right--;\\n            if(top <= bottom) {\\n                for(int i=right;i>=left;i--) {\\n                    ans[bottom][i] = data++;\\n                }\\n                bottom--;\\n            }\\n            if(left<=right) {\\n                for(int i=bottom;i>=top;i--) {\\n                    ans[i][left] = data++;\\n                }\\n                left++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n));\\n        int data=1;\\n        int top=0,bottom=n-1,left=0,right=n-1;\\n        while(left<=right && top<=bottom)\\n        {\\n            for(int i=left;i<=right;i++) {\\n                ans[top][i] = data++;\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++) {\\n                ans[i][right] = data++;\\n            }\\n            right--;\\n            if(top <= bottom) {\\n                for(int i=right;i>=left;i--) {\\n                    ans[bottom][i] = data++;\\n                }\\n                bottom--;\\n            }\\n            if(left<=right) {\\n                for(int i=bottom;i>=top;i--) {\\n                    ans[i][left] = data++;\\n                }\\n                left++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507661,
                "title": "java-easy-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int top=0,bottom=n-1,left=0,right=n-1;\\n        int[][] ans = new int[n][n];\\n        int count=0;\\n        if(bottom==0){\\n            for(int i=left;i<=right;i++){\\n                count++;\\n                ans[bottom][i]=count;\\n            }\\n            return ans;\\n        }\\n        if(right==0){\\n            for(int j=top;j<=bottom;j++){\\n                count++;\\n                ans[j][right]=count;\\n            }\\n            return ans;\\n        }\\n        while(top<=bottom && left <=right){\\n            for(int i=left;i<=right;i++){\\n                count++;\\n                ans[top][i]=count;\\n            }\\n            top++;\\n\\n            for(int j=top;j<=bottom;j++){\\n                count++;\\n                ans[j][right]=count;\\n            }\\n            right--;\\n\\n            for(int k=right;k>=left;k--){\\n                count++;\\n                ans[bottom][k]=count;\\n            }\\n            bottom--;\\n\\n            for(int a=bottom;a>=top;a--){\\n                count++;\\n                ans[a][left]=count;\\n            }\\n            left++;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int top=0,bottom=n-1,left=0,right=n-1;\\n        int[][] ans = new int[n][n];\\n        int count=0;\\n        if(bottom==0){\\n            for(int i=left;i<=right;i++){\\n                count++;\\n                ans[bottom][i]=count;\\n            }\\n            return ans;\\n        }\\n        if(right==0){\\n            for(int j=top;j<=bottom;j++){\\n                count++;\\n                ans[j][right]=count;\\n            }\\n            return ans;\\n        }\\n        while(top<=bottom && left <=right){\\n            for(int i=left;i<=right;i++){\\n                count++;\\n                ans[top][i]=count;\\n            }\\n            top++;\\n\\n            for(int j=top;j<=bottom;j++){\\n                count++;\\n                ans[j][right]=count;\\n            }\\n            right--;\\n\\n            for(int k=right;k>=left;k--){\\n                count++;\\n                ans[bottom][k]=count;\\n            }\\n            bottom--;\\n\\n            for(int a=bottom;a>=top;a--){\\n                count++;\\n                ans[a][left]=count;\\n            }\\n            left++;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507492,
                "title": "my-java-o-n-2-solution-beats-100-of-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA simple and effective solution to create a matrix of size n x n with elements 1 to n^2 in a spiral order is to initialize the matrix with all zeros and then fill in the elements in the desired order by iterating through the matrix in a spiral pattern.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start by initializing a 2D matrix of size n x n with all zeros. We then define four variables: rowStart, rowEnd, colStart, and colEnd, which represent the starting and ending indices for the rows and columns that we need to fill in. We also define a variable num, which represents the current number we want to fill in the matrix.\\n\\nWe then use a while loop to iterate through the matrix in a spiral pattern. In each iteration of the loop, we fill in the elements in the current row and column that we need to fill in. We then update the corresponding rowStart, rowEnd, colStart, and colEnd variables to reflect the fact that we have filled in those rows and columns.\\n\\nWe continue this process until we have filled in all the elements in the matrix in the desired order.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\nThe time complexity of this solution is O(n^2) because it needs to fill in every cell of the n x n matrix. The while loop runs exactly n/2 times, and each iteration fills in 4 rows or columns, which takes O(n) time. Therefore, the total time complexity is O(n/2 * 4n) = O(n^2).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n\\nThe space complexity of this solution is O(n^2) because the program needs to create an n x n matrix to store the result. No additional data structures are used, and the space required for the loop variables and integer counters is negligible compared to the size of the matrix.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] generateMatrix(int n) {\\n        // Declaration\\n        int[][] matrix = new int[n][n];\\n        \\n        // Edge Case\\n        if (n == 0) {\\n            return matrix;\\n        }\\n        \\n        // Normal Case\\n        int rowStart = 0;\\n        int rowEnd = n-1;\\n        int colStart = 0;\\n        int colEnd = n-1;\\n        int num = 1; //change\\n        \\n        while (rowStart <= rowEnd && colStart <= colEnd) {\\n            for (int i = colStart; i <= colEnd; i ++) {\\n                matrix[rowStart][i] = num ++; //change\\n            }\\n            rowStart ++;\\n            \\n            for (int i = rowStart; i <= rowEnd; i ++) {\\n                matrix[i][colEnd] = num ++; //change\\n            }\\n            colEnd --;\\n            \\n            for (int i = colEnd; i >= colStart; i --) {\\n                if (rowStart <= rowEnd)\\n                    matrix[rowEnd][i] = num ++; //change\\n            }\\n            rowEnd --;\\n            \\n            for (int i = rowEnd; i >= rowStart; i --) {\\n                if (colStart <= colEnd)\\n                    matrix[i][colStart] = num ++; //change\\n            }\\n            colStart ++;\\n        }\\n        \\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] generateMatrix(int n) {\\n        // Declaration\\n        int[][] matrix = new int[n][n];\\n        \\n        // Edge Case\\n        if (n == 0) {\\n            return matrix;\\n        }\\n        \\n        // Normal Case\\n        int rowStart = 0;\\n        int rowEnd = n-1;\\n        int colStart = 0;\\n        int colEnd = n-1;\\n        int num = 1; //change\\n        \\n        while (rowStart <= rowEnd && colStart <= colEnd) {\\n            for (int i = colStart; i <= colEnd; i ++) {\\n                matrix[rowStart][i] = num ++; //change\\n            }\\n            rowStart ++;\\n            \\n            for (int i = rowStart; i <= rowEnd; i ++) {\\n                matrix[i][colEnd] = num ++; //change\\n            }\\n            colEnd --;\\n            \\n            for (int i = colEnd; i >= colStart; i --) {\\n                if (rowStart <= rowEnd)\\n                    matrix[rowEnd][i] = num ++; //change\\n            }\\n            rowEnd --;\\n            \\n            for (int i = rowEnd; i >= rowStart; i --) {\\n                if (colStart <= colEnd)\\n                    matrix[i][colStart] = num ++; //change\\n            }\\n            colStart ++;\\n        }\\n        \\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507353,
                "title": "0ms-easy-approach-beasts-100-step-by-step-explanation",
                "content": "# Intuition\\n\\nEasy approach to solve this question :) \\uD83D\\uDD25.\\n\\nWe mainly focus on the `top row`, `right column`, `bottom row` & `left column` after creating a blank matrix.\\nAfter every iteration we increamnt `starting row` & `starting column` and decrement `ending row` & `ending column`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- **Creating** a blank matrix of size m.\\n`int[][] ans = new int[n][n];`\\n- **Initializing** the values for smooth travelling in the matrix \\n```\\nint startingRow = 0;\\nint endingRow = n - 1;\\nint startingCol = 0;\\nint endingCol = n - 1;\\n```\\n- For **Top Row** `Left -> Right` -> as we go left to right then we increament the values then we go to next row. i.e. `startingRow++`\\n```\\nfor (int i = startingCol; i <= endingCol; i++) {\\n        ans[startingRow][i] = count;\\n        count++;\\n    }\\n    startingRow++;\\n```\\n- For **Right Column** `Top-->Bottom` --> after the top row, for every next row we go with the last index value of every column, till last second row. Then decrement the ending column index  i.e. `endingCol--`.\\n```\\nfor (int i = startingRow; i <= endingRow; i++) {\\n        ans[i][endingCol] = count;\\n        count++;\\n    }\\n    endingCol--;\\n```\\n- For **Bottom Row** `Right-->LEft` --> we go right to left then we decrement the ending column variable. i.e. `endingCol--`.\\n```\\nfor (int i = endingCol; i >= startingCol; i--) {\\n        ans[endingRow][i] = count;\\n        count++;\\n    }\\n    endingRow--;\\n```\\n- For **Left Column** `Bottom-->Top` --> after the botto row, for every above row we go with the first index value till the top second row. Then we increment the first index of every column i.e. `startingCol++` . \\n```\\nfor (int i = endingRow; i >= startingRow; i--) {\\n        ans[i][startingCol] = count;\\n        count++;   \\n    }\\n    startingCol++;\\n```\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/f9496ec6-b5f3-4fd9-83af-4a801efab4ef_1683697175.891551.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n                \\n        int[][] ans = new int[n][n];\\n        \\n        int count = 1;\\n        int total = n * n;\\n        \\n        int startingRow = 0;\\n        int endingRow = n - 1;\\n        int startingCol = 0;\\n        int endingCol = n - 1;\\n        \\n        while (count <= total) {\\n            \\n            // Top row\\n            for (int i = startingCol; i <= endingCol; i++) {\\n                ans[startingRow][i] = count;\\n                count++;\\n            }\\n            startingRow++;\\n            \\n            // Right row\\n            for (int i = startingRow; i <= endingRow; i++) {\\n                ans[i][endingCol] = count;\\n                count++;\\n            }\\n            endingCol--;\\n            \\n            //  Bottom row \\n            for (int i = endingCol; i >= startingCol; i--) {\\n                ans[endingRow][i] = count;\\n                count++;\\n            }\\n            endingRow--;\\n            \\n            //   Left column\\n            for (int i = endingRow; i >= startingRow; i--) {\\n                ans[i][startingCol] = count;\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Simulation",
                    "Iterator"
                ],
                "code": "```\\nint startingRow = 0;\\nint endingRow = n - 1;\\nint startingCol = 0;\\nint endingCol = n - 1;\\n```\n```\\nfor (int i = startingCol; i <= endingCol; i++) {\\n        ans[startingRow][i] = count;\\n        count++;\\n    }\\n    startingRow++;\\n```\n```\\nfor (int i = startingRow; i <= endingRow; i++) {\\n        ans[i][endingCol] = count;\\n        count++;\\n    }\\n    endingCol--;\\n```\n```\\nfor (int i = endingCol; i >= startingCol; i--) {\\n        ans[endingRow][i] = count;\\n        count++;\\n    }\\n    endingRow--;\\n```\n```\\nfor (int i = endingRow; i >= startingRow; i--) {\\n        ans[i][startingCol] = count;\\n        count++;   \\n    }\\n    startingCol++;\\n```\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n                \\n        int[][] ans = new int[n][n];\\n        \\n        int count = 1;\\n        int total = n * n;\\n        \\n        int startingRow = 0;\\n        int endingRow = n - 1;\\n        int startingCol = 0;\\n        int endingCol = n - 1;\\n        \\n        while (count <= total) {\\n            \\n            // Top row\\n            for (int i = startingCol; i <= endingCol; i++) {\\n                ans[startingRow][i] = count;\\n                count++;\\n            }\\n            startingRow++;\\n            \\n            // Right row\\n            for (int i = startingRow; i <= endingRow; i++) {\\n                ans[i][endingCol] = count;\\n                count++;\\n            }\\n            endingCol--;\\n            \\n            //  Bottom row \\n            for (int i = endingCol; i >= startingCol; i--) {\\n                ans[endingRow][i] = count;\\n                count++;\\n            }\\n            endingRow--;\\n            \\n            //   Left column\\n            for (int i = endingRow; i >= startingRow; i--) {\\n                ans[i][startingCol] = count;\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507277,
                "title": "solution-with-easy-understandable-logics",
                "content": "# Approach \\nCreating 2D array and storing sequence of numbers incremented by 1 starting at 1 in spiral order\\n# Institution\\n[Made by using logics from solution of this problem](https://leetcode.com/problems/spiral-matrix/solutions/3503965/beats-99-with-scomplexity/)\\n\\n\\n >BY  Seeker of Miracle\\n# Complexity\\n- Time complexity:O(n^2) \\n- Space complexity:O(n^2)\\nWhere n is length of one axis in matrix\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar generateMatrix = function(n) {\\n    // MATRIX[Y][X]\\n    //    ---------\\n    //Y0 | 1  2  3 |\\n    //Y1 | 4  5  6 |\\n    //Y2 | 7  8  9 |\\n    //    ---------\\n    //     X0 X1 X2\\n    \\n    let matrix=[],count=0,x=0,y=0;\\n    const maxElements=n*n;\\n\\n    for(let i=0; i<n;i++)\\n    {\\n        matrix[i]= new Array()\\n    }\\n\\n    while(maxElements>count)\\n    {\\n        for(let i=x; maxElements>count && i<n-x;i++)\\n        {\\n            count++;\\n            matrix[y][i]=count\\n            // console.log(1, matrix[y][i])\\n        }\\n        y++;\\n\\n        for(let i=y; maxElements>count && i<n-(y-1);i++)\\n        {\\n            count++;\\n            matrix[i][(n-1) - x]=count;\\n            // console.log(2, matrix[i][(n-1) - x])\\n        }\\n        x++;\\n\\n        for(let i=(n-1)-x; maxElements>count && i>=x-1; i--)\\n        {\\n            count++;\\n            matrix[(n-1)-(y-1)][i]=count;\\n            // console.log(3, matrix[(n-1)-(y-1)][i])\\n        }\\n\\n        for(let i=(n-1)-y; maxElements>count && i>=y; i--)\\n        {\\n            count++;\\n            matrix[i][x-1]=count\\n            // console.log(4, matrix[i][x-1])\\n        }\\n    }\\n    return matrix;\\n};\\n```\\n*I am happy if you leave your comments below as advise in order to improve my code*",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar generateMatrix = function(n) {\\n    // MATRIX[Y][X]\\n    //    ---------\\n    //Y0 | 1  2  3 |\\n    //Y1 | 4  5  6 |\\n    //Y2 | 7  8  9 |\\n    //    ---------\\n    //     X0 X1 X2\\n    \\n    let matrix=[],count=0,x=0,y=0;\\n    const maxElements=n*n;\\n\\n    for(let i=0; i<n;i++)\\n    {\\n        matrix[i]= new Array()\\n    }\\n\\n    while(maxElements>count)\\n    {\\n        for(let i=x; maxElements>count && i<n-x;i++)\\n        {\\n            count++;\\n            matrix[y][i]=count\\n            // console.log(1, matrix[y][i])\\n        }\\n        y++;\\n\\n        for(let i=y; maxElements>count && i<n-(y-1);i++)\\n        {\\n            count++;\\n            matrix[i][(n-1) - x]=count;\\n            // console.log(2, matrix[i][(n-1) - x])\\n        }\\n        x++;\\n\\n        for(let i=(n-1)-x; maxElements>count && i>=x-1; i--)\\n        {\\n            count++;\\n            matrix[(n-1)-(y-1)][i]=count;\\n            // console.log(3, matrix[(n-1)-(y-1)][i])\\n        }\\n\\n        for(let i=(n-1)-y; maxElements>count && i>=y; i--)\\n        {\\n            count++;\\n            matrix[i][x-1]=count\\n            // console.log(4, matrix[i][x-1])\\n        }\\n    }\\n    return matrix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3507180,
                "title": "beginner-friendly-solution-in-cpp-beats-100-in-time-and-90-in-space",
                "content": "\\n# Complexity\\n- Time complexity: $$(N * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$(N * N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> generateMatrix(int n)\\n    {\\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        int row = 0, col = 0, number = 1, c = 0;\\n        while (c < (n + 1) / 2) // Filling the matrix in squares, starting from the outermost and then going inwards\\n        {\\n            row = sqr_count, col = sqr_count;\\n            for (; col < n - sqr_count - 1; col++) // Going from first element of the square to the second last in that row\\n                ans[row][col] = number++;\\n            for (; row < n - sqr_count - 1; row++) // Going from the last row element(first in the column) to the second last in that column\\n                ans[row][col] = number++;\\n            for (; col > sqr_count; col--) // From the last element in the last column(last row element) to the second element in the bottom row\\n                ans[row][col] = number++;\\n            for (; row > sqr_count; row--) // From the last element in the last row,(last column element) to the second element in the first column\\n                ans[row][col] = number++;\\n            sqr_count++;\\n        }\\n        if (n & 1)  // If the order of matrix is odd set the maximum in the center\\n            ans[n / 2][n / 2] = r;\\n        return ans;\\n    }\\n};\\n```\\n## Do upvote, if it helped",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> generateMatrix(int n)\\n    {\\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        int row = 0, col = 0, number = 1, c = 0;\\n        while (c < (n + 1) / 2) // Filling the matrix in squares, starting from the outermost and then going inwards\\n        {\\n            row = sqr_count, col = sqr_count;\\n            for (; col < n - sqr_count - 1; col++) // Going from first element of the square to the second last in that row\\n                ans[row][col] = number++;\\n            for (; row < n - sqr_count - 1; row++) // Going from the last row element(first in the column) to the second last in that column\\n                ans[row][col] = number++;\\n            for (; col > sqr_count; col--) // From the last element in the last column(last row element) to the second element in the bottom row\\n                ans[row][col] = number++;\\n            for (; row > sqr_count; row--) // From the last element in the last row,(last column element) to the second element in the first column\\n                ans[row][col] = number++;\\n            sqr_count++;\\n        }\\n        if (n & 1)  // If the order of matrix is odd set the maximum in the center\\n            ans[n / 2][n / 2] = r;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507106,
                "title": "daily-faster-than-100-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n, vector<int>(n));\\n        int top=0, down=n-1, left=0, right=n-1;\\n        int c=1;\\n        while(top<=down and left<=right){\\n            for(int i=left; i<=right; i++){\\n                ans[top][i]=c++;\\n            }\\n            top++;\\n            for(int i=top; i<=down; i++){\\n                ans[i][right]=c++;\\n            }\\n            right--;\\n            for(int i=right; i>=left; i--){\\n                ans[down][i]=c++;\\n            }\\n            down--;\\n            for(int i=down; i>=top; i--){\\n                ans[i][left]=c++;\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n, vector<int>(n));\\n        int top=0, down=n-1, left=0, right=n-1;\\n        int c=1;\\n        while(top<=down and left<=right){\\n            for(int i=left; i<=right; i++){\\n                ans[top][i]=c++;\\n            }\\n            top++;\\n            for(int i=top; i<=down; i++){\\n                ans[i][right]=c++;\\n            }\\n            right--;\\n            for(int i=right; i>=left; i--){\\n                ans[down][i]=c++;\\n            }\\n            down--;\\n            for(int i=down; i>=top; i--){\\n                ans[i][left]=c++;\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506922,
                "title": "python-short-and-clean-iterative-solution",
                "content": "# Approach\\n1. Reuse the `inwards_spiral` function from [Spiral Matrix I](https://leetcode.com/problems/spiral-matrix/solutions/1467615/python-short-and-clean-iterative-solution/?orderBy=most_votes) to generate indices in spiral order.\\n\\n2. Zip through indices and counter, assigning count to the corresponding index of the `matrix`.\\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n\\n- Space complexity: $$O(1)$$, ignoring the returned list.\\n\\nwhere,\\n`m * n is the dimensions of matrix.`\\n\\n# Code\\n```python\\nclass Solution:\\n    def generateMatrix(self, n: int) -> list[list[int]]:\\n        \\n        def inwards_spiral(m: int, n: int) -> Iterator[Tuple[int, int]]:\\n            \"\"\"Return list of (i, j) indices of a m * n matrix in spiral order\"\"\"\\n            \\n            for k in range((min(m, n) + 1) // 2):\\n                (i1, j1), (i2, j2) = (k, k), (m - k - 1, n - k - 1)\\n                \\n                if (i1, j1) == (i2, j2): yield (i1, j1); return                                 # Center\\n                \\n                yield from ((i1, j) for j in range(j1, j2))                                     # Left to Right\\n                yield from ((i, j2) for i in range(i1, i2))                                     # Top to Bottom\\n                yield from ((i2, j) for j in range(j2, j1, -1)) if i1 != i2 else ((i2, j2),)    # Right to Left\\n                yield from ((i, j1) for i in range(i2, i1, -1)) if j1 != j2 else ((i2, j1),)    # Bottom to Top\\n        \\n        matrix = [[0] * n for _ in range(n)]\\n        for (i, j), x in zip(inwards_spiral(n, n), count(1)): matrix[i][j] = x\\n        return matrix\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```python\\nclass Solution:\\n    def generateMatrix(self, n: int) -> list[list[int]]:\\n        \\n        def inwards_spiral(m: int, n: int) -> Iterator[Tuple[int, int]]:\\n            \"\"\"Return list of (i, j) indices of a m * n matrix in spiral order\"\"\"\\n            \\n            for k in range((min(m, n) + 1) // 2):\\n                (i1, j1), (i2, j2) = (k, k), (m - k - 1, n - k - 1)\\n                \\n                if (i1, j1) == (i2, j2): yield (i1, j1); return                                 # Center\\n                \\n                yield from ((i1, j) for j in range(j1, j2))                                     # Left to Right\\n                yield from ((i, j2) for i in range(i1, i2))                                     # Top to Bottom\\n                yield from ((i2, j) for j in range(j2, j1, -1)) if i1 != i2 else ((i2, j2),)    # Right to Left\\n                yield from ((i, j1) for i in range(i2, i1, -1)) if j1 != j2 else ((i2, j1),)    # Bottom to Top\\n        \\n        matrix = [[0] * n for _ in range(n)]\\n        for (i, j), x in zip(inwards_spiral(n, n), count(1)): matrix[i][j] = x\\n        return matrix\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506910,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>m(n,vector<int>(n,0));\\n        int c=1;\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            \\n                for(int i=left;i<=right;i++){\\n                    m[top][i]=c;\\n                    c++;\\n                }\\n                top++;\\n                for(int i=top;i<=bottom;i++){\\n                   m[i][right]=c;\\n                    c++; \\n                }\\n                right--;\\n                for(int i=right;i>=left;i--){\\n                    m[bottom][i]=c;\\n                    c++;\\n                }\\n                bottom--;\\n                for(int i=bottom;i>=top;i--){\\n                   m[i][left]=c;\\n                    c++; \\n                }\\n                left++;\\n        }\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>m(n,vector<int>(n,0));\\n        int c=1;\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            \\n                for(int i=left;i<=right;i++){\\n                    m[top][i]=c;\\n                    c++;\\n                }\\n                top++;\\n                for(int i=top;i<=bottom;i++){\\n                   m[i][right]=c;\\n                    c++; \\n                }\\n                right--;\\n                for(int i=right;i>=left;i--){\\n                    m[bottom][i]=c;\\n                    c++;\\n                }\\n                bottom--;\\n                for(int i=bottom;i>=top;i--){\\n                   m[i][left]=c;\\n                    c++; \\n                }\\n                left++;\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506897,
                "title": "direct-approach-java-0ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int arr[][] = new int[n][n];\\n\\n        int count = 1;\\n        int k = 0;\\n        int l = 0;\\n        int t = 0;\\n        for (int i = k; i < n; i++) {\\n            for(int j=l;j<n;j++){\\n                arr[t][j] = count++;\\n            }\\n            t++;\\n            for(int j=t;j<n;j++){\\n                arr[j][n-1] = count++;\\n            }\\n            t--;\\n            for(int j=n-2;j>=t;j--){\\n                arr[n-1][j] = count++;\\n            }\\n            t++;\\n            for(int j=n-2;j>=t;j--){\\n                arr[j][t-1] = count++;\\n            }\\n            n--;\\n            l++;\\n        }\\n\\n        return arr;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int arr[][] = new int[n][n];\\n\\n        int count = 1;\\n        int k = 0;\\n        int l = 0;\\n        int t = 0;\\n        for (int i = k; i < n; i++) {\\n            for(int j=l;j<n;j++){\\n                arr[t][j] = count++;\\n            }\\n            t++;\\n            for(int j=t;j<n;j++){\\n                arr[j][n-1] = count++;\\n            }\\n            t--;\\n            for(int j=n-2;j>=t;j--){\\n                arr[n-1][j] = count++;\\n            }\\n            t++;\\n            for(int j=n-2;j>=t;j--){\\n                arr[j][t-1] = count++;\\n            }\\n            n--;\\n            l++;\\n        }\\n\\n        return arr;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506795,
                "title": "java-solution-for-spiral-matrix-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to use four loops, each representing a direction (right, down, left, up) to fill the matrix in a spiral order. The loops move along the outer boundaries of the matrix and increment the current number to be filled.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize variables: total to store the total number of elements in the matrix, result to store the generated matrix, x and y as the current positions in the matrix, and step to keep track of the current boundary step.\\n- Use a loop that runs until i reaches the total number of elements.\\n- Within the loop, move right until reaching the end of the current row, fill the current position with the next number, and increment i.\\n- Adjust the position and repeat the process for moving down, left, and up, respectively.\\n- Update step after completing one spiral loop to move to the inner boundaries of the matrix.\\n- Repeat the steps until all elements are filled.\\n- Return the generated matrix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n^2), where n is the given input. It iterates over each element in the matrix exactly once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n^2) as well since the solution creates a 2D matrix of size n x n to store the generated matrix.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int total = n*n;\\n        int[][] result= new int[n][n];\\n        int x=0;\\n        int y=0;\\n        int step = 0;\\n        for(int i=0;i<total;)\\n        {\\n            while(y+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y++;\\n            }\\n            y--;\\n            x++;\\n            while(x+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x++;\\n            }\\n            x--;\\n            y--;\\n            while(y>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y--;\\n            }\\n            y++;\\n            x--;\\n            step++;\\n            while(x>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x--;\\n            }\\n            x++;\\n            y++;\\n        }\\n        return result;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int total = n*n;\\n        int[][] result= new int[n][n];\\n        int x=0;\\n        int y=0;\\n        int step = 0;\\n        for(int i=0;i<total;)\\n        {\\n            while(y+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y++;\\n            }\\n            y--;\\n            x++;\\n            while(x+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x++;\\n            }\\n            x--;\\n            y--;\\n            while(y>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y--;\\n            }\\n            y++;\\n            x--;\\n            step++;\\n            while(x>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x--;\\n            }\\n            x++;\\n            y++;\\n        }\\n        return result;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506662,
                "title": "c-easy-implementation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int k=1;\\n        int top,bottom,left,right;\\n        vector<vector<int>> matrix(n, vector<int> (n));\\n        top=left=0;\\n        right=bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            for(int i=left;i<=right;i++){\\n                matrix[top][i]=k++;\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                matrix[i][right]=k++;\\n            }\\n            right--;\\n            for(int i=right;i>=left;i--){\\n                matrix[bottom][i]=k++;\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                matrix[i][left]=k++;\\n            }\\n            left++;\\n        }\\n        return matrix;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int k=1;\\n        int top,bottom,left,right;\\n        vector<vector<int>> matrix(n, vector<int> (n));\\n        top=left=0;\\n        right=bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            for(int i=left;i<=right;i++){\\n                matrix[top][i]=k++;\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                matrix[i][right]=k++;\\n            }\\n            right--;\\n            for(int i=right;i>=left;i--){\\n                matrix[bottom][i]=k++;\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                matrix[i][left]=k++;\\n            }\\n            left++;\\n        }\\n        return matrix;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506430,
                "title": "daily-leetcoding-challenge-may-day-10",
                "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3505265,
                "title": "c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n*n)\\n\\n# Code\\n```\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, std::vector<int>(n, 0));\\n\\n        int rowTop = 0;\\n        int rowBottom = matrix.size() - 1;\\n        int columnLeft = 0;\\n        int columnRight = matrix.size() - 1;\\n\\n        int num = 1;\\n        while (true) {\\n            // right\\n            for (int i = columnLeft; i <= columnRight; i++) {\\n                matrix[rowTop][i] = num++;\\n            }\\n            rowTop++;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n\\n            // down\\n            for (int i = rowTop; i <= rowBottom; i++) {\\n                matrix[i][columnRight] = num++;\\n            }\\n            columnRight--;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n\\n            // left\\n            for (int i = columnRight; i >= columnLeft; i--) {\\n                matrix[rowBottom][i] = num++;\\n            }\\n            rowBottom--;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n\\n            // up\\n            for (int i = rowBottom; i >= rowTop; i--) {\\n                matrix[i][columnLeft] = num++;\\n            }\\n            columnLeft++;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, std::vector<int>(n, 0));\\n\\n        int rowTop = 0;\\n        int rowBottom = matrix.size() - 1;\\n        int columnLeft = 0;\\n        int columnRight = matrix.size() - 1;\\n\\n        int num = 1;\\n        while (true) {\\n            // right\\n            for (int i = columnLeft; i <= columnRight; i++) {\\n                matrix[rowTop][i] = num++;\\n            }\\n            rowTop++;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n\\n            // down\\n            for (int i = rowTop; i <= rowBottom; i++) {\\n                matrix[i][columnRight] = num++;\\n            }\\n            columnRight--;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n\\n            // left\\n            for (int i = columnRight; i >= columnLeft; i--) {\\n                matrix[rowBottom][i] = num++;\\n            }\\n            rowBottom--;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n\\n            // up\\n            for (int i = rowBottom; i >= rowTop; i--) {\\n                matrix[i][columnLeft] = num++;\\n            }\\n            columnLeft++;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3345184,
                "title": "c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int x=1;\\n        int i=0,j=0;\\n        int p=n,q=n;\\n        while(i<=p&&j<=q){\\n            for(int k=j;k<q;k++) {\\n               ans[i][k]=x;\\n               x++;\\n            }\\n            i++;\\n            for(int k=i;k<p;k++){\\n                ans[k][q-1]=x;\\n                x++;\\n            }\\n            q--;\\n            for(int k=q-1;k>=j;k--){\\n                ans[p-1][k]=x;\\n                x++;\\n            }\\n            p--;\\n            for(int k=p-1;k>=i;k--){\\n                ans[k][j]=x;\\n                x++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int x=1;\\n        int i=0,j=0;\\n        int p=n,q=n;\\n        while(i<=p&&j<=q){\\n            for(int k=j;k<q;k++) {\\n               ans[i][k]=x;\\n               x++;\\n            }\\n            i++;\\n            for(int k=i;k<p;k++){\\n                ans[k][q-1]=x;\\n                x++;\\n            }\\n            q--;\\n            for(int k=q-1;k>=j;k--){\\n                ans[p-1][k]=x;\\n                x++;\\n            }\\n            p--;\\n            for(int k=p-1;k>=i;k--){\\n                ans[k][j]=x;\\n                x++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1888784,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888659,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1710044,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888670,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1717655,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1567118,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888833,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888861,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888672,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1754605,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888784,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888659,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1710044,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888670,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1717655,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1567118,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888833,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888861,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888672,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1754605,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1889104,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1889078,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 2072367,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 2026817,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1993751,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1984801,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1901066,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1889605,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1889361,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1889347,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1889341,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1889319,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1889286,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1889196,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1889166,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1889133,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1889100,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1889008,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1888971,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1888924,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1888912,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888878,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888847,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888816,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888812,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888799,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888776,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888721,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888715,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888677,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            }
        ]
    },
    {
        "title": "Longest Substring with At Most Two Distinct Characters",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1566840,
                "content": [
                    {
                        "username": "suhanovsergey",
                        "content": "https://leetcode.com/problems/fruit-into-baskets. That one is marked as Medium however."
                    },
                    {
                        "username": "gaurav1903",
                        "content": "the only troubling thing about this question is that they decided to use uppercase as well as lowercase letters in the testcases"
                    },
                    {
                        "username": "sk4142",
                        "content": "Same as 340 except k = 2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Practice \\uD83D\\uDCAA\\uD83C\\uDFFC a little bit of `Variable Size Sliding Window` problems. Then this problem will feel like a piece of cake \\uD83C\\uDF70"
                    }
                ]
            },
            {
                "id": 1775696,
                "content": [
                    {
                        "username": "suhanovsergey",
                        "content": "https://leetcode.com/problems/fruit-into-baskets. That one is marked as Medium however."
                    },
                    {
                        "username": "gaurav1903",
                        "content": "the only troubling thing about this question is that they decided to use uppercase as well as lowercase letters in the testcases"
                    },
                    {
                        "username": "sk4142",
                        "content": "Same as 340 except k = 2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Practice \\uD83D\\uDCAA\\uD83C\\uDFFC a little bit of `Variable Size Sliding Window` problems. Then this problem will feel like a piece of cake \\uD83C\\uDF70"
                    }
                ]
            },
            {
                "id": 1979186,
                "content": [
                    {
                        "username": "suhanovsergey",
                        "content": "https://leetcode.com/problems/fruit-into-baskets. That one is marked as Medium however."
                    },
                    {
                        "username": "gaurav1903",
                        "content": "the only troubling thing about this question is that they decided to use uppercase as well as lowercase letters in the testcases"
                    },
                    {
                        "username": "sk4142",
                        "content": "Same as 340 except k = 2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Practice \\uD83D\\uDCAA\\uD83C\\uDFFC a little bit of `Variable Size Sliding Window` problems. Then this problem will feel like a piece of cake \\uD83C\\uDF70"
                    }
                ]
            },
            {
                "id": 1803117,
                "content": [
                    {
                        "username": "suhanovsergey",
                        "content": "https://leetcode.com/problems/fruit-into-baskets. That one is marked as Medium however."
                    },
                    {
                        "username": "gaurav1903",
                        "content": "the only troubling thing about this question is that they decided to use uppercase as well as lowercase letters in the testcases"
                    },
                    {
                        "username": "sk4142",
                        "content": "Same as 340 except k = 2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Practice \\uD83D\\uDCAA\\uD83C\\uDFFC a little bit of `Variable Size Sliding Window` problems. Then this problem will feel like a piece of cake \\uD83C\\uDF70"
                    }
                ]
            }
        ]
    },
    {
        "title": "3Sum Smaller",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565372,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "I was under the impression that 0 <= i < j < k < n and this applied to the vector coming in. If you sort the numbers, the indices are scrambled. All the solutions are sorting, so I must be misreading the problem... not sure how though..."
                    },
                    {
                        "username": "peachisamomoco",
                        "content": "I'm wondering what if the problem asks us to find the number of distinct triplets, instead of number of index triplets. Can we still solve it in O(n^2)? What's the good way to do it?"
                    },
                    {
                        "username": "miterl",
                        "content": "Agreed with [@Zak Coder](/zakcoder). The problem requires 0 <= i < j < k < n while i, j and k are apparently referring to the original indexes, and you lost them by sorting unless you save them somewhere.\\nIf the official problem description is correct, all the editorial solutions and most of the sorting based solutions actually solved a wrong problem: find the number of any 3-elements combinations such that the sum < target, thus the restriction \"0 <= i < j < k < n\" is meaningless."
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It only asks for the count and not the list of indices."
                    },
                    {
                        "username": "fpolica91",
                        "content": "This is a truly disappointingly wrong description. It is almost painful to derive to the answer as my initial understanding was different. In any case, if you have been solving the 3sum problems, what we are being asked in basically `ans+= abs(right - left);` that is the answer, not the number of occurrences of elements that are less than target.\\n\\nCheers"
                    },
                    {
                        "username": "lennonli999",
                        "content": "why starting from i+1 ends at  nums.length -2?\\n\\nfor (int i = 0; i < nums.length - 2; i++) {\\n            sum += twoSumSmaller(nums, i + 1, target - nums[i]);\\n        }"
                    }
                ]
            },
            {
                "id": 1571498,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "I was under the impression that 0 <= i < j < k < n and this applied to the vector coming in. If you sort the numbers, the indices are scrambled. All the solutions are sorting, so I must be misreading the problem... not sure how though..."
                    },
                    {
                        "username": "peachisamomoco",
                        "content": "I'm wondering what if the problem asks us to find the number of distinct triplets, instead of number of index triplets. Can we still solve it in O(n^2)? What's the good way to do it?"
                    },
                    {
                        "username": "miterl",
                        "content": "Agreed with [@Zak Coder](/zakcoder). The problem requires 0 <= i < j < k < n while i, j and k are apparently referring to the original indexes, and you lost them by sorting unless you save them somewhere.\\nIf the official problem description is correct, all the editorial solutions and most of the sorting based solutions actually solved a wrong problem: find the number of any 3-elements combinations such that the sum < target, thus the restriction \"0 <= i < j < k < n\" is meaningless."
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It only asks for the count and not the list of indices."
                    },
                    {
                        "username": "fpolica91",
                        "content": "This is a truly disappointingly wrong description. It is almost painful to derive to the answer as my initial understanding was different. In any case, if you have been solving the 3sum problems, what we are being asked in basically `ans+= abs(right - left);` that is the answer, not the number of occurrences of elements that are less than target.\\n\\nCheers"
                    },
                    {
                        "username": "lennonli999",
                        "content": "why starting from i+1 ends at  nums.length -2?\\n\\nfor (int i = 0; i < nums.length - 2; i++) {\\n            sum += twoSumSmaller(nums, i + 1, target - nums[i]);\\n        }"
                    }
                ]
            },
            {
                "id": 1847614,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "I was under the impression that 0 <= i < j < k < n and this applied to the vector coming in. If you sort the numbers, the indices are scrambled. All the solutions are sorting, so I must be misreading the problem... not sure how though..."
                    },
                    {
                        "username": "peachisamomoco",
                        "content": "I'm wondering what if the problem asks us to find the number of distinct triplets, instead of number of index triplets. Can we still solve it in O(n^2)? What's the good way to do it?"
                    },
                    {
                        "username": "miterl",
                        "content": "Agreed with [@Zak Coder](/zakcoder). The problem requires 0 <= i < j < k < n while i, j and k are apparently referring to the original indexes, and you lost them by sorting unless you save them somewhere.\\nIf the official problem description is correct, all the editorial solutions and most of the sorting based solutions actually solved a wrong problem: find the number of any 3-elements combinations such that the sum < target, thus the restriction \"0 <= i < j < k < n\" is meaningless."
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It only asks for the count and not the list of indices."
                    },
                    {
                        "username": "fpolica91",
                        "content": "This is a truly disappointingly wrong description. It is almost painful to derive to the answer as my initial understanding was different. In any case, if you have been solving the 3sum problems, what we are being asked in basically `ans+= abs(right - left);` that is the answer, not the number of occurrences of elements that are less than target.\\n\\nCheers"
                    },
                    {
                        "username": "lennonli999",
                        "content": "why starting from i+1 ends at  nums.length -2?\\n\\nfor (int i = 0; i < nums.length - 2; i++) {\\n            sum += twoSumSmaller(nums, i + 1, target - nums[i]);\\n        }"
                    }
                ]
            },
            {
                "id": 1789850,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "I was under the impression that 0 <= i < j < k < n and this applied to the vector coming in. If you sort the numbers, the indices are scrambled. All the solutions are sorting, so I must be misreading the problem... not sure how though..."
                    },
                    {
                        "username": "peachisamomoco",
                        "content": "I'm wondering what if the problem asks us to find the number of distinct triplets, instead of number of index triplets. Can we still solve it in O(n^2)? What's the good way to do it?"
                    },
                    {
                        "username": "miterl",
                        "content": "Agreed with [@Zak Coder](/zakcoder). The problem requires 0 <= i < j < k < n while i, j and k are apparently referring to the original indexes, and you lost them by sorting unless you save them somewhere.\\nIf the official problem description is correct, all the editorial solutions and most of the sorting based solutions actually solved a wrong problem: find the number of any 3-elements combinations such that the sum < target, thus the restriction \"0 <= i < j < k < n\" is meaningless."
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It only asks for the count and not the list of indices."
                    },
                    {
                        "username": "fpolica91",
                        "content": "This is a truly disappointingly wrong description. It is almost painful to derive to the answer as my initial understanding was different. In any case, if you have been solving the 3sum problems, what we are being asked in basically `ans+= abs(right - left);` that is the answer, not the number of occurrences of elements that are less than target.\\n\\nCheers"
                    },
                    {
                        "username": "lennonli999",
                        "content": "why starting from i+1 ends at  nums.length -2?\\n\\nfor (int i = 0; i < nums.length - 2; i++) {\\n            sum += twoSumSmaller(nums, i + 1, target - nums[i]);\\n        }"
                    }
                ]
            },
            {
                "id": 1624445,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "I was under the impression that 0 <= i < j < k < n and this applied to the vector coming in. If you sort the numbers, the indices are scrambled. All the solutions are sorting, so I must be misreading the problem... not sure how though..."
                    },
                    {
                        "username": "peachisamomoco",
                        "content": "I'm wondering what if the problem asks us to find the number of distinct triplets, instead of number of index triplets. Can we still solve it in O(n^2)? What's the good way to do it?"
                    },
                    {
                        "username": "miterl",
                        "content": "Agreed with [@Zak Coder](/zakcoder). The problem requires 0 <= i < j < k < n while i, j and k are apparently referring to the original indexes, and you lost them by sorting unless you save them somewhere.\\nIf the official problem description is correct, all the editorial solutions and most of the sorting based solutions actually solved a wrong problem: find the number of any 3-elements combinations such that the sum < target, thus the restriction \"0 <= i < j < k < n\" is meaningless."
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It only asks for the count and not the list of indices."
                    },
                    {
                        "username": "fpolica91",
                        "content": "This is a truly disappointingly wrong description. It is almost painful to derive to the answer as my initial understanding was different. In any case, if you have been solving the 3sum problems, what we are being asked in basically `ans+= abs(right - left);` that is the answer, not the number of occurrences of elements that are less than target.\\n\\nCheers"
                    },
                    {
                        "username": "lennonli999",
                        "content": "why starting from i+1 ends at  nums.length -2?\\n\\nfor (int i = 0; i < nums.length - 2; i++) {\\n            sum += twoSumSmaller(nums, i + 1, target - nums[i]);\\n        }"
                    }
                ]
            }
        ]
    },
    {
        "title": "Logger Rate Limiter",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1573233,
                "content": [
                    {
                        "username": "codekumar",
                        "content": "The problem basically is simple if we are going to consider only a single thread. Set plus queue based solution is fine but however the task of cleaning up the memory has to be done by the thread that request to log the message. This is unnecessary an overhead for a user  thread that does logging operation. \\n\\nLets say that there are multiple threads who are simultaneiously calling the shouldPrintMessage(), if the messages are different then obviously we have to store them all in the set. Now the question is how are we going to clean up this set as the size can increase indefinately. We may use a lock based approach and lock the set but this  makes the system unresponsive as other threads will block till the cleaner thread cleans some entries of the set and clears memory.\\n\\n**Epoch Based Approach:**\\nA epoch basically is an identifier during which some insertions happens on a paritcular set.\\nWe have 3 sets dedicated to 3 epochs. Lets say, set A for epoch 0, set B for epoch 1 and set C for epoch 2.\\n\\nWe basically have two housekeeping threads. First one is memory cleaner(Garbage collector) and second one is EpochActivator.\\n\\nEpochActivator thread wakes up every 10 seconds and does an operation like active_epoch = (active_epoch + 1)  % 3.\\n\\nWhen a thread wants to insert a message in the set, it checks if the message is present in the set belonging to current active epoch as well as previous active epoch. If the message is present, then it calculates the difference and adds message to the current active epoch  if the difference between time is greater than 10. \\n\\nThe garbage collector wakes periodically every 10 seconds and deletes the set which is 2 epochs behind the active epoch.\\n\\n\\nThis is one of the way we can implement a lock-free highly responsive logger for multiple threads.\\n"
                    },
                    {
                        "username": "queenkicker",
                        "content": "In your approach, are the 3 sets running on different threads? What happens if the message you are trying to add is not in the active_epoch (A) or previous active (B) set, i.e., it is in C."
                    },
                    {
                        "username": "Erick111",
                        "content": "Considering it's a problem from Google, I really want to know: where is the follow-up?"
                    },
                    {
                        "username": "xiaolucunzi",
                        "content": "The first test case is like this:\\n\\n[\"Logger\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\"]\\n[[],[1,\"foo\"],[2,\"bar\"],[3,\"foo\"],[8,\"bar\"],[10,\"foo\"],[11,\"foo\"]]\\n\\nThe expected results are [null,true,true,false,false,false,true].\\n\\nThe last expected result should NOT be true becasue result[\"foo\"] =1,  result[\"foo\"] = 3, then result[\"foo\"]  = 10,  However, last test result[\"foo\"] = 11, and the delta is only 1 different from previous message \"foo\" timestamp, NOT > 10. So the value of the last expected result should be false."
                    },
                    {
                        "username": "user1193uB",
                        "content": "10 seconds is the next eligible time to be true, meaning 10 seconds past the first true response the log is eligible to be logged again. With the logic you presented, if a log request comes across every second it will never actually log after the first instance whereas the rules ask for it to be eligible to be logged again after 10 seconds. \\n\\n- [1,\"foo\"] is true\\n- [3,\"foo\"] is false because its within 10 seconds of that last log event\\n- [11,\"foo\"] is true because its the first \"foo\" log request to come across at 10+ seconds since the first."
                    },
                    {
                        "username": "cyph0r",
                        "content": "The test cases are correct, there is a difference of 10 units in the emission of first \"Foo\" and 11th \"Foo\""
                    },
                    {
                        "username": "rsbh",
                        "content": "Here is the follow up question for this\n\nQuestion: If duplicate messages come within a 10secs window then discard previous and current Message.\nThe solution for this question will be given using Linked list and a MAP. A map to store the last reference of the message and linked list to print those messages later. This question has been recently asked in FAANG."
                    },
                    {
                        "username": "queenkicker",
                        "content": "Then that changes the API right. You have one method to `void addMessage(timestamp, message)` and another to `list<string> flush(timestamp)`. And they need to be synchronized. "
                    },
                    {
                        "username": "Basic_CoderLearner",
                        "content": "In the interview, I came up with Queue + map solution similar to yours.\\nIts tricky.\\nBut later on brainstormed & found that in Map we need to keep range of conflicting intervals. So when we are clearing our queue we should check if that message lies in the conflicting range"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "There should be a follow up question on this, I believe. If we design a log rate limiter like this it\\'s can burn down the heap memory and bring the application down :D\\nThere should be some cron job or something which would clean up the map on regular interval. That interval depends on how frequently we print logs. If we have limited variety of log messages then extra cron job is not needed. We can actually run this in lower environment and see how large this can grow and take logical decision. This could be a hot topic for tech discussion. "
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "Is this a phone screen question or an onsite? And for what level?"
                    }
                ]
            },
            {
                "id": 1571634,
                "content": [
                    {
                        "username": "codekumar",
                        "content": "The problem basically is simple if we are going to consider only a single thread. Set plus queue based solution is fine but however the task of cleaning up the memory has to be done by the thread that request to log the message. This is unnecessary an overhead for a user  thread that does logging operation. \\n\\nLets say that there are multiple threads who are simultaneiously calling the shouldPrintMessage(), if the messages are different then obviously we have to store them all in the set. Now the question is how are we going to clean up this set as the size can increase indefinately. We may use a lock based approach and lock the set but this  makes the system unresponsive as other threads will block till the cleaner thread cleans some entries of the set and clears memory.\\n\\n**Epoch Based Approach:**\\nA epoch basically is an identifier during which some insertions happens on a paritcular set.\\nWe have 3 sets dedicated to 3 epochs. Lets say, set A for epoch 0, set B for epoch 1 and set C for epoch 2.\\n\\nWe basically have two housekeeping threads. First one is memory cleaner(Garbage collector) and second one is EpochActivator.\\n\\nEpochActivator thread wakes up every 10 seconds and does an operation like active_epoch = (active_epoch + 1)  % 3.\\n\\nWhen a thread wants to insert a message in the set, it checks if the message is present in the set belonging to current active epoch as well as previous active epoch. If the message is present, then it calculates the difference and adds message to the current active epoch  if the difference between time is greater than 10. \\n\\nThe garbage collector wakes periodically every 10 seconds and deletes the set which is 2 epochs behind the active epoch.\\n\\n\\nThis is one of the way we can implement a lock-free highly responsive logger for multiple threads.\\n"
                    },
                    {
                        "username": "queenkicker",
                        "content": "In your approach, are the 3 sets running on different threads? What happens if the message you are trying to add is not in the active_epoch (A) or previous active (B) set, i.e., it is in C."
                    },
                    {
                        "username": "Erick111",
                        "content": "Considering it's a problem from Google, I really want to know: where is the follow-up?"
                    },
                    {
                        "username": "xiaolucunzi",
                        "content": "The first test case is like this:\\n\\n[\"Logger\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\"]\\n[[],[1,\"foo\"],[2,\"bar\"],[3,\"foo\"],[8,\"bar\"],[10,\"foo\"],[11,\"foo\"]]\\n\\nThe expected results are [null,true,true,false,false,false,true].\\n\\nThe last expected result should NOT be true becasue result[\"foo\"] =1,  result[\"foo\"] = 3, then result[\"foo\"]  = 10,  However, last test result[\"foo\"] = 11, and the delta is only 1 different from previous message \"foo\" timestamp, NOT > 10. So the value of the last expected result should be false."
                    },
                    {
                        "username": "user1193uB",
                        "content": "10 seconds is the next eligible time to be true, meaning 10 seconds past the first true response the log is eligible to be logged again. With the logic you presented, if a log request comes across every second it will never actually log after the first instance whereas the rules ask for it to be eligible to be logged again after 10 seconds. \\n\\n- [1,\"foo\"] is true\\n- [3,\"foo\"] is false because its within 10 seconds of that last log event\\n- [11,\"foo\"] is true because its the first \"foo\" log request to come across at 10+ seconds since the first."
                    },
                    {
                        "username": "cyph0r",
                        "content": "The test cases are correct, there is a difference of 10 units in the emission of first \"Foo\" and 11th \"Foo\""
                    },
                    {
                        "username": "rsbh",
                        "content": "Here is the follow up question for this\n\nQuestion: If duplicate messages come within a 10secs window then discard previous and current Message.\nThe solution for this question will be given using Linked list and a MAP. A map to store the last reference of the message and linked list to print those messages later. This question has been recently asked in FAANG."
                    },
                    {
                        "username": "queenkicker",
                        "content": "Then that changes the API right. You have one method to `void addMessage(timestamp, message)` and another to `list<string> flush(timestamp)`. And they need to be synchronized. "
                    },
                    {
                        "username": "Basic_CoderLearner",
                        "content": "In the interview, I came up with Queue + map solution similar to yours.\\nIts tricky.\\nBut later on brainstormed & found that in Map we need to keep range of conflicting intervals. So when we are clearing our queue we should check if that message lies in the conflicting range"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "There should be a follow up question on this, I believe. If we design a log rate limiter like this it\\'s can burn down the heap memory and bring the application down :D\\nThere should be some cron job or something which would clean up the map on regular interval. That interval depends on how frequently we print logs. If we have limited variety of log messages then extra cron job is not needed. We can actually run this in lower environment and see how large this can grow and take logical decision. This could be a hot topic for tech discussion. "
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "Is this a phone screen question or an onsite? And for what level?"
                    }
                ]
            },
            {
                "id": 1570043,
                "content": [
                    {
                        "username": "codekumar",
                        "content": "The problem basically is simple if we are going to consider only a single thread. Set plus queue based solution is fine but however the task of cleaning up the memory has to be done by the thread that request to log the message. This is unnecessary an overhead for a user  thread that does logging operation. \\n\\nLets say that there are multiple threads who are simultaneiously calling the shouldPrintMessage(), if the messages are different then obviously we have to store them all in the set. Now the question is how are we going to clean up this set as the size can increase indefinately. We may use a lock based approach and lock the set but this  makes the system unresponsive as other threads will block till the cleaner thread cleans some entries of the set and clears memory.\\n\\n**Epoch Based Approach:**\\nA epoch basically is an identifier during which some insertions happens on a paritcular set.\\nWe have 3 sets dedicated to 3 epochs. Lets say, set A for epoch 0, set B for epoch 1 and set C for epoch 2.\\n\\nWe basically have two housekeeping threads. First one is memory cleaner(Garbage collector) and second one is EpochActivator.\\n\\nEpochActivator thread wakes up every 10 seconds and does an operation like active_epoch = (active_epoch + 1)  % 3.\\n\\nWhen a thread wants to insert a message in the set, it checks if the message is present in the set belonging to current active epoch as well as previous active epoch. If the message is present, then it calculates the difference and adds message to the current active epoch  if the difference between time is greater than 10. \\n\\nThe garbage collector wakes periodically every 10 seconds and deletes the set which is 2 epochs behind the active epoch.\\n\\n\\nThis is one of the way we can implement a lock-free highly responsive logger for multiple threads.\\n"
                    },
                    {
                        "username": "queenkicker",
                        "content": "In your approach, are the 3 sets running on different threads? What happens if the message you are trying to add is not in the active_epoch (A) or previous active (B) set, i.e., it is in C."
                    },
                    {
                        "username": "Erick111",
                        "content": "Considering it's a problem from Google, I really want to know: where is the follow-up?"
                    },
                    {
                        "username": "xiaolucunzi",
                        "content": "The first test case is like this:\\n\\n[\"Logger\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\"]\\n[[],[1,\"foo\"],[2,\"bar\"],[3,\"foo\"],[8,\"bar\"],[10,\"foo\"],[11,\"foo\"]]\\n\\nThe expected results are [null,true,true,false,false,false,true].\\n\\nThe last expected result should NOT be true becasue result[\"foo\"] =1,  result[\"foo\"] = 3, then result[\"foo\"]  = 10,  However, last test result[\"foo\"] = 11, and the delta is only 1 different from previous message \"foo\" timestamp, NOT > 10. So the value of the last expected result should be false."
                    },
                    {
                        "username": "user1193uB",
                        "content": "10 seconds is the next eligible time to be true, meaning 10 seconds past the first true response the log is eligible to be logged again. With the logic you presented, if a log request comes across every second it will never actually log after the first instance whereas the rules ask for it to be eligible to be logged again after 10 seconds. \\n\\n- [1,\"foo\"] is true\\n- [3,\"foo\"] is false because its within 10 seconds of that last log event\\n- [11,\"foo\"] is true because its the first \"foo\" log request to come across at 10+ seconds since the first."
                    },
                    {
                        "username": "cyph0r",
                        "content": "The test cases are correct, there is a difference of 10 units in the emission of first \"Foo\" and 11th \"Foo\""
                    },
                    {
                        "username": "rsbh",
                        "content": "Here is the follow up question for this\n\nQuestion: If duplicate messages come within a 10secs window then discard previous and current Message.\nThe solution for this question will be given using Linked list and a MAP. A map to store the last reference of the message and linked list to print those messages later. This question has been recently asked in FAANG."
                    },
                    {
                        "username": "queenkicker",
                        "content": "Then that changes the API right. You have one method to `void addMessage(timestamp, message)` and another to `list<string> flush(timestamp)`. And they need to be synchronized. "
                    },
                    {
                        "username": "Basic_CoderLearner",
                        "content": "In the interview, I came up with Queue + map solution similar to yours.\\nIts tricky.\\nBut later on brainstormed & found that in Map we need to keep range of conflicting intervals. So when we are clearing our queue we should check if that message lies in the conflicting range"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "There should be a follow up question on this, I believe. If we design a log rate limiter like this it\\'s can burn down the heap memory and bring the application down :D\\nThere should be some cron job or something which would clean up the map on regular interval. That interval depends on how frequently we print logs. If we have limited variety of log messages then extra cron job is not needed. We can actually run this in lower environment and see how large this can grow and take logical decision. This could be a hot topic for tech discussion. "
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "Is this a phone screen question or an onsite? And for what level?"
                    }
                ]
            },
            {
                "id": 1823927,
                "content": [
                    {
                        "username": "codekumar",
                        "content": "The problem basically is simple if we are going to consider only a single thread. Set plus queue based solution is fine but however the task of cleaning up the memory has to be done by the thread that request to log the message. This is unnecessary an overhead for a user  thread that does logging operation. \\n\\nLets say that there are multiple threads who are simultaneiously calling the shouldPrintMessage(), if the messages are different then obviously we have to store them all in the set. Now the question is how are we going to clean up this set as the size can increase indefinately. We may use a lock based approach and lock the set but this  makes the system unresponsive as other threads will block till the cleaner thread cleans some entries of the set and clears memory.\\n\\n**Epoch Based Approach:**\\nA epoch basically is an identifier during which some insertions happens on a paritcular set.\\nWe have 3 sets dedicated to 3 epochs. Lets say, set A for epoch 0, set B for epoch 1 and set C for epoch 2.\\n\\nWe basically have two housekeeping threads. First one is memory cleaner(Garbage collector) and second one is EpochActivator.\\n\\nEpochActivator thread wakes up every 10 seconds and does an operation like active_epoch = (active_epoch + 1)  % 3.\\n\\nWhen a thread wants to insert a message in the set, it checks if the message is present in the set belonging to current active epoch as well as previous active epoch. If the message is present, then it calculates the difference and adds message to the current active epoch  if the difference between time is greater than 10. \\n\\nThe garbage collector wakes periodically every 10 seconds and deletes the set which is 2 epochs behind the active epoch.\\n\\n\\nThis is one of the way we can implement a lock-free highly responsive logger for multiple threads.\\n"
                    },
                    {
                        "username": "queenkicker",
                        "content": "In your approach, are the 3 sets running on different threads? What happens if the message you are trying to add is not in the active_epoch (A) or previous active (B) set, i.e., it is in C."
                    },
                    {
                        "username": "Erick111",
                        "content": "Considering it's a problem from Google, I really want to know: where is the follow-up?"
                    },
                    {
                        "username": "xiaolucunzi",
                        "content": "The first test case is like this:\\n\\n[\"Logger\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\"]\\n[[],[1,\"foo\"],[2,\"bar\"],[3,\"foo\"],[8,\"bar\"],[10,\"foo\"],[11,\"foo\"]]\\n\\nThe expected results are [null,true,true,false,false,false,true].\\n\\nThe last expected result should NOT be true becasue result[\"foo\"] =1,  result[\"foo\"] = 3, then result[\"foo\"]  = 10,  However, last test result[\"foo\"] = 11, and the delta is only 1 different from previous message \"foo\" timestamp, NOT > 10. So the value of the last expected result should be false."
                    },
                    {
                        "username": "user1193uB",
                        "content": "10 seconds is the next eligible time to be true, meaning 10 seconds past the first true response the log is eligible to be logged again. With the logic you presented, if a log request comes across every second it will never actually log after the first instance whereas the rules ask for it to be eligible to be logged again after 10 seconds. \\n\\n- [1,\"foo\"] is true\\n- [3,\"foo\"] is false because its within 10 seconds of that last log event\\n- [11,\"foo\"] is true because its the first \"foo\" log request to come across at 10+ seconds since the first."
                    },
                    {
                        "username": "cyph0r",
                        "content": "The test cases are correct, there is a difference of 10 units in the emission of first \"Foo\" and 11th \"Foo\""
                    },
                    {
                        "username": "rsbh",
                        "content": "Here is the follow up question for this\n\nQuestion: If duplicate messages come within a 10secs window then discard previous and current Message.\nThe solution for this question will be given using Linked list and a MAP. A map to store the last reference of the message and linked list to print those messages later. This question has been recently asked in FAANG."
                    },
                    {
                        "username": "queenkicker",
                        "content": "Then that changes the API right. You have one method to `void addMessage(timestamp, message)` and another to `list<string> flush(timestamp)`. And they need to be synchronized. "
                    },
                    {
                        "username": "Basic_CoderLearner",
                        "content": "In the interview, I came up with Queue + map solution similar to yours.\\nIts tricky.\\nBut later on brainstormed & found that in Map we need to keep range of conflicting intervals. So when we are clearing our queue we should check if that message lies in the conflicting range"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "There should be a follow up question on this, I believe. If we design a log rate limiter like this it\\'s can burn down the heap memory and bring the application down :D\\nThere should be some cron job or something which would clean up the map on regular interval. That interval depends on how frequently we print logs. If we have limited variety of log messages then extra cron job is not needed. We can actually run this in lower environment and see how large this can grow and take logical decision. This could be a hot topic for tech discussion. "
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "Is this a phone screen question or an onsite? And for what level?"
                    }
                ]
            },
            {
                "id": 1693749,
                "content": [
                    {
                        "username": "codekumar",
                        "content": "The problem basically is simple if we are going to consider only a single thread. Set plus queue based solution is fine but however the task of cleaning up the memory has to be done by the thread that request to log the message. This is unnecessary an overhead for a user  thread that does logging operation. \\n\\nLets say that there are multiple threads who are simultaneiously calling the shouldPrintMessage(), if the messages are different then obviously we have to store them all in the set. Now the question is how are we going to clean up this set as the size can increase indefinately. We may use a lock based approach and lock the set but this  makes the system unresponsive as other threads will block till the cleaner thread cleans some entries of the set and clears memory.\\n\\n**Epoch Based Approach:**\\nA epoch basically is an identifier during which some insertions happens on a paritcular set.\\nWe have 3 sets dedicated to 3 epochs. Lets say, set A for epoch 0, set B for epoch 1 and set C for epoch 2.\\n\\nWe basically have two housekeeping threads. First one is memory cleaner(Garbage collector) and second one is EpochActivator.\\n\\nEpochActivator thread wakes up every 10 seconds and does an operation like active_epoch = (active_epoch + 1)  % 3.\\n\\nWhen a thread wants to insert a message in the set, it checks if the message is present in the set belonging to current active epoch as well as previous active epoch. If the message is present, then it calculates the difference and adds message to the current active epoch  if the difference between time is greater than 10. \\n\\nThe garbage collector wakes periodically every 10 seconds and deletes the set which is 2 epochs behind the active epoch.\\n\\n\\nThis is one of the way we can implement a lock-free highly responsive logger for multiple threads.\\n"
                    },
                    {
                        "username": "queenkicker",
                        "content": "In your approach, are the 3 sets running on different threads? What happens if the message you are trying to add is not in the active_epoch (A) or previous active (B) set, i.e., it is in C."
                    },
                    {
                        "username": "Erick111",
                        "content": "Considering it's a problem from Google, I really want to know: where is the follow-up?"
                    },
                    {
                        "username": "xiaolucunzi",
                        "content": "The first test case is like this:\\n\\n[\"Logger\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\"]\\n[[],[1,\"foo\"],[2,\"bar\"],[3,\"foo\"],[8,\"bar\"],[10,\"foo\"],[11,\"foo\"]]\\n\\nThe expected results are [null,true,true,false,false,false,true].\\n\\nThe last expected result should NOT be true becasue result[\"foo\"] =1,  result[\"foo\"] = 3, then result[\"foo\"]  = 10,  However, last test result[\"foo\"] = 11, and the delta is only 1 different from previous message \"foo\" timestamp, NOT > 10. So the value of the last expected result should be false."
                    },
                    {
                        "username": "user1193uB",
                        "content": "10 seconds is the next eligible time to be true, meaning 10 seconds past the first true response the log is eligible to be logged again. With the logic you presented, if a log request comes across every second it will never actually log after the first instance whereas the rules ask for it to be eligible to be logged again after 10 seconds. \\n\\n- [1,\"foo\"] is true\\n- [3,\"foo\"] is false because its within 10 seconds of that last log event\\n- [11,\"foo\"] is true because its the first \"foo\" log request to come across at 10+ seconds since the first."
                    },
                    {
                        "username": "cyph0r",
                        "content": "The test cases are correct, there is a difference of 10 units in the emission of first \"Foo\" and 11th \"Foo\""
                    },
                    {
                        "username": "rsbh",
                        "content": "Here is the follow up question for this\n\nQuestion: If duplicate messages come within a 10secs window then discard previous and current Message.\nThe solution for this question will be given using Linked list and a MAP. A map to store the last reference of the message and linked list to print those messages later. This question has been recently asked in FAANG."
                    },
                    {
                        "username": "queenkicker",
                        "content": "Then that changes the API right. You have one method to `void addMessage(timestamp, message)` and another to `list<string> flush(timestamp)`. And they need to be synchronized. "
                    },
                    {
                        "username": "Basic_CoderLearner",
                        "content": "In the interview, I came up with Queue + map solution similar to yours.\\nIts tricky.\\nBut later on brainstormed & found that in Map we need to keep range of conflicting intervals. So when we are clearing our queue we should check if that message lies in the conflicting range"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "There should be a follow up question on this, I believe. If we design a log rate limiter like this it\\'s can burn down the heap memory and bring the application down :D\\nThere should be some cron job or something which would clean up the map on regular interval. That interval depends on how frequently we print logs. If we have limited variety of log messages then extra cron job is not needed. We can actually run this in lower environment and see how large this can grow and take logical decision. This could be a hot topic for tech discussion. "
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "Is this a phone screen question or an onsite? And for what level?"
                    }
                ]
            },
            {
                "id": 1931162,
                "content": [
                    {
                        "username": "codekumar",
                        "content": "The problem basically is simple if we are going to consider only a single thread. Set plus queue based solution is fine but however the task of cleaning up the memory has to be done by the thread that request to log the message. This is unnecessary an overhead for a user  thread that does logging operation. \\n\\nLets say that there are multiple threads who are simultaneiously calling the shouldPrintMessage(), if the messages are different then obviously we have to store them all in the set. Now the question is how are we going to clean up this set as the size can increase indefinately. We may use a lock based approach and lock the set but this  makes the system unresponsive as other threads will block till the cleaner thread cleans some entries of the set and clears memory.\\n\\n**Epoch Based Approach:**\\nA epoch basically is an identifier during which some insertions happens on a paritcular set.\\nWe have 3 sets dedicated to 3 epochs. Lets say, set A for epoch 0, set B for epoch 1 and set C for epoch 2.\\n\\nWe basically have two housekeeping threads. First one is memory cleaner(Garbage collector) and second one is EpochActivator.\\n\\nEpochActivator thread wakes up every 10 seconds and does an operation like active_epoch = (active_epoch + 1)  % 3.\\n\\nWhen a thread wants to insert a message in the set, it checks if the message is present in the set belonging to current active epoch as well as previous active epoch. If the message is present, then it calculates the difference and adds message to the current active epoch  if the difference between time is greater than 10. \\n\\nThe garbage collector wakes periodically every 10 seconds and deletes the set which is 2 epochs behind the active epoch.\\n\\n\\nThis is one of the way we can implement a lock-free highly responsive logger for multiple threads.\\n"
                    },
                    {
                        "username": "queenkicker",
                        "content": "In your approach, are the 3 sets running on different threads? What happens if the message you are trying to add is not in the active_epoch (A) or previous active (B) set, i.e., it is in C."
                    },
                    {
                        "username": "Erick111",
                        "content": "Considering it's a problem from Google, I really want to know: where is the follow-up?"
                    },
                    {
                        "username": "xiaolucunzi",
                        "content": "The first test case is like this:\\n\\n[\"Logger\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\"]\\n[[],[1,\"foo\"],[2,\"bar\"],[3,\"foo\"],[8,\"bar\"],[10,\"foo\"],[11,\"foo\"]]\\n\\nThe expected results are [null,true,true,false,false,false,true].\\n\\nThe last expected result should NOT be true becasue result[\"foo\"] =1,  result[\"foo\"] = 3, then result[\"foo\"]  = 10,  However, last test result[\"foo\"] = 11, and the delta is only 1 different from previous message \"foo\" timestamp, NOT > 10. So the value of the last expected result should be false."
                    },
                    {
                        "username": "user1193uB",
                        "content": "10 seconds is the next eligible time to be true, meaning 10 seconds past the first true response the log is eligible to be logged again. With the logic you presented, if a log request comes across every second it will never actually log after the first instance whereas the rules ask for it to be eligible to be logged again after 10 seconds. \\n\\n- [1,\"foo\"] is true\\n- [3,\"foo\"] is false because its within 10 seconds of that last log event\\n- [11,\"foo\"] is true because its the first \"foo\" log request to come across at 10+ seconds since the first."
                    },
                    {
                        "username": "cyph0r",
                        "content": "The test cases are correct, there is a difference of 10 units in the emission of first \"Foo\" and 11th \"Foo\""
                    },
                    {
                        "username": "rsbh",
                        "content": "Here is the follow up question for this\n\nQuestion: If duplicate messages come within a 10secs window then discard previous and current Message.\nThe solution for this question will be given using Linked list and a MAP. A map to store the last reference of the message and linked list to print those messages later. This question has been recently asked in FAANG."
                    },
                    {
                        "username": "queenkicker",
                        "content": "Then that changes the API right. You have one method to `void addMessage(timestamp, message)` and another to `list<string> flush(timestamp)`. And they need to be synchronized. "
                    },
                    {
                        "username": "Basic_CoderLearner",
                        "content": "In the interview, I came up with Queue + map solution similar to yours.\\nIts tricky.\\nBut later on brainstormed & found that in Map we need to keep range of conflicting intervals. So when we are clearing our queue we should check if that message lies in the conflicting range"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "There should be a follow up question on this, I believe. If we design a log rate limiter like this it\\'s can burn down the heap memory and bring the application down :D\\nThere should be some cron job or something which would clean up the map on regular interval. That interval depends on how frequently we print logs. If we have limited variety of log messages then extra cron job is not needed. We can actually run this in lower environment and see how large this can grow and take logical decision. This could be a hot topic for tech discussion. "
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "Is this a phone screen question or an onsite? And for what level?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Repeated Substring Pattern",
        "question_content": "<p>Given a string <code>s</code>, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abab&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> It is the substring &quot;ab&quot; twice.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aba&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcabcabcabc&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> It is the substring &quot;abc&quot; four times or the substring &quot;abcabc&quot; twice.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 94334,
                "title": "easy-python-solution-with-explaination",
                "content": "Basic idea:\\n\\n1) First char of input string is first char of repeated substring\\n2) Last char of input string is last char of repeated substring\\n3) Let S1 = S + S (where S in input string)\\n4) Remove 1 and last char of S1. Let this be S2\\n5) If S exists in S2 then return true else false\\n6) Let i be index in S2 where S starts then repeated substring length i + 1 and repeated substring S[0: i+1] \\n\\n```\\ndef repeatedSubstringPattern(self, str):\\n\\n        \"\"\"\\n        :type str: str\\n        :rtype: bool\\n        \"\"\"\\n        if not str:\\n            return False\\n            \\n        ss = (str + str)[1:-1]\\n        return ss.find(str) != -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef repeatedSubstringPattern(self, str):\\n\\n        \"\"\"\\n        :type str: str\\n        :rtype: bool\\n        \"\"\"\\n        if not str:\\n            return False\\n            \\n        ss = (str + str)[1:-1]\\n        return ss.find(str) != -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 94352,
                "title": "java-simple-solution-with-explanation",
                "content": "```\\npublic boolean repeatedSubstringPattern(String str) {\\n\\tint l = str.length();\\n\\tfor(int i=l/2;i>=1;i--) {\\n\\t\\tif(l%i==0) {\\n\\t\\t\\tint m = l/i;\\n\\t\\t\\tString subS = str.substring(0,i);\\n\\t\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\t\\tfor(int j=0;j<m;j++) {\\n\\t\\t\\t\\tsb.append(subS);\\n\\t\\t\\t}\\n\\t\\t\\tif(sb.toString().equals(str)) return true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```\\n1. The length of the repeating substring must be a divisor of the length of the input string\\n2. Search for all possible divisor of `str.length`, starting for `length/2`\\n3. If `i` is a divisor of `length`, repeat the substring from `0` to `i` the number of times `i` is contained in `s.length`\\n4. If the repeated substring is equals to the input `str` return `true`",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean repeatedSubstringPattern(String str) {\\n\\tint l = str.length();\\n\\tfor(int i=l/2;i>=1;i--) {\\n\\t\\tif(l%i==0) {\\n\\t\\t\\tint m = l/i;\\n\\t\\t\\tString subS = str.substring(0,i);\\n\\t\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\t\\tfor(int j=0;j<m;j++) {\\n\\t\\t\\t\\tsb.append(subS);\\n\\t\\t\\t}\\n\\t\\t\\tif(sb.toString().equals(str)) return true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94344,
                "title": "simple-java-solution-2-lines",
                "content": "```\\n    public boolean repeatedSubstringPattern(String str) {\\n        String s = str + str;\\n        return s.substring(1, s.length() - 1).contains(str);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean repeatedSubstringPattern(String str) {\\n        String s = str + str;\\n        return s.substring(1, s.length() - 1).contains(str);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94397,
                "title": "c-o-n-using-kmp-32ms-8-lines-of-code-with-brief-explanation",
                "content": "First, we build the KMP table. \\n1) Roughly speaking, dp[i+1] stores the maximum number of characters that the string is repeating itself up to position i.\\n2) Therefore, if a string repeats a length 5 substring 4 times, then the last entry would be of value 15.\\n3) To check if the string is repeating itself, we just need the last entry to be non-zero and  str.size() to divide (str.size()-last entry).\\n```\\n    bool repeatedSubstringPattern(string str) {\\n        int i = 1, j = 0, n = str.size();\\n        vector<int> dp(n+1,0);\\n        while( i < str.size() ){\\n            if( str[i] == str[j] ) dp[++i]=++j;\\n            else if( j == 0 ) i++;\\n            else j = dp[j];\\n        }\\n        return dp[n]&&dp[n]%(n-dp[n])==0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool repeatedSubstringPattern(string str) {\\n        int i = 1, j = 0, n = str.size();\\n        vector<int> dp(n+1,0);\\n        while( i < str.size() ){\\n            if( str[i] == str[j] ) dp[++i]=++j;\\n            else if( j == 0 ) i++;\\n            else j = dp[j];\\n        }\\n        return dp[n]&&dp[n]%(n-dp[n])==0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94360,
                "title": "my-one-line-c-solution",
                "content": "```\\nbool repeatedSubstringPattern(string str) \\n    {\\n        return (str + str).substr(1, str.size() * 2 - 2).find(str)!=-1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool repeatedSubstringPattern(string str) \\n    {\\n        return (str + str).substr(1, str.size() * 2 - 2).find(str)!=-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 826151,
                "title": "python-c-java-js-go-by-fold-and-find-w-simple-proof",
                "content": "![image](https://assets.leetcode.com/users/images/258103c9-2305-4e2a-812c-c585d1572ffa_1599127928.421695.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/917ae175-a569-4ce9-b648-77d6ebbde4bc_1599126979.9700963.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/70f0370c-f4dc-45f5-b780-b529525b8703_1599127500.4632437.png)\\n\\n---\\n\\n**Hint**:\\n\\na.\\nFold, make **s_fold** = s[ 1 : ] + s[ : -1 ]\\n\\nb.\\nCheck whether we can find **s** in **s_fold** or not\\n\\nIf s has repeated substring pattern, then we can find s in s_fold.\\nOtherwise, s cannot be found.\\n\\n---\\n\\n**Example & Demo**:\\n\\n#1.\\ns = \\'abab\\'\\ns_fold = \\'bababa\\'\\n\\nwe can find s in s_fold, where s_fold = \\'b**abab**a\\'\\n\\n---\\n\\n#2.\\n\\ns = \\'abac\\'\\ns_fold = \\'bacaba\\'\\n\\nwe cannot find s in s_fold, where s_fold = \\'bacaba\\'\\n\\n---\\n\\n**Implementation**:\\n\\n**Python**:\\n\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        \\n        s_fold = \"\".join( (s[1:], s[:-1]) )\\n        \\n        return s in s_fold\\n```\\n\\n---\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        \\n        int size = s.size();\\n        \\n        string postfix = s.substr(1, size-1);\\n        string prefix = s.substr(0, size-1);\\n        \\n        string sFold = postfix + prefix;\\n        \\n        return sFold.find(s) != string::npos;\\n    }\\n};\\n```\\n\\n---\\n\\n**Java**:\\n\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        \\n        int size = s.length();\\n        \\n        String sFold = s.substring(1, size) + s.substring(0, size-1);\\n        \\n        return sFold.contains(s);\\n        \\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript**:\\n\\n```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    \\n    let size = s.length;\\n    let sFold = s.substr(1, size) + s.substr(0, size-1);\\n    \\n    return sFold.indexOf( s ) != -1;\\n};\\n```\\n\\n---\\n\\n**Golang**:\\n\\n```\\nfunc repeatedSubstringPattern(s string) bool {\\n    \\n    size := len(s)\\n    sFold := s[1:size] + s[0:size-1]\\n    \\n    return strings.Contains(sFold, s)\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        \\n        s_fold = \"\".join( (s[1:], s[:-1]) )\\n        \\n        return s in s_fold\\n```\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        \\n        int size = s.size();\\n        \\n        string postfix = s.substr(1, size-1);\\n        string prefix = s.substr(0, size-1);\\n        \\n        string sFold = postfix + prefix;\\n        \\n        return sFold.find(s) != string::npos;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        \\n        int size = s.length();\\n        \\n        String sFold = s.substring(1, size) + s.substring(0, size-1);\\n        \\n        return sFold.contains(s);\\n        \\n    }\\n}\\n```\n```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    \\n    let size = s.length;\\n    let sFold = s.substr(1, size) + s.substr(0, size-1);\\n    \\n    return sFold.indexOf( s ) != -1;\\n};\\n```\n```\\nfunc repeatedSubstringPattern(s string) bool {\\n    \\n    size := len(s)\\n    sFold := s[1:size] + s[0:size-1]\\n    \\n    return strings.Contains(sFold, s)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938580,
                "title": "99-42-2-approaches-o-n",
                "content": "# Problem Understanding\\n\\nIn the \"459. Repeated Substring Pattern\" problem, we are given a string `s`. The task is to check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.\\n\\nFor instance, given the string `s = \"abab\"`, the output should be `True` as it is constructed by repeating the substring \"ab\" twice.\\n\\n**Input**: \"abab\"\\n**Output**: True\\n\\n---\\n\\n# Live Coding v1 & v2:\\nhttps://youtu.be/RweTIFVSVck\\n\\n- [in Python \\uD83D\\uDC0D](https://youtu.be/RweTIFVSVck)\\n- [in Go \\uD83D\\uDC39](https://youtu.be/DeCw5VFDWaI)\\n\\n# Approach 1/2: Check All Possible Substrings\\n\\nTo solve the \"459. Repeated Substring Pattern\" problem, we iterate over all possible substring lengths (from 1 to `len(s)//2`). For each length, we check if the string can be constructed by repeating that substring.\\n\\n## Key Data Structures:\\n- **Substring**: To hold the possible substring that could be repeated to form the string `s`.\\n\\n## Enhanced Breakdown:\\n\\n1. **Initialization**:\\n   - Start from the first character.\\n   \\n2. **Processing Each Substring**:\\n   - For each possible length of substring, check if repeating that substring forms the original string.\\n\\n3. **Wrap-up**:\\n   - Return `True` if any such substring is found, otherwise `False`.\\n\\n## Example:\\n\\nGiven the string \"abcabc\":\\n\\n1. First check with substring \"a\" - Does not form the original string.\\n2. Next, check with substring \"ab\" - Does not form the original string.\\n3. Finally, check with substring \"abc\" - Forms the original string. Hence, return `True`.\\n\\n---\\n\\n# Approach 2/2: Clever String Manipulation\\n\\nThe idea behind this approach is that if a string `s` can be constructed by repeating a substring, then concatenating two copies of `s` together and removing the first and last character would still contain `s` as a substring.\\n\\n## Key Data Structures:\\n- **Concatenated String**: A string formed by concatenating `s` with itself.\\n\\n## Enhanced Breakdown:\\n\\n1. **Initialization**:\\n   - Concatenate string `s` with itself.\\n   \\n2. **Check for Repeated Pattern**:\\n   - Remove the first and last character from the concatenated string and check if the original string `s` is present.\\n\\n3. **Wrap-up**:\\n   - Return `True` if the string is present, otherwise `False`.\\n\\n## Example:\\n\\nGiven the string \"abab\":\\n\\n1. Concatenate to get \"abababab\".\\n2. Remove first and last characters to get \"bababa\".\\n3. Check if \"abab\" is present in \"bababa\" - It is. Hence, return `True`.\\n\\n---\\n\\n# Complexity:\\n\\n## For Approach 1/2:\\n**Time Complexity:** \\n- $$O(n^2)$$ as we are iterating over half the string and for each length, we are checking the entire string.\\n\\n**Space Complexity:** \\n- $$O(n)$$ as we are constructing a repeated string of length `n`.\\n\\n## For Approach 2/2:\\n**Time Complexity:** \\n- $$O(n)$$ for concatenation and substring check.\\n\\n**Space Complexity:** \\n- $$O(n)$$ for the concatenated string.\\n\\n---\\n\\n# Performance:\\n## Approach 1/2:\\n| Language   | Runtime (ms) | Runtime Beat (%) | Memory (MB) | Memory Beat (%) |\\n|------------|--------------|------------------|-------------|-----------------|\\n| Rust       | 9            | 20.37%           | 2.1         | 42.59%          |\\n| Go         | 30           | 22.41%           | 8.7         | 13.79%          |\\n| Java       | 36           | 64.96%           | 44.1        | 61.10%          |\\n| C++        | 46           | 30.24%           | 91.8        | 20.17%          |\\n| Python3    | 50           | 73.5%            | 16.4        | 75.82%          |\\n| JavaScript | 83           | 41.70%           | 48.5        | 42.47%          |\\n| C#         | 87           | 66.81%           | 117.6       | 18.14%          |\\n\\n![v1a.png](https://assets.leetcode.com/users/images/f65f92c1-e905-4a37-b010-0a848aec6910_1692579412.5117164.png)\\n\\n\\n## Approach 2/2\\n| Language   | Runtime (ms) | Runtime Beat (%) | Memory (MB) | Memory Beat (%) |\\n|------------|--------------|------------------|-------------|-----------------|\\n| Rust       | 2            | 94.44%           | 2.4         | 20.37%          |\\n| Go         | 7            | 60.92%           | 6.0         | 51.15%          |\\n| C++        | 16           | 79.18%           | 13.4        | 57.60%          |\\n| Python3    | 31           | 99.42%           | 16.5        | 46.1%           |\\n| JavaScript | 61           | 76.6%            | 44.9        | 70.8%           |\\n| C#         | 70           | 88.94%           | 50.8        | 64.60%          |\\n| Java       | 75           | 50.12%           | 44.2        | 46.38%          |\\n\\n![v2.png](https://assets.leetcode.com/users/images/075370bf-c81d-4a8e-9c46-3c7eef412b76_1692577907.1661692.png)\\n\\n---\\n\\n# Code 1/2\\n``` Python []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n = len(s)\\n        for i in range(1, n//2 + 1):\\n            if n % i == 0:\\n                substring = s[:i]\\n                if substring * (n // i) == s:\\n                    return True\\n        return False\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; ++i) {\\n            if (n % i == 0) {\\n                string substring = s.substr(0, i);\\n                string repeated = \"\";\\n                for (int j = 0; j < n / i; ++j) {\\n                    repeated += substring;\\n                }\\n                if (repeated == s) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0) {\\n                String substring = s.substring(0, i);\\n                StringBuilder repeated = new StringBuilder();\\n                for (int j = 0; j < n / i; j++) {\\n                    repeated.append(substring);\\n                }\\n                if (repeated.toString().equals(s)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public bool RepeatedSubstringPattern(string s) {\\n        int n = s.Length;\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0) {\\n                string substring = s.Substring(0, i);\\n                System.Text.StringBuilder builder = new System.Text.StringBuilder();\\n                for (int j = 0; j < n / i; j++) {\\n                    builder.Append(substring);\\n                }\\n                if (builder.ToString() == s) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    const n = s.length;\\n    for (let i = 1; i <= n / 2; i++) {\\n        if (n % i === 0) {\\n            const substring = s.slice(0, i);\\n            let repeated = \"\";\\n            for (let j = 0; j < n / i; j++) {\\n                repeated += substring;\\n            }\\n            if (repeated === s) return true;\\n        }\\n    }\\n    return false;\\n};\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn repeated_substring_pattern(s: String) -> bool {\\n        let n = s.len();\\n        for i in 1..=n / 2 {\\n            if n % i == 0 {\\n                let substring = &s[0..i];\\n                let mut repeated = String::new();\\n                for _ in 0..(n / i) {\\n                    repeated.push_str(substring);\\n                }\\n                if repeated == s {\\n                    return true;\\n                }\\n            }\\n        }\\n        false\\n    }\\n}\\n```\\n``` Go []\\nimport \"strings\"\\n\\nfunc repeatedSubstringPattern(s string) bool {\\n    n := len(s)\\n    for i := 1; i <= n/2; i++ {\\n        if n%i == 0 {\\n            substring := s[:i]\\n            var builder strings.Builder\\n            for j := 0; j < n/i; j++ {\\n                builder.WriteString(substring)\\n            }\\n            if builder.String() == s {\\n                return true\\n            }\\n        }\\n    }\\n    return false\\n}\\n```\\n# Code 2/2\\n``` Python []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in (s + s)[1:-1]\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string doubled = s + s;\\n        string sub = doubled.substr(1, doubled.size() - 2);\\n        return sub.find(s) != string::npos;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String doubled = s + s;\\n        String sub = doubled.substring(1, doubled.length() - 1);\\n        return sub.contains(s);\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public bool RepeatedSubstringPattern(string s) {\\n        string doubled = s + s;\\n        string sub = doubled.Substring(1, doubled.Length - 2);\\n        return sub.Contains(s);\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    const doubled = s + s;\\n    const sub = doubled.slice(1, -1);\\n    return sub.includes(s);\\n};\\n```\\n``` Go []\\nfunc repeatedSubstringPattern(s string) bool {\\n    doubled := s + s\\n    return strings.Contains(doubled[1:len(doubled)-1], s)\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn repeated_substring_pattern(s: String) -> bool {\\n        let doubled = s.clone() + &s;\\n        let sub = &doubled[1..doubled.len()-1];\\n        return sub.contains(&s);\\n    }\\n}\\n```\\n## Live Coding in Go:\\nhttps://youtu.be/DeCw5VFDWaI\\n\\nThis problem beautifully showcases the importance of understanding the nature of strings and pattern recognition. By thinking out of the box, one can come up with more efficient solutions. \\uD83D\\uDCA1\\uD83C\\uDF20\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "String",
                    "String Matching"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n = len(s)\\n        for i in range(1, n//2 + 1):\\n            if n % i == 0:\\n                substring = s[:i]\\n                if substring * (n // i) == s:\\n                    return True\\n        return False\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; ++i) {\\n            if (n % i == 0) {\\n                string substring = s.substr(0, i);\\n                string repeated = \"\";\\n                for (int j = 0; j < n / i; ++j) {\\n                    repeated += substring;\\n                }\\n                if (repeated == s) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0) {\\n                String substring = s.substring(0, i);\\n                StringBuilder repeated = new StringBuilder();\\n                for (int j = 0; j < n / i; j++) {\\n                    repeated.append(substring);\\n                }\\n                if (repeated.toString().equals(s)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public bool RepeatedSubstringPattern(string s) {\\n        int n = s.Length;\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0) {\\n                string substring = s.Substring(0, i);\\n                System.Text.StringBuilder builder = new System.Text.StringBuilder();\\n                for (int j = 0; j < n / i; j++) {\\n                    builder.Append(substring);\\n                }\\n                if (builder.ToString() == s) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    const n = s.length;\\n    for (let i = 1; i <= n / 2; i++) {\\n        if (n % i === 0) {\\n            const substring = s.slice(0, i);\\n            let repeated = \"\";\\n            for (let j = 0; j < n / i; j++) {\\n                repeated += substring;\\n            }\\n            if (repeated === s) return true;\\n        }\\n    }\\n    return false;\\n};\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn repeated_substring_pattern(s: String) -> bool {\\n        let n = s.len();\\n        for i in 1..=n / 2 {\\n            if n % i == 0 {\\n                let substring = &s[0..i];\\n                let mut repeated = String::new();\\n                for _ in 0..(n / i) {\\n                    repeated.push_str(substring);\\n                }\\n                if repeated == s {\\n                    return true;\\n                }\\n            }\\n        }\\n        false\\n    }\\n}\\n```\n``` Go []\\nimport \"strings\"\\n\\nfunc repeatedSubstringPattern(s string) bool {\\n    n := len(s)\\n    for i := 1; i <= n/2; i++ {\\n        if n%i == 0 {\\n            substring := s[:i]\\n            var builder strings.Builder\\n            for j := 0; j < n/i; j++ {\\n                builder.WriteString(substring)\\n            }\\n            if builder.String() == s {\\n                return true\\n            }\\n        }\\n    }\\n    return false\\n}\\n```\n``` Python []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in (s + s)[1:-1]\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string doubled = s + s;\\n        string sub = doubled.substr(1, doubled.size() - 2);\\n        return sub.find(s) != string::npos;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String doubled = s + s;\\n        String sub = doubled.substring(1, doubled.length() - 1);\\n        return sub.contains(s);\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public bool RepeatedSubstringPattern(string s) {\\n        string doubled = s + s;\\n        string sub = doubled.Substring(1, doubled.Length - 2);\\n        return sub.Contains(s);\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    const doubled = s + s;\\n    const sub = doubled.slice(1, -1);\\n    return sub.includes(s);\\n};\\n```\n``` Go []\\nfunc repeatedSubstringPattern(s string) bool {\\n    doubled := s + s\\n    return strings.Contains(doubled[1:len(doubled)-1], s)\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn repeated_substring_pattern(s: String) -> bool {\\n        let doubled = s.clone() + &s;\\n        let sub = &doubled[1..doubled.len()-1];\\n        return sub.contains(&s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826121,
                "title": "python-2-solutions-1-oneliner-explained",
                "content": "Nice and easy problem, which can be solved in different ways.\\n\\n### Solution 1\\n\\nJust check all posible divisors of lenght of `s`, replicate them and compare them with original string. If we have found it, we return `True`, if we reached the end and we did not find any, we return `False`.\\n\\n**Complexity**: time complexity is `O(n*sqrt(n))`, because we have no more than `O(sqrt(n))` divisors of number `n` (we can split them into pairs, where one number in pair will be `<sqrt(n)`. Space compexity is `O(n)`.\\n\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s):\\n        N = len(s)\\n        for i in range(1, N//2+1):\\n            if N % i == 0 and s[:i]* (N//i) == s:\\n                return True\\n        return False\\n```\\n\\n### Solution 2\\nBut wait, there is more! There is in fact very short and interesting solution. Let us replicate our sting, remove first and last elements and try to find original string: for example:\\n\\n`s = abcdabcd`, then we have `bcdabcdabcdabc`, where we can find `abcdabcd` inside. It is a bit more difficult to prove, that opposite is true: if we found substring it will mean that we have repeated substring pattern. I will add proof a bit later.\\n\\n**Complexity**: time complexity is basically `O(n)`, because we can find substrings in linear time. In python function `in` will work, using Boyer\\u2013Moore algorithm, which is in average work in linear time (if you do not like average, you can use KMP, which have worst linear time, not average). Space complexity is `O(n)`.\\n\\n```\\nreturn s in (s+s)[1:-1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s):\\n        N = len(s)\\n        for i in range(1, N//2+1):\\n            if N % i == 0 and s[:i]* (N//i) == s:\\n                return True\\n        return False\\n```\n```\\nreturn s in (s+s)[1:-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94346,
                "title": "29-ms-cpp-simple-solution-no-kmp",
                "content": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string str) {\\n        string nextStr = str;\\n        int len = str.length();\\n        if(len < 1) return false;\\n        for(int i = 1; i <= len / 2; i++){\\n            if(len % i == 0){\\n                nextStr = leftShift(str, i);\\n                if(nextStr == str) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    string leftShift(string &str, int l){\\n        string ret = str.substr(l);\\n        ret += str.substr(0, l);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string str) {\\n        string nextStr = str;\\n        int len = str.length();\\n        if(len < 1) return false;\\n        for(int i = 1; i <= len / 2; i++){\\n            if(len % i == 0){\\n                nextStr = leftShift(str, i);\\n                if(nextStr == str) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    string leftShift(string &str, int l){\\n        string ret = str.substr(l);\\n        ret += str.substr(0, l);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94340,
                "title": "java-o-n",
                "content": "```\\npublic boolean repeatedSubstringPattern(String str) {\\n\\t        //This is the kmp issue\\n\\t        int[] prefix = kmp(str);\\n\\t        int len = prefix[str.length()-1];\\n\\t        int n = str.length();\\n\\t        return (len > 0 && n%(n-len) == 0);\\n\\t    }\\n\\t    private int[] kmp(String s){\\n\\t        int len = s.length();\\n\\t        int[] res = new int[len];\\n\\t        char[] ch = s.toCharArray();\\n\\t        int i = 0, j = 1;\\n\\t        res[0] = 0;\\n\\t        while(i < ch.length && j < ch.length){\\n\\t            if(ch[j] == ch[i]){\\n\\t                res[j] = i+1;\\n\\t                i++;\\n\\t                j++;\\n\\t            }else{\\n\\t                if(i == 0){\\n\\t                    res[j] = 0;\\n\\t                    j++;\\n\\t                }else{\\n\\t                    i = res[i-1];\\n\\t                }\\n\\t            }\\n\\t        }\\n\\t        return res;\\n\\t    }",
                "solutionTags": [],
                "code": "```\\npublic boolean repeatedSubstringPattern(String str) {\\n\\t        //This is the kmp issue\\n\\t        int[] prefix = kmp(str);\\n\\t        int len = prefix[str.length()-1];\\n\\t        int n = str.length();\\n\\t        return (len > 0 && n%(n-len) == 0);\\n\\t    }\\n\\t    private int[] kmp(String s){\\n\\t        int len = s.length();\\n\\t        int[] res = new int[len];\\n\\t        char[] ch = s.toCharArray();\\n\\t        int i = 0, j = 1;\\n\\t        res[0] = 0;\\n\\t        while(i < ch.length && j < ch.length){\\n\\t            if(ch[j] == ch[i]){\\n\\t                res[j] = i+1;\\n\\t                i++;\\n\\t                j++;\\n\\t            }else{\\n\\t                if(i == 0){\\n\\t                    res[j] = 0;\\n\\t                    j++;\\n\\t                }else{\\n\\t                    i = res[i-1];\\n\\t                }\\n\\t            }\\n\\t        }\\n\\t        return res;\\n\\t    }",
                "codeTag": "Unknown"
            },
            {
                "id": 441613,
                "title": "easiest-python-solution-with-detailed-explanation-and-example",
                "content": "```class Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in (s+s)[1:-1]\\n```\\n\\nExample:\\nTo find if the string has a repeatable substring inside, we can create a new string by duplicating the original string. \\nEx. \"abcabc\" => \"abcabcabcabc\"\\nBy removing the first and last character of the new string we create the string \"bcabcabcabcab\"\\nIf the original string \"abcabc\" is in \"bc**abcabc**ab\", we return true. \\n\\nWhy it works:\\nIf the original string has a repeating substring, the repeating substring can be no larger than 1/2 the length of the original string. I.e \"xyxy\" would be \"xy\"\\nBy repeating the string and removing the first and last character of the new string,  I.e \"xyxyxyxy\" => \"yxyxyx\", if the original string \"xyxy\" can be found in \"y**xyxy**x\", it means that \"xyxy\" has a repeating substring. \\n\\nHowever, this solution doesn\\'t tell us what the repeating substring is, but does solve the question if it exists.",
                "solutionTags": [],
                "code": "```class Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in (s+s)[1:-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551225,
                "title": "python-3-one-liner-beats-98-19",
                "content": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in s[1:] + s[:-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in s[1:] + s[:-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2145294,
                "title": "c-easy-fast-3-lines-of-code-commented-for-understanding",
                "content": "***\\u2714substring check method :***\\n\\n```\\nbool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n        for(int i=n/2;i>=1;i--){                //commented below\\n            if(n%i==0){                                                             //i is expressing the size of the substring forming-->if length of the substring(i.e, i) divides n equally then we can say the substring can be/may be a possible solution,so we check further,else we skip.\\n                if(s.substr(0,n-i)==s.substr(i))return true;           //rotation approach-->if two substrings from first and last match then we can say they can repeatedly form the string.\\n            }\\n        }\\n        return false;\\n    }\\n```\\n\\n***\\u2714explaination of running loop from n/2 :***  \\uD83D\\uDE0E\\n \\nFor those who are wondering why to choose \\noption-1)    \"for(int i = len/2; i>=1; i--)\" \\nand not\\noption-2)     \"for(int i = 1; i<=len/2; i++)\" \\n\\nLet\\'s take a small example to find which is better :\\ns = \"abcabcabcabc\"\\n\\nIf we chose option-1, we can find \"abcabc\" is the substring which when repeated \"twice\" gives the string s.\\n\\nIf we chose option-2, we can find \"abc\" is the substring which when repeated \"4 times\" gives the string s.\\n\\nSo, obviously option-1 is better as we are looking for the largest repeated substring first to minimize the time.\\n\\nHope that helps.\\n\\n![image](https://assets.leetcode.com/users/images/4364ec55-e199-4a4b-b10c-6261827d6f11_1655091797.973157.png)\\n\\n\\n\\uD83D\\uDE4CHappy Coding !!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n        for(int i=n/2;i>=1;i--){                //commented below\\n            if(n%i==0){                                                             //i is expressing the size of the substring forming-->if length of the substring(i.e, i) divides n equally then we can say the substring can be/may be a possible solution,so we check further,else we skip.\\n                if(s.substr(0,n-i)==s.substr(i))return true;           //rotation approach-->if two substrings from first and last match then we can say they can repeatedly form the string.\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 383957,
                "title": "python-beats-100-easy-explanation",
                "content": "**if there is a k repeating pattern in s, then we can say that a k-char rotation of s must be equal to s**\\n```\\ndef repeatedSubstringPattern(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        # if there is a k repeating pattern in s, then\\n        # we can tell that a k-rotation of s should be equal to s\\n        for k in range(1, len(s)//2 +1):   \\n            if s == s[k:] + s[:k]:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef repeatedSubstringPattern(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        # if there is a k repeating pattern in s, then\\n        # we can tell that a k-rotation of s should be equal to s\\n        for k in range(1, len(s)//2 +1):   \\n            if s == s[k:] + s[:k]:\\n                return True\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 94382,
                "title": "from-intuitive-but-slow-to-really-fast-but-a-little-hard-to-comprehend",
                "content": "Solution 1:\\nLet us start with the very naive solution. It uses 188 ms to solve 100 test cases. The idea is that when we see a character in *str* that matches the very first character of *str*, we can start to hoping that *str* is a built by copies of the substring composed by all characters before the reappearance of the its first character. \\n```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int l = str.length();\\n        if(l == 1) {\\n            return false;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        char first = str.charAt(0);\\n        sb.append(first);\\n        int i = 1;\\n        while(i <= l / 2) {\\n            char c = str.charAt(i++);\\n            if(c == first && isCopies(str, sb.toString())) {\\n                return true;\\n            }else {\\n                sb.append(c);\\n            }\\n        }\\n        return false;\\n    }\\n    private boolean isCopies(String str, String substr) {\\n        if(str.length() % substr.length() != 0) {\\n            return false;\\n        }\\n        for(int i = substr.length(); i < str.length(); i += substr.length()){\\n            if(!str.substring(i).startsWith(substr)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\nSolution 2:\\nThe problem of the first solution is that we do not use the knowledge of failed matching, and the Knuth-Morris-Pratt algorithm is a classic example of how knowledge of failed tries can be use to guide future search. \\n\\nIn fact we only need to compute the pattern table (the lps array, see below) in the Knuth-Morris-Pratt algorithm. \\n\\nThe entry lps[i] is the length of the longest proper prefix that is also a suffix of (s[0], ..., s[i]), or equivalently, length of the longest prefix that is also a proper suffix of (s[0], ..., s[i]). lps[0] is 0, since a single - character string has no proper prefix or proper suffix. [Here](http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/)  is a very detailed explanation on the KMP algorithm and how lps is computed dynamically.\\n    \\nAfter we get lps, we relate the property of the lps table to the property of a string being constructed by joining copies of its substring. \\n\\nOne on hand, if *str = (s[0], ..., s[km - 1])* is constructed by joining m copies of its substring *substr = (s[0], ..., s[k-1])*, and assuming that *substr* is the finest making block*str* can be boiled down to, meaning *str* is not constructed by joining copies of any proper substring of *substr*. Then we must have lps[km - 1] equals (m - 1)k. \\n\\nOn the other hand, assuming that the longest proper *prefix* of string *str* that is also a *suffix*, and the remaining string *remainderStr* obtained by removing *prefix* from *str* satisfies the following 3 properties:\\n1. *remainderStr* is a proper substring of *str*,\\n2. |str| is divisiable by |remainderStr|,\\n2. *remainderStr* is a prefix of *prefixStr*.\\n\\nWe can show by induction that *str* is constructed by joining copies of *remainderStr*.\\nHere is the code. It solve the 100 test cases in 29ms. A great improvement over the native approach! Remember the statement above, since we are going to use it again.\\n```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int l = str.length();\\n        int[] lps = new int[l];\\n        int leading = 1;\\n        int chasing = 0;\\n        while(leading < l) {\\n            if(str.charAt(chasing) == str.charAt(leading)) {\\n                chasing++;\\n                lps[leading] = chasing;\\n                leading++;\\n            }else {\\n                if(chasing > 0) {\\n                    chasing = lps[chasing - 1];\\n                }else {\\n                    chasing = 0;\\n                    leading++;\\n                }\\n            }\\n        }\\n        int lp = lps[l - 1];\\n        return (lp > 0 && l % (l - lp) == 0 && str.startsWith(str.substring(lp)));\\n    }\\n}\\n```\\nSolution 3:\\nCan the problem be solved efficiently without KMP? The following solution runs even faster (23ms on 100 test cases)\\n```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int l = str.length();\\n        for(int i = l / 2; i > 0; i--) {\\n            if(l % i == 0) {\\n                String substr = str.substring(0, i);\\n                int j = i;\\n                while(j < l) {\\n                    if(!str.substring(j, j + i).equals(substr)){\\n                        break;\\n                    }else {\\n                        j += i;\\n                    }\\n                }\\n                if(j == l) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\nSolution 4:\\nWant clearer code that runs even faster ? Here is it. The idea is stated at the end of the explanation for solution 2. Without really find the longest proper prefix that is also a suffix as in solution 2 and see whether the three properties are matched, we just test each *remainderStr*, from the longest possible that satisfies condition 1 and 2, that  whether the corresponding prefix and suffix match each other. It solve 100 test cases in 16ms. So maybe now, you really want to prove the statement since it lead to such a clean and fast solution? It is not hard to prove by induction.\\n```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int l = str.length();\\n        for(int i = (l + 1) / 2; i < l; i++) {\\n            if(l % (l - i) == 0) {\\n                String prefix = str.substring(0, i);\\n                String remainder = str.substring(i);\\n                String suffix = str.substring(l - i);\\n                if(str.startsWith(remainder) && suffix.equals(prefix)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int l = str.length();\\n        if(l == 1) {\\n            return false;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        char first = str.charAt(0);\\n        sb.append(first);\\n        int i = 1;\\n        while(i <= l / 2) {\\n            char c = str.charAt(i++);\\n            if(c == first && isCopies(str, sb.toString())) {\\n                return true;\\n            }else {\\n                sb.append(c);\\n            }\\n        }\\n        return false;\\n    }\\n    private boolean isCopies(String str, String substr) {\\n        if(str.length() % substr.length() != 0) {\\n            return false;\\n        }\\n        for(int i = substr.length(); i < str.length(); i += substr.length()){\\n            if(!str.substring(i).startsWith(substr)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int l = str.length();\\n        int[] lps = new int[l];\\n        int leading = 1;\\n        int chasing = 0;\\n        while(leading < l) {\\n            if(str.charAt(chasing) == str.charAt(leading)) {\\n                chasing++;\\n                lps[leading] = chasing;\\n                leading++;\\n            }else {\\n                if(chasing > 0) {\\n                    chasing = lps[chasing - 1];\\n                }else {\\n                    chasing = 0;\\n                    leading++;\\n                }\\n            }\\n        }\\n        int lp = lps[l - 1];\\n        return (lp > 0 && l % (l - lp) == 0 && str.startsWith(str.substring(lp)));\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int l = str.length();\\n        for(int i = l / 2; i > 0; i--) {\\n            if(l % i == 0) {\\n                String substr = str.substring(0, i);\\n                int j = i;\\n                while(j < l) {\\n                    if(!str.substring(j, j + i).equals(substr)){\\n                        break;\\n                    }else {\\n                        j += i;\\n                    }\\n                }\\n                if(j == l) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int l = str.length();\\n        for(int i = (l + 1) / 2; i < l; i++) {\\n            if(l % (l - i) == 0) {\\n                String prefix = str.substring(0, i);\\n                String remainder = str.substring(i);\\n                String suffix = str.substring(l - i);\\n                if(str.startsWith(remainder) && suffix.equals(prefix)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442971,
                "title": "javascript-single-line-solution",
                "content": "```js\\nvar repeatedSubstringPattern = function(s) {\\n    return s.repeat(2).slice(1, -1).includes(s);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar repeatedSubstringPattern = function(s) {\\n    return s.repeat(2).slice(1, -1).includes(s);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938646,
                "title": "c-simple-solution",
                "content": "Time complexity-O(n^2)\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string t = s; \\n\\n        for(int i=0; i<s.size()-1; i++){ \\n            char c = t[0];  // Store the first char\\n            t.erase(0,1); // Remove the first char\\n            t.push_back(c); // Append the char\\n\\n            if(t==s) { \\n                return true; \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nMethod 2  \\nTime Complexity- O(n^2)\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0) {\\n                string substring = s.substr(0, i);\\n               // cout<<substring.size()<<endl;\\n                string repeated;\\n                for (int j = 0; j < n / i; j++) {\\n                    repeated += substring;\\n                }\\n                if (repeated == s) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/59feb6ab-c9c8-4147-9b7a-444ab64a4d01_1692580232.9738462.webp)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string t = s; \\n\\n        for(int i=0; i<s.size()-1; i++){ \\n            char c = t[0];  // Store the first char\\n            t.erase(0,1); // Remove the first char\\n            t.push_back(c); // Append the char\\n\\n            if(t==s) { \\n                return true; \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0) {\\n                string substring = s.substr(0, i);\\n               // cout<<substring.size()<<endl;\\n                string repeated;\\n                for (int j = 0; j < n / i; j++) {\\n                    repeated += substring;\\n                }\\n                if (repeated == s) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3235934,
                "title": "c-2-line-code-using-substr-and-find",
                "content": "# Approach\\nTo explain with an example:\\nlet string be\\n# **\"abcabc\"**\\nso if we concatenate(add same string) it it becomes:\\n# **\"abcabcabcabc\"**\\nIf we remove 1st and last charater from this string:\\n# **\"bcabcabcab\"**\\nAnd now if we check for the original string in this and find it then the ans is true else false\\nAs we can see in the below line there is original string at the middle:\\n# **\"bc   abcabc   ab\"**\\nThen the output is TRUE.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string t=s+s;\\n        if(t.substr(1,t.size()-2).find(s)!=-1)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string t=s+s;\\n        if(t.substr(1,t.size()-2).find(s)!=-1)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694256,
                "title": "java-kmp-solution-with-explanation",
                "content": "Before going into details about how the solution works, you should have an understanding of the KMP algorithm.\\n\\nIn the KMP algorithm, we generate **lps[]** which represents the **longest proper prefix which is also suffix**. It tries to find the longest repetative pattern in given string. We can use this lps array to find out if given string can be created using pattern repeatedly.\\n\\nConsider string **\"ABABCD\"** and its lps array. In the case of a string with continuous repeated pattern if we subtract lps[i] from the length of string till that point it will give us the length of the pattern. In the given image we can see that `length(\"ABAB\") - lps[3] = 4-2 = 2` which is length of continuous repeated pattern **AB**.\\n\\n![image](https://assets.leetcode.com/users/images/5e2eaadb-5865-4f02-a666-987ed6e4a9ee_1642328355.7733243.png)\\n\\nAnother example. String **\"ABCABCABC\"**.\\n\\n![image](https://assets.leetcode.com/users/images/e4052dd9-4351-4fd2-9e17-02347ccc8f26_1642328467.3847742.png)\\n\\nSo, if the **length of string(n) % length of pattern(m) is zero** then we can say that the string can be constructed by taking a substring of it and appending multiple copies of the substring together. Where `length of pattern(m) = n - lps[n-1]`.\\n\\nJava solution\\n\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length(), prevLPS = 0, i = 1;\\n        int[] lps = new int[n];\\n        while (i < n) {\\n            if (s.charAt(i) == s.charAt(prevLPS)) {\\n                lps[i++] = ++prevLPS;\\n            } else if (prevLPS == 0) {\\n                lps[i++] = 0;\\n            } else {\\n                prevLPS = lps[prevLPS - 1];\\n            }\\n        }\\n        return lps[n - 1] > 0 && n % (n - lps[n - 1]) == 0;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length(), prevLPS = 0, i = 1;\\n        int[] lps = new int[n];\\n        while (i < n) {\\n            if (s.charAt(i) == s.charAt(prevLPS)) {\\n                lps[i++] = ++prevLPS;\\n            } else if (prevLPS == 0) {\\n                lps[i++] = 0;\\n            } else {\\n                prevLPS = lps[prevLPS - 1];\\n            }\\n        }\\n        return lps[n - 1] > 0 && n % (n - lps[n - 1]) == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203353,
                "title": "c-3-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string S = s + s;\\n        S = S.substr(1, S.size() - 2);\\n        return S.find(s) == string::npos ? false : true;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string S = s + s;\\n        S = S.substr(1, S.size() - 2);\\n        return S.find(s) == string::npos ? false : true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 541860,
                "title": "one-liner-with-explaination",
                "content": "I found this solution is not unique, but very few people explained this properly. If a String s is a repetitive string, you will find s is a substring of ss.substring(1, ss.length()), where ss = s + s. The reason is, considering the basic case in which s is somestring s\\' repeated twice, where we have s = s\\' + s\\'. Imagine now you hold s to find a match in ss. Only when the cursor moves to the second s\\' in ss, we will find a match. Meanwhile, you get the pattern length which is the index of s in ss.substring() - 1. So in any repetitive string, you will be able to find a match once proceed the pattern length.\\n\\n```\\ns =   \\'abcabc\\'\\nss = \\'abcabcabcabc\\'\\n\\n\\'abcabcabcabc\\'\\n  abcabc\\n\\t...\\n\\'abcabcabcabc\\'\\n    abcabc\\n```\\t\\t        \\n\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int idx = (s + s).indexOf(s, 1);\\n        return  idx < s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\ns =   \\'abcabc\\'\\nss = \\'abcabcabcabc\\'\\n\\n\\'abcabcabcabc\\'\\n  abcabc\\n\\t...\\n\\'abcabcabcabc\\'\\n    abcabc\\n```\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int idx = (s + s).indexOf(s, 1);\\n        return  idx < s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940083,
                "title": "c-string-algo-day-21",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; ++i) {\\n            if (n % i == 0) {\\n                string substring = s.substr(0, i);\\n                string repeated = \"\";\\n                for (int j = 0; j < n / i; ++j) {\\n                    repeated += substring;\\n                }\\n                if (repeated == s) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/ee6509ef-a08e-4998-94da-9902b54d64bd_1692608855.7340677.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; ++i) {\\n            if (n % i == 0) {\\n                string substring = s.substr(0, i);\\n                string repeated = \"\";\\n                for (int j = 0; j < n / i; ++j) {\\n                    repeated += substring;\\n                }\\n                if (repeated == s) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826171,
                "title": "c-easy-to-understand-with-explanation-without-kmp",
                "content": "If there is any string that consists of any pattern then the pattern should present at least 2 times in the string. \\n\\nSuppose there is Y string which is created using X pattern then Y will be one of list [XX,  XXX, XXXX, ...]. For example, take Y as XX.\\n\\n* Append the same string twice will make it XXXX.   \\n* The First Pattern of the new string will be changed if we remove the first character, Assume it will become A.\\n* The Last Pattern of the new string will be changed if remove the last character. Assume it will become B.\\n\\t **Note**: I am taking A and B because the characters were removed from the different sides from patterns. \\n* Now, String is AXXB. Check original string is present in it or not. If yes, then the original string is definitely constructed using pattern.\\n\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string tmp = s+s;\\n        /* Remove first char to avoid to match with input string which is from 0 to s.length() */\\n        tmp = tmp.substr(1);\\n        /* Remove last char to avoid to match with input string which is appended after s.length() */\\n        tmp = tmp.substr(0, tmp.length()-1);\\n        /* if the input string present then then pattern is repeated*/\\n        return tmp.find(s) != string::npos ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string tmp = s+s;\\n        /* Remove first char to avoid to match with input string which is from 0 to s.length() */\\n        tmp = tmp.substr(1);\\n        /* Remove last char to avoid to match with input string which is appended after s.length() */\\n        tmp = tmp.substr(0, tmp.length()-1);\\n        /* if the input string present then then pattern is repeated*/\\n        return tmp.find(s) != string::npos ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825657,
                "title": "java-short-and-clean-two-pointers",
                "content": "Basically move two windows until you match or mismatch.\\nThere\\'s no need to append anything, all you\\'re supposed to do is compare characters...\\n\\nSimilar problem that uses this kind of thinking: https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times\\n\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int n = str.length();\\n        \\n        for (int i = n / 2; i > 0; i--) {\\n            if (n % i == 0) {\\n                int left = 0;\\n                int right = i;\\n                \\n                while (right < n && str.charAt(left++) == str.charAt(right)) right++;\\n                \\n                if (right == n) {\\n                    return true;\\n                }                \\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int n = str.length();\\n        \\n        for (int i = n / 2; i > 0; i--) {\\n            if (n % i == 0) {\\n                int left = 0;\\n                int right = i;\\n                \\n                while (right < n && str.charAt(left++) == str.charAt(right)) right++;\\n                \\n                if (right == n) {\\n                    return true;\\n                }                \\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826243,
                "title": "python-simple-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=I8NNSCpDt3U)\\nhttps://www.youtube.com/watch?v=I8NNSCpDt3U\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        rep = \\'\\'\\n        length_s = len(s)\\n        \\n        for i in range(length_s // 2):\\n            rep += s[i]\\n            if length_s % len(rep) == 0:\\n                if rep * (length_s // len(rep)) == s:\\n                    return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        rep = \\'\\'\\n        length_s = len(s)\\n        \\n        for i in range(length_s // 2):\\n            rep += s[i]\\n            if length_s % len(rep) == 0:\\n                if rep * (length_s // len(rep)) == s:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826105,
                "title": "python-shortest-simplest-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        for i in range(1, len(s)//2+1):\\n            if s[:i] * (len(s)//i) == s:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        for i in range(1, len(s)//2+1):\\n            if s[:i] * (len(s)//i) == s:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550956,
                "title": "two-js-solutions",
                "content": "```\\nvar repeatedSubstringPattern = function(s) {\\n    let i = 1, len = s.length;\\n    while (i <= Math.floor(len/2)) {\\n        if (s.slice(0, i).repeat(len/i) == s) return true;\\n        i++\\n    }\\n    return false;\\n};\\n```\\n\\n```\\nvar repeatedSubstringPattern = function(s) {\\n    let pattern = \"\";\\n    for (let i = 0; i < Math.floor(s.length/2); i++) {\\n        pattern += s[i];\\n        if (pattern.repeat(s.length / pattern.length) === s) return true;\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar repeatedSubstringPattern = function(s) {\\n    let i = 1, len = s.length;\\n    while (i <= Math.floor(len/2)) {\\n        if (s.slice(0, i).repeat(len/i) == s) return true;\\n        i++\\n    }\\n    return false;\\n};\\n```\n```\\nvar repeatedSubstringPattern = function(s) {\\n    let pattern = \"\";\\n    for (let i = 0; i < Math.floor(s.length/2); i++) {\\n        pattern += s[i];\\n        if (pattern.repeat(s.length / pattern.length) === s) return true;\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 487699,
                "title": "java-solution-in-o-n-using-kmp",
                "content": "```\\n//Create one KMP table which will tell us about LPS in the string.\\n//Find the length of the pattern (if formed).\\n//check whether that pattern length is divisible by the length of the given string.\\n//Note:- we need to check the condition of the last index of LPS array. If that is 0 then it means that there is \\n//no pattern formed in the string.\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int[] lps = new int[s.length()];\\n        int i = 1;\\n        for(int j = 0; i < s.length();) {//\\n            if(s.charAt(i) == s.charAt(j)) {\\n                lps[i] = j+1;\\n                i++;\\n                j++;\\n            }\\n            else if(j!=0 && s.charAt(i) != s.charAt(j)) {\\n                j = lps[j-1];\\n            }\\n            else {\\n                i++;\\n            }\\n        }\\n        \\n        if(lps[lps.length - 1] == 0) return false;\\n        \\n        int patternlength = s.length() - lps[lps.length - 1];\\n        \\n        if(s.length() % patternlength == 0) return true;\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//Create one KMP table which will tell us about LPS in the string.\\n//Find the length of the pattern (if formed).\\n//check whether that pattern length is divisible by the length of the given string.\\n//Note:- we need to check the condition of the last index of LPS array. If that is 0 then it means that there is \\n//no pattern formed in the string.\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int[] lps = new int[s.length()];\\n        int i = 1;\\n        for(int j = 0; i < s.length();) {//\\n            if(s.charAt(i) == s.charAt(j)) {\\n                lps[i] = j+1;\\n                i++;\\n                j++;\\n            }\\n            else if(j!=0 && s.charAt(i) != s.charAt(j)) {\\n                j = lps[j-1];\\n            }\\n            else {\\n                i++;\\n            }\\n        }\\n        \\n        if(lps[lps.length - 1] == 0) return false;\\n        \\n        int patternlength = s.length() - lps[lps.length - 1];\\n        \\n        if(s.length() % patternlength == 0) return true;\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94455,
                "title": "1-line-in-python",
                "content": "```\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, s):\\n        return any(s[:i] * (len(s) / i) == s for i in range(1, len(s)) if len(s) % i == 0)\\n```\\n\\nTime complexity is O(n<sup>1.5</sup>) because I do for O(n<sup>0.5</sup>)   times (number of divisors of n) an O(n) operation, i.e.,  `s[:i] * (len(s) / d) == s `. Space complexity is O(n).",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, s):\\n        return any(s[:i] * (len(s) / i) == s for i in range(1, len(s)) if len(s) % i == 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94448,
                "title": "one-line-with-regex",
                "content": "```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        return str.matches(\"^([a-z]+)\\\\\\\\1+$\");\\n    }\\n}\\n```\\n\\nThanks to @StefanPochmann , it can be simplified:\\n```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        return str.matches(\"(.+)\\\\\\\\1+\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        return str.matches(\"^([a-z]+)\\\\\\\\1+$\");\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        return str.matches(\"(.+)\\\\\\\\1+\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94368,
                "title": "share-my-simple-solution",
                "content": "Try every possible substring, then check.\\n\\n```java\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int len = str.length();\\n        if(len<2) return false;\\n        for(int i=2;i<=len;i++){\\n            if(len%i!=0) continue;\\n            if(check(str, i)) return true;\\n        }\\n        return false;\\n    }\\n    public boolean check(String str, int repeat){\\n        int len = str.length();\\n        String cand = str.substring(0, len/repeat);\\n        for(int i=0;i<len;i++){\\n            if(str.charAt(i)!=cand.charAt(i%(len/repeat))) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int len = str.length();\\n        if(len<2) return false;\\n        for(int i=2;i<=len;i++){\\n            if(len%i!=0) continue;\\n            if(check(str, i)) return true;\\n        }\\n        return false;\\n    }\\n    public boolean check(String str, int repeat){\\n        int len = str.length();\\n        String cand = str.substring(0, len/repeat);\\n        for(int i=0;i<len;i++){\\n            if(str.charAt(i)!=cand.charAt(i%(len/repeat))) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938766,
                "title": "video-ex-amazon-explains-a-solution-with-python-javascript-java-and-c",
                "content": "I\\'m going to show you two ways to solve this quesiton.\\n\\n# Solution Video\\n\\n### Please subscribe to my channel from here. I have 245 videos as of August 21th.\\n\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nhttps://youtu.be/Fx7dQgDcZXU\\n\\n---\\n\\n# Approach1 with O(n^2) time\\nThis is based on Python. Other might be different a bit.\\n\\n**1. Iterate through potential substring lengths.**\\n- The code begins by calculating the length of the input string \\'s\\'. It then enters a loop that iterates through possible substring lengths, ranging from 1 to half of the string length (n // 2).\\n\\n**2. Check if the current length divides the string length evenly.**\\n- Within each loop iteration, the code verifies whether the current substring length \\'i\\' evenly divides the length of the string \\'s\\' using the modulo operation (n % i == 0). This condition ensures that the substring could be repeated to form the original string.\\n\\n**3. Compare the repeated substring with the original string.**\\n- If the current substring length is a valid divisor of the string length, the code extracts the substring of length \\'i\\' from the start of the string \\'s\\'. It then constructs a repeated string by replicating this substring a certain number of times (s[:i] * (n // i)). The code subsequently checks if this repeated substring matches the original string \\'s\\'. If they match, it signifies that the string \\'s\\' can indeed be formed by repeating this particular substring, and the function returns True.\\n\\n**4. Return False if no valid repeated substring is found.**\\n- In case the loop concludes without finding a valid repeated substring that can recreate the original string, the function returns False. This indicates that the input string cannot be generated through the repetition of any of its substrings.\\n\\nIn summary, the algorithm systematically examines all potential substring lengths to ascertain if any repeated substring can reconstruct the original string. If such a substring is identified, the function returns True; otherwise, it returns False.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(1)\\n\\n\\n# Approach2 with O(n) time\\n**1. Create a new string by concatenating the original string with itself.**\\n- The code starts by creating a new string, which is obtained by concatenating the original string \\'s\\' with itself (s + s).\\n\\n**2. Check if the original string is a substring of the concatenated string excluding the first and last characters.**\\n- The code then uses the \\'in\\' operator to check if the original string \\'s\\' is a substring of the concatenated string (s + s). However, the slice notation [1:-1] is applied to the concatenated string to exclude its first and last characters. This is because the original string cannot form a repeated substring pattern using the first and last characters of the concatenated string.\\n\\n**3. Return True if the condition is met, otherwise return False.**\\n- If the check for substring existence is successful, indicating that the original string can be formed by repeating a substring, the function returns True. If the condition is not met, it returns False, indicating that the original string cannot be formed by repeating any substring.\\n\\nIn summary, the algorithm creates a new string by doubling the original string and then checks whether the original string is a substring of the doubled string excluding the first and last characters. If this condition is satisfied, the function returns True; otherwise, it returns False.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code of Apporach1\\n```python []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n = len(s)\\n        for i in range(1, n // 2 + 1):\\n            if n % i == 0 and s[:i] * (n // i) == s:\\n                return True\\n        \\n        return False\\n```\\n```javascript []\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    const n = s.length;\\n\\n    for (let i = 1; i <= Math.floor(n / 2); i++) {\\n        if (n % i === 0 && s.slice(0, i).repeat(n / i) === s) {\\n            return true;\\n        }\\n    }\\n    \\n    return false;    \\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0 && s.substring(0, i).repeat(n / i).equals(s)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0) {\\n                string repeated = \"\";\\n                for (int j = 0; j < n / i; j++) {\\n                    repeated += s.substr(0, i);\\n                }\\n                if (repeated == s) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n# Code of Apporach2\\n```python []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in (s+s)[1:-1]\\n```\\n```javascript []\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    return (s + s).substring(1, s.length * 2 - 1).includes(s);    \\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String concatenated = s + s;\\n        return concatenated.substring(1, concatenated.length() - 1).contains(s);\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string concatenated = s + s;\\n        return concatenated.substr(1, concatenated.length() - 2).find(s) != string::npos;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n = len(s)\\n        for i in range(1, n // 2 + 1):\\n            if n % i == 0 and s[:i] * (n // i) == s:\\n                return True\\n        \\n        return False\\n```\n```javascript []\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    const n = s.length;\\n\\n    for (let i = 1; i <= Math.floor(n / 2); i++) {\\n        if (n % i === 0 && s.slice(0, i).repeat(n / i) === s) {\\n            return true;\\n        }\\n    }\\n    \\n    return false;    \\n};\\n```\n```java []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0 && s.substring(0, i).repeat(n / i).equals(s)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0) {\\n                string repeated = \"\";\\n                for (int j = 0; j < n / i; j++) {\\n                    repeated += s.substr(0, i);\\n                }\\n                if (repeated == s) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in (s+s)[1:-1]\\n```\n```javascript []\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    return (s + s).substring(1, s.length * 2 - 1).includes(s);    \\n};\\n```\n```java []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String concatenated = s + s;\\n        return concatenated.substring(1, concatenated.length() - 1).contains(s);\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string concatenated = s + s;\\n        return concatenated.substr(1, concatenated.length() - 2).find(s) != string::npos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212659,
                "title": "java-one-line-solution",
                "content": "class Solution {\\n    public boolean repeatedSubstringPattern(String string) {\\n        return ((string + string).indexOf(string, 1) != string.length());\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean repeatedSubstringPattern(String string) {\\n        return ((string + string).indexOf(string, 1) != string.length());\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 235383,
                "title": "javascript",
                "content": "**\\u65B9\\u6CD51:** \\u66B4\\u529B\\u7834\\u89E3\\u6CD5\\n**\\u89E3\\u9898\\u601D\\u8DEF:**\\n1. \\u4F7F\\u7528repeat\\u65B9\\u6CD5\\n\\n**\\u4EE3\\u7801:**\\n```\\nvar repeatedSubstringPattern = function(s) {\\n  for (let i = 1; i < s.length; i++) {\\n    if (s.length % i === 0 && s.slice(0, i).repeat(s.length / i) === s) return true;\\n  }\\n  return false;\\n};\\n```\\n\\n**\\u65B9\\u6CD52:** \\u91CD\\u590D\\u5B57\\u7B26\\u4E32\\u6CD5\\n**\\u89E3\\u9898\\u601D\\u8DEF:**\\n1. \\u91CD\\u590D\\u5B57\\u7B26\\u4E32, \\u53BB\\u9664\\u9996\\u5C3E\\u4E24\\u4E2A\\u5B57\\u7B26.\\n2. \\u5982\\u679C\\u662F\\u5B50\\u5B57\\u7B26\\u4E32\\u6784\\u6210\\u7684, \\u90A3\\u4E48\\u5E94\\u8BE5\\u5B58\\u5728\\u4E8E\\u91CD\\u590D\\u7684\\u5B57\\u7B26\\u4E32\\u4E2D.\\n\\n**\\u4EE3\\u7801:**\\n```\\nvar repeatedSubstringPattern = function(s) {\\n  const str = s + s;\\n  return str.slice(1, str.length - 1).includes(s);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar repeatedSubstringPattern = function(s) {\\n  for (let i = 1; i < s.length; i++) {\\n    if (s.length % i === 0 && s.slice(0, i).repeat(s.length / i) === s) return true;\\n  }\\n  return false;\\n};\\n```\n```\\nvar repeatedSubstringPattern = function(s) {\\n  const str = s + s;\\n  return str.slice(1, str.length - 1).includes(s);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 213464,
                "title": "java-1-line-clever-solution-that-i-came-across",
                "content": "```\\npublic boolean repeatedSubstringPattern(String s) {\\n\\treturn (s+s).substring(1,2*s.length()-1).contains(s);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean repeatedSubstringPattern(String s) {\\n\\treturn (s+s).substring(1,2*s.length()-1).contains(s);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94335,
                "title": "java-o-n-2-accepted-solution",
                "content": "```\\n    public boolean repeatedSubstringPattern(String str) {\\n        for(int i = 1; i <= str.length()/2; i++) {\\n            String pattern = str.substring(0, i);\\n            if(isRepeated(str.substring(i), pattern)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean isRepeated(String s, String pattern) {\\n        if(s == null || s.isEmpty()) {\\n            return true;\\n        }\\n        if(!s.startsWith(pattern)) {\\n            return false;\\n        }\\n        \\n        return isRepeated(s.substring(pattern.length()), pattern);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public boolean repeatedSubstringPattern(String str) {\\n        for(int i = 1; i <= str.length()/2; i++) {\\n            String pattern = str.substring(0, i);\\n            if(isRepeated(str.substring(i), pattern)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean isRepeated(String s, String pattern) {\\n        if(s == null || s.isEmpty()) {\\n            return true;\\n        }\\n        if(!s.startsWith(pattern)) {\\n            return false;\\n        }\\n        \\n        return isRepeated(s.substring(pattern.length()), pattern);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3251626,
                "title": "easy-java-2-lines-solution",
                "content": "\\n# Code\\n```java []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String concatenated = s+s;\\n        return concatenated.substring(1,concatenated.length()-1).contains(s);\\n    }\\n}\\n```\\n![upvote1.png](https://assets.leetcode.com/users/images/6cf8d222-6eb5-420d-940a-264691c3549a_1677842430.2708967.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String concatenated = s+s;\\n        return concatenated.substring(1,concatenated.length()-1).contains(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94379,
                "title": "simple-python-solution-beat-100-in-49ms",
                "content": "'''\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, str):\\n        \"\"\"\\n        :type str: str\\n        :rtype: bool\\n        \"\"\"\\n        ss = (str*2)[1:-1]\\n        return str in ss\\n'''",
                "solutionTags": [],
                "code": "'''\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, str):\\n        \"\"\"\\n        :type str: str\\n        :rtype: bool\\n        \"\"\"\\n        ss = (str*2)[1:-1]\\n        return str in ss\\n'''",
                "codeTag": "Java"
            },
            {
                "id": 1182123,
                "title": "python-python3-solution-with-explanation-ans-easy-understanding",
                "content": "**Code:**\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        length = len(s) # compute the length of the string\\n        for i in range(1,length//2+1): # run the loop for length / 2 times\\n            if length % i == 0 and s[:i] * (length//i) == s: if length mod i is equal to zero and the string upto i * length divided by i is equal to s then return True \\n                return True\\n        return False\\n```\\nExample is explained below:\\ns = \"abcabcabcabc\"\\nOutput: True\\n\\nExplanation :\\nStep 1: length = 12\\nStep 2: run the loop length by 2 times from 1\\nWhy we need to run loop from 1 to length //2 times?\\n* s[:i] will take the characters before i.\\t\\t\\n* length //2 times is because of to recude the loop running and we will compute our output with the length // 2 times itself.\\n\\nStep 3: enters the if length % i ==0 and s[:i] * (length //i) ==s:\\n* i:1 =>12 % 1 = 0 and s[:1] =\\'a\\' * 12 // 1(12) == \\'abcabcabcabc\\'\\nTrue and False = False\\n* i:2 =>12 % 2 = 0 and s[:2] =\\'ab\\' * 12 // 2(6) == \\'abcabcabcabc\\'\\nTrue and False = False\\n* i:1 =>12 % 3 = 0 and s[:3] =\\'abc\\' * 12 // 3(4) == \\'abcabcabcabc\\'\\nTrue and True = True => Enter the if returns True.\\n\\n\\n\\n\\n***We rise by lifting others***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        length = len(s) # compute the length of the string\\n        for i in range(1,length//2+1): # run the loop for length / 2 times\\n            if length % i == 0 and s[:i] * (length//i) == s: if length mod i is equal to zero and the string upto i * length divided by i is equal to s then return True \\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826214,
                "title": "c-kmp-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        \\n        int n=s.length();\\n        vector<int> dp(n,0);\\n        \\n        int i=1;\\n        int j=0;\\n        \\n        for(i=1;i<n;)\\n        {\\n            if(s[i]==s[j])\\n            {\\n                j++;\\n                dp[i]=j;\\n                i++;\\n            }\\n            else\\n            {\\n                if(j!=0)\\n                {\\n                    j=dp[j-1];\\n                }\\n                else\\n                {\\n                    dp[i]=0;\\n                    i++;\\n                }\\n            }\\n        }\\n        \\n        return dp[n-1] && (dp[n-1]%(n-dp[n-1])==0);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        \\n        int n=s.length();\\n        vector<int> dp(n,0);\\n        \\n        int i=1;\\n        int j=0;\\n        \\n        for(i=1;i<n;)\\n        {\\n            if(s[i]==s[j])\\n            {\\n                j++;\\n                dp[i]=j;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 444086,
                "title": "python-kmp-explained",
                "content": "KMP alg is used to find a substring (word) in a string. If the characters in the word are distinct then you rarely find matches in the string by bruteforce method and it works as O(N). However if the beginning of the word repeats, then we can have something like \\'aaaaaa...aaab\\' where we could find that there is no match with the parent string only at the last character, and KMP algorithm deals with that problem.\\n\\nThis is also the task in this problem, where we need to find if some beginning part of the word composes the word by repeating itself. \\n\\nThat\\'s why we build the table T for the word that contains information where we should return our pointer when we matched first N characters of the word with some other string and the character N + 1 does not match. If we have a word \"patternpatr\" and a string \"patternpat^ternpatr\" then \"t\" does not match with \"r\" and we should return our pointer to the first \"pat\". Normally we have a word like \"abcd\" and if b,c,d do not match like in \"abc^e\" we just return to \"a\" and check if \"e\" is \"a\", so T contains 0 at ^. For \"abcd^a\" if the second \\'a\\' doesn\\'t match we just skip to the next character in the string without any checks and start allover, so T contains -1 at ^.\\n\\nThe numbers in T other than 0 and -1 are rare and are the most interesting for this problem. Because basically they represent the number of characters that repeated the beginning before the pattern stopped reproducing. And they come from a counter, which is called \"pos\" in the code below, which remains hidden, and appears in the table only when the pattern breaks. \\n\\nSo if we have a repeating pattern in the beginning of the word, the numbers of T could look like whatever for this pattern, their purpose is to return us to the right place in this pattern UNTIL we hit the next occurence of the full pattern. After that the counter \"pos\" just increases while the pattern repeats itself.\\n\\nTherefore, if we have a repeating pattern, then in the end \"len(s) - pos\" will be equal to the size of this pattern, because this pattern repeated itself for \"pos\" number of characaters till the end of the word \"s\", and otherwise \"len(s) % (len(s) - pos) !=0\"\\n\\nP. S. Since in Python find() (or \"in\") is standard for strings and it is also O(N), a very elegant solution used by other users is just to check if s in (s+s)[1:-1]. But under the hood one would of course use KMP to find \"s\" in the larger string, so it\\'s still worth understanding why KMP is useful and how it gives us the direct answer in O(N) without any explicit matching of a substring within a larger string.\\n\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        if len(s) <= 1:\\n            return False\\n        T = [-1 for c in s]\\n        pos = 0\\n        for i in range(1, len(s)):\\n            if s[i] == s[pos]:\\n                T[i] = T[pos]\\n            else:\\n                T[i] = pos\\n                pos = T[pos]\\n                while pos >= 0 and s[i] != s[pos]:\\n                    pos = T[pos]\\n            pos += 1\\n        lens = len(s) - pos\\n        if lens == 0 or len(s) % lens != 0 or len(s) == lens:\\n            return False\\n        return True\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        if len(s) <= 1:\\n            return False\\n        T = [-1 for c in s]\\n        pos = 0\\n        for i in range(1, len(s)):\\n            if s[i] == s[pos]:\\n                T[i] = T[pos]\\n            else:\\n                T[i] = pos\\n                pos = T[pos]\\n                while pos >= 0 and s[i] != s[pos]:\\n                    pos = T[pos]\\n            pos += 1\\n        lens = len(s) - pos\\n        if lens == 0 or len(s) % lens != 0 or len(s) == lens:\\n            return False\\n        return True\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818673,
                "title": "python-97-68-faster-two-solutions-one-liner",
                "content": "**Solution 1 :**\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\t# Here we checking that s is present in a new string double of s which after remvoing fast and last element\\n        return s in s[1:] + s[:-1] \\n```\\n\\n**Solution 2 :**\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n,t=len(s),\\'\\'\\n        for i in range(n//2):\\n            t+=s[i]\\n            if t*(n//(i+1))==s: return True\\n        return False\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\t# Here we checking that s is present in a new string double of s which after remvoing fast and last element\\n        return s in s[1:] + s[:-1] \\n```\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n,t=len(s),\\'\\'\\n        for i in range(n//2):\\n            t+=s[i]\\n            if t*(n//(i+1))==s: return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304034,
                "title": "python-93-74-fasters-python-simplest-solution-with-explanation-beg-to-adv-slicing",
                "content": "```python\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in s[1:] + s[:-1]\\n```\\n```python\\nExample:\\nTo find if the string has a repeatable substring inside, we can create a new string by duplicating the original string.\\nEx. \"abcabc\" => \"abcabcabcabc\"\\nBy removing the first and last character of the new string we create the string \"bcabcabcabcab\"\\nIf the original string \"abcabc\" is in \"bcabcabcab\", we return true.\\n\\nWhy it works:\\nIf the original string has a repeating substring, the repeating substring can be no larger than 1/2 the length of the original string. I.e \"xyxy\" would be \"xy\"\\nBy repeating the string and removing the first and last character of the new string, I.e \"xyxyxyxy\" => \"yxyxyx\", if the original string \"xyxy\" can be found in \"yxyxyx\", it means that \"xyxy\" has a repeating substring.\\n\\nHowever, this solution doesn\\'t tell us what the repeating substring is, but does solve the question if it exists.\\n```\\n\\n![image](https://assets.leetcode.com/users/images/0840b211-ac16-48de-9bb6-d324748aed00_1658231895.0107276.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in s[1:] + s[:-1]\\n```\n```python\\nExample:\\nTo find if the string has a repeatable substring inside, we can create a new string by duplicating the original string.\\nEx. \"abcabc\" => \"abcabcabcabc\"\\nBy removing the first and last character of the new string we create the string \"bcabcabcabcab\"\\nIf the original string \"abcabc\" is in \"bcabcabcab\", we return true.\\n\\nWhy it works:\\nIf the original string has a repeating substring, the repeating substring can be no larger than 1/2 the length of the original string. I.e \"xyxy\" would be \"xy\"\\nBy repeating the string and removing the first and last character of the new string, I.e \"xyxyxyxy\" => \"yxyxyx\", if the original string \"xyxy\" can be found in \"yxyxyx\", it means that \"xyxy\" has a repeating substring.\\n\\nHowever, this solution doesn\\'t tell us what the repeating substring is, but does solve the question if it exists.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351474,
                "title": "java-solution-in-3-lines-with-explanation",
                "content": "```\\npublic boolean repeatedSubstringPattern(String s) {\\n    String doubled = s.repeat(2);\\n\\t// find the occurrence of the s starting from the 1st index\\n    // we cannot use 0 or else we will find the s itself\\n\\tint occurrenceIndex = doubled.indexOf(s, 1);\\n\\t// if found index equals to the length of the string, the s string does not have repeated pattern\\n    // e.g.\\n    // if we have s = `ab`, doubled = `abab`\\n    // occurrenceIndex == 2 which is pointing to the beginning of the s copy\\n    // `abab`\\n    //    ^\\n    // for s = `abab`, doubled = `abababab`\\n    // occurrenceIndex == 2. 2 < s.length(), so that we found the pattern\\n    // `abababab`\\n    //    ^\\n\\treturn occurrenceIndex != s.length();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean repeatedSubstringPattern(String s) {\\n    String doubled = s.repeat(2);\\n\\t// find the occurrence of the s starting from the 1st index\\n    // we cannot use 0 or else we will find the s itself\\n\\tint occurrenceIndex = doubled.indexOf(s, 1);\\n\\t// if found index equals to the length of the string, the s string does not have repeated pattern\\n    // e.g.\\n    // if we have s = `ab`, doubled = `abab`\\n    // occurrenceIndex == 2 which is pointing to the beginning of the s copy\\n    // `abab`\\n    //    ^\\n    // for s = `abab`, doubled = `abababab`\\n    // occurrenceIndex == 2. 2 < s.length(), so that we found the pattern\\n    // `abababab`\\n    //    ^\\n\\treturn occurrenceIndex != s.length();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 369467,
                "title": "simple-java-solution-with-explanation",
                "content": "Thought of this solution from the CTCI 1.9 problem \\nExample: **abcabc**\\nRotate by 1: **c**abcab\\nRotate by 2: **bc**abca\\nRotate by 3: **abc**abc which is equal to the original String indicates that there is a repeatation. \\nSo if you append the duplicate of the String and remove the first and last character it should contain the original string that is provided. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(removed char)a--- bc**abcabc**ab  ---c (removed char)\\n\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String ss = s + s;\\n        return ss.substring(1, ss.length()-1).contains(s);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String ss = s + s;\\n        return ss.substring(1, ss.length()-1).contains(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774294,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution { \\n\\tpublic boolean repeatedSubstringPattern(String s) {\\n\\t\\tString str=s+s;\\n\\t\\tString str1=str.substring(1, str.length()-1); \\n\\t\\treturn str1.contains(s);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution { \\n\\tpublic boolean repeatedSubstringPattern(String s) {\\n\\t\\tString str=s+s;\\n\\t\\tString str1=str.substring(1, str.length()-1); \\n\\t\\treturn str1.contains(s);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399126,
                "title": "c-kmp-algo-t-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> kmp_algo(string s){\\n        int len=0, i=1, n=s.size();\\n        vector<int> kmp(n,0);\\n        while(i<n){\\n            if(s[i]==s[len]){\\n                kmp[i]=len+1;\\n                i++;\\n                len++;\\n            }else{\\n                if(len!=0){\\n                    len=kmp[len-1];\\n                }else{\\n                    kmp[i]=0;\\n                    ++i;\\n                }\\n            }\\n        }\\n        return kmp;\\n    }\\n    \\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n        auto kmp = kmp_algo(s);\\n        \\n        int len = n-kmp[n-1];\\n        if(kmp[n-1]%len == 0 && kmp[n-1]!=0) return true;\\n        return false;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kmp_algo(string s){\\n        int len=0, i=1, n=s.size();\\n        vector<int> kmp(n,0);\\n        while(i<n){\\n            if(s[i]==s[len]){\\n                kmp[i]=len+1;\\n                i++;\\n                len++;\\n            }else{\\n                if(len!=0){\\n                    len=kmp[len-1];\\n                }else{\\n                    kmp[i]=0;\\n                    ++i;\\n                }\\n            }\\n        }\\n        return kmp;\\n    }\\n    \\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n        auto kmp = kmp_algo(s);\\n        \\n        int len = n-kmp[n-1];\\n        if(kmp[n-1]%len == 0 && kmp[n-1]!=0) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856181,
                "title": "javascript-solution-459-one-line-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nlet repeatedSubstringPattern = function(s) {\\n    return s.repeat(2).slice(1, -1).includes(s);\\n};\\n```\\n**Runtime: 64 ms, faster than 99.67% of JavaScript online submissions for Repeated Substring Pattern.**\\n\\n**Memory Usage: 39.5 MB, less than 85.06% of JavaScript online submissions for Repeated Substring Pattern.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nlet repeatedSubstringPattern = function(s) {\\n    return s.repeat(2).slice(1, -1).includes(s);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 333119,
                "title": "python-12-ms-beats-99",
                "content": "```\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        newstr = s[1:] + s[:-1]\\n        return newstr.find(s) != -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        newstr = s[1:] + s[:-1]\\n        return newstr.find(s) != -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 207312,
                "title": "c-1-line-with-explanation",
                "content": "There are 3 major parts in the code.\\nPart 1 ---Double the original string to get a new string:``` s+s```\\nPart 2 ---Scan the new string from the second charactor to the end with the original string: ```substr(1,2*s.size()-1).find(s)```\\nPart 3 ---If you can find it before the beginning of the second half of the new string: ```s.size()-1```,\\nthat means the original string has a repeated pattern, otherwise it doesn\\'t.\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) \\n    {  return (s+s).substr(1,2*s.size()-1).find(s)!=s.size()-1;  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` s+s```\n```substr(1,2*s.size()-1).find(s)```\n```s.size()-1```\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) \\n    {  return (s+s).substr(1,2*s.size()-1).find(s)!=s.size()-1;  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194064,
                "title": "one-line-code-stl-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# **Using find stl**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nadd the string str=s+s; and find s in str if u find it before the half size of str then it will return true (SEARCH FROM INDEX 1);\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nconstant space or zero space\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        return (s+s).find(s,1) < s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        return (s+s).find(s,1) < s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851811,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool can_make(string &key, string &s){\\n        int sub = key.length();\\n        \\n         for(int i{sub}; i < s.length(); i += sub)\\n            if(s.substr(i, sub) != key)\\n                return false;\\n        \\n        return true;\\n    }\\n    \\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        int right{1};\\n        string key{s[0]};\\n        \\n        while(right <= (n / 2)){  \\n            if(n % right == 0){\\n                if(can_make(key, s)) // If key can make s\\n                    return true;\\n            }\\n            \\n            key.push_back(s[right]);\\n            \\n            right++;\\n        }\\n        \\n       return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool can_make(string &key, string &s){\\n        int sub = key.length();\\n        \\n         for(int i{sub}; i < s.length(); i += sub)\\n            if(s.substr(i, sub) != key)\\n                return false;\\n        \\n        return true;\\n    }\\n    \\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        int right{1};\\n        string key{s[0]};\\n        \\n        while(right <= (n / 2)){  \\n            if(n % right == 0){\\n                if(can_make(key, s)) // If key can make s\\n                    return true;\\n            }\\n            \\n            key.push_back(s[right]);\\n            \\n            right++;\\n        }\\n        \\n       return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236527,
                "title": "repeated-substring-pattern-java-solution-with-explanation",
                "content": "**Approach:**\\n* Loop from i=len/2 i.e half of the string.\\n* Check if a substring of length \\'i\\' can be appended integer no of times to form the given string.(i.e check if len%i == 0.\\n* Take a substring sub from index 0 to i-1.\\n* Append the substring sub len/i times to a string builder st.\\n* if st.toString()==s,return true else i--\\n* Do this till i>=1.\\n![image](https://assets.leetcode.com/users/images/f058ffaf-3b0c-4f42-b831-c53d8a8515eb_1656934628.3738313.jpeg)\\n![image](https://assets.leetcode.com/users/images/22e9fafc-0f00-459c-847c-c5bfe0e699a4_1656934628.399924.jpeg)\\n\\n```\\nclass Solution \\n{\\n    public boolean repeatedSubstringPattern(String s) \\n    {\\n        int len = s.length();\\n        for(int i=len/2;i>=1;i--)\\n        {\\n            if(len%i == 0)\\n            {\\n                int repeats = len/i;\\n                String sub = s.substring(0,i);\\n                StringBuilder st = new StringBuilder();\\n                while(repeats-- > 0)\\n                    st.append(sub);\\n                if(st.toString().equals(s))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public boolean repeatedSubstringPattern(String s) \\n    {\\n        int len = s.length();\\n        for(int i=len/2;i>=1;i--)\\n        {\\n            if(len%i == 0)\\n            {\\n                int repeats = len/i;\\n                String sub = s.substring(0,i);\\n                StringBuilder st = new StringBuilder();\\n                while(repeats-- > 0)\\n                    st.append(sub);\\n                if(st.toString().equals(s))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585318,
                "title": "python-one-liner",
                "content": "```\\n\\ndef repeatedSubstringPattern(s):\\n        return s in (s+s)[1:-1]",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\ndef repeatedSubstringPattern(s):\\n        return s in (s+s)[1:-1]",
                "codeTag": "Python3"
            },
            {
                "id": 3938867,
                "title": "python3-beats-98-9-with-explanation-for-o-n",
                "content": "# Intuition\\n\\nShould I concat origibal string twice?\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s think my string s contains of two substring s1 and s2 that means s = (s1)(s2) and I have to check s1==s2 or not.\\n\\nAfter concatinating, my new string will look like (s1s2)(s1s2)\\n\\nnewS = s1s2s1s2\\n\\nLet\\'s remove the first and last character from newS, in order to manipulate the original string. After removing can we say, my newS will look like,\\n\\nnewS = s3s2s1s4 , as s3 and s4 are string after removing character\\n\\nNow let\\'s find out if s exists in newS or not, s=s1s2 can only exist\\nif s2s1 = s1s2\\n\\nNow let\\'s take a step back and think at what condition, s1s2 will be equal to s2s1?? Can I say, when s1=s2 only at that time s1s2=s2s1?\\n\\nthat means if s contains in newS, at that time we can say s1=s2 which means s =s1(s1)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) --> to check contains or not\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in s[1:]+s[:len(s)-1]\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in s[1:]+s[:len(s)-1]\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938737,
                "title": "c-uses-sieve-divisor-1-line-methods-solving-string-hard-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaybe it is shooting birds with a cannon.\\nUse sieve method to test whether n=s.length is a prime.\\nIf not, use the divisor i, n/i to test whether the string is the pattern.\\n\\nSecond approach doesn\\'t use any cannon and based on the divisors which is also fast.\\n\\nThird approach is a one line solution! \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe following is the demo for sieve method\\n[https://youtu.be/7GGhURLPnIs](https://youtu.be/7GGhURLPnIs)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code using sieve method Beats 95.17% in 11 ms\\n```\\nclass Solution {\\npublic:\\n    //Use sieve method to list a prime table\\n    vector<bool> isPrime;\\n    void sieve(int n){\\n        isPrime.assign(n+1, 1);\\n        isPrime[0]=isPrime[1]=0;\\n        int&& n_sqrt=int(sqrt(n));\\n        for(int&& i=2; i<=n_sqrt; i++){\\n            if (isPrime[i]){\\n                for(int j=i*i ; j<=n; j+=i)\\n                    isPrime[j]=0;\\n            }\\n        }\\n    }\\n    string repeatString(string& s , int k){\\n        string ans=\"\";\\n        for(int i=0; i<k; i++){\\n            ans+=s;\\n        }\\n        return ans;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n        if (n==1) return 0;\\n        sieve(n); \\n        char s0=s[0];\\n        if (isPrime[n]){// only divisor 1 & n\\n            return string(n, s0)==s;\\n        }\\n        int sqrt_n=sqrt(n);\\n        for(int i=1; i<=sqrt_n; i++){\\n            if (n%i==0){\\n                if (s0==s[i]){\\n                    string ss=s.substr(0, i);\\n                    if (s==repeatString(ss, n/i)) \\n                        return 1;\\n                }\\n                if (s[n/i]==s0){\\n                    string ss=s.substr(0, n/i);\\n                    if (s==repeatString(ss, i))\\n                        return 1;\\n                }              \\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n# Using divisor method Beats 95.17% in 11 ms\\n```\\n    string repeatString(string& s , int k){\\n        string ans=\"\";\\n        for(int i=0; i<k; i++){\\n            ans+=s;\\n        }\\n        return ans;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n        if (n==1) return 0;\\n        char s0=s[0];\\n        int d=0, k;\\n        int sqrt_n=sqrt(n);\\n        for(int i=1; i<=sqrt_n; i++){\\n            if (n%i==0){\\n                if (s0==s[i]){\\n                    string ss=s.substr(0, i);\\n                    if (s==repeatString(ss, n/i)) \\n                        return 1;\\n                }\\n                if (s[n/i]==s0 && i!=1){\\n                    string ss=s.substr(0, n/i);\\n                    if (s==repeatString(ss, i))\\n                        return 1;\\n                }              \\n            }\\n        }\\n        return 0;\\n    }\\n```\\n# One line solution\\n```\\nreturn (s+s).substr(1, s.size()*2-2).find(s)!=-1;\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Use sieve method to list a prime table\\n    vector<bool> isPrime;\\n    void sieve(int n){\\n        isPrime.assign(n+1, 1);\\n        isPrime[0]=isPrime[1]=0;\\n        int&& n_sqrt=int(sqrt(n));\\n        for(int&& i=2; i<=n_sqrt; i++){\\n            if (isPrime[i]){\\n                for(int j=i*i ; j<=n; j+=i)\\n                    isPrime[j]=0;\\n            }\\n        }\\n    }\\n    string repeatString(string& s , int k){\\n        string ans=\"\";\\n        for(int i=0; i<k; i++){\\n            ans+=s;\\n        }\\n        return ans;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n        if (n==1) return 0;\\n        sieve(n); \\n        char s0=s[0];\\n        if (isPrime[n]){// only divisor 1 & n\\n            return string(n, s0)==s;\\n        }\\n        int sqrt_n=sqrt(n);\\n        for(int i=1; i<=sqrt_n; i++){\\n            if (n%i==0){\\n                if (s0==s[i]){\\n                    string ss=s.substr(0, i);\\n                    if (s==repeatString(ss, n/i)) \\n                        return 1;\\n                }\\n                if (s[n/i]==s0){\\n                    string ss=s.substr(0, n/i);\\n                    if (s==repeatString(ss, i))\\n                        return 1;\\n                }              \\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\n    string repeatString(string& s , int k){\\n        string ans=\"\";\\n        for(int i=0; i<k; i++){\\n            ans+=s;\\n        }\\n        return ans;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n        if (n==1) return 0;\\n        char s0=s[0];\\n        int d=0, k;\\n        int sqrt_n=sqrt(n);\\n        for(int i=1; i<=sqrt_n; i++){\\n            if (n%i==0){\\n                if (s0==s[i]){\\n                    string ss=s.substr(0, i);\\n                    if (s==repeatString(ss, n/i)) \\n                        return 1;\\n                }\\n                if (s[n/i]==s0 && i!=1){\\n                    string ss=s.substr(0, n/i);\\n                    if (s==repeatString(ss, i))\\n                        return 1;\\n                }              \\n            }\\n        }\\n        return 0;\\n    }\\n```\n```\\nreturn (s+s).substr(1, s.size()*2-2).find(s)!=-1;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545887,
                "title": "shortest-and-best-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public static boolean repeatedSubstringPattern(String s) {\\n        String str = s + s;\\n        String str1 = str.substring(1, str.length() - 1);\\n        return str1.contains(s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean repeatedSubstringPattern(String s) {\\n        String str = s + s;\\n        String str1 = str.substring(1, str.length() - 1);\\n        return str1.contains(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892885,
                "title": "c-easy-3-solutions-o-n",
                "content": "### 3 different solutions\\n\\n<br>\\n\\n1. Doubling the array (One liner)\\n\\n```\\n\\tbool repeatedSubstringPattern(string s) {\\n        return (s+s).substr(1, (s.size()*2) - 2).find(s)!=-1;\\n\\t}\\n```\\n<br>\\n\\n2. Comparison by appending all possible substring of length <= n/2\\n\\n```\\nbool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n        string s1 = \"\", s2 = \"\";\\n        for(int i=1; i<=n/2; i++) {\\n            if (n%i == 0) {\\n                s1 = s.substr(0, i);\\n                s2 = \"\";\\n                for(int j=0; j<n/i; j++) {\\n                    s2 += s1;\\n                }\\n                \\n                if(s==s2) return true;\\n            }\\n        }\\n\\t\\treturn false;\\n    }\\n```\\n\\n<br>\\n\\n3. Using KMP \"lps\" table as array\\n\\n```\\nbool repeatedSubstringPattern(string s) {\\n\\tint n = s.size();\\n\\n\\tif(n==1) return false;\\n\\n\\tvector<int> lps(n, 0);\\n\\n\\tint j=0;\\n\\tfor(int i=1; i<n; i++) {\\n\\t\\tif (s[i]==s[j]) {\\n\\t\\t\\tlps[i] = j+1;\\n\\t\\t\\tj++;\\n\\t\\t} else {\\n\\t\\t\\twhile(j>0) {\\n\\t\\t\\t\\tj = (j>0) ? lps[j-1] : 0;\\n\\t\\t\\t\\tif (s[i]==s[j]) {\\n\\t\\t\\t\\t\\tlps[i] = j+1;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (j==0) lps[i]=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (lps[n-1]>0 && n%(n-lps[n-1]) == 0 ) {\\n\\t\\treturn true;\\n\\t} else {\\n\\t\\treturn false;\\n\\t}\\n}\\n```\\n\\nPlease do upvote if you find this helpful.\\nFeel free to comment down your queries.",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n\\tbool repeatedSubstringPattern(string s) {\\n        return (s+s).substr(1, (s.size()*2) - 2).find(s)!=-1;\\n\\t}\\n```\n```\\nbool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n        string s1 = \"\", s2 = \"\";\\n        for(int i=1; i<=n/2; i++) {\\n            if (n%i == 0) {\\n                s1 = s.substr(0, i);\\n                s2 = \"\";\\n                for(int j=0; j<n/i; j++) {\\n                    s2 += s1;\\n                }\\n                \\n                if(s==s2) return true;\\n            }\\n        }\\n\\t\\treturn false;\\n    }\\n```\n```\\nbool repeatedSubstringPattern(string s) {\\n\\tint n = s.size();\\n\\n\\tif(n==1) return false;\\n\\n\\tvector<int> lps(n, 0);\\n\\n\\tint j=0;\\n\\tfor(int i=1; i<n; i++) {\\n\\t\\tif (s[i]==s[j]) {\\n\\t\\t\\tlps[i] = j+1;\\n\\t\\t\\tj++;\\n\\t\\t} else {\\n\\t\\t\\twhile(j>0) {\\n\\t\\t\\t\\tj = (j>0) ? lps[j-1] : 0;\\n\\t\\t\\t\\tif (s[i]==s[j]) {\\n\\t\\t\\t\\t\\tlps[i] = j+1;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (j==0) lps[i]=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (lps[n-1]>0 && n%(n-lps[n-1]) == 0 ) {\\n\\t\\treturn true;\\n\\t} else {\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1761482,
                "title": "python-two-approaches-simple-and-easy",
                "content": "Approach 1:\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        N = len(s)\\n        for idx in range(1, N//2+1):\\n            if N%idx==0:\\n                subString = s[:idx]\\n                if subString*(N//idx) == s:\\n                    return True\\n        return False\\n```\\n\\nApproach 2:\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        newS = (s+s)[1:-1]\\n        return s in newS\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        N = len(s)\\n        for idx in range(1, N//2+1):\\n            if N%idx==0:\\n                subString = s[:idx]\\n                if subString*(N//idx) == s:\\n                    return True\\n        return False\\n```\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        newS = (s+s)[1:-1]\\n        return s in newS\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325804,
                "title": "simple-c-solution-with-detailed-explanation",
                "content": "``` \\n    bool repeatedSubstringPattern(string s) {\\n        if (s == \"\") {\\n            return false;\\n        }\\n        string doubleS = s + s;\\n        return doubleS.find(s, 1) < s.size();\\n    }\\n```\\nIf the input string length is 0, then it mens that there\\'s no way for it to be constructed with repeated substring, and we will return false.\\n\\nFor an input string s with length n (n >= 1), we can represent it as s = s[0]s[1]s[2]...s[n-1]. For any m in the range of 0 and n-1, s[m] is a char indexed at m in the input string s.\\n\\nWe define a rotation of the input string by removing the first char from it and concatenating the removed char to the end of the input string.\\n\\nFor example a rotation of the string s is s\\' = s[1]s[2]...s[n-1]s[0]. Two rotations of string s is to remove first two chars from s and concatenate them to the end of the string (i.e. s\\'\\' = s[2]s[3]...s[n-1]s[0]s[1]).\\n\\nWe can easily see that s is the same as itself after 0 or n times of rotations. What we will do is to prove that if string s\\' which is generated by s after m times (0 < m < n) of rotations is the same as s then s is composed by n/m substrings s[0]s[1]...s[m-1].\\n\\nIf the input string is s = s[0]s[1]s[2]...s[n-1], after m times (e.g. m = 3) of rotations the new string s\\' = s[3]s[4]s[5]...s[n-1]s[0]s[1]s[2].\\n\\nIf s = s\\' then\\ns[0]s[1]s[2]s[3]s[4]s[5]...s[n-6]s[n-5]s[n-4]s[n-3]s[n-2]s[n-1] is the same as\\ns[3]s[4]s[5]s[6]s[7]s[8]...s[n-3]s[n-2]s[n-1]s[0]s[1]s[2]\\n\\nso\\ns[0]s[1]s[2] = s[n-3]s[n-2]s[n-1]\\ns[3]s[4]s[5] = s[0]s[1]s[2]\\ns[6]s[7]s[8] = s[3]s[4]s[5]\\n.\\n.\\n.\\ns[n-3]s[n-2]s[n-1] = s[n-6]s[n-5]s[n-4]\\n\\nso\\ns[0]s[1]s[2] = s[3]s[4]s[5] = s[6]s[7]s[8] = ... = s[n-6]s[n-5]s[n-4] = s[n-3]s[n-2]s[n-1]\\n\\nso string s consists of n/m substrings s[0]s[1]...s[m-1], in the above proof m = 3.\\n\\nWith the above proof, if we can find a rotation m which is larger than 0 and less than n then the input string consists of repeated substrings.\\n\\nWe can concatenate the input string s which length is n with itself to form a new string str = s+s, if we can find a substring s in str which is indexed larger than 0 and lower than n then it means s can be the same as itself after m times of rotations where 0<m<n, then s must consist of repeated substrings.\\n",
                "solutionTags": [],
                "code": "``` \\n    bool repeatedSubstringPattern(string s) {\\n        if (s == \"\") {\\n            return false;\\n        }\\n        string doubleS = s + s;\\n        return doubleS.find(s, 1) < s.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1016467,
                "title": "kmp",
                "content": "```\\n/* When we finish creating the lps array, In this scenario, the last value will contain the Length of the largest substring. If we are deducting it from \\n   the length of the entire strin, we will get the length of the smallest substring pattern. which \\n   is 2 for String ABABAB. Suppose the string is ABCABCABC. ABCABCABC --> KMP Table will be : \\n   0 0 0 1 2 3 4 5 6. The value of the smallest substring will be 3 (ABC --> 9 (Length of the Entire \\n   String) - 6 (Last Value of the LPS Array)). */\\n\\n\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        if(null == s || s.trim().length() == 0){\\n            return false;\\n        }\\n        s = s.trim();\\n        int strLen = s.length();\\n        int lps[] = new int[strLen];\\n        createLPSArr(s, lps);\\n        int patternLen = strLen - lps[lps.length - 1];\\n        if(patternLen == strLen){\\n            return false;\\n        }\\n        if(s.length() % patternLen != 0){\\n            return false;\\n        }\\n        return true;\\n    }\\n    private void createLPSArr(String pattern, int[] lps){\\n        int patternLength = pattern.length();\\n        int i = 1;\\n        int j = 0;\\n        while(i < patternLength){\\n            if(pattern.charAt(i) == pattern.charAt(j)){\\n                j++;\\n                lps[i] = j;\\n                i++;\\n            }else {\\n                if(j == 0){\\n                    i++;\\n                }else{\\n                    j = lps[j-1];\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/* When we finish creating the lps array, In this scenario, the last value will contain the Length of the largest substring. If we are deducting it from \\n   the length of the entire strin, we will get the length of the smallest substring pattern. which \\n   is 2 for String ABABAB. Suppose the string is ABCABCABC. ABCABCABC --> KMP Table will be : \\n   0 0 0 1 2 3 4 5 6. The value of the smallest substring will be 3 (ABC --> 9 (Length of the Entire \\n   String) - 6 (Last Value of the LPS Array)). */\\n\\n\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        if(null == s || s.trim().length() == 0){\\n            return false;\\n        }\\n        s = s.trim();\\n        int strLen = s.length();\\n        int lps[] = new int[strLen];\\n        createLPSArr(s, lps);\\n        int patternLen = strLen - lps[lps.length - 1];\\n        if(patternLen == strLen){\\n            return false;\\n        }\\n        if(s.length() % patternLen != 0){\\n            return false;\\n        }\\n        return true;\\n    }\\n    private void createLPSArr(String pattern, int[] lps){\\n        int patternLength = pattern.length();\\n        int i = 1;\\n        int j = 0;\\n        while(i < patternLength){\\n            if(pattern.charAt(i) == pattern.charAt(j)){\\n                j++;\\n                lps[i] = j;\\n                i++;\\n            }else {\\n                if(j == 0){\\n                    i++;\\n                }else{\\n                    j = lps[j-1];\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827897,
                "title": "c-24ms-o-n-find-prime-divisors-and-compare-explained",
                "content": "Firstly I should say this method is ristricted by the condition `string length will not exceed 10000`.\\n\\nSo, if we are able to find a repeated substring pattern in a string, the length of string `N` must either:\\n- N is **NOT** a prime number (is divisible by one or more integers that 2<= d < N)\\n- N is a prime number, and the string contains only one character that repeated N times\\n\\nIf we can find a pattern that is repeated, say, 6 times, we can also treat the string has patterns that repeat 2 or 3 times. Therefore, we only need to check **prime divisors**. \\n- N is divisible by one or more prime numbers that < 101 (since 101^2 > 10000)\\n- N is a prime number, and the string contains only one character that repeated N times\\n\\nSo we only need to check at most 25 times to find all the candidate divisions. Also since 2\\\\*3\\\\*5\\\\*7\\\\*11\\\\*13>10000, the number of candidates is at most 5.\\n\\nThen for each candidate `d`, we divide the string into `d` sections, and compare section 2 to section 1, then compare section 3 to section 2, and so on. If we find any unmatched character, quit the loop and try next candidate. If we successfully processed to the end of the string, a pattern is found.\\nWe use two pointers to do this comparison.\\n\\nThe worst case time complexity is O(25+5n), ie O(n).\\n\\n```cpp\\nbool repeatedSubstringPattern(string s) {\\n    const int N = s.size();\\n    const vector<int> primes{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\\n                             43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\\n    vector<int> divisors;\\n    int prod = 1;\\n    for (int p : primes) {\\n        if (prod*p > N) break;\\n        if (N%p == 0) {\\n            divisors.push_back(p);\\n            prod *= p;\\n        }\\n    }\\n\\n    for (int d : divisors) {\\n        int l = 0, r = N/d;\\n        for (; r < N; ++l, ++r) {\\n            if (s[l] != s[r]) break;\\n        }\\n        if (r == N) return true;\\n    }\\n    return false;\\n}\\n```\\n\\n----\\nWhat if the string length can be much much longer, or unlimited?\\nThen the KMP method might be a wiser choice. :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nbool repeatedSubstringPattern(string s) {\\n    const int N = s.size();\\n    const vector<int> primes{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\\n                             43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\\n    vector<int> divisors;\\n    int prod = 1;\\n    for (int p : primes) {\\n        if (prod*p > N) break;\\n        if (N%p == 0) {\\n            divisors.push_back(p);\\n            prod *= p;\\n        }\\n    }\\n\\n    for (int d : divisors) {\\n        int l = 0, r = N/d;\\n        for (; r < N; ++l, ++r) {\\n            if (s[l] != s[r]) break;\\n        }\\n        if (r == N) return true;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 541051,
                "title": "python-solution-with-in-depth-explanation",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        #the length of the substring has to be a divsor\\n        #of the original string\\n        \\n        #start at the half way mark and see if i to the \\n        #half way mark matches the rest of the string\\n        \\n        length = len(s)\\n        \\n        for i in range(length//2 , 0, -1):   \\n            if(length % i == 0):\\n                string = s[:i]\\n                times = length//i\\n                ns = \"\"\\n                for j in range(0,times):\\n                    ns+=string\\n                if(ns == s):\\n                    return True\\n        return False\\n\\'\\'\\'\\n\\nIn order to obtain our solution, what we first have to realize is that our substring length HAS to be easily divisible by the original string length. What this means is that our substring has to be a length that is a multiple of the original sting length (i.e. original string length = 9, which means our substring length has to be of length 3 (since 3 is the only divisible number by 9 --another example -- original string length = 4, substring  length has to be 2)\\n\\nThe easiest way to obtain a divsor of the original string is to start at the half way point. Why we start at the half way point is because we will build our substring starting at index 0, to the halfway point and compare this with the rest of the string. We decrement by -1 in the case where the halfway point is NOT divisble by the original string length (i.e. string length = 9, half = 4 which is not a divisor of 9, decrement by -1 to get 3 which will be the length of the substring)\\n\\n\"string = s[:i]\" will build our substring to match on the rest of the original string. We need to know how many times to mutiply this substring in order to get the length of our original string (so we can compare them) so we divide the length of our original string by the length of our substring to get the number of times we need to \"clone\" our string. This is what the second for loop is for.\\n\\nAfter the second for loop, we should have a new substring that is of length of the original string. We now compare this substring to see if it matches the original string. If it does, then we return true. \\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        #the length of the substring has to be a divsor\\n        #of the original string\\n        \\n        #start at the half way mark and see if i to the \\n        #half way mark matches the rest of the string\\n        \\n        length = len(s)\\n        \\n        for i in range(length//2 , 0, -1):   \\n            if(length % i == 0):\\n                string = s[:i]\\n                times = length//i\\n                ns = \"\"\\n                for j in range(0,times):\\n                    ns+=string\\n                if(ns == s):\\n                    return True\\n        return False\\n\\'\\'\\'\\n\\nIn order to obtain our solution, what we first have to realize is that our substring length HAS to be easily divisible by the original string length. What this means is that our substring has to be a length that is a multiple of the original sting length (i.e. original string length = 9, which means our substring length has to be of length 3 (since 3 is the only divisible number by 9 --another example -- original string length = 4, substring  length has to be 2)\\n\\nThe easiest way to obtain a divsor of the original string is to start at the half way point. Why we start at the half way point is because we will build our substring starting at index 0, to the halfway point and compare this with the rest of the string. We decrement by -1 in the case where the halfway point is NOT divisble by the original string length (i.e. string length = 9, half = 4 which is not a divisor of 9, decrement by -1 to get 3 which will be the length of the substring)\\n\\n\"string = s[:i]\" will build our substring to match on the rest of the original string. We need to know how many times to mutiply this substring in order to get the length of our original string (so we can compare them) so we divide the length of our original string by the length of our substring to get the number of times we need to \"clone\" our string. This is what the second for loop is for.\\n\\nAfter the second for loop, we should have a new substring that is of length of the original string. We now compare this substring to see if it matches the original string. If it does, then we return true. \\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 479942,
                "title": "python-easy-solution",
                "content": "Let say s consists of n sub strings a, that is, s = n* a. So for s+s, which is 2n * a, there must be at least one s in (s+s)[1:-1].\\n```\\ndef repeatedSubstringPattern(self, s: str) -> bool:\\n        return (s + s)[1:-1].find(s) != -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef repeatedSubstringPattern(self, s: str) -> bool:\\n        return (s + s)[1:-1].find(s) != -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 140743,
                "title": "java-one-liner",
                "content": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        return ((s+s).substring(1, 2*s.length()-1).contains(s)); \\n    }\\n}\\n```\\nUpdate : Thanks to [liweiweiwei](https://leetcode.com/liweiweiwei/)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        return ((s+s).substring(1, 2*s.length()-1).contains(s)); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020376,
                "title": "2-line-python-solution-briefly-explained",
                "content": "# Approach\\nThis Python code defines a class `Solution` with a method `repeatedSubstringPattern` that checks if a given string `s` can be formed by repeating a substring within itself.\\n\\nHere\\'s a brief explanation of the code:\\n\\n1. `ss = (s + s)[1:-1]`: This line creates a new string `ss` by concatenating the input string `s` with itself (doubling it). `[1:-1]` slices this doubled string, removing the first and last characters. This effectively removes the first character of `s` and the last character of `s` from `ss`.\\n\\n2. `return s in ss`: This line checks if the original string `s` is a substring of `ss`. If it is, that means `s` can be formed by repeating a substring within itself, so the method returns `True`. Otherwise, it returns `False`.\\n\\nIn essence, this code checks if `s` can be constructed by repeating a portion of itself, and it does this by creating a new string `ss` where `s` is doubled and the first and last characters are removed. Then, it checks if `s` is a substring of `ss`. If it is, it returns `True`; otherwise, it returns `False`.\\n\\n# Code\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        ss = (s+s)[1:-1]\\n        return s in ss\\n```\\n\\n**Please upvote if you like the solution.\\nHappy Coding! \\uD83D\\uDE0A**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        ss = (s+s)[1:-1]\\n        return s in ss\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938585,
                "title": "beats-100-js-ts-java-c-c-c-php-python-python3-kotlin",
                "content": "---\\n![header_.png](https://assets.leetcode.com/users/images/ab4510d5-90e7-4616-b1e1-aac91ec90eea_1692159981.2067795.png)\\n\\n---\\n**Approach**\\nTo solve this problem, you can use a sliding window approach to check if the string `s` can be constructed by repeating a substring. Here\\'s an approach to solve this problem:\\n\\n1. Start with a window size of 1 and try to find a repeated substring within the given string `s`. Increase the window size until you reach half the length of the string. The reason for considering only half the length is that if the repeated substring is longer than half of the string, it cannot be repeated multiple times to form the original string.\\n\\n2. For each window size, check if the string `s` can be formed by repeating the substring of that size. If it can, return `true`.\\n\\n3. If you can\\'t find a repeated substring for all window sizes, return `false`.\\n\\n**Time Complexity**:\\nIn the worst case, you would need to check for repeated substrings for all possible window sizes from 1 to n/2. For each window size, you are comparing the substring with the original string, which takes O(n) time. Therefore, the overall time complexity of this approach is O(n^2).\\n\\n- Keep in mind that this is not the most efficient approach, but it\\'s simple and works within the given constraints. There are more optimized algorithms that can solve this problem in linear time complexity, but they are more complex to implement.\\n\\n---\\n```Javascript []\\nvar repeatedSubstringPattern = function(s) {\\n    const n = s.length;\\n    \\n    for (let len = 1; len <= n / 2; len++) {\\n        if (n % len === 0) {\\n            const substring = s.slice(0, len);\\n            let repeated = \\'\\';\\n            \\n            for (let i = 0; i < n / len; i++) {\\n                repeated += substring;\\n            }\\n            \\n            if (repeated === s) {\\n                return true;\\n            }\\n        }\\n    }\\n    \\n    return false;\\n};\\n```\\n```Typescript []\\nfunction repeatedSubstringPattern(s: string): boolean {\\n    const n = s.length;\\n    \\n    for (let len = 1; len <= n / 2; len++) {\\n        if (n % len === 0) {\\n            const repeatedSubstring = s.slice(0, len);\\n            let formedString = \"\";\\n            \\n            for (let i = 0; i < n / len; i++) {\\n                formedString += repeatedSubstring;\\n            }\\n            \\n            if (formedString === s) {\\n                return true;\\n            }\\n        }\\n    }\\n    \\n    return false;\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n = len(s)\\n        \\n        for length in range(1, n // 2 + 1):\\n            if n % length == 0:  # Check only if length divides n\\n                substring = s[:length]\\n                times = n // length\\n                if substring * times == s:\\n                    return True\\n                \\n        return False\\n```\\n```Python []\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, s):\\n        n = len(s)\\n        for length in range(1, n // 2 + 1):  # Possible substring lengths\\n            if n % length == 0:  # Check if it\\'s a valid length for repetition\\n                substring = s[:length]\\n                if substring * (n // length) == s:  # Check if repetition works\\n                    return True\\n        return False\\n```\\n```Kotlin []\\nclass Solution {\\n    fun repeatedSubstringPattern(s: String): Boolean {\\n        val n = s.length\\n        \\n        for (i in 1..n / 2) {\\n            if (n % i == 0) {\\n                val substring = s.substring(0, i)\\n                val repeatedString = buildString { repeat(n / i) { append(substring) } }\\n                \\n                if (repeatedString == s) {\\n                    return true\\n                }\\n            }\\n        }\\n        \\n        return false\\n    }\\n}\\n```\\n```Java []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length();\\n\\n        for (int len = 1; len <= n / 2; len++) {\\n            if (n % len == 0) {\\n                String substring = s.substring(0, len);\\n                StringBuilder repeated = new StringBuilder();\\n\\n                for (int i = 0; i < n / len; i++) {\\n                    repeated.append(substring);\\n                }\\n\\n                if (repeated.toString().equals(s)) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n```PHP []\\nclass Solution {\\n    function repeatedSubstringPattern($s) {\\n        $n = strlen($s);\\n        \\n        // Iterate through possible substring lengths\\n        for ($len = 1; $len <= $n / 2; $len++) {\\n            if ($n % $len == 0) {  // Check if the length is a divisor of n\\n                $sub = substr($s, 0, $len);  // Get the current potential substring\\n                \\n                // Construct the new string using the current substring\\n                $newString = \"\";\\n                for ($i = 0; $i < $n / $len; $i++) {\\n                    $newString .= $sub;\\n                }\\n                \\n                // If the new string is equal to the original string, return true\\n                if ($newString == $s) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;  // If no such substring found\\n    }\\n}\\n```\\n```C []\\n#include <stdbool.h>\\n#include <string.h>\\n\\nbool repeatedSubstringPattern(char *s) {\\n    int n = strlen(s);\\n    \\n    // Check divisors of n\\n    for (int i = 1; i <= n / 2; i++) {\\n        if (n % i == 0) {\\n            int numRepeats = n / i;\\n            \\n            // Create the potential substring\\n            char substring[i + 1];\\n            strncpy(substring, s, i);\\n            substring[i] = \\'\\\\0\\';\\n            \\n            // Construct the repeated string\\n            char repeatedString[n + 1];\\n            repeatedString[0] = \\'\\\\0\\';\\n            for (int j = 0; j < numRepeats; j++) {\\n                strcat(repeatedString, substring);\\n            }\\n            \\n            // Check if the constructed string matches the original string\\n            if (strcmp(repeatedString, s) == 0) {\\n                return true;\\n            }\\n        }\\n    }\\n    \\n    return false;\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        \\n        for (int len = 1; len <= n / 2; len++) {\\n            if (n % len == 0) {\\n                string substring = s.substr(0, len);\\n                string constructed = \"\";\\n                \\n                for (int i = 0; i < n / len; i++) {\\n                    constructed += substring;\\n                }\\n                \\n                if (constructed == s) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n```C# []\\npublic class Solution {\\n    public bool RepeatedSubstringPattern(string s) {\\n        int n = s.Length;\\n        \\n        for (int len = 1; len <= n / 2; len++) {\\n            if (n % len == 0) {\\n                string substring = s.Substring(0, len);\\n                StringBuilder sb = new StringBuilder();\\n\\n                for (int i = 0; i < n / len; i++) {\\n                    sb.Append(substring);\\n                }\\n\\n                if (sb.ToString() == s) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n---\\n![download.jpg](https://assets.leetcode.com/users/images/5196fec2-1dd4-4b82-9700-36c5a0e72623_1692159956.9446952.jpeg)\\n\\n---",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "C#",
                    "JavaScript",
                    "Kotlin",
                    "PHP",
                    "TypeScript"
                ],
                "code": "```Javascript []\\nvar repeatedSubstringPattern = function(s) {\\n    const n = s.length;\\n    \\n    for (let len = 1; len <= n / 2; len++) {\\n        if (n % len === 0) {\\n            const substring = s.slice(0, len);\\n            let repeated = \\'\\';\\n            \\n            for (let i = 0; i < n / len; i++) {\\n                repeated += substring;\\n            }\\n            \\n            if (repeated === s) {\\n                return true;\\n            }\\n        }\\n    }\\n    \\n    return false;\\n};\\n```\n```Typescript []\\nfunction repeatedSubstringPattern(s: string): boolean {\\n    const n = s.length;\\n    \\n    for (let len = 1; len <= n / 2; len++) {\\n        if (n % len === 0) {\\n            const repeatedSubstring = s.slice(0, len);\\n            let formedString = \"\";\\n            \\n            for (let i = 0; i < n / len; i++) {\\n                formedString += repeatedSubstring;\\n            }\\n            \\n            if (formedString === s) {\\n                return true;\\n            }\\n        }\\n    }\\n    \\n    return false;\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n = len(s)\\n        \\n        for length in range(1, n // 2 + 1):\\n            if n % length == 0:  # Check only if length divides n\\n                substring = s[:length]\\n                times = n // length\\n                if substring * times == s:\\n                    return True\\n                \\n        return False\\n```\n```Python []\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, s):\\n        n = len(s)\\n        for length in range(1, n // 2 + 1):  # Possible substring lengths\\n            if n % length == 0:  # Check if it\\'s a valid length for repetition\\n                substring = s[:length]\\n                if substring * (n // length) == s:  # Check if repetition works\\n                    return True\\n        return False\\n```\n```Kotlin []\\nclass Solution {\\n    fun repeatedSubstringPattern(s: String): Boolean {\\n        val n = s.length\\n        \\n        for (i in 1..n / 2) {\\n            if (n % i == 0) {\\n                val substring = s.substring(0, i)\\n                val repeatedString = buildString { repeat(n / i) { append(substring) } }\\n                \\n                if (repeatedString == s) {\\n                    return true\\n                }\\n            }\\n        }\\n        \\n        return false\\n    }\\n}\\n```\n```Java []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length();\\n\\n        for (int len = 1; len <= n / 2; len++) {\\n            if (n % len == 0) {\\n                String substring = s.substring(0, len);\\n                StringBuilder repeated = new StringBuilder();\\n\\n                for (int i = 0; i < n / len; i++) {\\n                    repeated.append(substring);\\n                }\\n\\n                if (repeated.toString().equals(s)) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\n```PHP []\\nclass Solution {\\n    function repeatedSubstringPattern($s) {\\n        $n = strlen($s);\\n        \\n        // Iterate through possible substring lengths\\n        for ($len = 1; $len <= $n / 2; $len++) {\\n            if ($n % $len == 0) {  // Check if the length is a divisor of n\\n                $sub = substr($s, 0, $len);  // Get the current potential substring\\n                \\n                // Construct the new string using the current substring\\n                $newString = \"\";\\n                for ($i = 0; $i < $n / $len; $i++) {\\n                    $newString .= $sub;\\n                }\\n                \\n                // If the new string is equal to the original string, return true\\n                if ($newString == $s) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;  // If no such substring found\\n    }\\n}\\n```\n```C []\\n#include <stdbool.h>\\n#include <string.h>\\n\\nbool repeatedSubstringPattern(char *s) {\\n    int n = strlen(s);\\n    \\n    // Check divisors of n\\n    for (int i = 1; i <= n / 2; i++) {\\n        if (n % i == 0) {\\n            int numRepeats = n / i;\\n            \\n            // Create the potential substring\\n            char substring[i + 1];\\n            strncpy(substring, s, i);\\n            substring[i] = \\'\\\\0\\';\\n            \\n            // Construct the repeated string\\n            char repeatedString[n + 1];\\n            repeatedString[0] = \\'\\\\0\\';\\n            for (int j = 0; j < numRepeats; j++) {\\n                strcat(repeatedString, substring);\\n            }\\n            \\n            // Check if the constructed string matches the original string\\n            if (strcmp(repeatedString, s) == 0) {\\n                return true;\\n            }\\n        }\\n    }\\n    \\n    return false;\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        \\n        for (int len = 1; len <= n / 2; len++) {\\n            if (n % len == 0) {\\n                string substring = s.substr(0, len);\\n                string constructed = \"\";\\n                \\n                for (int i = 0; i < n / len; i++) {\\n                    constructed += substring;\\n                }\\n                \\n                if (constructed == s) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\n```C# []\\npublic class Solution {\\n    public bool RepeatedSubstringPattern(string s) {\\n        int n = s.Length;\\n        \\n        for (int len = 1; len <= n / 2; len++) {\\n            if (n % len == 0) {\\n                string substring = s.Substring(0, len);\\n                StringBuilder sb = new StringBuilder();\\n\\n                for (int i = 0; i < n / len; i++) {\\n                    sb.Append(substring);\\n                }\\n\\n                if (sb.ToString() == s) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2003734,
                "title": "java-very-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String a1=s+s;\\n        String a2=a1.substring(1,a1.length()-1);\\n        if(a2.contains(s)) return true;\\n        else return false;\\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String a1=s+s;\\n        String a2=a1.substring(1,a1.length()-1);\\n        if(a2.contains(s)) return true;\\n        else return false;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1868705,
                "title": "python-beats-94",
                "content": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        ds = (s+s)[1:-1]\\n        print (ds)\\n        \\n        return s in ds\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        ds = (s+s)[1:-1]\\n        print (ds)\\n        \\n        return s in ds\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806593,
                "title": "simple-java-solution-better-than-88-of-solutions",
                "content": "# Logic :\\nIf the given string is made up of repeated substrings, then the lengths of those repeated substrings will be a factor of the length of the given string.\\n\\n#### Example :\\n\\nString of length 10.\\nxxxxxxxxxx\\n\\nThe factors of 10 = 5, 2, 1.\\n\\nSo, the repeated string can be of length 5, 2, 1.\\nxxxxx xxxxx\\nxx xx xx xx xx\\nx x x x x x x x x x.\\n\\nabcdeabcde, \"abcde\" is repeated.\\nababababab, \"ab\" is repeated.\\naaaaaaaaaaa, \"a\" is repeated.\\n\\n# Solution :\\n* Loop through the factors of the length of the given string.\\n* Using Sliding Window Approach, find out all the substrings taking the factors as the lengths of substrings. These substrings start after the previous substring has ended.\\n* Find out if all the substrings are equal, return true if such repetition is found.\\n* Return false, if no such repetition is found.\\n\\nThe solution is more efficient if we take the factors in descending order.\\n\\n#### Implementation :\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) \\n    {\\n        int len = s.length();\\n        int div=2;\\n        while(div<=len)\\n        {\\n            if(len%div==0)\\n            {\\n                int windowSize = len/div;\\n                // window size is equal to the factor\\n                String firstSubString = s.substring(0,windowSize);\\n                int start = windowSize;\\n                boolean substringRepeated = false;\\n                // Loop through all the remaining substrings\\n                while(start<len)\\n                {\\n                    String nextSubString = s.substring(start,start+windowSize);\\n                    start += windowSize;\\n                    if(firstSubString.equals(nextSubString)==false)\\n                    {\\n                        substringRepeated = false;\\n                        break;\\n                    }\\n                    substringRepeated = true;\\n                }\\n                if(substringRepeated)\\n                {\\n                    return true;\\n                }\\n            }\\n            div++;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nThis Solution takes around 10ms, and is better than around 88% of all Java Submissions.\\n\\nThis is my first time posting a solution on LeetCode. Please excuse any grammatical errors.",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) \\n    {\\n        int len = s.length();\\n        int div=2;\\n        while(div<=len)\\n        {\\n            if(len%div==0)\\n            {\\n                int windowSize = len/div;\\n                // window size is equal to the factor\\n                String firstSubString = s.substring(0,windowSize);\\n                int start = windowSize;\\n                boolean substringRepeated = false;\\n                // Loop through all the remaining substrings\\n                while(start<len)\\n                {\\n                    String nextSubString = s.substring(start,start+windowSize);\\n                    start += windowSize;\\n                    if(firstSubString.equals(nextSubString)==false)\\n                    {\\n                        substringRepeated = false;\\n                        break;\\n                    }\\n                    substringRepeated = true;\\n                }\\n                if(substringRepeated)\\n                {\\n                    return true;\\n                }\\n            }\\n            div++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154854,
                "title": "java-just-one-line",
                "content": "```\\nclass Solution {\\n    public static boolean repeatedSubstringPattern(String s) {\\n\\n        return (s.substring(1) + s.substring(0, s.length() - 1)).contains(s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean repeatedSubstringPattern(String s) {\\n\\n        return (s.substring(1) + s.substring(0, s.length() - 1)).contains(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897535,
                "title": "beats-100-well-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        \\n        // the idea is to find the occurence of some of \\n        // the substring within the string.\\n        \\n        // concatenate 2 strings together.\\n        string double_string = s+s;\\n        \\n        // remove the first element and also the last one\\n        double_string = double_string.substr(1);\\n        double_string.pop_back();\\n        \\n        // if still you find s in this string, then\\n        // there are more than 1 duplications, because\\n        // now it has been joined by another same string\\n        // but first and last elements are gone.\\n        return double_string.find(s) != -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        \\n        // the idea is to find the occurence of some of \\n        // the substring within the string.\\n        \\n        // concatenate 2 strings together.\\n        string double_string = s+s;\\n        \\n        // remove the first element and also the last one\\n        double_string = double_string.substr(1);\\n        double_string.pop_back();\\n        \\n        // if still you find s in this string, then\\n        // there are more than 1 duplications, because\\n        // now it has been joined by another same string\\n        // but first and last elements are gone.\\n        return double_string.find(s) != -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441605,
                "title": "kmp-o-n",
                "content": "```cpp\\nclass Solution {\\nprivate:\\n    vector<int> getPrefix(const string& p) {\\n        int n = p.size();\\n        vector<int> prefix(n, 0);\\n        for (int i=1; i<n; i++) {\\n            int j = prefix[i-1];\\n            while (j and p[i] != p[j]) j = prefix[j-1];\\n            prefix[i] = p[i] == p[j] ? j+1 : prefix[i];\\n        }\\n        return prefix;\\n    }\\npublic:\\n    bool repeatedSubstringPattern(const string& s) {\\n        auto prefix = getPrefix(s);\\n        int n = s.length(), last = prefix.back(), size = n - last;\\n        return last and !(last % size);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\nprivate:\\n    vector<int> getPrefix(const string& p) {\\n        int n = p.size();\\n        vector<int> prefix(n, 0);\\n        for (int i=1; i<n; i++) {\\n            int j = prefix[i-1];\\n            while (j and p[i] != p[j]) j = prefix[j-1];\\n            prefix[i] = p[i] == p[j] ? j+1 : prefix[i];\\n        }\\n        return prefix;\\n    }\\npublic:\\n    bool repeatedSubstringPattern(const string& s) {\\n        auto prefix = getPrefix(s);\\n        int n = s.length(), last = prefix.back(), size = n - last;\\n        return last and !(last % size);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350305,
                "title": "javascript-beats-both-100-1-line",
                "content": "```\\n\\n```var repeatedSubstringPattern = function(s) {\\n    return (s+s).substring(1, s.length*2-1).indexOf(s) != -1;\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 135210,
                "title": "python-common-o-n-solution",
                "content": "```\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool \\n        \"\"\"\\n        for i in range(1, len(s)):\\n            if len(s) % i == 0 and int(len(s)/i) * s[:i] == s:\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool \\n        \"\"\"\\n        for i in range(1, len(s)):\\n            if len(s) % i == 0 and int(len(s)/i) * s[:i] == s:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94349,
                "title": "z-function-o-n-solution",
                "content": "To solve this problem there was used z-function algorithm. Which calculates for each position how many characters starting from this position matches the prefix. Algorithm works in O(n) time;\\nTo check if there all characters are period we should check two conditions:\\n1) the length of prefix + zfunction value must be equal to the size of str. ( it will guarantee that exactly all elements exists in period\\n2) does characters between (i -- i+z[i]) and prefix covers all characters.\\n\\nI feel that there exists more elegant check for periods by using the z-function.  Any ideas about that?\\n\\n```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int n = str.length();\\n        int z[] = zFunction(str.toCharArray());\\n        \\n        for (int i=0; i<z.length; i++) {\\n            if (i+z[i]==n && z[i]*2>=str.length()) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private int [] zFunction(char c[]) {\\n        int n = c.length;\\n        int z[] = new int[n];\\n        \\n        int left = 0;\\n        int mostRight = 0;\\n        \\n        for (int i=1; i<n; i++) {\\n            if (i<=mostRight) {\\n                z[i] = Math.min(mostRight-i+1, z[i-left]);\\n            } \\n            while (i+z[i]<n && c[i+z[i]] == c[z[i]]) {\\n                z[i]++;\\n            }\\n            if (i+z[i]-1>mostRight) {\\n                mostRight = i+z[i]-1;\\n                left = i;\\n            }\\n        }\\n        return z;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int n = str.length();\\n        int z[] = zFunction(str.toCharArray());\\n        \\n        for (int i=0; i<z.length; i++) {\\n            if (i+z[i]==n && z[i]*2>=str.length()) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private int [] zFunction(char c[]) {\\n        int n = c.length;\\n        int z[] = new int[n];\\n        \\n        int left = 0;\\n        int mostRight = 0;\\n        \\n        for (int i=1; i<n; i++) {\\n            if (i<=mostRight) {\\n                z[i] = Math.min(mostRight-i+1, z[i-left]);\\n            } \\n            while (i+z[i]<n && c[i+z[i]] == c[z[i]]) {\\n                z[i]++;\\n            }\\n            if (i+z[i]-1>mostRight) {\\n                mostRight = i+z[i]-1;\\n                left = i;\\n            }\\n        }\\n        return z;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94415,
                "title": "repeated-substring-pattern-simple-java-solution-using-kmp",
                "content": "```\\npublic class Solution {\\n    /* KMP pattern table construction part */\\n    public boolean repeatedSubstringPattern(String str) {\\n        int n = str.length(), cur = 0, j = 1;\\n        int[] pattern = new int[n];\\n        pattern[0] = 0;\\n        \\n        while( j<n ) {\\n            if( str.charAt(cur) == str.charAt(j) ) {\\n                pattern[j++] = ++cur;\\n            }\\n            else {\\n                if( cur == 0 )  pattern[j++] = 0;\\n                else cur = pattern[cur-1]; /* start from beginning of current matching pattern */\\n            }\\n        }\\n        \\n        return (pattern[n-1] > 0 && n%(n-pattern[n-1]) == 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    /* KMP pattern table construction part */\\n    public boolean repeatedSubstringPattern(String str) {\\n        int n = str.length(), cur = 0, j = 1;\\n        int[] pattern = new int[n];\\n        pattern[0] = 0;\\n        \\n        while( j<n ) {\\n            if( str.charAt(cur) == str.charAt(j) ) {\\n                pattern[j++] = ++cur;\\n            }\\n            else {\\n                if( cur == 0 )  pattern[j++] = 0;\\n                else cur = pattern[cur-1]; /* start from beginning of current matching pattern */\\n            }\\n        }\\n        \\n        return (pattern[n-1] > 0 && n%(n-pattern[n-1]) == 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939992,
                "title": "o-n-sqrt-n-solution-c-sliding-window",
                "content": "# Intuition\\nThe size of repeatating string will always be divible by the total size.\\n# Approach\\nWe will check for all the mutiples of N (size of string).\\nAlso, let say we checked for the window size 8 and it was false, \\nthen obviously it will be false for it\\'s other factors like (4 , 2 , 1). \\n\\n# Complexity\\n- Time complexity: O(N* sqrt(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) to store this vector of indexes\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // this function will tkae O(N) time \\n    // as we will traverse every index only once\\n    bool check(string &s, int window, int &n) {\\n        vector<int> idxs; // starting index of all the parts \\n        for(int i=0;i<n;i+=window) {\\n            idxs.emplace_back(i);\\n        }\\n        int idx = idxs.back(), cnt=0;\\n        while(idx + cnt < n) {\\n            for(auto &i : idxs) \\n            if(s[i+cnt] != s[idx+cnt]) return false;\\n            cnt++;\\n        }\\n        return true;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n        if(n==1) return false;\\n        for(int i=2;i*i<=n;i++) { // O(sqrt(N))\\n            if(n%(n/i) == 0   && check(s,n/i,n))\\n                return true; \\n            if(n%i ==0 && (n/i)%i != 0 && check(s,i,n)) \\n                return true;\\n        }\\n\\n        return check(s,1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sliding Window",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // this function will tkae O(N) time \\n    // as we will traverse every index only once\\n    bool check(string &s, int window, int &n) {\\n        vector<int> idxs; // starting index of all the parts \\n        for(int i=0;i<n;i+=window) {\\n            idxs.emplace_back(i);\\n        }\\n        int idx = idxs.back(), cnt=0;\\n        while(idx + cnt < n) {\\n            for(auto &i : idxs) \\n            if(s[i+cnt] != s[idx+cnt]) return false;\\n            cnt++;\\n        }\\n        return true;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n        if(n==1) return false;\\n        for(int i=2;i*i<=n;i++) { // O(sqrt(N))\\n            if(n%(n/i) == 0   && check(s,n/i,n))\\n                return true; \\n            if(n%i ==0 && (n/i)%i != 0 && check(s,i,n)) \\n                return true;\\n        }\\n\\n        return check(s,1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939601,
                "title": "c-full-explanation-simplest-solution",
                "content": "# Introduction:\\nThe given solution addresses the problem of determining whether a given string can be constructed by taking a substring of itself and appending multiple copies of that substring together.\\n\\n**Step 1: Concatenation**\\n\\nFirst, the solution concatenates the input string str with itself, effectively creating a new string where the original str is repeated twice. For example, if str is \"abc\", then (str + str) becomes \"abcabc\".\\n**Step 2: Searching for Substring**\\n2.The solution uses the .find() method, a string method in C++, to search for the first occurrence of the original str substring within the concatenated string. This search starts from index 1. The search is started from index 1 to exclude the original string itself from being found, as we are interested in finding repeated substrings.\\n\\n**Step 3: Comparison with Length**\\n3. After finding the substring, the solution compares the index of the found substring with the length of the original string str.\\n\\n**Step 4: Decision Making**\\n4. If the index of the found substring is less than the length of the original string, this implies that a repeated substring was found within the concatenated string after the first occurrence. This indicates that the original string can be constructed by appending multiple copies of a substring.\\n\\n\\nTime Complexity:**O(n)**\\nSpace Complexity: **O(n)**\\n**The solution has a linear time complexity and linear space.**\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string str) {\\n        return (str + str).find(str, 1) < str.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string str) {\\n        return (str + str).find(str, 1) < str.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938810,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        ds=(s+s)[1:-1]\\n        return s in ds\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        ds=(s+s)[1:-1]\\n        return s in ds\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137907,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string temp= s+s;\\n        return temp.substr(1,temp.size()-2).find(s) != -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string temp= s+s;\\n        return temp.substr(1,temp.size()-2).find(s) != -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543091,
                "title": "c-easy-solution-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n       string mix=s+s;  //Adding string with it self\\n\\n       for(int i=1;i<n;i++)\\n       {\\n         string str=mix.substr(i,n);\\n         if(str==s) \\n              return true;\\n       }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n       string mix=s+s;  //Adding string with it self\\n\\n       for(int i=1;i<n;i++)\\n       {\\n         string str=mix.substr(i,n);\\n         if(str==s) \\n              return true;\\n       }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479599,
                "title": "python-c-java-beginner-level-2line-solution-as-simple-as-u-think-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q459. Repeated Substring Pattern***\\nGiven a string `s`, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        s_fold=s[1:]+s[:-1]\\n        return s in s_fold\\n```\\n**Runtime:**  55 ms\\t\\n**Memory Usage:**  14.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n     String str=s+s;\\n        return str.substring(1,str.length()-1).contains(s);\\n    }\\n}\\n```\\n**Runtime:**  91 ms\\t\\t\\n**Memory Usage:**  49.8 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string str=s+s;\\n        return str.substr(1,str.size()-2).find(s)!=-1;\\n    }\\n};\\n```\\n**Runtime:** 34 ms\\t\\n**Memory Usage:**  16.5 MB\\t\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        s_fold=s[1:]+s[:-1]\\n        return s in s_fold\\n```\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n     String str=s+s;\\n        return str.substring(1,str.length()-1).contains(s);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string str=s+s;\\n        return str.substr(1,str.size()-2).find(s)!=-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376770,
                "title": "c-comments-3-methods-with-without-function-faster-than-95",
                "content": "Without function \\n```\\nclass Solution\\n{\\npublic:\\n\\tbool repeatedSubstringPattern(string s){\\n\\t\\tint n = s.size();\\n\\t\\tfor (int i = 1; i < n; i++){\\n\\t\\t// to check if the string can be repeated to get the required string length\\n\\t\\t\\tif (n % i == 0){\\n\\t\\t\\t// getting the substring from 0 to i;\\n\\t\\t\\t\\tstring curr = s.substr(0, i);\\n\\t\\t\\t\\tbool flag = true;\\n\\t\\t\\t\\tfor (int j = i; j < n; j += curr.size()){\\n\\t\\t\\t\\t\\tif (curr != s.substr(j, i)){\\n\\t\\t\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (flag)           return true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n};\\n```\\nWith function\\n```\\nclass Solution {\\npublic:\\n    string repeat(string s, int n){\\n        string k = \"\";\\n        for(int i=0; i<n; i++)            k+=s;\\n        return k;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n\\t\\tint n = s.size();\\n        for(int i=n/2; i>=1; i--){\\n            if(n%i==0){\\n                if((repeat(s.substr(0, i), n/i)==s))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nUsing KMP\\n```\\nvoid computeLPSArray(char str[], int M, int lps[])\\n{\\n    // length of the previous longest prefix suffix\\n    int len = 0;\\n    int i;  \\n    lps[0] = 0; // lps[0] is always 0\\n    i = 1;\\n  \\n    // the loop calculates lps[i] for i = 1 to M-1\\n    while (i < M) {\\n        if (str[i] == str[len]) {\\n            len++;\\n            lps[i] = len;\\n            i++;\\n        }\\n        else // (pat[i] != pat[len])\\n        {\\n            if (len != 0) {\\n                // This is tricky. Consider the example\\n                // AAACAAAA and i = 7.\\n                len = lps[len - 1];\\n  \\n                // Also, note that we do not increment i\\n                // here\\n            }\\n            else // if (len == 0)\\n            {\\n                lps[i] = 0;\\n                i++;\\n            }\\n        }\\n    }\\n}\\n  \\n// Returns true if str is repetition of one of its\\n// substrings else return false.\\nbool isRepeat(char str[])\\n{\\n    // Find length of string and create an array to\\n    // store lps values used in KMP\\n    int n = strlen(str);\\n    int lps[n];\\n  \\n    // Preprocess the pattern (calculate lps[] array)\\n    computeLPSArray(str, n, lps);\\n  \\n    // Find length of longest suffix which is also\\n    // prefix of str.\\n    int len = lps[n - 1];\\n  \\n    // If there exist a suffix which is also prefix AND\\n    // Length of the remaining substring divides total\\n    // length, then str[0..n-len-1] is the substring that\\n    // repeats n/(n-len) times (Readers can print substring\\n    // and value of n/(n-len) for more clarity.\\n    return (len > 0 && n % (n - len) == 0) ? true : false;\\n}\\n// kmp is from gfg\\n```\\nPlease upvote if you found it useful :)",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tbool repeatedSubstringPattern(string s){\\n\\t\\tint n = s.size();\\n\\t\\tfor (int i = 1; i < n; i++){\\n\\t\\t// to check if the string can be repeated to get the required string length\\n\\t\\t\\tif (n % i == 0){\\n\\t\\t\\t// getting the substring from 0 to i;\\n\\t\\t\\t\\tstring curr = s.substr(0, i);\\n\\t\\t\\t\\tbool flag = true;\\n\\t\\t\\t\\tfor (int j = i; j < n; j += curr.size()){\\n\\t\\t\\t\\t\\tif (curr != s.substr(j, i)){\\n\\t\\t\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (flag)           return true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string repeat(string s, int n){\\n        string k = \"\";\\n        for(int i=0; i<n; i++)            k+=s;\\n        return k;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n\\t\\tint n = s.size();\\n        for(int i=n/2; i>=1; i--){\\n            if(n%i==0){\\n                if((repeat(s.substr(0, i), n/i)==s))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nvoid computeLPSArray(char str[], int M, int lps[])\\n{\\n    // length of the previous longest prefix suffix\\n    int len = 0;\\n    int i;  \\n    lps[0] = 0; // lps[0] is always 0\\n    i = 1;\\n  \\n    // the loop calculates lps[i] for i = 1 to M-1\\n    while (i < M) {\\n        if (str[i] == str[len]) {\\n            len++;\\n            lps[i] = len;\\n            i++;\\n        }\\n        else // (pat[i] != pat[len])\\n        {\\n            if (len != 0) {\\n                // This is tricky. Consider the example\\n                // AAACAAAA and i = 7.\\n                len = lps[len - 1];\\n  \\n                // Also, note that we do not increment i\\n                // here\\n            }\\n            else // if (len == 0)\\n            {\\n                lps[i] = 0;\\n                i++;\\n            }\\n        }\\n    }\\n}\\n  \\n// Returns true if str is repetition of one of its\\n// substrings else return false.\\nbool isRepeat(char str[])\\n{\\n    // Find length of string and create an array to\\n    // store lps values used in KMP\\n    int n = strlen(str);\\n    int lps[n];\\n  \\n    // Preprocess the pattern (calculate lps[] array)\\n    computeLPSArray(str, n, lps);\\n  \\n    // Find length of longest suffix which is also\\n    // prefix of str.\\n    int len = lps[n - 1];\\n  \\n    // If there exist a suffix which is also prefix AND\\n    // Length of the remaining substring divides total\\n    // length, then str[0..n-len-1] is the substring that\\n    // repeats n/(n-len) times (Readers can print substring\\n    // and value of n/(n-len) for more clarity.\\n    return (len > 0 && n % (n - len) == 0) ? true : false;\\n}\\n// kmp is from gfg\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2353429,
                "title": "one-liner-c-solution-beats-97-percent-c-solutions-clear-and-crisp-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/73a3e741-ee3f-4145-9007-cd17b659a232_1659157603.8087559.png)\\n\\n\\n```\\nbool repeatedSubstringPattern(string s){\\n        return (s + s).substr(1, 2*s.length() - 2).find(s) != string :: npos;\\n    }\\n```\\n\\n**Explanation**\\n\\n![image](https://assets.leetcode.com/users/images/dd75d6e2-9828-4331-8b72-225485ad2687_1659158060.4675162.png)\\n\\n**We exclude first character and last character while searching of s in s+ s, because as we added the given string twice, then if there is a possibility of a pattern, then we can find the same s in s + s after excluding first and last characters of s + s**.\\n\\nPlease do upvote if you understood the solution!!",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nbool repeatedSubstringPattern(string s){\\n        return (s + s).substr(1, 2*s.length() - 2).find(s) != string :: npos;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2350001,
                "title": "python-one-liner-solution-96-tc-o-n",
                "content": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n\\treturn s in s[1:]+s[:-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n\\treturn s in s[1:]+s[:-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250534,
                "title": "python-one-liner-faster-than-97-easy",
                "content": "METHOD USED:-If a string is made of repetitive substring, then you\\'ll find the string in a concatenated string with itself where first and last char is deleted.\\n\\nIF THIS HELP U KINDLY UPVOTE THIS TO HELP OTHERS TO GET THIS SOLUTION\\nIF U DONT GET IT KINDLY COMMENT AND FEEL FREE TO ASK\\nAND CORRECT MEIF I AM WRONG\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in s[1:]+s[:-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in s[1:]+s[:-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2239737,
                "title": "java-3-lines-with-clear-explanation-and-how-i-figure-it-out",
                "content": "first the solution\\n\\n```\\n     public boolean repeatedSubstringPattern(String s) {\\n            String ss = s + s;\\n            ss = ss.substring(1, ss.length() - 1);\\n            return ss.contains(s);\\n     }\\n```\\n\\n### how I figure it out?\\n\\nthis question is a proof question, you have to proof **P** (here is s contains multi substring) is true.\\n\\nbut maybe it\\'s hard to proof **P is true** directly.\\n\\nso we can use this logic below.\\n\\n>\\n> if P is true , then Q is true.\\n> if Q is false, then P must be false\\n\\nnow if **Q** is easy to proof, we will proof **P**.\\n\\nso for this question, what about the **Q**?\\n\\n\\n> suppose s contains multi substring.\\n> so s == xx\\n> then ss == xxxx\\n> then ss must conatins s, and s must exist in the middle of ss (except the first X and last X)\\n> in order to exclude the first and last X\\n> we use ss.substring(1, ss.length() -1);\\n\\n\\nnow we figure out the **Q**\\n\\n> ss must conatins s, and s must exist in the middle of ss (except the first X and last X)\\n\\nand **Q** is easy to proof. \\n\\nand we can proof **P**\\n\\nthat\\'s all",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n     public boolean repeatedSubstringPattern(String s) {\\n            String ss = s + s;\\n            ss = ss.substring(1, ss.length() - 1);\\n            return ss.contains(s);\\n     }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1904957,
                "title": "beginner-friendly-javascript-solution",
                "content": "We have removed 1st land lst character form str, now we are checking if s present in it ;\\nif pattern is there s+s can form new string str that includes s\\n\\n```\\nvar repeatedSubstringPattern = function(s) {\\n    let str = s+s\\n    return str.substring(1, str.length-1).includes(s)\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar repeatedSubstringPattern = function(s) {\\n    let str = s+s\\n    return str.substring(1, str.length-1).includes(s)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1774418,
                "title": "python-3-easy-solution",
                "content": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n = len(s)\\n        sub = \\'\\'\\n        for i in range(n // 2):\\n            sub += s[i]\\n            k, r = divmod(n, i + 1)\\n            if r == 0 and sub * k == s:\\n                return True\\n        \\n        return False",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n = len(s)\\n        sub = \\'\\'\\n        for i in range(n // 2):\\n            sub += s[i]\\n            k, r = divmod(n, i + 1)\\n            if r == 0 and sub * k == s:\\n                return True\\n        \\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 1751481,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string a=\"\",c;\\n        for(int i=0;i<s.length()/2;i++) //till half of the string since thats the max substring\\n        {\\n            a+=s[i]; //substring\\n            c=a;\\n            if(s.length()%c.length()==0) //checking if length of s is a multiple of length of subsrting\\n            {\\n                int n=s.length()/c.length(); //number of time suubstring need to be repeated\\n                while(n>1)\\n                {c+=a;n--;} //making the repeated substring\\n                if(c==s)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string a=\"\",c;\\n        for(int i=0;i<s.length()/2;i++) //till half of the string since thats the max substring\\n        {\\n            a+=s[i]; //substring\\n            c=a;\\n            if(s.length()%c.length()==0) //checking if length of s is a multiple of length of subsrting\\n            {\\n                int n=s.length()/c.length(); //number of time suubstring need to be repeated\\n                while(n>1)\\n                {c+=a;n--;} //making the repeated substring\\n                if(c==s)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630190,
                "title": "java-solution-with-comments",
                "content": "Logic of code:\\ns=abc\\nss= abcabc\\nbcab does not contain abc\\n\\ns=abab\\nss=abababab\\nb**abab**a contains abab\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) \\n    {\\n        boolean ans;\\n        String ss =s+s;\\n        \\n        ans=(ss.substring(1,ss.length()-1).contains(s));\\n        return ans;\\n    }\\n}\\n```\\n\\nHere `(ss.substring(1,ss.length()-1)` means removing 1st and last character of concatenated string",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) \\n    {\\n        boolean ans;\\n        String ss =s+s;\\n        \\n        ans=(ss.substring(1,ss.length()-1).contains(s));\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594547,
                "title": "short-and-simple-c-solution",
                "content": "```\\n bool repeatedSubstringPattern(string s) {\\n        string str=s+s;\\n        string str2=str.substr(1,2*s.size()-2);\\n        if(str2.find(s)!=-1){\\n            return true;\\n        }\\n        return false;\\n    }\\n```\\nFor More LeetCode Problem\\'s Solution(Topic-Wise)Please Check Out;\\nhttps://github.com/Ariyanlaskar/DSA/tree/master/LeetCode",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n bool repeatedSubstringPattern(string s) {\\n        string str=s+s;\\n        string str2=str.substr(1,2*s.size()-2);\\n        if(str2.find(s)!=-1){\\n            return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1554697,
                "title": "python-easy-solution-to-understand",
                "content": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        i=1\\n        while(i!=(len(s)//2)+1):\\n            x=s[:i]\\n            i=i+1\\n            y=s.count(x)\\n            #print(x,y)\\n            if(y*len(x)==len(s)):\\n                return(True)\\n            \\n        return(False)\\n```\\nIf u understood the code plz..UPVOTE",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        i=1\\n        while(i!=(len(s)//2)+1):\\n            x=s[:i]\\n            i=i+1\\n            y=s.count(x)\\n            #print(x,y)\\n            if(y*len(x)==len(s)):\\n                return(True)\\n            \\n        return(False)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357812,
                "title": "brute-force-20ms-cpp-solution",
                "content": "//All test cases will pass\\n\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        for(int len = 1; len<s.length(); len++){\\n            if(len>(s.length()/2)) break;\\n            if(s.length()%len) continue;\\n            int i;\\n            string str = s.substr(0,len);\\n            for(i=len; i<s.length(); i+=len){\\n                string temp = s.substr(i,len);\\n                if(temp!=str) break;\\n            }\\n            if(i==s.length()) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        for(int len = 1; len<s.length(); len++){\\n            if(len>(s.length()/2)) break;\\n            if(s.length()%len) continue;\\n            int i;\\n            string str = s.substr(0,len);\\n            for(i=len; i<s.length(); i+=len){\\n                string temp = s.substr(i,len);\\n                if(temp!=str) break;\\n            }\\n            if(i==s.length()) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285707,
                "title": "python-1-line-code-faster-than-95-33",
                "content": "Runtime: 28 ms, faster than 95.33% of Python3 online submissions for Repeated Substring Pattern.\\nMemory Usage: 14.3 MB, less than 80.00% of Python3 online submissions for Repeated Substring Pattern.\\n\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in s[1:]+s[:-1]",
                "solutionTags": [],
                "code": "Runtime: 28 ms, faster than 95.33% of Python3 online submissions for Repeated Substring Pattern.\\nMemory Usage: 14.3 MB, less than 80.00% of Python3 online submissions for Repeated Substring Pattern.\\n\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in s[1:]+s[:-1]",
                "codeTag": "Python3"
            },
            {
                "id": 1186619,
                "title": "python-3-simple-one-line-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        ## if s is composed of n copies of substring m where n >=2\\n        ## In the case where n = 2, \\n        ## s = m+m\\n        ## s+s = m+m+m+m\\n        ## In addition,\\n        ## make sure s cannot be matched in the head.\\n        ## make sure s cannot be matched at the tail.\\n        ## Chop off the first charcter of s. Call it s\\'\\n        ## Chop off the last character of s. Call it s\\'\\'\\n        ## s\\' = m\\' + m where m\\' is m minus first character\\n        ## s\\'\\' = m + m\\'\\' where m\\'\\' is m minus last character\\n        ## s\\' + s\\'\\' = m\\' + m + m + m\\'\\' = m\\' + s + m\\'\\'\\n        ## Note: if we just use s + s instead of s\\' + s\\'\\', it won\\'t work because s is always in s + s\\n        return s in s[1:]+s[:-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        ## if s is composed of n copies of substring m where n >=2\\n        ## In the case where n = 2, \\n        ## s = m+m\\n        ## s+s = m+m+m+m\\n        ## In addition,\\n        ## make sure s cannot be matched in the head.\\n        ## make sure s cannot be matched at the tail.\\n        ## Chop off the first charcter of s. Call it s\\'\\n        ## Chop off the last character of s. Call it s\\'\\'\\n        ## s\\' = m\\' + m where m\\' is m minus first character\\n        ## s\\'\\' = m + m\\'\\' where m\\'\\' is m minus last character\\n        ## s\\' + s\\'\\' = m\\' + m + m + m\\'\\' = m\\' + s + m\\'\\'\\n        ## Note: if we just use s + s instead of s\\' + s\\'\\', it won\\'t work because s is always in s + s\\n        return s in s[1:]+s[:-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127925,
                "title": "my-python-solution",
                "content": "Hi guys here\\'s what I came up with. Cheers!\\n\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        \\n        for i in range(len(s)//2):\\n            floor, remainder = divmod(len(s), i + 1)\\n            if remainder == 0:\\n                if s[:i+1] * floor == s:\\n                    return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        \\n        for i in range(len(s)//2):\\n            floor, remainder = divmod(len(s), i + 1)\\n            if remainder == 0:\\n                if s[:i+1] * floor == s:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113021,
                "title": "python-easy-solution",
                "content": "Runtime: 16 ms, faster than 100.00% of Python3.\\nMemory Usage: 14.3 MB, less than 65.04% of Python3.\\n\\nThis is based on the observation that a string is periodic if and only if it is equal to a nontrivial rotation of itself.\\n\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        i = (s+s).find(s,1,-1)\\n        \\n        if i>0:\\n            return True\\n        else:\\n            return False\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        i = (s+s).find(s,1,-1)\\n        \\n        if i>0:\\n            return True\\n        else:\\n            return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826771,
                "title": "java-simple-solution-with-substring",
                "content": "This solution is intended to verify if a substring of `s + s` contains `s`. The new substring will be created from index `1` to `length() - 1`.\\n\\n`aba` + `aba` becomes `abaaba` and the substring will be `baab`,  then we can check if this new substring contains `aba`, if not then return false.\\n\\n`abab` + `abab` becomes `abababab` and the substring will be `bababa` wich contains `s`, then return true.\\n\\n```java\\n    public boolean repeatedSubstringPattern(String s) {\\n        String str = s + s;\\n        return str.substring(1, str.length() - 1).contains(s);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```java\\n    public boolean repeatedSubstringPattern(String s) {\\n        String str = s + s;\\n        return str.substring(1, str.length() - 1).contains(s);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 452275,
                "title": "java-9ms-non-bruteforce-solution-using-gcd-100-less-memory-81-faster-runtime",
                "content": "\\nTo find repeating substring, information about the frequency of each character helps a lot.\\n\\nLet\\'s take `babbaaabbbbabbaaabbbbabbaaabbb` as an example, \\nthe frequencies of each character are\\n\\n```txt\\na : 12\\nb : 18\\n```\\n\\nOf those frequences, `min = 12`, `max = 18`.\\n\\nThere are few obvious cases that can be eliminated\\n1. if `max` equals the string length, we can infer that there is only one unique character in the string, so if the length is greater than 1, the string repeats n times. Example: `aaaaa`.\\n2.  If `min` is equal to 1, there is a character that occurs only once, which is not possible if a repetition exists. Example: `abcabcd`.\\n\\nIf we calculate the GCD of `min`, `max` we can know the upper bound on the number of possible repetitions. If GCD equals 1, it means that no common divisor is found and hence no repetitions are possible.\\n\\n`GCD(min, max) = GCD(12, 18) = 6`\\n\\nIf there are 6 possible repetitions, then the pattern size should be equal to `string.length / 6 => 30 / 6 = 5` \\nPattern size 5, `babba` is not the pattern that\\'s repeating, so we move on to the multiples of 6 `[3, 2]`\\n\\nIf there are 3 repetitions, then the pattern size will be equal to `string.length / 3 => 30 / 3 = 10`\\nPattern size 10 `babbaaabbb` is the repeating pattern.\\n\\n\\n```java\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        int[] c = new int[26];\\n        \\n        // count frequency of each character\\n        for (int i=0; i<s.length(); i++) {\\n            c[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        // calculate max, min frequency\\n        for (int i=0; i<c.length; i++) {\\n            if (c[i] > 0) {\\n                if (c[i] < min) {\\n                    min = c[i];\\n                }\\n                if (c[i] > max) {\\n                    max = c[i];\\n                }\\n            }\\n        }\\n        \\n        // if a character frequency == string length,\\n        // there is only one unique character in the entire string\\n        if (max == s.length()) {\\n            return max > 1;\\n        }\\n        \\n        // min must be >= 2 for repetition to occur\\n        if (min <= 1) {\\n            return false;\\n        }\\n        \\n        // GCD gives an upper bound on the possible number of repetitions\\n        int repeatCount = GCD(min, max);\\n        \\n        // If no common divisor > 1, repetition not possible\\n        if (repeatCount == 1) {\\n            return false;\\n        }\\n        \\n        List<Integer> multiples = new ArrayList<Integer>();\\n        multiples.add(repeatCount);\\n        multiples.addAll(getMultiples(repeatCount));\\n        \\n        // for each multiple of GCD, check if pattern repeats\\n        for (int i : multiples) {\\n            if (isRepeating(s, i)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int GCD(int a, int b) {\\n        return a == 0 ? b : GCD(b%a, a);\\n    }\\n    \\n    List<Integer> getMultiples(int n) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        for (int i=n/2; i>=2; i--) {\\n            if (n % i == 0) {\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n    \\n    boolean isRepeating(String s, int repeatCount) {\\n        int patternLength = s.length()/repeatCount;\\n        String pattern = s.substring(0, patternLength);\\n        for (int i=1;i<repeatCount; i++) {\\n            int begin = patternLength * i;\\n            int end = begin + patternLength;\\n            if (!s.substring(begin, end).equals(pattern)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```txt\\na : 12\\nb : 18\\n```\n```java\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        int[] c = new int[26];\\n        \\n        // count frequency of each character\\n        for (int i=0; i<s.length(); i++) {\\n            c[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        // calculate max, min frequency\\n        for (int i=0; i<c.length; i++) {\\n            if (c[i] > 0) {\\n                if (c[i] < min) {\\n                    min = c[i];\\n                }\\n                if (c[i] > max) {\\n                    max = c[i];\\n                }\\n            }\\n        }\\n        \\n        // if a character frequency == string length,\\n        // there is only one unique character in the entire string\\n        if (max == s.length()) {\\n            return max > 1;\\n        }\\n        \\n        // min must be >= 2 for repetition to occur\\n        if (min <= 1) {\\n            return false;\\n        }\\n        \\n        // GCD gives an upper bound on the possible number of repetitions\\n        int repeatCount = GCD(min, max);\\n        \\n        // If no common divisor > 1, repetition not possible\\n        if (repeatCount == 1) {\\n            return false;\\n        }\\n        \\n        List<Integer> multiples = new ArrayList<Integer>();\\n        multiples.add(repeatCount);\\n        multiples.addAll(getMultiples(repeatCount));\\n        \\n        // for each multiple of GCD, check if pattern repeats\\n        for (int i : multiples) {\\n            if (isRepeating(s, i)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int GCD(int a, int b) {\\n        return a == 0 ? b : GCD(b%a, a);\\n    }\\n    \\n    List<Integer> getMultiples(int n) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        for (int i=n/2; i>=2; i--) {\\n            if (n % i == 0) {\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n    \\n    boolean isRepeating(String s, int repeatCount) {\\n        int patternLength = s.length()/repeatCount;\\n        String pattern = s.substring(0, patternLength);\\n        for (int i=1;i<repeatCount; i++) {\\n            int begin = patternLength * i;\\n            int end = begin + patternLength;\\n            if (!s.substring(begin, end).equals(pattern)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372713,
                "title": "o-n-with-z-function",
                "content": "z[i] represent the length of common prefix between s and s[i:]. The Z array could be calculated in O(N) time.\\n\\nSee https://cp-algorithms.com/string/z-function.html for more information\\n\\n```cpp\\n    bool repeatedSubstringPattern(string s) {\\n        vector<int> z(s.size());\\n        int l = 0, r = 0;\\n        for (int i=1; i<s.size(); ++i) {\\n            if (i <= r) {\\n                z[i] = min(r - i + 1, z[i - l]);\\n                if (i + z[i] - 1 < r) continue;\\n            }\\n            while (i + z[i] < s.size() && s[i + z[i]] == s[z[i]]) ++z[i];\\n            if (i + z[i] - 1 > r) {\\n                r = i + z[i] - 1;\\n                l = i;\\n            }\\n        }\\n        for (int i = 1; i < s.size(); ++i)\\n            if (s.size() % i == 0 && z[i] + i == s.size()) return true;\\n        return false;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```cpp\\n    bool repeatedSubstringPattern(string s) {\\n        vector<int> z(s.size());\\n        int l = 0, r = 0;\\n        for (int i=1; i<s.size(); ++i) {\\n            if (i <= r) {\\n                z[i] = min(r - i + 1, z[i - l]);\\n                if (i + z[i] - 1 < r) continue;\\n            }\\n            while (i + z[i] < s.size() && s[i + z[i]] == s[z[i]]) ++z[i];\\n            if (i + z[i] - 1 > r) {\\n                r = i + z[i] - 1;\\n                l = i;\\n            }\\n        }\\n        for (int i = 1; i < s.size(); ++i)\\n            if (s.size() % i == 0 && z[i] + i == s.size()) return true;\\n        return false;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 298224,
                "title": "java-intuitive-proof",
                "content": "```java\\nclass Solution {\\n    \\n\\n    // [a b] [a b] : given a string with repeated pattern\\n    // [a b] [a b] [a b] [a b] : double it\\n    // b [a b] [a b] a : break first and last chunk\\n    // The final string should contain original string\\n    \\n    // [a b c] : given a string without repeated pattern\\n    // [a b c] [a b c] : double it\\n    // b c a b : break first and last chunk\\n    // The final string does not contain original string\\n\\n    public boolean repeatedSubstringPattern(String s) {\\n        String s2 = s + s;\\n        return s2.substring(1, s2.length() - 1).contains(s);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n\\n    // [a b] [a b] : given a string with repeated pattern\\n    // [a b] [a b] [a b] [a b] : double it\\n    // b [a b] [a b] a : break first and last chunk\\n    // The final string should contain original string\\n    \\n    // [a b c] : given a string without repeated pattern\\n    // [a b c] [a b c] : double it\\n    // b c a b : break first and last chunk\\n    // The final string does not contain original string\\n\\n    public boolean repeatedSubstringPattern(String s) {\\n        String s2 = s + s;\\n        return s2.substring(1, s2.length() - 1).contains(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184558,
                "title": "concise-javascript-solution",
                "content": "```\\nvar repeatedSubstringPattern = function(s) {\\n    if (s.length === 0 || s.length === 1) return false;\\n    for (let i = 1; i <= s.length / 2; i++) {\\n        if (s.length % i === 0 && s.slice(0, i).repeat(s.length / i) === s) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar repeatedSubstringPattern = function(s) {\\n    if (s.length === 0 || s.length === 1) return false;\\n    for (let i = 1; i <= s.length / 2; i++) {\\n        if (s.length % i === 0 && s.slice(0, i).repeat(s.length / i) === s) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94428,
                "title": "java-one-liner-no-regexp",
                "content": "```\\npublic boolean repeatedSubstringPattern(String str) {\\n    return (str + str).indexOf(str, 1) < str.length();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean repeatedSubstringPattern(String str) {\\n    return (str + str).indexOf(str, 1) < str.length();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94380,
                "title": "1-line-c-solution-return-s-s-find-s-1-s-size-with-proof",
                "content": "```\\n    bool repeatedSubstringPattern(string& s) { return (s+s).find(s,1) < s.size(); }\\n```\\nSince neither `string::find` nor `std::strstr` specify complexity, the algorithm is up to whatever their implementation is. (e.g., `O(N)` time and space if using KMP, where `N = s.size()`)\\n\\nWhy condition `return (s+s).find(s,1) < s.size()` is equivalent to substring repetition?\\n**Proof:** Let `N = s.size()` and `L := (s+s).find(s,1)`, actually we can prove that **the following 2 statements are equivalent:**\\n1. `0 < L < N`;\\n2. `N%L == 0` and `s[i] == s[i%L]` is true for any `i` in `[0, N)`. (which means `s.substr(0,L)` is the repetitive substring)\\n\\nConsider function `char f(int i) { return s[i%N]; }`, obviously it has a period `N`.\\n\\n**\"1 => 2\"**: From condition 1, we have for any `i` in `[0,N)`\\n* `s[i] == (s+s)[i+L] == s[(i+L)%N]`, \\nwhich means `L` is also a positive period of function `f`. Note that `N == L*(N/L)+N%L`, so we have\\n* `f(i) == f(i+N) == f(i+L*(N/L)+N%L) == f(i+N%L)`,\\nwhich means `N%L` is also a period of `f`. Note that `N%L < L` but `L := (s+s).find(s,1)` is the minimum positive period of function `f`, so we must have `N%L == 0`. Note that `i == L*(i/L)+i%L`, so we have\\n* `s[i] == f(i) == f(L*(i/L)+i%L) == f(i%L) == s[i%L]`,\\nso condition 2 is obtained.\\n\\n**\"2=>1\"**: If condition 2 holds, for any `i` in `[0,N)`, note that `N%L == 0`, we have\\n* `(s+s)[i+L] == s[(i+L)%N] == s[((i+L)%N)%L] == s[(i+L)%L] == s[i]`,\\nwhich means `(s+s).substr(L,N) == s`, so condition 1 is obtained.",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n    bool repeatedSubstringPattern(string& s) { return (s+s).find(s,1) < s.size(); }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94502,
                "title": "easy-and-fast-python",
                "content": "    def repeatedSubstringPattern(self, s):\\n        n = len(s)\\n        return any(n / d * s[:d] == s\\n                   for d in range(1, n)\\n                   if n % d == 0)\\n\\nI just try all possible divisors. Submitted three times, accepted in 78, 68 and 89 ms, average 78.3 ms.\\n\\nHere's an optimized version, accepted in 39, 62 and 45 ms, average 48.7 ms.\\n\\n    def repeatedSubstringPattern(self, s):\\n        n = len(s)\\n        d = 1\\n        while d * d <= n:\\n            if n % d == 0:\\n                for m in {d, n/d}:\\n                    if m > 1 and m * s[:n/m] == s:\\n                        return True\\n            d += 1\\n        return False\\n\\nFor comparison, I also tested @protein-graph's [KMP O(n) solution](https://discuss.leetcode.com/topic/67640/python-kmp-o-n) (the only Python solution posted so far) which got accepted in 185, 235 and 185 ms, average 201.7 ms.\\n\\nThe baseline (the time not caused by our solution but by the judge) is about 38 ms, as determined by the below cheat which got accepted in 42, 33 and 39 ms. Subtracting that, my solutions averaged 40.3 ms and 10.7 ms, and @protein-graph's averaged 163.7 ms.\\n```\\nclass Solution(object):\\n    answers = [False, False, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, False, False, False, False, False, False, False, False, False, False, True, True, True, False, False, False, False, False, False, False, False, False, False, False, False, False, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, False, True, False, False, False, False, False, False, True, False, False, True, True, True, True, True, False, True, False, True, False, True]\\n    def repeatedSubstringPattern(self, s):\\n        return self.answers.pop()\\n```\\n<br>\\nJust another way to write my optimized solution:\\n\\n    def repeatedSubstringPattern(self, s):\\n        n = len(s)\\n        return any(m > 1 and m * s[:n/m] == s\\n                   for d in range(1, int(n**0.5+2))\\n                   if n % d == 0\\n                   for m in {d, n/d})\\n\\nGot accepted in 45, 38 and 72 ms.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    answers = [False, False, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, False, False, False, False, False, False, False, False, False, False, True, True, True, False, False, False, False, False, False, False, False, False, False, False, False, False, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, False, True, False, False, False, False, False, False, True, False, False, True, True, True, True, True, False, True, False, True, False, True]\\n    def repeatedSubstringPattern(self, s):\\n        return self.answers.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939921,
                "title": "easy-explanation-by-creating-repetitions",
                "content": "# Intuition\\nWe can solve this problem by iterating through possible substrings of the input string and checking if they can be repeated to form the original string.\\n\\n# Approach\\nThis function iterates through possible substring lengths from 1 to `n//2` (since a substring\\'s length cannot exceed half of the original string\\'s length). For each length, it checks if the original string can be formed by repeating that substring. If such a substring is found, the function returns `True`, indicating that the string can be constructed as described. If no such substring is found for all possible lengths, the function returns `False`\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n=len(s)\\n        for i in range(1,n//2+1):\\n            if n%i == 0:\\n                substring = s[:i]\\n                repetitions = n // i\\n                constructed_substring= substring * repetitions\\n\\n                if constructed_substring == s:\\n                    return True\\n        return False\\n\\n\\n                    \\n```\\n# **PLEASE DO UPVOTE!!!\\uD83E\\uDD79**",
                "solutionTags": [
                    "Python3",
                    "String Matching"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n=len(s)\\n        for i in range(1,n//2+1):\\n            if n%i == 0:\\n                substring = s[:i]\\n                repetitions = n // i\\n                constructed_substring= substring * repetitions\\n\\n                if constructed_substring == s:\\n                    return True\\n        return False\\n\\n\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771595,
                "title": "easy-c-solution-handwritten-image-explanation-simple-brute-force-approach",
                "content": "# Explanation \\n![sol.jpg](https://assets.leetcode.com/users/images/b180d6a3-ee1d-43f8-99db-fe593a619c82_1689481783.411159.jpeg) \\n**Correction :** We do not need to maintain int end as we can just increment start = start + len.\\n**Note :** substr(start, length) has first argument as starting position of susbstring and second argument as length of the substring.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length(), i = n%2!=0 ? (n+1)/2 : n/2;\\n        if(n==1)    return false;\\n        bool flag = true;\\n        while(i<n){\\n            int start = 0, len = n-i;\\n            string temp = s.substr(i, len);\\n            flag = true;\\n            while(start+len < n){\\n                string val = s.substr(start, len);\\n                if(val != temp){\\n                    flag = false;\\n                    break;\\n                }\\n                start += len;\\n            }\\n            if(flag == true)    break;\\n            i++;\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length(), i = n%2!=0 ? (n+1)/2 : n/2;\\n        if(n==1)    return false;\\n        bool flag = true;\\n        while(i<n){\\n            int start = 0, len = n-i;\\n            string temp = s.substr(i, len);\\n            flag = true;\\n            while(start+len < n){\\n                string val = s.substr(start, len);\\n                if(val != temp){\\n                    flag = false;\\n                    break;\\n                }\\n                start += len;\\n            }\\n            if(flag == true)    break;\\n            i++;\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363969,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        return (s+s).find(s,1)<s.size();\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        if not s:\\n            return False   \\n        ss = (s + s)[1:-1]\\n        return ss.find(s) != -1\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int len = s.length();\\n\\n        for (int i = len / 2; i > 0; i--) {\\n            if (len % i == 0 && s.charAt(i - 1) == s.charAt(len - 1)) {\\n                String ss = s.substring(0, i);\\n                int repeat = len / i;\\n\\n                if (ss.repeat(repeat).equals(s)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        return (s+s).find(s,1)<s.size();\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        if not s:\\n            return False   \\n        ss = (s + s)[1:-1]\\n        return ss.find(s) != -1\\n```\n```Java []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int len = s.length();\\n\\n        for (int i = len / 2; i > 0; i--) {\\n            if (len % i == 0 && s.charAt(i - 1) == s.charAt(len - 1)) {\\n                String ss = s.substring(0, i);\\n                int repeat = len / i;\\n\\n                if (ss.repeat(repeat).equals(s)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278680,
                "title": "459-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define a function repeatedSubstringPattern that takes a string s as input and returns a boolean value.\\n2. Calculate the length of the string s and store it in variable n.\\n3. Iterate over all possible substring lengths, i, such that i is a factor of n.\\n4. Check if i evenly divides n. If not, skip to the next iteration.\\n5. Check if the substring of length i repeated n // i times equals the original string s.\\n6. If it does, return True.\\n7. If no repeated substring is found, return False.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def repeatedSubstringPattern(self, s: str) -> bool:\\n    # calculate the length of the string\\n    n = len(s)\\n    # try only those substring lengths that are factors of the length of the string\\n    for i in range(1, n // 2 + 1):\\n        if n % i == 0:\\n            # check only those substrings that start at the beginning of the string\\n            if s[:i] * (n // i) == s:\\n                return True\\n    \\n    return False\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution:\\n  def repeatedSubstringPattern(self, s: str) -> bool:\\n    # calculate the length of the string\\n    n = len(s)\\n    # try only those substring lengths that are factors of the length of the string\\n    for i in range(1, n // 2 + 1):\\n        if n % i == 0:\\n            # check only those substrings that start at the beginning of the string\\n            if s[:i] * (n // i) == s:\\n                return True\\n    \\n    return False\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276697,
                "title": "typescript-doubled-string-solution",
                "content": "# Code\\n```\\nfunction repeatedSubstringPattern(s: string): boolean {\\n    return s.repeat(2).slice(1, -1).includes(s);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction repeatedSubstringPattern(s: string): boolean {\\n    return s.repeat(2).slice(1, -1).includes(s);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3250630,
                "title": "easy-single-loop-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n  let sub = \"\";\\n  for (let i = 0; i < Math.floor(s.length / 2); i++) {\\n    sub += s[i];\\n    if (sub.repeat(s.length / sub.length) === s) return true;\\n  }\\n  return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n  let sub = \"\";\\n  for (let i = 0; i < Math.floor(s.length / 2); i++) {\\n    sub += s[i];\\n    if (sub.repeat(s.length / sub.length) === s) return true;\\n  }\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3149595,
                "title": "repeated-substring-pattern",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs the substring have to be repeated the length of the substring should be less than or equals to half of the length and thus create the possible substring and try to create the copies by extracting the length to the required length..\\n\\ns1=\"abab\"\\n\\nFirst form the substring they are \"a\" and \"ab\"\\nnow repeat  the pattern till it equals the length of the resultant lenght and thus it gives as..\\n \"aaaa\"\\n    and \"abab\"\\n\\n Hence we should return True as it is possible to create the string....\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        stringlen=len(s)\\n        \\n        for i in range(0,len(s)//2):\\n            string=s[0:i+1]\\n            length=len(string)\\n            required=len(s)//length\\n            if(string*required==s):\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        stringlen=len(s)\\n        \\n        for i in range(0,len(s)//2):\\n            string=s[0:i+1]\\n            length=len(string)\\n            required=len(s)//length\\n            if(string*required==s):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094859,
                "title": "clean-work-98-faster-94-in-memory",
                "content": "**Hi Guys! \\nCheck my approach and please upvote, if you found it useful**\\n\\n**Main Hint**\\n  Don\\'t check every piece of the string. Let ```s.length()=28```, we should check only substrings those are length of its are 1,2,4,7,14.\\n\\n**Main piece of my code**\\n```\\nint size = s.length();\\n// i = count of the pieces of the s\\nfor(int i=2;i<=size/2;i++){\\n    //count of the pieces of the s can be only divisor of its size\\n    if(size%i==0){\\n        \\n        int count = 0;\\n        String str = s.substring(0,size/i);\\n        //whenever any piece of s don\\'t equals to str then breaks loop\\n        //if all of pieces of s equals to str then returns true\\n        for(int j=size/i;j<size;j+=size/i){\\n            if(s.substring(j,j+size/i).equals(str)){\\n                count++;\\n            }else{\\n                count=0;\\n                break;\\n            }\\n        }\\n\\n        if(count==i-1) return true;\\n}\\n```\\n\\nif ```s.length()==1``` or ```s.length()==2``` it does match the code, so we check its at the beginning.\\nAnd in this code we didn\\'t check the case ```i=size``` because of decreasing loop steps. So we also check it at the end.\\n   \\n\\n#My Code\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n\\n        if(s.length()==1) return false;\\n        if(s.length()==2) return s.substring(0,1).equals(s.substring(1));\\n\\n        int size = s.length();\\n        for(int i=2;i<=size/2;i++){\\n            if(size%i==0){\\n                String str = s.substring(0,size/i);\\n                int count = 0;\\n\\n                for(int j=size/i;j<size;j+=size/i){\\n                    if(s.substring(j,j+size/i).equals(str)){\\n                        count++;\\n                    }else{\\n                        count=0;\\n                        break;\\n                    }\\n                }\\n\\n                if(count==i-1) return true;\\n            }\\n        }\\n\\n        int a = s.charAt(0);\\n        for(char ch : s.toCharArray()){\\n            if(a!=ch) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n# Result \\n\\n![image.png](https://assets.leetcode.com/users/images/11ad1af6-0a44-43a0-8395-6ca27bf8fcb4_1674581037.8360991.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```s.length()=28```\n```\\nint size = s.length();\\n// i = count of the pieces of the s\\nfor(int i=2;i<=size/2;i++){\\n    //count of the pieces of the s can be only divisor of its size\\n    if(size%i==0){\\n        \\n        int count = 0;\\n        String str = s.substring(0,size/i);\\n        //whenever any piece of s don\\'t equals to str then breaks loop\\n        //if all of pieces of s equals to str then returns true\\n        for(int j=size/i;j<size;j+=size/i){\\n            if(s.substring(j,j+size/i).equals(str)){\\n                count++;\\n            }else{\\n                count=0;\\n                break;\\n            }\\n        }\\n\\n        if(count==i-1) return true;\\n}\\n```\n```s.length()==1```\n```s.length()==2```\n```i=size```\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n\\n        if(s.length()==1) return false;\\n        if(s.length()==2) return s.substring(0,1).equals(s.substring(1));\\n\\n        int size = s.length();\\n        for(int i=2;i<=size/2;i++){\\n            if(size%i==0){\\n                String str = s.substring(0,size/i);\\n                int count = 0;\\n\\n                for(int j=size/i;j<size;j+=size/i){\\n                    if(s.substring(j,j+size/i).equals(str)){\\n                        count++;\\n                    }else{\\n                        count=0;\\n                        break;\\n                    }\\n                }\\n\\n                if(count==i-1) return true;\\n            }\\n        }\\n\\n        int a = s.charAt(0);\\n        for(char ch : s.toCharArray()){\\n            if(a!=ch) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938049,
                "title": "fastest-solution-fully-explained-o-n-2-java",
                "content": "\\n# Approach :\\n```\\n1. The substring that will be repeated should repeat at least 2 times\\n   otherwise every string will be considered as a repeated substring.\\n2. Since the number of repetitions is between n times (size of the \\n   string) to 2 times so the size of a valid repeating substring \\n   would lie between[ 1, n / 2 ].\\n3. A substring of size \\u201D i \\u201D will only be a repeated substring if \\n   size % i == 0.\\n4. Now following which we have two methods whether current substring\\n   of size suppose k is a repeated substring or not\\n\\n\\n```\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity :\\n- Time complexity : O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public boolean repeatedSubstringPattern(String s) \\n    {\\n        //String part=\"\";\\n        for(int i=1;i<=s.length()/2;i++)\\n        {\\n            if(s.length()%i==0)//check if equal parts can be formed\\n            {\\n                String part=s.substring(0,i);\\n                int j=i;\\n                while(j<s.length() && s.substring(j,j+i).equals(part))\\n                  j+=i;\\n                if(j==s.length())\\n                  return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "String Matching"
                ],
                "code": "```\\n1. The substring that will be repeated should repeat at least 2 times\\n   otherwise every string will be considered as a repeated substring.\\n2. Since the number of repetitions is between n times (size of the \\n   string) to 2 times so the size of a valid repeating substring \\n   would lie between[ 1, n / 2 ].\\n3. A substring of size \\u201D i \\u201D will only be a repeated substring if \\n   size % i == 0.\\n4. Now following which we have two methods whether current substring\\n   of size suppose k is a repeated substring or not\\n\\n\\n```\n```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\n```\\nclass Solution \\n{\\n    public boolean repeatedSubstringPattern(String s) \\n    {\\n        //String part=\"\";\\n        for(int i=1;i<=s.length()/2;i++)\\n        {\\n            if(s.length()%i==0)//check if equal parts can be formed\\n            {\\n                String part=s.substring(0,i);\\n                int j=i;\\n                while(j<s.length() && s.substring(j,j+i).equals(part))\\n                  j+=i;\\n                if(j==s.length())\\n                  return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854402,
                "title": "kotlin-smart-solution-one-liner-with-detailed-explanation",
                "content": "# Intuition\\nGiven that the string `S` was formed by a pattern `P`, if we create `S1 = S + S` and we removed the first and the last letter of `S1` (`S2 = S1[1:-1]`), `S` can still be found in `S1`.\\n\\nFor example:\\n\\n```\\n// the pattern\\nP = \"ab\"\\n// the input\\nS = \"ababab\"\\n\"ababab\" + \"ababab\" = \"abababababab\" minus first and last character = \"bababababa\"\\nand \"bababababa\" still contains \"ababab\".\\n```\\n\\n![a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg](https://assets.leetcode.com/users/images/88128a41-c894-49cb-9bf3-c816e5ad7606_1669571545.9509563.jpeg)\\n\\n# Approach\\n\\nGiven the String `S` is formed by the pattern `P` repeated`n` times (`S=P*n`), then `S1=P*n+P*n -> S1 = P*2n`, then by removing the first and the last letter, we remove the first and th last `P` (`S2=P*2n - 2P`). If `P` exist, then `S` must have been created when adding `S.substring(1,S.size-1)` to `S.substring(0,S.size-2)`.\\n\\n```\\nP = \"cd\"\\nS=\"cdcd\"\\nS1 = \"cdcd\" + \"cdcd\" (S+S) . S1 contains twice S and four times P.\\nS2 = \"dcdcdc\" (S2 removed the first and the last pattern P)\\nif P exist, S was formed again by combining S.substring(1,S.size-1)+S.substring(0,S.size-2)\\n```\\n\\nThe following example showcase if there is no `P` in `S`, then `S2` does not contain `S`.\\n\\n```\\nS=\"abc\"\\nS1 = \"abcabc\"\\nS2= \"bcab\" \\n```\\n\\n\\n# Complexity\\n- Time complexity: `O(N)`\\n\\n- Space complexity: `O(N)`\\n\\n# Code\\n```\\nclass Solution {\\n    fun repeatedSubstringPattern(s: String): Boolean = when (s.length){\\n        0,1 -> false\\n        2 -> s.get(0) == s.get(1)\\n        else ->  \"${s.substring(1)}${s.substring(0,s.length-2)}\".contains(s)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n// the pattern\\nP = \"ab\"\\n// the input\\nS = \"ababab\"\\n\"ababab\" + \"ababab\" = \"abababababab\" minus first and last character = \"bababababa\"\\nand \"bababababa\" still contains \"ababab\".\\n```\n```\\nP = \"cd\"\\nS=\"cdcd\"\\nS1 = \"cdcd\" + \"cdcd\" (S+S) . S1 contains twice S and four times P.\\nS2 = \"dcdcdc\" (S2 removed the first and the last pattern P)\\nif P exist, S was formed again by combining S.substring(1,S.size-1)+S.substring(0,S.size-2)\\n```\n```\\nS=\"abc\"\\nS1 = \"abcabc\"\\nS2= \"bcab\" \\n```\n```\\nclass Solution {\\n    fun repeatedSubstringPattern(s: String): Boolean = when (s.length){\\n        0,1 -> false\\n        2 -> s.get(0) == s.get(1)\\n        else ->  \"${s.substring(1)}${s.substring(0,s.length-2)}\".contains(s)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684930,
                "title": "python-easy-explained-two-lines",
                "content": "1. Create a string by use of substring starting from 1 to last index and 0th to last but 1 index.\\n2. Check if the given string s is present in the above created new string and return True if present.\\n\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        combined = \"\".join( (s[1:], s[:-1]) )\\n        return s in combined\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        combined = \"\".join( (s[1:], s[:-1]) )\\n        return s in combined\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431263,
                "title": "yet-another-linear-o-n-python-solution-with-kmp",
                "content": "In the previous [post](https://leetcode.com/problems/repeated-substring-pattern/discuss/2425393/Yet-another-Python-solutions-O(n-*-sqrt(n))) I found a solution with complexity O(N * sqrt(N)) which is not in comparison with many other offered solutions with complexity O(N^2). Here I show a difficult but elegant solution by the use of [KMP algorithm](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm). And to be precise, I use only one part of the algorithm ```prefix function()```\\n\\nShort theory: KMP algorithm finds a pattern in the text in linear time O(N). I encourage everyone to analyze it and remember it by heart because it is used in many applications with strings. The algorithm is so powerful and it takes into account, that while we compare each character of the pattern with the characters in the text, we can reuse partially that information. \\nLater I will create a post with details, about how the algorithm works, and post it here.\\n\\nExamples: \\n1) for a string of lenght 9  ```\\'abcabcabc\\'```    the prefix function is: [0, 0, 0, 1, 2, 3, 4, 5, 6]\\n2) for a string of lenght 10 ```\\'abcabrcabc\\'``` the prefix function is:  [0, 0, 0, 1, 2, 0, 0, 1, 2, 3]\\n3) for a string of lenght 10 ```\\'abcabcabcd\\'``` the prefix function is: [0, 0, 0, 1, 2, 3, 4, 5, 6, 0]\\n\\nIn example 1) the pattern ```\\'abc\\'``` is repeated 3 time, in 2) and 3) no patterns\\nAs soon as there are repeated patterns, the prefix functions would increase. And its minimum values is if half of the length of the string because the minimum number of pattern repetitions is 2. The next property: the last element of the ```array s``` is the length of the longest border (when the prefix and the suffix of the string are the same). If we find the difference between the length of the string and the last value of the ```array s``` we find the length of the repeated pattern. And to check if it is a true repeated pattern, the last value of the ```array s``` should be a multiple of the pattern. \\nI would recommend to watch lectures [prefix function](https://www.coursera.org/learn/algorithms-on-strings/lecture/exytr/prefix-function) and [compute prefix](https://www.coursera.org/learn/algorithms-on-strings/lecture/5lDsK/computing-prefix-function).\\n\\n*Please upvote if you like for motivation and karma :)*\\n\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, p: str) -> bool:\\n    \\n        s = [0] * len(p)\\n        border = 0\\n\\n        for i in range(1, len(p)):\\n\\n            while border > 0 and p[i] != p[border]:\\n                border = s[border - 1]\\n\\n            if p[border] == p[i]:\\n                border += 1\\n            else:\\n                border = 0\\n\\n            s[i] = border\\n\\n        return s[-1] and s[-1] % (len(s) - s[-1]) == 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```prefix function()```\n```\\'abcabcabc\\'```\n```\\'abcabrcabc\\'```\n```\\'abcabcabcd\\'```\n```\\'abc\\'```\n```array s```\n```array s```\n```array s```\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, p: str) -> bool:\\n    \\n        s = [0] * len(p)\\n        border = 0\\n\\n        for i in range(1, len(p)):\\n\\n            while border > 0 and p[i] != p[border]:\\n                border = s[border - 1]\\n\\n            if p[border] == p[i]:\\n                border += 1\\n            else:\\n                border = 0\\n\\n            s[i] = border\\n\\n        return s[-1] and s[-1] % (len(s) - s[-1]) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152794,
                "title": "c-3-easier-solutions-without-kmp",
                "content": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n        \\n        for(int l = n/2;l>0;l--){\\n            int i = 0;\\n            while(i+l<n && s[i]==s[i+l]) i++;\\n            \\n            if(i+l==n) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n        for(int l = n/2;l>0;l--){\\n            if(n%l==0)\\n                if(s.substr(0,n-l)==s.substr(l)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        return (s+s).substr(1,2*s.size()-2).find(s)!=-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n        \\n        for(int l = n/2;l>0;l--){\\n            int i = 0;\\n            while(i+l<n && s[i]==s[i+l]) i++;\\n            \\n            if(i+l==n) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n        for(int l = n/2;l>0;l--){\\n            if(n%l==0)\\n                if(s.substr(0,n-l)==s.substr(l)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        return (s+s).substr(1,2*s.size()-2).find(s)!=-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977772,
                "title": "c-kmp-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(const string &s) {\\n\\t    vector<int> kmp(s.size(), 0);\\n\\t    for (int i = 0, j = 1; j < s.size(); j++) {\\n\\t\\t    while (i > 0 and s[i] != s[j])\\n\\t\\t\\t    i = kmp[i - 1];\\n\\t\\t    if (s[i] == s[j])\\n\\t\\t\\t    kmp[j] = ++i;\\n\\t    }\\n\\t    return kmp.back() and kmp.back() % (s.size() - kmp.back()) == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(const string &s) {\\n\\t    vector<int> kmp(s.size(), 0);\\n\\t    for (int i = 0, j = 1; j < s.size(); j++) {\\n\\t\\t    while (i > 0 and s[i] != s[j])\\n\\t\\t\\t    i = kmp[i - 1];\\n\\t\\t    if (s[i] == s[j])\\n\\t\\t\\t    kmp[j] = ++i;\\n\\t    }\\n\\t    return kmp.back() and kmp.back() % (s.size() - kmp.back()) == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904955,
                "title": "beginner-friendly-java-solution",
                "content": "We have removed 1st land lst character form str, now we are checking if s present in it ;\\nif pattern is there s+s can form new string str that contains s\\n\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String str = s+s;\\n        return str.substring(1, str.length()-1).contains(s);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String str = s+s;\\n        return str.substring(1, str.length()-1).contains(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716110,
                "title": "python-1-liner-faster-than-96-28ms",
                "content": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in (s*2)[1:-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in (s*2)[1:-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299864,
                "title": "java-simplest-solution-with-proper-explaination",
                "content": "```\\n    public boolean repeatedSubstringPattern(String s) {\\n        String k =s+s;     // 1.\\n        k=k.substring(1,k.length()-1);  //2.\\n        if(k.contains(s))    //3.\\n            return true;\\n        return false;    //4.\\n       \\n    }\\n```\\n1. Rotation method i.e if we concatenate string with itself it will form a rotation of that string ( \"abab\" + \"abab\" -> \"abababab\"  , \"aba\"+\"aba\"->\"abaaba\"). \\n2.  Now remove the first and last letter from the new generated string. It will help to remove the ambigous substring as we need to search for the the original string in this new string. \\n3.  Now check for the original string in new string, if it is present then it means the new generated string is the repetition of the substring of original string. (\"bababa\", from index 1 to 4 we can find the original string therefore returned true)\\n4.  Whereas in \"baab\" the original string \"aba\" is not to be found hence returned false.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public boolean repeatedSubstringPattern(String s) {\\n        String k =s+s;     // 1.\\n        k=k.substring(1,k.length()-1);  //2.\\n        if(k.contains(s))    //3.\\n            return true;\\n        return false;    //4.\\n       \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1076920,
                "title": "javascript-one-liner",
                "content": "```javascript\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    return s.repeat(2).slice(1,-1).indexOf(s) !== -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    return s.repeat(2).slice(1,-1).indexOf(s) !== -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 840400,
                "title": "c-faster-than-96",
                "content": "Runtime: 76 ms, faster than 96.19% of C# online submissions for Repeated Substring Pattern.\\nMemory Usage: 30.1 MB, less than 99.59% of C# online submissions for Repeated Substring Pattern.\\n```\\npublic class Solution {\\n    public bool RepeatedSubstringPattern(string s) {\\n        int len = s.Length;\\n        if(len < 2)\\n            return false;\\n        \\n        for(int i=2; i<=len/2; i++)\\n            if(len % i == 0)\\n                if(CheckConcatenation(s, i))\\n                    return true;\\n\\n        //check if all characters are the same\\n        char first=s[0];\\n        for(int i=1; i<len; i++)\\n            if(s[i] != first)\\n                return false;\\n        \\n        return true;\\n    }\\n    \\n    private bool CheckConcatenation(string s, int multi)\\n    {\\n        int div = s.Length / multi;\\n        for(int i=0; i<div; i++)\\n        {\\n            char first = s[i];\\n            for(int j=1; j<multi; j++)\\n                if(s[i+j*div] != first)\\n                    return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool RepeatedSubstringPattern(string s) {\\n        int len = s.Length;\\n        if(len < 2)\\n            return false;\\n        \\n        for(int i=2; i<=len/2; i++)\\n            if(len % i == 0)\\n                if(CheckConcatenation(s, i))\\n                    return true;\\n\\n        //check if all characters are the same\\n        char first=s[0];\\n        for(int i=1; i<len; i++)\\n            if(s[i] != first)\\n                return false;\\n        \\n        return true;\\n    }\\n    \\n    private bool CheckConcatenation(string s, int multi)\\n    {\\n        int div = s.Length / multi;\\n        for(int i=0; i<div; i++)\\n        {\\n            char first = s[i];\\n            for(int j=1; j<multi; j++)\\n                if(s[i+j*div] != first)\\n                    return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827791,
                "title": "c-repeated-substring-pattern-easy-maintain-the-length-window",
                "content": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n\\t\\t// This loop takes care of the length of substring(1-n/2) (for minimum 2 repeated substring , length=n/2)\\n        for(int l=1;l<=n/2;l++){\\n\\t\\t// i= starting index of previous substring ,j=starting index of current substring\\n            int i=0,j=i+l;\\n           // match the corresponding index of two substrings\\n            while(i<n && j<n && s[i]==s[j]){\\n                i++;j++;\\n            }\\n\\t\\t\\t// if the current length divides the string length , then thr substring can be repeated to form the given string\\n            if(j==n && n%l==0)\\n                return true;\\n        }return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n\\t\\t// This loop takes care of the length of substring(1-n/2) (for minimum 2 repeated substring , length=n/2)\\n        for(int l=1;l<=n/2;l++){\\n\\t\\t// i= starting index of previous substring ,j=starting index of current substring\\n            int i=0,j=i+l;\\n           // match the corresponding index of two substrings\\n            while(i<n && j<n && s[i]==s[j]){\\n                i++;j++;\\n            }\\n\\t\\t\\t// if the current length divides the string length , then thr substring can be repeated to form the given string\\n            if(j==n && n%l==0)\\n                return true;\\n        }return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827070,
                "title": "python-o-n-practice-kmp",
                "content": "Using KMP, `dfa[i]` helps us find out the length of longest prefix that equals to the suffix in `s[:i]`. aka. if `dfa[i] == d`, then `s[:d] == s[i-d:i]`.\\nIn this case, a valid `s` should be a substring `p` repeated by `k` times (`k >1`). So that `dfa[n-1] == len(p) * (k-1)`. We can check this by `dfa[n-1] != 0 and dfa[n-1] % (n-dfa[n-1]) == 0`. And necessity is easy to prove: if  `dfa[n-1] == len(p) * (k-1)`, `s[:(k-1)p]` == `s[p:]` then s is a `p` repeated by `k` times.\\n```\\ndef repeatedSubstringPattern(s):\\n\\tn = len(s)\\n\\tdfa = [0] * n\\n\\td = 0\\n\\tfor i in range(1, n):\\n\\t\\twhile d and s[i] != s[d]:\\n\\t\\t\\td = dfa[d-1]\\n\\t\\td += s[i] == s[d]\\n\\t\\tdfa[i] = d\\n\\tpat = dfa[n-1]\\n\\treturn pat != 0 and (pat % (n-pat) == 0)\\n```\\nActually running time is much more than `return s in (s+s)[1:-1]` but time complexity is `O(n)`.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef repeatedSubstringPattern(s):\\n\\tn = len(s)\\n\\tdfa = [0] * n\\n\\td = 0\\n\\tfor i in range(1, n):\\n\\t\\twhile d and s[i] != s[d]:\\n\\t\\t\\td = dfa[d-1]\\n\\t\\td += s[i] == s[d]\\n\\t\\tdfa[i] = d\\n\\tpat = dfa[n-1]\\n\\treturn pat != 0 and (pat % (n-pat) == 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 827014,
                "title": "c-gcd-of-frequencies-based-solution-explained-100-time-100-space",
                "content": "I know the problem is somehow trivial, checking in a loop if your first character matches the following character, otherwise increasing the step and so on.\\n\\nAnd as any respectable OCD-led engineer, I wanted to optimise it.\\n\\nSo I started to think what I could have done before to improve and avoid wasteful attempts.\\n\\nAnd I decided first of all to get the frequency of all the characters, then take all those frequencies and compute the GCD of them with the always handy [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm), setting the initial value of `base` to the overall length of the string itself, then reducing it while using all the non-`0` frequencies I found.\\n\\nSay for example my frequencies for `\\'a\\'`, `\\'b\\'` and `\\'c\\'`, were, respectively, `6`, `15` and `18`: I would have known that the `base` tiniest repetition of all the character an even amount of time (in proportion to their distribution in the string) would have had length `3` (the GCD of those 3 frequencies); and later on we can assume that the tiniest substring we can start looking for it has to be equal to the overall string length (`6 + 15 + 18 == 39` in the example above) divided by this amount of repetitions (so the smallest possible pattern, if any such existed, would have been `39 / 3 == 13`).\\n\\nFurthermore, if performing my GCD reduction would have resulted in `base == 1`, that would have told me that it was not possible to split the string into any sub-part of repeated characters, since the frequencies would have been prime compared to each other (ie: in the above example, getting for example `4`, `15` and `18`).\\n\\nSo, in a lot of cases, my pre-parse of the string already pays off its own cost, saving more hussle later on - I call it a win already!\\n\\nBut there is more: when we actually start to grind down and actually check for repeated patterns, instead of blindly trying in bits of `1`, `2`, etc..., we just move on in more sensible steps of `step` size, having computed it (initially) as `sLen / base` .\\n\\nThat is not trivial either, since in some more advanced tests, I obtained an initial `step` value of `5` or more, so definitely a lot of saved computation compared to going and testing our luck with all the numbers in the `1 - s.size() / 2` range.\\n\\nNow, the last part is probably the easiest one: we initialise our `isRepeated` boolean to `true` because we feel optimistic (and because it is much less of a pain to check for mismatches in this kind of problem) and start looping:\\n* the outer loop will just go from `0` to `step` (excluded), that is to say with, say, `step == 13`, we would loop with `i` taking `0`, `1`, ... , `11` and `12` as values;\\n* the inner loop would compare the same character across all the supposed subpatterns, so, in our initial example, it will check in the first run if th characters in positions `0`, `13` and `26` all had the same value, then `1`, `14` and `27`, and so on;\\n* if any mismatch was found, we would flag `isRepeated` as `false`, break out of both loops;\\n* regardless of the reasonm once we are out of both loops we check; if `isRepeated` is `true`, then we also exit the while loop at once, otherwise we increase the `step` by `subStrLen`, all the time that we need so that `step` is still a valid divisor of `sLen` and then assign to `isRepeated` a value depending whether or not it has grown past half of the initial string length - if so, we are done checking and we exit.\\n\\nAt the end of it all, we just return the final value of `isRepeated` and we are done :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // euclidean algorithm here, if you wonder\\n\\tint gcd(int a, int b) {\\n        return b ? gcd(b, a % b) : a;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        int chars[26], sLen = s.size(), base = sLen;\\n        for (auto &c: chars) c = 0;\\n        for (char c: s) chars[c - \\'a\\']++;\\n        for (int i: chars) if (i) base = gcd(base, i);\\n        // exit: no repeated substrings\\n        if (base == 1) return false;\\n        int subStrLen = sLen / base, step = subStrLen;\\n        // our result variable to be checked\\n        bool isRepeated = true;\\n        while (isRepeated) {\\n            for (int i = 0; i < step; i++) {\\n                for (int j = i; j < sLen; j += step) if (s[i] != s[j]) {\\n                    isRepeated = false;\\n                    break;\\n                }\\n                // if it is not a valid sequence, we exit here\\n                if (!isRepeated) break;\\n            }\\n            // if it is instead a valid sequence, here we exit for good\\n            if (isRepeated) break;\\n            // otherwise we try with a bigger step that is still a divisor of sLen\\n            do {\\n                step += subStrLen;\\n            } while (step <= sLen / 2 && sLen % step);\\n            // we reset isRepeated for another go\\n            isRepeated = step <= sLen / 2;\\n        }\\n        return isRepeated;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // euclidean algorithm here, if you wonder\\n\\tint gcd(int a, int b) {\\n        return b ? gcd(b, a % b) : a;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        int chars[26], sLen = s.size(), base = sLen;\\n        for (auto &c: chars) c = 0;\\n        for (char c: s) chars[c - \\'a\\']++;\\n        for (int i: chars) if (i) base = gcd(base, i);\\n        // exit: no repeated substrings\\n        if (base == 1) return false;\\n        int subStrLen = sLen / base, step = subStrLen;\\n        // our result variable to be checked\\n        bool isRepeated = true;\\n        while (isRepeated) {\\n            for (int i = 0; i < step; i++) {\\n                for (int j = i; j < sLen; j += step) if (s[i] != s[j]) {\\n                    isRepeated = false;\\n                    break;\\n                }\\n                // if it is not a valid sequence, we exit here\\n                if (!isRepeated) break;\\n            }\\n            // if it is instead a valid sequence, here we exit for good\\n            if (isRepeated) break;\\n            // otherwise we try with a bigger step that is still a divisor of sLen\\n            do {\\n                step += subStrLen;\\n            } while (step <= sLen / 2 && sLen % step);\\n            // we reset isRepeated for another go\\n            isRepeated = step <= sLen / 2;\\n        }\\n        return isRepeated;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826598,
                "title": "repeated-substring-pattern-easy-to-understand-5-liner-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        for(int i=1;i<=n/2;i++)\\n            if(n%i == 0 && s.substr(i) == s.substr(0,n-i))\\n                return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        for(int i=1;i<=n/2;i++)\\n            if(n%i == 0 && s.substr(i) == s.substr(0,n-i))\\n                return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826417,
                "title": "rust-oneliner",
                "content": "```rust\\nimpl Solution {\\n    pub fn repeated_substring_pattern(s: String) -> bool {\\n        return (s.clone() + &s)[1..s.len()*2-1].contains(&s);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn repeated_substring_pattern(s: String) -> bool {\\n        return (s.clone() + &s)[1..s.len()*2-1].contains(&s);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 697405,
                "title": "python3-one-line",
                "content": "# Example:\\n`abab` can be found in \"~~a~~b**abab**a~~b~~\"\\n`abc` cannot be found in \"~~a~~bcab~~c~~\"\\n\\n\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return (s*2)[1:-1].find(s) != -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return (s*2)[1:-1].find(s) != -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442557,
                "title": "javascript-easy-to-read",
                "content": "```javascript\\nvar repeatedSubstringPattern = function(s) { \\n    let median = Math.floor(s.length / 2);\\n    let cur;\\n    let multiple;\\n    \\n    for (let i = 1; i <= median; i++) {\\n        cur = s.slice(0, i);\\n        multiple = Math.floor(s.length / cur.length);\\n        \\n        if (cur.repeat(multiple) === s) {\\n            return true;\\n        }\\n    }\\n    \\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar repeatedSubstringPattern = function(s) { \\n    let median = Math.floor(s.length / 2);\\n    let cur;\\n    let multiple;\\n    \\n    for (let i = 1; i <= median; i++) {\\n        cur = s.slice(0, i);\\n        multiple = Math.floor(s.length / cur.length);\\n        \\n        if (cur.repeat(multiple) === s) {\\n            return true;\\n        }\\n    }\\n    \\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 399870,
                "title": "swift-simple-solution",
                "content": "```\\n    func repeatedSubstringPattern(_ s: String) -> Bool {\\n        var newstr = s + s\\n        newstr.removeLast()\\n        newstr.removeFirst()\\n        return newstr.contains(s) ? true : false\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    func repeatedSubstringPattern(_ s: String) -> Bool {\\n        var newstr = s + s\\n        newstr.removeLast()\\n        newstr.removeFirst()\\n        return newstr.contains(s) ? true : false\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 218996,
                "title": "another-solution-and-explanation",
                "content": "Many people have shared the clever idea of concatenating the input string. The nitpick about this clever idea is that it needs to construct a new string, which has space complexity of `O(n)`. So I would like to add one in the following with strict `O(n)` time and `O(1)` space.\\n\\nThe idea is to traverse all possible patterns. Suppose the string `s` is of length `n`, then the pattern can at most have `n/2` characters and should start with `s[0]`. Moreover, the length of the pattern should be divisible by `n`. Given the pattern `s[0:l)`, we check whether the remaining `s[l:l+1), ..., s[n-l:n)` are all equal to it.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n        for (int l = 1; l <= n / 2; l++) {\\n            if (n % l) {\\n                continue;\\n            }\\n            string pattern = s.substr(0, l);\\n            int i = l;\\n            for (; i < n; i += l) {\\n                if (s.substr(i, l) != pattern) {\\n                    break;\\n                }\\n            }\\n            if (i == n) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n        for (int l = 1; l <= n / 2; l++) {\\n            if (n % l) {\\n                continue;\\n            }\\n            string pattern = s.substr(0, l);\\n            int i = l;\\n            for (; i < n; i += l) {\\n                if (s.substr(i, l) != pattern) {\\n                    break;\\n                }\\n            }\\n            if (i == n) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212154,
                "title": "kotlin-1-line-without-explanation",
                "content": "```\\n//https://leetcode.com/problems/repeated-substring-pattern/\\n\\nclass Solution {\\n  fun repeatedSubstringPattern(s: String) = (1..s.length / 2).any { s.length % it == 0 && s.take(it).repeat(s.length / it) == s}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//https://leetcode.com/problems/repeated-substring-pattern/\\n\\nclass Solution {\\n  fun repeatedSubstringPattern(s: String) = (1..s.length / 2).any { s.length % it == 0 && s.take(it).repeat(s.length / it) == s}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180439,
                "title": "java-1-line-with-simple-explanation",
                "content": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        return s.concat(s).indexOf(s, 1) < s.length();\\n    }\\n}\\n```\\n```(s + s).indexOf(s, 1)``` can be less than ```s.length()``` only if ```s``` is a repeated pattern. Actually, in this case ```indexOf(s, 1)``` is the length of the pattern and it\\'s always less than or equal to ```s.length() / 2```.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        return s.concat(s).indexOf(s, 1) < s.length();\\n    }\\n}\\n```\n```(s + s).indexOf(s, 1)```\n```s.length()```\n```s```\n```indexOf(s, 1)```\n```s.length() / 2```",
                "codeTag": "Java"
            },
            {
                "id": 168141,
                "title": "java-o-n-solution-kmp-with-explanation",
                "content": "At each index we store the position 1 after the found pattern starting from the left, naturally this means the position after it will also be the length of the found pattern since we start from 0.  The reason we store +1 the position is that we already know this letter was matched, so there\\'s no point in checking the letter again, we should check the letter after it. \\n\\nWe have two pointers j=0 and i=1, if the characters are equal to advance them and assign dp[i]=j+1 (point to character after j since we already know character j matches).\\n\\nIf they aren\\'t equal and j was already reset all the way (j==0).  We give up on the letter i  and advance i to the next letter. \\n\\nIf it\\'s not equal we backtrack j to j = dp[j-1].  dp[j] gives the position after the match of this character, this character didn\\'t match so going back dp[j] is not a correct choice, we need to choose the letter before it.  We try dp[j-1] then check if it matches in the next iteration. j-1 will never be negative because if j==0 we would have hit the branch before it.\\n\\nFor example:\\na b a a b a b a a b\\n0 0 1 1 2 3 2 3 4 5\\nabaab is of length 5, so we know that it\\'s a repeated substring if the last index is more than 0 (means at least one character was matched, and we know it\\'s repeated if the length is divisble by the (length - substring length) since it means we repeated the substring that many times. In this case length = 10 %(10-5) == 0   10/5 = 2 because abaababaab consists of 2 abaab \\'s\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int [] dp = new int[s.length()];\\n        int i = 1;\\n        int j = 0;\\n        while(i<s.length()){\\n            if(s.charAt(i)==s.charAt(j)){\\n                dp[i]=++j;\\n                ++i;\\n            }\\n            else if(j==0){\\n                ++i;\\n            }\\n            else{\\n                j=dp[j-1];\\n            }\\n        }\\n        return dp[s.length()-1]>0 && s.length()%(s.length()-dp[s.length()-1])==0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int [] dp = new int[s.length()];\\n        int i = 1;\\n        int j = 0;\\n        while(i<s.length()){\\n            if(s.charAt(i)==s.charAt(j)){\\n                dp[i]=++j;\\n                ++i;\\n            }\\n            else if(j==0){\\n                ++i;\\n            }\\n            else{\\n                j=dp[j-1];\\n            }\\n        }\\n        return dp[s.length()-1]>0 && s.length()%(s.length()-dp[s.length()-1])==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94343,
                "title": "5-java-solutions",
                "content": "1. Regular Expression\\n```\\npublic boolean repeatedSubstringPattern(String s) {\\n    return s.matches(\"^([a-z]+)\\\\\\\\1{1,}$\");\\n}\\n```\\n2. Use char array\\n```\\npublic boolean repeatedSubstringPattern(String s) {\\n    int len = s.length();\\n    char[] sc = s.toCharArray();\\n    for (int i = len / 2; i > 0; i--) {\\n        if (len % i != 0) continue;\\n        boolean find = true;\\n        for (int j = i; j < len; j++) {\\n            if (sc[j] != sc[j % i]) {\\n                find = false;\\n                break;\\n            }\\n        }\\n        if (find) return true;\\n    }\\n    return false;\\n}\\n```\\n3. StringBuilder\\n```\\npublic boolean repeatedSubstringPattern(String s) {\\n    int len = s.length();\\n    char[] sc = s.toCharArray();\\n    for (int i = len / 2; i > 0; i--) {\\n        if (len % i != 0) continue;\\n        boolean find = true;\\n        for (int j = i; j < len; j++) {\\n            if (sc[j] != sc[j % i]) {\\n                find = false;\\n                break;\\n            }\\n        }\\n        if (find) return true;\\n    }\\n    return false;\\n}\\n```\\n4. Concatinate 2 strings\\nBasic Idea:\\n1) First char of input string is first char of repeated substring\\n2) Last char of input string is last char of repeated substring\\n3) Let S1 = S + S (where S in input string)\\n4) Remove 1 and last char of S1. Let this be S2\\n5) If S exists in S2 then return true else false\\n6) Let i be index in S2 where S starts then repeated substring length i + 1 and repeated substring S[0: i+1]\\n```\\npublic boolean repeatedSubstringPattern(String str) {\\n    String s = str + str;\\n    return s.substring(1, s.length() - 1).contains(str);\\n}\\n```\\n5. KMP Solution\\n```\\npublic boolean repeatedSubstringPattern(String str) {\\n    int len = str.length();\\n    int last = computePrefix(str.toCharArray())[len - 1];\\n    return last > 0 && (len % (len - last) == 0);\\n}\\nprivate int[] computePrefix(char[] pattern) {\\n    int len = pattern.length, left = 0, right = 1;\\n    int[] ret = new int[len];\\n    ret[0] = 0;\\n    while (right < pattern.length) {\\n        if (pattern[right] == pattern[left])\\n            ret[right++] = ++left;\\n        else if (left == 0)\\n            ret[right++] = 0;\\n        else\\n            left = ret[left - 1];\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean repeatedSubstringPattern(String s) {\\n    return s.matches(\"^([a-z]+)\\\\\\\\1{1,}$\");\\n}\\n```\n```\\npublic boolean repeatedSubstringPattern(String s) {\\n    int len = s.length();\\n    char[] sc = s.toCharArray();\\n    for (int i = len / 2; i > 0; i--) {\\n        if (len % i != 0) continue;\\n        boolean find = true;\\n        for (int j = i; j < len; j++) {\\n            if (sc[j] != sc[j % i]) {\\n                find = false;\\n                break;\\n            }\\n        }\\n        if (find) return true;\\n    }\\n    return false;\\n}\\n```\n```\\npublic boolean repeatedSubstringPattern(String s) {\\n    int len = s.length();\\n    char[] sc = s.toCharArray();\\n    for (int i = len / 2; i > 0; i--) {\\n        if (len % i != 0) continue;\\n        boolean find = true;\\n        for (int j = i; j < len; j++) {\\n            if (sc[j] != sc[j % i]) {\\n                find = false;\\n                break;\\n            }\\n        }\\n        if (find) return true;\\n    }\\n    return false;\\n}\\n```\n```\\npublic boolean repeatedSubstringPattern(String str) {\\n    String s = str + str;\\n    return s.substring(1, s.length() - 1).contains(str);\\n}\\n```\n```\\npublic boolean repeatedSubstringPattern(String str) {\\n    int len = str.length();\\n    int last = computePrefix(str.toCharArray())[len - 1];\\n    return last > 0 && (len % (len - last) == 0);\\n}\\nprivate int[] computePrefix(char[] pattern) {\\n    int len = pattern.length, left = 0, right = 1;\\n    int[] ret = new int[len];\\n    ret[0] = 0;\\n    while (right < pattern.length) {\\n        if (pattern[right] == pattern[left])\\n            ret[right++] = ++left;\\n        else if (left == 0)\\n            ret[right++] = 0;\\n        else\\n            left = ret[left - 1];\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94410,
                "title": "java-solution-using-prime-numbers-beats-97-59-16ms",
                "content": "The idea is the same as @fabrizio3 and @prateek470 with slight optimizations. \\nPls. go through this solution first https://discuss.leetcode.com/topic/67992/java-simple-solution-with-explanation\\nWe can use the premise that if the we checked for i == 2 then we do not need to check to 4, 8, and so on. So, in turn we just need to check for prime numbers i.e. 2, 3, 5, 7, etc. We can hard code the first few prime numbers or write a code to generate those as well.\\n```\\nint[] primes = {};//array of primes\\nint l = s.length();\\nif (l == 0) {\\n    return false;\\n}\\nint index = 0;\\nint count;\\nwhile (index < primes.length) {\\n    count = primes[index];\\n    if (l % count == 0) {\\n        int len = l / count;\\n        //System.out.println(\"Len is: \" + len);\\n        String subS = s.substring(0, len);\\n        //System.out.println(subS);\\n        int i;\\n        for (i = 1; i < count; i++) {\\n            if (!subS.equals(s.substring(i * len, len + len * i))) {\\n                break;\\n            }\\n        }\\n        if (i == count) {\\n            return true;\\n        }\\n    }\\n    index++;\\n}\\nreturn false;",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String"
                ],
                "code": "The idea is the same as @fabrizio3 and @prateek470 with slight optimizations. \\nPls. go through this solution first https://discuss.leetcode.com/topic/67992/java-simple-solution-with-explanation\\nWe can use the premise that if the we checked for i == 2 then we do not need to check to 4, 8, and so on. So, in turn we just need to check for prime numbers i.e. 2, 3, 5, 7, etc. We can hard code the first few prime numbers or write a code to generate those as well.\\n```\\nint[] primes = {};//array of primes\\nint l = s.length();\\nif (l == 0) {\\n    return false;\\n}\\nint index = 0;\\nint count;\\nwhile (index < primes.length) {\\n    count = primes[index];\\n    if (l % count == 0) {\\n        int len = l / count;\\n        //System.out.println(\"Len is: \" + len);\\n        String subS = s.substring(0, len);\\n        //System.out.println(subS);\\n        int i;\\n        for (i = 1; i < count; i++) {\\n            if (!subS.equals(s.substring(i * len, len + len * i))) {\\n                break;\\n            }\\n        }\\n        if (i == count) {\\n            return true;\\n        }\\n    }\\n    index++;\\n}\\nreturn false;",
                "codeTag": "Unknown"
            },
            {
                "id": 94469,
                "title": "python-regular-expression-solution",
                "content": "    def repeatedSubstringPattern(self, str):\\n        \"\"\"\\n        :type str: str\\n        :rtype: bool\\n        \"\"\"\\n        import re\\n        return bool(re.match(r\"^([a-z]+)\\\\1+$\", str))",
                "solutionTags": [],
                "code": "    def repeatedSubstringPattern(self, str):\\n        \"\"\"\\n        :type str: str\\n        :rtype: bool\\n        \"\"\"\\n        import re\\n        return bool(re.match(r\"^([a-z]+)\\\\1+$\", str))",
                "codeTag": "Python3"
            },
            {
                "id": 94393,
                "title": "python-kmp-o-n",
                "content": "```\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, str):\\n        \"\"\"\\n        :type str: str\\n        :rtype: bool\\n        \"\"\"\\n        def computeLPS(str):\\n            lps=[0]*len(str)\\n            i=1\\n            length=0\\n            \\n            while i<len(str):\\n                if str[i]==str[length]:\\n                    length+=1\\n                    lps[i]=length\\n                    i+=1\\n                else:\\n                    if length:\\n                        length=lps[length-1]\\n                    else:\\n                        lps[i]=0\\n                        i+=1\\n            return lps \\n        \\n        lps = computeLPS(str)\\n        n = len(str)\\n        lenn = lps[-1]\\n        if lenn and n%(n-lenn)==0:\\n            return True \\n        else:\\n            return False \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, str):\\n        \"\"\"\\n        :type str: str\\n        :rtype: bool\\n        \"\"\"\\n        def computeLPS(str):\\n            lps=[0]*len(str)\\n            i=1\\n            length=0\\n            \\n            while i<len(str):\\n                if str[i]==str[length]:\\n                    length+=1\\n                    lps[i]=length\\n                    i+=1\\n                else:\\n                    if length:\\n                        length=lps[length-1]\\n                    else:\\n                        lps[i]=0\\n                        i+=1\\n            return lps \\n        \\n        lps = computeLPS(str)\\n        n = len(str)\\n        lenn = lps[-1]\\n        if lenn and n%(n-lenn)==0:\\n            return True \\n        else:\\n            return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941892,
                "title": "optimized-solution-in-cpp-83-runtime-87-memory",
                "content": "# Intuition\\nIf such a substring exists, repeated concatenation of which gives `s`, it must:\\n1. Be a prefix of `s`\\n2. Have a length which is a divisor of length of `s` i.e. `s.size()`\\n\\nSo we only need to check prefixes of `s` which have lengths which are divisors of`s.size()`, also if a prefix of length `l` gets rejected, then all divisors of `l` get rejected too.\\n# Approach\\nFirstly, if length of `s` is `1`, we return false, otherwise:\\nWe first start by finding all the divisors of `s.size()` except `s.size()` and store them in decreasing order using a set:\\n```\\nset<int,greater<int>>divs;\\nint n=s.size();\\nfor(int i=2;i*i<=n;i++)\\n{\\n    if(n%i==0)\\n    {\\n        divs.insert(n/i);\\n        divs.insert(i);\\n    }\\n}\\ndivs.insert(1);\\n```\\nWe now check prefixes in decreasing order of their lengths:\\nIf the current prefix keeps appearing continously in `s` till the last index, we return true, else, we remove all divisors of the length of the current prefix from the set:\\n```\\nfor(auto i:divs)\\n{\\n    int j=0;\\n    while(j+2*i<=n&&s.substr(j,i)==s.substr(j+i,i))\\n    {\\n        j+=i;\\n    }\\n    if(j==n-i)\\n    {\\n        return true;\\n    }\\n    for(int j=2;j*j<=i;j++)\\n    {\\n        if(i%j==0)\\n        {\\n            divs.erase(j);\\n            divs.erase(i/j);\\n        }\\n}\\n```\\nIf none of the elements of the set give the required substring, we simply return false.\\n# Complexity\\n- Time complexity:$$O(n.\\u221An)$$\\n`n=s.size()` can have a maximum of 2\\u221An divisors and each of the loop checking if the prefix is a valid substring runs for a max n times (in case of divisor=1).\\n\\n- Space complexity:$$O(n)$$\\nSelf-explanatory -.- \\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool repeatedSubstringPattern(string s) \\n    {\\n        if(s.size()==1)\\n        {\\n            return false;\\n        }\\n        set<int,greater<int>>divs;\\n        int n=s.size();\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            {\\n                divs.insert(n/i);\\n                divs.insert(i);\\n            }\\n        }\\n        divs.insert(1);\\n        n=s.size();\\n        for(auto i:divs)\\n        {\\n            int j=0;\\n            while(j+2*i<=n&&s.substr(j,i)==s.substr(j+i,i))\\n            {\\n                j+=i;\\n            }\\n            if(j==n-i)\\n            {\\n                return true;\\n            }\\n            for(int j=2;j*j<=i;j++)\\n            {\\n                if(i%j==0)\\n                {\\n                    divs.erase(j);\\n                    divs.erase(i/j);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nset<int,greater<int>>divs;\\nint n=s.size();\\nfor(int i=2;i*i<=n;i++)\\n{\\n    if(n%i==0)\\n    {\\n        divs.insert(n/i);\\n        divs.insert(i);\\n    }\\n}\\ndivs.insert(1);\\n```\n```\\nfor(auto i:divs)\\n{\\n    int j=0;\\n    while(j+2*i<=n&&s.substr(j,i)==s.substr(j+i,i))\\n    {\\n        j+=i;\\n    }\\n    if(j==n-i)\\n    {\\n        return true;\\n    }\\n    for(int j=2;j*j<=i;j++)\\n    {\\n        if(i%j==0)\\n        {\\n            divs.erase(j);\\n            divs.erase(i/j);\\n        }\\n}\\n```\n```\\nclass Solution \\n{\\npublic:\\n    bool repeatedSubstringPattern(string s) \\n    {\\n        if(s.size()==1)\\n        {\\n            return false;\\n        }\\n        set<int,greater<int>>divs;\\n        int n=s.size();\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            {\\n                divs.insert(n/i);\\n                divs.insert(i);\\n            }\\n        }\\n        divs.insert(1);\\n        n=s.size();\\n        for(auto i:divs)\\n        {\\n            int j=0;\\n            while(j+2*i<=n&&s.substr(j,i)==s.substr(j+i,i))\\n            {\\n                j+=i;\\n            }\\n            if(j==n-i)\\n            {\\n                return true;\\n            }\\n            for(int j=2;j*j<=i;j++)\\n            {\\n                if(i%j==0)\\n                {\\n                    divs.erase(j);\\n                    divs.erase(i/j);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941109,
                "title": "most-optimal-solution-using-kmp-knuth-morris-pratt-algorithm",
                "content": "\\n\\n# Approach\\nIn this solution, we calculate the Longest Prefix which is also a Suffix (lps) array using the KMP algorithm. The key observation is that if a string can be divided into multiple copies of a substring, the entire string\\'s length minus the last value in the lps array gives the length of the repeating substring. We then check if the given string length is divisible by the pattern length to determine if it can be constructed using repeated substrings.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        vector<int> lps(n, 0);  \\n        int len = 0;  \\n        for (int i = 1; i < n; ++i) {\\n            while (len > 0 && s[i] != s[len]) {\\n                len = lps[len - 1];\\n            }\\n            if (s[i] == s[len]) {\\n                ++len;\\n            }\\n            lps[i] = len;\\n        }\\n        int patternLen = n - lps[n - 1];\\n        return (patternLen != n && n % patternLen == 0);\\n    }\\n};\\n\\n```\\n```JAVA []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length();\\n        int[] lps = new int[n];\\n        \\n        int len = 0;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            while (len > 0 && s.charAt(i) != s.charAt(len)) {\\n                len = lps[len - 1];\\n            }\\n            if (s.charAt(i) == s.charAt(len)) {\\n                ++len;\\n            }\\n            lps[i] = len;\\n        }\\n        \\n        int patternLen = n - lps[n - 1];\\n        \\n        return patternLen != n && n % patternLen == 0;\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n = len(s)\\n        lps = [0] * n\\n        \\n        len = 0\\n        \\n        for i in range(1, n):\\n            while len > 0 and s[i] != s[len]:\\n                len = lps[len - 1]\\n            if s[i] == s[len]:\\n                len += 1\\n            lps[i] = len\\n        \\n        pattern_len = n - lps[n - 1]\\n        \\n        return pattern_len != n and n % pattern_len == 0\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "String",
                    "String Matching"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        vector<int> lps(n, 0);  \\n        int len = 0;  \\n        for (int i = 1; i < n; ++i) {\\n            while (len > 0 && s[i] != s[len]) {\\n                len = lps[len - 1];\\n            }\\n            if (s[i] == s[len]) {\\n                ++len;\\n            }\\n            lps[i] = len;\\n        }\\n        int patternLen = n - lps[n - 1];\\n        return (patternLen != n && n % patternLen == 0);\\n    }\\n};\\n\\n```\n```JAVA []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length();\\n        int[] lps = new int[n];\\n        \\n        int len = 0;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            while (len > 0 && s.charAt(i) != s.charAt(len)) {\\n                len = lps[len - 1];\\n            }\\n            if (s.charAt(i) == s.charAt(len)) {\\n                ++len;\\n            }\\n            lps[i] = len;\\n        }\\n        \\n        int patternLen = n - lps[n - 1];\\n        \\n        return patternLen != n && n % patternLen == 0;\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n = len(s)\\n        lps = [0] * n\\n        \\n        len = 0\\n        \\n        for i in range(1, n):\\n            while len > 0 and s[i] != s[len]:\\n                len = lps[len - 1]\\n            if s[i] == s[len]:\\n                len += 1\\n            lps[i] = len\\n        \\n        pattern_len = n - lps[n - 1]\\n        \\n        return pattern_len != n and n % pattern_len == 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939399,
                "title": "easy-to-understand-solution-for-daily-challenge-with-comments",
                "content": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        \\n        int n = s.length();\\n        \\n        for(int i=0;i<floor(n/2);i++){\\n            \\n            string str = s.substr(0,i+1);\\n            \\n            // now try to match this string with the remaining string\\n            int j = i+1;\\n            int itr = 0;\\n            bool flag=true;\\n            while(j<n){\\n                // trying to check each character of the string with pattern , if they are matching then the pattern string (str) is a valid answer till now\\n                if(str[itr]==s[j]){\\n                    itr++;\\n                }\\n                else{\\n                    flag=false;\\n                    break;\\n                }\\n                \\n                // setting the index of pattern string to 0 again since whole pattern string has matched once\\n                if(itr==str.length()){\\n                    itr=0;\\n                }\\n                j++;\\n            }\\n            \\n            /* for matching two conditions have to be true \\n             1) flag should be true which means the string pattern has matched properly with respect to whole remaining string indicating the pattern when concatenated can form thw whole of the remaining string\\n             2) the length of whole string should be a multiple of pattern\\'s length \\n            */\\n            if(flag && n%str.length()==0){\\n                return true;\\n            }\\n        }\\n        \\n        \\n        return false;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        \\n        int n = s.length();\\n        \\n        for(int i=0;i<floor(n/2);i++){\\n            \\n            string str = s.substr(0,i+1);\\n            \\n            // now try to match this string with the remaining string\\n            int j = i+1;\\n            int itr = 0;\\n            bool flag=true;\\n            while(j<n){\\n                // trying to check each character of the string with pattern , if they are matching then the pattern string (str) is a valid answer till now\\n                if(str[itr]==s[j]){\\n                    itr++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3938819,
                "title": "c-solution-for-repeated-substring-pattern-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea behind the solution is to consider all possible substring lengths that could potentially form the repeated pattern. For each candidate substring length, we check if it can be used to construct the entire string by appending multiple copies of it together.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We iterate through the possible substring lengths from 1 to half the length of the input string (n / 2). This is because a substring of length greater than half the length of the string cannot be used to form a repeated pattern.\\n\\n1. For each substring length (len), we check if the length of the input string is divisible by len. If it is, then it\\'s possible that a repeated pattern of length len could form the entire string.\\n\\n1. We extract the candidate substring of length len from the beginning of the input string.\\n\\n1. We construct a new string by repeating the candidate substring the necessary number of times (n / len times).\\n\\n1. We compare the newly constructed string with the original input string. If they match, then the input string can be formed by repeating the candidate substring, and we return true.\\n\\n1. If no candidate substring length leads to a match, we return false.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution can be analyzed as follows:\\n\\n- We iterate through possible substring lengths from 1 to n / 2, where n is the length of the input string. This takes O(n) time.\\n- For each candidate substring length, we construct a new string by repeating the substring n / len times. Constructing this new string takes O(n) time in the worst case.\\n- Comparing the newly constructed string with the input string also takes O(n) time.\\n- Therefore, the overall time complexity is approximately O(n^2) in the worst case.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is determined by the space used for the candidate substring and the space used for constructing the new string. Both of these can take up to O(n) space in the worst case (when the candidate substring is the entire string itself).\\n\\nHence, the overall space complexity is O(n).\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool RepeatedSubstringPattern(string s) {\\n        int n = s.Length;\\n    \\n        for (int len = 1; len <= n / 2; len++) {\\n            if (n % len == 0) {\\n                string sub = s.Substring(0, len);\\n                StringBuilder sb = new StringBuilder();\\n                \\n                for (int i = 0; i < n / len; i++) {\\n                    sb.Append(sub);\\n                }\\n                \\n                if (sb.ToString() == s) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool RepeatedSubstringPattern(string s) {\\n        int n = s.Length;\\n    \\n        for (int len = 1; len <= n / 2; len++) {\\n            if (n % len == 0) {\\n                string sub = s.Substring(0, len);\\n                StringBuilder sb = new StringBuilder();\\n                \\n                for (int i = 0; i < n / len; i++) {\\n                    sb.Append(sub);\\n                }\\n                \\n                if (sb.ToString() == s) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690488,
                "title": "very-easy-to-understand-but-21-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        StringBuilder str = new StringBuilder();\\n\\n        for (int i = 0; i < s.length() / 2; i++) {\\n            str.append(s.charAt(i));\\n            if (s.endsWith(str.toString())) if (s.split(str.toString()).length == 0) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        StringBuilder str = new StringBuilder();\\n\\n        for (int i = 0; i < s.length() / 2; i++) {\\n            str.append(s.charAt(i));\\n            if (s.endsWith(str.toString())) if (s.split(str.toString()).length == 0) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607437,
                "title": "simplest-3-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string tmp=s+s;\\n        if(tmp.substr(1,tmp.size()-2).find(s)==-1) return false;\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string tmp=s+s;\\n        if(tmp.substr(1,tmp.size()-2).find(s)==-1) return false;\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534851,
                "title": "python-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        # n = len(s)\\n        # for i in range(n - 1):\\n        #     s0 = s[:i + 1]\\n        #     if s0 * (n // (i + 1)) == s:\\n        #         return True\\n        \\n        # return False\\n\\n\\n        return True if s in (s + s)[1:-1] else False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        # n = len(s)\\n        # for i in range(n - 1):\\n        #     s0 = s[:i + 1]\\n        #     if s0 * (n // (i + 1)) == s:\\n        #         return True\\n        \\n        # return False\\n\\n\\n        return True if s in (s + s)[1:-1] else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101183,
                "title": "one-line-solution",
                "content": "# Approach 1\\nUsing regular expression with group reference.\\n\\n# Complexity\\n- Time complexity: between $$O(n)$$ and $$O(n^2)$$ - depends on implementation of regular expression module.\\n\\n- Space complexity: between $$O(1)$$ and $$O(n)$$ - depends on implementation of regular expression module.\\n\\n# Code\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return re.search(r\\'^(.+)\\\\1+$\\', s)\\n```\\n\\n# Approach 2\\nSearching string in cut double string.\\n\\n# Code\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in (s + s)[1:-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return re.search(r\\'^(.+)\\\\1+$\\', s)\\n```\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in (s + s)[1:-1]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570295,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1568215,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1569122,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1778080,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1576980,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 2023441,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1649332,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 2023338,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1679794,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1687043,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1570295,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1568215,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1569122,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1778080,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1576980,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 2023441,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1649332,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 2023338,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1679794,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1687043,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1566967,
                "content": [
                    {
                        "username": "koolkaps7",
                        "content": "return (str + str).find(str, 1) < str.size();"
                    },
                    {
                        "username": "adityaleetcode",
                        "content": "My code is failing for input \"bb\", but in the example \"aba\" shown as False!! In that case if you consider one character as substring string then \"aba\" also True."
                    },
                    {
                        "username": "dimitryku",
                        "content": "if substring is \"a\", than you can not make \"aba\", since you have not \"b\" in your substring. If substring is \"ab\" than you can not make \"aba\", since you can do \"abab\", \"ababab\" etc only. So it is False. \"bb\" can be made from \"b\", so it is True."
                    },
                    {
                        "username": "bhati25",
                        "content": "Just a tip use KMP algo. "
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/F1irIhD\"><img src=\"https://i.imgur.com/F1irIhD.jpg\" title=\"source: imgur.com\"  width=\"400px\"/></a>"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this question should be a medium... I feel like only the brute force method is easy/intuitive"
                    },
                    {
                        "username": "s3stan",
                        "content": "\\nOne joy on Monday morning - green on LeetCode"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Brute force solution: \\nUse a sliding window technique, try every window size of substring then move the window by the substring length."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This problem is easy to solve and hard to optimize:\nHere are few condition which can be used to optimize the code:\n\nFor **Naive string matching** which involve construction of substring and comparison of those substring the one can reduce his number iteration by:\nHere str is the substring of s which can be repeated to form s (possible answer)\n\n1. Check whether it is possible to create n(*an integer*) substring of size =  str.length for which use the condition:\n    **if (s.length % str.length == 0)**\n2. Before making substring from s check whether the substrings first and last letter are same.\n\nBut these all things will optimize the code to much extent but the real optimization would to use better string matching or pattern matching algorithm:\n**Robin karp Algorithm**: which involve sort of hashing(*converting the string into number to reduce the comparison time*) and sliding window(* as while applying this approach one would be hashing every window of size str.length)\nBut the issue with this algo is its time complexity is $$O(mn)$$\nwhich is not good in term of optimization.\n\n**KMP algorithm**: This algo is little bit difficult to code and understand (I write about it this comment would become an article\nand no one like to read article)\nThe best part about this algo is its time complexity is $$O(m + n)$$.\n\n🚀 Next Level Coding: Now, I get it, this isn't a walk in the park. But trust me, the rewards are worth it. It's like leveling up in the coding universe.\n\nI know it is a bit difficult to implement but you would be able to do it."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "Just hardcoded this and beats 94% in runtime xD"
                    },
                    {
                        "username": "dan_cho",
                        "content": "I saw your solution, It\\'s really hard to even think about that hardcode solution... LOL"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "If you\\'re thinking about PRIME FACTORS and finding all divisors, STOP!\\n\\nKeep it Simple.\\nJust iterate from length `1 ... (N/2)` ( where N is the length of original string ) and check if the current iteration value `i` divides `N` completely i.e. `i % N == 0`, voila you got one of your divisors else continue to next iteration.\\nTime to check if a substring of this length ( starting at 0 ) is able to partition the entire string correctly or not.\\nIf yes, you got the answer, otherwise continue with next iteration."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I tried to check for factors/divisors of length. It should be O(nrootn). But its giving me TLE. \nHere's my code. Please tell me whats wrong..\n\n\n\nclass Solution {\npublic:\n    bool is_pattern(string &s, string &subs)\n    {\n        int n = s.length(), m = subs.length();\n        for(int i = m; i < n; i++)\n        {\n            if(s[i] != subs[i%m]) return false;\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\n        }\n        return true;\n    }\n\n    bool repeatedSubstringPattern(string s) {\n        int n = s.length();\n        if(n == 1) return false;\n        cout<<n<<endl;\n        bool allsame = true;\n        for(int i = 1; i < n; i++)\n        {\n            if(s[i] != s[i-1]) \n            {\n                allsame = false;\n                break;\n            }\n        }\n        if(allsame) return true;\n        for(int i = 2; i*i <= n; i++)\n        {\n            if((n%i) == 0)\n            {\n                int j = n/i;\n                string subs1 = s.substr(0,i);\n                string subs2 = s.substr(0,j);\n\n                // cout<<subs1<<\" \"<<subs2<<endl;\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\n            }\n        } \n        return false;\n    }\n};"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "nice explanation\\n"
                    }
                ]
            },
            {
                "id": 1574637,
                "content": [
                    {
                        "username": "koolkaps7",
                        "content": "return (str + str).find(str, 1) < str.size();"
                    },
                    {
                        "username": "adityaleetcode",
                        "content": "My code is failing for input \"bb\", but in the example \"aba\" shown as False!! In that case if you consider one character as substring string then \"aba\" also True."
                    },
                    {
                        "username": "dimitryku",
                        "content": "if substring is \"a\", than you can not make \"aba\", since you have not \"b\" in your substring. If substring is \"ab\" than you can not make \"aba\", since you can do \"abab\", \"ababab\" etc only. So it is False. \"bb\" can be made from \"b\", so it is True."
                    },
                    {
                        "username": "bhati25",
                        "content": "Just a tip use KMP algo. "
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/F1irIhD\"><img src=\"https://i.imgur.com/F1irIhD.jpg\" title=\"source: imgur.com\"  width=\"400px\"/></a>"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this question should be a medium... I feel like only the brute force method is easy/intuitive"
                    },
                    {
                        "username": "s3stan",
                        "content": "\\nOne joy on Monday morning - green on LeetCode"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Brute force solution: \\nUse a sliding window technique, try every window size of substring then move the window by the substring length."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This problem is easy to solve and hard to optimize:\nHere are few condition which can be used to optimize the code:\n\nFor **Naive string matching** which involve construction of substring and comparison of those substring the one can reduce his number iteration by:\nHere str is the substring of s which can be repeated to form s (possible answer)\n\n1. Check whether it is possible to create n(*an integer*) substring of size =  str.length for which use the condition:\n    **if (s.length % str.length == 0)**\n2. Before making substring from s check whether the substrings first and last letter are same.\n\nBut these all things will optimize the code to much extent but the real optimization would to use better string matching or pattern matching algorithm:\n**Robin karp Algorithm**: which involve sort of hashing(*converting the string into number to reduce the comparison time*) and sliding window(* as while applying this approach one would be hashing every window of size str.length)\nBut the issue with this algo is its time complexity is $$O(mn)$$\nwhich is not good in term of optimization.\n\n**KMP algorithm**: This algo is little bit difficult to code and understand (I write about it this comment would become an article\nand no one like to read article)\nThe best part about this algo is its time complexity is $$O(m + n)$$.\n\n🚀 Next Level Coding: Now, I get it, this isn't a walk in the park. But trust me, the rewards are worth it. It's like leveling up in the coding universe.\n\nI know it is a bit difficult to implement but you would be able to do it."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "Just hardcoded this and beats 94% in runtime xD"
                    },
                    {
                        "username": "dan_cho",
                        "content": "I saw your solution, It\\'s really hard to even think about that hardcode solution... LOL"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "If you\\'re thinking about PRIME FACTORS and finding all divisors, STOP!\\n\\nKeep it Simple.\\nJust iterate from length `1 ... (N/2)` ( where N is the length of original string ) and check if the current iteration value `i` divides `N` completely i.e. `i % N == 0`, voila you got one of your divisors else continue to next iteration.\\nTime to check if a substring of this length ( starting at 0 ) is able to partition the entire string correctly or not.\\nIf yes, you got the answer, otherwise continue with next iteration."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I tried to check for factors/divisors of length. It should be O(nrootn). But its giving me TLE. \nHere's my code. Please tell me whats wrong..\n\n\n\nclass Solution {\npublic:\n    bool is_pattern(string &s, string &subs)\n    {\n        int n = s.length(), m = subs.length();\n        for(int i = m; i < n; i++)\n        {\n            if(s[i] != subs[i%m]) return false;\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\n        }\n        return true;\n    }\n\n    bool repeatedSubstringPattern(string s) {\n        int n = s.length();\n        if(n == 1) return false;\n        cout<<n<<endl;\n        bool allsame = true;\n        for(int i = 1; i < n; i++)\n        {\n            if(s[i] != s[i-1]) \n            {\n                allsame = false;\n                break;\n            }\n        }\n        if(allsame) return true;\n        for(int i = 2; i*i <= n; i++)\n        {\n            if((n%i) == 0)\n            {\n                int j = n/i;\n                string subs1 = s.substr(0,i);\n                string subs2 = s.substr(0,j);\n\n                // cout<<subs1<<\" \"<<subs2<<endl;\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\n            }\n        } \n        return false;\n    }\n};"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "nice explanation\\n"
                    }
                ]
            },
            {
                "id": 2023333,
                "content": [
                    {
                        "username": "koolkaps7",
                        "content": "return (str + str).find(str, 1) < str.size();"
                    },
                    {
                        "username": "adityaleetcode",
                        "content": "My code is failing for input \"bb\", but in the example \"aba\" shown as False!! In that case if you consider one character as substring string then \"aba\" also True."
                    },
                    {
                        "username": "dimitryku",
                        "content": "if substring is \"a\", than you can not make \"aba\", since you have not \"b\" in your substring. If substring is \"ab\" than you can not make \"aba\", since you can do \"abab\", \"ababab\" etc only. So it is False. \"bb\" can be made from \"b\", so it is True."
                    },
                    {
                        "username": "bhati25",
                        "content": "Just a tip use KMP algo. "
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/F1irIhD\"><img src=\"https://i.imgur.com/F1irIhD.jpg\" title=\"source: imgur.com\"  width=\"400px\"/></a>"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this question should be a medium... I feel like only the brute force method is easy/intuitive"
                    },
                    {
                        "username": "s3stan",
                        "content": "\\nOne joy on Monday morning - green on LeetCode"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Brute force solution: \\nUse a sliding window technique, try every window size of substring then move the window by the substring length."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This problem is easy to solve and hard to optimize:\nHere are few condition which can be used to optimize the code:\n\nFor **Naive string matching** which involve construction of substring and comparison of those substring the one can reduce his number iteration by:\nHere str is the substring of s which can be repeated to form s (possible answer)\n\n1. Check whether it is possible to create n(*an integer*) substring of size =  str.length for which use the condition:\n    **if (s.length % str.length == 0)**\n2. Before making substring from s check whether the substrings first and last letter are same.\n\nBut these all things will optimize the code to much extent but the real optimization would to use better string matching or pattern matching algorithm:\n**Robin karp Algorithm**: which involve sort of hashing(*converting the string into number to reduce the comparison time*) and sliding window(* as while applying this approach one would be hashing every window of size str.length)\nBut the issue with this algo is its time complexity is $$O(mn)$$\nwhich is not good in term of optimization.\n\n**KMP algorithm**: This algo is little bit difficult to code and understand (I write about it this comment would become an article\nand no one like to read article)\nThe best part about this algo is its time complexity is $$O(m + n)$$.\n\n🚀 Next Level Coding: Now, I get it, this isn't a walk in the park. But trust me, the rewards are worth it. It's like leveling up in the coding universe.\n\nI know it is a bit difficult to implement but you would be able to do it."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "Just hardcoded this and beats 94% in runtime xD"
                    },
                    {
                        "username": "dan_cho",
                        "content": "I saw your solution, It\\'s really hard to even think about that hardcode solution... LOL"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "If you\\'re thinking about PRIME FACTORS and finding all divisors, STOP!\\n\\nKeep it Simple.\\nJust iterate from length `1 ... (N/2)` ( where N is the length of original string ) and check if the current iteration value `i` divides `N` completely i.e. `i % N == 0`, voila you got one of your divisors else continue to next iteration.\\nTime to check if a substring of this length ( starting at 0 ) is able to partition the entire string correctly or not.\\nIf yes, you got the answer, otherwise continue with next iteration."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I tried to check for factors/divisors of length. It should be O(nrootn). But its giving me TLE. \nHere's my code. Please tell me whats wrong..\n\n\n\nclass Solution {\npublic:\n    bool is_pattern(string &s, string &subs)\n    {\n        int n = s.length(), m = subs.length();\n        for(int i = m; i < n; i++)\n        {\n            if(s[i] != subs[i%m]) return false;\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\n        }\n        return true;\n    }\n\n    bool repeatedSubstringPattern(string s) {\n        int n = s.length();\n        if(n == 1) return false;\n        cout<<n<<endl;\n        bool allsame = true;\n        for(int i = 1; i < n; i++)\n        {\n            if(s[i] != s[i-1]) \n            {\n                allsame = false;\n                break;\n            }\n        }\n        if(allsame) return true;\n        for(int i = 2; i*i <= n; i++)\n        {\n            if((n%i) == 0)\n            {\n                int j = n/i;\n                string subs1 = s.substr(0,i);\n                string subs2 = s.substr(0,j);\n\n                // cout<<subs1<<\" \"<<subs2<<endl;\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\n            }\n        } \n        return false;\n    }\n};"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "nice explanation\\n"
                    }
                ]
            },
            {
                "id": 2023695,
                "content": [
                    {
                        "username": "koolkaps7",
                        "content": "return (str + str).find(str, 1) < str.size();"
                    },
                    {
                        "username": "adityaleetcode",
                        "content": "My code is failing for input \"bb\", but in the example \"aba\" shown as False!! In that case if you consider one character as substring string then \"aba\" also True."
                    },
                    {
                        "username": "dimitryku",
                        "content": "if substring is \"a\", than you can not make \"aba\", since you have not \"b\" in your substring. If substring is \"ab\" than you can not make \"aba\", since you can do \"abab\", \"ababab\" etc only. So it is False. \"bb\" can be made from \"b\", so it is True."
                    },
                    {
                        "username": "bhati25",
                        "content": "Just a tip use KMP algo. "
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/F1irIhD\"><img src=\"https://i.imgur.com/F1irIhD.jpg\" title=\"source: imgur.com\"  width=\"400px\"/></a>"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this question should be a medium... I feel like only the brute force method is easy/intuitive"
                    },
                    {
                        "username": "s3stan",
                        "content": "\\nOne joy on Monday morning - green on LeetCode"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Brute force solution: \\nUse a sliding window technique, try every window size of substring then move the window by the substring length."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This problem is easy to solve and hard to optimize:\nHere are few condition which can be used to optimize the code:\n\nFor **Naive string matching** which involve construction of substring and comparison of those substring the one can reduce his number iteration by:\nHere str is the substring of s which can be repeated to form s (possible answer)\n\n1. Check whether it is possible to create n(*an integer*) substring of size =  str.length for which use the condition:\n    **if (s.length % str.length == 0)**\n2. Before making substring from s check whether the substrings first and last letter are same.\n\nBut these all things will optimize the code to much extent but the real optimization would to use better string matching or pattern matching algorithm:\n**Robin karp Algorithm**: which involve sort of hashing(*converting the string into number to reduce the comparison time*) and sliding window(* as while applying this approach one would be hashing every window of size str.length)\nBut the issue with this algo is its time complexity is $$O(mn)$$\nwhich is not good in term of optimization.\n\n**KMP algorithm**: This algo is little bit difficult to code and understand (I write about it this comment would become an article\nand no one like to read article)\nThe best part about this algo is its time complexity is $$O(m + n)$$.\n\n🚀 Next Level Coding: Now, I get it, this isn't a walk in the park. But trust me, the rewards are worth it. It's like leveling up in the coding universe.\n\nI know it is a bit difficult to implement but you would be able to do it."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "Just hardcoded this and beats 94% in runtime xD"
                    },
                    {
                        "username": "dan_cho",
                        "content": "I saw your solution, It\\'s really hard to even think about that hardcode solution... LOL"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "If you\\'re thinking about PRIME FACTORS and finding all divisors, STOP!\\n\\nKeep it Simple.\\nJust iterate from length `1 ... (N/2)` ( where N is the length of original string ) and check if the current iteration value `i` divides `N` completely i.e. `i % N == 0`, voila you got one of your divisors else continue to next iteration.\\nTime to check if a substring of this length ( starting at 0 ) is able to partition the entire string correctly or not.\\nIf yes, you got the answer, otherwise continue with next iteration."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I tried to check for factors/divisors of length. It should be O(nrootn). But its giving me TLE. \nHere's my code. Please tell me whats wrong..\n\n\n\nclass Solution {\npublic:\n    bool is_pattern(string &s, string &subs)\n    {\n        int n = s.length(), m = subs.length();\n        for(int i = m; i < n; i++)\n        {\n            if(s[i] != subs[i%m]) return false;\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\n        }\n        return true;\n    }\n\n    bool repeatedSubstringPattern(string s) {\n        int n = s.length();\n        if(n == 1) return false;\n        cout<<n<<endl;\n        bool allsame = true;\n        for(int i = 1; i < n; i++)\n        {\n            if(s[i] != s[i-1]) \n            {\n                allsame = false;\n                break;\n            }\n        }\n        if(allsame) return true;\n        for(int i = 2; i*i <= n; i++)\n        {\n            if((n%i) == 0)\n            {\n                int j = n/i;\n                string subs1 = s.substr(0,i);\n                string subs2 = s.substr(0,j);\n\n                // cout<<subs1<<\" \"<<subs2<<endl;\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\n            }\n        } \n        return false;\n    }\n};"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "nice explanation\\n"
                    }
                ]
            },
            {
                "id": 2023554,
                "content": [
                    {
                        "username": "koolkaps7",
                        "content": "return (str + str).find(str, 1) < str.size();"
                    },
                    {
                        "username": "adityaleetcode",
                        "content": "My code is failing for input \"bb\", but in the example \"aba\" shown as False!! In that case if you consider one character as substring string then \"aba\" also True."
                    },
                    {
                        "username": "dimitryku",
                        "content": "if substring is \"a\", than you can not make \"aba\", since you have not \"b\" in your substring. If substring is \"ab\" than you can not make \"aba\", since you can do \"abab\", \"ababab\" etc only. So it is False. \"bb\" can be made from \"b\", so it is True."
                    },
                    {
                        "username": "bhati25",
                        "content": "Just a tip use KMP algo. "
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/F1irIhD\"><img src=\"https://i.imgur.com/F1irIhD.jpg\" title=\"source: imgur.com\"  width=\"400px\"/></a>"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this question should be a medium... I feel like only the brute force method is easy/intuitive"
                    },
                    {
                        "username": "s3stan",
                        "content": "\\nOne joy on Monday morning - green on LeetCode"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Brute force solution: \\nUse a sliding window technique, try every window size of substring then move the window by the substring length."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This problem is easy to solve and hard to optimize:\nHere are few condition which can be used to optimize the code:\n\nFor **Naive string matching** which involve construction of substring and comparison of those substring the one can reduce his number iteration by:\nHere str is the substring of s which can be repeated to form s (possible answer)\n\n1. Check whether it is possible to create n(*an integer*) substring of size =  str.length for which use the condition:\n    **if (s.length % str.length == 0)**\n2. Before making substring from s check whether the substrings first and last letter are same.\n\nBut these all things will optimize the code to much extent but the real optimization would to use better string matching or pattern matching algorithm:\n**Robin karp Algorithm**: which involve sort of hashing(*converting the string into number to reduce the comparison time*) and sliding window(* as while applying this approach one would be hashing every window of size str.length)\nBut the issue with this algo is its time complexity is $$O(mn)$$\nwhich is not good in term of optimization.\n\n**KMP algorithm**: This algo is little bit difficult to code and understand (I write about it this comment would become an article\nand no one like to read article)\nThe best part about this algo is its time complexity is $$O(m + n)$$.\n\n🚀 Next Level Coding: Now, I get it, this isn't a walk in the park. But trust me, the rewards are worth it. It's like leveling up in the coding universe.\n\nI know it is a bit difficult to implement but you would be able to do it."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "Just hardcoded this and beats 94% in runtime xD"
                    },
                    {
                        "username": "dan_cho",
                        "content": "I saw your solution, It\\'s really hard to even think about that hardcode solution... LOL"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "If you\\'re thinking about PRIME FACTORS and finding all divisors, STOP!\\n\\nKeep it Simple.\\nJust iterate from length `1 ... (N/2)` ( where N is the length of original string ) and check if the current iteration value `i` divides `N` completely i.e. `i % N == 0`, voila you got one of your divisors else continue to next iteration.\\nTime to check if a substring of this length ( starting at 0 ) is able to partition the entire string correctly or not.\\nIf yes, you got the answer, otherwise continue with next iteration."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I tried to check for factors/divisors of length. It should be O(nrootn). But its giving me TLE. \nHere's my code. Please tell me whats wrong..\n\n\n\nclass Solution {\npublic:\n    bool is_pattern(string &s, string &subs)\n    {\n        int n = s.length(), m = subs.length();\n        for(int i = m; i < n; i++)\n        {\n            if(s[i] != subs[i%m]) return false;\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\n        }\n        return true;\n    }\n\n    bool repeatedSubstringPattern(string s) {\n        int n = s.length();\n        if(n == 1) return false;\n        cout<<n<<endl;\n        bool allsame = true;\n        for(int i = 1; i < n; i++)\n        {\n            if(s[i] != s[i-1]) \n            {\n                allsame = false;\n                break;\n            }\n        }\n        if(allsame) return true;\n        for(int i = 2; i*i <= n; i++)\n        {\n            if((n%i) == 0)\n            {\n                int j = n/i;\n                string subs1 = s.substr(0,i);\n                string subs2 = s.substr(0,j);\n\n                // cout<<subs1<<\" \"<<subs2<<endl;\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\n            }\n        } \n        return false;\n    }\n};"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "nice explanation\\n"
                    }
                ]
            },
            {
                "id": 2023470,
                "content": [
                    {
                        "username": "koolkaps7",
                        "content": "return (str + str).find(str, 1) < str.size();"
                    },
                    {
                        "username": "adityaleetcode",
                        "content": "My code is failing for input \"bb\", but in the example \"aba\" shown as False!! In that case if you consider one character as substring string then \"aba\" also True."
                    },
                    {
                        "username": "dimitryku",
                        "content": "if substring is \"a\", than you can not make \"aba\", since you have not \"b\" in your substring. If substring is \"ab\" than you can not make \"aba\", since you can do \"abab\", \"ababab\" etc only. So it is False. \"bb\" can be made from \"b\", so it is True."
                    },
                    {
                        "username": "bhati25",
                        "content": "Just a tip use KMP algo. "
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/F1irIhD\"><img src=\"https://i.imgur.com/F1irIhD.jpg\" title=\"source: imgur.com\"  width=\"400px\"/></a>"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this question should be a medium... I feel like only the brute force method is easy/intuitive"
                    },
                    {
                        "username": "s3stan",
                        "content": "\\nOne joy on Monday morning - green on LeetCode"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Brute force solution: \\nUse a sliding window technique, try every window size of substring then move the window by the substring length."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This problem is easy to solve and hard to optimize:\nHere are few condition which can be used to optimize the code:\n\nFor **Naive string matching** which involve construction of substring and comparison of those substring the one can reduce his number iteration by:\nHere str is the substring of s which can be repeated to form s (possible answer)\n\n1. Check whether it is possible to create n(*an integer*) substring of size =  str.length for which use the condition:\n    **if (s.length % str.length == 0)**\n2. Before making substring from s check whether the substrings first and last letter are same.\n\nBut these all things will optimize the code to much extent but the real optimization would to use better string matching or pattern matching algorithm:\n**Robin karp Algorithm**: which involve sort of hashing(*converting the string into number to reduce the comparison time*) and sliding window(* as while applying this approach one would be hashing every window of size str.length)\nBut the issue with this algo is its time complexity is $$O(mn)$$\nwhich is not good in term of optimization.\n\n**KMP algorithm**: This algo is little bit difficult to code and understand (I write about it this comment would become an article\nand no one like to read article)\nThe best part about this algo is its time complexity is $$O(m + n)$$.\n\n🚀 Next Level Coding: Now, I get it, this isn't a walk in the park. But trust me, the rewards are worth it. It's like leveling up in the coding universe.\n\nI know it is a bit difficult to implement but you would be able to do it."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "Just hardcoded this and beats 94% in runtime xD"
                    },
                    {
                        "username": "dan_cho",
                        "content": "I saw your solution, It\\'s really hard to even think about that hardcode solution... LOL"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "If you\\'re thinking about PRIME FACTORS and finding all divisors, STOP!\\n\\nKeep it Simple.\\nJust iterate from length `1 ... (N/2)` ( where N is the length of original string ) and check if the current iteration value `i` divides `N` completely i.e. `i % N == 0`, voila you got one of your divisors else continue to next iteration.\\nTime to check if a substring of this length ( starting at 0 ) is able to partition the entire string correctly or not.\\nIf yes, you got the answer, otherwise continue with next iteration."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I tried to check for factors/divisors of length. It should be O(nrootn). But its giving me TLE. \nHere's my code. Please tell me whats wrong..\n\n\n\nclass Solution {\npublic:\n    bool is_pattern(string &s, string &subs)\n    {\n        int n = s.length(), m = subs.length();\n        for(int i = m; i < n; i++)\n        {\n            if(s[i] != subs[i%m]) return false;\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\n        }\n        return true;\n    }\n\n    bool repeatedSubstringPattern(string s) {\n        int n = s.length();\n        if(n == 1) return false;\n        cout<<n<<endl;\n        bool allsame = true;\n        for(int i = 1; i < n; i++)\n        {\n            if(s[i] != s[i-1]) \n            {\n                allsame = false;\n                break;\n            }\n        }\n        if(allsame) return true;\n        for(int i = 2; i*i <= n; i++)\n        {\n            if((n%i) == 0)\n            {\n                int j = n/i;\n                string subs1 = s.substr(0,i);\n                string subs2 = s.substr(0,j);\n\n                // cout<<subs1<<\" \"<<subs2<<endl;\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\n            }\n        } \n        return false;\n    }\n};"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "nice explanation\\n"
                    }
                ]
            },
            {
                "id": 2023325,
                "content": [
                    {
                        "username": "koolkaps7",
                        "content": "return (str + str).find(str, 1) < str.size();"
                    },
                    {
                        "username": "adityaleetcode",
                        "content": "My code is failing for input \"bb\", but in the example \"aba\" shown as False!! In that case if you consider one character as substring string then \"aba\" also True."
                    },
                    {
                        "username": "dimitryku",
                        "content": "if substring is \"a\", than you can not make \"aba\", since you have not \"b\" in your substring. If substring is \"ab\" than you can not make \"aba\", since you can do \"abab\", \"ababab\" etc only. So it is False. \"bb\" can be made from \"b\", so it is True."
                    },
                    {
                        "username": "bhati25",
                        "content": "Just a tip use KMP algo. "
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/F1irIhD\"><img src=\"https://i.imgur.com/F1irIhD.jpg\" title=\"source: imgur.com\"  width=\"400px\"/></a>"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this question should be a medium... I feel like only the brute force method is easy/intuitive"
                    },
                    {
                        "username": "s3stan",
                        "content": "\\nOne joy on Monday morning - green on LeetCode"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Brute force solution: \\nUse a sliding window technique, try every window size of substring then move the window by the substring length."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This problem is easy to solve and hard to optimize:\nHere are few condition which can be used to optimize the code:\n\nFor **Naive string matching** which involve construction of substring and comparison of those substring the one can reduce his number iteration by:\nHere str is the substring of s which can be repeated to form s (possible answer)\n\n1. Check whether it is possible to create n(*an integer*) substring of size =  str.length for which use the condition:\n    **if (s.length % str.length == 0)**\n2. Before making substring from s check whether the substrings first and last letter are same.\n\nBut these all things will optimize the code to much extent but the real optimization would to use better string matching or pattern matching algorithm:\n**Robin karp Algorithm**: which involve sort of hashing(*converting the string into number to reduce the comparison time*) and sliding window(* as while applying this approach one would be hashing every window of size str.length)\nBut the issue with this algo is its time complexity is $$O(mn)$$\nwhich is not good in term of optimization.\n\n**KMP algorithm**: This algo is little bit difficult to code and understand (I write about it this comment would become an article\nand no one like to read article)\nThe best part about this algo is its time complexity is $$O(m + n)$$.\n\n🚀 Next Level Coding: Now, I get it, this isn't a walk in the park. But trust me, the rewards are worth it. It's like leveling up in the coding universe.\n\nI know it is a bit difficult to implement but you would be able to do it."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "Just hardcoded this and beats 94% in runtime xD"
                    },
                    {
                        "username": "dan_cho",
                        "content": "I saw your solution, It\\'s really hard to even think about that hardcode solution... LOL"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "If you\\'re thinking about PRIME FACTORS and finding all divisors, STOP!\\n\\nKeep it Simple.\\nJust iterate from length `1 ... (N/2)` ( where N is the length of original string ) and check if the current iteration value `i` divides `N` completely i.e. `i % N == 0`, voila you got one of your divisors else continue to next iteration.\\nTime to check if a substring of this length ( starting at 0 ) is able to partition the entire string correctly or not.\\nIf yes, you got the answer, otherwise continue with next iteration."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I tried to check for factors/divisors of length. It should be O(nrootn). But its giving me TLE. \nHere's my code. Please tell me whats wrong..\n\n\n\nclass Solution {\npublic:\n    bool is_pattern(string &s, string &subs)\n    {\n        int n = s.length(), m = subs.length();\n        for(int i = m; i < n; i++)\n        {\n            if(s[i] != subs[i%m]) return false;\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\n        }\n        return true;\n    }\n\n    bool repeatedSubstringPattern(string s) {\n        int n = s.length();\n        if(n == 1) return false;\n        cout<<n<<endl;\n        bool allsame = true;\n        for(int i = 1; i < n; i++)\n        {\n            if(s[i] != s[i-1]) \n            {\n                allsame = false;\n                break;\n            }\n        }\n        if(allsame) return true;\n        for(int i = 2; i*i <= n; i++)\n        {\n            if((n%i) == 0)\n            {\n                int j = n/i;\n                string subs1 = s.substr(0,i);\n                string subs2 = s.substr(0,j);\n\n                // cout<<subs1<<\" \"<<subs2<<endl;\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\n            }\n        } \n        return false;\n    }\n};"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "nice explanation\\n"
                    }
                ]
            },
            {
                "id": 2023700,
                "content": [
                    {
                        "username": "koolkaps7",
                        "content": "return (str + str).find(str, 1) < str.size();"
                    },
                    {
                        "username": "adityaleetcode",
                        "content": "My code is failing for input \"bb\", but in the example \"aba\" shown as False!! In that case if you consider one character as substring string then \"aba\" also True."
                    },
                    {
                        "username": "dimitryku",
                        "content": "if substring is \"a\", than you can not make \"aba\", since you have not \"b\" in your substring. If substring is \"ab\" than you can not make \"aba\", since you can do \"abab\", \"ababab\" etc only. So it is False. \"bb\" can be made from \"b\", so it is True."
                    },
                    {
                        "username": "bhati25",
                        "content": "Just a tip use KMP algo. "
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/F1irIhD\"><img src=\"https://i.imgur.com/F1irIhD.jpg\" title=\"source: imgur.com\"  width=\"400px\"/></a>"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this question should be a medium... I feel like only the brute force method is easy/intuitive"
                    },
                    {
                        "username": "s3stan",
                        "content": "\\nOne joy on Monday morning - green on LeetCode"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Brute force solution: \\nUse a sliding window technique, try every window size of substring then move the window by the substring length."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This problem is easy to solve and hard to optimize:\nHere are few condition which can be used to optimize the code:\n\nFor **Naive string matching** which involve construction of substring and comparison of those substring the one can reduce his number iteration by:\nHere str is the substring of s which can be repeated to form s (possible answer)\n\n1. Check whether it is possible to create n(*an integer*) substring of size =  str.length for which use the condition:\n    **if (s.length % str.length == 0)**\n2. Before making substring from s check whether the substrings first and last letter are same.\n\nBut these all things will optimize the code to much extent but the real optimization would to use better string matching or pattern matching algorithm:\n**Robin karp Algorithm**: which involve sort of hashing(*converting the string into number to reduce the comparison time*) and sliding window(* as while applying this approach one would be hashing every window of size str.length)\nBut the issue with this algo is its time complexity is $$O(mn)$$\nwhich is not good in term of optimization.\n\n**KMP algorithm**: This algo is little bit difficult to code and understand (I write about it this comment would become an article\nand no one like to read article)\nThe best part about this algo is its time complexity is $$O(m + n)$$.\n\n🚀 Next Level Coding: Now, I get it, this isn't a walk in the park. But trust me, the rewards are worth it. It's like leveling up in the coding universe.\n\nI know it is a bit difficult to implement but you would be able to do it."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "Just hardcoded this and beats 94% in runtime xD"
                    },
                    {
                        "username": "dan_cho",
                        "content": "I saw your solution, It\\'s really hard to even think about that hardcode solution... LOL"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "If you\\'re thinking about PRIME FACTORS and finding all divisors, STOP!\\n\\nKeep it Simple.\\nJust iterate from length `1 ... (N/2)` ( where N is the length of original string ) and check if the current iteration value `i` divides `N` completely i.e. `i % N == 0`, voila you got one of your divisors else continue to next iteration.\\nTime to check if a substring of this length ( starting at 0 ) is able to partition the entire string correctly or not.\\nIf yes, you got the answer, otherwise continue with next iteration."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I tried to check for factors/divisors of length. It should be O(nrootn). But its giving me TLE. \nHere's my code. Please tell me whats wrong..\n\n\n\nclass Solution {\npublic:\n    bool is_pattern(string &s, string &subs)\n    {\n        int n = s.length(), m = subs.length();\n        for(int i = m; i < n; i++)\n        {\n            if(s[i] != subs[i%m]) return false;\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\n        }\n        return true;\n    }\n\n    bool repeatedSubstringPattern(string s) {\n        int n = s.length();\n        if(n == 1) return false;\n        cout<<n<<endl;\n        bool allsame = true;\n        for(int i = 1; i < n; i++)\n        {\n            if(s[i] != s[i-1]) \n            {\n                allsame = false;\n                break;\n            }\n        }\n        if(allsame) return true;\n        for(int i = 2; i*i <= n; i++)\n        {\n            if((n%i) == 0)\n            {\n                int j = n/i;\n                string subs1 = s.substr(0,i);\n                string subs2 = s.substr(0,j);\n\n                // cout<<subs1<<\" \"<<subs2<<endl;\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\n            }\n        } \n        return false;\n    }\n};"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "nice explanation\\n"
                    }
                ]
            },
            {
                "id": 2023692,
                "content": [
                    {
                        "username": "koolkaps7",
                        "content": "return (str + str).find(str, 1) < str.size();"
                    },
                    {
                        "username": "adityaleetcode",
                        "content": "My code is failing for input \"bb\", but in the example \"aba\" shown as False!! In that case if you consider one character as substring string then \"aba\" also True."
                    },
                    {
                        "username": "dimitryku",
                        "content": "if substring is \"a\", than you can not make \"aba\", since you have not \"b\" in your substring. If substring is \"ab\" than you can not make \"aba\", since you can do \"abab\", \"ababab\" etc only. So it is False. \"bb\" can be made from \"b\", so it is True."
                    },
                    {
                        "username": "bhati25",
                        "content": "Just a tip use KMP algo. "
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/F1irIhD\"><img src=\"https://i.imgur.com/F1irIhD.jpg\" title=\"source: imgur.com\"  width=\"400px\"/></a>"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this question should be a medium... I feel like only the brute force method is easy/intuitive"
                    },
                    {
                        "username": "s3stan",
                        "content": "\\nOne joy on Monday morning - green on LeetCode"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Brute force solution: \\nUse a sliding window technique, try every window size of substring then move the window by the substring length."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This problem is easy to solve and hard to optimize:\nHere are few condition which can be used to optimize the code:\n\nFor **Naive string matching** which involve construction of substring and comparison of those substring the one can reduce his number iteration by:\nHere str is the substring of s which can be repeated to form s (possible answer)\n\n1. Check whether it is possible to create n(*an integer*) substring of size =  str.length for which use the condition:\n    **if (s.length % str.length == 0)**\n2. Before making substring from s check whether the substrings first and last letter are same.\n\nBut these all things will optimize the code to much extent but the real optimization would to use better string matching or pattern matching algorithm:\n**Robin karp Algorithm**: which involve sort of hashing(*converting the string into number to reduce the comparison time*) and sliding window(* as while applying this approach one would be hashing every window of size str.length)\nBut the issue with this algo is its time complexity is $$O(mn)$$\nwhich is not good in term of optimization.\n\n**KMP algorithm**: This algo is little bit difficult to code and understand (I write about it this comment would become an article\nand no one like to read article)\nThe best part about this algo is its time complexity is $$O(m + n)$$.\n\n🚀 Next Level Coding: Now, I get it, this isn't a walk in the park. But trust me, the rewards are worth it. It's like leveling up in the coding universe.\n\nI know it is a bit difficult to implement but you would be able to do it."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "Just hardcoded this and beats 94% in runtime xD"
                    },
                    {
                        "username": "dan_cho",
                        "content": "I saw your solution, It\\'s really hard to even think about that hardcode solution... LOL"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "If you\\'re thinking about PRIME FACTORS and finding all divisors, STOP!\\n\\nKeep it Simple.\\nJust iterate from length `1 ... (N/2)` ( where N is the length of original string ) and check if the current iteration value `i` divides `N` completely i.e. `i % N == 0`, voila you got one of your divisors else continue to next iteration.\\nTime to check if a substring of this length ( starting at 0 ) is able to partition the entire string correctly or not.\\nIf yes, you got the answer, otherwise continue with next iteration."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I tried to check for factors/divisors of length. It should be O(nrootn). But its giving me TLE. \nHere's my code. Please tell me whats wrong..\n\n\n\nclass Solution {\npublic:\n    bool is_pattern(string &s, string &subs)\n    {\n        int n = s.length(), m = subs.length();\n        for(int i = m; i < n; i++)\n        {\n            if(s[i] != subs[i%m]) return false;\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\n        }\n        return true;\n    }\n\n    bool repeatedSubstringPattern(string s) {\n        int n = s.length();\n        if(n == 1) return false;\n        cout<<n<<endl;\n        bool allsame = true;\n        for(int i = 1; i < n; i++)\n        {\n            if(s[i] != s[i-1]) \n            {\n                allsame = false;\n                break;\n            }\n        }\n        if(allsame) return true;\n        for(int i = 2; i*i <= n; i++)\n        {\n            if((n%i) == 0)\n            {\n                int j = n/i;\n                string subs1 = s.substr(0,i);\n                string subs2 = s.substr(0,j);\n\n                // cout<<subs1<<\" \"<<subs2<<endl;\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\n            }\n        } \n        return false;\n    }\n};"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "nice explanation\\n"
                    }
                ]
            },
            {
                "id": 2023479,
                "content": [
                    {
                        "username": "koolkaps7",
                        "content": "return (str + str).find(str, 1) < str.size();"
                    },
                    {
                        "username": "adityaleetcode",
                        "content": "My code is failing for input \"bb\", but in the example \"aba\" shown as False!! In that case if you consider one character as substring string then \"aba\" also True."
                    },
                    {
                        "username": "dimitryku",
                        "content": "if substring is \"a\", than you can not make \"aba\", since you have not \"b\" in your substring. If substring is \"ab\" than you can not make \"aba\", since you can do \"abab\", \"ababab\" etc only. So it is False. \"bb\" can be made from \"b\", so it is True."
                    },
                    {
                        "username": "bhati25",
                        "content": "Just a tip use KMP algo. "
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/F1irIhD\"><img src=\"https://i.imgur.com/F1irIhD.jpg\" title=\"source: imgur.com\"  width=\"400px\"/></a>"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this question should be a medium... I feel like only the brute force method is easy/intuitive"
                    },
                    {
                        "username": "s3stan",
                        "content": "\\nOne joy on Monday morning - green on LeetCode"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Brute force solution: \\nUse a sliding window technique, try every window size of substring then move the window by the substring length."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This problem is easy to solve and hard to optimize:\nHere are few condition which can be used to optimize the code:\n\nFor **Naive string matching** which involve construction of substring and comparison of those substring the one can reduce his number iteration by:\nHere str is the substring of s which can be repeated to form s (possible answer)\n\n1. Check whether it is possible to create n(*an integer*) substring of size =  str.length for which use the condition:\n    **if (s.length % str.length == 0)**\n2. Before making substring from s check whether the substrings first and last letter are same.\n\nBut these all things will optimize the code to much extent but the real optimization would to use better string matching or pattern matching algorithm:\n**Robin karp Algorithm**: which involve sort of hashing(*converting the string into number to reduce the comparison time*) and sliding window(* as while applying this approach one would be hashing every window of size str.length)\nBut the issue with this algo is its time complexity is $$O(mn)$$\nwhich is not good in term of optimization.\n\n**KMP algorithm**: This algo is little bit difficult to code and understand (I write about it this comment would become an article\nand no one like to read article)\nThe best part about this algo is its time complexity is $$O(m + n)$$.\n\n🚀 Next Level Coding: Now, I get it, this isn't a walk in the park. But trust me, the rewards are worth it. It's like leveling up in the coding universe.\n\nI know it is a bit difficult to implement but you would be able to do it."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "Just hardcoded this and beats 94% in runtime xD"
                    },
                    {
                        "username": "dan_cho",
                        "content": "I saw your solution, It\\'s really hard to even think about that hardcode solution... LOL"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "If you\\'re thinking about PRIME FACTORS and finding all divisors, STOP!\\n\\nKeep it Simple.\\nJust iterate from length `1 ... (N/2)` ( where N is the length of original string ) and check if the current iteration value `i` divides `N` completely i.e. `i % N == 0`, voila you got one of your divisors else continue to next iteration.\\nTime to check if a substring of this length ( starting at 0 ) is able to partition the entire string correctly or not.\\nIf yes, you got the answer, otherwise continue with next iteration."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I tried to check for factors/divisors of length. It should be O(nrootn). But its giving me TLE. \nHere's my code. Please tell me whats wrong..\n\n\n\nclass Solution {\npublic:\n    bool is_pattern(string &s, string &subs)\n    {\n        int n = s.length(), m = subs.length();\n        for(int i = m; i < n; i++)\n        {\n            if(s[i] != subs[i%m]) return false;\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\n        }\n        return true;\n    }\n\n    bool repeatedSubstringPattern(string s) {\n        int n = s.length();\n        if(n == 1) return false;\n        cout<<n<<endl;\n        bool allsame = true;\n        for(int i = 1; i < n; i++)\n        {\n            if(s[i] != s[i-1]) \n            {\n                allsame = false;\n                break;\n            }\n        }\n        if(allsame) return true;\n        for(int i = 2; i*i <= n; i++)\n        {\n            if((n%i) == 0)\n            {\n                int j = n/i;\n                string subs1 = s.substr(0,i);\n                string subs2 = s.substr(0,j);\n\n                // cout<<subs1<<\" \"<<subs2<<endl;\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\n            }\n        } \n        return false;\n    }\n};"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "nice explanation\\n"
                    }
                ]
            },
            {
                "id": 2023312,
                "content": [
                    {
                        "username": "yashy_",
                        "content": "finally an easy monday :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "heh, first easy after 41 days \\uD83D\\uDE0A"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why is \"a\" false?  "
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) This is an edge case, there is no substring smaller than the string itself."
                    },
                    {
                        "username": "sleep_404",
                        "content": "there are no copies of even a single character involved"
                    },
                    {
                        "username": "narekGev",
                        "content": "return (s + s).substr(1, s.size()*2 - 2).find(s) != string::npos;"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "hol\\' up\\nthis isnt easy"
                    },
                    {
                        "username": "user2134Fq",
                        "content": "\"abaababaab\"\\nHow does it contains a repeated substring pattern?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    },
                    {
                        "username": "madpoly",
                        "content": "surprised its marked as easy. Found it quite tricky but not undoable. Basically optimized it and only check if its divisible and return false if my substring is greater than 1/2 of source string which means you cant divide it into even parts."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I am getting a timelimit exeeded error on last testcase 129 and the intersting thing is the input is empty. can anyone tell me what to do?"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "just give this code   \n\n\nif not s : return False\n\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Impossible, all valid testcases have to be at least size 1."
                    },
                    {
                        "username": "Gracemann280",
                        "content": " `\\n\\ncheck if length generated substring divides length whole string \\nthen check if the that subtring can generate the string \\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n        n=len(s)\\n\\n        for length in range(1,n//2+1):\\n\\n            if n%length==0:\\n\\n\\n                if s[:length]*(n//length)==s:\\n                    return True\\n        return False\\n`"
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "check the start and the end of the string, if matches check the pattern. "
                    }
                ]
            },
            {
                "id": 2023311,
                "content": [
                    {
                        "username": "yashy_",
                        "content": "finally an easy monday :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "heh, first easy after 41 days \\uD83D\\uDE0A"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why is \"a\" false?  "
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) This is an edge case, there is no substring smaller than the string itself."
                    },
                    {
                        "username": "sleep_404",
                        "content": "there are no copies of even a single character involved"
                    },
                    {
                        "username": "narekGev",
                        "content": "return (s + s).substr(1, s.size()*2 - 2).find(s) != string::npos;"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "hol\\' up\\nthis isnt easy"
                    },
                    {
                        "username": "user2134Fq",
                        "content": "\"abaababaab\"\\nHow does it contains a repeated substring pattern?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    },
                    {
                        "username": "madpoly",
                        "content": "surprised its marked as easy. Found it quite tricky but not undoable. Basically optimized it and only check if its divisible and return false if my substring is greater than 1/2 of source string which means you cant divide it into even parts."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I am getting a timelimit exeeded error on last testcase 129 and the intersting thing is the input is empty. can anyone tell me what to do?"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "just give this code   \n\n\nif not s : return False\n\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Impossible, all valid testcases have to be at least size 1."
                    },
                    {
                        "username": "Gracemann280",
                        "content": " `\\n\\ncheck if length generated substring divides length whole string \\nthen check if the that subtring can generate the string \\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n        n=len(s)\\n\\n        for length in range(1,n//2+1):\\n\\n            if n%length==0:\\n\\n\\n                if s[:length]*(n//length)==s:\\n                    return True\\n        return False\\n`"
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "check the start and the end of the string, if matches check the pattern. "
                    }
                ]
            },
            {
                "id": 1950886,
                "content": [
                    {
                        "username": "yashy_",
                        "content": "finally an easy monday :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "heh, first easy after 41 days \\uD83D\\uDE0A"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why is \"a\" false?  "
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) This is an edge case, there is no substring smaller than the string itself."
                    },
                    {
                        "username": "sleep_404",
                        "content": "there are no copies of even a single character involved"
                    },
                    {
                        "username": "narekGev",
                        "content": "return (s + s).substr(1, s.size()*2 - 2).find(s) != string::npos;"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "hol\\' up\\nthis isnt easy"
                    },
                    {
                        "username": "user2134Fq",
                        "content": "\"abaababaab\"\\nHow does it contains a repeated substring pattern?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    },
                    {
                        "username": "madpoly",
                        "content": "surprised its marked as easy. Found it quite tricky but not undoable. Basically optimized it and only check if its divisible and return false if my substring is greater than 1/2 of source string which means you cant divide it into even parts."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I am getting a timelimit exeeded error on last testcase 129 and the intersting thing is the input is empty. can anyone tell me what to do?"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "just give this code   \n\n\nif not s : return False\n\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Impossible, all valid testcases have to be at least size 1."
                    },
                    {
                        "username": "Gracemann280",
                        "content": " `\\n\\ncheck if length generated substring divides length whole string \\nthen check if the that subtring can generate the string \\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n        n=len(s)\\n\\n        for length in range(1,n//2+1):\\n\\n            if n%length==0:\\n\\n\\n                if s[:length]*(n//length)==s:\\n                    return True\\n        return False\\n`"
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "check the start and the end of the string, if matches check the pattern. "
                    }
                ]
            },
            {
                "id": 1576628,
                "content": [
                    {
                        "username": "yashy_",
                        "content": "finally an easy monday :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "heh, first easy after 41 days \\uD83D\\uDE0A"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why is \"a\" false?  "
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) This is an edge case, there is no substring smaller than the string itself."
                    },
                    {
                        "username": "sleep_404",
                        "content": "there are no copies of even a single character involved"
                    },
                    {
                        "username": "narekGev",
                        "content": "return (s + s).substr(1, s.size()*2 - 2).find(s) != string::npos;"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "hol\\' up\\nthis isnt easy"
                    },
                    {
                        "username": "user2134Fq",
                        "content": "\"abaababaab\"\\nHow does it contains a repeated substring pattern?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    },
                    {
                        "username": "madpoly",
                        "content": "surprised its marked as easy. Found it quite tricky but not undoable. Basically optimized it and only check if its divisible and return false if my substring is greater than 1/2 of source string which means you cant divide it into even parts."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I am getting a timelimit exeeded error on last testcase 129 and the intersting thing is the input is empty. can anyone tell me what to do?"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "just give this code   \n\n\nif not s : return False\n\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Impossible, all valid testcases have to be at least size 1."
                    },
                    {
                        "username": "Gracemann280",
                        "content": " `\\n\\ncheck if length generated substring divides length whole string \\nthen check if the that subtring can generate the string \\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n        n=len(s)\\n\\n        for length in range(1,n//2+1):\\n\\n            if n%length==0:\\n\\n\\n                if s[:length]*(n//length)==s:\\n                    return True\\n        return False\\n`"
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "check the start and the end of the string, if matches check the pattern. "
                    }
                ]
            },
            {
                "id": 2023355,
                "content": [
                    {
                        "username": "yashy_",
                        "content": "finally an easy monday :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "heh, first easy after 41 days \\uD83D\\uDE0A"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why is \"a\" false?  "
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) This is an edge case, there is no substring smaller than the string itself."
                    },
                    {
                        "username": "sleep_404",
                        "content": "there are no copies of even a single character involved"
                    },
                    {
                        "username": "narekGev",
                        "content": "return (s + s).substr(1, s.size()*2 - 2).find(s) != string::npos;"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "hol\\' up\\nthis isnt easy"
                    },
                    {
                        "username": "user2134Fq",
                        "content": "\"abaababaab\"\\nHow does it contains a repeated substring pattern?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    },
                    {
                        "username": "madpoly",
                        "content": "surprised its marked as easy. Found it quite tricky but not undoable. Basically optimized it and only check if its divisible and return false if my substring is greater than 1/2 of source string which means you cant divide it into even parts."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I am getting a timelimit exeeded error on last testcase 129 and the intersting thing is the input is empty. can anyone tell me what to do?"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "just give this code   \n\n\nif not s : return False\n\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Impossible, all valid testcases have to be at least size 1."
                    },
                    {
                        "username": "Gracemann280",
                        "content": " `\\n\\ncheck if length generated substring divides length whole string \\nthen check if the that subtring can generate the string \\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n        n=len(s)\\n\\n        for length in range(1,n//2+1):\\n\\n            if n%length==0:\\n\\n\\n                if s[:length]*(n//length)==s:\\n                    return True\\n        return False\\n`"
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "check the start and the end of the string, if matches check the pattern. "
                    }
                ]
            },
            {
                "id": 2063615,
                "content": [
                    {
                        "username": "yashy_",
                        "content": "finally an easy monday :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "heh, first easy after 41 days \\uD83D\\uDE0A"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why is \"a\" false?  "
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) This is an edge case, there is no substring smaller than the string itself."
                    },
                    {
                        "username": "sleep_404",
                        "content": "there are no copies of even a single character involved"
                    },
                    {
                        "username": "narekGev",
                        "content": "return (s + s).substr(1, s.size()*2 - 2).find(s) != string::npos;"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "hol\\' up\\nthis isnt easy"
                    },
                    {
                        "username": "user2134Fq",
                        "content": "\"abaababaab\"\\nHow does it contains a repeated substring pattern?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    },
                    {
                        "username": "madpoly",
                        "content": "surprised its marked as easy. Found it quite tricky but not undoable. Basically optimized it and only check if its divisible and return false if my substring is greater than 1/2 of source string which means you cant divide it into even parts."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I am getting a timelimit exeeded error on last testcase 129 and the intersting thing is the input is empty. can anyone tell me what to do?"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "just give this code   \n\n\nif not s : return False\n\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Impossible, all valid testcases have to be at least size 1."
                    },
                    {
                        "username": "Gracemann280",
                        "content": " `\\n\\ncheck if length generated substring divides length whole string \\nthen check if the that subtring can generate the string \\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n        n=len(s)\\n\\n        for length in range(1,n//2+1):\\n\\n            if n%length==0:\\n\\n\\n                if s[:length]*(n//length)==s:\\n                    return True\\n        return False\\n`"
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "check the start and the end of the string, if matches check the pattern. "
                    }
                ]
            },
            {
                "id": 2061272,
                "content": [
                    {
                        "username": "yashy_",
                        "content": "finally an easy monday :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "heh, first easy after 41 days \\uD83D\\uDE0A"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why is \"a\" false?  "
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) This is an edge case, there is no substring smaller than the string itself."
                    },
                    {
                        "username": "sleep_404",
                        "content": "there are no copies of even a single character involved"
                    },
                    {
                        "username": "narekGev",
                        "content": "return (s + s).substr(1, s.size()*2 - 2).find(s) != string::npos;"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "hol\\' up\\nthis isnt easy"
                    },
                    {
                        "username": "user2134Fq",
                        "content": "\"abaababaab\"\\nHow does it contains a repeated substring pattern?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    },
                    {
                        "username": "madpoly",
                        "content": "surprised its marked as easy. Found it quite tricky but not undoable. Basically optimized it and only check if its divisible and return false if my substring is greater than 1/2 of source string which means you cant divide it into even parts."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I am getting a timelimit exeeded error on last testcase 129 and the intersting thing is the input is empty. can anyone tell me what to do?"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "just give this code   \n\n\nif not s : return False\n\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Impossible, all valid testcases have to be at least size 1."
                    },
                    {
                        "username": "Gracemann280",
                        "content": " `\\n\\ncheck if length generated substring divides length whole string \\nthen check if the that subtring can generate the string \\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n        n=len(s)\\n\\n        for length in range(1,n//2+1):\\n\\n            if n%length==0:\\n\\n\\n                if s[:length]*(n//length)==s:\\n                    return True\\n        return False\\n`"
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "check the start and the end of the string, if matches check the pattern. "
                    }
                ]
            },
            {
                "id": 2031711,
                "content": [
                    {
                        "username": "yashy_",
                        "content": "finally an easy monday :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "heh, first easy after 41 days \\uD83D\\uDE0A"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why is \"a\" false?  "
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) This is an edge case, there is no substring smaller than the string itself."
                    },
                    {
                        "username": "sleep_404",
                        "content": "there are no copies of even a single character involved"
                    },
                    {
                        "username": "narekGev",
                        "content": "return (s + s).substr(1, s.size()*2 - 2).find(s) != string::npos;"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "hol\\' up\\nthis isnt easy"
                    },
                    {
                        "username": "user2134Fq",
                        "content": "\"abaababaab\"\\nHow does it contains a repeated substring pattern?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    },
                    {
                        "username": "madpoly",
                        "content": "surprised its marked as easy. Found it quite tricky but not undoable. Basically optimized it and only check if its divisible and return false if my substring is greater than 1/2 of source string which means you cant divide it into even parts."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I am getting a timelimit exeeded error on last testcase 129 and the intersting thing is the input is empty. can anyone tell me what to do?"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "just give this code   \n\n\nif not s : return False\n\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Impossible, all valid testcases have to be at least size 1."
                    },
                    {
                        "username": "Gracemann280",
                        "content": " `\\n\\ncheck if length generated substring divides length whole string \\nthen check if the that subtring can generate the string \\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n        n=len(s)\\n\\n        for length in range(1,n//2+1):\\n\\n            if n%length==0:\\n\\n\\n                if s[:length]*(n//length)==s:\\n                    return True\\n        return False\\n`"
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "check the start and the end of the string, if matches check the pattern. "
                    }
                ]
            },
            {
                "id": 2031157,
                "content": [
                    {
                        "username": "yashy_",
                        "content": "finally an easy monday :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "heh, first easy after 41 days \\uD83D\\uDE0A"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why is \"a\" false?  "
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) This is an edge case, there is no substring smaller than the string itself."
                    },
                    {
                        "username": "sleep_404",
                        "content": "there are no copies of even a single character involved"
                    },
                    {
                        "username": "narekGev",
                        "content": "return (s + s).substr(1, s.size()*2 - 2).find(s) != string::npos;"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "hol\\' up\\nthis isnt easy"
                    },
                    {
                        "username": "user2134Fq",
                        "content": "\"abaababaab\"\\nHow does it contains a repeated substring pattern?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    },
                    {
                        "username": "madpoly",
                        "content": "surprised its marked as easy. Found it quite tricky but not undoable. Basically optimized it and only check if its divisible and return false if my substring is greater than 1/2 of source string which means you cant divide it into even parts."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I am getting a timelimit exeeded error on last testcase 129 and the intersting thing is the input is empty. can anyone tell me what to do?"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "just give this code   \n\n\nif not s : return False\n\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Impossible, all valid testcases have to be at least size 1."
                    },
                    {
                        "username": "Gracemann280",
                        "content": " `\\n\\ncheck if length generated substring divides length whole string \\nthen check if the that subtring can generate the string \\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n        n=len(s)\\n\\n        for length in range(1,n//2+1):\\n\\n            if n%length==0:\\n\\n\\n                if s[:length]*(n//length)==s:\\n                    return True\\n        return False\\n`"
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "check the start and the end of the string, if matches check the pattern. "
                    }
                ]
            },
            {
                "id": 2028132,
                "content": [
                    {
                        "username": "yashy_",
                        "content": "finally an easy monday :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "heh, first easy after 41 days \\uD83D\\uDE0A"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why is \"a\" false?  "
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) This is an edge case, there is no substring smaller than the string itself."
                    },
                    {
                        "username": "sleep_404",
                        "content": "there are no copies of even a single character involved"
                    },
                    {
                        "username": "narekGev",
                        "content": "return (s + s).substr(1, s.size()*2 - 2).find(s) != string::npos;"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "hol\\' up\\nthis isnt easy"
                    },
                    {
                        "username": "user2134Fq",
                        "content": "\"abaababaab\"\\nHow does it contains a repeated substring pattern?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    },
                    {
                        "username": "madpoly",
                        "content": "surprised its marked as easy. Found it quite tricky but not undoable. Basically optimized it and only check if its divisible and return false if my substring is greater than 1/2 of source string which means you cant divide it into even parts."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I am getting a timelimit exeeded error on last testcase 129 and the intersting thing is the input is empty. can anyone tell me what to do?"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "just give this code   \n\n\nif not s : return False\n\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Impossible, all valid testcases have to be at least size 1."
                    },
                    {
                        "username": "Gracemann280",
                        "content": " `\\n\\ncheck if length generated substring divides length whole string \\nthen check if the that subtring can generate the string \\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n        n=len(s)\\n\\n        for length in range(1,n//2+1):\\n\\n            if n%length==0:\\n\\n\\n                if s[:length]*(n//length)==s:\\n                    return True\\n        return False\\n`"
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "check the start and the end of the string, if matches check the pattern. "
                    }
                ]
            },
            {
                "id": 2027154,
                "content": [
                    {
                        "username": "user5154h",
                        "content": "why does \\'ababba\\' retuns false ?\\n\\nit has 2 ab so it should return true"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "no. You have to make the original string by concatenating a substring that is present in the original string.\\nhere ababba is the original string. if we consider ab as a substring, even if we concatenate ab 3 times it still can\\'t make the original string again. thus answer becomes false.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "s3stan",
                        "content": "We cannot make ab ba. Now, if there was ababab, then yes, it should have been true here.\\nIf it is possible to get the full string from the substring then it will be true."
                    },
                    {
                        "username": "DimSonikku",
                        "content": "Why does testcase 129 give time limit exceeded?\nEdit: it passed testcase 129(although the codes perfomance is poor) after i removed the while loop and added a check \nif s.Length % substring.Length == 0, so that it would skip some useless iterations\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub, res;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            res = \"\";\n            sub = s.Substring(0, i+1);\n            while(res.Length < s.Length) \n                res += sub;\n            if (res == s)\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            if (s.Length%s.Substring(0, i+1).Length == 0)\n            {\n            sub = s.Substring(0, i+1);\n            sub = String.Concat(Enumerable.Repeat(sub, s.Length/sub.Length));\n            if (sub == s)\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) thank you for the help, i will try to do something about this"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "It might be giving Time limit Exceeded error because your logic is running 0(n^2) times"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) tried checking if its null, still gives time limit exceeded"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Cant paste it, because cant copy it, its nothing. It says: \"s =\" and i cant copy what comes after \"=\", even using the copy button that is next to this testcase."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@DimSonikku](/DimSonikku) what\\'s the testcase 129 paste it here\\n"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Yes, this code passes every other testcase, except for 129"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "testcase 129?\\n\\n"
                    },
                    {
                        "username": "dipak2000",
                        "content": "Can we do This question using LPS(longest prefix suffix) method which is used in KMP algorithm?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, it\\'s possible give it a go"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "Pleasse someone tell why i got tle \\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> factorize(int n){\\n        unordered_map<int, int>mp;\\n        for(int i=1; i*i<=n; i++){\\n            if(n%i == 0){\\n                mp[i] = 1;\\n                mp[n/i] = 1;  \\n            }\\n        }\\n        return mp;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        if(s == \"\"){\\n            return false;\\n        }\\n        int n = s.length(), i, j;\\n        \\n        if(n == 1)return false;\\n        vector<int>f(26, 0);\\n        for(i=0; i<n; i++){\\n            f[s[i] - \\'a\\'] ++;\\n        }\\n        for(i=0; i<n; i++){\\n            if(f[s[i] - \\'a\\'] == 1) return false;\\n        }\\n        //unordered_map<int, int>mp = factorize(n);\\n        string temp = \"\";\\n        for(i=0; i<n/2; i++){\\n            temp.push_back(s[i]);\\n            if(n%(i+1) == 0){\\n                //cout<<i<<\" \";\\n                string check = \"\";\\n                for(j=0; j<n/(i+1); j++){\\n                    check = check + temp;\\n                }\\n                 //out<<temp<<\" \"<<check<<endl;\\n                if(s == check){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "[@mstuebs](/mstuebs) still same result\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "You are looping through each char individually. To speed up, consider using the built-in C++ string comparison functions. "
                    },
                    {
                        "username": "SG-C",
                        "content": "this should be labeled medium "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "it is easy if you know kmp, first check its prefixing algorithm\\nyou will like this problem"
                    },
                    {
                        "username": "Emily50",
                        "content": "Why O(n^2) solution makes TLE?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "In complexity analysis, \"10^7\" (10 million) is used as a reference to estimate the efficiency of algorithms based on input size .In the question constraints are given as 10^4  so if you use 0(n^2) complexity that will be (10^4)*2 that will lead to TLE.\\n\\nYou have to find 0(NlogN) , 0(N), solution\\nIn this problem It will also Accept 0(N*sqrt(N)) solution\\n\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What\\'s your thought process with your solution?"
                    },
                    {
                        "username": "BIPIN21CSB0B09",
                        "content": "how to approach this problem?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "String rotation or dynamic programming. Either will get you there regardless of time complexity"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Why is my O(n^2) solution giving me TLE\n\n` function repeatedSubstringPattern(s: string): boolean {`\n   \n   ` let subString=\"\";`\n \n` for(let i=0;i<s.length;i++){`\n`    subString+=s.charAt(i);`\n   ` if(checkValidity(subString,s)){`\n      ` return true`\n `   }`\n` }`\n\n`return false;`\n\n};\n\n\n`function checkValidity(subStr:string,s:string){`\n`   if(subStr.length==s.length){`\n`      return false;`\n`   }`\n`  const n=s.length;`\n`  let resultLength=n;`\n`  let subString=\"\"`\n`  for(let i=0;i<s.length;i++){`\n   `  subString+=s.charAt(i);`\n    ` if(subString===subStr){`\n        `resultLength-=subStr.length;`\n      `  subString=\"\";`\n    ` }`\n ` }`\n ` return resultLength==0;`\n\n`}`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use 3 backticks to format your code better:\\n\\nyou can use slice to get a subString in one go, instead of doing it per char. and you can add the whole subString to itself rather than per char, thats a lot faster. \\n\\nAlso you can think about what it means if you can build s from copies of subString. Can you do a quick check beforehand based on the length, so that you only have to check a fraction of all the posibillities? \\n"
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone please explain why s=\"abaababaab\" expects output to be True? (testcase 78)"
                    },
                    {
                        "username": "ramanchik",
                        "content": "\"abaab\" + \"abaab\" "
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone explain in testcase 78/129\\ns=\"abaababaab\", why is the expected answer True?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    }
                ]
            },
            {
                "id": 2025212,
                "content": [
                    {
                        "username": "user5154h",
                        "content": "why does \\'ababba\\' retuns false ?\\n\\nit has 2 ab so it should return true"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "no. You have to make the original string by concatenating a substring that is present in the original string.\\nhere ababba is the original string. if we consider ab as a substring, even if we concatenate ab 3 times it still can\\'t make the original string again. thus answer becomes false.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "s3stan",
                        "content": "We cannot make ab ba. Now, if there was ababab, then yes, it should have been true here.\\nIf it is possible to get the full string from the substring then it will be true."
                    },
                    {
                        "username": "DimSonikku",
                        "content": "Why does testcase 129 give time limit exceeded?\nEdit: it passed testcase 129(although the codes perfomance is poor) after i removed the while loop and added a check \nif s.Length % substring.Length == 0, so that it would skip some useless iterations\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub, res;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            res = \"\";\n            sub = s.Substring(0, i+1);\n            while(res.Length < s.Length) \n                res += sub;\n            if (res == s)\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            if (s.Length%s.Substring(0, i+1).Length == 0)\n            {\n            sub = s.Substring(0, i+1);\n            sub = String.Concat(Enumerable.Repeat(sub, s.Length/sub.Length));\n            if (sub == s)\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) thank you for the help, i will try to do something about this"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "It might be giving Time limit Exceeded error because your logic is running 0(n^2) times"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) tried checking if its null, still gives time limit exceeded"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Cant paste it, because cant copy it, its nothing. It says: \"s =\" and i cant copy what comes after \"=\", even using the copy button that is next to this testcase."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@DimSonikku](/DimSonikku) what\\'s the testcase 129 paste it here\\n"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Yes, this code passes every other testcase, except for 129"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "testcase 129?\\n\\n"
                    },
                    {
                        "username": "dipak2000",
                        "content": "Can we do This question using LPS(longest prefix suffix) method which is used in KMP algorithm?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, it\\'s possible give it a go"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "Pleasse someone tell why i got tle \\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> factorize(int n){\\n        unordered_map<int, int>mp;\\n        for(int i=1; i*i<=n; i++){\\n            if(n%i == 0){\\n                mp[i] = 1;\\n                mp[n/i] = 1;  \\n            }\\n        }\\n        return mp;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        if(s == \"\"){\\n            return false;\\n        }\\n        int n = s.length(), i, j;\\n        \\n        if(n == 1)return false;\\n        vector<int>f(26, 0);\\n        for(i=0; i<n; i++){\\n            f[s[i] - \\'a\\'] ++;\\n        }\\n        for(i=0; i<n; i++){\\n            if(f[s[i] - \\'a\\'] == 1) return false;\\n        }\\n        //unordered_map<int, int>mp = factorize(n);\\n        string temp = \"\";\\n        for(i=0; i<n/2; i++){\\n            temp.push_back(s[i]);\\n            if(n%(i+1) == 0){\\n                //cout<<i<<\" \";\\n                string check = \"\";\\n                for(j=0; j<n/(i+1); j++){\\n                    check = check + temp;\\n                }\\n                 //out<<temp<<\" \"<<check<<endl;\\n                if(s == check){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "[@mstuebs](/mstuebs) still same result\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "You are looping through each char individually. To speed up, consider using the built-in C++ string comparison functions. "
                    },
                    {
                        "username": "SG-C",
                        "content": "this should be labeled medium "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "it is easy if you know kmp, first check its prefixing algorithm\\nyou will like this problem"
                    },
                    {
                        "username": "Emily50",
                        "content": "Why O(n^2) solution makes TLE?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "In complexity analysis, \"10^7\" (10 million) is used as a reference to estimate the efficiency of algorithms based on input size .In the question constraints are given as 10^4  so if you use 0(n^2) complexity that will be (10^4)*2 that will lead to TLE.\\n\\nYou have to find 0(NlogN) , 0(N), solution\\nIn this problem It will also Accept 0(N*sqrt(N)) solution\\n\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What\\'s your thought process with your solution?"
                    },
                    {
                        "username": "BIPIN21CSB0B09",
                        "content": "how to approach this problem?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "String rotation or dynamic programming. Either will get you there regardless of time complexity"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Why is my O(n^2) solution giving me TLE\n\n` function repeatedSubstringPattern(s: string): boolean {`\n   \n   ` let subString=\"\";`\n \n` for(let i=0;i<s.length;i++){`\n`    subString+=s.charAt(i);`\n   ` if(checkValidity(subString,s)){`\n      ` return true`\n `   }`\n` }`\n\n`return false;`\n\n};\n\n\n`function checkValidity(subStr:string,s:string){`\n`   if(subStr.length==s.length){`\n`      return false;`\n`   }`\n`  const n=s.length;`\n`  let resultLength=n;`\n`  let subString=\"\"`\n`  for(let i=0;i<s.length;i++){`\n   `  subString+=s.charAt(i);`\n    ` if(subString===subStr){`\n        `resultLength-=subStr.length;`\n      `  subString=\"\";`\n    ` }`\n ` }`\n ` return resultLength==0;`\n\n`}`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use 3 backticks to format your code better:\\n\\nyou can use slice to get a subString in one go, instead of doing it per char. and you can add the whole subString to itself rather than per char, thats a lot faster. \\n\\nAlso you can think about what it means if you can build s from copies of subString. Can you do a quick check beforehand based on the length, so that you only have to check a fraction of all the posibillities? \\n"
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone please explain why s=\"abaababaab\" expects output to be True? (testcase 78)"
                    },
                    {
                        "username": "ramanchik",
                        "content": "\"abaab\" + \"abaab\" "
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone explain in testcase 78/129\\ns=\"abaababaab\", why is the expected answer True?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    }
                ]
            },
            {
                "id": 2024590,
                "content": [
                    {
                        "username": "user5154h",
                        "content": "why does \\'ababba\\' retuns false ?\\n\\nit has 2 ab so it should return true"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "no. You have to make the original string by concatenating a substring that is present in the original string.\\nhere ababba is the original string. if we consider ab as a substring, even if we concatenate ab 3 times it still can\\'t make the original string again. thus answer becomes false.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "s3stan",
                        "content": "We cannot make ab ba. Now, if there was ababab, then yes, it should have been true here.\\nIf it is possible to get the full string from the substring then it will be true."
                    },
                    {
                        "username": "DimSonikku",
                        "content": "Why does testcase 129 give time limit exceeded?\nEdit: it passed testcase 129(although the codes perfomance is poor) after i removed the while loop and added a check \nif s.Length % substring.Length == 0, so that it would skip some useless iterations\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub, res;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            res = \"\";\n            sub = s.Substring(0, i+1);\n            while(res.Length < s.Length) \n                res += sub;\n            if (res == s)\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            if (s.Length%s.Substring(0, i+1).Length == 0)\n            {\n            sub = s.Substring(0, i+1);\n            sub = String.Concat(Enumerable.Repeat(sub, s.Length/sub.Length));\n            if (sub == s)\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) thank you for the help, i will try to do something about this"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "It might be giving Time limit Exceeded error because your logic is running 0(n^2) times"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) tried checking if its null, still gives time limit exceeded"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Cant paste it, because cant copy it, its nothing. It says: \"s =\" and i cant copy what comes after \"=\", even using the copy button that is next to this testcase."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@DimSonikku](/DimSonikku) what\\'s the testcase 129 paste it here\\n"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Yes, this code passes every other testcase, except for 129"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "testcase 129?\\n\\n"
                    },
                    {
                        "username": "dipak2000",
                        "content": "Can we do This question using LPS(longest prefix suffix) method which is used in KMP algorithm?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, it\\'s possible give it a go"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "Pleasse someone tell why i got tle \\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> factorize(int n){\\n        unordered_map<int, int>mp;\\n        for(int i=1; i*i<=n; i++){\\n            if(n%i == 0){\\n                mp[i] = 1;\\n                mp[n/i] = 1;  \\n            }\\n        }\\n        return mp;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        if(s == \"\"){\\n            return false;\\n        }\\n        int n = s.length(), i, j;\\n        \\n        if(n == 1)return false;\\n        vector<int>f(26, 0);\\n        for(i=0; i<n; i++){\\n            f[s[i] - \\'a\\'] ++;\\n        }\\n        for(i=0; i<n; i++){\\n            if(f[s[i] - \\'a\\'] == 1) return false;\\n        }\\n        //unordered_map<int, int>mp = factorize(n);\\n        string temp = \"\";\\n        for(i=0; i<n/2; i++){\\n            temp.push_back(s[i]);\\n            if(n%(i+1) == 0){\\n                //cout<<i<<\" \";\\n                string check = \"\";\\n                for(j=0; j<n/(i+1); j++){\\n                    check = check + temp;\\n                }\\n                 //out<<temp<<\" \"<<check<<endl;\\n                if(s == check){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "[@mstuebs](/mstuebs) still same result\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "You are looping through each char individually. To speed up, consider using the built-in C++ string comparison functions. "
                    },
                    {
                        "username": "SG-C",
                        "content": "this should be labeled medium "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "it is easy if you know kmp, first check its prefixing algorithm\\nyou will like this problem"
                    },
                    {
                        "username": "Emily50",
                        "content": "Why O(n^2) solution makes TLE?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "In complexity analysis, \"10^7\" (10 million) is used as a reference to estimate the efficiency of algorithms based on input size .In the question constraints are given as 10^4  so if you use 0(n^2) complexity that will be (10^4)*2 that will lead to TLE.\\n\\nYou have to find 0(NlogN) , 0(N), solution\\nIn this problem It will also Accept 0(N*sqrt(N)) solution\\n\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What\\'s your thought process with your solution?"
                    },
                    {
                        "username": "BIPIN21CSB0B09",
                        "content": "how to approach this problem?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "String rotation or dynamic programming. Either will get you there regardless of time complexity"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Why is my O(n^2) solution giving me TLE\n\n` function repeatedSubstringPattern(s: string): boolean {`\n   \n   ` let subString=\"\";`\n \n` for(let i=0;i<s.length;i++){`\n`    subString+=s.charAt(i);`\n   ` if(checkValidity(subString,s)){`\n      ` return true`\n `   }`\n` }`\n\n`return false;`\n\n};\n\n\n`function checkValidity(subStr:string,s:string){`\n`   if(subStr.length==s.length){`\n`      return false;`\n`   }`\n`  const n=s.length;`\n`  let resultLength=n;`\n`  let subString=\"\"`\n`  for(let i=0;i<s.length;i++){`\n   `  subString+=s.charAt(i);`\n    ` if(subString===subStr){`\n        `resultLength-=subStr.length;`\n      `  subString=\"\";`\n    ` }`\n ` }`\n ` return resultLength==0;`\n\n`}`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use 3 backticks to format your code better:\\n\\nyou can use slice to get a subString in one go, instead of doing it per char. and you can add the whole subString to itself rather than per char, thats a lot faster. \\n\\nAlso you can think about what it means if you can build s from copies of subString. Can you do a quick check beforehand based on the length, so that you only have to check a fraction of all the posibillities? \\n"
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone please explain why s=\"abaababaab\" expects output to be True? (testcase 78)"
                    },
                    {
                        "username": "ramanchik",
                        "content": "\"abaab\" + \"abaab\" "
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone explain in testcase 78/129\\ns=\"abaababaab\", why is the expected answer True?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    }
                ]
            },
            {
                "id": 2024573,
                "content": [
                    {
                        "username": "user5154h",
                        "content": "why does \\'ababba\\' retuns false ?\\n\\nit has 2 ab so it should return true"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "no. You have to make the original string by concatenating a substring that is present in the original string.\\nhere ababba is the original string. if we consider ab as a substring, even if we concatenate ab 3 times it still can\\'t make the original string again. thus answer becomes false.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "s3stan",
                        "content": "We cannot make ab ba. Now, if there was ababab, then yes, it should have been true here.\\nIf it is possible to get the full string from the substring then it will be true."
                    },
                    {
                        "username": "DimSonikku",
                        "content": "Why does testcase 129 give time limit exceeded?\nEdit: it passed testcase 129(although the codes perfomance is poor) after i removed the while loop and added a check \nif s.Length % substring.Length == 0, so that it would skip some useless iterations\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub, res;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            res = \"\";\n            sub = s.Substring(0, i+1);\n            while(res.Length < s.Length) \n                res += sub;\n            if (res == s)\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            if (s.Length%s.Substring(0, i+1).Length == 0)\n            {\n            sub = s.Substring(0, i+1);\n            sub = String.Concat(Enumerable.Repeat(sub, s.Length/sub.Length));\n            if (sub == s)\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) thank you for the help, i will try to do something about this"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "It might be giving Time limit Exceeded error because your logic is running 0(n^2) times"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) tried checking if its null, still gives time limit exceeded"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Cant paste it, because cant copy it, its nothing. It says: \"s =\" and i cant copy what comes after \"=\", even using the copy button that is next to this testcase."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@DimSonikku](/DimSonikku) what\\'s the testcase 129 paste it here\\n"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Yes, this code passes every other testcase, except for 129"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "testcase 129?\\n\\n"
                    },
                    {
                        "username": "dipak2000",
                        "content": "Can we do This question using LPS(longest prefix suffix) method which is used in KMP algorithm?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, it\\'s possible give it a go"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "Pleasse someone tell why i got tle \\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> factorize(int n){\\n        unordered_map<int, int>mp;\\n        for(int i=1; i*i<=n; i++){\\n            if(n%i == 0){\\n                mp[i] = 1;\\n                mp[n/i] = 1;  \\n            }\\n        }\\n        return mp;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        if(s == \"\"){\\n            return false;\\n        }\\n        int n = s.length(), i, j;\\n        \\n        if(n == 1)return false;\\n        vector<int>f(26, 0);\\n        for(i=0; i<n; i++){\\n            f[s[i] - \\'a\\'] ++;\\n        }\\n        for(i=0; i<n; i++){\\n            if(f[s[i] - \\'a\\'] == 1) return false;\\n        }\\n        //unordered_map<int, int>mp = factorize(n);\\n        string temp = \"\";\\n        for(i=0; i<n/2; i++){\\n            temp.push_back(s[i]);\\n            if(n%(i+1) == 0){\\n                //cout<<i<<\" \";\\n                string check = \"\";\\n                for(j=0; j<n/(i+1); j++){\\n                    check = check + temp;\\n                }\\n                 //out<<temp<<\" \"<<check<<endl;\\n                if(s == check){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "[@mstuebs](/mstuebs) still same result\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "You are looping through each char individually. To speed up, consider using the built-in C++ string comparison functions. "
                    },
                    {
                        "username": "SG-C",
                        "content": "this should be labeled medium "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "it is easy if you know kmp, first check its prefixing algorithm\\nyou will like this problem"
                    },
                    {
                        "username": "Emily50",
                        "content": "Why O(n^2) solution makes TLE?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "In complexity analysis, \"10^7\" (10 million) is used as a reference to estimate the efficiency of algorithms based on input size .In the question constraints are given as 10^4  so if you use 0(n^2) complexity that will be (10^4)*2 that will lead to TLE.\\n\\nYou have to find 0(NlogN) , 0(N), solution\\nIn this problem It will also Accept 0(N*sqrt(N)) solution\\n\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What\\'s your thought process with your solution?"
                    },
                    {
                        "username": "BIPIN21CSB0B09",
                        "content": "how to approach this problem?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "String rotation or dynamic programming. Either will get you there regardless of time complexity"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Why is my O(n^2) solution giving me TLE\n\n` function repeatedSubstringPattern(s: string): boolean {`\n   \n   ` let subString=\"\";`\n \n` for(let i=0;i<s.length;i++){`\n`    subString+=s.charAt(i);`\n   ` if(checkValidity(subString,s)){`\n      ` return true`\n `   }`\n` }`\n\n`return false;`\n\n};\n\n\n`function checkValidity(subStr:string,s:string){`\n`   if(subStr.length==s.length){`\n`      return false;`\n`   }`\n`  const n=s.length;`\n`  let resultLength=n;`\n`  let subString=\"\"`\n`  for(let i=0;i<s.length;i++){`\n   `  subString+=s.charAt(i);`\n    ` if(subString===subStr){`\n        `resultLength-=subStr.length;`\n      `  subString=\"\";`\n    ` }`\n ` }`\n ` return resultLength==0;`\n\n`}`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use 3 backticks to format your code better:\\n\\nyou can use slice to get a subString in one go, instead of doing it per char. and you can add the whole subString to itself rather than per char, thats a lot faster. \\n\\nAlso you can think about what it means if you can build s from copies of subString. Can you do a quick check beforehand based on the length, so that you only have to check a fraction of all the posibillities? \\n"
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone please explain why s=\"abaababaab\" expects output to be True? (testcase 78)"
                    },
                    {
                        "username": "ramanchik",
                        "content": "\"abaab\" + \"abaab\" "
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone explain in testcase 78/129\\ns=\"abaababaab\", why is the expected answer True?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    }
                ]
            },
            {
                "id": 2024494,
                "content": [
                    {
                        "username": "user5154h",
                        "content": "why does \\'ababba\\' retuns false ?\\n\\nit has 2 ab so it should return true"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "no. You have to make the original string by concatenating a substring that is present in the original string.\\nhere ababba is the original string. if we consider ab as a substring, even if we concatenate ab 3 times it still can\\'t make the original string again. thus answer becomes false.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "s3stan",
                        "content": "We cannot make ab ba. Now, if there was ababab, then yes, it should have been true here.\\nIf it is possible to get the full string from the substring then it will be true."
                    },
                    {
                        "username": "DimSonikku",
                        "content": "Why does testcase 129 give time limit exceeded?\nEdit: it passed testcase 129(although the codes perfomance is poor) after i removed the while loop and added a check \nif s.Length % substring.Length == 0, so that it would skip some useless iterations\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub, res;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            res = \"\";\n            sub = s.Substring(0, i+1);\n            while(res.Length < s.Length) \n                res += sub;\n            if (res == s)\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            if (s.Length%s.Substring(0, i+1).Length == 0)\n            {\n            sub = s.Substring(0, i+1);\n            sub = String.Concat(Enumerable.Repeat(sub, s.Length/sub.Length));\n            if (sub == s)\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) thank you for the help, i will try to do something about this"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "It might be giving Time limit Exceeded error because your logic is running 0(n^2) times"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) tried checking if its null, still gives time limit exceeded"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Cant paste it, because cant copy it, its nothing. It says: \"s =\" and i cant copy what comes after \"=\", even using the copy button that is next to this testcase."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@DimSonikku](/DimSonikku) what\\'s the testcase 129 paste it here\\n"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Yes, this code passes every other testcase, except for 129"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "testcase 129?\\n\\n"
                    },
                    {
                        "username": "dipak2000",
                        "content": "Can we do This question using LPS(longest prefix suffix) method which is used in KMP algorithm?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, it\\'s possible give it a go"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "Pleasse someone tell why i got tle \\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> factorize(int n){\\n        unordered_map<int, int>mp;\\n        for(int i=1; i*i<=n; i++){\\n            if(n%i == 0){\\n                mp[i] = 1;\\n                mp[n/i] = 1;  \\n            }\\n        }\\n        return mp;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        if(s == \"\"){\\n            return false;\\n        }\\n        int n = s.length(), i, j;\\n        \\n        if(n == 1)return false;\\n        vector<int>f(26, 0);\\n        for(i=0; i<n; i++){\\n            f[s[i] - \\'a\\'] ++;\\n        }\\n        for(i=0; i<n; i++){\\n            if(f[s[i] - \\'a\\'] == 1) return false;\\n        }\\n        //unordered_map<int, int>mp = factorize(n);\\n        string temp = \"\";\\n        for(i=0; i<n/2; i++){\\n            temp.push_back(s[i]);\\n            if(n%(i+1) == 0){\\n                //cout<<i<<\" \";\\n                string check = \"\";\\n                for(j=0; j<n/(i+1); j++){\\n                    check = check + temp;\\n                }\\n                 //out<<temp<<\" \"<<check<<endl;\\n                if(s == check){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "[@mstuebs](/mstuebs) still same result\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "You are looping through each char individually. To speed up, consider using the built-in C++ string comparison functions. "
                    },
                    {
                        "username": "SG-C",
                        "content": "this should be labeled medium "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "it is easy if you know kmp, first check its prefixing algorithm\\nyou will like this problem"
                    },
                    {
                        "username": "Emily50",
                        "content": "Why O(n^2) solution makes TLE?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "In complexity analysis, \"10^7\" (10 million) is used as a reference to estimate the efficiency of algorithms based on input size .In the question constraints are given as 10^4  so if you use 0(n^2) complexity that will be (10^4)*2 that will lead to TLE.\\n\\nYou have to find 0(NlogN) , 0(N), solution\\nIn this problem It will also Accept 0(N*sqrt(N)) solution\\n\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What\\'s your thought process with your solution?"
                    },
                    {
                        "username": "BIPIN21CSB0B09",
                        "content": "how to approach this problem?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "String rotation or dynamic programming. Either will get you there regardless of time complexity"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Why is my O(n^2) solution giving me TLE\n\n` function repeatedSubstringPattern(s: string): boolean {`\n   \n   ` let subString=\"\";`\n \n` for(let i=0;i<s.length;i++){`\n`    subString+=s.charAt(i);`\n   ` if(checkValidity(subString,s)){`\n      ` return true`\n `   }`\n` }`\n\n`return false;`\n\n};\n\n\n`function checkValidity(subStr:string,s:string){`\n`   if(subStr.length==s.length){`\n`      return false;`\n`   }`\n`  const n=s.length;`\n`  let resultLength=n;`\n`  let subString=\"\"`\n`  for(let i=0;i<s.length;i++){`\n   `  subString+=s.charAt(i);`\n    ` if(subString===subStr){`\n        `resultLength-=subStr.length;`\n      `  subString=\"\";`\n    ` }`\n ` }`\n ` return resultLength==0;`\n\n`}`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use 3 backticks to format your code better:\\n\\nyou can use slice to get a subString in one go, instead of doing it per char. and you can add the whole subString to itself rather than per char, thats a lot faster. \\n\\nAlso you can think about what it means if you can build s from copies of subString. Can you do a quick check beforehand based on the length, so that you only have to check a fraction of all the posibillities? \\n"
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone please explain why s=\"abaababaab\" expects output to be True? (testcase 78)"
                    },
                    {
                        "username": "ramanchik",
                        "content": "\"abaab\" + \"abaab\" "
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone explain in testcase 78/129\\ns=\"abaababaab\", why is the expected answer True?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    }
                ]
            },
            {
                "id": 2024390,
                "content": [
                    {
                        "username": "user5154h",
                        "content": "why does \\'ababba\\' retuns false ?\\n\\nit has 2 ab so it should return true"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "no. You have to make the original string by concatenating a substring that is present in the original string.\\nhere ababba is the original string. if we consider ab as a substring, even if we concatenate ab 3 times it still can\\'t make the original string again. thus answer becomes false.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "s3stan",
                        "content": "We cannot make ab ba. Now, if there was ababab, then yes, it should have been true here.\\nIf it is possible to get the full string from the substring then it will be true."
                    },
                    {
                        "username": "DimSonikku",
                        "content": "Why does testcase 129 give time limit exceeded?\nEdit: it passed testcase 129(although the codes perfomance is poor) after i removed the while loop and added a check \nif s.Length % substring.Length == 0, so that it would skip some useless iterations\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub, res;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            res = \"\";\n            sub = s.Substring(0, i+1);\n            while(res.Length < s.Length) \n                res += sub;\n            if (res == s)\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            if (s.Length%s.Substring(0, i+1).Length == 0)\n            {\n            sub = s.Substring(0, i+1);\n            sub = String.Concat(Enumerable.Repeat(sub, s.Length/sub.Length));\n            if (sub == s)\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) thank you for the help, i will try to do something about this"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "It might be giving Time limit Exceeded error because your logic is running 0(n^2) times"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) tried checking if its null, still gives time limit exceeded"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Cant paste it, because cant copy it, its nothing. It says: \"s =\" and i cant copy what comes after \"=\", even using the copy button that is next to this testcase."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@DimSonikku](/DimSonikku) what\\'s the testcase 129 paste it here\\n"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Yes, this code passes every other testcase, except for 129"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "testcase 129?\\n\\n"
                    },
                    {
                        "username": "dipak2000",
                        "content": "Can we do This question using LPS(longest prefix suffix) method which is used in KMP algorithm?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, it\\'s possible give it a go"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "Pleasse someone tell why i got tle \\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> factorize(int n){\\n        unordered_map<int, int>mp;\\n        for(int i=1; i*i<=n; i++){\\n            if(n%i == 0){\\n                mp[i] = 1;\\n                mp[n/i] = 1;  \\n            }\\n        }\\n        return mp;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        if(s == \"\"){\\n            return false;\\n        }\\n        int n = s.length(), i, j;\\n        \\n        if(n == 1)return false;\\n        vector<int>f(26, 0);\\n        for(i=0; i<n; i++){\\n            f[s[i] - \\'a\\'] ++;\\n        }\\n        for(i=0; i<n; i++){\\n            if(f[s[i] - \\'a\\'] == 1) return false;\\n        }\\n        //unordered_map<int, int>mp = factorize(n);\\n        string temp = \"\";\\n        for(i=0; i<n/2; i++){\\n            temp.push_back(s[i]);\\n            if(n%(i+1) == 0){\\n                //cout<<i<<\" \";\\n                string check = \"\";\\n                for(j=0; j<n/(i+1); j++){\\n                    check = check + temp;\\n                }\\n                 //out<<temp<<\" \"<<check<<endl;\\n                if(s == check){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "[@mstuebs](/mstuebs) still same result\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "You are looping through each char individually. To speed up, consider using the built-in C++ string comparison functions. "
                    },
                    {
                        "username": "SG-C",
                        "content": "this should be labeled medium "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "it is easy if you know kmp, first check its prefixing algorithm\\nyou will like this problem"
                    },
                    {
                        "username": "Emily50",
                        "content": "Why O(n^2) solution makes TLE?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "In complexity analysis, \"10^7\" (10 million) is used as a reference to estimate the efficiency of algorithms based on input size .In the question constraints are given as 10^4  so if you use 0(n^2) complexity that will be (10^4)*2 that will lead to TLE.\\n\\nYou have to find 0(NlogN) , 0(N), solution\\nIn this problem It will also Accept 0(N*sqrt(N)) solution\\n\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What\\'s your thought process with your solution?"
                    },
                    {
                        "username": "BIPIN21CSB0B09",
                        "content": "how to approach this problem?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "String rotation or dynamic programming. Either will get you there regardless of time complexity"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Why is my O(n^2) solution giving me TLE\n\n` function repeatedSubstringPattern(s: string): boolean {`\n   \n   ` let subString=\"\";`\n \n` for(let i=0;i<s.length;i++){`\n`    subString+=s.charAt(i);`\n   ` if(checkValidity(subString,s)){`\n      ` return true`\n `   }`\n` }`\n\n`return false;`\n\n};\n\n\n`function checkValidity(subStr:string,s:string){`\n`   if(subStr.length==s.length){`\n`      return false;`\n`   }`\n`  const n=s.length;`\n`  let resultLength=n;`\n`  let subString=\"\"`\n`  for(let i=0;i<s.length;i++){`\n   `  subString+=s.charAt(i);`\n    ` if(subString===subStr){`\n        `resultLength-=subStr.length;`\n      `  subString=\"\";`\n    ` }`\n ` }`\n ` return resultLength==0;`\n\n`}`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use 3 backticks to format your code better:\\n\\nyou can use slice to get a subString in one go, instead of doing it per char. and you can add the whole subString to itself rather than per char, thats a lot faster. \\n\\nAlso you can think about what it means if you can build s from copies of subString. Can you do a quick check beforehand based on the length, so that you only have to check a fraction of all the posibillities? \\n"
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone please explain why s=\"abaababaab\" expects output to be True? (testcase 78)"
                    },
                    {
                        "username": "ramanchik",
                        "content": "\"abaab\" + \"abaab\" "
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone explain in testcase 78/129\\ns=\"abaababaab\", why is the expected answer True?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    }
                ]
            },
            {
                "id": 2024337,
                "content": [
                    {
                        "username": "user5154h",
                        "content": "why does \\'ababba\\' retuns false ?\\n\\nit has 2 ab so it should return true"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "no. You have to make the original string by concatenating a substring that is present in the original string.\\nhere ababba is the original string. if we consider ab as a substring, even if we concatenate ab 3 times it still can\\'t make the original string again. thus answer becomes false.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "s3stan",
                        "content": "We cannot make ab ba. Now, if there was ababab, then yes, it should have been true here.\\nIf it is possible to get the full string from the substring then it will be true."
                    },
                    {
                        "username": "DimSonikku",
                        "content": "Why does testcase 129 give time limit exceeded?\nEdit: it passed testcase 129(although the codes perfomance is poor) after i removed the while loop and added a check \nif s.Length % substring.Length == 0, so that it would skip some useless iterations\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub, res;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            res = \"\";\n            sub = s.Substring(0, i+1);\n            while(res.Length < s.Length) \n                res += sub;\n            if (res == s)\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            if (s.Length%s.Substring(0, i+1).Length == 0)\n            {\n            sub = s.Substring(0, i+1);\n            sub = String.Concat(Enumerable.Repeat(sub, s.Length/sub.Length));\n            if (sub == s)\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) thank you for the help, i will try to do something about this"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "It might be giving Time limit Exceeded error because your logic is running 0(n^2) times"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) tried checking if its null, still gives time limit exceeded"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Cant paste it, because cant copy it, its nothing. It says: \"s =\" and i cant copy what comes after \"=\", even using the copy button that is next to this testcase."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@DimSonikku](/DimSonikku) what\\'s the testcase 129 paste it here\\n"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Yes, this code passes every other testcase, except for 129"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "testcase 129?\\n\\n"
                    },
                    {
                        "username": "dipak2000",
                        "content": "Can we do This question using LPS(longest prefix suffix) method which is used in KMP algorithm?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, it\\'s possible give it a go"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "Pleasse someone tell why i got tle \\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> factorize(int n){\\n        unordered_map<int, int>mp;\\n        for(int i=1; i*i<=n; i++){\\n            if(n%i == 0){\\n                mp[i] = 1;\\n                mp[n/i] = 1;  \\n            }\\n        }\\n        return mp;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        if(s == \"\"){\\n            return false;\\n        }\\n        int n = s.length(), i, j;\\n        \\n        if(n == 1)return false;\\n        vector<int>f(26, 0);\\n        for(i=0; i<n; i++){\\n            f[s[i] - \\'a\\'] ++;\\n        }\\n        for(i=0; i<n; i++){\\n            if(f[s[i] - \\'a\\'] == 1) return false;\\n        }\\n        //unordered_map<int, int>mp = factorize(n);\\n        string temp = \"\";\\n        for(i=0; i<n/2; i++){\\n            temp.push_back(s[i]);\\n            if(n%(i+1) == 0){\\n                //cout<<i<<\" \";\\n                string check = \"\";\\n                for(j=0; j<n/(i+1); j++){\\n                    check = check + temp;\\n                }\\n                 //out<<temp<<\" \"<<check<<endl;\\n                if(s == check){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "[@mstuebs](/mstuebs) still same result\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "You are looping through each char individually. To speed up, consider using the built-in C++ string comparison functions. "
                    },
                    {
                        "username": "SG-C",
                        "content": "this should be labeled medium "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "it is easy if you know kmp, first check its prefixing algorithm\\nyou will like this problem"
                    },
                    {
                        "username": "Emily50",
                        "content": "Why O(n^2) solution makes TLE?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "In complexity analysis, \"10^7\" (10 million) is used as a reference to estimate the efficiency of algorithms based on input size .In the question constraints are given as 10^4  so if you use 0(n^2) complexity that will be (10^4)*2 that will lead to TLE.\\n\\nYou have to find 0(NlogN) , 0(N), solution\\nIn this problem It will also Accept 0(N*sqrt(N)) solution\\n\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What\\'s your thought process with your solution?"
                    },
                    {
                        "username": "BIPIN21CSB0B09",
                        "content": "how to approach this problem?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "String rotation or dynamic programming. Either will get you there regardless of time complexity"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Why is my O(n^2) solution giving me TLE\n\n` function repeatedSubstringPattern(s: string): boolean {`\n   \n   ` let subString=\"\";`\n \n` for(let i=0;i<s.length;i++){`\n`    subString+=s.charAt(i);`\n   ` if(checkValidity(subString,s)){`\n      ` return true`\n `   }`\n` }`\n\n`return false;`\n\n};\n\n\n`function checkValidity(subStr:string,s:string){`\n`   if(subStr.length==s.length){`\n`      return false;`\n`   }`\n`  const n=s.length;`\n`  let resultLength=n;`\n`  let subString=\"\"`\n`  for(let i=0;i<s.length;i++){`\n   `  subString+=s.charAt(i);`\n    ` if(subString===subStr){`\n        `resultLength-=subStr.length;`\n      `  subString=\"\";`\n    ` }`\n ` }`\n ` return resultLength==0;`\n\n`}`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use 3 backticks to format your code better:\\n\\nyou can use slice to get a subString in one go, instead of doing it per char. and you can add the whole subString to itself rather than per char, thats a lot faster. \\n\\nAlso you can think about what it means if you can build s from copies of subString. Can you do a quick check beforehand based on the length, so that you only have to check a fraction of all the posibillities? \\n"
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone please explain why s=\"abaababaab\" expects output to be True? (testcase 78)"
                    },
                    {
                        "username": "ramanchik",
                        "content": "\"abaab\" + \"abaab\" "
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone explain in testcase 78/129\\ns=\"abaababaab\", why is the expected answer True?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    }
                ]
            },
            {
                "id": 2024267,
                "content": [
                    {
                        "username": "user5154h",
                        "content": "why does \\'ababba\\' retuns false ?\\n\\nit has 2 ab so it should return true"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "no. You have to make the original string by concatenating a substring that is present in the original string.\\nhere ababba is the original string. if we consider ab as a substring, even if we concatenate ab 3 times it still can\\'t make the original string again. thus answer becomes false.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "s3stan",
                        "content": "We cannot make ab ba. Now, if there was ababab, then yes, it should have been true here.\\nIf it is possible to get the full string from the substring then it will be true."
                    },
                    {
                        "username": "DimSonikku",
                        "content": "Why does testcase 129 give time limit exceeded?\nEdit: it passed testcase 129(although the codes perfomance is poor) after i removed the while loop and added a check \nif s.Length % substring.Length == 0, so that it would skip some useless iterations\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub, res;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            res = \"\";\n            sub = s.Substring(0, i+1);\n            while(res.Length < s.Length) \n                res += sub;\n            if (res == s)\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            if (s.Length%s.Substring(0, i+1).Length == 0)\n            {\n            sub = s.Substring(0, i+1);\n            sub = String.Concat(Enumerable.Repeat(sub, s.Length/sub.Length));\n            if (sub == s)\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) thank you for the help, i will try to do something about this"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "It might be giving Time limit Exceeded error because your logic is running 0(n^2) times"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) tried checking if its null, still gives time limit exceeded"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Cant paste it, because cant copy it, its nothing. It says: \"s =\" and i cant copy what comes after \"=\", even using the copy button that is next to this testcase."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@DimSonikku](/DimSonikku) what\\'s the testcase 129 paste it here\\n"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Yes, this code passes every other testcase, except for 129"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "testcase 129?\\n\\n"
                    },
                    {
                        "username": "dipak2000",
                        "content": "Can we do This question using LPS(longest prefix suffix) method which is used in KMP algorithm?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, it\\'s possible give it a go"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "Pleasse someone tell why i got tle \\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> factorize(int n){\\n        unordered_map<int, int>mp;\\n        for(int i=1; i*i<=n; i++){\\n            if(n%i == 0){\\n                mp[i] = 1;\\n                mp[n/i] = 1;  \\n            }\\n        }\\n        return mp;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        if(s == \"\"){\\n            return false;\\n        }\\n        int n = s.length(), i, j;\\n        \\n        if(n == 1)return false;\\n        vector<int>f(26, 0);\\n        for(i=0; i<n; i++){\\n            f[s[i] - \\'a\\'] ++;\\n        }\\n        for(i=0; i<n; i++){\\n            if(f[s[i] - \\'a\\'] == 1) return false;\\n        }\\n        //unordered_map<int, int>mp = factorize(n);\\n        string temp = \"\";\\n        for(i=0; i<n/2; i++){\\n            temp.push_back(s[i]);\\n            if(n%(i+1) == 0){\\n                //cout<<i<<\" \";\\n                string check = \"\";\\n                for(j=0; j<n/(i+1); j++){\\n                    check = check + temp;\\n                }\\n                 //out<<temp<<\" \"<<check<<endl;\\n                if(s == check){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "[@mstuebs](/mstuebs) still same result\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "You are looping through each char individually. To speed up, consider using the built-in C++ string comparison functions. "
                    },
                    {
                        "username": "SG-C",
                        "content": "this should be labeled medium "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "it is easy if you know kmp, first check its prefixing algorithm\\nyou will like this problem"
                    },
                    {
                        "username": "Emily50",
                        "content": "Why O(n^2) solution makes TLE?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "In complexity analysis, \"10^7\" (10 million) is used as a reference to estimate the efficiency of algorithms based on input size .In the question constraints are given as 10^4  so if you use 0(n^2) complexity that will be (10^4)*2 that will lead to TLE.\\n\\nYou have to find 0(NlogN) , 0(N), solution\\nIn this problem It will also Accept 0(N*sqrt(N)) solution\\n\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What\\'s your thought process with your solution?"
                    },
                    {
                        "username": "BIPIN21CSB0B09",
                        "content": "how to approach this problem?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "String rotation or dynamic programming. Either will get you there regardless of time complexity"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Why is my O(n^2) solution giving me TLE\n\n` function repeatedSubstringPattern(s: string): boolean {`\n   \n   ` let subString=\"\";`\n \n` for(let i=0;i<s.length;i++){`\n`    subString+=s.charAt(i);`\n   ` if(checkValidity(subString,s)){`\n      ` return true`\n `   }`\n` }`\n\n`return false;`\n\n};\n\n\n`function checkValidity(subStr:string,s:string){`\n`   if(subStr.length==s.length){`\n`      return false;`\n`   }`\n`  const n=s.length;`\n`  let resultLength=n;`\n`  let subString=\"\"`\n`  for(let i=0;i<s.length;i++){`\n   `  subString+=s.charAt(i);`\n    ` if(subString===subStr){`\n        `resultLength-=subStr.length;`\n      `  subString=\"\";`\n    ` }`\n ` }`\n ` return resultLength==0;`\n\n`}`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use 3 backticks to format your code better:\\n\\nyou can use slice to get a subString in one go, instead of doing it per char. and you can add the whole subString to itself rather than per char, thats a lot faster. \\n\\nAlso you can think about what it means if you can build s from copies of subString. Can you do a quick check beforehand based on the length, so that you only have to check a fraction of all the posibillities? \\n"
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone please explain why s=\"abaababaab\" expects output to be True? (testcase 78)"
                    },
                    {
                        "username": "ramanchik",
                        "content": "\"abaab\" + \"abaab\" "
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone explain in testcase 78/129\\ns=\"abaababaab\", why is the expected answer True?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    }
                ]
            },
            {
                "id": 2024264,
                "content": [
                    {
                        "username": "user5154h",
                        "content": "why does \\'ababba\\' retuns false ?\\n\\nit has 2 ab so it should return true"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "no. You have to make the original string by concatenating a substring that is present in the original string.\\nhere ababba is the original string. if we consider ab as a substring, even if we concatenate ab 3 times it still can\\'t make the original string again. thus answer becomes false.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "s3stan",
                        "content": "We cannot make ab ba. Now, if there was ababab, then yes, it should have been true here.\\nIf it is possible to get the full string from the substring then it will be true."
                    },
                    {
                        "username": "DimSonikku",
                        "content": "Why does testcase 129 give time limit exceeded?\nEdit: it passed testcase 129(although the codes perfomance is poor) after i removed the while loop and added a check \nif s.Length % substring.Length == 0, so that it would skip some useless iterations\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub, res;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            res = \"\";\n            sub = s.Substring(0, i+1);\n            while(res.Length < s.Length) \n                res += sub;\n            if (res == s)\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            if (s.Length%s.Substring(0, i+1).Length == 0)\n            {\n            sub = s.Substring(0, i+1);\n            sub = String.Concat(Enumerable.Repeat(sub, s.Length/sub.Length));\n            if (sub == s)\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) thank you for the help, i will try to do something about this"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "It might be giving Time limit Exceeded error because your logic is running 0(n^2) times"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) tried checking if its null, still gives time limit exceeded"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Cant paste it, because cant copy it, its nothing. It says: \"s =\" and i cant copy what comes after \"=\", even using the copy button that is next to this testcase."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@DimSonikku](/DimSonikku) what\\'s the testcase 129 paste it here\\n"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Yes, this code passes every other testcase, except for 129"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "testcase 129?\\n\\n"
                    },
                    {
                        "username": "dipak2000",
                        "content": "Can we do This question using LPS(longest prefix suffix) method which is used in KMP algorithm?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, it\\'s possible give it a go"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "Pleasse someone tell why i got tle \\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> factorize(int n){\\n        unordered_map<int, int>mp;\\n        for(int i=1; i*i<=n; i++){\\n            if(n%i == 0){\\n                mp[i] = 1;\\n                mp[n/i] = 1;  \\n            }\\n        }\\n        return mp;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        if(s == \"\"){\\n            return false;\\n        }\\n        int n = s.length(), i, j;\\n        \\n        if(n == 1)return false;\\n        vector<int>f(26, 0);\\n        for(i=0; i<n; i++){\\n            f[s[i] - \\'a\\'] ++;\\n        }\\n        for(i=0; i<n; i++){\\n            if(f[s[i] - \\'a\\'] == 1) return false;\\n        }\\n        //unordered_map<int, int>mp = factorize(n);\\n        string temp = \"\";\\n        for(i=0; i<n/2; i++){\\n            temp.push_back(s[i]);\\n            if(n%(i+1) == 0){\\n                //cout<<i<<\" \";\\n                string check = \"\";\\n                for(j=0; j<n/(i+1); j++){\\n                    check = check + temp;\\n                }\\n                 //out<<temp<<\" \"<<check<<endl;\\n                if(s == check){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "[@mstuebs](/mstuebs) still same result\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "You are looping through each char individually. To speed up, consider using the built-in C++ string comparison functions. "
                    },
                    {
                        "username": "SG-C",
                        "content": "this should be labeled medium "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "it is easy if you know kmp, first check its prefixing algorithm\\nyou will like this problem"
                    },
                    {
                        "username": "Emily50",
                        "content": "Why O(n^2) solution makes TLE?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "In complexity analysis, \"10^7\" (10 million) is used as a reference to estimate the efficiency of algorithms based on input size .In the question constraints are given as 10^4  so if you use 0(n^2) complexity that will be (10^4)*2 that will lead to TLE.\\n\\nYou have to find 0(NlogN) , 0(N), solution\\nIn this problem It will also Accept 0(N*sqrt(N)) solution\\n\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What\\'s your thought process with your solution?"
                    },
                    {
                        "username": "BIPIN21CSB0B09",
                        "content": "how to approach this problem?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "String rotation or dynamic programming. Either will get you there regardless of time complexity"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Why is my O(n^2) solution giving me TLE\n\n` function repeatedSubstringPattern(s: string): boolean {`\n   \n   ` let subString=\"\";`\n \n` for(let i=0;i<s.length;i++){`\n`    subString+=s.charAt(i);`\n   ` if(checkValidity(subString,s)){`\n      ` return true`\n `   }`\n` }`\n\n`return false;`\n\n};\n\n\n`function checkValidity(subStr:string,s:string){`\n`   if(subStr.length==s.length){`\n`      return false;`\n`   }`\n`  const n=s.length;`\n`  let resultLength=n;`\n`  let subString=\"\"`\n`  for(let i=0;i<s.length;i++){`\n   `  subString+=s.charAt(i);`\n    ` if(subString===subStr){`\n        `resultLength-=subStr.length;`\n      `  subString=\"\";`\n    ` }`\n ` }`\n ` return resultLength==0;`\n\n`}`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use 3 backticks to format your code better:\\n\\nyou can use slice to get a subString in one go, instead of doing it per char. and you can add the whole subString to itself rather than per char, thats a lot faster. \\n\\nAlso you can think about what it means if you can build s from copies of subString. Can you do a quick check beforehand based on the length, so that you only have to check a fraction of all the posibillities? \\n"
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone please explain why s=\"abaababaab\" expects output to be True? (testcase 78)"
                    },
                    {
                        "username": "ramanchik",
                        "content": "\"abaab\" + \"abaab\" "
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone explain in testcase 78/129\\ns=\"abaababaab\", why is the expected answer True?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    }
                ]
            },
            {
                "id": 2024257,
                "content": [
                    {
                        "username": "user5154h",
                        "content": "why does \\'ababba\\' retuns false ?\\n\\nit has 2 ab so it should return true"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "no. You have to make the original string by concatenating a substring that is present in the original string.\\nhere ababba is the original string. if we consider ab as a substring, even if we concatenate ab 3 times it still can\\'t make the original string again. thus answer becomes false.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "s3stan",
                        "content": "We cannot make ab ba. Now, if there was ababab, then yes, it should have been true here.\\nIf it is possible to get the full string from the substring then it will be true."
                    },
                    {
                        "username": "DimSonikku",
                        "content": "Why does testcase 129 give time limit exceeded?\nEdit: it passed testcase 129(although the codes perfomance is poor) after i removed the while loop and added a check \nif s.Length % substring.Length == 0, so that it would skip some useless iterations\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub, res;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            res = \"\";\n            sub = s.Substring(0, i+1);\n            while(res.Length < s.Length) \n                res += sub;\n            if (res == s)\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            if (s.Length%s.Substring(0, i+1).Length == 0)\n            {\n            sub = s.Substring(0, i+1);\n            sub = String.Concat(Enumerable.Repeat(sub, s.Length/sub.Length));\n            if (sub == s)\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) thank you for the help, i will try to do something about this"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "It might be giving Time limit Exceeded error because your logic is running 0(n^2) times"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) tried checking if its null, still gives time limit exceeded"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Cant paste it, because cant copy it, its nothing. It says: \"s =\" and i cant copy what comes after \"=\", even using the copy button that is next to this testcase."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@DimSonikku](/DimSonikku) what\\'s the testcase 129 paste it here\\n"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Yes, this code passes every other testcase, except for 129"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "testcase 129?\\n\\n"
                    },
                    {
                        "username": "dipak2000",
                        "content": "Can we do This question using LPS(longest prefix suffix) method which is used in KMP algorithm?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, it\\'s possible give it a go"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "Pleasse someone tell why i got tle \\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> factorize(int n){\\n        unordered_map<int, int>mp;\\n        for(int i=1; i*i<=n; i++){\\n            if(n%i == 0){\\n                mp[i] = 1;\\n                mp[n/i] = 1;  \\n            }\\n        }\\n        return mp;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        if(s == \"\"){\\n            return false;\\n        }\\n        int n = s.length(), i, j;\\n        \\n        if(n == 1)return false;\\n        vector<int>f(26, 0);\\n        for(i=0; i<n; i++){\\n            f[s[i] - \\'a\\'] ++;\\n        }\\n        for(i=0; i<n; i++){\\n            if(f[s[i] - \\'a\\'] == 1) return false;\\n        }\\n        //unordered_map<int, int>mp = factorize(n);\\n        string temp = \"\";\\n        for(i=0; i<n/2; i++){\\n            temp.push_back(s[i]);\\n            if(n%(i+1) == 0){\\n                //cout<<i<<\" \";\\n                string check = \"\";\\n                for(j=0; j<n/(i+1); j++){\\n                    check = check + temp;\\n                }\\n                 //out<<temp<<\" \"<<check<<endl;\\n                if(s == check){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "[@mstuebs](/mstuebs) still same result\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "You are looping through each char individually. To speed up, consider using the built-in C++ string comparison functions. "
                    },
                    {
                        "username": "SG-C",
                        "content": "this should be labeled medium "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "it is easy if you know kmp, first check its prefixing algorithm\\nyou will like this problem"
                    },
                    {
                        "username": "Emily50",
                        "content": "Why O(n^2) solution makes TLE?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "In complexity analysis, \"10^7\" (10 million) is used as a reference to estimate the efficiency of algorithms based on input size .In the question constraints are given as 10^4  so if you use 0(n^2) complexity that will be (10^4)*2 that will lead to TLE.\\n\\nYou have to find 0(NlogN) , 0(N), solution\\nIn this problem It will also Accept 0(N*sqrt(N)) solution\\n\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What\\'s your thought process with your solution?"
                    },
                    {
                        "username": "BIPIN21CSB0B09",
                        "content": "how to approach this problem?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "String rotation or dynamic programming. Either will get you there regardless of time complexity"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Why is my O(n^2) solution giving me TLE\n\n` function repeatedSubstringPattern(s: string): boolean {`\n   \n   ` let subString=\"\";`\n \n` for(let i=0;i<s.length;i++){`\n`    subString+=s.charAt(i);`\n   ` if(checkValidity(subString,s)){`\n      ` return true`\n `   }`\n` }`\n\n`return false;`\n\n};\n\n\n`function checkValidity(subStr:string,s:string){`\n`   if(subStr.length==s.length){`\n`      return false;`\n`   }`\n`  const n=s.length;`\n`  let resultLength=n;`\n`  let subString=\"\"`\n`  for(let i=0;i<s.length;i++){`\n   `  subString+=s.charAt(i);`\n    ` if(subString===subStr){`\n        `resultLength-=subStr.length;`\n      `  subString=\"\";`\n    ` }`\n ` }`\n ` return resultLength==0;`\n\n`}`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use 3 backticks to format your code better:\\n\\nyou can use slice to get a subString in one go, instead of doing it per char. and you can add the whole subString to itself rather than per char, thats a lot faster. \\n\\nAlso you can think about what it means if you can build s from copies of subString. Can you do a quick check beforehand based on the length, so that you only have to check a fraction of all the posibillities? \\n"
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone please explain why s=\"abaababaab\" expects output to be True? (testcase 78)"
                    },
                    {
                        "username": "ramanchik",
                        "content": "\"abaab\" + \"abaab\" "
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone explain in testcase 78/129\\ns=\"abaababaab\", why is the expected answer True?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    }
                ]
            },
            {
                "id": 2024211,
                "content": [
                    {
                        "username": "akash_vannam",
                        "content": "Someone HELP!!!!\\n\\n\\nsubs = prefix of string s;\\nn = s.length(), m = subs.length()\\nOne necessary condition of subs to build s is that m must divide n.\\nFinding all the factors is O(rootn) time and checking if its a pattern is O(n) time.\\nOverall time complexity is O(nrootn)  < O(n2)\\nIf n^2 solutions are accepted then nrootn must surely be accepted.\\nBut it\\'s giving me TLE!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool is_pattern(string &s, string &subs)\\n    {\\n        int n = s.length(), m = subs.length();\\n        for(int i = m; i < n; i++)\\n        {\\n            if(s[i] != subs[i%m]) return false;\\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\\n        }\\n        return true;\\n    }\\n\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        if(n == 1) return false;\\n        cout<<n<<endl;\\n        bool allsame = true;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s[i] != s[i-1]) \\n            {\\n                allsame = false;\\n                break;\\n            }\\n        }\\n        if(allsame) return true;\\n        for(int i = 2; i*i <= n; i++)\\n        {\\n            if((n%i) == 0)\\n            {\\n                int j = n/i;\\n                string subs1 = s.substr(0,i);\\n                string subs2 = s.substr(0,j);\\n\\n                // cout<<subs1<<\" \"<<subs2<<endl;\\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\\n            }\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Your function `is_pattern()` is too slow because it compares every char individually. \\nIf you compare *each chunk as a whole* to the substring, it will be sufficient to pass. This is your code:\\n```\\n    for(int i = m; i < n; i++)\\n    {\\n          if(s[i] != subs[i%m]) return false;\\n     }\\n```\\nReplace it with this:\\n```\\n    for(int i = m; i < n; i += m)\\n    {\\n        string investigated_substring = s.substr(i,i+m);\\n        if(investigated_substring != subs) return false;\\n    }\\n```"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "So Happy to solve this ...After ages 1 easy quetion."
                    },
                    {
                        "username": "s3stan",
                        "content": "And a simple task helps to gain new knowledge"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Well leetcode , provide more problems this week like this easy one"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is easy only because we don\\'t have to code the KMP algorithm. We can use a library function for that. The trick about concatenating the string onto itself is not something that somebody would invent in an interview situation but even then you can get away without doing it. Brute force will pass all test cases."
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "why this not working, can anyone explain?\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n\\n        for (int l = n / 2; l >= 1 && n % l == 0; l--) {\\n            string pattern = s.substr(0, l);\\n            string new_s = \"\";\\n            int times = n / l;\\n\\n            while (times--) {\\n                new_s += pattern;\\n            }\\n\\n            cout << new_s << endl;\\n            if (s == new_s) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "bhaiya ! you made mistake in your test condition of for loop :\\ngeneral => for loop : for(int i=0;i<n;i++) \\nthis above code says that  \\' i \\' should always satisfy condition  i<n else loop will break, this is the test ondition\\nbut , your loop is like i>=1 and always satisfy n%i==0 \\nso this may be cause why your code is not working as you expected ..."
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "After a long time I got to see easy question on LeetCode Streak   "
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "why ababba return false"
                    },
                    {
                        "username": "andykimchris",
                        "content": "You can\\'t replicate the string from any substring i.e \"aba\" and \"ab\" don\\'t align with \"bb\" or \"bba\". \\nbbabba or abaaba can."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'ababab' for example"
                    },
                    {
                        "username": "MdFaizan034",
                        "content": "how is \"aba\" false."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@mina2025](/mina2025) then you don't have the 'b' you need all the letters, using just 'a' would give 'aaa'"
                    },
                    {
                        "username": "mina2025",
                        "content": "[@Mister_CK](/Mister_CK) Why not use \\'a\\' substring to create the last \\'a\\' in \\'aba\\' just like in \\'bb\\' example?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'abab' for example"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Observe that the string length should be multiple of the assumed substr !\\n[My solution here](https://leetcode.com/problems/repeated-substring-pattern/solutions/3940188/solved-only-using-arrays-easy-approach-simple-understanding-my-solution-accepted/)"
                    }
                ]
            },
            {
                "id": 2024144,
                "content": [
                    {
                        "username": "akash_vannam",
                        "content": "Someone HELP!!!!\\n\\n\\nsubs = prefix of string s;\\nn = s.length(), m = subs.length()\\nOne necessary condition of subs to build s is that m must divide n.\\nFinding all the factors is O(rootn) time and checking if its a pattern is O(n) time.\\nOverall time complexity is O(nrootn)  < O(n2)\\nIf n^2 solutions are accepted then nrootn must surely be accepted.\\nBut it\\'s giving me TLE!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool is_pattern(string &s, string &subs)\\n    {\\n        int n = s.length(), m = subs.length();\\n        for(int i = m; i < n; i++)\\n        {\\n            if(s[i] != subs[i%m]) return false;\\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\\n        }\\n        return true;\\n    }\\n\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        if(n == 1) return false;\\n        cout<<n<<endl;\\n        bool allsame = true;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s[i] != s[i-1]) \\n            {\\n                allsame = false;\\n                break;\\n            }\\n        }\\n        if(allsame) return true;\\n        for(int i = 2; i*i <= n; i++)\\n        {\\n            if((n%i) == 0)\\n            {\\n                int j = n/i;\\n                string subs1 = s.substr(0,i);\\n                string subs2 = s.substr(0,j);\\n\\n                // cout<<subs1<<\" \"<<subs2<<endl;\\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\\n            }\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Your function `is_pattern()` is too slow because it compares every char individually. \\nIf you compare *each chunk as a whole* to the substring, it will be sufficient to pass. This is your code:\\n```\\n    for(int i = m; i < n; i++)\\n    {\\n          if(s[i] != subs[i%m]) return false;\\n     }\\n```\\nReplace it with this:\\n```\\n    for(int i = m; i < n; i += m)\\n    {\\n        string investigated_substring = s.substr(i,i+m);\\n        if(investigated_substring != subs) return false;\\n    }\\n```"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "So Happy to solve this ...After ages 1 easy quetion."
                    },
                    {
                        "username": "s3stan",
                        "content": "And a simple task helps to gain new knowledge"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Well leetcode , provide more problems this week like this easy one"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is easy only because we don\\'t have to code the KMP algorithm. We can use a library function for that. The trick about concatenating the string onto itself is not something that somebody would invent in an interview situation but even then you can get away without doing it. Brute force will pass all test cases."
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "why this not working, can anyone explain?\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n\\n        for (int l = n / 2; l >= 1 && n % l == 0; l--) {\\n            string pattern = s.substr(0, l);\\n            string new_s = \"\";\\n            int times = n / l;\\n\\n            while (times--) {\\n                new_s += pattern;\\n            }\\n\\n            cout << new_s << endl;\\n            if (s == new_s) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "bhaiya ! you made mistake in your test condition of for loop :\\ngeneral => for loop : for(int i=0;i<n;i++) \\nthis above code says that  \\' i \\' should always satisfy condition  i<n else loop will break, this is the test ondition\\nbut , your loop is like i>=1 and always satisfy n%i==0 \\nso this may be cause why your code is not working as you expected ..."
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "After a long time I got to see easy question on LeetCode Streak   "
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "why ababba return false"
                    },
                    {
                        "username": "andykimchris",
                        "content": "You can\\'t replicate the string from any substring i.e \"aba\" and \"ab\" don\\'t align with \"bb\" or \"bba\". \\nbbabba or abaaba can."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'ababab' for example"
                    },
                    {
                        "username": "MdFaizan034",
                        "content": "how is \"aba\" false."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@mina2025](/mina2025) then you don't have the 'b' you need all the letters, using just 'a' would give 'aaa'"
                    },
                    {
                        "username": "mina2025",
                        "content": "[@Mister_CK](/Mister_CK) Why not use \\'a\\' substring to create the last \\'a\\' in \\'aba\\' just like in \\'bb\\' example?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'abab' for example"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Observe that the string length should be multiple of the assumed substr !\\n[My solution here](https://leetcode.com/problems/repeated-substring-pattern/solutions/3940188/solved-only-using-arrays-easy-approach-simple-understanding-my-solution-accepted/)"
                    }
                ]
            },
            {
                "id": 2024077,
                "content": [
                    {
                        "username": "akash_vannam",
                        "content": "Someone HELP!!!!\\n\\n\\nsubs = prefix of string s;\\nn = s.length(), m = subs.length()\\nOne necessary condition of subs to build s is that m must divide n.\\nFinding all the factors is O(rootn) time and checking if its a pattern is O(n) time.\\nOverall time complexity is O(nrootn)  < O(n2)\\nIf n^2 solutions are accepted then nrootn must surely be accepted.\\nBut it\\'s giving me TLE!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool is_pattern(string &s, string &subs)\\n    {\\n        int n = s.length(), m = subs.length();\\n        for(int i = m; i < n; i++)\\n        {\\n            if(s[i] != subs[i%m]) return false;\\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\\n        }\\n        return true;\\n    }\\n\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        if(n == 1) return false;\\n        cout<<n<<endl;\\n        bool allsame = true;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s[i] != s[i-1]) \\n            {\\n                allsame = false;\\n                break;\\n            }\\n        }\\n        if(allsame) return true;\\n        for(int i = 2; i*i <= n; i++)\\n        {\\n            if((n%i) == 0)\\n            {\\n                int j = n/i;\\n                string subs1 = s.substr(0,i);\\n                string subs2 = s.substr(0,j);\\n\\n                // cout<<subs1<<\" \"<<subs2<<endl;\\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\\n            }\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Your function `is_pattern()` is too slow because it compares every char individually. \\nIf you compare *each chunk as a whole* to the substring, it will be sufficient to pass. This is your code:\\n```\\n    for(int i = m; i < n; i++)\\n    {\\n          if(s[i] != subs[i%m]) return false;\\n     }\\n```\\nReplace it with this:\\n```\\n    for(int i = m; i < n; i += m)\\n    {\\n        string investigated_substring = s.substr(i,i+m);\\n        if(investigated_substring != subs) return false;\\n    }\\n```"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "So Happy to solve this ...After ages 1 easy quetion."
                    },
                    {
                        "username": "s3stan",
                        "content": "And a simple task helps to gain new knowledge"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Well leetcode , provide more problems this week like this easy one"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is easy only because we don\\'t have to code the KMP algorithm. We can use a library function for that. The trick about concatenating the string onto itself is not something that somebody would invent in an interview situation but even then you can get away without doing it. Brute force will pass all test cases."
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "why this not working, can anyone explain?\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n\\n        for (int l = n / 2; l >= 1 && n % l == 0; l--) {\\n            string pattern = s.substr(0, l);\\n            string new_s = \"\";\\n            int times = n / l;\\n\\n            while (times--) {\\n                new_s += pattern;\\n            }\\n\\n            cout << new_s << endl;\\n            if (s == new_s) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "bhaiya ! you made mistake in your test condition of for loop :\\ngeneral => for loop : for(int i=0;i<n;i++) \\nthis above code says that  \\' i \\' should always satisfy condition  i<n else loop will break, this is the test ondition\\nbut , your loop is like i>=1 and always satisfy n%i==0 \\nso this may be cause why your code is not working as you expected ..."
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "After a long time I got to see easy question on LeetCode Streak   "
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "why ababba return false"
                    },
                    {
                        "username": "andykimchris",
                        "content": "You can\\'t replicate the string from any substring i.e \"aba\" and \"ab\" don\\'t align with \"bb\" or \"bba\". \\nbbabba or abaaba can."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'ababab' for example"
                    },
                    {
                        "username": "MdFaizan034",
                        "content": "how is \"aba\" false."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@mina2025](/mina2025) then you don't have the 'b' you need all the letters, using just 'a' would give 'aaa'"
                    },
                    {
                        "username": "mina2025",
                        "content": "[@Mister_CK](/Mister_CK) Why not use \\'a\\' substring to create the last \\'a\\' in \\'aba\\' just like in \\'bb\\' example?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'abab' for example"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Observe that the string length should be multiple of the assumed substr !\\n[My solution here](https://leetcode.com/problems/repeated-substring-pattern/solutions/3940188/solved-only-using-arrays-easy-approach-simple-understanding-my-solution-accepted/)"
                    }
                ]
            },
            {
                "id": 2024065,
                "content": [
                    {
                        "username": "akash_vannam",
                        "content": "Someone HELP!!!!\\n\\n\\nsubs = prefix of string s;\\nn = s.length(), m = subs.length()\\nOne necessary condition of subs to build s is that m must divide n.\\nFinding all the factors is O(rootn) time and checking if its a pattern is O(n) time.\\nOverall time complexity is O(nrootn)  < O(n2)\\nIf n^2 solutions are accepted then nrootn must surely be accepted.\\nBut it\\'s giving me TLE!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool is_pattern(string &s, string &subs)\\n    {\\n        int n = s.length(), m = subs.length();\\n        for(int i = m; i < n; i++)\\n        {\\n            if(s[i] != subs[i%m]) return false;\\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\\n        }\\n        return true;\\n    }\\n\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        if(n == 1) return false;\\n        cout<<n<<endl;\\n        bool allsame = true;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s[i] != s[i-1]) \\n            {\\n                allsame = false;\\n                break;\\n            }\\n        }\\n        if(allsame) return true;\\n        for(int i = 2; i*i <= n; i++)\\n        {\\n            if((n%i) == 0)\\n            {\\n                int j = n/i;\\n                string subs1 = s.substr(0,i);\\n                string subs2 = s.substr(0,j);\\n\\n                // cout<<subs1<<\" \"<<subs2<<endl;\\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\\n            }\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Your function `is_pattern()` is too slow because it compares every char individually. \\nIf you compare *each chunk as a whole* to the substring, it will be sufficient to pass. This is your code:\\n```\\n    for(int i = m; i < n; i++)\\n    {\\n          if(s[i] != subs[i%m]) return false;\\n     }\\n```\\nReplace it with this:\\n```\\n    for(int i = m; i < n; i += m)\\n    {\\n        string investigated_substring = s.substr(i,i+m);\\n        if(investigated_substring != subs) return false;\\n    }\\n```"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "So Happy to solve this ...After ages 1 easy quetion."
                    },
                    {
                        "username": "s3stan",
                        "content": "And a simple task helps to gain new knowledge"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Well leetcode , provide more problems this week like this easy one"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is easy only because we don\\'t have to code the KMP algorithm. We can use a library function for that. The trick about concatenating the string onto itself is not something that somebody would invent in an interview situation but even then you can get away without doing it. Brute force will pass all test cases."
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "why this not working, can anyone explain?\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n\\n        for (int l = n / 2; l >= 1 && n % l == 0; l--) {\\n            string pattern = s.substr(0, l);\\n            string new_s = \"\";\\n            int times = n / l;\\n\\n            while (times--) {\\n                new_s += pattern;\\n            }\\n\\n            cout << new_s << endl;\\n            if (s == new_s) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "bhaiya ! you made mistake in your test condition of for loop :\\ngeneral => for loop : for(int i=0;i<n;i++) \\nthis above code says that  \\' i \\' should always satisfy condition  i<n else loop will break, this is the test ondition\\nbut , your loop is like i>=1 and always satisfy n%i==0 \\nso this may be cause why your code is not working as you expected ..."
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "After a long time I got to see easy question on LeetCode Streak   "
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "why ababba return false"
                    },
                    {
                        "username": "andykimchris",
                        "content": "You can\\'t replicate the string from any substring i.e \"aba\" and \"ab\" don\\'t align with \"bb\" or \"bba\". \\nbbabba or abaaba can."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'ababab' for example"
                    },
                    {
                        "username": "MdFaizan034",
                        "content": "how is \"aba\" false."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@mina2025](/mina2025) then you don't have the 'b' you need all the letters, using just 'a' would give 'aaa'"
                    },
                    {
                        "username": "mina2025",
                        "content": "[@Mister_CK](/Mister_CK) Why not use \\'a\\' substring to create the last \\'a\\' in \\'aba\\' just like in \\'bb\\' example?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'abab' for example"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Observe that the string length should be multiple of the assumed substr !\\n[My solution here](https://leetcode.com/problems/repeated-substring-pattern/solutions/3940188/solved-only-using-arrays-easy-approach-simple-understanding-my-solution-accepted/)"
                    }
                ]
            },
            {
                "id": 2024061,
                "content": [
                    {
                        "username": "akash_vannam",
                        "content": "Someone HELP!!!!\\n\\n\\nsubs = prefix of string s;\\nn = s.length(), m = subs.length()\\nOne necessary condition of subs to build s is that m must divide n.\\nFinding all the factors is O(rootn) time and checking if its a pattern is O(n) time.\\nOverall time complexity is O(nrootn)  < O(n2)\\nIf n^2 solutions are accepted then nrootn must surely be accepted.\\nBut it\\'s giving me TLE!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool is_pattern(string &s, string &subs)\\n    {\\n        int n = s.length(), m = subs.length();\\n        for(int i = m; i < n; i++)\\n        {\\n            if(s[i] != subs[i%m]) return false;\\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\\n        }\\n        return true;\\n    }\\n\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        if(n == 1) return false;\\n        cout<<n<<endl;\\n        bool allsame = true;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s[i] != s[i-1]) \\n            {\\n                allsame = false;\\n                break;\\n            }\\n        }\\n        if(allsame) return true;\\n        for(int i = 2; i*i <= n; i++)\\n        {\\n            if((n%i) == 0)\\n            {\\n                int j = n/i;\\n                string subs1 = s.substr(0,i);\\n                string subs2 = s.substr(0,j);\\n\\n                // cout<<subs1<<\" \"<<subs2<<endl;\\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\\n            }\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Your function `is_pattern()` is too slow because it compares every char individually. \\nIf you compare *each chunk as a whole* to the substring, it will be sufficient to pass. This is your code:\\n```\\n    for(int i = m; i < n; i++)\\n    {\\n          if(s[i] != subs[i%m]) return false;\\n     }\\n```\\nReplace it with this:\\n```\\n    for(int i = m; i < n; i += m)\\n    {\\n        string investigated_substring = s.substr(i,i+m);\\n        if(investigated_substring != subs) return false;\\n    }\\n```"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "So Happy to solve this ...After ages 1 easy quetion."
                    },
                    {
                        "username": "s3stan",
                        "content": "And a simple task helps to gain new knowledge"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Well leetcode , provide more problems this week like this easy one"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is easy only because we don\\'t have to code the KMP algorithm. We can use a library function for that. The trick about concatenating the string onto itself is not something that somebody would invent in an interview situation but even then you can get away without doing it. Brute force will pass all test cases."
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "why this not working, can anyone explain?\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n\\n        for (int l = n / 2; l >= 1 && n % l == 0; l--) {\\n            string pattern = s.substr(0, l);\\n            string new_s = \"\";\\n            int times = n / l;\\n\\n            while (times--) {\\n                new_s += pattern;\\n            }\\n\\n            cout << new_s << endl;\\n            if (s == new_s) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "bhaiya ! you made mistake in your test condition of for loop :\\ngeneral => for loop : for(int i=0;i<n;i++) \\nthis above code says that  \\' i \\' should always satisfy condition  i<n else loop will break, this is the test ondition\\nbut , your loop is like i>=1 and always satisfy n%i==0 \\nso this may be cause why your code is not working as you expected ..."
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "After a long time I got to see easy question on LeetCode Streak   "
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "why ababba return false"
                    },
                    {
                        "username": "andykimchris",
                        "content": "You can\\'t replicate the string from any substring i.e \"aba\" and \"ab\" don\\'t align with \"bb\" or \"bba\". \\nbbabba or abaaba can."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'ababab' for example"
                    },
                    {
                        "username": "MdFaizan034",
                        "content": "how is \"aba\" false."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@mina2025](/mina2025) then you don't have the 'b' you need all the letters, using just 'a' would give 'aaa'"
                    },
                    {
                        "username": "mina2025",
                        "content": "[@Mister_CK](/Mister_CK) Why not use \\'a\\' substring to create the last \\'a\\' in \\'aba\\' just like in \\'bb\\' example?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'abab' for example"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Observe that the string length should be multiple of the assumed substr !\\n[My solution here](https://leetcode.com/problems/repeated-substring-pattern/solutions/3940188/solved-only-using-arrays-easy-approach-simple-understanding-my-solution-accepted/)"
                    }
                ]
            },
            {
                "id": 2023983,
                "content": [
                    {
                        "username": "akash_vannam",
                        "content": "Someone HELP!!!!\\n\\n\\nsubs = prefix of string s;\\nn = s.length(), m = subs.length()\\nOne necessary condition of subs to build s is that m must divide n.\\nFinding all the factors is O(rootn) time and checking if its a pattern is O(n) time.\\nOverall time complexity is O(nrootn)  < O(n2)\\nIf n^2 solutions are accepted then nrootn must surely be accepted.\\nBut it\\'s giving me TLE!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool is_pattern(string &s, string &subs)\\n    {\\n        int n = s.length(), m = subs.length();\\n        for(int i = m; i < n; i++)\\n        {\\n            if(s[i] != subs[i%m]) return false;\\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\\n        }\\n        return true;\\n    }\\n\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        if(n == 1) return false;\\n        cout<<n<<endl;\\n        bool allsame = true;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s[i] != s[i-1]) \\n            {\\n                allsame = false;\\n                break;\\n            }\\n        }\\n        if(allsame) return true;\\n        for(int i = 2; i*i <= n; i++)\\n        {\\n            if((n%i) == 0)\\n            {\\n                int j = n/i;\\n                string subs1 = s.substr(0,i);\\n                string subs2 = s.substr(0,j);\\n\\n                // cout<<subs1<<\" \"<<subs2<<endl;\\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\\n            }\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Your function `is_pattern()` is too slow because it compares every char individually. \\nIf you compare *each chunk as a whole* to the substring, it will be sufficient to pass. This is your code:\\n```\\n    for(int i = m; i < n; i++)\\n    {\\n          if(s[i] != subs[i%m]) return false;\\n     }\\n```\\nReplace it with this:\\n```\\n    for(int i = m; i < n; i += m)\\n    {\\n        string investigated_substring = s.substr(i,i+m);\\n        if(investigated_substring != subs) return false;\\n    }\\n```"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "So Happy to solve this ...After ages 1 easy quetion."
                    },
                    {
                        "username": "s3stan",
                        "content": "And a simple task helps to gain new knowledge"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Well leetcode , provide more problems this week like this easy one"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is easy only because we don\\'t have to code the KMP algorithm. We can use a library function for that. The trick about concatenating the string onto itself is not something that somebody would invent in an interview situation but even then you can get away without doing it. Brute force will pass all test cases."
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "why this not working, can anyone explain?\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n\\n        for (int l = n / 2; l >= 1 && n % l == 0; l--) {\\n            string pattern = s.substr(0, l);\\n            string new_s = \"\";\\n            int times = n / l;\\n\\n            while (times--) {\\n                new_s += pattern;\\n            }\\n\\n            cout << new_s << endl;\\n            if (s == new_s) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "bhaiya ! you made mistake in your test condition of for loop :\\ngeneral => for loop : for(int i=0;i<n;i++) \\nthis above code says that  \\' i \\' should always satisfy condition  i<n else loop will break, this is the test ondition\\nbut , your loop is like i>=1 and always satisfy n%i==0 \\nso this may be cause why your code is not working as you expected ..."
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "After a long time I got to see easy question on LeetCode Streak   "
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "why ababba return false"
                    },
                    {
                        "username": "andykimchris",
                        "content": "You can\\'t replicate the string from any substring i.e \"aba\" and \"ab\" don\\'t align with \"bb\" or \"bba\". \\nbbabba or abaaba can."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'ababab' for example"
                    },
                    {
                        "username": "MdFaizan034",
                        "content": "how is \"aba\" false."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@mina2025](/mina2025) then you don't have the 'b' you need all the letters, using just 'a' would give 'aaa'"
                    },
                    {
                        "username": "mina2025",
                        "content": "[@Mister_CK](/Mister_CK) Why not use \\'a\\' substring to create the last \\'a\\' in \\'aba\\' just like in \\'bb\\' example?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'abab' for example"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Observe that the string length should be multiple of the assumed substr !\\n[My solution here](https://leetcode.com/problems/repeated-substring-pattern/solutions/3940188/solved-only-using-arrays-easy-approach-simple-understanding-my-solution-accepted/)"
                    }
                ]
            },
            {
                "id": 2023959,
                "content": [
                    {
                        "username": "akash_vannam",
                        "content": "Someone HELP!!!!\\n\\n\\nsubs = prefix of string s;\\nn = s.length(), m = subs.length()\\nOne necessary condition of subs to build s is that m must divide n.\\nFinding all the factors is O(rootn) time and checking if its a pattern is O(n) time.\\nOverall time complexity is O(nrootn)  < O(n2)\\nIf n^2 solutions are accepted then nrootn must surely be accepted.\\nBut it\\'s giving me TLE!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool is_pattern(string &s, string &subs)\\n    {\\n        int n = s.length(), m = subs.length();\\n        for(int i = m; i < n; i++)\\n        {\\n            if(s[i] != subs[i%m]) return false;\\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\\n        }\\n        return true;\\n    }\\n\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        if(n == 1) return false;\\n        cout<<n<<endl;\\n        bool allsame = true;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s[i] != s[i-1]) \\n            {\\n                allsame = false;\\n                break;\\n            }\\n        }\\n        if(allsame) return true;\\n        for(int i = 2; i*i <= n; i++)\\n        {\\n            if((n%i) == 0)\\n            {\\n                int j = n/i;\\n                string subs1 = s.substr(0,i);\\n                string subs2 = s.substr(0,j);\\n\\n                // cout<<subs1<<\" \"<<subs2<<endl;\\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\\n            }\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Your function `is_pattern()` is too slow because it compares every char individually. \\nIf you compare *each chunk as a whole* to the substring, it will be sufficient to pass. This is your code:\\n```\\n    for(int i = m; i < n; i++)\\n    {\\n          if(s[i] != subs[i%m]) return false;\\n     }\\n```\\nReplace it with this:\\n```\\n    for(int i = m; i < n; i += m)\\n    {\\n        string investigated_substring = s.substr(i,i+m);\\n        if(investigated_substring != subs) return false;\\n    }\\n```"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "So Happy to solve this ...After ages 1 easy quetion."
                    },
                    {
                        "username": "s3stan",
                        "content": "And a simple task helps to gain new knowledge"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Well leetcode , provide more problems this week like this easy one"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is easy only because we don\\'t have to code the KMP algorithm. We can use a library function for that. The trick about concatenating the string onto itself is not something that somebody would invent in an interview situation but even then you can get away without doing it. Brute force will pass all test cases."
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "why this not working, can anyone explain?\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n\\n        for (int l = n / 2; l >= 1 && n % l == 0; l--) {\\n            string pattern = s.substr(0, l);\\n            string new_s = \"\";\\n            int times = n / l;\\n\\n            while (times--) {\\n                new_s += pattern;\\n            }\\n\\n            cout << new_s << endl;\\n            if (s == new_s) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "bhaiya ! you made mistake in your test condition of for loop :\\ngeneral => for loop : for(int i=0;i<n;i++) \\nthis above code says that  \\' i \\' should always satisfy condition  i<n else loop will break, this is the test ondition\\nbut , your loop is like i>=1 and always satisfy n%i==0 \\nso this may be cause why your code is not working as you expected ..."
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "After a long time I got to see easy question on LeetCode Streak   "
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "why ababba return false"
                    },
                    {
                        "username": "andykimchris",
                        "content": "You can\\'t replicate the string from any substring i.e \"aba\" and \"ab\" don\\'t align with \"bb\" or \"bba\". \\nbbabba or abaaba can."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'ababab' for example"
                    },
                    {
                        "username": "MdFaizan034",
                        "content": "how is \"aba\" false."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@mina2025](/mina2025) then you don't have the 'b' you need all the letters, using just 'a' would give 'aaa'"
                    },
                    {
                        "username": "mina2025",
                        "content": "[@Mister_CK](/Mister_CK) Why not use \\'a\\' substring to create the last \\'a\\' in \\'aba\\' just like in \\'bb\\' example?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'abab' for example"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Observe that the string length should be multiple of the assumed substr !\\n[My solution here](https://leetcode.com/problems/repeated-substring-pattern/solutions/3940188/solved-only-using-arrays-easy-approach-simple-understanding-my-solution-accepted/)"
                    }
                ]
            },
            {
                "id": 2023930,
                "content": [
                    {
                        "username": "akash_vannam",
                        "content": "Someone HELP!!!!\\n\\n\\nsubs = prefix of string s;\\nn = s.length(), m = subs.length()\\nOne necessary condition of subs to build s is that m must divide n.\\nFinding all the factors is O(rootn) time and checking if its a pattern is O(n) time.\\nOverall time complexity is O(nrootn)  < O(n2)\\nIf n^2 solutions are accepted then nrootn must surely be accepted.\\nBut it\\'s giving me TLE!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool is_pattern(string &s, string &subs)\\n    {\\n        int n = s.length(), m = subs.length();\\n        for(int i = m; i < n; i++)\\n        {\\n            if(s[i] != subs[i%m]) return false;\\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\\n        }\\n        return true;\\n    }\\n\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        if(n == 1) return false;\\n        cout<<n<<endl;\\n        bool allsame = true;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s[i] != s[i-1]) \\n            {\\n                allsame = false;\\n                break;\\n            }\\n        }\\n        if(allsame) return true;\\n        for(int i = 2; i*i <= n; i++)\\n        {\\n            if((n%i) == 0)\\n            {\\n                int j = n/i;\\n                string subs1 = s.substr(0,i);\\n                string subs2 = s.substr(0,j);\\n\\n                // cout<<subs1<<\" \"<<subs2<<endl;\\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\\n            }\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Your function `is_pattern()` is too slow because it compares every char individually. \\nIf you compare *each chunk as a whole* to the substring, it will be sufficient to pass. This is your code:\\n```\\n    for(int i = m; i < n; i++)\\n    {\\n          if(s[i] != subs[i%m]) return false;\\n     }\\n```\\nReplace it with this:\\n```\\n    for(int i = m; i < n; i += m)\\n    {\\n        string investigated_substring = s.substr(i,i+m);\\n        if(investigated_substring != subs) return false;\\n    }\\n```"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "So Happy to solve this ...After ages 1 easy quetion."
                    },
                    {
                        "username": "s3stan",
                        "content": "And a simple task helps to gain new knowledge"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Well leetcode , provide more problems this week like this easy one"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is easy only because we don\\'t have to code the KMP algorithm. We can use a library function for that. The trick about concatenating the string onto itself is not something that somebody would invent in an interview situation but even then you can get away without doing it. Brute force will pass all test cases."
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "why this not working, can anyone explain?\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n\\n        for (int l = n / 2; l >= 1 && n % l == 0; l--) {\\n            string pattern = s.substr(0, l);\\n            string new_s = \"\";\\n            int times = n / l;\\n\\n            while (times--) {\\n                new_s += pattern;\\n            }\\n\\n            cout << new_s << endl;\\n            if (s == new_s) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "bhaiya ! you made mistake in your test condition of for loop :\\ngeneral => for loop : for(int i=0;i<n;i++) \\nthis above code says that  \\' i \\' should always satisfy condition  i<n else loop will break, this is the test ondition\\nbut , your loop is like i>=1 and always satisfy n%i==0 \\nso this may be cause why your code is not working as you expected ..."
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "After a long time I got to see easy question on LeetCode Streak   "
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "why ababba return false"
                    },
                    {
                        "username": "andykimchris",
                        "content": "You can\\'t replicate the string from any substring i.e \"aba\" and \"ab\" don\\'t align with \"bb\" or \"bba\". \\nbbabba or abaaba can."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'ababab' for example"
                    },
                    {
                        "username": "MdFaizan034",
                        "content": "how is \"aba\" false."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@mina2025](/mina2025) then you don't have the 'b' you need all the letters, using just 'a' would give 'aaa'"
                    },
                    {
                        "username": "mina2025",
                        "content": "[@Mister_CK](/Mister_CK) Why not use \\'a\\' substring to create the last \\'a\\' in \\'aba\\' just like in \\'bb\\' example?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'abab' for example"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Observe that the string length should be multiple of the assumed substr !\\n[My solution here](https://leetcode.com/problems/repeated-substring-pattern/solutions/3940188/solved-only-using-arrays-easy-approach-simple-understanding-my-solution-accepted/)"
                    }
                ]
            },
            {
                "id": 2023835,
                "content": [
                    {
                        "username": "akash_vannam",
                        "content": "Someone HELP!!!!\\n\\n\\nsubs = prefix of string s;\\nn = s.length(), m = subs.length()\\nOne necessary condition of subs to build s is that m must divide n.\\nFinding all the factors is O(rootn) time and checking if its a pattern is O(n) time.\\nOverall time complexity is O(nrootn)  < O(n2)\\nIf n^2 solutions are accepted then nrootn must surely be accepted.\\nBut it\\'s giving me TLE!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool is_pattern(string &s, string &subs)\\n    {\\n        int n = s.length(), m = subs.length();\\n        for(int i = m; i < n; i++)\\n        {\\n            if(s[i] != subs[i%m]) return false;\\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\\n        }\\n        return true;\\n    }\\n\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        if(n == 1) return false;\\n        cout<<n<<endl;\\n        bool allsame = true;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s[i] != s[i-1]) \\n            {\\n                allsame = false;\\n                break;\\n            }\\n        }\\n        if(allsame) return true;\\n        for(int i = 2; i*i <= n; i++)\\n        {\\n            if((n%i) == 0)\\n            {\\n                int j = n/i;\\n                string subs1 = s.substr(0,i);\\n                string subs2 = s.substr(0,j);\\n\\n                // cout<<subs1<<\" \"<<subs2<<endl;\\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\\n            }\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Your function `is_pattern()` is too slow because it compares every char individually. \\nIf you compare *each chunk as a whole* to the substring, it will be sufficient to pass. This is your code:\\n```\\n    for(int i = m; i < n; i++)\\n    {\\n          if(s[i] != subs[i%m]) return false;\\n     }\\n```\\nReplace it with this:\\n```\\n    for(int i = m; i < n; i += m)\\n    {\\n        string investigated_substring = s.substr(i,i+m);\\n        if(investigated_substring != subs) return false;\\n    }\\n```"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "So Happy to solve this ...After ages 1 easy quetion."
                    },
                    {
                        "username": "s3stan",
                        "content": "And a simple task helps to gain new knowledge"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Well leetcode , provide more problems this week like this easy one"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is easy only because we don\\'t have to code the KMP algorithm. We can use a library function for that. The trick about concatenating the string onto itself is not something that somebody would invent in an interview situation but even then you can get away without doing it. Brute force will pass all test cases."
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "why this not working, can anyone explain?\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n\\n        for (int l = n / 2; l >= 1 && n % l == 0; l--) {\\n            string pattern = s.substr(0, l);\\n            string new_s = \"\";\\n            int times = n / l;\\n\\n            while (times--) {\\n                new_s += pattern;\\n            }\\n\\n            cout << new_s << endl;\\n            if (s == new_s) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "bhaiya ! you made mistake in your test condition of for loop :\\ngeneral => for loop : for(int i=0;i<n;i++) \\nthis above code says that  \\' i \\' should always satisfy condition  i<n else loop will break, this is the test ondition\\nbut , your loop is like i>=1 and always satisfy n%i==0 \\nso this may be cause why your code is not working as you expected ..."
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "After a long time I got to see easy question on LeetCode Streak   "
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "why ababba return false"
                    },
                    {
                        "username": "andykimchris",
                        "content": "You can\\'t replicate the string from any substring i.e \"aba\" and \"ab\" don\\'t align with \"bb\" or \"bba\". \\nbbabba or abaaba can."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'ababab' for example"
                    },
                    {
                        "username": "MdFaizan034",
                        "content": "how is \"aba\" false."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@mina2025](/mina2025) then you don't have the 'b' you need all the letters, using just 'a' would give 'aaa'"
                    },
                    {
                        "username": "mina2025",
                        "content": "[@Mister_CK](/Mister_CK) Why not use \\'a\\' substring to create the last \\'a\\' in \\'aba\\' just like in \\'bb\\' example?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'abab' for example"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Observe that the string length should be multiple of the assumed substr !\\n[My solution here](https://leetcode.com/problems/repeated-substring-pattern/solutions/3940188/solved-only-using-arrays-easy-approach-simple-understanding-my-solution-accepted/)"
                    }
                ]
            },
            {
                "id": 2023827,
                "content": [
                    {
                        "username": "akash_vannam",
                        "content": "Someone HELP!!!!\\n\\n\\nsubs = prefix of string s;\\nn = s.length(), m = subs.length()\\nOne necessary condition of subs to build s is that m must divide n.\\nFinding all the factors is O(rootn) time and checking if its a pattern is O(n) time.\\nOverall time complexity is O(nrootn)  < O(n2)\\nIf n^2 solutions are accepted then nrootn must surely be accepted.\\nBut it\\'s giving me TLE!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool is_pattern(string &s, string &subs)\\n    {\\n        int n = s.length(), m = subs.length();\\n        for(int i = m; i < n; i++)\\n        {\\n            if(s[i] != subs[i%m]) return false;\\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\\n        }\\n        return true;\\n    }\\n\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        if(n == 1) return false;\\n        cout<<n<<endl;\\n        bool allsame = true;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s[i] != s[i-1]) \\n            {\\n                allsame = false;\\n                break;\\n            }\\n        }\\n        if(allsame) return true;\\n        for(int i = 2; i*i <= n; i++)\\n        {\\n            if((n%i) == 0)\\n            {\\n                int j = n/i;\\n                string subs1 = s.substr(0,i);\\n                string subs2 = s.substr(0,j);\\n\\n                // cout<<subs1<<\" \"<<subs2<<endl;\\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\\n            }\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Your function `is_pattern()` is too slow because it compares every char individually. \\nIf you compare *each chunk as a whole* to the substring, it will be sufficient to pass. This is your code:\\n```\\n    for(int i = m; i < n; i++)\\n    {\\n          if(s[i] != subs[i%m]) return false;\\n     }\\n```\\nReplace it with this:\\n```\\n    for(int i = m; i < n; i += m)\\n    {\\n        string investigated_substring = s.substr(i,i+m);\\n        if(investigated_substring != subs) return false;\\n    }\\n```"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "So Happy to solve this ...After ages 1 easy quetion."
                    },
                    {
                        "username": "s3stan",
                        "content": "And a simple task helps to gain new knowledge"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Well leetcode , provide more problems this week like this easy one"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is easy only because we don\\'t have to code the KMP algorithm. We can use a library function for that. The trick about concatenating the string onto itself is not something that somebody would invent in an interview situation but even then you can get away without doing it. Brute force will pass all test cases."
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "why this not working, can anyone explain?\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n\\n        for (int l = n / 2; l >= 1 && n % l == 0; l--) {\\n            string pattern = s.substr(0, l);\\n            string new_s = \"\";\\n            int times = n / l;\\n\\n            while (times--) {\\n                new_s += pattern;\\n            }\\n\\n            cout << new_s << endl;\\n            if (s == new_s) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "bhaiya ! you made mistake in your test condition of for loop :\\ngeneral => for loop : for(int i=0;i<n;i++) \\nthis above code says that  \\' i \\' should always satisfy condition  i<n else loop will break, this is the test ondition\\nbut , your loop is like i>=1 and always satisfy n%i==0 \\nso this may be cause why your code is not working as you expected ..."
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "After a long time I got to see easy question on LeetCode Streak   "
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "why ababba return false"
                    },
                    {
                        "username": "andykimchris",
                        "content": "You can\\'t replicate the string from any substring i.e \"aba\" and \"ab\" don\\'t align with \"bb\" or \"bba\". \\nbbabba or abaaba can."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'ababab' for example"
                    },
                    {
                        "username": "MdFaizan034",
                        "content": "how is \"aba\" false."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@mina2025](/mina2025) then you don't have the 'b' you need all the letters, using just 'a' would give 'aaa'"
                    },
                    {
                        "username": "mina2025",
                        "content": "[@Mister_CK](/Mister_CK) Why not use \\'a\\' substring to create the last \\'a\\' in \\'aba\\' just like in \\'bb\\' example?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'abab' for example"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Observe that the string length should be multiple of the assumed substr !\\n[My solution here](https://leetcode.com/problems/repeated-substring-pattern/solutions/3940188/solved-only-using-arrays-easy-approach-simple-understanding-my-solution-accepted/)"
                    }
                ]
            },
            {
                "id": 2023816,
                "content": [
                    {
                        "username": "DeepakPalUPres",
                        "content": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\n        // cout<<s;\\n        string str=s;\\n        int n=str.size()/2;\\n        while(n--)\\n        {\\n            reverse(str.begin()+1,str.end());\\n            reverse(str.begin(),str.end());\\n            if(str==s)\\n            return true;\\n        }\\n        // if(str.substr(1,str.size()-2).find(s)!=-1)\\n        // return true;\\n        return false;\\n    }\\n};\\n why this code is giving TLE ? \\nis the last executed input vilid ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very nice and simple string checking problem.\nAs a quick fail-fast tip, check if and only if the proposed window interval length divides the length of string s."
                    },
                    {
                        "username": "dark_coder_47",
                        "content": "finally monday easy\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "finally....... an easy question!"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I solved this using DP. Not the fastest over string rotation, but it works."
                    },
                    {
                        "username": "karanbangia14",
                        "content": "i am confused \"abcd\" is  a substring of \"abcd\", then in this case ideally all strings can be repeated, is there something else i should consider?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re missing the word \"multiple\" in the problem description, you need at least two copies of the subString:\\nGiven a string s, check if it can be constructed by taking a substring of it and appending `MULTIPLE` copies of the substring together."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "just check all the characters are repeated same time use maps brute force"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "No bro map solution won\\'t work \\nTake a example  \"abba\"\\nHere if we use map It will give TRUE as freq of a and b is 2.\\nBut answer is false. as   ab != ba"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "not at all easy"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "make it a string week, atleast then i will learn more string algos\\uD83D\\uDE29"
                    },
                    {
                        "username": "Braderbell",
                        "content": "makes me happy that it\\'s not a LeetCode hard graph problem again"
                    }
                ]
            },
            {
                "id": 2023815,
                "content": [
                    {
                        "username": "DeepakPalUPres",
                        "content": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\n        // cout<<s;\\n        string str=s;\\n        int n=str.size()/2;\\n        while(n--)\\n        {\\n            reverse(str.begin()+1,str.end());\\n            reverse(str.begin(),str.end());\\n            if(str==s)\\n            return true;\\n        }\\n        // if(str.substr(1,str.size()-2).find(s)!=-1)\\n        // return true;\\n        return false;\\n    }\\n};\\n why this code is giving TLE ? \\nis the last executed input vilid ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very nice and simple string checking problem.\nAs a quick fail-fast tip, check if and only if the proposed window interval length divides the length of string s."
                    },
                    {
                        "username": "dark_coder_47",
                        "content": "finally monday easy\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "finally....... an easy question!"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I solved this using DP. Not the fastest over string rotation, but it works."
                    },
                    {
                        "username": "karanbangia14",
                        "content": "i am confused \"abcd\" is  a substring of \"abcd\", then in this case ideally all strings can be repeated, is there something else i should consider?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re missing the word \"multiple\" in the problem description, you need at least two copies of the subString:\\nGiven a string s, check if it can be constructed by taking a substring of it and appending `MULTIPLE` copies of the substring together."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "just check all the characters are repeated same time use maps brute force"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "No bro map solution won\\'t work \\nTake a example  \"abba\"\\nHere if we use map It will give TRUE as freq of a and b is 2.\\nBut answer is false. as   ab != ba"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "not at all easy"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "make it a string week, atleast then i will learn more string algos\\uD83D\\uDE29"
                    },
                    {
                        "username": "Braderbell",
                        "content": "makes me happy that it\\'s not a LeetCode hard graph problem again"
                    }
                ]
            },
            {
                "id": 2023791,
                "content": [
                    {
                        "username": "DeepakPalUPres",
                        "content": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\n        // cout<<s;\\n        string str=s;\\n        int n=str.size()/2;\\n        while(n--)\\n        {\\n            reverse(str.begin()+1,str.end());\\n            reverse(str.begin(),str.end());\\n            if(str==s)\\n            return true;\\n        }\\n        // if(str.substr(1,str.size()-2).find(s)!=-1)\\n        // return true;\\n        return false;\\n    }\\n};\\n why this code is giving TLE ? \\nis the last executed input vilid ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very nice and simple string checking problem.\nAs a quick fail-fast tip, check if and only if the proposed window interval length divides the length of string s."
                    },
                    {
                        "username": "dark_coder_47",
                        "content": "finally monday easy\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "finally....... an easy question!"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I solved this using DP. Not the fastest over string rotation, but it works."
                    },
                    {
                        "username": "karanbangia14",
                        "content": "i am confused \"abcd\" is  a substring of \"abcd\", then in this case ideally all strings can be repeated, is there something else i should consider?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re missing the word \"multiple\" in the problem description, you need at least two copies of the subString:\\nGiven a string s, check if it can be constructed by taking a substring of it and appending `MULTIPLE` copies of the substring together."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "just check all the characters are repeated same time use maps brute force"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "No bro map solution won\\'t work \\nTake a example  \"abba\"\\nHere if we use map It will give TRUE as freq of a and b is 2.\\nBut answer is false. as   ab != ba"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "not at all easy"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "make it a string week, atleast then i will learn more string algos\\uD83D\\uDE29"
                    },
                    {
                        "username": "Braderbell",
                        "content": "makes me happy that it\\'s not a LeetCode hard graph problem again"
                    }
                ]
            },
            {
                "id": 2023782,
                "content": [
                    {
                        "username": "DeepakPalUPres",
                        "content": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\n        // cout<<s;\\n        string str=s;\\n        int n=str.size()/2;\\n        while(n--)\\n        {\\n            reverse(str.begin()+1,str.end());\\n            reverse(str.begin(),str.end());\\n            if(str==s)\\n            return true;\\n        }\\n        // if(str.substr(1,str.size()-2).find(s)!=-1)\\n        // return true;\\n        return false;\\n    }\\n};\\n why this code is giving TLE ? \\nis the last executed input vilid ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very nice and simple string checking problem.\nAs a quick fail-fast tip, check if and only if the proposed window interval length divides the length of string s."
                    },
                    {
                        "username": "dark_coder_47",
                        "content": "finally monday easy\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "finally....... an easy question!"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I solved this using DP. Not the fastest over string rotation, but it works."
                    },
                    {
                        "username": "karanbangia14",
                        "content": "i am confused \"abcd\" is  a substring of \"abcd\", then in this case ideally all strings can be repeated, is there something else i should consider?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re missing the word \"multiple\" in the problem description, you need at least two copies of the subString:\\nGiven a string s, check if it can be constructed by taking a substring of it and appending `MULTIPLE` copies of the substring together."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "just check all the characters are repeated same time use maps brute force"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "No bro map solution won\\'t work \\nTake a example  \"abba\"\\nHere if we use map It will give TRUE as freq of a and b is 2.\\nBut answer is false. as   ab != ba"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "not at all easy"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "make it a string week, atleast then i will learn more string algos\\uD83D\\uDE29"
                    },
                    {
                        "username": "Braderbell",
                        "content": "makes me happy that it\\'s not a LeetCode hard graph problem again"
                    }
                ]
            },
            {
                "id": 2023745,
                "content": [
                    {
                        "username": "DeepakPalUPres",
                        "content": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\n        // cout<<s;\\n        string str=s;\\n        int n=str.size()/2;\\n        while(n--)\\n        {\\n            reverse(str.begin()+1,str.end());\\n            reverse(str.begin(),str.end());\\n            if(str==s)\\n            return true;\\n        }\\n        // if(str.substr(1,str.size()-2).find(s)!=-1)\\n        // return true;\\n        return false;\\n    }\\n};\\n why this code is giving TLE ? \\nis the last executed input vilid ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very nice and simple string checking problem.\nAs a quick fail-fast tip, check if and only if the proposed window interval length divides the length of string s."
                    },
                    {
                        "username": "dark_coder_47",
                        "content": "finally monday easy\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "finally....... an easy question!"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I solved this using DP. Not the fastest over string rotation, but it works."
                    },
                    {
                        "username": "karanbangia14",
                        "content": "i am confused \"abcd\" is  a substring of \"abcd\", then in this case ideally all strings can be repeated, is there something else i should consider?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re missing the word \"multiple\" in the problem description, you need at least two copies of the subString:\\nGiven a string s, check if it can be constructed by taking a substring of it and appending `MULTIPLE` copies of the substring together."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "just check all the characters are repeated same time use maps brute force"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "No bro map solution won\\'t work \\nTake a example  \"abba\"\\nHere if we use map It will give TRUE as freq of a and b is 2.\\nBut answer is false. as   ab != ba"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "not at all easy"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "make it a string week, atleast then i will learn more string algos\\uD83D\\uDE29"
                    },
                    {
                        "username": "Braderbell",
                        "content": "makes me happy that it\\'s not a LeetCode hard graph problem again"
                    }
                ]
            },
            {
                "id": 2023588,
                "content": [
                    {
                        "username": "DeepakPalUPres",
                        "content": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\n        // cout<<s;\\n        string str=s;\\n        int n=str.size()/2;\\n        while(n--)\\n        {\\n            reverse(str.begin()+1,str.end());\\n            reverse(str.begin(),str.end());\\n            if(str==s)\\n            return true;\\n        }\\n        // if(str.substr(1,str.size()-2).find(s)!=-1)\\n        // return true;\\n        return false;\\n    }\\n};\\n why this code is giving TLE ? \\nis the last executed input vilid ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very nice and simple string checking problem.\nAs a quick fail-fast tip, check if and only if the proposed window interval length divides the length of string s."
                    },
                    {
                        "username": "dark_coder_47",
                        "content": "finally monday easy\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "finally....... an easy question!"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I solved this using DP. Not the fastest over string rotation, but it works."
                    },
                    {
                        "username": "karanbangia14",
                        "content": "i am confused \"abcd\" is  a substring of \"abcd\", then in this case ideally all strings can be repeated, is there something else i should consider?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re missing the word \"multiple\" in the problem description, you need at least two copies of the subString:\\nGiven a string s, check if it can be constructed by taking a substring of it and appending `MULTIPLE` copies of the substring together."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "just check all the characters are repeated same time use maps brute force"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "No bro map solution won\\'t work \\nTake a example  \"abba\"\\nHere if we use map It will give TRUE as freq of a and b is 2.\\nBut answer is false. as   ab != ba"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "not at all easy"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "make it a string week, atleast then i will learn more string algos\\uD83D\\uDE29"
                    },
                    {
                        "username": "Braderbell",
                        "content": "makes me happy that it\\'s not a LeetCode hard graph problem again"
                    }
                ]
            },
            {
                "id": 2023530,
                "content": [
                    {
                        "username": "DeepakPalUPres",
                        "content": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\n        // cout<<s;\\n        string str=s;\\n        int n=str.size()/2;\\n        while(n--)\\n        {\\n            reverse(str.begin()+1,str.end());\\n            reverse(str.begin(),str.end());\\n            if(str==s)\\n            return true;\\n        }\\n        // if(str.substr(1,str.size()-2).find(s)!=-1)\\n        // return true;\\n        return false;\\n    }\\n};\\n why this code is giving TLE ? \\nis the last executed input vilid ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very nice and simple string checking problem.\nAs a quick fail-fast tip, check if and only if the proposed window interval length divides the length of string s."
                    },
                    {
                        "username": "dark_coder_47",
                        "content": "finally monday easy\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "finally....... an easy question!"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I solved this using DP. Not the fastest over string rotation, but it works."
                    },
                    {
                        "username": "karanbangia14",
                        "content": "i am confused \"abcd\" is  a substring of \"abcd\", then in this case ideally all strings can be repeated, is there something else i should consider?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re missing the word \"multiple\" in the problem description, you need at least two copies of the subString:\\nGiven a string s, check if it can be constructed by taking a substring of it and appending `MULTIPLE` copies of the substring together."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "just check all the characters are repeated same time use maps brute force"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "No bro map solution won\\'t work \\nTake a example  \"abba\"\\nHere if we use map It will give TRUE as freq of a and b is 2.\\nBut answer is false. as   ab != ba"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "not at all easy"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "make it a string week, atleast then i will learn more string algos\\uD83D\\uDE29"
                    },
                    {
                        "username": "Braderbell",
                        "content": "makes me happy that it\\'s not a LeetCode hard graph problem again"
                    }
                ]
            },
            {
                "id": 2023522,
                "content": [
                    {
                        "username": "DeepakPalUPres",
                        "content": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\n        // cout<<s;\\n        string str=s;\\n        int n=str.size()/2;\\n        while(n--)\\n        {\\n            reverse(str.begin()+1,str.end());\\n            reverse(str.begin(),str.end());\\n            if(str==s)\\n            return true;\\n        }\\n        // if(str.substr(1,str.size()-2).find(s)!=-1)\\n        // return true;\\n        return false;\\n    }\\n};\\n why this code is giving TLE ? \\nis the last executed input vilid ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very nice and simple string checking problem.\nAs a quick fail-fast tip, check if and only if the proposed window interval length divides the length of string s."
                    },
                    {
                        "username": "dark_coder_47",
                        "content": "finally monday easy\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "finally....... an easy question!"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I solved this using DP. Not the fastest over string rotation, but it works."
                    },
                    {
                        "username": "karanbangia14",
                        "content": "i am confused \"abcd\" is  a substring of \"abcd\", then in this case ideally all strings can be repeated, is there something else i should consider?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re missing the word \"multiple\" in the problem description, you need at least two copies of the subString:\\nGiven a string s, check if it can be constructed by taking a substring of it and appending `MULTIPLE` copies of the substring together."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "just check all the characters are repeated same time use maps brute force"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "No bro map solution won\\'t work \\nTake a example  \"abba\"\\nHere if we use map It will give TRUE as freq of a and b is 2.\\nBut answer is false. as   ab != ba"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "not at all easy"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "make it a string week, atleast then i will learn more string algos\\uD83D\\uDE29"
                    },
                    {
                        "username": "Braderbell",
                        "content": "makes me happy that it\\'s not a LeetCode hard graph problem again"
                    }
                ]
            },
            {
                "id": 2023400,
                "content": [
                    {
                        "username": "DeepakPalUPres",
                        "content": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\n        // cout<<s;\\n        string str=s;\\n        int n=str.size()/2;\\n        while(n--)\\n        {\\n            reverse(str.begin()+1,str.end());\\n            reverse(str.begin(),str.end());\\n            if(str==s)\\n            return true;\\n        }\\n        // if(str.substr(1,str.size()-2).find(s)!=-1)\\n        // return true;\\n        return false;\\n    }\\n};\\n why this code is giving TLE ? \\nis the last executed input vilid ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very nice and simple string checking problem.\nAs a quick fail-fast tip, check if and only if the proposed window interval length divides the length of string s."
                    },
                    {
                        "username": "dark_coder_47",
                        "content": "finally monday easy\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "finally....... an easy question!"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I solved this using DP. Not the fastest over string rotation, but it works."
                    },
                    {
                        "username": "karanbangia14",
                        "content": "i am confused \"abcd\" is  a substring of \"abcd\", then in this case ideally all strings can be repeated, is there something else i should consider?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re missing the word \"multiple\" in the problem description, you need at least two copies of the subString:\\nGiven a string s, check if it can be constructed by taking a substring of it and appending `MULTIPLE` copies of the substring together."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "just check all the characters are repeated same time use maps brute force"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "No bro map solution won\\'t work \\nTake a example  \"abba\"\\nHere if we use map It will give TRUE as freq of a and b is 2.\\nBut answer is false. as   ab != ba"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "not at all easy"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "make it a string week, atleast then i will learn more string algos\\uD83D\\uDE29"
                    },
                    {
                        "username": "Braderbell",
                        "content": "makes me happy that it\\'s not a LeetCode hard graph problem again"
                    }
                ]
            },
            {
                "id": 2023348,
                "content": [
                    {
                        "username": "DeepakPalUPres",
                        "content": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\n        // cout<<s;\\n        string str=s;\\n        int n=str.size()/2;\\n        while(n--)\\n        {\\n            reverse(str.begin()+1,str.end());\\n            reverse(str.begin(),str.end());\\n            if(str==s)\\n            return true;\\n        }\\n        // if(str.substr(1,str.size()-2).find(s)!=-1)\\n        // return true;\\n        return false;\\n    }\\n};\\n why this code is giving TLE ? \\nis the last executed input vilid ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very nice and simple string checking problem.\nAs a quick fail-fast tip, check if and only if the proposed window interval length divides the length of string s."
                    },
                    {
                        "username": "dark_coder_47",
                        "content": "finally monday easy\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "finally....... an easy question!"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I solved this using DP. Not the fastest over string rotation, but it works."
                    },
                    {
                        "username": "karanbangia14",
                        "content": "i am confused \"abcd\" is  a substring of \"abcd\", then in this case ideally all strings can be repeated, is there something else i should consider?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re missing the word \"multiple\" in the problem description, you need at least two copies of the subString:\\nGiven a string s, check if it can be constructed by taking a substring of it and appending `MULTIPLE` copies of the substring together."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "just check all the characters are repeated same time use maps brute force"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "No bro map solution won\\'t work \\nTake a example  \"abba\"\\nHere if we use map It will give TRUE as freq of a and b is 2.\\nBut answer is false. as   ab != ba"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "not at all easy"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "make it a string week, atleast then i will learn more string algos\\uD83D\\uDE29"
                    },
                    {
                        "username": "Braderbell",
                        "content": "makes me happy that it\\'s not a LeetCode hard graph problem again"
                    }
                ]
            },
            {
                "id": 2023337,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the 2nd method in the editorial runs on voodoo"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Finally.. a problem I can read in one go\\n"
                    },
                    {
                        "username": "itbaaN",
                        "content": "guys can u tell me why the test case that starts with \"qtpddbuotbbqcwivrf......\"(10000 letters) is returning false.\\ni have debug my code and i think its working fine bc i did find a pattern in this input (pattern repeated after each 100 letters). My code is giving me true bc there is a pattern in the string but for some reason the answer is false.\\n\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "babbabbabbabbab -> is 15 characters how can it be that it\\'s repeated?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "that is because it is a pattern of bab"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@user9962Xz](/user9962Xz) Yes, check for each length 1->(n/2)\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "oh, \"bab\""
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem doesn\\'t feel easy to me, if it accepts brute force, checking each substring against the whole string it might justify the tag, but in the real world nobody implements like that."
                    },
                    {
                        "username": "abhinavchandel_01",
                        "content": "\"ababababababaababababababaababababababa\" \\n\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        deque<int>dq;\\n        for( int i = 0 ; i < s.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n\\n        if(dq.size() > s.size()/2) return false;\\n        int prevSize = dq.size();\\n        for( int i = 0 ; i < s.size()-dq.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n        if( prevSize != dq.size()) return false;\\n        return true;\\n    }\\n};\\n\\n\\ni have written o(n) solution using deque  it passess 127 test cases  out of 129 \\n\"ababababababaababababababaababababababa\"  in this test case i found bababa as residue in deque ... plzzz reply \\n\\n"
                    },
                    {
                        "username": "Vide_Walter",
                        "content": "So, I did it in this way: \\nfor each i = (string.length)/2 to i = 1 check if length%i == 0, if yes take the first i characters (using substr method) and append them length/i times to make a new string and check whether the string formed is equal to the input string.\\nBut I have a doubt in it I think the time complexity of this solution is O(N^2) because of the inner substr method and for appending operations. But the T.C by this method is given as O(N) on various blogs and platforms.\\nplease clarify help would be greatly appreciated \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "\"abaababaab\" this case is returning false by this method"
                    },
                    {
                        "username": "DimanNe",
                        "content": "This should be marked as HARD.\n\nNone of the solutions (apart from the brute-force one) is EASY. But it is unlikely that Google will be OK with the brute-force one."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Duplicate the string and store it\\nUse substring (start index ,last index of string)"
                    },
                    {
                        "username": "AndyYangMa",
                        "content": "Why cannot use string1.equals(string2) in Java. "
                    }
                ]
            },
            {
                "id": 2023332,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the 2nd method in the editorial runs on voodoo"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Finally.. a problem I can read in one go\\n"
                    },
                    {
                        "username": "itbaaN",
                        "content": "guys can u tell me why the test case that starts with \"qtpddbuotbbqcwivrf......\"(10000 letters) is returning false.\\ni have debug my code and i think its working fine bc i did find a pattern in this input (pattern repeated after each 100 letters). My code is giving me true bc there is a pattern in the string but for some reason the answer is false.\\n\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "babbabbabbabbab -> is 15 characters how can it be that it\\'s repeated?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "that is because it is a pattern of bab"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@user9962Xz](/user9962Xz) Yes, check for each length 1->(n/2)\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "oh, \"bab\""
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem doesn\\'t feel easy to me, if it accepts brute force, checking each substring against the whole string it might justify the tag, but in the real world nobody implements like that."
                    },
                    {
                        "username": "abhinavchandel_01",
                        "content": "\"ababababababaababababababaababababababa\" \\n\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        deque<int>dq;\\n        for( int i = 0 ; i < s.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n\\n        if(dq.size() > s.size()/2) return false;\\n        int prevSize = dq.size();\\n        for( int i = 0 ; i < s.size()-dq.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n        if( prevSize != dq.size()) return false;\\n        return true;\\n    }\\n};\\n\\n\\ni have written o(n) solution using deque  it passess 127 test cases  out of 129 \\n\"ababababababaababababababaababababababa\"  in this test case i found bababa as residue in deque ... plzzz reply \\n\\n"
                    },
                    {
                        "username": "Vide_Walter",
                        "content": "So, I did it in this way: \\nfor each i = (string.length)/2 to i = 1 check if length%i == 0, if yes take the first i characters (using substr method) and append them length/i times to make a new string and check whether the string formed is equal to the input string.\\nBut I have a doubt in it I think the time complexity of this solution is O(N^2) because of the inner substr method and for appending operations. But the T.C by this method is given as O(N) on various blogs and platforms.\\nplease clarify help would be greatly appreciated \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "\"abaababaab\" this case is returning false by this method"
                    },
                    {
                        "username": "DimanNe",
                        "content": "This should be marked as HARD.\n\nNone of the solutions (apart from the brute-force one) is EASY. But it is unlikely that Google will be OK with the brute-force one."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Duplicate the string and store it\\nUse substring (start index ,last index of string)"
                    },
                    {
                        "username": "AndyYangMa",
                        "content": "Why cannot use string1.equals(string2) in Java. "
                    }
                ]
            },
            {
                "id": 1980883,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the 2nd method in the editorial runs on voodoo"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Finally.. a problem I can read in one go\\n"
                    },
                    {
                        "username": "itbaaN",
                        "content": "guys can u tell me why the test case that starts with \"qtpddbuotbbqcwivrf......\"(10000 letters) is returning false.\\ni have debug my code and i think its working fine bc i did find a pattern in this input (pattern repeated after each 100 letters). My code is giving me true bc there is a pattern in the string but for some reason the answer is false.\\n\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "babbabbabbabbab -> is 15 characters how can it be that it\\'s repeated?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "that is because it is a pattern of bab"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@user9962Xz](/user9962Xz) Yes, check for each length 1->(n/2)\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "oh, \"bab\""
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem doesn\\'t feel easy to me, if it accepts brute force, checking each substring against the whole string it might justify the tag, but in the real world nobody implements like that."
                    },
                    {
                        "username": "abhinavchandel_01",
                        "content": "\"ababababababaababababababaababababababa\" \\n\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        deque<int>dq;\\n        for( int i = 0 ; i < s.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n\\n        if(dq.size() > s.size()/2) return false;\\n        int prevSize = dq.size();\\n        for( int i = 0 ; i < s.size()-dq.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n        if( prevSize != dq.size()) return false;\\n        return true;\\n    }\\n};\\n\\n\\ni have written o(n) solution using deque  it passess 127 test cases  out of 129 \\n\"ababababababaababababababaababababababa\"  in this test case i found bababa as residue in deque ... plzzz reply \\n\\n"
                    },
                    {
                        "username": "Vide_Walter",
                        "content": "So, I did it in this way: \\nfor each i = (string.length)/2 to i = 1 check if length%i == 0, if yes take the first i characters (using substr method) and append them length/i times to make a new string and check whether the string formed is equal to the input string.\\nBut I have a doubt in it I think the time complexity of this solution is O(N^2) because of the inner substr method and for appending operations. But the T.C by this method is given as O(N) on various blogs and platforms.\\nplease clarify help would be greatly appreciated \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "\"abaababaab\" this case is returning false by this method"
                    },
                    {
                        "username": "DimanNe",
                        "content": "This should be marked as HARD.\n\nNone of the solutions (apart from the brute-force one) is EASY. But it is unlikely that Google will be OK with the brute-force one."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Duplicate the string and store it\\nUse substring (start index ,last index of string)"
                    },
                    {
                        "username": "AndyYangMa",
                        "content": "Why cannot use string1.equals(string2) in Java. "
                    }
                ]
            },
            {
                "id": 1962710,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the 2nd method in the editorial runs on voodoo"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Finally.. a problem I can read in one go\\n"
                    },
                    {
                        "username": "itbaaN",
                        "content": "guys can u tell me why the test case that starts with \"qtpddbuotbbqcwivrf......\"(10000 letters) is returning false.\\ni have debug my code and i think its working fine bc i did find a pattern in this input (pattern repeated after each 100 letters). My code is giving me true bc there is a pattern in the string but for some reason the answer is false.\\n\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "babbabbabbabbab -> is 15 characters how can it be that it\\'s repeated?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "that is because it is a pattern of bab"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@user9962Xz](/user9962Xz) Yes, check for each length 1->(n/2)\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "oh, \"bab\""
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem doesn\\'t feel easy to me, if it accepts brute force, checking each substring against the whole string it might justify the tag, but in the real world nobody implements like that."
                    },
                    {
                        "username": "abhinavchandel_01",
                        "content": "\"ababababababaababababababaababababababa\" \\n\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        deque<int>dq;\\n        for( int i = 0 ; i < s.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n\\n        if(dq.size() > s.size()/2) return false;\\n        int prevSize = dq.size();\\n        for( int i = 0 ; i < s.size()-dq.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n        if( prevSize != dq.size()) return false;\\n        return true;\\n    }\\n};\\n\\n\\ni have written o(n) solution using deque  it passess 127 test cases  out of 129 \\n\"ababababababaababababababaababababababa\"  in this test case i found bababa as residue in deque ... plzzz reply \\n\\n"
                    },
                    {
                        "username": "Vide_Walter",
                        "content": "So, I did it in this way: \\nfor each i = (string.length)/2 to i = 1 check if length%i == 0, if yes take the first i characters (using substr method) and append them length/i times to make a new string and check whether the string formed is equal to the input string.\\nBut I have a doubt in it I think the time complexity of this solution is O(N^2) because of the inner substr method and for appending operations. But the T.C by this method is given as O(N) on various blogs and platforms.\\nplease clarify help would be greatly appreciated \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "\"abaababaab\" this case is returning false by this method"
                    },
                    {
                        "username": "DimanNe",
                        "content": "This should be marked as HARD.\n\nNone of the solutions (apart from the brute-force one) is EASY. But it is unlikely that Google will be OK with the brute-force one."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Duplicate the string and store it\\nUse substring (start index ,last index of string)"
                    },
                    {
                        "username": "AndyYangMa",
                        "content": "Why cannot use string1.equals(string2) in Java. "
                    }
                ]
            },
            {
                "id": 1941386,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the 2nd method in the editorial runs on voodoo"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Finally.. a problem I can read in one go\\n"
                    },
                    {
                        "username": "itbaaN",
                        "content": "guys can u tell me why the test case that starts with \"qtpddbuotbbqcwivrf......\"(10000 letters) is returning false.\\ni have debug my code and i think its working fine bc i did find a pattern in this input (pattern repeated after each 100 letters). My code is giving me true bc there is a pattern in the string but for some reason the answer is false.\\n\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "babbabbabbabbab -> is 15 characters how can it be that it\\'s repeated?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "that is because it is a pattern of bab"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@user9962Xz](/user9962Xz) Yes, check for each length 1->(n/2)\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "oh, \"bab\""
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem doesn\\'t feel easy to me, if it accepts brute force, checking each substring against the whole string it might justify the tag, but in the real world nobody implements like that."
                    },
                    {
                        "username": "abhinavchandel_01",
                        "content": "\"ababababababaababababababaababababababa\" \\n\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        deque<int>dq;\\n        for( int i = 0 ; i < s.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n\\n        if(dq.size() > s.size()/2) return false;\\n        int prevSize = dq.size();\\n        for( int i = 0 ; i < s.size()-dq.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n        if( prevSize != dq.size()) return false;\\n        return true;\\n    }\\n};\\n\\n\\ni have written o(n) solution using deque  it passess 127 test cases  out of 129 \\n\"ababababababaababababababaababababababa\"  in this test case i found bababa as residue in deque ... plzzz reply \\n\\n"
                    },
                    {
                        "username": "Vide_Walter",
                        "content": "So, I did it in this way: \\nfor each i = (string.length)/2 to i = 1 check if length%i == 0, if yes take the first i characters (using substr method) and append them length/i times to make a new string and check whether the string formed is equal to the input string.\\nBut I have a doubt in it I think the time complexity of this solution is O(N^2) because of the inner substr method and for appending operations. But the T.C by this method is given as O(N) on various blogs and platforms.\\nplease clarify help would be greatly appreciated \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "\"abaababaab\" this case is returning false by this method"
                    },
                    {
                        "username": "DimanNe",
                        "content": "This should be marked as HARD.\n\nNone of the solutions (apart from the brute-force one) is EASY. But it is unlikely that Google will be OK with the brute-force one."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Duplicate the string and store it\\nUse substring (start index ,last index of string)"
                    },
                    {
                        "username": "AndyYangMa",
                        "content": "Why cannot use string1.equals(string2) in Java. "
                    }
                ]
            },
            {
                "id": 1931546,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the 2nd method in the editorial runs on voodoo"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Finally.. a problem I can read in one go\\n"
                    },
                    {
                        "username": "itbaaN",
                        "content": "guys can u tell me why the test case that starts with \"qtpddbuotbbqcwivrf......\"(10000 letters) is returning false.\\ni have debug my code and i think its working fine bc i did find a pattern in this input (pattern repeated after each 100 letters). My code is giving me true bc there is a pattern in the string but for some reason the answer is false.\\n\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "babbabbabbabbab -> is 15 characters how can it be that it\\'s repeated?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "that is because it is a pattern of bab"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@user9962Xz](/user9962Xz) Yes, check for each length 1->(n/2)\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "oh, \"bab\""
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem doesn\\'t feel easy to me, if it accepts brute force, checking each substring against the whole string it might justify the tag, but in the real world nobody implements like that."
                    },
                    {
                        "username": "abhinavchandel_01",
                        "content": "\"ababababababaababababababaababababababa\" \\n\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        deque<int>dq;\\n        for( int i = 0 ; i < s.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n\\n        if(dq.size() > s.size()/2) return false;\\n        int prevSize = dq.size();\\n        for( int i = 0 ; i < s.size()-dq.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n        if( prevSize != dq.size()) return false;\\n        return true;\\n    }\\n};\\n\\n\\ni have written o(n) solution using deque  it passess 127 test cases  out of 129 \\n\"ababababababaababababababaababababababa\"  in this test case i found bababa as residue in deque ... plzzz reply \\n\\n"
                    },
                    {
                        "username": "Vide_Walter",
                        "content": "So, I did it in this way: \\nfor each i = (string.length)/2 to i = 1 check if length%i == 0, if yes take the first i characters (using substr method) and append them length/i times to make a new string and check whether the string formed is equal to the input string.\\nBut I have a doubt in it I think the time complexity of this solution is O(N^2) because of the inner substr method and for appending operations. But the T.C by this method is given as O(N) on various blogs and platforms.\\nplease clarify help would be greatly appreciated \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "\"abaababaab\" this case is returning false by this method"
                    },
                    {
                        "username": "DimanNe",
                        "content": "This should be marked as HARD.\n\nNone of the solutions (apart from the brute-force one) is EASY. But it is unlikely that Google will be OK with the brute-force one."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Duplicate the string and store it\\nUse substring (start index ,last index of string)"
                    },
                    {
                        "username": "AndyYangMa",
                        "content": "Why cannot use string1.equals(string2) in Java. "
                    }
                ]
            },
            {
                "id": 1922424,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the 2nd method in the editorial runs on voodoo"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Finally.. a problem I can read in one go\\n"
                    },
                    {
                        "username": "itbaaN",
                        "content": "guys can u tell me why the test case that starts with \"qtpddbuotbbqcwivrf......\"(10000 letters) is returning false.\\ni have debug my code and i think its working fine bc i did find a pattern in this input (pattern repeated after each 100 letters). My code is giving me true bc there is a pattern in the string but for some reason the answer is false.\\n\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "babbabbabbabbab -> is 15 characters how can it be that it\\'s repeated?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "that is because it is a pattern of bab"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@user9962Xz](/user9962Xz) Yes, check for each length 1->(n/2)\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "oh, \"bab\""
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem doesn\\'t feel easy to me, if it accepts brute force, checking each substring against the whole string it might justify the tag, but in the real world nobody implements like that."
                    },
                    {
                        "username": "abhinavchandel_01",
                        "content": "\"ababababababaababababababaababababababa\" \\n\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        deque<int>dq;\\n        for( int i = 0 ; i < s.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n\\n        if(dq.size() > s.size()/2) return false;\\n        int prevSize = dq.size();\\n        for( int i = 0 ; i < s.size()-dq.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n        if( prevSize != dq.size()) return false;\\n        return true;\\n    }\\n};\\n\\n\\ni have written o(n) solution using deque  it passess 127 test cases  out of 129 \\n\"ababababababaababababababaababababababa\"  in this test case i found bababa as residue in deque ... plzzz reply \\n\\n"
                    },
                    {
                        "username": "Vide_Walter",
                        "content": "So, I did it in this way: \\nfor each i = (string.length)/2 to i = 1 check if length%i == 0, if yes take the first i characters (using substr method) and append them length/i times to make a new string and check whether the string formed is equal to the input string.\\nBut I have a doubt in it I think the time complexity of this solution is O(N^2) because of the inner substr method and for appending operations. But the T.C by this method is given as O(N) on various blogs and platforms.\\nplease clarify help would be greatly appreciated \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "\"abaababaab\" this case is returning false by this method"
                    },
                    {
                        "username": "DimanNe",
                        "content": "This should be marked as HARD.\n\nNone of the solutions (apart from the brute-force one) is EASY. But it is unlikely that Google will be OK with the brute-force one."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Duplicate the string and store it\\nUse substring (start index ,last index of string)"
                    },
                    {
                        "username": "AndyYangMa",
                        "content": "Why cannot use string1.equals(string2) in Java. "
                    }
                ]
            },
            {
                "id": 1901039,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the 2nd method in the editorial runs on voodoo"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Finally.. a problem I can read in one go\\n"
                    },
                    {
                        "username": "itbaaN",
                        "content": "guys can u tell me why the test case that starts with \"qtpddbuotbbqcwivrf......\"(10000 letters) is returning false.\\ni have debug my code and i think its working fine bc i did find a pattern in this input (pattern repeated after each 100 letters). My code is giving me true bc there is a pattern in the string but for some reason the answer is false.\\n\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "babbabbabbabbab -> is 15 characters how can it be that it\\'s repeated?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "that is because it is a pattern of bab"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@user9962Xz](/user9962Xz) Yes, check for each length 1->(n/2)\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "oh, \"bab\""
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem doesn\\'t feel easy to me, if it accepts brute force, checking each substring against the whole string it might justify the tag, but in the real world nobody implements like that."
                    },
                    {
                        "username": "abhinavchandel_01",
                        "content": "\"ababababababaababababababaababababababa\" \\n\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        deque<int>dq;\\n        for( int i = 0 ; i < s.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n\\n        if(dq.size() > s.size()/2) return false;\\n        int prevSize = dq.size();\\n        for( int i = 0 ; i < s.size()-dq.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n        if( prevSize != dq.size()) return false;\\n        return true;\\n    }\\n};\\n\\n\\ni have written o(n) solution using deque  it passess 127 test cases  out of 129 \\n\"ababababababaababababababaababababababa\"  in this test case i found bababa as residue in deque ... plzzz reply \\n\\n"
                    },
                    {
                        "username": "Vide_Walter",
                        "content": "So, I did it in this way: \\nfor each i = (string.length)/2 to i = 1 check if length%i == 0, if yes take the first i characters (using substr method) and append them length/i times to make a new string and check whether the string formed is equal to the input string.\\nBut I have a doubt in it I think the time complexity of this solution is O(N^2) because of the inner substr method and for appending operations. But the T.C by this method is given as O(N) on various blogs and platforms.\\nplease clarify help would be greatly appreciated \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "\"abaababaab\" this case is returning false by this method"
                    },
                    {
                        "username": "DimanNe",
                        "content": "This should be marked as HARD.\n\nNone of the solutions (apart from the brute-force one) is EASY. But it is unlikely that Google will be OK with the brute-force one."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Duplicate the string and store it\\nUse substring (start index ,last index of string)"
                    },
                    {
                        "username": "AndyYangMa",
                        "content": "Why cannot use string1.equals(string2) in Java. "
                    }
                ]
            },
            {
                "id": 1805079,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the 2nd method in the editorial runs on voodoo"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Finally.. a problem I can read in one go\\n"
                    },
                    {
                        "username": "itbaaN",
                        "content": "guys can u tell me why the test case that starts with \"qtpddbuotbbqcwivrf......\"(10000 letters) is returning false.\\ni have debug my code and i think its working fine bc i did find a pattern in this input (pattern repeated after each 100 letters). My code is giving me true bc there is a pattern in the string but for some reason the answer is false.\\n\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "babbabbabbabbab -> is 15 characters how can it be that it\\'s repeated?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "that is because it is a pattern of bab"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@user9962Xz](/user9962Xz) Yes, check for each length 1->(n/2)\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "oh, \"bab\""
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem doesn\\'t feel easy to me, if it accepts brute force, checking each substring against the whole string it might justify the tag, but in the real world nobody implements like that."
                    },
                    {
                        "username": "abhinavchandel_01",
                        "content": "\"ababababababaababababababaababababababa\" \\n\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        deque<int>dq;\\n        for( int i = 0 ; i < s.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n\\n        if(dq.size() > s.size()/2) return false;\\n        int prevSize = dq.size();\\n        for( int i = 0 ; i < s.size()-dq.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n        if( prevSize != dq.size()) return false;\\n        return true;\\n    }\\n};\\n\\n\\ni have written o(n) solution using deque  it passess 127 test cases  out of 129 \\n\"ababababababaababababababaababababababa\"  in this test case i found bababa as residue in deque ... plzzz reply \\n\\n"
                    },
                    {
                        "username": "Vide_Walter",
                        "content": "So, I did it in this way: \\nfor each i = (string.length)/2 to i = 1 check if length%i == 0, if yes take the first i characters (using substr method) and append them length/i times to make a new string and check whether the string formed is equal to the input string.\\nBut I have a doubt in it I think the time complexity of this solution is O(N^2) because of the inner substr method and for appending operations. But the T.C by this method is given as O(N) on various blogs and platforms.\\nplease clarify help would be greatly appreciated \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "\"abaababaab\" this case is returning false by this method"
                    },
                    {
                        "username": "DimanNe",
                        "content": "This should be marked as HARD.\n\nNone of the solutions (apart from the brute-force one) is EASY. But it is unlikely that Google will be OK with the brute-force one."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Duplicate the string and store it\\nUse substring (start index ,last index of string)"
                    },
                    {
                        "username": "AndyYangMa",
                        "content": "Why cannot use string1.equals(string2) in Java. "
                    }
                ]
            },
            {
                "id": 1782308,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the 2nd method in the editorial runs on voodoo"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Finally.. a problem I can read in one go\\n"
                    },
                    {
                        "username": "itbaaN",
                        "content": "guys can u tell me why the test case that starts with \"qtpddbuotbbqcwivrf......\"(10000 letters) is returning false.\\ni have debug my code and i think its working fine bc i did find a pattern in this input (pattern repeated after each 100 letters). My code is giving me true bc there is a pattern in the string but for some reason the answer is false.\\n\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "babbabbabbabbab -> is 15 characters how can it be that it\\'s repeated?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "that is because it is a pattern of bab"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@user9962Xz](/user9962Xz) Yes, check for each length 1->(n/2)\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "oh, \"bab\""
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem doesn\\'t feel easy to me, if it accepts brute force, checking each substring against the whole string it might justify the tag, but in the real world nobody implements like that."
                    },
                    {
                        "username": "abhinavchandel_01",
                        "content": "\"ababababababaababababababaababababababa\" \\n\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        deque<int>dq;\\n        for( int i = 0 ; i < s.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n\\n        if(dq.size() > s.size()/2) return false;\\n        int prevSize = dq.size();\\n        for( int i = 0 ; i < s.size()-dq.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n        if( prevSize != dq.size()) return false;\\n        return true;\\n    }\\n};\\n\\n\\ni have written o(n) solution using deque  it passess 127 test cases  out of 129 \\n\"ababababababaababababababaababababababa\"  in this test case i found bababa as residue in deque ... plzzz reply \\n\\n"
                    },
                    {
                        "username": "Vide_Walter",
                        "content": "So, I did it in this way: \\nfor each i = (string.length)/2 to i = 1 check if length%i == 0, if yes take the first i characters (using substr method) and append them length/i times to make a new string and check whether the string formed is equal to the input string.\\nBut I have a doubt in it I think the time complexity of this solution is O(N^2) because of the inner substr method and for appending operations. But the T.C by this method is given as O(N) on various blogs and platforms.\\nplease clarify help would be greatly appreciated \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "\"abaababaab\" this case is returning false by this method"
                    },
                    {
                        "username": "DimanNe",
                        "content": "This should be marked as HARD.\n\nNone of the solutions (apart from the brute-force one) is EASY. But it is unlikely that Google will be OK with the brute-force one."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Duplicate the string and store it\\nUse substring (start index ,last index of string)"
                    },
                    {
                        "username": "AndyYangMa",
                        "content": "Why cannot use string1.equals(string2) in Java. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Depth of N-ary Tree",
        "question_content": "<p>Given a n-ary tree, find its maximum depth.</p>\n\n<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\n\n<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,3,2,4,null,5,6]\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"width: 296px; height: 241px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>Output:</strong> 5\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The total number of nodes is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li>The depth of the n-ary tree is less than or equal to <code>1000</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 183060,
                "title": "java-bfs-iterative-solution",
                "content": "    public int maxDepth(Node root) {\n        if(root == null) return 0;\n        \n        Queue<Node> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        int depth = 0;\n        \n        while(!queue.isEmpty())\n        {\n            int size = queue.size();\n            \n            for(int i = 0; i < size; i++)\n            {\n                Node current = queue.poll();\n                for(Node child: current.children) queue.offer(child);\n            }\n            \n            depth++;\n        }\n        \n        return depth;\n    }",
                "solutionTags": [],
                "code": "    public int maxDepth(Node root) {\n        if(root == null) return 0;\n        Queue<Node> queue = new LinkedList<>();\n        queue.offer(root);\n        int depth = 0;\n        while(!queue.isEmpty())\n        {\n            int size = queue.size();\n            for(int i = 0; i < size; i++)\n            {\n                Node current = queue.poll();\n                for(Node child: current.children) queue.offer(child);\n            }\n            depth++;\n        }\n        return depth;\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 167010,
                "title": "dfs-bfs-solutions-in-c",
                "content": "Recursive DFS:\\n```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (root == nullptr) return 0;\\n        int depth = 0;\\n        for (auto child : root->children) depth = max(depth, maxDepth(child));\\n        return 1 + depth;\\n    }\\n};\\n```\\n\\nRecursive DFS without raw loops:\\n```\\nclass Solution {\\npublic:\\n    static int maxDepth(Node* root) {\\n        if (root == nullptr) return 0;\\n        return 1 + transform_reduce(begin(root->children), end(root->children), 0, [](int acc, int d) { return max(acc, d); }, [](auto* node) { return maxDepth(node); });\\n    }\\n};\\n```\\n\\nRecursive DFS one-liner:\\n```\\nclass Solution {\\npublic:\\n    static int maxDepth(Node* root) {\\n        return root ? 1 + transform_reduce(begin(root->children), end(root->children), 0, [](int acc, int d) { return max(acc, d); }, [](auto* node) { return maxDepth(node); }) : 0;\\n    }\\n};\\n```\\n\\nBFS:\\n```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (root == nullptr) return 0;\\n        queue<Node*> q; q.push(root);\\n        int depth = 0;\\n        while (!q.empty()) {\\n            depth += 1;\\n            int breadth = q.size();\\n            for (int _ = 0; _ < breadth; ++_) {\\n                auto node = q.front(); q.pop();\\n                for (auto child : node->children) if (child) q.push(child);\\n            }\\n        }\\n        return depth;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (root == nullptr) return 0;\\n        int depth = 0;\\n        for (auto child : root->children) depth = max(depth, maxDepth(child));\\n        return 1 + depth;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    static int maxDepth(Node* root) {\\n        if (root == nullptr) return 0;\\n        return 1 + transform_reduce(begin(root->children), end(root->children), 0, [](int acc, int d) { return max(acc, d); }, [](auto* node) { return maxDepth(node); });\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    static int maxDepth(Node* root) {\\n        return root ? 1 + transform_reduce(begin(root->children), end(root->children), 0, [](int acc, int d) { return max(acc, d); }, [](auto* node) { return maxDepth(node); }) : 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (root == nullptr) return 0;\\n        queue<Node*> q; q.push(root);\\n        int depth = 0;\\n        while (!q.empty()) {\\n            depth += 1;\\n            int breadth = q.size();\\n            for (int _ = 0; _ < breadth; ++_) {\\n                auto node = q.front(); q.pop();\\n                for (auto child : node->children) if (child) q.push(child);\\n            }\\n        }\\n        return depth;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 275725,
                "title": "python-dfs-solution-with-explanation",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, children):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        # Base case\\n        if root == None:\\n            return 0\\n        # Depth level of the tree\\n        depth = 0\\n        \\n        # Loops through children array\\n        for child in root.children:\\n            # Compares current depth of depth with a new level of depth \\n            # Sets the biggest value to variable depth\\n            depth = max(depth, self.maxDepth(child))\\n        \\n        # As going deeper into the tree increases depth by 1\\n        print (\\'root \\' + str(root.val) + \\' depth \\' + str(depth + 1))\\n        return depth + 1 \\n    \\n    # So for the first test case it\\'ll look like\\n    # first call is the call with root 1\\n    # depth = 0 -> second call with child 3 -> \\n    # it has 2 children so there\\'ll be two calls from for loop\\n    # call with child 5 -> sets the for loop with child of 5 which is None (Null)\\n    # this call hits base case and returns 0\\n    # the same happens with child 6\\n    # call to child 6 from the for loop -> child of 6 is None -> returns 0\\n    # depth = max(0, 0) -> depth = 0\\n    # return to one level higher -> call to child 5 reaches return statement ->\\n    # depth = 1\\n    # call to child 6 reaches return statement and it returns 1 ->\\n    # current depth is 1 because child 5 set it -> max(1, 1) -> depth = 1\\n    # return to one more level higher\\n    # call to child 3 reaches return statement ->\\n    # depth was equal to 1 now it becomes 2 (depth + 1)\\n    # now it\\'s turn to children 2 and 4 to be called\\n    # the story is exactly the same as with 5 and 6 only depth is now 2 ->\\n    # both 2 and 4 return depth 1 that\\'s why it\\'s rejected by max(2, 1)\\n    # depth remains 2\\n    # and finally everything returns to the very first call with root 1 \\n    # it reaches return statement and returns 2+1=3\\n```\\n\\nI hope it\\'ll help! \\nRecursion is difficult for me. It usually takes hours to solve a problem or wrap my head around a solution that other people post.",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, children):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        # Base case\\n        if root == None:\\n            return 0\\n        # Depth level of the tree\\n        depth = 0\\n        \\n        # Loops through children array\\n        for child in root.children:\\n            # Compares current depth of depth with a new level of depth \\n            # Sets the biggest value to variable depth\\n            depth = max(depth, self.maxDepth(child))\\n        \\n        # As going deeper into the tree increases depth by 1\\n        print (\\'root \\' + str(root.val) + \\' depth \\' + str(depth + 1))\\n        return depth + 1 \\n    \\n    # So for the first test case it\\'ll look like\\n    # first call is the call with root 1\\n    # depth = 0 -> second call with child 3 -> \\n    # it has 2 children so there\\'ll be two calls from for loop\\n    # call with child 5 -> sets the for loop with child of 5 which is None (Null)\\n    # this call hits base case and returns 0\\n    # the same happens with child 6\\n    # call to child 6 from the for loop -> child of 6 is None -> returns 0\\n    # depth = max(0, 0) -> depth = 0\\n    # return to one level higher -> call to child 5 reaches return statement ->\\n    # depth = 1\\n    # call to child 6 reaches return statement and it returns 1 ->\\n    # current depth is 1 because child 5 set it -> max(1, 1) -> depth = 1\\n    # return to one more level higher\\n    # call to child 3 reaches return statement ->\\n    # depth was equal to 1 now it becomes 2 (depth + 1)\\n    # now it\\'s turn to children 2 and 4 to be called\\n    # the story is exactly the same as with 5 and 6 only depth is now 2 ->\\n    # both 2 and 4 return depth 1 that\\'s why it\\'s rejected by max(2, 1)\\n    # depth remains 2\\n    # and finally everything returns to the very first call with root 1 \\n    # it reaches return statement and returns 2+1=3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152659,
                "title": "java-solution-with-explain-same-logic-with-maximum-depth-of-binary-tree",
                "content": "This question is same as the binary one.\\nFirst, let\\'s review the 104. Maximum Depth of Binary Tree\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int maxDepth(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int left = maxDepth(root.left);\\n        int right = maxDepth(root.right);\\n        return Math.max(left, right) + 1;\\n    }\\n}\\n```\\nFor current node, the maximum depth of this node is Math.max(node.left.depth, node.right.depth).\\nSo, what is the depth of node.left and node.right? You can put node.left as node. The recursive  method has been built.\\n\\nNow, for this question, there are not only left and right, but there are children. So, only change left, right as a children for loop.\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val,List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        int max = 0;\\n        for (Node child : root.children) { //replace left&right to for loop\\n            int value = maxDepth(child);\\n            \\n            if (value > max) {\\n                max = value;\\n            }\\n        }\\n        return max +1;\\n    }\\n}\\n```\\nActually, this code also works for binary tree.",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int maxDepth(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int left = maxDepth(root.left);\\n        int right = maxDepth(root.right);\\n        return Math.max(left, right) + 1;\\n    }\\n}\\n```\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val,List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        int max = 0;\\n        for (Node child : root.children) { //replace left&right to for loop\\n            int value = maxDepth(child);\\n            \\n            if (value > max) {\\n                max = value;\\n            }\\n        }\\n        return max +1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330666,
                "title": "3-python-solutions-recursion-bfs-dfs",
                "content": "2-line Recursion. In most tree problems, try recursion first.\\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        return 1 + max(map(self.maxDepth, root.children or [None]))\\n```\\n\\t\\nBFS (use a queue, the last level we see will be the depth)\\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        queue = []\\n        if root: queue.append((root, 1))\\n        depth = 0\\n        for (node, level) in queue:\\n            depth = level\\n            queue += [(child, level+1) for child in node.children]\\n        return depth\\n```\\n\\nDFS (use a stack, use max to update depth)\\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        stack = []\\n        if root: stack.append((root, 1))\\n        depth = 0\\n        while stack:\\n            (node, d) = stack.pop()\\n            depth = max(depth, d)\\n            for child in node.children:\\n                stack.append((child, d+1))\\n        return depth\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        return 1 + max(map(self.maxDepth, root.children or [None]))\\n```\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        queue = []\\n        if root: queue.append((root, 1))\\n        depth = 0\\n        for (node, level) in queue:\\n            depth = level\\n            queue += [(child, level+1) for child in node.children]\\n        return depth\\n```\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        stack = []\\n        if root: stack.append((root, 1))\\n        depth = 0\\n        while stack:\\n            (node, d) = stack.pop()\\n            depth = max(depth, d)\\n            for child in node.children:\\n                stack.append((child, d+1))\\n        return depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723210,
                "title": "simple-c-solution-very-easy-to-understand-dfs-recursive",
                "content": "```\\n// DFS Recursive\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root==NULL)\\n            return 0;\\n        int max_depth = 1;\\n        for(int i=0;i<root->children.size();i++){\\n            max_depth = max(max_depth, 1 + maxDepth(root->children[i]));\\n        }\\n        return max_depth;\\n    }\\n};\\n```\\nFeel free to ask any question in the **comment** section.\\nIf you like this solution, do **UPVOTE**.\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n// DFS Recursive\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root==NULL)\\n            return 0;\\n        int max_depth = 1;\\n        for(int i=0;i<root->children.size();i++){\\n            max_depth = max(max_depth, 1 + maxDepth(root->children[i]));\\n        }\\n        return max_depth;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151804,
                "title": "solution-python-c-simple-with-explanation",
                "content": "In question 104, Maximum Depth of Binary Tree, to find the maximum of a binary tree we all know:\\n```\\nclass Solution:\\n    def maxDepth(self, root):\\n        if not root:\\n            return 0\\n        return max(self.maxDepth(root.left),self.maxDepth(root.right)) + 1\\n```\\n\\nSo similarly, for a N-ary Tree, instead of comparing depth between only left and right child nodes, we simply iterate all child nodes by ```(self.maxDepth(node) for node in root.children)``` and return the ``` max_depth``` on the current node by the fucntion ```max(child1, child2, ...)```. Eventually we will get the maximum depth for the root.\\n\\n<b>Python</b>\\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        if not root.children: return 1\\n        return max(self.maxDepth(node) for node in root.children) + 1\\n```\\n\\n36 / 36 test cases passed.\\nStatus: Accepted\\nRuntime: 102 ms\\n\\n<b>C++</b>\\n```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n    if (!root) return 0;\\n    int res = 1;\\n    for(Node* child : root->children) \\n        res = max(res, maxDepth(child) + 1);\\n    return res;\\n    }\\n};\\n```\\n36 / 36 test cases passed.\\nStatus: Accepted\\nRuntime: 40 ms",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root):\\n        if not root:\\n            return 0\\n        return max(self.maxDepth(root.left),self.maxDepth(root.right)) + 1\\n```\n```(self.maxDepth(node) for node in root.children)```\n``` max_depth```\n```max(child1, child2, ...)```\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        if not root.children: return 1\\n        return max(self.maxDepth(node) for node in root.children) + 1\\n```\n```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n    if (!root) return 0;\\n    int res = 1;\\n    for(Node* child : root->children) \\n        res = max(res, maxDepth(child) + 1);\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 266547,
                "title": "4-solutions-in-python-from-easy-to-hard",
                "content": "```python\\nclass Solution1(object):\\n    def maxDepth(self, root):\\n        if not root: return 0 #base case 1\\n        if not root.children: return 1 #base case 2\\n        heights = [] #hold all the heights of root\\'s children \\n        for node in root.children:\\n            heights.append(self.maxDepth(node))\\n        return max(heights) + 1\\n\\n\\n#Simplify solution 1\\nclass Solution2(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        if not root.children: return 1\\n        height = [self.maxDepth(node) for node in root.children]\\n        return max(height) + 1\\n\\n\\n#improve it one more step\\nclass Solution3(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        if not root: return 0\\n        if not root.children: return 1\\n        return max(self.maxDepth(node) for node in root.children) + 1   \\n\\n\\n#Compare the heights in a loop\\nclass Solution4(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        height = 0\\n        for node in root.children:\\n            height = max(self.maxDepth(node), height)\\n        return height + 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution1(object):\\n    def maxDepth(self, root):\\n        if not root: return 0 #base case 1\\n        if not root.children: return 1 #base case 2\\n        heights = [] #hold all the heights of root\\'s children \\n        for node in root.children:\\n            heights.append(self.maxDepth(node))\\n        return max(heights) + 1\\n\\n\\n#Simplify solution 1\\nclass Solution2(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        if not root.children: return 1\\n        height = [self.maxDepth(node) for node in root.children]\\n        return max(height) + 1\\n\\n\\n#improve it one more step\\nclass Solution3(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        if not root: return 0\\n        if not root.children: return 1\\n        return max(self.maxDepth(node) for node in root.children) + 1   \\n\\n\\n#Compare the heights in a loop\\nclass Solution4(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        height = 0\\n        for node in root.children:\\n            height = max(self.maxDepth(node), height)\\n        return height + 1",
                "codeTag": "Java"
            },
            {
                "id": 658460,
                "title": "javascript-3-solutions",
                "content": "**DFS Recursion:**\\n```\\nvar maxDepth = function(root) {\\n    if(!root) return 0;\\n    let max = 0;\\n    for(let child of root.children) {\\n       max = Math.max(max, maxDepth(child));\\n    }\\n    return max + 1;\\n}\\n```\\n**DFS Recursion with helper function:**\\n```\\n\\nvar maxDepth = function(root) {\\n    if(!root) return 0;\\n    let max = -1;\\n    \\n    const helper = (node, depth) => {\\n        if(depth > max) max = depth;\\n        for(let c of node.children){\\n            helper(c, depth + 1);\\n        }\\n    }\\n    \\n    helper(root, 1)\\n    return max;\\n};\\n```\\n**BFS:**\\n```\\nvar maxDepth = function(root) {\\n    if(!root) return 0;\\n    // Note: it is not advised to use array as queue\\n    let queue = [], depthCount = 0;\\n    queue.push(root);\\n    \\n    while(queue.length > 0){\\n        let len = queue.length;\\n        \\n        for(let i = 0; i < len; i++){\\n            let node = queue.shift();\\n            for(let child of node.children) queue.push(child);\\n        }\\n        depthCount++;\\n    }\\n    return depthCount;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar maxDepth = function(root) {\\n    if(!root) return 0;\\n    let max = 0;\\n    for(let child of root.children) {\\n       max = Math.max(max, maxDepth(child));\\n    }\\n    return max + 1;\\n}\\n```\n```\\n\\nvar maxDepth = function(root) {\\n    if(!root) return 0;\\n    let max = -1;\\n    \\n    const helper = (node, depth) => {\\n        if(depth > max) max = depth;\\n        for(let c of node.children){\\n            helper(c, depth + 1);\\n        }\\n    }\\n    \\n    helper(root, 1)\\n    return max;\\n};\\n```\n```\\nvar maxDepth = function(root) {\\n    if(!root) return 0;\\n    // Note: it is not advised to use array as queue\\n    let queue = [], depthCount = 0;\\n    queue.push(root);\\n    \\n    while(queue.length > 0){\\n        let len = queue.length;\\n        \\n        for(let i = 0; i < len; i++){\\n            let node = queue.shift();\\n            for(let child of node.children) queue.push(child);\\n        }\\n        depthCount++;\\n    }\\n    return depthCount;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 255481,
                "title": "python-2-node-n-node-559",
                "content": "# 104. Maximum Depth of Binary Tree\\n\\nTime: O(N) Proportional to input nodes, Iterates all nodes once.\\nSpace: O(H) Maximum nodes within the temporary call stack\\n\\n**Base Case**: \\u5F53Node\\u4E3A\\u7A7A\\u7684\\u65F6\\u5019\\uFF0C\\u8FD4\\u56DE\\u9AD8\\u5EA6\\u4E3A0\\n\\n**Recursive Rule\\u7CBE\\u786E\\u7248\\u672C** : \\n\\u4F20\\u9012\\uFF1A \\u5DE6\\u53F3\\u5B69\\u5B50\\n\\u5411\\u4E0B\\u7D22\\u53D6\\uFF1A\\u4E0B\\u4E00\\u5C42\\u7684\\u5DE6\\u5B50\\u6811\\u548C\\u53F3\\u5B50\\u6811\\u7D22\\u53D6**\\u6700\\u9AD8\\u6DF1\\u5EA6**\\n\\u5411\\u4E0A\\u8FD4\\u56DE\\uFF1A\\u9009\\u62E9\\u66F4\\u9AD8\\u7684\\u6DF1\\u5EA6**\\u5E76\\u4E14**\\u52A0\\u4E0A\\u5F53\\u524D\\u5C42\\u6570\\u7684\\u9AD8\\u5EA6 (+1) \\u3002\\u6700\\u7EC8\\u8FD4\\u56DE\\u3002\\n\\n**Recursive Rule\\u8BF4\\u4EBA\\u8BDD**: \\n\\u8C01\\u9AD8\\u53D6\\u8C01\\uFF0C\\u5E76\\u52A0\\u4E00\\n\\n\\n```python\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        left = self.maxDepth(root.left)\\n        right= self.maxDepth(root.right)\\n        return max(left, right) + 1\\n```\\n\\n<br><br><br>\\n\\n# 559. Maximum Depth of N-ary Tree\\n\\n**Base Case**: \\n\\u5F53Node\\u4E3A\\u7A7A\\u7684\\u65F6\\u5019\\uFF0C\\u8FD4\\u56DE\\u9AD8\\u5EA6\\u4E3A0\\n\\u5982\\u679C\\u9700\\u8981\\u63D0\\u524DDereference node.children\\uFF0C\\u90A3\\u4E48\\u540C\\u65F6\\u4E5F\\u8981\\u7ED9node.children\\u505A\\u4E00\\u4E2Abasecase\\uFF0C\\u8FD4\\u56DE\\u9AD8\\u5EA61\\n\\n**Recursive Rule\\u7CBE\\u786E\\u7248\\u672C** : \\n\\u4F20\\u9012\\uFF1A root.children\\n\\u5411\\u4E0B\\u7D22\\u53D6\\uFF1A\\u4E0B\\u4E00\\u5C42\\u7684\\u6240\\u6709\\u5B69\\u5B50\\u7684**\\u6700\\u9AD8\\u6DF1\\u5EA6**\\n\\u5411\\u4E0A\\u8FD4\\u56DE\\uFF1A\\u9009\\u62E9\\u66F4\\u9AD8\\u7684\\u6DF1\\u5EA6**\\u5E76\\u4E14**\\u52A0\\u4E0A\\u5F53\\u524D\\u5C42\\u6570\\u7684\\u9AD8\\u5EA6 (+1) \\u3002\\u6700\\u7EC8\\u8FD4\\u56DE\\u3002\\n\\n**Recursive Rule\\u8BF4\\u4EBA\\u8BDD**: \\n\\u8C01\\u9AD8\\u53D6\\u8C01\\uFF0C\\u5E76\\u52A0\\u4E00\\n\\n## \\u6362\\u6C64\\u4E0D\\u6362\\u836F\\u505A\\u6CD5\\n\\nTime: O(N) Proportional to input nodes, Iterates all nodes once.\\nSpace: O(H * Tempoaray List Space)) Maximum nodes within the temporary call stack, along with a list initialized on each level of call stack.\\n\\n\\u6362\\u6C64\\u4E0D\\u6362\\u836F\\u505A\\u6CD5\\uFF0C\\u5229\\u7528104\\u7684\\u601D\\u7EF4\\uFF0C104\\u6BCF\\u5C42\\u6BD4\\u5BF9\\u5DE6\\u53F3\\u5B69\\u5B50\\uFF0C\\u90A3\\u4E48\\u6211\\u4EEC\\u5728\\u6BCF\\u4E00\\u5C42\\u521B\\u5EFA\\u4E00\\u4E2A\\u4E34\\u65F6\\u7684List\\u7528\\u6765\\u4FDD\\u5B58\\u5F53\\u524DNode\\u7684\\u6240\\u6709\\u5B50\\u5B69\\u5B50\\u4F20\\u9012\\u4E0A\\u6765\\u7684\\u9AD8\\u5EA6\\uFF0C\\u53D6\\u5176\\u6700\\u5927\\u8FD4\\u56DE\\n\\n```python\\n# Readable\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        if not root.children: return 1\\n        height = []\\n        for node in root.children:\\n            height.append(self.maxDepth(node))\\n        return max(height) + 1\\n\\n#Pythonic\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        if not root.children: return 1\\n        height = [self.maxDepth(node) for node in root.children]\\n        return max(height) + 1\\n```\\n\\n## \\u5229\\u7528\\u53D8\\u91CF\\u4EE3\\u66FF\\u6BCF\\u5C42\\u7684Temporary List\\n\\nTime: O(N) Proportional to input nodes, Iterates all nodes once.\\nSpace: O(H) Maximum nodes within the temporary call stack\\n\\n\\u6362\\u4E86\\u70B9\\u836F\\uFF0C\\u5176\\u5B9E\\u4E5F\\u4E00\\u6837\\uFF0C\\u5C31\\u662F\\u6BCF\\u5C42\\u4E0D\\u9700\\u8981List\\uFF0C\\u7528\\u4E00\\u4E2A\\u53D8\\u91CF\\u4EE3\\u66FF\\u5373\\u53EF\\u3002\\n\\n```python\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        height = 0\\n        for node in root.children:\\n            height = max(self.maxDepth(node), height)\\n        return height + 1\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        left = self.maxDepth(root.left)\\n        right= self.maxDepth(root.right)\\n        return max(left, right) + 1\\n```\n```python\\n# Readable\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        if not root.children: return 1\\n        height = []\\n        for node in root.children:\\n            height.append(self.maxDepth(node))\\n        return max(height) + 1\\n\\n#Pythonic\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        if not root.children: return 1\\n        height = [self.maxDepth(node) for node in root.children]\\n        return max(height) + 1\\n```\n```python\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        height = 0\\n        for node in root.children:\\n            height = max(self.maxDepth(node), height)\\n        return height + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339873,
                "title": "java-1ms-solution-dfs-faster-than-99-8-lines",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root==null) return 0;\\n        int max_depth = 0;\\n        for(Node child: root.children) {\\n            max_depth = Math.max(max_depth, maxDepth(child));\\n        }\\n        return 1 + max_depth;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxDepth(Node root) {\\n        if(root==null) return 0;\\n        int max_depth = 0;\\n        for(Node child: root.children) {\\n            max_depth = Math.max(max_depth, maxDepth(child));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 169244,
                "title": "bfs-python-check-all-the-nodes-per-level-99",
                "content": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if root == None:\\n            return 0\\n        depth = 0\\n        stack = [root]\\n        while stack:\\n            next_level = []\\n            while stack:\\n                node = stack.pop()\\n                if node.children:\\n                    next_level += node.children\\n            stack = next_level\\n            depth += 1\\n        return depth\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if root == None:\\n            return 0\\n        depth = 0\\n        stack = [root]\\n        while stack:\\n            next_level = []\\n            while stack:\\n                node = stack.pop()\\n                if node.children:\\n                    next_level += node.children\\n            stack = next_level\\n            depth += 1\\n        return depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470308,
                "title": "java-simple-dfs-solution-with-comments-100-fast-and-100-less-space",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        \\n        if(root == null) {\\n            return 0;\\n        }\\n        \\n        //already height is 1 if node is not null\\n        int height = 1;\\n        \\n        for(Node node : root.children) {\\n            \\n\\t\\t\\t//track max height.\\n            height = Math.max(height, 1+maxDepth(node)); //1+maxDepth(node) will calculate depth recursively.\\n        }\\n        \\n        return height;\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        \\n        if(root == null) {\\n            return 0;\\n        }\\n        \\n        //already height is 1 if node is not null\\n        int height = 1;\\n        \\n        for(Node node : root.children) {\\n            \\n\\t\\t\\t//track max height.\\n            height = Math.max(height, 1+maxDepth(node)); //1+maxDepth(node) will calculate depth recursively.\\n        }\\n        \\n        return height;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374244,
                "title": "javascript-recursive-solution",
                "content": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n/**\\n * @param {Node} root\\n * @return {number}\\n */\\nvar maxDepth = function(root) {\\n    if (root == null) {\\n        return 0;\\n    }\\n    \\n    let max = 0;\\n    for (let child of root.children) {\\n        max = Math.max(max, maxDepth(child));\\n    }\\n    \\n    return max + 1;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n/**\\n * @param {Node} root\\n * @return {number}\\n */\\nvar maxDepth = function(root) {\\n    if (root == null) {\\n        return 0;\\n    }\\n    \\n    let max = 0;\\n    for (let child of root.children) {\\n        max = Math.max(max, maxDepth(child));\\n    }\\n    \\n    return max + 1;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 684633,
                "title": "simple-easy-solution-using-dfs-by-python-3",
                "content": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n\\n        depth = 1\\n        if root.children:\\n            depth += max(self.maxDepth(child) for child in root.children)\\n        return depth\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n\\n        depth = 1\\n        if root.children:\\n            depth += max(self.maxDepth(child) for child in root.children)\\n        return depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148544,
                "title": "java-top-down-dfs-solutions",
                "content": "Top Down\\n```JAVA\\nprivate int max = 0;\\npublic int maxDepth(Node root) {\\n    if (root == null) return 0;\\n    maxDepth(root, 1);\\n    return max;\\n} \\n    \\npublic void maxDepth(Node node, int depth) {\\n    if (node == null) return;\\n    max = Math.max(max, depth);\\n    for (Node child : node.children){\\n        maxDepth(child, depth+1);\\n    }\\n}",
                "solutionTags": [],
                "code": "Top Down\\n```JAVA\\nprivate int max = 0;\\npublic int maxDepth(Node root) {\\n    if (root == null) return 0;\\n    maxDepth(root, 1);\\n    return max;\\n} \\n    \\npublic void maxDepth(Node node, int depth) {\\n    if (node == null) return;\\n    max = Math.max(max, depth);\\n    for (Node child : node.children){\\n        maxDepth(child, depth+1);\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 952462,
                "title": "python-bfs-iterative-beats-92",
                "content": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n        \\n        nodes = deque()\\n        nodes.append((root, 1))\\n        maxx = 0\\n        while nodes:\\n            cur, val = nodes.popleft()\\n            maxx = val\\n            if cur.children:\\n                for child in cur.children:\\n                    nodes.append((child, val+1))\\n        return maxx\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n        \\n        nodes = deque()\\n        nodes.append((root, 1))\\n        maxx = 0\\n        while nodes:\\n            cur, val = nodes.popleft()\\n            maxx = val\\n            if cur.children:\\n                for child in cur.children:\\n                    nodes.append((child, val+1))\\n        return maxx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044279,
                "title": "java-all-approach-recursive-iterative-dfs-iterative-bfs",
                "content": "**Recursive**\\n```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if (root == null) return 0;\\n        int max = 0;\\n        for (Node child : root.children)\\n            max = Math.max(max, maxDepth(child));\\n        return max +1;\\n    }\\n}\\n```\\n\\n**Iterative BFS**\\n```\\nclass Solution {\\n     public int maxDepth(Node root) {\\n         if (root == null) return 0;\\n        \\n         Queue<Node> queue = new LinkedList<>();\\n         queue.offer(root);\\n         int level = 0;\\n         while (!queue.isEmpty()){\\n            int size = queue.size();\\n             for (int i=0;i<size;i++){\\n                 Node node = queue.poll();\\n                 for(Node n: node.children)\\n                     queue.offer(n);\\n             }\\n             level++;\\n         }\\n         return level;\\n     }\\n}\\n```\\n**Iterative DFS**\\n\\n```\\n     \\tpublic int maxDepth(Node root) {\\n         if(root == null) return 0;\\n         \\n         Stack<Node> stack = new Stack<>();\\n         Stack<Integer> depth = new Stack<>();\\n         stack.push(root);\\n         depth.push(1);\\n         int max = 1;\\n        \\n         while(!stack.isEmpty()) {\\n             Node n = stack.pop();\\n             int d = depth.pop();\\n            \\n             for(Node node: n.children) {\\n                 max = Math.max(d + 1, maxDepth);\\n                 stack.push(node);\\n                 depth.push(d + 1);\\n             }\\n         }\\n        return max;\\n     }\\n }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if (root == null) return 0;\\n        int max = 0;\\n        for (Node child : root.children)\\n            max = Math.max(max, maxDepth(child));\\n        return max +1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n     public int maxDepth(Node root) {\\n         if (root == null) return 0;\\n        \\n         Queue<Node> queue = new LinkedList<>();\\n         queue.offer(root);\\n         int level = 0;\\n         while (!queue.isEmpty()){\\n            int size = queue.size();\\n             for (int i=0;i<size;i++){\\n                 Node node = queue.poll();\\n                 for(Node n: node.children)\\n                     queue.offer(n);\\n             }\\n             level++;\\n         }\\n         return level;\\n     }\\n}\\n```\n```\\n     \\tpublic int maxDepth(Node root) {\\n         if(root == null) return 0;\\n         \\n         Stack<Node> stack = new Stack<>();\\n         Stack<Integer> depth = new Stack<>();\\n         stack.push(root);\\n         depth.push(1);\\n         int max = 1;\\n        \\n         while(!stack.isEmpty()) {\\n             Node n = stack.pop();\\n             int d = depth.pop();\\n            \\n             for(Node node: n.children) {\\n                 max = Math.max(d + 1, maxDepth);\\n                 stack.push(node);\\n                 depth.push(d + 1);\\n             }\\n         }\\n        return max;\\n     }\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 840332,
                "title": "c-bfs-vs-dfs-solutions-compared-and-explained-100-time-80-space",
                "content": "First approach, in pure BFS style, we first of all check if the tree is empty (in which case its height is of course `0`); if not, we create a queue and populate it initially with `root->children`; we also create a counter variable `level`, initially set to `1` (if we are here, it means we have at least a valid root).\\n\\nWe then start looping while `len` (set to match the length of our queue at each iteration) is not `0` - ie: there are still elements in the queue.\\n\\nInside the loop, we have a for loop running `len` times, one for each member of the current level of the tree (taken and popped from the front one by one), and add its children, if any, to end the next queue; after having updated the queue itself, we update consequently `len` and increase `level` by `1`.\\n\\nAfter the loop, we just return `len` :)\\n\\nThe BFS code, which run up to 90% Time and 80% Space:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        // edge case: empty tree\\n        if (!root) return 0;\\n        // support variables\\n        int level = 1, len;\\n        Node *curr;\\n        // preparing for a BFS\\n        queue<Node*> q;\\n        for (auto n: root->children) q.push(n);\\n        len = q.size();\\n        while (len) {\\n            // updating q with a new layer of items\\n            for (int i = 0; i < len; i++) {\\n                curr = q.front();\\n                q.pop();\\n                // adding new children to the queue\\n                for (auto n: curr->children) q.push(n);\\n            }\\n            // updating len and level\\n            len = q.size();\\n            level++;\\n        }\\n        return level;\\n    }\\n};\\n```\\n\\nIn my alternative going for a DFS, I just declared a `maxLevel` class variable, initially set to `0`, to track how deep we go; in the main function, I just invoke my helper `dfs` and then return this variable.\\n\\nIn `dfs` first of all I check if I have a root - if not, I exit; otherwise I update both `maxLevel` and the function\\'s optional second parameter `currLevel` in one fell swoop and finally I call `dfs` again on each child, with the updated value of `currLevel` I just increased in the above line.\\n\\nDFS version that \\\\*SPOILER\\\\* is much more compact and quicker (100% Time), also apparently using a bit less memory:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxLevel = 0;\\n    void dfs(Node* root, int currLevel = 1) {\\n        // exit condition\\n        if (!root) return;\\n        // updating both maxLevel and currLevel at the same time\\n        maxLevel = max(maxLevel, currLevel++);\\n        // recursing all the way down!\\n        for (auto n: root->children) dfs(n, currLevel);\\n    }\\n    int maxDepth(Node* root) {\\n        dfs(root);\\n        return maxLevel;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        // edge case: empty tree\\n        if (!root) return 0;\\n        // support variables\\n        int level = 1, len;\\n        Node *curr;\\n        // preparing for a BFS\\n        queue<Node*> q;\\n        for (auto n: root->children) q.push(n);\\n        len = q.size();\\n        while (len) {\\n            // updating q with a new layer of items\\n            for (int i = 0; i < len; i++) {\\n                curr = q.front();\\n                q.pop();\\n                // adding new children to the queue\\n                for (auto n: curr->children) q.push(n);\\n            }\\n            // updating len and level\\n            len = q.size();\\n            level++;\\n        }\\n        return level;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxLevel = 0;\\n    void dfs(Node* root, int currLevel = 1) {\\n        // exit condition\\n        if (!root) return;\\n        // updating both maxLevel and currLevel at the same time\\n        maxLevel = max(maxLevel, currLevel++);\\n        // recursing all the way down!\\n        for (auto n: root->children) dfs(n, currLevel);\\n    }\\n    int maxDepth(Node* root) {\\n        dfs(root);\\n        return maxLevel;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148882,
                "title": "python-4-lines-bfs-1-line-dfs-solutions",
                "content": "* BFS\\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        q, level = root and [root], 0\\n        while q:\\n            q, level = [child for node in q for child in node.children if child], level + 1\\n        return level \\n```\\n* DFS\\n```\\nclass Solution(object):\\n    def maxDepth(self, root, level = 1):\\n        return max(root and [self.maxDepth(child, level + 1) for child in root.children] + [level] or [0])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        q, level = root and [root], 0\\n        while q:\\n            q, level = [child for node in q for child in node.children if child], level + 1\\n        return level \\n```\n```\\nclass Solution(object):\\n    def maxDepth(self, root, level = 1):\\n        return max(root and [self.maxDepth(child, level + 1) for child in root.children] + [level] or [0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557851,
                "title": "3-sol-bfs-dfs-easy-to-understand-faster-simple-python-solution",
                "content": "```\\n    def iterative_bfs(self, root):\\n        if not root: return 0\\n        stack = [root]\\n        out = 0\\n        while len(stack):\\n            temp = []\\n            while len(stack):\\n                ele = stack.pop()\\n                for node in ele.children:\\n                    temp.append(node)\\n            stack = temp\\n            out += 1\\n            \\n        return out\\n            \\n    \\n    def iterative_dfs(self, root):\\n        if not root: return 0\\n        stack = [[root, 0]]\\n        out = 1\\n        while len(stack):\\n            top, level = stack.pop()\\n            for node in top.children:\\n                stack.append([node, level + 1])\\n            out = max(out, 1 + level)\\n        return out\\n    \\n    def recursive(self, root):\\n        def rec(root):\\n            if root:\\n                curr = 1\\n                for node in root.children:\\n                    curr = max(curr, 1 + rec(node))\\n                return curr\\n            return 0\\n        return rec(root)\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    def iterative_bfs(self, root):\\n        if not root: return 0\\n        stack = [root]\\n        out = 0\\n        while len(stack):\\n            temp = []\\n            while len(stack):\\n                ele = stack.pop()\\n                for node in ele.children:\\n                    temp.append(node)\\n            stack = temp\\n            out += 1\\n            \\n        return out\\n            \\n    \\n    def iterative_dfs(self, root):\\n        if not root: return 0\\n        stack = [[root, 0]]\\n        out = 1\\n        while len(stack):\\n            top, level = stack.pop()\\n            for node in top.children:\\n                stack.append([node, level + 1])\\n            out = max(out, 1 + level)\\n        return out\\n    \\n    def recursive(self, root):\\n        def rec(root):\\n            if root:\\n                curr = 1\\n                for node in root.children:\\n                    curr = max(curr, 1 + rec(node))\\n                return curr\\n            return 0\\n        return rec(root)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 222144,
                "title": "javascript-bfs",
                "content": "```\\nvar maxDepth = function(root) {\\n    if(!root) return 0;\\n    let depth = 0;\\n    let queue = [];\\n    queue.push(root);\\n\\n    while (queue.length){\\n      let queueSize = queue.length;\\n\\n      for(let i = 0; i < queueSize; i++){\\n        let node = queue.shift();\\n        queue.push(...node.children);\\n      }\\n\\n      depth++;\\n    }\\n\\n    return depth;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxDepth = function(root) {\\n    if(!root) return 0;\\n    let depth = 0;\\n    let queue = [];\\n    queue.push(root);\\n\\n    while (queue.length){\\n      let queueSize = queue.length;\\n\\n      for(let i = 0; i < queueSize; i++){\\n        let node = queue.shift();\\n        queue.push(...node.children);\\n      }\\n\\n      depth++;\\n    }\\n\\n    return depth;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3326128,
                "title": "what-about-minimum-depth-of-n-ary-tree",
                "content": "# **I Have Tried To Do The Code For Minimum Depth Or N-ary Tree**\\n\\n```\\nclass Solution {\\npublic:\\n\\tint minDepth(Node* root) {\\n\\t\\tif (!root) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tif (root->children.empty()) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\n\\t\\tint min_depth = 0;\\n\\t\\tfor (auto child : root->children) {\\n\\t\\t\\tmin_depth = min(min_depth, minDepth(child));\\n\\t\\t}\\n\\n\\t\\treturn min_depth + 1;\\n\\t}\\n};\\n\\n```\\n\\n### Don\\'t Forget To Give Some Suggestions, Point Out Mistakes And Comments.\\n\\n#### Put The Comment If You Find Out Some Kind Of Error In The Code.\\n\\n### **Thanks You :)**\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint minDepth(Node* root) {\\n\\t\\tif (!root) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tif (root->children.empty()) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\n\\t\\tint min_depth = 0;\\n\\t\\tfor (auto child : root->children) {\\n\\t\\t\\tmin_depth = min(min_depth, minDepth(child));\\n\\t\\t}\\n\\n\\t\\treturn min_depth + 1;\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545916,
                "title": "go-recursive-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Maximum Depth of N-ary Tree.\\nMemory Usage: 3.3 MB, less than 100.00% of Go online submissions for Maximum Depth of N-ary Tree.\\n```\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Children []*Node\\n * }\\n */\\n\\nfunc maxDepth(root *Node) int {\\n    if root == nil {\\n        return 0\\n    }\\n    m := 1\\n    for _, v := range root.Children {\\n        m = max(m, maxDepth(v)+1)\\n    }\\n    return m\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Children []*Node\\n * }\\n */\\n\\nfunc maxDepth(root *Node) int {\\n    if root == nil {\\n        return 0\\n    }\\n    m := 1\\n    for _, v := range root.Children {\\n        m = max(m, maxDepth(v)+1)\\n    }\\n    return m\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 334674,
                "title": "javascript-js-one-line-recursive-solution",
                "content": "if `root` is null, return `0`\\nelse return max of its children\\'s `maxDepth + 1`\\n```\\nvar maxDepth = function (root) {\\n  return root ? root.children.reduce((r, n) => Math.max(r, maxDepth(n)), 0) + 1 : 0;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "if `root` is null, return `0`\\nelse return max of its children\\'s `maxDepth + 1`\\n```\\nvar maxDepth = function (root) {\\n  return root ? root.children.reduce((r, n) => Math.max(r, maxDepth(n)), 0) + 1 : 0;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3298776,
                "title": "559-time-95-76-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Check if the root node is None. If it is, return 0 as the maximum depth since there are no nodes in the tree.\\n2. Create a variable called max_depth and set it to 0. This variable will keep track of the maximum depth of the tree.\\n3. Iterate through each child node of the root node.\\n4. Recursively call the maxDepth function on each child node to get the maximum depth of that subtree.\\n5. Compare the maximum depth of the current subtree to the current max_depth variable. If the maximum depth is greater than max_depth, set max_depth to the maximum depth of the current subtree.\\n6. Return max_depth plus 1, since we need to count the root node itself in the depth calculation.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a Node.\\n# class Node:\\n#     def __init__(self, val=None, children=None):\\n#         self.val = val\\n#         self.children = children if children is not None else []\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n        max_depth = 0\\n        for child in root.children:\\n            max_depth = max(max_depth, self.maxDepth(child))\\n        return max_depth + 1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a Node.\\n# class Node:\\n#     def __init__(self, val=None, children=None):\\n#         self.val = val\\n#         self.children = children if children is not None else []\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n        max_depth = 0\\n        for child in root.children:\\n            max_depth = max(max_depth, self.maxDepth(child))\\n        return max_depth + 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090004,
                "title": "python-one-liner",
                "content": "```\\ndef maxDepth(self, root: \\'Node\\') -> int:\\n        return max([0] + [self.maxDepth(c) for c in root.children]) + 1 if root else 0\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\ndef maxDepth(self, root: \\'Node\\') -> int:\\n        return max([0] + [self.maxDepth(c) for c in root.children]) + 1 if root else 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1985642,
                "title": "python-easy-solution-faster-than-94-submits",
                "content": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        \\n        if not root : return 0\\n        \\n        if root.children :\\n            return 1 + max([self.maxDepth(x) for x in root.children])\\n        else :\\n            return 1 \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        \\n        if not root : return 0\\n        \\n        if root.children :\\n            return 1 + max([self.maxDepth(x) for x in root.children])\\n        else :\\n            return 1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1061186,
                "title": "simple-c-solution-using-dfs",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    int maxDepth(Node* root) {\\n        if(!root) return 0;\\n        \\n        int max=0;\\n        for(auto child: root->children){\\n            int height = maxDepth(child);\\n            if(height>max) max=height;\\n        }\\n        return 1+max;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    int maxDepth(Node* root) {\\n        if(!root) return 0;\\n        \\n        int max=0;\\n        for(auto child: root->children){\\n            int height = maxDepth(child);\\n            if(height>max) max=height;\\n        }\\n        return 1+max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358352,
                "title": "python-recursive-solution-top-down-and-bottom-up",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val, children):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\n#   Bottom-Up approach\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        if root is None:\\n            return 0\\n        maxDepthOfChildren = 0\\n        for child in root.children:\\n            depth = self.maxDepth(child)\\n            maxDepthOfChildren = max(maxDepthOfChildren, depth)\\n        return maxDepthOfChildren + 1\\n    \\n    \\n    \\n    \\n#   Top-Down approach\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        if root is None:\\n            return 0\\n        return self.maxDepthHelper(root, 1, 1)\\n    \\n    def maxDepthHelper(self, root, depth, maxDepth):\\n        if root is None:\\n            return maxDepth\\n        maxDepth = max(depth, maxDepth)\\n        for child in root.children:\\n            maxDepth = self.maxDepthHelper(child, depth + 1, maxDepth)\\n        return maxDepth\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val, children):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\n#   Bottom-Up approach\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        if root is None:\\n            return 0\\n        maxDepthOfChildren = 0\\n        for child in root.children:\\n            depth = self.maxDepth(child)\\n            maxDepthOfChildren = max(maxDepthOfChildren, depth)\\n        return maxDepthOfChildren + 1\\n    \\n    \\n    \\n    \\n#   Top-Down approach\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        if root is None:\\n            return 0\\n        return self.maxDepthHelper(root, 1, 1)\\n    \\n    def maxDepthHelper(self, root, depth, maxDepth):\\n        if root is None:\\n            return maxDepth\\n        maxDepth = max(depth, maxDepth)\\n        for child in root.children:\\n            maxDepth = self.maxDepthHelper(child, depth + 1, maxDepth)\\n        return maxDepth\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561519,
                "title": "c-3-solutions-recursive-iterative-level-order-traversal-clean-code",
                "content": "### Solution 1: recursive\\n\\n```\\n    static int maxDepth(const Node* root) {\\n        if (!root) return 0;\\n        int max_child = 0;\\n        for (const Node* child : root->children) {\\n            max_child = max(max_child, maxDepth(child));\\n        }\\n        return 1 + max_child;\\n    }\\n```\\n\\n### Solution 2: iterative DFS/BFS\\n\\nThis is the DFS solution, but we could just replace the ```stack``` with a ```queue``` and we would have a BFS solution.\\n\\n```\\n    static int maxDepth(const Node* root) {\\n        if (!root) return 0;\\n        \\n        stack<pair<const Node*, int>> st;\\n        st.push({root, 1});\\n        int ans = 1;\\n        while (!empty(st)) {\\n            const auto [node, depth] = st.top(); st.pop();\\n            ans = max(ans, depth);\\n            for (const Node* child : node->children) {\\n                st.push({child, depth + 1});\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n### Solution 3: level order traversal (BFS)\\n\\nThis was inspired by a submission from @pan_vis98.\\n\\n```\\n    static int maxDepth(const Node* root) {\\n        if (!root) return 0;\\n        \\n        queue<const Node*> q;\\n        q.push(root);\\n        int ans = 0;\\n        while (!empty(q)) {\\n            int q_size = size(q);\\n            while (q_size--) {\\n                const Node* node = q.front(); q.pop();\\n                \\n                for (const Node* child : node->children) {\\n                    q.push(child);\\n                }\\n            }\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n```\\n\\n_As always: Feedback, questions, and comments are welcome. Please upvote if you like this post._\\n",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    static int maxDepth(const Node* root) {\\n        if (!root) return 0;\\n        int max_child = 0;\\n        for (const Node* child : root->children) {\\n            max_child = max(max_child, maxDepth(child));\\n        }\\n        return 1 + max_child;\\n    }\\n```\n```stack```\n```queue```\n```\\n    static int maxDepth(const Node* root) {\\n        if (!root) return 0;\\n        \\n        stack<pair<const Node*, int>> st;\\n        st.push({root, 1});\\n        int ans = 1;\\n        while (!empty(st)) {\\n            const auto [node, depth] = st.top(); st.pop();\\n            ans = max(ans, depth);\\n            for (const Node* child : node->children) {\\n                st.push({child, depth + 1});\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\n    static int maxDepth(const Node* root) {\\n        if (!root) return 0;\\n        \\n        queue<const Node*> q;\\n        q.push(root);\\n        int ans = 0;\\n        while (!empty(q)) {\\n            int q_size = size(q);\\n            while (q_size--) {\\n                const Node* node = q.front(); q.pop();\\n                \\n                for (const Node* child : node->children) {\\n                    q.push(child);\\n                }\\n            }\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1172377,
                "title": "100-faster-98-45-less-space-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int height(Node* root){\\n        if(root == NULL)return 0;\\n        int maxht = 1;\\n        for(Node* child: root->children){\\n            maxht = max(maxht, height(child)+1);\\n        }\\n        return maxht;\\n    }\\n    \\n    int maxDepth(Node* root) {\\n        Node* ans = root;\\n        return height(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int height(Node* root){\\n        if(root == NULL)return 0;\\n        int maxht = 1;\\n        for(Node* child: root->children){\\n            maxht = max(maxht, height(child)+1);\\n        }\\n        return maxht;\\n    }\\n    \\n    int maxDepth(Node* root) {\\n        Node* ans = root;\\n        return height(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 318921,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (root == NULL)\\n            return 0;\\n\\n        int maxChildDepth = 0;\\n        for (Node* child : root->children)\\n        {\\n            int childDepth = maxDepth(child);\\n            if (childDepth > maxChildDepth)\\n                maxChildDepth = childDepth;\\n        }\\n        return 1 + maxChildDepth;       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (root == NULL)\\n            return 0;\\n\\n        int maxChildDepth = 0;\\n        for (Node* child : root->children)\\n        {\\n            int childDepth = maxDepth(child);\\n            if (childDepth > maxChildDepth)\\n                maxChildDepth = childDepth;\\n        }\\n        return 1 + maxChildDepth;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106427,
                "title": "java-0ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n         if(root==null) return 0;\\n         \\n         int max=0;\\n      \\n          for(Node c: root.children){\\n              max = Math.max(max, maxDepth(c));\\n              }\\n        return 1+max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n         if(root==null) return 0;\\n         \\n         int max=0;\\n      \\n          for(Node c: root.children){\\n              max = Math.max(max, maxDepth(c));\\n              }\\n        return 1+max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997742,
                "title": "javascript-solution-beats-88-97-recursive-approach",
                "content": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n\\n/**\\n * @param {Node|null} root\\n * @return {number}\\n */\\nvar maxDepth = function(root) {\\n    if (root == null)\\n        return 0;\\n    \\n    let maximumDepth = 0;\\n    for (let node of root.children){\\n        maximumDepth = Math.max(maximumDepth, maxDepth(node));\\n    }\\n    return maximumDepth + 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n\\n/**\\n * @param {Node|null} root\\n * @return {number}\\n */\\nvar maxDepth = function(root) {\\n    if (root == null)\\n        return 0;\\n    \\n    let maximumDepth = 0;\\n    for (let node of root.children){\\n        maximumDepth = Math.max(maximumDepth, maxDepth(node));\\n    }\\n    return maximumDepth + 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2354757,
                "title": "java-trees",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root==null) return 0;\\n\\n        int max=0;\\n        for(Node child:root.children)\\n            max=Math.max(max,maxDepth(child));\\n\\n        return max+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root==null) return 0;\\n\\n        int max=0;\\n        for(Node child:root.children)\\n            max=Math.max(max,maxDepth(child));\\n\\n        return max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723779,
                "title": "c-simple-and-short",
                "content": "**plz Upvote If You Like It :**\\n```\\nclass Solution {\\npublic:\\n    int height(Node* root){\\n        if(!root){\\n            return 0;\\n        }\\n        int maxHeight = 0;\\n        for(auto child : root->children){\\n            maxHeight = max(height(child),maxHeight);\\n        }\\n        return maxHeight + 1;\\n    }\\n    int maxDepth(Node* root) {\\n        return height(root);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int height(Node* root){\\n        if(!root){\\n            return 0;\\n        }\\n        int maxHeight = 0;\\n        for(auto child : root->children){\\n            maxHeight = max(height(child),maxHeight);\\n        }\\n        return maxHeight + 1;\\n    }\\n    int maxDepth(Node* root) {\\n        return height(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629671,
                "title": "python-o-n-by-dfs-90-w-comment",
                "content": "Python O(n) by DFS\\n\\n---\\n\\n**Implementation** by DFS:\\n\\n```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        \\n        if root is None:\\n            # empty node or empty tree\\n            return 0\\n    \\n        else:\\n            # DFS to choose the longest path\\n            \\n            if root.children:\\n                # current node has subtrees\\n                return max( self.maxDepth(child) for child in root.children ) + 1\\n            \\n            else:\\n                # current node is leaf node\\n                return 1\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #111 Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree)\\n\\n[Leetcode #104 Maximum Depth of Binary Tree ](https://leetcode.com/problems/maximum-depth-of-binary-tree)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        \\n        if root is None:\\n            # empty node or empty tree\\n            return 0\\n    \\n        else:\\n            # DFS to choose the longest path\\n            \\n            if root.children:\\n                # current node has subtrees\\n                return max( self.maxDepth(child) for child in root.children ) + 1\\n            \\n            else:\\n                # current node is leaf node\\n                return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546927,
                "title": "c-bfs-and-dfs-solutions",
                "content": "**BFS solution**\\n```\\npublic class Solution {\\n    public int MaxDepth(Node root) {\\n        \\n        if(root == null)\\n            return 0;\\n        \\n        Queue<Node> queue = new Queue<Node>();\\n        queue.Enqueue(root);\\n        int depth = 0;\\n        while(queue.Count > 0)\\n        {\\n            int size = queue.Count;\\n            for(int i = 0; i < size; i++)\\n            {\\n                Node curr = queue.Dequeue();           \\n                foreach(Node node in curr.children)\\n                    queue.Enqueue(node);\\n            }\\n            depth++;\\n        }\\n        \\n        return depth;\\n    }\\n}\\n```\\n\\n**DFS solution version 1**\\n```\\npublic class Solution\\n{\\n    public int MaxDepth(Node root)\\n    {\\n        if (root == null)\\n            return 0;\\n\\n        List<int> depth = new List<int>(); // store children\\'s depths in a list, root\\'s maximum depth will be Max(children\\'s depths) + 1\\n        foreach (Node node in root.children)\\n        {\\n            int currDepth = MaxDepth(node);\\n            depth.Add(currDepth);\\n        }\\n\\n        return depth.Count == 0 ? 1 : depth.Max() + 1;\\n    }\\n}\\n```\\n**DFS solution version 2**\\n```\\npublic class Solution\\n{\\n    public int MaxDepth(Node root)\\n    {\\n        if (root == null)\\n            return 0;\\n\\n        int depth = 0; \\n\\n        foreach (Node node in root.children)\\n        {\\n            int currDepth = MaxDepth(node);\\n            depth = Math.Max(depth, currDepth); // // maximum depth of current root node\\'s children layer\\n        }\\n\\n        return depth + 1; // maximum depth of current layer\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxDepth(Node root) {\\n        \\n        if(root == null)\\n            return 0;\\n        \\n        Queue<Node> queue = new Queue<Node>();\\n        queue.Enqueue(root);\\n        int depth = 0;\\n        while(queue.Count > 0)\\n        {\\n            int size = queue.Count;\\n            for(int i = 0; i < size; i++)\\n            {\\n                Node curr = queue.Dequeue();           \\n                foreach(Node node in curr.children)\\n                    queue.Enqueue(node);\\n            }\\n            depth++;\\n        }\\n        \\n        return depth;\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    public int MaxDepth(Node root)\\n    {\\n        if (root == null)\\n            return 0;\\n\\n        List<int> depth = new List<int>(); // store children\\'s depths in a list, root\\'s maximum depth will be Max(children\\'s depths) + 1\\n        foreach (Node node in root.children)\\n        {\\n            int currDepth = MaxDepth(node);\\n            depth.Add(currDepth);\\n        }\\n\\n        return depth.Count == 0 ? 1 : depth.Max() + 1;\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    public int MaxDepth(Node root)\\n    {\\n        if (root == null)\\n            return 0;\\n\\n        int depth = 0; \\n\\n        foreach (Node node in root.children)\\n        {\\n            int currDepth = MaxDepth(node);\\n            depth = Math.Max(depth, currDepth); // // maximum depth of current root node\\'s children layer\\n        }\\n\\n        return depth + 1; // maximum depth of current layer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472341,
                "title": "javascript-with-dfs-and-bfs",
                "content": "**Setup**\\n```\\nif (!root) return 0    \\nlet depth = 1\\n\\n// Enter DFS or BFS method here\\n\\nreturn depth\\n```\\n    \\n**DFS method** (recursive)\\n```\\n const dfs = (node, level) => {\\n\\t if (node) {\\n\\t\\t if (level > depth) depth = level\\n\\n\\t\\t if (node.children.length) {\\n\\t\\t\\t node.children.forEach(vertex => dfs(vertex, level + 1))\\n\\t\\t }\\n\\t }\\n }\\n\\n dfs(root, 1)\\n```\\n    \\n**BFS method** (iterative)\\nBecause `Array.shift` has to move the entire array over after removing the first element, its inefficient. For the purposes of this demonstration, lets just say we have `O(1)` for all operations if we used a double-ended queue, otherwise if we just use a standard JS array its `O(n)`.\\n```\\nconst queue = [{ node: root, level: 1 }]\\n\\nwhile (queue.length) {\\n\\tconst { node, level } = queue.shift()\\n\\n\\tif (level > depth) depth = level\\n\\n\\tif (node.children.length) {\\n\\t\\tnode.children.forEach(vertex => queue.push({\\n\\t\\t\\tnode: vertex,\\n\\t\\t\\tlevel: level + 1\\n\\t\\t}))\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nif (!root) return 0    \\nlet depth = 1\\n\\n// Enter DFS or BFS method here\\n\\nreturn depth\\n```\n```\\n const dfs = (node, level) => {\\n\\t if (node) {\\n\\t\\t if (level > depth) depth = level\\n\\n\\t\\t if (node.children.length) {\\n\\t\\t\\t node.children.forEach(vertex => dfs(vertex, level + 1))\\n\\t\\t }\\n\\t }\\n }\\n\\n dfs(root, 1)\\n```\n```\\nconst queue = [{ node: root, level: 1 }]\\n\\nwhile (queue.length) {\\n\\tconst { node, level } = queue.shift()\\n\\n\\tif (level > depth) depth = level\\n\\n\\tif (node.children.length) {\\n\\t\\tnode.children.forEach(vertex => queue.push({\\n\\t\\t\\tnode: vertex,\\n\\t\\t\\tlevel: level + 1\\n\\t\\t}))\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 238408,
                "title": "python-solution",
                "content": "Depth first search. Time complexity: `O(n)`, space complexity: `O(h)`, where `n` and `h` are the number of nodes and height of the tree, respectively.\\n\\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return 0\\n            res = 0\\n            for child in root.children:\\n                res = max(dfs(child), res)\\n            return res+1\\n        return dfs(root)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return 0\\n            res = 0\\n            for child in root.children:\\n                res = max(dfs(child), res)\\n            return res+1\\n        return dfs(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175427,
                "title": "python-dfs-dfs-stack-bfs-solutions",
                "content": "```from collections import deque\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        if not root:\\n            return 0\\n        self.level = 1\\n        # self.dfs(root, 1)\\n        self.dfs_stack(root)\\n        # self.bfs(root)\\n        return self.level\\n        \\n    def dfs(self, root, level):\\n        if level > self.level:\\n            self.level = level\\n        for child in root.children:\\n            self.dfs(child, level + 1)\\n            \\n    def dfs_stack(self, root):\\n        stack = []\\n        stack.append((root, 1))\\n        while stack:\\n            node, level = stack.pop()\\n            if level > self.level:\\n                self.level = level\\n            for child in node.children:\\n                stack.append((child, level + 1))\\n        \\n    \\n    def bfs(self, root):\\n        queue = deque()\\n        queue.append((root, 1))\\n        while queue:\\n            node, level = queue.popleft()\\n            if level > self.level:\\n                self.level = level\\n            for child in node.children:\\n                queue.append((child, level + 1))",
                "solutionTags": [],
                "code": "```from collections import deque\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        if not root:\\n            return 0\\n        self.level = 1\\n        # self.dfs(root, 1)\\n        self.dfs_stack(root)\\n        # self.bfs(root)\\n        return self.level\\n        \\n    def dfs(self, root, level):\\n        if level > self.level:\\n            self.level = level\\n        for child in root.children:\\n            self.dfs(child, level + 1)\\n            \\n    def dfs_stack(self, root):\\n        stack = []\\n        stack.append((root, 1))\\n        while stack:\\n            node, level = stack.pop()\\n            if level > self.level:\\n                self.level = level\\n            for child in node.children:\\n                stack.append((child, level + 1))\\n        \\n    \\n    def bfs(self, root):\\n        queue = deque()\\n        queue.append((root, 1))\\n        while queue:\\n            node, level = queue.popleft()\\n            if level > self.level:\\n                self.level = level\\n            for child in node.children:\\n                queue.append((child, level + 1))",
                "codeTag": "Java"
            },
            {
                "id": 172097,
                "title": "c-simple-recursive-solution",
                "content": "```\\n    int maxDepth(Node* root) {\\n        if (root == NULL) {\\n            return 0;\\n        }\\n        \\n        vector<Node*> child;\\n        if (root) {\\n            child = root->children;\\n        }\\n\\t\\t\\t\\t\\n        int maxVal = 1;\\n        for (int i = 0; i < child.size(); i++) {\\n            if (child[i]) {\\n                int depth = 1+maxDepth(child[i]);\\n                maxVal = max(depth, maxVal);\\n            }\\n        }\\n        \\n        return maxVal;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int maxDepth(Node* root) {\\n        if (root == NULL) {\\n            return 0;\\n        }\\n        \\n        vector<Node*> child;\\n        if (root) {\\n            child = root->children;\\n        }\\n\\t\\t\\t\\t\\n        int maxVal = 1;\\n        for (int i = 0; i < child.size(); i++) {\\n            if (child[i]) {\\n                int depth = 1+maxDepth(child[i]);\\n                maxVal = max(depth, maxVal);\\n            }\\n        }\\n        \\n        return maxVal;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3331747,
                "title": "6-lines-awesome-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n        maxdepth=0\\n        for child in root.children:\\n            maxdepth=max(self.maxDepth(child),maxdepth)\\n        return maxdepth+1\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n        maxdepth=0\\n        for child in root.children:\\n            maxdepth=max(self.maxDepth(child),maxdepth)\\n        return maxdepth+1\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991266,
                "title": "c-very-easy-and-straightforward-clean-code",
                "content": "![image](https://assets.leetcode.com/users/images/bee63fd6-f560-4cc4-8a4a-85c5a8682f67_1672734427.6673162.png)\\n\\n**n==Number of Node\\nd==depth of the Tree\\nT->O(n) && S->O(d)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint depth(Node* curr){\\n\\t\\t\\t\\tif(!curr) return 0;\\n\\t\\t\\t\\tint d = 0;\\n\\t\\t\\t\\tfor(auto child : curr->children) d = max(d , depth(child) + 1);\\n\\t\\t\\t\\treturn d;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint maxDepth(Node* root) {\\n\\t\\t\\t\\tif(!root) return 0;\\n\\t\\t\\t\\treturn depth(root) + 1;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint depth(Node* curr){\\n\\t\\t\\t\\tif(!curr) return 0;\\n\\t\\t\\t\\tint d = 0;\\n\\t\\t\\t\\tfor(auto child : curr->children) d = max(d , depth(child) + 1);\\n\\t\\t\\t\\treturn d;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2606873,
                "title": "java-simple-recursive-and-iterative-solution",
                "content": "**Recursive Solution..**\\n```\\npublic int maxDepth(Node root) {\\n\\tif (root == null) return 0;\\n\\tint depth = 0;\\n\\tif (root.children != null && !root.children.isEmpty()) {\\n\\t\\tfor (Node child : root.children) {\\n\\t\\t\\tdepth = Math.max(depth, maxDepth(child));\\n\\t\\t}\\n\\t}\\n\\treturn depth + 1;\\n}\\n```\\n---\\n**Iterative Solution...**\\n\\n```\\npublic int maxDepth(Node root) {\\n\\tint depth = 0;\\n\\tif (root == null) return depth;\\n\\tDeque<Node> queue = new ArrayDeque<>();\\n\\tqueue.add(root);\\n\\twhile (!queue.isEmpty()) {\\n\\t\\tint level_size = queue.size();\\n\\t\\tfor (int i = 0; i < level_size; i++) {\\n\\t\\t\\tNode node = queue.poll();\\n\\t\\t\\tif (node != null && node.children != null && !node.children.isEmpty()) {\\n\\t\\t\\t\\tfor (Node child : node.children) {\\n\\t\\t\\t\\t\\tqueue.offer(child);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdepth += 1;\\n\\t}\\n\\treturn depth;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\npublic int maxDepth(Node root) {\\n\\tif (root == null) return 0;\\n\\tint depth = 0;\\n\\tif (root.children != null && !root.children.isEmpty()) {\\n\\t\\tfor (Node child : root.children) {\\n\\t\\t\\tdepth = Math.max(depth, maxDepth(child));\\n\\t\\t}\\n\\t}\\n\\treturn depth + 1;\\n}\\n```\n```\\npublic int maxDepth(Node root) {\\n\\tint depth = 0;\\n\\tif (root == null) return depth;\\n\\tDeque<Node> queue = new ArrayDeque<>();\\n\\tqueue.add(root);\\n\\twhile (!queue.isEmpty()) {\\n\\t\\tint level_size = queue.size();\\n\\t\\tfor (int i = 0; i < level_size; i++) {\\n\\t\\t\\tNode node = queue.poll();\\n\\t\\t\\tif (node != null && node.children != null && !node.children.isEmpty()) {\\n\\t\\t\\t\\tfor (Node child : node.children) {\\n\\t\\t\\t\\t\\tqueue.offer(child);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdepth += 1;\\n\\t}\\n\\treturn depth;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2582321,
                "title": "c-easy-fast-and-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxi=0;\\n    void solve(Node* root, int d)\\n    {\\n        if(!root)\\n        return;\\n        \\n        d++;\\n        maxi=max(maxi,d);\\n        \\n        for(auto r:root->children)\\n        solve(r,d);\\n    }\\n    \\n    int maxDepth(Node* root) {\\n        solve(root,0);\\n        return maxi;\\n    }\\n};\\n```\\nUpvote if it helps !",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi=0;\\n    void solve(Node* root, int d)\\n    {\\n        if(!root)\\n        return;\\n        \\n        d++;\\n        maxi=max(maxi,d);\\n        \\n        for(auto r:root->children)\\n        solve(r,d);\\n    }\\n    \\n    int maxDepth(Node* root) {\\n        solve(root,0);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630034,
                "title": "readable-5-line-efficient-solution-in-c-with-explanation",
                "content": "```\\n// in binary tree we return  1 + max( left_child_depth, right_child_depth)\\n// here i am doing same\\n// return 1 + max( child1_depth , child2_depth, child3_depth ........)\\n\\n\\n\\n int maxDepth(Node* root) \\n    {\\n        if(root==NULL)      return 0;\\n        \\n        int d=0;\\n        \\n        for(int i=0;i<root->children.size();i++)\\n            d=max(d,maxDepth(root->children[i]));\\n        \\n        return 1+d;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// in binary tree we return  1 + max( left_child_depth, right_child_depth)\\n// here i am doing same\\n// return 1 + max( child1_depth , child2_depth, child3_depth ........)\\n\\n\\n\\n int maxDepth(Node* root) \\n    {\\n        if(root==NULL)      return 0;\\n        \\n        int d=0;\\n        \\n        for(int i=0;i<root->children.size();i++)\\n            d=max(d,maxDepth(root->children[i]));\\n        \\n        return 1+d;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1602166,
                "title": "c-code",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        int height = 0;\\n        if(root == NULL)\\n        {\\n            return 0;\\n        }\\n        for(Node*child : root->children)\\n        {\\n            int childheight = maxDepth(child);\\n            height = max(height , childheight);\\n        }\\n        return height+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        int height = 0;\\n        if(root == NULL)\\n        {\\n            return 0;\\n        }\\n        for(Node*child : root->children)\\n        {\\n            int childheight = maxDepth(child);\\n            height = max(height , childheight);\\n        }\\n        return height+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564925,
                "title": "c-94-95-faster-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root == nullptr){\\n            return 0;\\n        }\\n        int max_val = 0;\\n        for(auto x: root->children){\\n            max_val = max(max_val, maxDepth(x));\\n        }\\n        \\n        return max_val + 1;\\n    }\\n};\\n```\\n\\n**Result-**\\n```\\nRuntime: 12 ms, faster than 94.95% of C++ online submissions for Maximum Depth of N-ary Tree.\\nMemory Usage: 10.8 MB, less than 70.40% of C++ online submissions for Maximum Depth of N-ary Tree.\\n```\\n",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root == nullptr){\\n            return 0;\\n        }\\n        int max_val = 0;\\n        for(auto x: root->children){\\n            max_val = max(max_val, maxDepth(x));\\n        }\\n        \\n        return max_val + 1;\\n    }\\n};\\n```\n```\\nRuntime: 12 ms, faster than 94.95% of C++ online submissions for Maximum Depth of N-ary Tree.\\nMemory Usage: 10.8 MB, less than 70.40% of C++ online submissions for Maximum Depth of N-ary Tree.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507948,
                "title": "c-easy-recursive-code",
                "content": "We iterate over all the child nodes of the root and check the maximum height from every node.\\nSimple recursive Code:\\n```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root == NULL)return 0;\\n        int depth = 0;\\n        \\n        for(auto &i:root->children){\\n            depth = max(depth, maxDepth(i));\\n        }\\n        return 1+depth;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root == NULL)return 0;\\n        int depth = 0;\\n        \\n        for(auto &i:root->children){\\n            depth = max(depth, maxDepth(i));\\n        }\\n        return 1+depth;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492897,
                "title": "c-solution",
                "content": "```\\nint maxDepth(Node* root) {\\n        if(!root) return 0;\\n        int depth=0;\\n        for(auto i:root->children)\\n        {\\n            depth=max(depth,maxDepth(i));\\n        }\\n        return depth+1;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nint maxDepth(Node* root) {\\n        if(!root) return 0;\\n        int depth=0;\\n        for(auto i:root->children)\\n        {\\n            depth=max(depth,maxDepth(i));\\n        }\\n        return depth+1;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1343765,
                "title": "c-recursive-solution-by-kushalatolia",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root == NULL)\\n            return 0;\\n        int ans = 0;\\n        for(auto i:root->children)\\n        {\\n            ans = max(ans,maxDepth(i));\\n        }\\n        return  1 + ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root == NULL)\\n            return 0;\\n        int ans = 0;\\n        for(auto i:root->children)\\n        {\\n            ans = max(ans,maxDepth(i));\\n        }\\n        return  1 + ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927102,
                "title": "python-simple-recursion-beats-91",
                "content": "```python\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root: return 0\\n        if root.children:\\n            return max(self.maxDepth(childNode)+1 for childNode in root.children)\\n        return 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```python\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root: return 0\\n        if root.children:\\n            return max(self.maxDepth(childNode)+1 for childNode in root.children)\\n        return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875657,
                "title": "python-dfs",
                "content": "```\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        if not root: return 0\\n        def f(root):\\n            if not root.children: return 1\\n            h = -1\\n            for v in root.children:\\n                h = max(h, f(v))\\n            return 1 + h\\n        return f(root)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        if not root: return 0\\n        def f(root):\\n            if not root.children: return 1\\n            h = -1\\n            for v in root.children:\\n                h = max(h, f(v))\\n            return 1 + h\\n        return f(root)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 859405,
                "title": "javascript-very-simple-recursive-logic-w-comments",
                "content": "```\\n/**\\n * @param {Node} root\\n * @return {number}\\n */\\nvar maxDepth = function (root) {\\n    // base case : return 0, since this node has no depth\\n    if (!root) return 0;\\n    // max depth of all children\\n    let max = 0;\\n    // iterate thru children\\n    for (let child of root.children) {\\n        // set max if max\\n        max = Math.max(max, maxDepth(child));\\n    }\\n    // return 1 + max depth of all children (1 is because this node has depth)\\n    return 1 + max;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {Node} root\\n * @return {number}\\n */\\nvar maxDepth = function (root) {\\n    // base case : return 0, since this node has no depth\\n    if (!root) return 0;\\n    // max depth of all children\\n    let max = 0;\\n    // iterate thru children\\n    for (let child of root.children) {\\n        // set max if max\\n        max = Math.max(max, maxDepth(child));\\n    }\\n    // return 1 + max depth of all children (1 is because this node has depth)\\n    return 1 + max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 619747,
                "title": "c-recursively-as-well-as-bfs-solution-to-calculate-max-depth",
                "content": "Recursive:\\n\\n```csharp\\npublic int MaxDepth(Node root) \\n{\\n\\treturn findMaxDepth(root, 1);\\n}\\n\\nprivate int findMaxDepth(Node node, int currentDepth)\\n{\\n\\tint maxDepth = currentDepth;\\n\\n\\tif(node == null)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tforeach(var child in node.children)\\n\\t{\\n\\t\\tint depth = findMaxDepth(child, currentDepth + 1);\\n\\t\\tmaxDepth = Math.Max(maxDepth, depth);\\n\\t}\\n\\n\\treturn maxDepth;\\n}\\n```\\n\\nBFS:\\n```csharp\\npublic int MaxDepth(Node root) \\n{\\t\\n\\tif(root == null)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tQueue<Node> queue = new Queue<Node>();\\n\\tqueue.Enqueue(root);\\n\\tint depth = 0;\\n\\n\\twhile(queue.Count > 0)\\n\\t{\\n\\t\\tint count = queue.Count;\\n\\t\\tfor(int i = 0; i < count; i++)\\n\\t\\t{\\n\\t\\t\\tNode current = queue.Dequeue();\\n\\t\\t\\tforeach(var children in current.children)\\n\\t\\t\\t{\\n\\t\\t\\t\\tqueue.Enqueue(children);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tdepth++;\\n\\t}\\n\\treturn depth;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MaxDepth(Node root) \\n{\\n\\treturn findMaxDepth(root, 1);\\n}\\n\\nprivate int findMaxDepth(Node node, int currentDepth)\\n{\\n\\tint maxDepth = currentDepth;\\n\\n\\tif(node == null)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tforeach(var child in node.children)\\n\\t{\\n\\t\\tint depth = findMaxDepth(child, currentDepth + 1);\\n\\t\\tmaxDepth = Math.Max(maxDepth, depth);\\n\\t}\\n\\n\\treturn maxDepth;\\n}\\n```\n```csharp\\npublic int MaxDepth(Node root) \\n{\\t\\n\\tif(root == null)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tQueue<Node> queue = new Queue<Node>();\\n\\tqueue.Enqueue(root);\\n\\tint depth = 0;\\n\\n\\twhile(queue.Count > 0)\\n\\t{\\n\\t\\tint count = queue.Count;\\n\\t\\tfor(int i = 0; i < count; i++)\\n\\t\\t{\\n\\t\\t\\tNode current = queue.Dequeue();\\n\\t\\t\\tforeach(var children in current.children)\\n\\t\\t\\t{\\n\\t\\t\\t\\tqueue.Enqueue(children);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tdepth++;\\n\\t}\\n\\treturn depth;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 548337,
                "title": "python-simple-solution-36-ms-15mb",
                "content": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        self.maxdepth = 0\\n\\n        def helper(node, depth):\\n            if node:  \\n                depth += 1\\n                for child in node.children:\\n                    helper(child, depth)\\n            if depth > self.maxdepth:\\n                self.maxdepth = depth\\n\\n        helper(root, 0)\\n        return self.maxdepth\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        self.maxdepth = 0\\n\\n        def helper(node, depth):\\n            if node:  \\n                depth += 1\\n                for child in node.children:\\n                    helper(child, depth)\\n            if depth > self.maxdepth:\\n                self.maxdepth = depth\\n\\n        helper(root, 0)\\n        return self.maxdepth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323811,
                "title": "java-bfs-iterative",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        int result = 0;\\n        \\n        if (root == null) {\\n            return result;\\n        }\\n        \\n        Queue<Node> q = new LinkedList<>();\\n        q.add(root);\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Node cur = q.remove();\\n                \\n                for (Node n : cur.children) {\\n                    if (n != null) {\\n                        q.add(n);\\n                    }\\n                }\\n            }\\n            result++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        int result = 0;\\n        \\n        if (root == null) {\\n            return result;\\n        }\\n        \\n        Queue<Node> q = new LinkedList<>();\\n        q.add(root);\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Node cur = q.remove();\\n                \\n                for (Node n : cur.children) {\\n                    if (n != null) {\\n                        q.add(n);\\n                    }\\n                }\\n            }\\n            result++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158833,
                "title": "python-bfs-with-explanation",
                "content": "I learned this method a while back from someone else (don\\'t remember who) and thought  it was quite clever and easy to understand for beginners.  The solution uses \\'X\\' to indicate the end of all nodes on a level in the queue.  The \\'X\\' gets added only after all the nodes from the same level are enqueued. \\n\\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        if not root.children: return 1\\n        \\n        max_depth = 0\\n        q = [root, \\'X\\']\\n        while len(q) >0:\\n            node = q.pop(0)\\n            if node == \\'X\\': \\n                max_depth += 1\\n                if len(q): q.append(\\'X\\')\\n                continue\\n            if node and node.children: \\n                for c in node.children: \\n                    q.append(c)\\n            \\n        return max_depth\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        if not root.children: return 1\\n        \\n        max_depth = 0\\n        q = [root, \\'X\\']\\n        while len(q) >0:\\n            node = q.pop(0)\\n            if node == \\'X\\': \\n                max_depth += 1\\n                if len(q): q.append(\\'X\\')\\n                continue\\n            if node and node.children: \\n                for c in node.children: \\n                    q.append(c)\\n            \\n        return max_depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150397,
                "title": "simple-solution-3-lines-python-code-beats-99",
                "content": "```python\\nif root is None: return 0\\nif root.children is None or root.children == []: return 1\\nreturn max(map(self.maxDepth, root.children)) + 1\\n```",
                "solutionTags": [],
                "code": "```python\\nif root is None: return 0\\nif root.children is None or root.children == []: return 1\\nreturn max(map(self.maxDepth, root.children)) + 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2842261,
                "title": "easiest-solution-c-plus-plus-easy-to-understand-recursion-only-4-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    void solve(Node* root,int a,int &ans){\\n        if(root==NULL) return;\\n        a++;\\n        ans=max(ans,a);\\n        for(Node* i:root->children) solve(i,a,ans);\\n    }\\n    int maxDepth(Node* root) {\\n        int ans = 0;\\n        solve(root,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    void solve(Node* root,int a,int &ans){\\n        if(root==NULL) return;\\n        a++;\\n        ans=max(ans,a);\\n        for(Node* i:root->children) solve(i,a,ans);\\n    }\\n    int maxDepth(Node* root) {\\n        int ans = 0;\\n        solve(root,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819538,
                "title": "java",
                "content": "If you like it pls upvote\\n```\\n\\n public int maxDepth(Node root) {\\n if(root == null) return 0;\\n Stack<Node> stack = new Stack<>();\\n Stack<Integer> num = new Stack<>();\\n stack.push(root);\\n num.push(1);\\n int depth = 1;\\n\\n while (!stack.empty()) {\\n  Node node = stack.pop();\\n  int count = num.pop();\\n\\n  if (node.children != null) {\\n   for (Node nod : node.children) {\\n     stack.push(nod);\\n     depth = Math.max(count + 1, depth);\\n     num.push(count + 1);\\n   }\\n  }\\n }\\n\\n return depth;\\n }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\n\\n public int maxDepth(Node root) {\\n if(root == null) return 0;\\n Stack<Node> stack = new Stack<>();\\n Stack<Integer> num = new Stack<>();\\n stack.push(root);\\n num.push(1);\\n int depth = 1;\\n\\n while (!stack.empty()) {\\n  Node node = stack.pop();\\n  int count = num.pop();\\n\\n  if (node.children != null) {\\n   for (Node nod : node.children) {\\n     stack.push(nod);\\n     depth = Math.max(count + 1, depth);\\n     num.push(count + 1);\\n   }\\n  }\\n }\\n\\n return depth;\\n }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2555808,
                "title": "java-dfs-fast",
                "content": "```\\n\\tpublic int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        int max = 0;\\n        for(Node node : root.children) {\\n            max = Math.max(max, maxDepth(node));\\n        }\\n        return 1 + max;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n\\tpublic int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        int max = 0;\\n        for(Node node : root.children) {\\n            max = Math.max(max, maxDepth(node));\\n        }\\n        return 1 + max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2274121,
                "title": "java-fast-recursive-solution-0ms",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root==null)\\n            return 0;\\n        if(root.children.size()==0)\\n            return 1;\\n        int height = 0;\\n        for(Node child : root.children) {\\n            int recAns = maxDepth(child);\\n            height = Math.max(height,recAns);\\n        }\\n        return height+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root==null)\\n            return 0;\\n        if(root.children.size()==0)\\n            return 1;\\n        int height = 0;\\n        for(Node child : root.children) {\\n            int recAns = maxDepth(child);\\n            height = Math.max(height,recAns);\\n        }\\n        return height+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209188,
                "title": "c-dfs-beats-84",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root==NULL)\\n            return 0;\\n        \\n        if(root->children.size()==0)\\n            return 1;\\n        \\n        vector<int> v(root->children.size(),1);\\n        int i=0;\\n        for(auto x:root->children)\\n        {\\n            v[i++]+=maxDepth(x);\\n        }\\n        return *max_element(v.begin(),v.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root==NULL)\\n            return 0;\\n        \\n        if(root->children.size()==0)\\n            return 1;\\n        \\n        vector<int> v(root->children.size(),1);\\n        int i=0;\\n        for(auto x:root->children)\\n        {\\n            v[i++]+=maxDepth(x);\\n        }\\n        return *max_element(v.begin(),v.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163226,
                "title": "c-recursive-bfs-pre-order",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(!root) return 0;\\n        int mx = 0;\\n        for(Node* n : root->children) mx = max(mx, maxDepth(n));\\n        return mx + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(!root) return 0;\\n        int mx = 0;\\n        for(Node* n : root->children) mx = max(mx, maxDepth(n));\\n        return mx + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1983953,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/1c6b3bdd-4384-4ab5-9306-32ecc67d521c_1650981563.7521918.png)\\n\\n```\\nint maxDepth(struct Node* root) {\\n    if (!root) return 0;\\n    if (root->numChildren == 0) return 1;\\n    int max = 0;\\n    for (int i = 0; i < root->numChildren; i++) {\\n        int tmp = maxDepth(root->children[i]) + 1;\\n        max = tmp > max ? tmp : max;\\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxDepth(struct Node* root) {\\n    if (!root) return 0;\\n    if (root->numChildren == 0) return 1;\\n    int max = 0;\\n    for (int i = 0; i < root->numChildren; i++) {\\n        int tmp = maxDepth(root->children[i]) + 1;\\n        max = tmp > max ? tmp : max;\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1872600,
                "title": "maximum-depth-of-n-ary-tree-solution-java",
                "content": "class Solution {\\n  public int maxDepth(Node root) {\\n    if (root == null)\\n      return 0;\\n\\n    int ans = 0;\\n\\n    for (Node child : root.children)\\n      ans = Math.max(ans, maxDepth(child));\\n\\n    return 1 + ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n  public int maxDepth(Node root) {\\n    if (root == null)\\n      return 0;\\n\\n    int ans = 0;\\n\\n    for (Node child : root.children)\\n      ans = Math.max(ans, maxDepth(child));\\n\\n    return 1 + ans;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1779469,
                "title": "n-ary-tree-easy-aprroach-c-simple-explanantion",
                "content": "```\\n/* N ary Tree can have any number of children where as binary can have atmost 2 child.\\n   Find Height of each children of root \\n   find maximum height among its children\\n   Return maximum + 1\\n              root\\n            / | \\\\ \\\\\\n           5  8  9 10\\n          |   \\\\  \\\\  \\\\\\n          6    7  5  11\\n              /   \\\\  \\n             5     8\\n             \\\\\\n             11\\n    Maximum Height will be 5\\n*/\\n```\\n```\\nUpVote If You Like It \\n```\\n```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* ptr) {\\n        if (!ptr)            //Base condition\\n            return 0;\\n \\n    // Check for all children and find\\n    // the maximum depth\\n    int maxdepth = 0;\\n        vector<Node*>::iterator it;\\n    for (it = ptr->children.begin();it != ptr->children.end(); it++)\\n        maxdepth = max(maxdepth, maxDepth(*it));\\n \\n    return maxdepth + 1 ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\n/* N ary Tree can have any number of children where as binary can have atmost 2 child.\\n   Find Height of each children of root \\n   find maximum height among its children\\n   Return maximum + 1\\n              root\\n            / | \\\\ \\\\\\n           5  8  9 10\\n          |   \\\\  \\\\  \\\\\\n          6    7  5  11\\n              /   \\\\  \\n             5     8\\n             \\\\\\n             11\\n    Maximum Height will be 5\\n*/\\n```\n```\\nUpVote If You Like It \\n```\n```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* ptr) {\\n        if (!ptr)            //Base condition\\n            return 0;\\n \\n    // Check for all children and find\\n    // the maximum depth\\n    int maxdepth = 0;\\n        vector<Node*>::iterator it;\\n    for (it = ptr->children.begin();it != ptr->children.end(); it++)\\n        maxdepth = max(maxdepth, maxDepth(*it));\\n \\n    return maxdepth + 1 ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723410,
                "title": "beginner-friendly-javascript-solution",
                "content": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n\\n/**\\n * @param {Node|null} root\\n * @return {number}\\n */\\nvar maxDepth = function(root) {\\n    if(root == null)    return 0;\\n    let max = 0;\\n    for(let child of root.children){\\n        max = Math.max(max, maxDepth(child));\\n    }\\n    return max+1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n\\n/**\\n * @param {Node|null} root\\n * @return {number}\\n */\\nvar maxDepth = function(root) {\\n    if(root == null)    return 0;\\n    let max = 0;\\n    for(let child of root.children){\\n        max = Math.max(max, maxDepth(child));\\n    }\\n    return max+1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1506608,
                "title": "c-easy-logic-recursive-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int max_height = 0;\\n    void solve(Node* root, int height){\\n        int size = root->children.size();\\n        if(size){\\n            height++;\\n            for(int i=0; i<size; i++){\\n                solve(root->children[i], height);\\n            }\\n        }\\n        else{\\n            max_height = max(height, max_height);\\n        }\\n    }\\n    \\n    int maxDepth(Node* root) {\\n        if(!root){\\n            return 0;\\n        }\\n        int height = 1;\\n        solve(root, height);\\n        return max_height;\\n    }\\n};\\n```\\n**If you learn from this code then please upvote this.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int max_height = 0;\\n    void solve(Node* root, int height){\\n        int size = root->children.size();\\n        if(size){\\n            height++;\\n            for(int i=0; i<size; i++){\\n                solve(root->children[i], height);\\n            }\\n        }\\n        else{\\n            max_height = max(height, max_height);\\n        }\\n    }\\n    \\n    int maxDepth(Node* root) {\\n        if(!root){\\n            return 0;\\n        }\\n        int height = 1;\\n        solve(root, height);\\n        return max_height;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470196,
                "title": "c-sol-with-null-marker",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(!root) return 0;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(nullptr);\\n        int count=1;\\n        while(root){\\n            Node* front = q.front();\\n            q.pop();\\n            if(front==nullptr){\\n                q.push(nullptr);\\n                if(q.size()==1) break;\\n                count++;\\n            }else{\\n                for(int i=0;i<front->children.size();i++){\\n                    q.push(front->children[i]);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(!root) return 0;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(nullptr);\\n        int count=1;\\n        while(root){\\n            Node* front = q.front();\\n            q.pop();\\n            if(front==nullptr){\\n                q.push(nullptr);\\n                if(q.size()==1) break;\\n                count++;\\n            }else{\\n                for(int i=0;i<front->children.size();i++){\\n                    q.push(front->children[i]);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376795,
                "title": "python3-bfs-dfs",
                "content": "```\\n#     DFS\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:return 0\\n        depth=0\\n        for child in root.children:\\n            depth=max(depth,self.maxDepth(child))\\n        return depth+1\\n    \\n    \\n#     BFS\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:return 0\\n        depth=0\\n        q=deque()\\n        q.append((root,1))\\n        while q:\\n            curr_node,curr_level=q.popleft()\\n            depth=curr_level\\n            for child in curr_node.children:\\n                q.append((child,depth+1))\\n        return depth",
                "solutionTags": [],
                "code": "```\\n#     DFS\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:return 0\\n        depth=0\\n        for child in root.children:\\n            depth=max(depth,self.maxDepth(child))\\n        return depth+1\\n    \\n    \\n#     BFS\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:return 0\\n        depth=0\\n        q=deque()\\n        q.append((root,1))\\n        while q:\\n            curr_node,curr_level=q.popleft()\\n            depth=curr_level\\n            for child in curr_node.children:\\n                q.append((child,depth+1))\\n        return depth",
                "codeTag": "Python3"
            },
            {
                "id": 1323720,
                "title": "straightforward-bfs-in-python-beating-98-submissions",
                "content": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        depth = 0\\n        if not root:\\n            return depth\\n        \\n        level = [root]\\n        \\n        while level:\\n            depth += 1\\n            level = [c for n in level for c in n.children if c]\\n            \\n        return depth\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        depth = 0\\n        if not root:\\n            return depth\\n        \\n        level = [root]\\n        \\n        while level:\\n            depth += 1\\n            level = [c for n in level for c in n.children if c]\\n            \\n        return depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220361,
                "title": "c-easy-to-understand-recursive-straight-forward-solution-99-43-faster-code",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)**\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        int depth;\\n    if(root==NULL)\\n    return 0;\\n    int maximumDepth=1;\\n        for(int i=0;i<root->children.size();i++)\\n        {\\n            maximumDepth=max(maximumDepth,maxDepth(root->children[i])+1);\\n        }\\n    return maximumDepth;\\n    }\\n    \\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        int depth;\\n    if(root==NULL)\\n    return 0;\\n    int maximumDepth=1;\\n        for(int i=0;i<root->children.size();i++)\\n        {\\n            maximumDepth=max(maximumDepth,maxDepth(root->children[i])+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1196070,
                "title": "easy-simple-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxH=0;\\n    int calculate(Node* root,int count)\\n    {\\n        if(!root)\\n            return maxH;\\n        count++;\\n        maxH=max(maxH,count);\\n        for(auto i:root->children)\\n        {\\n            calculate(i,count);\\n        }\\n        return maxH;\\n    }\\n    int maxDepth(Node* root) {\\n        if(!root)\\n            return 0;\\n        return calculate(root,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxH=0;\\n    int calculate(Node* root,int count)\\n    {\\n        if(!root)\\n            return maxH;\\n        count++;\\n        maxH=max(maxH,count);\\n        for(auto i:root->children)\\n        {\\n            calculate(i,count);\\n        }\\n        return maxH;\\n    }\\n    int maxDepth(Node* root) {\\n        if(!root)\\n            return 0;\\n        return calculate(root,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179877,
                "title": "python-3-liner",
                "content": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root: return 0\\n        if not len(root.children): return 1\\n        return 1 + max([self.maxDepth(child) for child in root.children])\\n```\\n\\nPretty straight forward recursive-dfs solution.",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root: return 0\\n        if not len(root.children): return 1\\n        return 1 + max([self.maxDepth(child) for child in root.children])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025091,
                "title": "python-recursion-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.level = 0\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        def depth(node, level):\\n            if level > self.level:\\n                self.level = level\\n            if node:\\n                for n in node.children:\\n                    depth(n, level+1)\\n        if root:\\n            depth(root, 1)\\n        return self.level\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.level = 0\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        def depth(node, level):\\n            if level > self.level:\\n                self.level = level\\n            if node:\\n                for n in node.children:\\n                    depth(n, level+1)\\n        if root:\\n            depth(root, 1)\\n        return self.level\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990854,
                "title": "java",
                "content": "``` \\npublic int maxDepth(Node root) {\\n        \\n        if(root==null) return 0;\\n        int depth=0;\\n        for(Node node:root.children){\\n           depth=Math.max(depth,maxDepth(node));\\n        }\\n        // Collections.sort(vals);\\n        return depth+1;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "``` \\npublic int maxDepth(Node root) {\\n        \\n        if(root==null) return 0;\\n        int depth=0;\\n        for(Node node:root.children){\\n           depth=Math.max(depth,maxDepth(node));\\n        }\\n        // Collections.sort(vals);\\n        return depth+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 881868,
                "title": "c-explanation-with-clear-idea-3-ideas",
                "content": "# Idea 1:\\n```\\n/*\\n * 1. Idea:\\n * max depth of the tree = max(depth of 1st sub-tree + 1, depth of 2nd sub-tree + 1, ..., depth of Nth sub-tree + 1)\\n *                       = max(depth of sub-trees) + 1\\n *\\n * 2. Algorithm\\n * TC = O(N) with N is number of nodes of the tree.\\n * SC = O(H) with H is height (depth) of the tree.\\n *    In the bad case, SC = O(N)\\n *    In the best case, SC = O(logN)\\n */\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (root == NULL)\\n            return 0;\\n        \\n        int depthSubtree = 0;\\n        for (int i = 0, N = root->children.size(); i < N; i++)\\n            depthSubtree = max(depthSubtree, maxDepth(root->children[i]));\\n\\n        return ++depthSubtree;\\n    }\\n};\\n```\\n\\n# Idea 2\\n\\n```\\n/*\\n * 1. Idea:\\n * Tracking the current depth we are in.\\n * - when visting a node, the current depth should be increased by 1.\\n * - when leaving the node, the current depth should be descreased by 1.\\n * - if the visiting node doesn\\'t have children nodes, update the current depth to maximum depth.\\n *\\n * 2. Algorithm\\n * TC = O(N) with N is number of nodes of the tree.\\n * SC = O(H) with H is height (depth) of the tree.\\n *    In the bad case, SC = O(N)\\n *    In the best case, SC = O(logN)\\n */\\nclass Solution {\\nprivate:\\n    void traversal(Node* root, int& currDepth, int& answer) {\\n        if (root == NULL)\\n            return;\\n\\n        currDepth++;\\n        int numChildren = root->children.size();\\n        for (int i = 0; i < numChildren; i++)\\n            traversal(root->children[i], currDepth, answer);\\n        if (numChildren == 0)\\n            answer = max(answer, currDepth);\\n        currDepth--;\\n    }\\n\\npublic:\\n    int maxDepth(Node* root) {\\n        int currDepth = 0, answer = 0;\\n        traversal(root, currDepth, answer);\\n        return answer;\\n    }\\n};\\n```\\n\\n# Idea 3\\n```\\n/*\\n * 1. Idea:\\n * Not good but we can reuse node\\'s value to mark depth of the node.\\n * First, create a queue to store the nodes will be visited (initialize the queue with the root node)\\n * After that, check front node until queue empty. For each front node, if there is no children, update the node\\'s value to max depth.\\n * If the front node has some children, push its children to the queue with children\\'s value = parent\\'s value + 1\\n * Before visit next node, remember to dequeue the current front node.\\n *\\n * 2. Algorithm\\n * TC = O(N) with N is number of nodes of the tree.\\n * SC = O(N) with N is number of nodes of the tree.\\n */\\n\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (root == NULL)\\n            return 0;\\n        \\n        int maximumDepth = 0;\\n        queue<Node*> q;\\n        root->val = 1;\\n        q.push(root);\\n        while (!q.empty()) {\\n            Node* node = q.front();\\n            int numChildren = node->children.size();\\n            for (int i = 0; i < numChildren; i++) {\\n                node->children[i]->val = node->val + 1;\\n                q.push(node->children[i]);\\n            }\\n            if (numChildren == 0)\\n                maximumDepth = max(maximumDepth, node->val);\\n            q.pop();\\n        }\\n        return maximumDepth;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n * 1. Idea:\\n * max depth of the tree = max(depth of 1st sub-tree + 1, depth of 2nd sub-tree + 1, ..., depth of Nth sub-tree + 1)\\n *                       = max(depth of sub-trees) + 1\\n *\\n * 2. Algorithm\\n * TC = O(N) with N is number of nodes of the tree.\\n * SC = O(H) with H is height (depth) of the tree.\\n *    In the bad case, SC = O(N)\\n *    In the best case, SC = O(logN)\\n */\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (root == NULL)\\n            return 0;\\n        \\n        int depthSubtree = 0;\\n        for (int i = 0, N = root->children.size(); i < N; i++)\\n            depthSubtree = max(depthSubtree, maxDepth(root->children[i]));\\n\\n        return ++depthSubtree;\\n    }\\n};\\n```\n```\\n/*\\n * 1. Idea:\\n * Tracking the current depth we are in.\\n * - when visting a node, the current depth should be increased by 1.\\n * - when leaving the node, the current depth should be descreased by 1.\\n * - if the visiting node doesn\\'t have children nodes, update the current depth to maximum depth.\\n *\\n * 2. Algorithm\\n * TC = O(N) with N is number of nodes of the tree.\\n * SC = O(H) with H is height (depth) of the tree.\\n *    In the bad case, SC = O(N)\\n *    In the best case, SC = O(logN)\\n */\\nclass Solution {\\nprivate:\\n    void traversal(Node* root, int& currDepth, int& answer) {\\n        if (root == NULL)\\n            return;\\n\\n        currDepth++;\\n        int numChildren = root->children.size();\\n        for (int i = 0; i < numChildren; i++)\\n            traversal(root->children[i], currDepth, answer);\\n        if (numChildren == 0)\\n            answer = max(answer, currDepth);\\n        currDepth--;\\n    }\\n\\npublic:\\n    int maxDepth(Node* root) {\\n        int currDepth = 0, answer = 0;\\n        traversal(root, currDepth, answer);\\n        return answer;\\n    }\\n};\\n```\n```\\n/*\\n * 1. Idea:\\n * Not good but we can reuse node\\'s value to mark depth of the node.\\n * First, create a queue to store the nodes will be visited (initialize the queue with the root node)\\n * After that, check front node until queue empty. For each front node, if there is no children, update the node\\'s value to max depth.\\n * If the front node has some children, push its children to the queue with children\\'s value = parent\\'s value + 1\\n * Before visit next node, remember to dequeue the current front node.\\n *\\n * 2. Algorithm\\n * TC = O(N) with N is number of nodes of the tree.\\n * SC = O(N) with N is number of nodes of the tree.\\n */\\n\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (root == NULL)\\n            return 0;\\n        \\n        int maximumDepth = 0;\\n        queue<Node*> q;\\n        root->val = 1;\\n        q.push(root);\\n        while (!q.empty()) {\\n            Node* node = q.front();\\n            int numChildren = node->children.size();\\n            for (int i = 0; i < numChildren; i++) {\\n                node->children[i]->val = node->val + 1;\\n                q.push(node->children[i]);\\n            }\\n            if (numChildren == 0)\\n                maximumDepth = max(maximumDepth, node->val);\\n            q.pop();\\n        }\\n        return maximumDepth;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 799360,
                "title": "plain-python-recursion",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root is None:\\n            return 0\\n        elif not root.children:\\n            return 1\\n        else:\\n            return 1 + max(map(self.maxDepth, root.children))\\n",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root is None:\\n            return 0\\n        elif not root.children:\\n            return 1\\n        else:\\n            return 1 + max(map(self.maxDepth, root.children))\\n",
                "codeTag": "Java"
            },
            {
                "id": 790351,
                "title": "recursive-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int depth = 0;\\n    int maxDepth(Node* root) {\\n        helper(root, 1);\\n        return depth;\\n    }\\n    \\n    void helper(Node* node, int d) {\\n        if (!node) return ;\\n        if (node->children.empty()) {\\n            if (depth < d) depth = d;\\n        } else {\\n            for (size_t i = 0; i < node->children.size(); i++) {\\n                helper(node->children[i], d + 1);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int depth = 0;\\n    int maxDepth(Node* root) {\\n        helper(root, 1);\\n        return depth;\\n    }\\n    \\n    void helper(Node* node, int d) {\\n        if (!node) return ;\\n        if (node->children.empty()) {\\n            if (depth < d) depth = d;\\n        } else {\\n            for (size_t i = 0; i < node->children.size(); i++) {\\n                helper(node->children[i], d + 1);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765324,
                "title": "simplest-fastest-0ms-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        \\n        if(root == null){\\n            return 0;\\n        }\\n\\n        int max = 0;\\n        for(int i=0; i<root.children.size(); i++){\\n            int depth = maxDepth(root.children.get(i));\\n            max = Math.max(max, depth);\\n        }\\n    \\n        return max + 1;    \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int maxDepth(Node root) {\\n        \\n        if(root == null){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 764373,
                "title": "go-golang-bfs-and-dfs-solutions",
                "content": ">Runtime: 0 ms, faster than 100.00% of Go online submissions for Maximum Depth of N-ary Tree.\\nMemory Usage: 3.5 MB, less than 16.67% of Go online submissions for Maximum Depth of N-ary Tree.\\n\\n```go\\nfunc maxDepth(root *Node) int {\\n    if root == nil { return 0 }\\n    queue, ans := []*Node{ root }, 0\\n    for len(queue) > 0 {\\n        n := len(queue)\\n        for i := 0; i < n; i++ {\\n            pop := queue[0]\\n            queue = queue[1:]\\n            for _, v := range pop.Children { queue = append(queue, v) }\\n        }\\n        ans++\\n    }\\n    return ans\\n}\\n```\\n\\n>Runtime: 0 ms, faster than 100.00% of Go online submissions for Maximum Depth of N-ary Tree.\\nMemory Usage: 3.4 MB, less than 16.67% of Go online submissions for Maximum Depth of N-ary Tree.\\n\\n```go\\nfunc maxDepth(root *Node) int {\\n    if root == nil { return 0 }\\n    ans := 0\\n    for _, child := range root.Children { ans = max(ans, maxDepth(child)) }\\n    return ans + 1\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc maxDepth(root *Node) int {\\n    if root == nil { return 0 }\\n    queue, ans := []*Node{ root }, 0\\n    for len(queue) > 0 {\\n        n := len(queue)\\n        for i := 0; i < n; i++ {\\n            pop := queue[0]\\n            queue = queue[1:]\\n            for _, v := range pop.Children { queue = append(queue, v) }\\n        }\\n        ans++\\n    }\\n    return ans\\n}\\n```\n```go\\nfunc maxDepth(root *Node) int {\\n    if root == nil { return 0 }\\n    ans := 0\\n    for _, child := range root.Children { ans = max(ans, maxDepth(child)) }\\n    return ans + 1\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 761481,
                "title": "java-dfs-4-lines",
                "content": "```\\n    public int maxDepth(Node root) {\\n        if (root == null || root.children == null) return root == null ? 0 : 1;\\n        int res = 1;\\n        for (Node node : root.children) res = Math.max(res, maxDepth(node) + 1);\\n        return res;\\n    }    \\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int maxDepth(Node root) {\\n        if (root == null || root.children == null) return root == null ? 0 : 1;\\n        int res = 1;\\n        for (Node node : root.children) res = Math.max(res, maxDepth(node) + 1);\\n        return res;\\n    }    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 757546,
                "title": "swift-easy-iterative-and-recursive-solution",
                "content": "```\\nclass Solution {\\n//Iterative\\n    func maxDepth(_ root: Node?) -> Int {\\n        guard let root = root else { return 0 }\\n        var stack: [(node: Node, level: Int)] = [(root, 1)]\\n        var maxLevel = 1\\n        \\n        while !stack.isEmpty {\\n            let parent = stack.popLast()\\n            maxLevel = max(maxLevel, parent!.level)\\n            \\n            parent!.node.children.forEach { \\n                stack.append(($0, parent!.level+1))\\n            }\\n            \\n        }\\n        return maxLevel\\n    }\\n//Recursive    \\n    func maxDepth(_ root: Node?) -> Int {\\n        guard let root = root else { return 0 }\\n        var tempMax = 0\\n        root.children.forEach {\\n            tempMax = max(tempMax, maxDepth($0))\\n        }\\n        return tempMax + 1\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n//Iterative\\n    func maxDepth(_ root: Node?) -> Int {\\n        guard let root = root else { return 0 }\\n        var stack: [(node: Node, level: Int)] = [(root, 1)]\\n        var maxLevel = 1\\n        \\n        while !stack.isEmpty {\\n            let parent = stack.popLast()\\n            maxLevel = max(maxLevel, parent!.level)\\n            \\n            parent!.node.children.forEach { \\n                stack.append(($0, parent!.level+1))\\n            }\\n            \\n        }\\n        return maxLevel\\n    }\\n//Recursive    \\n    func maxDepth(_ root: Node?) -> Int {\\n        guard let root = root else { return 0 }\\n        var tempMax = 0\\n        root.children.forEach {\\n            tempMax = max(tempMax, maxDepth($0))\\n        }\\n        return tempMax + 1\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752291,
                "title": "python-bfs-with-expression-assignment",
                "content": "BFS:\\n\\n```\\ndef maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n        q, MAX = deque(), 1\\n        q.append((root, 1))\\n        while q:\\n            n, l = q.popleft()\\n            q += [(chi, l + 1) for chi in n.children if (MAX := l + 1)]\\n        return MAX\\n```\\n\\nDFS:\\n```\\ndef maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n        MAX = 1\\n        for chi in root.children:\\n            MAX = max(self.maxDepth(chi) + 1, MAX)\\n        return MAX\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n        q, MAX = deque(), 1\\n        q.append((root, 1))\\n        while q:\\n            n, l = q.popleft()\\n            q += [(chi, l + 1) for chi in n.children if (MAX := l + 1)]\\n        return MAX\\n```\n```\\ndef maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n        MAX = 1\\n        for chi in root.children:\\n            MAX = max(self.maxDepth(chi) + 1, MAX)\\n        return MAX\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 724575,
                "title": "simple-faster-c-recursive-solution-dfs",
                "content": "class Solution {\\npublic:\\n\\n    int maxDepth(Node* root) {\\n        if (root) {\\n            vector<Node*> v = root->children;\\n            int maxiDepth = 0;\\n            for (int i = 0; i < v.size(); i++) {\\n                maxiDepth = max(maxDepth(v[i]), maxiDepth);\\n            }\\n            return 1 + maxiDepth;\\n        }\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maxDepth(Node* root) {\\n        if (root) {\\n            vector<Node*> v = root->children;\\n            int maxiDepth = 0;\\n            for (int i = 0; i < v.size(); i++) {\\n                maxiDepth = max(maxDepth(v[i]), maxiDepth);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 711921,
                "title": "python-solution",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root==None:\\n            return 0\\n        queue=[]\\n        queue.append(root)\\n        depth=0\\n        while(len(queue)!=0):\\n            l=len(queue)\\n            for i in range(l):\\n                cur=queue.pop(0)\\n                for nodes in cur.children:\\n                    queue.append(nodes)\\n            depth+=1\\n        return depth\\n                \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root==None:\\n            return 0\\n        queue=[]\\n        queue.append(root)\\n        depth=0\\n        while(len(queue)!=0):\\n            l=len(queue)\\n            for i in range(l):\\n                cur=queue.pop(0)\\n                for nodes in cur.children:\\n                    queue.append(nodes)\\n            depth+=1\\n        return depth\\n                \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 641871,
                "title": "python-recursive-solution",
                "content": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0;\\n        \\n        max_depth = 0\\n        for child in root.children:\\n            max_depth = max(max_depth, self.maxDepth(child))\\n        return 1 + max_depth\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0;\\n        \\n        max_depth = 0\\n        for child in root.children:\\n            max_depth = max(max_depth, self.maxDepth(child))\\n        return 1 + max_depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581015,
                "title": "ruby-simple-solution-but-faster-and-less-memory",
                "content": "using `map` and `flatten`\\n\\n```ruby\\ndef maxDepth(root, depth = 1)\\n  return 0 unless root\\n  children = root.children\\n  while !children.empty?\\n    children = children.map(&:children).flatten\\n    depth += 1\\n  end\\n  depth\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef maxDepth(root, depth = 1)\\n  return 0 unless root\\n  children = root.children\\n  while !children.empty?\\n    children = children.map(&:children).flatten\\n    depth += 1\\n  end\\n  depth\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 443262,
                "title": "c-beats-100-on-speed-with-explanation",
                "content": "```\\nclass Solution {\\n\\n// Recrusive solution. If we can go deeper into the node\\'s children vector\\n// (i.e. another node below it exists) then we go in. We track the maximum depth\\n// throughout the entire process, where level is the depth at a given node.\\n\\n    void setDepth(Node* root, int& maxDepth, int level) {\\n        if (!root) return;\\n        maxDepth = max(maxDepth, level);\\n        for (int i{}; i < root->children.size(); ++i) {\\n            if (root->children[i]) {\\n                setDepth(root->children[i], maxDepth, level + 1);\\n            }\\n        }\\n        return;\\n    }\\n\\t\\npublic:\\n    int maxDepth(Node* root) {\\n        int maxDepth{0};\\n\\t\\t// Level starts at 1 (1 node deep)\\n        setDepth(root, maxDepth, 1);\\n        return maxDepth;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\n// Recrusive solution. If we can go deeper into the node\\'s children vector\\n// (i.e. another node below it exists) then we go in. We track the maximum depth\\n// throughout the entire process, where level is the depth at a given node.\\n\\n    void setDepth(Node* root, int& maxDepth, int level) {\\n        if (!root) return;\\n        maxDepth = max(maxDepth, level);\\n        for (int i{}",
                "codeTag": "Java"
            },
            {
                "id": 438353,
                "title": "python-recursive-solution",
                "content": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n \\n        if root is None:\\n            return 0\\n        \\n        m = 0\\n\\n        for i in root.children:\\n            k = self.maxDepth(i)\\n            if k > m:\\n                m = k\\n        return 1 + m\\n      \\n```\\n\\n![image](https://assets.leetcode.com/users/ghisloti_duarte_de_souza/image_1574810463.png)\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n \\n        if root is None:\\n            return 0\\n        \\n        m = 0\\n\\n        for i in root.children:\\n            k = self.maxDepth(i)\\n            if k > m:\\n                m = k\\n        return 1 + m\\n      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 422575,
                "title": "java-old-school-and-simple-syntax-beats-100",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        \\n        if (root == null) return 0;\\n        if (root.children == null) return 1;\\n        \\n        int max = 0;\\n        for(Node n : root.children){\\n            int depth = maxDepth(n);\\n            if(depth > max) max = depth;\\n        }\\n        \\n        return max + 1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        \\n        if (root == null) return 0;\\n        if (root.children == null) return 1;\\n        \\n        int max = 0;\\n        for(Node n : root.children){\\n            int depth = maxDepth(n);\\n            if(depth > max) max = depth;\\n        }\\n        \\n        return max + 1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 408706,
                "title": "simplest-solution-c",
                "content": "```\\nint maxDepth(Node* root) {\\n        if(!root) return 0;\\n        int depth = 0;\\n        for(auto it : root->children)\\n            depth = max(depth, maxDepth(it));\\n        return depth+1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maxDepth(Node* root) {\\n        if(!root) return 0;\\n        int depth = 0;\\n        for(auto it : root->children)\\n            depth = max(depth, maxDepth(it));\\n        return depth+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 405017,
                "title": "java-easy-1ms-recursive-solution",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        return maxDepth(root, 0);\\n    }\\n    public int maxDepth(Node root, int currentDepth){\\n        if (root==null)return currentDepth;\\n        currentDepth++;        \\n        int max = currentDepth;\\n        for (Node child: root.children) \\n            max = Math.max(max, maxDepth(child, currentDepth));\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        return maxDepth(root, 0);\\n    }\\n    public int maxDepth(Node root, int currentDepth){\\n        if (root==null)return currentDepth;\\n        currentDepth++;        \\n        int max = currentDepth;\\n        for (Node child: root.children) \\n            max = Math.max(max, maxDepth(child, currentDepth));\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 390130,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        int max = 0;\\n        \\n        for(Node temp : root.children){\\n            max = Math.max(maxDepth(temp),max);\\n        }\\n        \\n        return max+1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        int max = 0;\\n        \\n        for(Node temp : root.children){\\n            max = Math.max(maxDepth(temp),max);\\n        }\\n        \\n        return max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 368223,
                "title": "bfs-and-dfs-very-easy-to-understand",
                "content": "**BFS**\\n```java\\npublic int maxDepth(Node root) {\\n        if(root==null) return 0;\\n        Queue<Node> queue = new LinkedList<Node>();\\n        int level=0;\\n        queue.offer(root);\\n        while(!queue.isEmpty()){\\n            int size=queue.size();\\n            level++;\\n            for(int i=0;i<size;i++){\\n                Node node=queue.poll();\\n                for(Node nextNode : node.children){\\n                    queue.offer(nextNode);\\n                }\\n            }\\n        }\\n        return level;\\n    }\\n    \\n    public int maxDepth(Node root) {\\n        return dfs(root);\\n    }\\n```\\n\\n**DFS**\\n**Similar to getting a binary height**\\n```java\\n private int dfs(Node root){\\n        int max=0;\\n        if(root==null) return 0;\\n        else if(root!=null && root.children.size()==0) return 1;\\n        else if(root!=null && root.children.size() > 0){\\n            for(Node node : root.children){\\n                int num=dfs(node);\\n                if(num>max) max=num;\\n            }\\n        }\\n        return max+1;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```java\\npublic int maxDepth(Node root) {\\n        if(root==null) return 0;\\n        Queue<Node> queue = new LinkedList<Node>();\\n        int level=0;\\n        queue.offer(root);\\n        while(!queue.isEmpty()){\\n            int size=queue.size();\\n            level++;\\n            for(int i=0;i<size;i++){\\n                Node node=queue.poll();\\n                for(Node nextNode : node.children){\\n                    queue.offer(nextNode);\\n                }\\n            }\\n        }\\n        return level;\\n    }\\n    \\n    public int maxDepth(Node root) {\\n        return dfs(root);\\n    }\\n```\n```java\\n private int dfs(Node root){\\n        int max=0;\\n        if(root==null) return 0;\\n        else if(root!=null && root.children.size()==0) return 1;\\n        else if(root!=null && root.children.size() > 0){\\n            for(Node node : root.children){\\n                int num=dfs(node);\\n                if(num>max) max=num;\\n            }\\n        }\\n        return max+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 357152,
                "title": "c-recursive",
                "content": "```C++\\nclass Solution {\\npublic:\\n    int maxDepth( Node* root ) {\\n        if( !root ) return 0;\\n        int maxHeight = 0;\\n        for( auto node : root->children ) {\\n            maxHeight = max( maxHeight, maxDepth( node ) );\\n        }\\n        return 1 + maxHeight;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int maxDepth( Node* root ) {\\n        if( !root ) return 0;\\n        int maxHeight = 0;\\n        for( auto node : root->children ) {\\n            maxHeight = max( maxHeight, maxDepth( node ) );\\n        }\\n        return 1 + maxHeight;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352991,
                "title": "simple-recursive-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root==NULL){return 0;}\\n        int m = 0;\\n        for(int i=0;i<root->children.size();i++){\\n            m = max(m,maxDepth(root->children[i]));\\n        }\\n        return 1+m;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root==NULL){return 0;}\\n        int m = 0;\\n        for(int i=0;i<root->children.size();i++){\\n            m = max(m,maxDepth(root->children[i]));\\n        }\\n        return 1+m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313168,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:return 0\\n        self.max_level = 0\\n        def dfs(node, level):\\n            self.max_level = max(self.max_level, level)\\n            if not node.children:return\\n            for child in node.children:\\n                dfs(child, level+1)\\n        dfs(root, 1)\\n        return (self.max_level)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:return 0\\n        self.max_level = 0\\n        def dfs(node, level):\\n            self.max_level = max(self.max_level, level)\\n            if not node.children:return\\n            for child in node.children:\\n                dfs(child, level+1)\\n        dfs(root, 1)\\n        return (self.max_level)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 237081,
                "title": "javascript",
                "content": "**\\u65B9\\u6CD51:** \\u5C42\\u5E8F\\u904D\\u5386\\n**\\u89E3\\u9898\\u601D\\u8DEF:**\\n1. \\u5148\\u5C42\\u5E8F\\u904D\\u5386, \\u7136\\u540E\\u4E0D\\u65AD\\u5224\\u65AD\\u5C42\\u6B21\\u5373\\u53EF.\\n\\n**\\u4EE3\\u7801:**\\n```\\nvar maxDepth = function(root) {\\n  let r = 0;\\n  const levelOrder = (node, level=1) => {\\n    if (!node) return;\\n    if (level > r) r = level;\\n    node.children.forEach(_c => levelOrder(_c, level + 1));\\n  }\\n  levelOrder(root);\\n  \\n  return r;\\n};\\n```\\n\\n**\\u65B9\\u6CD52:** \\u9012\\u5F52\\u5224\\u65AD\\n**\\u89E3\\u9898\\u601D\\u8DEF:**\\n1. \\u4E0D\\u65AD\\u5BF9children\\u8FDB\\u884C\\u9012\\u5F52\\u5904\\u7406.\\n\\n**\\u4EE3\\u7801:**\\n```\\nvar maxDepth = function(root) {\\n  if (!root) return 0;\\n  let max = 1;\\n  for (let i = 0; i < root.children.length; i++) {\\n    max = Math.max(max, maxDepth(root.children[i]) + 1);\\n  }\\n  return max;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxDepth = function(root) {\\n  let r = 0;\\n  const levelOrder = (node, level=1) => {\\n    if (!node) return;\\n    if (level > r) r = level;\\n    node.children.forEach(_c => levelOrder(_c, level + 1));\\n  }\\n  levelOrder(root);\\n  \\n  return r;\\n};\\n```\n```\\nvar maxDepth = function(root) {\\n  if (!root) return 0;\\n  let max = 1;\\n  for (let i = 0; i < root.children.length; i++) {\\n    max = Math.max(max, maxDepth(root.children[i]) + 1);\\n  }\\n  return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 234734,
                "title": "javascript-simple-two-line-solution",
                "content": "```\\n\\tif(!root) return 0;\\n    return root.children.reduce((acc, child) => Math.max(acc, maxDepth(child)), 0) + 1;\\n```",
                "solutionTags": [],
                "code": "```\\n\\tif(!root) return 0;\\n    return root.children.reduce((acc, child) => Math.max(acc, maxDepth(child)), 0) + 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 233867,
                "title": "c-one-line",
                "content": "```\\npublic class Solution {\\n    public int MaxDepth(Node root) {\\n        return root == null ? 0 : root.children.DefaultIfEmpty().Max(MaxDepth) + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxDepth(Node root) {\\n        return root == null ? 0 : root.children.DefaultIfEmpty().Max(MaxDepth) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226453,
                "title": "java-solution-faster-than-100-easy-to-understand",
                "content": "This is a recursive solution that uses a helper function. I think it\\'s a pretty straightforward solution but feel free to ask questions. Thanks!\\n\\n```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        int max = maximumDepth(root);\\n        return max; \\n    }\\n    \\n    public int maximumDepth(Node root){\\n        if(root == null) return 0;\\n        if(root.children.size() == 0) return 1;\\n        \\n        int max = 0;\\n        for(int i = 0; i < root.children.size(); i++){\\n            max = Math.max(max, maximumDepth(root.children.get(i)));\\n        }\\n        \\n        return 1 + max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        int max = maximumDepth(root);\\n        return max; \\n    }\\n    \\n    public int maximumDepth(Node root){\\n        if(root == null) return 0;\\n        if(root.children.size() == 0) return 1;\\n        \\n        int max = 0;\\n        for(int i = 0; i < root.children.size(); i++){\\n            max = Math.max(max, maximumDepth(root.children.get(i)));\\n        }\\n        \\n        return 1 + max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200326,
                "title": "python-93-solution",
                "content": "```\\nclass Solution(object):        \\n    def maxDepth(self, root):\\n        if root is None:\\n            return 0\\n    \\n        MaxVal = 1\\n        for child in root.children:\\n            depthCount = self.maxDepth(child) + 1\\n            MaxVal = max(MaxVal, depthCount)\\n            \\n    \\n        return MaxVal\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):        \\n    def maxDepth(self, root):\\n        if root is None:\\n            return 0\\n    \\n        MaxVal = 1\\n        for child in root.children:\\n            depthCount = self.maxDepth(child) + 1\\n            MaxVal = max(MaxVal, depthCount)\\n            \\n    \\n        return MaxVal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168030,
                "title": "java-8-streams-simple-solution",
                "content": "Simple recursive solution using Java 8 Stream API:\\n```\\npublic int maxDepth(Node root) {\\n         if (root == null) {\\n                return 0;\\n            }\\n            if (root.children == null ) {\\n                return 1;\\n            }\\n\\n            return 1 + root.children.stream()\\n                    .mapToInt(this::maxDepth)\\n                    .max()\\n                    .orElse(0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxDepth(Node root) {\\n         if (root == null) {\\n                return 0;\\n            }\\n            if (root.children == null ) {\\n                return 1;\\n            }\\n\\n            return 1 + root.children.stream()\\n                    .mapToInt(this::maxDepth)\\n                    .max()\\n                    .orElse(0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165681,
                "title": "concise-bfs-and-dfs-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        return recurse(root);\\n    }\\n    \\n    public int recurse(Node root) {\\n        if(root == null) return 0;\\n        if( root.children == null) return 1;\\n        \\n\\t\\t\\t int max=0;\\n        for(Node each: root.children)\\n            max = Math.max(max, recurse(each));\\n            \\n        return 1+max;\\n    }\\n}\\n\\n    public int traverseBFS(Node root) {\\n        if(root == null) return 0;\\n        \\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        int count =0, size=0;\\n        \\n        while(queue.size() > 0) {\\n            size = queue.size();\\n            \\n            for( int i=0; i< size; i++) {\\n                Node temp = queue.poll();\\n\\n                if(temp.children != null)\\n                    for( Node each : temp.children)\\n                        queue.add(each);\\n            }\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        return recurse(root);\\n    }\\n    \\n    public int recurse(Node root) {\\n        if(root == null) return 0;\\n        if( root.children == null) return 1;\\n        \\n\\t\\t\\t int max=0;\\n        for(Node each: root.children)\\n            max = Math.max(max, recurse(each));\\n            \\n        return 1+max;\\n    }\\n}\\n\\n    public int traverseBFS(Node root) {\\n        if(root == null) return 0;\\n        \\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        int count =0, size=0;\\n        \\n        while(queue.size() > 0) {\\n            size = queue.size();\\n            \\n            for( int i=0; i< size; i++) {\\n                Node temp = queue.poll();\\n\\n                if(temp.children != null)\\n                    for( Node each : temp.children)\\n                        queue.add(each);\\n            }\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148927,
                "title": "python-1-liner-in-dfs",
                "content": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        return 1 + max([self.maxDepth(n) for n in root.children] + [0]) if root else 0 \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        return 1 + max([self.maxDepth(n) for n in root.children] + [0]) if root else 0 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866117,
                "title": "dfs-using-stack-detailed-explanation",
                "content": "# Approach\\n1. The function uses a stack to traverse the tree nodes. A stack is a data structure that follows the `Last-In-First-Out` (`LIFO`) principle, meaning the last element added is the first one to be removed.\\n\\n2. First, it initializes an empty stack.\\n\\n3. It checks if the `root` node is not None (i.e., it exists). If it does, the root node and its depth (which is initially `1`) are added to the stack as a tuple: `stack += [(root, 1)]`. This sets up the starting point for the tree traversal.\\n\\n4. It also initializes a variable `maxDepth` to `0`, which will be used to keep track of the `maximum depth` encountered so far.\\n\\n5. The function enters a `while` loop that continues as long as there are elements in the stack.\\n\\n6. Inside the loop, it pops the top element from the `stack`, which is a tuple containing a node and its depth: `node, depth = stack.pop()`. This is essentially taking the last added node from the stack to process its depth.\\n\\n7. It compares the `current depth` with the `maxDepth` variable and updates maxDepth with the maximum value: `maxDepth = max(maxDepth, depth)`. This ensures that maxDepth always stores the `maximum depth` encountered during the traversal.\\n\\n8. The function then iterates over the `children` of the current node in the loop `for child in node.children:`. For each child, it calculates its depth as `depth + 1` and adds the child and its new depth as a tuple to the stack.\\n\\n9. The loop continues until all nodes are visited.\\n\\n10. After the loop, the function returns the calculated `maxDepth`, representing the maximum depth of the tree.\\n\\n- #### Time Complexity:\\n\\n1. The time complexity of this DFS algorithm depends on the number of nodes in the tree.\\n2. In the `worst` case, the algorithm visits all nodes exactly once, as it traverses the entire tree.\\n3. Therefore, the time complexity is $O(N)$, where `N` is the number of nodes in the tree.\\n\\n- #### Space Complexity:\\n\\n1. The space complexity is determined by the stack used for `DFS` traversal.\\n2. In the `worst` case, the stack can hold all the nodes in the longest path from the root to a leaf. This happens when the tree is `skewed` (essentially forming a linked list).\\n3. Therefore, the space complexity of the algorithm is $O(H)$, where `H` is the height of the tree. In the worst case (`skewed tree`), `H` can be equal to `N` (`number of nodes`), resulting in a space complexity of $O(N)$.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        stack = []\\n        if root:\\n            stack += [(root,1)]\\n        maxDepth = 0\\n        while stack:\\n            node,depth = stack.pop()\\n            maxDepth = max(maxDepth, depth)\\n            for child in node.children:\\n                stack += (child,depth+1),\\n        return maxDepth\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        stack = []\\n        if root:\\n            stack += [(root,1)]\\n        maxDepth = 0\\n        while stack:\\n            node,depth = stack.pop()\\n            maxDepth = max(maxDepth, depth)\\n            for child in node.children:\\n                stack += (child,depth+1),\\n        return maxDepth\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865955,
                "title": "bfs-iterative-solution-beats-100-runtime-detailed-explanation",
                "content": "# Performance\\n![image.png](https://assets.leetcode.com/users/images/1faec166-08ed-4304-a46b-67016843af66_1691220098.4566412.png)\\n\\n# Approach\\nHere\\'s the explanation:\\n\\n1. The code starts by creating an empty list named `queue`. This list will be used to perform a `\"breadth-first search\"` traversal of the tree nodes.\\n\\n2. Next, there is an `if` statement: `if root:`. It checks if the root node exists (i.e., it\\'s not None). If it exists, the code adds a tuple containing the root `node` and its `depth` (which is initially `1`) to the queue. This tuple represents the current node and its depth in the tree.\\n\\n3. The code then initializes a variable `maxDepth` to `0`. This variable will be used to keep track of the maximum depth found during the traversal.\\n\\n4. The code enters a loop using a for loop: `for (node, depth) in queue:`. This loop will iterate over each element `(node, depth)` in the `queue` list.\\n\\n5. Inside the loop, the code updates the `maxDepth` variable to the `current depth`. This effectively keeps track of the deepest depth found so far.\\n\\n6. The code then updates the `queue` list with new tuples. It uses a generator expression inside `queue += ...` to add elements to the `queue`. This step is crucial for the breadth-first search traversal. It iterates over each `child node` of the `current node`, and for each child, it creates a new tuple with the child node and its `depth` incremented by `1`. This is how the traversal progresses to deeper levels in the tree.\\n\\n7. The loop continues until all nodes in the `queue` have been processed. The process of adding child nodes and their depths to the queue continues, effectively exploring the tree in a breadth-first manner.\\n\\n8. Once the loop ends, the function returns the value of `maxDepth`, which represents the maximum depth of the tree (i.e., the longest path from the root to a leaf node).\\n\\nIn summary, this function performs a `breadth-first search` on a tree structure starting from the root node and finds the `maximum depth` of the tree. The maximum depth is the longest path from the root node to any leaf node.\\n\\n# Complexity\\n- #### Time Complexity:\\n\\n1. Enqueuing the `root` node: $O(1)$\\n2. The loop iterates through the queue until it becomes empty. In the worst case, it can iterate through all the nodes of the N-ary tree, which results in $O(N)$ iterations.\\n3. For each node, it iterates through its children to add them to the queue. In the `worst` case, where each node has a large number of children, this step would take $O(M)$ time per node. Since we perform this operation for each node, the total `time complexity` for this step is $O(N * M)$.\\n\\nSo the overall `time complexity` of the function is $O(N * M)$ in the `worst` case.\\n\\n- #### Space Complexity:\\n\\n1. The queue is used to store tuples of `(node, depth)`. In the `worst` case, the queue can store all the `nodes` in the tree, which results in a space complexity of $O(N)$.\\n2. Apart from the queue, the function uses a few variables (e.g., `maxDepth`), but they have constant space usage.\\n\\nSo the overall `space complexity` is $O(N)$ in the `worst` case.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        queue = []\\n        if root:\\n            queue += [(root,1)]\\n        maxDepth = 0\\n        for (node,depth) in queue:\\n            maxDepth=depth\\n            queue += ((child,depth+1) for child in node.children)\\n        return maxDepth\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        queue = []\\n        if root:\\n            queue += [(root,1)]\\n        maxDepth = 0\\n        for (node,depth) in queue:\\n            maxDepth=depth\\n            queue += ((child,depth+1) for child in node.children)\\n        return maxDepth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865642,
                "title": "recursive-sollution-o-n-detailed-explanation",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/ebf37284-fa9c-4a2a-9807-df05441c083c_1691216474.9388244.png)\\n\\n# Approach\\nLet me explain how it works step by step:\\n\\n1. First, we check if the tree has a `root` or not. If there is no root (which means the tree is empty), we conclude that the depth of the tree is `0`, because there are no branches or levels.\\n\\n2. If the tree has a root, we initialize a variable called `depth` to `1`. This means, at least, there is one level (the root level) in the tree.\\n\\n3. Now, we start exploring the branches of the `root`. We look at each branch one by one.\\n\\n4. For each branch, we call the `maxDepth` function again. But this time, we pass that branch as the new root. This is like exploring the sub-branches and the sub-branches of sub-branches, until we reach the end of each branch.\\n\\n5. When we explore each branch, we get a number, and that number tells us how deep that branch goes (the number of levels it has). We add `1` to this number because we are considering the current branch\\'s level as well.\\n\\n6. We compare this number with the current depth value, which is the maximum depth we have found so far. If the number we got from the current branch is greater than the current depth, we update `depth` to be that number.\\n\\n7. We repeat this process for each branch. So, we go through all the branches, explore their sub-branches, and keep updating `depth` if we find a deeper branch.\\n\\n8. Once we finish exploring all the branches, the depth variable will hold the maximum number of levels we found in the entire tree.\\n\\n9. Finally, we return this `maximum depth` value, which gives us the answer: How deep the tree goes, or in other words, its `maximum depth (height)`.\\n\\nIn summary, the `maxDept`h function explores the tree\\'s branches and sub-branches, recursively finding the `deepest path` possible, and returns the maximum number of levels in the tree, giving us its `height`.\\n\\n- #### Time complexity:\\nThe time complexity of the code is $$O(N)$$, where `N` is the number of nodes in the tree. This is because, in the worst-case scenario, we may have to visit all nodes of the tree once.\\n\\n- #### Space complexity:\\nThe space complexity of the code is $$O(H)$$, where `H` is the maximum height (depth) of the tree. This is because the function uses recursion, and the maximum depth of the call stack will be equal to the height of the tree. In other words, the function will create a new call frame for each level of the tree it explores. If the tree is well-balanced (i.e., has a smaller height), the space complexity will be relatively low. However, if the tree is unbalanced (i.e., skewed), the space complexity could be higher.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root:\\n            return 0\\n        depth = 1\\n        for node in root.children:\\n            curr = self.maxDepth(node)+1\\n            depth = max(depth, curr)\\n        return depth\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root:\\n            return 0\\n        depth = 1\\n        for node in root.children:\\n            curr = self.maxDepth(node)+1\\n            depth = max(depth, curr)\\n        return depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729516,
                "title": "c-accepted-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public int helper(Node root, int cur){\\n        if(root!=null){\\n            if(root.children.Count==0)\\n                return cur;\\n            int tmp,max=-1;\\n            for(int i=0;i<root.children.Count;i++){\\n                tmp=helper(root.children[i],cur+1);\\n                if(tmp>max)\\n                    max=tmp;\\n            }\\n            return max;\\n        } else\\n            return cur;\\n    }\\n    public int MaxDepth(Node root) {\\n        return root==null?0: helper(root,1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int helper(Node root, int cur){\\n        if(root!=null){\\n            if(root.children.Count==0)\\n                return cur;\\n            int tmp,max=-1;\\n            for(int i=0;i<root.children.Count;i++){\\n                tmp=helper(root.children[i],cur+1);\\n                if(tmp>max)\\n                    max=tmp;\\n            }\\n            return max;\\n        } else\\n            return cur;\\n    }\\n    public int MaxDepth(Node root) {\\n        return root==null?0: helper(root,1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641746,
                "title": "c-bfs-simple",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (!root) return 0;\\n\\n        int levels = 0;\\n        queue<Node*> Q; Q.push(root);\\n\\n        while (!Q.empty()) {\\n            size_t size = Q.size();\\n            levels++;\\n            for (int _ = 0; _ < size; _++) {\\n                Node* curr = Q.front(); Q.pop();\\n                for (Node*& child : curr->children) Q.push(child);\\n            }\\n        }\\n\\n        return levels;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Queue"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (!root) return 0;\\n\\n        int levels = 0;\\n        queue<Node*> Q; Q.push(root);\\n\\n        while (!Q.empty()) {\\n            size_t size = Q.size();\\n            levels++;\\n            for (int _ = 0; _ < size; _++) {\\n                Node* curr = Q.front(); Q.pop();\\n                for (Node*& child : curr->children) Q.push(child);\\n            }\\n        }\\n\\n        return levels;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155533,
                "title": "python-simple-bfs-beats-tc-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(V+E)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(|V|)$$\\n\\n# Code\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root==None:\\n            return 0\\n        que=Deque()\\n        que.append(root)\\n        count=0\\n        while(que):\\n            n=len(que)\\n            for _ in range(n):\\n                cur=que.popleft()\\n                for i in cur.children:\\n                    que.append(i)\\n            count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root==None:\\n            return 0\\n        que=Deque()\\n        que.append(root)\\n        count=0\\n        while(que):\\n            n=len(que)\\n            for _ in range(n):\\n                cur=que.popleft()\\n                for i in cur.children:\\n                    que.append(i)\\n            count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918104,
                "title": "100-beats-easy-step-java",
                "content": "- 38/38 cases passed (0 ms)\\n- Your runtime beats 100 % of java submissions\\n- Your memory usage beats 86.23 % of java submissions (42.4 MB)\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    int trav(Node n, int p){\\n        if(n==null)return p;\\n        int max=p;\\n        for(int i=0;i<n.children.size();i++)\\n            max=Math.max(max, trav(n.children.get(i), p+1));\\n        \\n        return max;\\n    }\\n\\n\\n    public int maxDepth(Node root) {\\n        if(root==null) return 0;\\n        return trav(root,1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    int trav(Node n, int p){\\n        if(n==null)return p;\\n        int max=p;\\n        for(int i=0;i<n.children.size();i++)\\n            max=Math.max(max, trav(n.children.get(i), p+1));\\n        \\n        return max;\\n    }\\n\\n\\n    public int maxDepth(Node root) {\\n        if(root==null) return 0;\\n        return trav(root,1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772897,
                "title": "golang-solution-clean-concise-bfs",
                "content": "```\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Children []*Node\\n * }\\n */\\n\\nfunc maxDepth(root *Node) int {\\n    if root == nil {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tqueue := []*Node{root}\\n\\tvar depth int\\n\\n\\tfor len(queue) > 0 {\\n\\t\\tfor _, node := range queue {\\t\\t\\t\\n\\t\\t\\tqueue = queue[1:]\\n\\t\\t\\tif node.Children != nil {\\n\\t\\t\\t\\tfor _, child := range node.Children {\\n\\t\\t\\t\\t\\tqueue = append(queue, child)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdepth++\\n\\t}\\n\\n\\treturn depth\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Children []*Node\\n * }\\n */\\n\\nfunc maxDepth(root *Node) int {\\n    if root == nil {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tqueue := []*Node{root}\\n\\tvar depth int\\n\\n\\tfor len(queue) > 0 {\\n\\t\\tfor _, node := range queue {\\t\\t\\t\\n\\t\\t\\tqueue = queue[1:]\\n\\t\\t\\tif node.Children != nil {\\n\\t\\t\\t\\tfor _, child := range node.Children {\\n\\t\\t\\t\\t\\tqueue = append(queue, child)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdepth++\\n\\t}\\n\\n\\treturn depth\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2710737,
                "title": "easy-c-solution-dfs",
                "content": "```\\n\\tint ans = INT_MIN;\\n    void solve(Node* root,int depth)\\n    {\\n        if(!root)\\n            return;\\n        ans = max(ans,depth);\\n        \\n        for(int i=0;i<root->children.size();i++)\\n        {\\n            solve(root->children[i],depth+1);  // move to root\\'s children and increase depth by 1\\n        }\\n    }\\n    \\n    int maxDepth(Node* root) {\\n        if(!root)\\n            return 0;\\n        solve(root,1);\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\tint ans = INT_MIN;\\n    void solve(Node* root,int depth)\\n    {\\n        if(!root)\\n            return;\\n        ans = max(ans,depth);\\n        \\n        for(int i=0;i<root->children.size();i++)\\n        {\\n            solve(root->children[i],depth+1);  // move to root\\'s children and increase depth by 1\\n        }\\n    }\\n    \\n    int maxDepth(Node* root) {\\n        if(!root)\\n            return 0;\\n        solve(root,1);\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2710372,
                "title": "ruby-with-recursion-from-junior",
                "content": "```\\ndef maxDepth(root)\\n    return 0 unless root\\n    @max, k = 1, 1\\n    walker(root,k)\\n    @max\\nend\\n\\ndef walker(root,k)\\n    @max = k unless k <= @max\\n    root.children.each { |child| walker(child,k+1)}\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef maxDepth(root)\\n    return 0 unless root\\n    @max, k = 1, 1\\n    walker(root,k)\\n    @max\\nend\\n\\ndef walker(root,k)\\n    @max = k unless k <= @max\\n    root.children.each { |child| walker(child,k+1)}\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2672301,
                "title": "python-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root == None:\\n            return 0\\n        else:\\n            depth = 0\\n            nodes_queue = [root]\\n            next_nodes_queue = []\\n            while(nodes_queue):\\n                node_out = nodes_queue.pop(0)\\n                for child in node_out.children:\\n                    next_nodes_queue.append(child)\\n                if nodes_queue == []:\\n                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue\\n                    depth += 1\\n            return depth\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root == None:\\n            return 0\\n        else:\\n            depth = 0\\n            nodes_queue = [root]\\n            next_nodes_queue = []\\n            while(nodes_queue):\\n                node_out = nodes_queue.pop(0)\\n                for child in node_out.children:\\n                    next_nodes_queue.append(child)\\n                if nodes_queue == []:\\n                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue\\n                    depth += 1\\n            return depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662396,
                "title": "recursive-java-easy-solution",
                "content": "```\\nclass Solution {\\n    static int maxcount ;\\n    void maxheight(Node root,int height){\\n        if(root!=null){\\n            height++;\\n            if((root.children).isEmpty()){\\n            if(height>maxcount){\\n                maxcount = height;\\n            }\\n        }\\n        \\n        for(Node child : root.children){\\n            maxheight(child,height);\\n        }\\n        }\\n        \\n    }\\n    public int maxDepth(Node root) {\\n        maxcount = 0;\\n        int height = 0;\\n        maxheight(root,height);\\n        return maxcount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    static int maxcount ;\\n    void maxheight(Node root,int height){\\n        if(root!=null){\\n            height++;\\n            if((root.children).isEmpty()){\\n            if(height>maxcount){\\n                maxcount = height;\\n            }\\n        }\\n        \\n        for(Node child : root.children){\\n            maxheight(child,height);\\n        }\\n        }\\n        \\n    }\\n    public int maxDepth(Node root) {\\n        maxcount = 0;\\n        int height = 0;\\n        maxheight(root,height);\\n        return maxcount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639215,
                "title": "1-line-python-easy-using-dfs",
                "content": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        return max(self.maxDepth(child) for child in root.children or [0]) + 1 if root else 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        return max(self.maxDepth(child) for child in root.children or [0]) + 1 if root else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568677,
                "title": "java-recursive-short-and-intuitive",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if (root == null) return 0;\\n        List<Node> children = root.children;\\n        int max = 0;\\n        for (Node node : children) {\\n            max = Math.max(max, maxDepth(node));\\n        }\\n        return 1 + max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if (root == null) return 0;\\n        List<Node> children = root.children;\\n        int max = 0;\\n        for (Node node : children) {\\n            max = Math.max(max, maxDepth(node));\\n        }\\n        return 1 + max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547270,
                "title": "very-easy-one-liner-implementations",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        def dfs(node):\\n            if not node:\\n                return 0\\n            return 1+max([dfs(child) for child in node.children if node.children],default=0)\\n        return dfs(root)\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        def dfs(node):\\n            if not node:\\n                return 0\\n            return 1+max([dfs(child) for child in node.children if node.children],default=0)\\n        return dfs(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535053,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        queue<Node*>q;\\n        if(root==NULL)return 0;\\n        q.push(root);\\n        int c=0;\\n        while(!q.empty()){\\n            int s=q.size();\\n            for(int i=0;i<s;i++){\\n                Node* a=q.front();\\n                q.pop();\\n                for(auto j:a->children){\\n                    q.push(j);\\n                }\\n            }\\n            c++;\\n            \\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        queue<Node*>q;\\n        if(root==NULL)return 0;\\n        q.push(root);\\n        int c=0;\\n        while(!q.empty()){\\n            int s=q.size();\\n            for(int i=0;i<s;i++){\\n                Node* a=q.front();\\n                q.pop();\\n                for(auto j:a->children){\\n                    q.push(j);\\n                }\\n            }\\n            c++;\\n            \\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506696,
                "title": "easy-shoort-fast-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n    public int maxDepth(Node root) {\\n        dfs(root, 1);\\n        return max;\\n    }\\n    \\n    int max = 0;\\n    \\n    private void dfs(Node root, int lvl){\\n        if(root == null) return ;\\n        \\n        max = Math.max(max, lvl);\\n        \\n        for(Node node: root.children) dfs(node, lvl+1);\\n        \\n        return ;\\n    }\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2504549,
                "title": "simple-pyhton-solution-faster-bfs-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if(root==None):\\n            return 0\\n        \\n        q=collections.deque()\\n        q.append(root)\\n        level=0\\n        while(q):\\n            level+=1\\n            for i in range(len(q)):\\n                node=q.popleft()\\n                for i in node.children:\\n                    q.append(i)\\n        return level\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if(root==None):\\n            return 0\\n        \\n        q=collections.deque()\\n        q.append(root)\\n        level=0\\n        while(q):\\n            level+=1\\n            for i in range(len(q)):\\n                node=q.popleft()\\n                for i in node.children:\\n                    q.append(i)\\n        return level\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346441,
                "title": "java-bfs-solution",
                "content": "\\n\\tpublic int maxDepth(Node root) {\\n        int depth = 0;\\n        \\n        if (root == null)\\n            return 0;\\n        \\n        Deque<Node> queue = new ArrayDeque<>();\\n        \\n        queue.addLast(root);\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                Node cur = queue.pollFirst();\\n                for (Node node : cur.children)\\n                    queue.addLast(node);\\n            }\\n            depth++;\\n        }\\n        \\n        return depth;\\n    }",
                "solutionTags": [],
                "code": "\\n\\tpublic int maxDepth(Node root) {\\n        int depth = 0;\\n        \\n        if (root == null)\\n            return 0;\\n        \\n        Deque<Node> queue = new ArrayDeque<>();\\n        \\n        queue.addLast(root);\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                Node cur = queue.pollFirst();\\n                for (Node node : cur.children)\\n                    queue.addLast(node);\\n            }\\n            depth++;\\n        }\\n        \\n        return depth;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2266146,
                "title": "java-0-ms-100-faster-5-line-code-no-helper-fun-simple-recursion",
                "content": "\\'\\'\\'\\npublic int maxDepth(Node root) {\\n        if(root == null){return 0;}\\n        if(root.children.size() == 0){return 1;}\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<root.children.size();i++){\\n            max = Math.max(max,maxDepth(root.children.get(i)));\\n        }\\n        return 1+max;   \\n    }\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "\\'\\'\\'\\npublic int maxDepth(Node root) {\\n        if(root == null){return 0;}\\n        if(root.children.size() == 0){return 1;}\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<root.children.size();i++){\\n            max = Math.max(max,maxDepth(root.children.get(i)));\\n        }\\n        return 1+max;   \\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2266014,
                "title": "python-clean-code-o-n",
                "content": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        def dfs(v):\\n            if not v: return 0\\n            res = 1\\n            for w in v.children:\\n                res = max(res, 1+dfs(w))\\n            return res\\n        return dfs(root)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        def dfs(v):\\n            if not v: return 0\\n            res = 1\\n            for w in v.children:\\n                res = max(res, 1+dfs(w))\\n            return res\\n        return dfs(root)",
                "codeTag": "Java"
            },
            {
                "id": 2247981,
                "title": "0ms-100-faster-java-simple-solution",
                "content": "![image](https://assets.leetcode.com/users/images/f165d15c-54b3-4a58-9b0f-b7bf3fda12f8_1657138401.865614.png)\\n```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        int level = 0;\\n        levelOrderTraversal(root, result, level);\\n        \\n        return result.size();\\n    }\\n    private void levelOrderTraversal(Node root, List<List<Integer>> result, int level){\\n        \\n        if(level >= result.size()){\\n            List<Integer> list = new ArrayList<>();\\n            list.add(root.val);\\n            result.add(list);\\n        }else{\\n            result.get(level).add(root.val);\\n        }\\n        for(int i = 0; i < root.children.size(); i++){\\n            levelOrderTraversal(root.children.get(i), result, level+1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        int level = 0;\\n        levelOrderTraversal(root, result, level);\\n        \\n        return result.size();\\n    }\\n    private void levelOrderTraversal(Node root, List<List<Integer>> result, int level){\\n        \\n        if(level >= result.size()){\\n            List<Integer> list = new ArrayList<>();\\n            list.add(root.val);\\n            result.add(list);\\n        }else{\\n            result.get(level).add(root.val);\\n        }\\n        for(int i = 0; i < root.children.size(); i++){\\n            levelOrderTraversal(root.children.get(i), result, level+1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192345,
                "title": "easy-logic-completed-in-3ms",
                "content": "class Solution {\\n    public int maxDepth(Node root) {\\n        Queue<Node> queue=new LinkedList<>();\\n        int count=0;\\n        if(root==null)\\n            return count;\\n        queue.offer(root);\\n        while(queue.size()!=0)\\n        {\\n            int len=queue.size();\\n            for(int i=0;i<len;i++)\\n            {\\n                Node node=queue.poll();\\n                //if(node!=null)\\n                for(Node child:node.children)\\n                    queue.offer(child);\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxDepth(Node root) {\\n        Queue<Node> queue=new LinkedList<>();\\n        int count=0;\\n        if(root==null)\\n            return count;\\n        queue.offer(root);\\n        while(queue.size()!=0)\\n        {\\n            int len=queue.size();\\n            for(int i=0;i<len;i++)\\n            {\\n                Node node=queue.poll();\\n                //if(node!=null)\\n                for(Node child:node.children)\\n                    queue.offer(child);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2190005,
                "title": "c-dfs-bfs-solutions",
                "content": "**Code (dfs - recursive):**\\n```\\nclass Solution {\\n public:\\n  int MaxDepth(Node *root) {\\n    if (!root) return 0;\\n    int max_depth = 0;\\n    for (auto child : root->children)\\n      max_depth = max(max_depth, MaxDepth(child));\\n    return max_depth + 1;\\n  }\\n};\\n```\\n\\n---\\n**Code (dfs - iterative):**\\n```\\nclass Solution {\\n public:\\n  int MaxDepth(Node *root) {\\n    int max_depth = 0, depth;\\n    stack<pair<Node *, int>> s;\\n\\n    if (root) s.push({root, 1});\\n    while (!s.empty()) {\\n      root = s.top().first;\\n      depth = s.top().second;\\n      s.pop();\\n\\n      if (root->children.empty())\\n        max_depth = max(max_depth, depth);\\n      for (auto child : root->children)\\n        s.push({child, depth + 1});\\n    }\\n    return max_depth;\\n  }\\n};\\n```\\n\\n---\\n**Code (bfs - iterative):**\\n```\\nclass Solution {\\n public:\\n  int MaxDepth(Node *root) {\\n    int max_depth = 0, breadth;\\n    queue<Node *> q;\\n\\n    if (root) q.push(root);\\n    while (!q.empty()) {\\n      breadth = q.size(), max_depth++;\\n      for (int i = 0; i < breadth; i++) {\\n        root = q.front(), q.pop();\\n        for (auto child : root->children) q.push(child);\\n      }\\n    }\\n    return max_depth;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int MaxDepth(Node *root) {\\n    if (!root) return 0;\\n    int max_depth = 0;\\n    for (auto child : root->children)\\n      max_depth = max(max_depth, MaxDepth(child));\\n    return max_depth + 1;\\n  }\\n};\\n```\n```\\nclass Solution {\\n public:\\n  int MaxDepth(Node *root) {\\n    int max_depth = 0, depth;\\n    stack<pair<Node *, int>> s;\\n\\n    if (root) s.push({root, 1});\\n    while (!s.empty()) {\\n      root = s.top().first;\\n      depth = s.top().second;\\n      s.pop();\\n\\n      if (root->children.empty())\\n        max_depth = max(max_depth, depth);\\n      for (auto child : root->children)\\n        s.push({child, depth + 1});\\n    }\\n    return max_depth;\\n  }\\n};\\n```\n```\\nclass Solution {\\n public:\\n  int MaxDepth(Node *root) {\\n    int max_depth = 0, breadth;\\n    queue<Node *> q;\\n\\n    if (root) q.push(root);\\n    while (!q.empty()) {\\n      breadth = q.size(), max_depth++;\\n      for (int i = 0; i < breadth; i++) {\\n        root = q.front(), q.pop();\\n        for (auto child : root->children) q.push(child);\\n      }\\n    }\\n    return max_depth;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125689,
                "title": "c-simple-approach-recursive-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root==NULL)\\n            return 0;\\n        int ans=0;\\n        for(int i=0;i<root->children.size();i++)\\n        {\\n            int temp=maxDepth(root->children[i]);\\n            ans=max(ans,temp);\\n        }\\n        return 1+ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root==NULL)\\n            return 0;\\n        int ans=0;\\n        for(int i=0;i<root->children.size();i++)\\n        {\\n            int temp=maxDepth(root->children[i]);\\n            ans=max(ans,temp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2091554,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        int max = 1;\\n        for(Node c: root.children) {\\n            max = Math.max(max, 1 + maxDepth(c));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        int max = 1;\\n        for(Node c: root.children) {\\n            max = Math.max(max, 1 + maxDepth(c));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989133,
                "title": "javascript-dfs-recursive-solution-with-short-comment-image-91-65-faster",
                "content": "```\\nvar maxDepth = function(root) {\\n    if(!root) return 0;  // if root is null, depth is 0\\n    let depth = 1;  // root\\'s depth is 1\\n    let max = 0;  // maximum depth of each children node\\n    \\n    for(let child of root.children) {\\n        max = Math.max(maxDepth(child), max)  // Calculate the maximum depth of each children node with recursion\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // it means each children node to be root node in maxDepth() function recursion\\n    }\\n    depth += max;  // root node\\'s depth is to be calculated root node\\'s depth(1) plus maximum depth of each children node\\n    return depth;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/d8835efe-8d3f-4026-8ce7-0138d2877d1d_1651154028.2737224.jpeg)\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar maxDepth = function(root) {\\n    if(!root) return 0;  // if root is null, depth is 0\\n    let depth = 1;  // root\\'s depth is 1\\n    let max = 0;  // maximum depth of each children node\\n    \\n    for(let child of root.children) {\\n        max = Math.max(maxDepth(child), max)  // Calculate the maximum depth of each children node with recursion\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // it means each children node to be root node in maxDepth() function recursion\\n    }\\n    depth += max;  // root node\\'s depth is to be calculated root node\\'s depth(1) plus maximum depth of each children node\\n    return depth;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977860,
                "title": "js-dfs-recursion-easy-one",
                "content": "1. **make array for storing depth for every child**\\n2. **traverse with DFS  to last leaf node of every child**\\n3. **return max depth of it**\\n\\n\\n```\\nvar maxDepth = function(root) {\\nlet nums= [];\\n    traverseDepth(root,nums,0)\\n    let max=  Math.max(...nums);\\n  return  max<=0 ?0:max;\\n}\\n\\nfunction traverseDepth(root,nums,depth=0){\\n    if(!root) return 0;\\n     let c= depth;\\n        for (child of root.children){\\n            if(child)\\n            c= traverseDepth(child,nums,depth+1)\\n            \\n            \\n        }\\n    \\n    \\n  nums.push(c+1)\\n    return c; \\n    \\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar maxDepth = function(root) {\\nlet nums= [];\\n    traverseDepth(root,nums,0)\\n    let max=  Math.max(...nums);\\n  return  max<=0 ?0:max;\\n}\\n\\nfunction traverseDepth(root,nums,depth=0){\\n    if(!root) return 0;\\n     let c= depth;\\n        for (child of root.children){\\n            if(child)\\n            c= traverseDepth(child,nums,depth+1)\\n            \\n            \\n        }\\n    \\n    \\n  nums.push(c+1)\\n    return c; \\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1963939,
                "title": "faster-than-80-easy-java",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node node) {\\n        if (node == null)\\n            return 0;\\n        int ht = 0;\\n        for (Node child : node.children) {\\n            ht= Math.max(ht, maxDepth(child));\\n        }\\n        return ht+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node node) {\\n        if (node == null)\\n            return 0;\\n        int ht = 0;\\n        for (Node child : node.children) {\\n            ht= Math.max(ht, maxDepth(child));\\n        }\\n        return ht+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946408,
                "title": "easy-to-understand-java-bfs-level-order-dfs",
                "content": "**BFS**\\n```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        Queue<Node> que = new LinkedList<>();\\n        que.add(root);\\n        int level =0;\\n        while(!que.isEmpty()){\\n            level++;\\n            int size = que.size();\\n            for(int i=0; i<size; i++){\\n                Node cur = que.poll();\\n                List<Node> child = cur.children;\\n                for(Node children: child){\\n                    que.add(children);\\n                }\\n            }\\n            \\n        }\\n        return level;\\n    }\\n}\\n```\\n\\n**DFS**\\n```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        int height = 1;\\n        for(Node child: root.children){\\n            height = Math.max(height, 1+maxDepth(child));\\n        }\\n        return height;\\n    }\\n}\\n```\\n\\n\\nIf you have any **doubts**, feel **free to ask**...\\nIf you understand the **concept**. Don\\'t Forget to **upvote**\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        Queue<Node> que = new LinkedList<>();\\n        que.add(root);\\n        int level =0;\\n        while(!que.isEmpty()){\\n            level++;\\n            int size = que.size();\\n            for(int i=0; i<size; i++){\\n                Node cur = que.poll();\\n                List<Node> child = cur.children;\\n                for(Node children: child){\\n                    que.add(children);\\n                }\\n            }\\n            \\n        }\\n        return level;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        int height = 1;\\n        for(Node child: root.children){\\n            height = Math.max(height, 1+maxDepth(child));\\n        }\\n        return height;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918255,
                "title": "python-bfs",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        \\n        current_depth = 1\\n        if not root:\\n            return 0\\n        queue = [root]\\n        \\n        while(queue):\\n            l = len(queue)\\n            for i in range(l):\\n                node = queue.pop(0)\\n                for n in node.children:\\n                    if n:\\n                        queue.append(n)\\n            current_depth +=1\\n        \\n        return current_depth-1\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        \\n        current_depth = 1\\n        if not root:\\n            return 0\\n        queue = [root]\\n        \\n        while(queue):\\n            l = len(queue)\\n            for i in range(l):\\n                node = queue.pop(0)\\n                for n in node.children:\\n                    if n:\\n                        queue.append(n)\\n            current_depth +=1\\n        \\n        return current_depth-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890005,
                "title": "c-simple-solution-using-accumulate",
                "content": "\\tint maxDepth(Node* root) {\\n\\t\\t\\tif(!root)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\treturn std::accumulate(\\n\\t\\t\\t\\troot->children.begin(), root->children.end(), 1, \\n\\t\\t\\t\\t[this](int maxResult, Node* node) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// if node exists return 1 + (depth of children) else just 0 and accumulate the result by taking max.\\n\\t\\t\\t\\t\\treturn std::max(maxResult, !node? 0 : 1 + maxDepth(node) );\\n\\t\\t\\t\\t});\\n\\t\\t}",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tint maxDepth(Node* root) {\\n\\t\\t\\tif(!root)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\treturn std::accumulate(\\n\\t\\t\\t\\troot->children.begin(), root->children.end(), 1, \\n\\t\\t\\t\\t[this](int maxResult, Node* node) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// if node exists return 1 + (depth of children) else just 0 and accumulate the result by taking max.\\n\\t\\t\\t\\t\\treturn std::max(maxResult, !node? 0 : 1 + maxDepth(node) );\\n\\t\\t\\t\\t});\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1887461,
                "title": "python-dfs-clean-code",
                "content": "```\\ndef height(root):\\n    if root is None:\\n        return 0\\n    ans=0\\n    for i in root.children:\\n        ans=max(ans,height(i))\\n    return ans+1\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        return height(root)\\n```\\n   **if you like the solution please upvote**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef height(root):\\n    if root is None:\\n        return 0\\n    ans=0\\n    for i in root.children:\\n        ans=max(ans,height(i))\\n    return ans+1\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        return height(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881273,
                "title": "simple-4-lines-of-c-code-check-it-once",
                "content": "# **[@iprincekumark](https://leetcode.com/iprincekumark/)**\\nVISIT MY PROFILE\\n**CODE**\\n```\\nint maxDepth(Node* root) {\\n        if(root == NULL)\\n            return 0;\\n        int i, depth = 1;\\n        for(i=0; i<root->children.size(); i++)\\n            depth = max(maxDepth(root->children[i]) + 1, depth);\\n        return depth;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint maxDepth(Node* root) {\\n        if(root == NULL)\\n            return 0;\\n        int i, depth = 1;\\n        for(i=0; i<root->children.size(); i++)\\n            depth = max(maxDepth(root->children[i]) + 1, depth);\\n        return depth;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1815357,
                "title": "c-bfs-dfs-two-methods-to-implement",
                "content": "(1)Level Traversal, BFS\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(!root)\\n            return 0;\\n        \\n        queue<Node*> q;\\n        Node* curr=root;\\n        q.push(curr);\\n        int depth=0;\\n        while(!q.empty()){\\n            depth++;\\n            int n_level=q.size();\\n            for(int i=0;i<n_level;i++){\\n                curr=q.front();\\n                q.pop();\\n                for(Node* t:curr->children){\\n                    q.push(t);\\n                }\\n            }\\n        }\\n        return depth;\\n    }\\n};\\n```\\n(2)DFS\\n```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(!root)\\n            return 0;\\n        \\n        int res=0;\\n        int temp=0;\\n        for(Node* t:root->children){\\n            temp=maxDepth(t);\\n            res=max(res,temp);\\n        }\\n        return res+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(!root)\\n            return 0;\\n        \\n        queue<Node*> q;\\n        Node* curr=root;\\n        q.push(curr);\\n        int depth=0;\\n        while(!q.empty()){\\n            depth++;\\n            int n_level=q.size();\\n            for(int i=0;i<n_level;i++){\\n                curr=q.front();\\n                q.pop();\\n                for(Node* t:curr->children){\\n                    q.push(t);\\n                }\\n            }\\n        }\\n        return depth;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(!root)\\n            return 0;\\n        \\n        int res=0;\\n        int temp=0;\\n        for(Node* t:root->children){\\n            temp=maxDepth(t);\\n            res=max(res,temp);\\n        }\\n        return res+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1797459,
                "title": "c-easy-to-understand",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int h = 0;\\n        \\n        for(auto x : root->children){\\n            h = max(h,maxDepth(x));\\n        }\\n        return 1+h;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int h = 0;\\n        \\n        for(auto x : root->children){\\n            h = max(h,maxDepth(x));\\n        }\\n        return 1+h;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769554,
                "title": "java-simple-recursive-solution-beats-100-runtime",
                "content": "The code explains itself.\\n\\n```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        int depth = 0;\\n        for(int i = 0; i < root.children.size(); i++){\\n            depth = Math.max(depth, maxDepth(root.children.get(i)));\\n        }\\n        return depth + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        int depth = 0;\\n        for(int i = 0; i < root.children.size(); i++){\\n            depth = Math.max(depth, maxDepth(root.children.get(i)));\\n        }\\n        return depth + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757615,
                "title": "python-1-liner",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        return 1 + max(map(self.maxDepth, root.children), default = 0) if root else 0\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        return 1 + max(map(self.maxDepth, root.children), default = 0) if root else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737715,
                "title": "simple-dfs-solution-in-python",
                "content": "\\xB4\\xB4\\xB4\\nclass Solution:\\n\\n    def isLeaf(self, node):\\n        return node.children == []\\n    \\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root == None:\\n            return 0\\n        \\n        stack = []\\n        checked = {}\\n        count = 0\\n        checked[root] = 1\\n        stack.append(root)\\n        \\n        while stack != []:\\n            current = stack.pop()\\n            \\n            if self.isLeaf(current):\\n                count = max(count, checked[current])\\n            else:\\n                for i in current.children:\\n                    if i not in checked:\\n                        stack.append(i)\\n                        checked[i] = checked[current] + 1\\n        return count\\n\\xB4\\xB4\\xB4",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n\\n    def isLeaf(self, node):\\n        return node.children == []\\n    \\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root == None:\\n            return 0\\n        \\n        stack = []\\n        checked = {}",
                "codeTag": "Java"
            },
            {
                "id": 1723408,
                "title": "beginner-friendly-java-solution",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null)    return 0;\\n        int max = 0;\\n        for(Node child : root.children){\\n            max = Math.max(max, maxDepth(child));\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null)    return 0;\\n        int max = 0;\\n        for(Node child : root.children){\\n            max = Math.max(max, maxDepth(child));\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1572140,
                "content": [
                    {
                        "username": "Kurtz",
                        "content": "From the description, we don\\'t know if a node has no children, will it be ``self.children == []``, or ``self.children == None``. It will be ideal to add a line indicating that ``self.children = []`` if the node has no children."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "DFS using stack, Detailed Explanation\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3866117/dfs-using-stack-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`BFS` iterative approach, Beats 100% Runtime\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865955/bfs-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Explore the tree\\'s `branches` and `sub-branches`, recursively finding the deepest path possible, and returns the maximum number of levels in the tree, giving us its height!!! Simple!\\n\\n`Here is Recursive Implementation` $$O(N)$$, with Detailed Explanation:\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865642/recursive-sollution-o-n-detailed-explanation/"
                    },
                    {
                        "username": "edsaunders92",
                        "content": "Type hint poor in Python3. Optional would be clearer"
                    },
                    {
                        "username": "fantazer",
                        "content": " 22 / 38 testcases passed\\nTime Limit Exceeded\\n\\n`int maxDepth(struct Node* root) {\\n\\n    if (!root) return 0;\\n    int max = 0;\\n    for (int i = 0; i<root->numChildren; i++){\\n        if (maxDepth(root->children[i]) > max) max = maxDepth(root->children[i]);\\n    }\\n    return 1+max;\\n\\n}`\\n\\nIs this code logically correct, but too unefficient? If so, how can I optimize it? "
                    },
                    {
                        "username": "ribhav_32",
                        "content": "for (int i = 0; i<root->children.size(); i++){\n            mx = max(mx,maxDepth(root->children[i]));\n        }\nreturn 1+mx;\n\njust modify your code as shown above \nbecause you are recursively checking same thing many times by using if condition."
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "[@fantazer](/fantazer) It seems like it\\'s the way your code is written. You are recursively checking the max depth of EVERY NODE first and then using the if condition to set the max variable which is AGAIN recursively searching EVERY NODE. \\n\\nIn essence that is very redundant which I think is what\\'s causing your code to exceed the time limit. You can instead try this\\n- Search the node\\'s children\\n- Add the depth of the children to a list\\n- Return the max value of the depths of the children\\n\\nImplement the above recursively and it should work."
                    },
                    {
                        "username": "fantazer",
                        "content": "[@drvnprgrmr](/drvnprgrmr) the failed testcase is long af, so I am assuming that everything is ok, just too slow. (Time Limit Exceeded, 22 / 38 testcases passed)\n\n[4,null,9,null,2,null,0,null,7,null,6,null,4,null,7,null,7,null,7,null,1,null,4,null,0,null,7,null,3,null,1,null,9,null,9,null,3,null,1,null,8,null,5,null,7,null,0,null,5,null,0,null,3,null,9,null,8,null,9,null,7,null,7,null,1,null,5,null,6,null,5,null,6,null,7,null,2,null,1,null,9,null,10,null,9,null,3,null,3,null,1,null,10,null,0,null,10,null,10,null,7,null,9,null,10,null,1,null,7,null,9,null,10,null,10,null,0,null,9,null,8,null,6,null,10,null,3,null,1,null,6,null,0,null,9,null,9,null,2,null,7,null,7,null,5,null,8,null,2,null,6,null,6,null,2,null,3,null,5,null,2,null,2,null,3,null,3,null,9,null,10,null,6,null,1,null,2,null,7,null,4,null,4,null,5,null,3,null,9,null,4,null,0,null,0,null,1,null,3,null,4,null,2,null,0,null,3,null,4,null,8,null,7,null,10,null,4,null,1,null,5,null,6,null,8,null,5,null,8,null,5,null,7,null,6,null,5,null,8,null,10,null,8,null,3,null,4,null,4,null,6,null,8,null,8,null,0,null,9,null,3,null,4,null,4,null,6,null,9,null,2,null,0,null,8,null,3,null,7,null,5,null,10,null,3,null,8,null,4,null,8,null,5,null,5,null,2,null,5,null,7,null,9,null,7,null,3,null,3,null,6,null,1,null,3,null,4,null,5,null,3,null,7,null,7,null,7,null,5,null,6,null,9,null,6,null,3,null,8,null,9,null,5,null,7,null,9,null,4,null,8,null,6,null,7,null,10,null,0,null,4,null,10,null,1,null,8,null,9,null,8,null,8,null,8,null,9,null,1,null,8,null,4,null,6,null,1,null,0,null,7,null,1,null,2,null,5,null,8,null,6,null,6,null,8,null,9,null,8,null,5,null,9,null,8,null,6,null,6,null,1,null,8,null,1,null,2,null,6,null,5,null,5,null,4,null,8,null,9,null,3,null,8,null,9,null,0,null,4,null,0,null,9,null,5,null,7,null,3,null,9,null,2,null,2,null,0,null,8,null,0,null,5,null,3,null,7,null,4,null,1,null,4,null,5,null,3,null,9,null,7,null,10,null,7,null,9,null,5,null,5,null,10,null,6,null,2,null,10,null,4,null,10,null,1,null,7,null,8,null,6,null,1,null,2,null,0,null,7,null,6,null,2,null,1,null,2,null,5,null,10,null,1,null,1,null,2,null,2,null,8,null,8,null,0,null,9,null,9,null,1,null,6,null,1,null,2,null,9,null,2,null,2,null,10,null,2,null,2,null,7,null,10,null,9,null,6,null,8,null,3,null,8,null,3,null,9,null,0,null,2,null,2,null,4,null,8,null,10,null,1,null,3,null,2,null,2,null,5,null,8,null,0,null,6,null,2,null,7,null,2,null,9,null,10,null,7,null,7,null,6,null,9,null,0,null,7,null,9,null,7,null,4,null,9,null,10,null,3,null,5,null,10,null,9,null,5,null,0,null,6,null,7,null,9,null,10,null,4,null,8,null,9,null,3,null,0,null,2,null,6,null,3,null,9,null,4,null,10,null,4,null,7,null,10,null,7,null,9,null,6,null,9,null,1,null,6,null,2,null,8,null,2,null,0,null,7]"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I don\\'t know the language this is written in but it seems to me that you\\'re logic is correct. \\nWhat was the test case that failed? Maybe try examining it and walking through your algorithm step by step to see where it went wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 2000778,
                "content": [
                    {
                        "username": "Kurtz",
                        "content": "From the description, we don\\'t know if a node has no children, will it be ``self.children == []``, or ``self.children == None``. It will be ideal to add a line indicating that ``self.children = []`` if the node has no children."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "DFS using stack, Detailed Explanation\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3866117/dfs-using-stack-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`BFS` iterative approach, Beats 100% Runtime\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865955/bfs-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Explore the tree\\'s `branches` and `sub-branches`, recursively finding the deepest path possible, and returns the maximum number of levels in the tree, giving us its height!!! Simple!\\n\\n`Here is Recursive Implementation` $$O(N)$$, with Detailed Explanation:\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865642/recursive-sollution-o-n-detailed-explanation/"
                    },
                    {
                        "username": "edsaunders92",
                        "content": "Type hint poor in Python3. Optional would be clearer"
                    },
                    {
                        "username": "fantazer",
                        "content": " 22 / 38 testcases passed\\nTime Limit Exceeded\\n\\n`int maxDepth(struct Node* root) {\\n\\n    if (!root) return 0;\\n    int max = 0;\\n    for (int i = 0; i<root->numChildren; i++){\\n        if (maxDepth(root->children[i]) > max) max = maxDepth(root->children[i]);\\n    }\\n    return 1+max;\\n\\n}`\\n\\nIs this code logically correct, but too unefficient? If so, how can I optimize it? "
                    },
                    {
                        "username": "ribhav_32",
                        "content": "for (int i = 0; i<root->children.size(); i++){\n            mx = max(mx,maxDepth(root->children[i]));\n        }\nreturn 1+mx;\n\njust modify your code as shown above \nbecause you are recursively checking same thing many times by using if condition."
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "[@fantazer](/fantazer) It seems like it\\'s the way your code is written. You are recursively checking the max depth of EVERY NODE first and then using the if condition to set the max variable which is AGAIN recursively searching EVERY NODE. \\n\\nIn essence that is very redundant which I think is what\\'s causing your code to exceed the time limit. You can instead try this\\n- Search the node\\'s children\\n- Add the depth of the children to a list\\n- Return the max value of the depths of the children\\n\\nImplement the above recursively and it should work."
                    },
                    {
                        "username": "fantazer",
                        "content": "[@drvnprgrmr](/drvnprgrmr) the failed testcase is long af, so I am assuming that everything is ok, just too slow. (Time Limit Exceeded, 22 / 38 testcases passed)\n\n[4,null,9,null,2,null,0,null,7,null,6,null,4,null,7,null,7,null,7,null,1,null,4,null,0,null,7,null,3,null,1,null,9,null,9,null,3,null,1,null,8,null,5,null,7,null,0,null,5,null,0,null,3,null,9,null,8,null,9,null,7,null,7,null,1,null,5,null,6,null,5,null,6,null,7,null,2,null,1,null,9,null,10,null,9,null,3,null,3,null,1,null,10,null,0,null,10,null,10,null,7,null,9,null,10,null,1,null,7,null,9,null,10,null,10,null,0,null,9,null,8,null,6,null,10,null,3,null,1,null,6,null,0,null,9,null,9,null,2,null,7,null,7,null,5,null,8,null,2,null,6,null,6,null,2,null,3,null,5,null,2,null,2,null,3,null,3,null,9,null,10,null,6,null,1,null,2,null,7,null,4,null,4,null,5,null,3,null,9,null,4,null,0,null,0,null,1,null,3,null,4,null,2,null,0,null,3,null,4,null,8,null,7,null,10,null,4,null,1,null,5,null,6,null,8,null,5,null,8,null,5,null,7,null,6,null,5,null,8,null,10,null,8,null,3,null,4,null,4,null,6,null,8,null,8,null,0,null,9,null,3,null,4,null,4,null,6,null,9,null,2,null,0,null,8,null,3,null,7,null,5,null,10,null,3,null,8,null,4,null,8,null,5,null,5,null,2,null,5,null,7,null,9,null,7,null,3,null,3,null,6,null,1,null,3,null,4,null,5,null,3,null,7,null,7,null,7,null,5,null,6,null,9,null,6,null,3,null,8,null,9,null,5,null,7,null,9,null,4,null,8,null,6,null,7,null,10,null,0,null,4,null,10,null,1,null,8,null,9,null,8,null,8,null,8,null,9,null,1,null,8,null,4,null,6,null,1,null,0,null,7,null,1,null,2,null,5,null,8,null,6,null,6,null,8,null,9,null,8,null,5,null,9,null,8,null,6,null,6,null,1,null,8,null,1,null,2,null,6,null,5,null,5,null,4,null,8,null,9,null,3,null,8,null,9,null,0,null,4,null,0,null,9,null,5,null,7,null,3,null,9,null,2,null,2,null,0,null,8,null,0,null,5,null,3,null,7,null,4,null,1,null,4,null,5,null,3,null,9,null,7,null,10,null,7,null,9,null,5,null,5,null,10,null,6,null,2,null,10,null,4,null,10,null,1,null,7,null,8,null,6,null,1,null,2,null,0,null,7,null,6,null,2,null,1,null,2,null,5,null,10,null,1,null,1,null,2,null,2,null,8,null,8,null,0,null,9,null,9,null,1,null,6,null,1,null,2,null,9,null,2,null,2,null,10,null,2,null,2,null,7,null,10,null,9,null,6,null,8,null,3,null,8,null,3,null,9,null,0,null,2,null,2,null,4,null,8,null,10,null,1,null,3,null,2,null,2,null,5,null,8,null,0,null,6,null,2,null,7,null,2,null,9,null,10,null,7,null,7,null,6,null,9,null,0,null,7,null,9,null,7,null,4,null,9,null,10,null,3,null,5,null,10,null,9,null,5,null,0,null,6,null,7,null,9,null,10,null,4,null,8,null,9,null,3,null,0,null,2,null,6,null,3,null,9,null,4,null,10,null,4,null,7,null,10,null,7,null,9,null,6,null,9,null,1,null,6,null,2,null,8,null,2,null,0,null,7]"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I don\\'t know the language this is written in but it seems to me that you\\'re logic is correct. \\nWhat was the test case that failed? Maybe try examining it and walking through your algorithm step by step to see where it went wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 2000735,
                "content": [
                    {
                        "username": "Kurtz",
                        "content": "From the description, we don\\'t know if a node has no children, will it be ``self.children == []``, or ``self.children == None``. It will be ideal to add a line indicating that ``self.children = []`` if the node has no children."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "DFS using stack, Detailed Explanation\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3866117/dfs-using-stack-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`BFS` iterative approach, Beats 100% Runtime\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865955/bfs-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Explore the tree\\'s `branches` and `sub-branches`, recursively finding the deepest path possible, and returns the maximum number of levels in the tree, giving us its height!!! Simple!\\n\\n`Here is Recursive Implementation` $$O(N)$$, with Detailed Explanation:\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865642/recursive-sollution-o-n-detailed-explanation/"
                    },
                    {
                        "username": "edsaunders92",
                        "content": "Type hint poor in Python3. Optional would be clearer"
                    },
                    {
                        "username": "fantazer",
                        "content": " 22 / 38 testcases passed\\nTime Limit Exceeded\\n\\n`int maxDepth(struct Node* root) {\\n\\n    if (!root) return 0;\\n    int max = 0;\\n    for (int i = 0; i<root->numChildren; i++){\\n        if (maxDepth(root->children[i]) > max) max = maxDepth(root->children[i]);\\n    }\\n    return 1+max;\\n\\n}`\\n\\nIs this code logically correct, but too unefficient? If so, how can I optimize it? "
                    },
                    {
                        "username": "ribhav_32",
                        "content": "for (int i = 0; i<root->children.size(); i++){\n            mx = max(mx,maxDepth(root->children[i]));\n        }\nreturn 1+mx;\n\njust modify your code as shown above \nbecause you are recursively checking same thing many times by using if condition."
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "[@fantazer](/fantazer) It seems like it\\'s the way your code is written. You are recursively checking the max depth of EVERY NODE first and then using the if condition to set the max variable which is AGAIN recursively searching EVERY NODE. \\n\\nIn essence that is very redundant which I think is what\\'s causing your code to exceed the time limit. You can instead try this\\n- Search the node\\'s children\\n- Add the depth of the children to a list\\n- Return the max value of the depths of the children\\n\\nImplement the above recursively and it should work."
                    },
                    {
                        "username": "fantazer",
                        "content": "[@drvnprgrmr](/drvnprgrmr) the failed testcase is long af, so I am assuming that everything is ok, just too slow. (Time Limit Exceeded, 22 / 38 testcases passed)\n\n[4,null,9,null,2,null,0,null,7,null,6,null,4,null,7,null,7,null,7,null,1,null,4,null,0,null,7,null,3,null,1,null,9,null,9,null,3,null,1,null,8,null,5,null,7,null,0,null,5,null,0,null,3,null,9,null,8,null,9,null,7,null,7,null,1,null,5,null,6,null,5,null,6,null,7,null,2,null,1,null,9,null,10,null,9,null,3,null,3,null,1,null,10,null,0,null,10,null,10,null,7,null,9,null,10,null,1,null,7,null,9,null,10,null,10,null,0,null,9,null,8,null,6,null,10,null,3,null,1,null,6,null,0,null,9,null,9,null,2,null,7,null,7,null,5,null,8,null,2,null,6,null,6,null,2,null,3,null,5,null,2,null,2,null,3,null,3,null,9,null,10,null,6,null,1,null,2,null,7,null,4,null,4,null,5,null,3,null,9,null,4,null,0,null,0,null,1,null,3,null,4,null,2,null,0,null,3,null,4,null,8,null,7,null,10,null,4,null,1,null,5,null,6,null,8,null,5,null,8,null,5,null,7,null,6,null,5,null,8,null,10,null,8,null,3,null,4,null,4,null,6,null,8,null,8,null,0,null,9,null,3,null,4,null,4,null,6,null,9,null,2,null,0,null,8,null,3,null,7,null,5,null,10,null,3,null,8,null,4,null,8,null,5,null,5,null,2,null,5,null,7,null,9,null,7,null,3,null,3,null,6,null,1,null,3,null,4,null,5,null,3,null,7,null,7,null,7,null,5,null,6,null,9,null,6,null,3,null,8,null,9,null,5,null,7,null,9,null,4,null,8,null,6,null,7,null,10,null,0,null,4,null,10,null,1,null,8,null,9,null,8,null,8,null,8,null,9,null,1,null,8,null,4,null,6,null,1,null,0,null,7,null,1,null,2,null,5,null,8,null,6,null,6,null,8,null,9,null,8,null,5,null,9,null,8,null,6,null,6,null,1,null,8,null,1,null,2,null,6,null,5,null,5,null,4,null,8,null,9,null,3,null,8,null,9,null,0,null,4,null,0,null,9,null,5,null,7,null,3,null,9,null,2,null,2,null,0,null,8,null,0,null,5,null,3,null,7,null,4,null,1,null,4,null,5,null,3,null,9,null,7,null,10,null,7,null,9,null,5,null,5,null,10,null,6,null,2,null,10,null,4,null,10,null,1,null,7,null,8,null,6,null,1,null,2,null,0,null,7,null,6,null,2,null,1,null,2,null,5,null,10,null,1,null,1,null,2,null,2,null,8,null,8,null,0,null,9,null,9,null,1,null,6,null,1,null,2,null,9,null,2,null,2,null,10,null,2,null,2,null,7,null,10,null,9,null,6,null,8,null,3,null,8,null,3,null,9,null,0,null,2,null,2,null,4,null,8,null,10,null,1,null,3,null,2,null,2,null,5,null,8,null,0,null,6,null,2,null,7,null,2,null,9,null,10,null,7,null,7,null,6,null,9,null,0,null,7,null,9,null,7,null,4,null,9,null,10,null,3,null,5,null,10,null,9,null,5,null,0,null,6,null,7,null,9,null,10,null,4,null,8,null,9,null,3,null,0,null,2,null,6,null,3,null,9,null,4,null,10,null,4,null,7,null,10,null,7,null,9,null,6,null,9,null,1,null,6,null,2,null,8,null,2,null,0,null,7]"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I don\\'t know the language this is written in but it seems to me that you\\'re logic is correct. \\nWhat was the test case that failed? Maybe try examining it and walking through your algorithm step by step to see where it went wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 2000651,
                "content": [
                    {
                        "username": "Kurtz",
                        "content": "From the description, we don\\'t know if a node has no children, will it be ``self.children == []``, or ``self.children == None``. It will be ideal to add a line indicating that ``self.children = []`` if the node has no children."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "DFS using stack, Detailed Explanation\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3866117/dfs-using-stack-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`BFS` iterative approach, Beats 100% Runtime\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865955/bfs-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Explore the tree\\'s `branches` and `sub-branches`, recursively finding the deepest path possible, and returns the maximum number of levels in the tree, giving us its height!!! Simple!\\n\\n`Here is Recursive Implementation` $$O(N)$$, with Detailed Explanation:\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865642/recursive-sollution-o-n-detailed-explanation/"
                    },
                    {
                        "username": "edsaunders92",
                        "content": "Type hint poor in Python3. Optional would be clearer"
                    },
                    {
                        "username": "fantazer",
                        "content": " 22 / 38 testcases passed\\nTime Limit Exceeded\\n\\n`int maxDepth(struct Node* root) {\\n\\n    if (!root) return 0;\\n    int max = 0;\\n    for (int i = 0; i<root->numChildren; i++){\\n        if (maxDepth(root->children[i]) > max) max = maxDepth(root->children[i]);\\n    }\\n    return 1+max;\\n\\n}`\\n\\nIs this code logically correct, but too unefficient? If so, how can I optimize it? "
                    },
                    {
                        "username": "ribhav_32",
                        "content": "for (int i = 0; i<root->children.size(); i++){\n            mx = max(mx,maxDepth(root->children[i]));\n        }\nreturn 1+mx;\n\njust modify your code as shown above \nbecause you are recursively checking same thing many times by using if condition."
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "[@fantazer](/fantazer) It seems like it\\'s the way your code is written. You are recursively checking the max depth of EVERY NODE first and then using the if condition to set the max variable which is AGAIN recursively searching EVERY NODE. \\n\\nIn essence that is very redundant which I think is what\\'s causing your code to exceed the time limit. You can instead try this\\n- Search the node\\'s children\\n- Add the depth of the children to a list\\n- Return the max value of the depths of the children\\n\\nImplement the above recursively and it should work."
                    },
                    {
                        "username": "fantazer",
                        "content": "[@drvnprgrmr](/drvnprgrmr) the failed testcase is long af, so I am assuming that everything is ok, just too slow. (Time Limit Exceeded, 22 / 38 testcases passed)\n\n[4,null,9,null,2,null,0,null,7,null,6,null,4,null,7,null,7,null,7,null,1,null,4,null,0,null,7,null,3,null,1,null,9,null,9,null,3,null,1,null,8,null,5,null,7,null,0,null,5,null,0,null,3,null,9,null,8,null,9,null,7,null,7,null,1,null,5,null,6,null,5,null,6,null,7,null,2,null,1,null,9,null,10,null,9,null,3,null,3,null,1,null,10,null,0,null,10,null,10,null,7,null,9,null,10,null,1,null,7,null,9,null,10,null,10,null,0,null,9,null,8,null,6,null,10,null,3,null,1,null,6,null,0,null,9,null,9,null,2,null,7,null,7,null,5,null,8,null,2,null,6,null,6,null,2,null,3,null,5,null,2,null,2,null,3,null,3,null,9,null,10,null,6,null,1,null,2,null,7,null,4,null,4,null,5,null,3,null,9,null,4,null,0,null,0,null,1,null,3,null,4,null,2,null,0,null,3,null,4,null,8,null,7,null,10,null,4,null,1,null,5,null,6,null,8,null,5,null,8,null,5,null,7,null,6,null,5,null,8,null,10,null,8,null,3,null,4,null,4,null,6,null,8,null,8,null,0,null,9,null,3,null,4,null,4,null,6,null,9,null,2,null,0,null,8,null,3,null,7,null,5,null,10,null,3,null,8,null,4,null,8,null,5,null,5,null,2,null,5,null,7,null,9,null,7,null,3,null,3,null,6,null,1,null,3,null,4,null,5,null,3,null,7,null,7,null,7,null,5,null,6,null,9,null,6,null,3,null,8,null,9,null,5,null,7,null,9,null,4,null,8,null,6,null,7,null,10,null,0,null,4,null,10,null,1,null,8,null,9,null,8,null,8,null,8,null,9,null,1,null,8,null,4,null,6,null,1,null,0,null,7,null,1,null,2,null,5,null,8,null,6,null,6,null,8,null,9,null,8,null,5,null,9,null,8,null,6,null,6,null,1,null,8,null,1,null,2,null,6,null,5,null,5,null,4,null,8,null,9,null,3,null,8,null,9,null,0,null,4,null,0,null,9,null,5,null,7,null,3,null,9,null,2,null,2,null,0,null,8,null,0,null,5,null,3,null,7,null,4,null,1,null,4,null,5,null,3,null,9,null,7,null,10,null,7,null,9,null,5,null,5,null,10,null,6,null,2,null,10,null,4,null,10,null,1,null,7,null,8,null,6,null,1,null,2,null,0,null,7,null,6,null,2,null,1,null,2,null,5,null,10,null,1,null,1,null,2,null,2,null,8,null,8,null,0,null,9,null,9,null,1,null,6,null,1,null,2,null,9,null,2,null,2,null,10,null,2,null,2,null,7,null,10,null,9,null,6,null,8,null,3,null,8,null,3,null,9,null,0,null,2,null,2,null,4,null,8,null,10,null,1,null,3,null,2,null,2,null,5,null,8,null,0,null,6,null,2,null,7,null,2,null,9,null,10,null,7,null,7,null,6,null,9,null,0,null,7,null,9,null,7,null,4,null,9,null,10,null,3,null,5,null,10,null,9,null,5,null,0,null,6,null,7,null,9,null,10,null,4,null,8,null,9,null,3,null,0,null,2,null,6,null,3,null,9,null,4,null,10,null,4,null,7,null,10,null,7,null,9,null,6,null,9,null,1,null,6,null,2,null,8,null,2,null,0,null,7]"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I don\\'t know the language this is written in but it seems to me that you\\'re logic is correct. \\nWhat was the test case that failed? Maybe try examining it and walking through your algorithm step by step to see where it went wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1960095,
                "content": [
                    {
                        "username": "Kurtz",
                        "content": "From the description, we don\\'t know if a node has no children, will it be ``self.children == []``, or ``self.children == None``. It will be ideal to add a line indicating that ``self.children = []`` if the node has no children."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "DFS using stack, Detailed Explanation\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3866117/dfs-using-stack-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`BFS` iterative approach, Beats 100% Runtime\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865955/bfs-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Explore the tree\\'s `branches` and `sub-branches`, recursively finding the deepest path possible, and returns the maximum number of levels in the tree, giving us its height!!! Simple!\\n\\n`Here is Recursive Implementation` $$O(N)$$, with Detailed Explanation:\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865642/recursive-sollution-o-n-detailed-explanation/"
                    },
                    {
                        "username": "edsaunders92",
                        "content": "Type hint poor in Python3. Optional would be clearer"
                    },
                    {
                        "username": "fantazer",
                        "content": " 22 / 38 testcases passed\\nTime Limit Exceeded\\n\\n`int maxDepth(struct Node* root) {\\n\\n    if (!root) return 0;\\n    int max = 0;\\n    for (int i = 0; i<root->numChildren; i++){\\n        if (maxDepth(root->children[i]) > max) max = maxDepth(root->children[i]);\\n    }\\n    return 1+max;\\n\\n}`\\n\\nIs this code logically correct, but too unefficient? If so, how can I optimize it? "
                    },
                    {
                        "username": "ribhav_32",
                        "content": "for (int i = 0; i<root->children.size(); i++){\n            mx = max(mx,maxDepth(root->children[i]));\n        }\nreturn 1+mx;\n\njust modify your code as shown above \nbecause you are recursively checking same thing many times by using if condition."
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "[@fantazer](/fantazer) It seems like it\\'s the way your code is written. You are recursively checking the max depth of EVERY NODE first and then using the if condition to set the max variable which is AGAIN recursively searching EVERY NODE. \\n\\nIn essence that is very redundant which I think is what\\'s causing your code to exceed the time limit. You can instead try this\\n- Search the node\\'s children\\n- Add the depth of the children to a list\\n- Return the max value of the depths of the children\\n\\nImplement the above recursively and it should work."
                    },
                    {
                        "username": "fantazer",
                        "content": "[@drvnprgrmr](/drvnprgrmr) the failed testcase is long af, so I am assuming that everything is ok, just too slow. (Time Limit Exceeded, 22 / 38 testcases passed)\n\n[4,null,9,null,2,null,0,null,7,null,6,null,4,null,7,null,7,null,7,null,1,null,4,null,0,null,7,null,3,null,1,null,9,null,9,null,3,null,1,null,8,null,5,null,7,null,0,null,5,null,0,null,3,null,9,null,8,null,9,null,7,null,7,null,1,null,5,null,6,null,5,null,6,null,7,null,2,null,1,null,9,null,10,null,9,null,3,null,3,null,1,null,10,null,0,null,10,null,10,null,7,null,9,null,10,null,1,null,7,null,9,null,10,null,10,null,0,null,9,null,8,null,6,null,10,null,3,null,1,null,6,null,0,null,9,null,9,null,2,null,7,null,7,null,5,null,8,null,2,null,6,null,6,null,2,null,3,null,5,null,2,null,2,null,3,null,3,null,9,null,10,null,6,null,1,null,2,null,7,null,4,null,4,null,5,null,3,null,9,null,4,null,0,null,0,null,1,null,3,null,4,null,2,null,0,null,3,null,4,null,8,null,7,null,10,null,4,null,1,null,5,null,6,null,8,null,5,null,8,null,5,null,7,null,6,null,5,null,8,null,10,null,8,null,3,null,4,null,4,null,6,null,8,null,8,null,0,null,9,null,3,null,4,null,4,null,6,null,9,null,2,null,0,null,8,null,3,null,7,null,5,null,10,null,3,null,8,null,4,null,8,null,5,null,5,null,2,null,5,null,7,null,9,null,7,null,3,null,3,null,6,null,1,null,3,null,4,null,5,null,3,null,7,null,7,null,7,null,5,null,6,null,9,null,6,null,3,null,8,null,9,null,5,null,7,null,9,null,4,null,8,null,6,null,7,null,10,null,0,null,4,null,10,null,1,null,8,null,9,null,8,null,8,null,8,null,9,null,1,null,8,null,4,null,6,null,1,null,0,null,7,null,1,null,2,null,5,null,8,null,6,null,6,null,8,null,9,null,8,null,5,null,9,null,8,null,6,null,6,null,1,null,8,null,1,null,2,null,6,null,5,null,5,null,4,null,8,null,9,null,3,null,8,null,9,null,0,null,4,null,0,null,9,null,5,null,7,null,3,null,9,null,2,null,2,null,0,null,8,null,0,null,5,null,3,null,7,null,4,null,1,null,4,null,5,null,3,null,9,null,7,null,10,null,7,null,9,null,5,null,5,null,10,null,6,null,2,null,10,null,4,null,10,null,1,null,7,null,8,null,6,null,1,null,2,null,0,null,7,null,6,null,2,null,1,null,2,null,5,null,10,null,1,null,1,null,2,null,2,null,8,null,8,null,0,null,9,null,9,null,1,null,6,null,1,null,2,null,9,null,2,null,2,null,10,null,2,null,2,null,7,null,10,null,9,null,6,null,8,null,3,null,8,null,3,null,9,null,0,null,2,null,2,null,4,null,8,null,10,null,1,null,3,null,2,null,2,null,5,null,8,null,0,null,6,null,2,null,7,null,2,null,9,null,10,null,7,null,7,null,6,null,9,null,0,null,7,null,9,null,7,null,4,null,9,null,10,null,3,null,5,null,10,null,9,null,5,null,0,null,6,null,7,null,9,null,10,null,4,null,8,null,9,null,3,null,0,null,2,null,6,null,3,null,9,null,4,null,10,null,4,null,7,null,10,null,7,null,9,null,6,null,9,null,1,null,6,null,2,null,8,null,2,null,0,null,7]"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I don\\'t know the language this is written in but it seems to me that you\\'re logic is correct. \\nWhat was the test case that failed? Maybe try examining it and walking through your algorithm step by step to see where it went wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1739636,
                "content": [
                    {
                        "username": "Kurtz",
                        "content": "From the description, we don\\'t know if a node has no children, will it be ``self.children == []``, or ``self.children == None``. It will be ideal to add a line indicating that ``self.children = []`` if the node has no children."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "DFS using stack, Detailed Explanation\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3866117/dfs-using-stack-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`BFS` iterative approach, Beats 100% Runtime\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865955/bfs-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Explore the tree\\'s `branches` and `sub-branches`, recursively finding the deepest path possible, and returns the maximum number of levels in the tree, giving us its height!!! Simple!\\n\\n`Here is Recursive Implementation` $$O(N)$$, with Detailed Explanation:\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865642/recursive-sollution-o-n-detailed-explanation/"
                    },
                    {
                        "username": "edsaunders92",
                        "content": "Type hint poor in Python3. Optional would be clearer"
                    },
                    {
                        "username": "fantazer",
                        "content": " 22 / 38 testcases passed\\nTime Limit Exceeded\\n\\n`int maxDepth(struct Node* root) {\\n\\n    if (!root) return 0;\\n    int max = 0;\\n    for (int i = 0; i<root->numChildren; i++){\\n        if (maxDepth(root->children[i]) > max) max = maxDepth(root->children[i]);\\n    }\\n    return 1+max;\\n\\n}`\\n\\nIs this code logically correct, but too unefficient? If so, how can I optimize it? "
                    },
                    {
                        "username": "ribhav_32",
                        "content": "for (int i = 0; i<root->children.size(); i++){\n            mx = max(mx,maxDepth(root->children[i]));\n        }\nreturn 1+mx;\n\njust modify your code as shown above \nbecause you are recursively checking same thing many times by using if condition."
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "[@fantazer](/fantazer) It seems like it\\'s the way your code is written. You are recursively checking the max depth of EVERY NODE first and then using the if condition to set the max variable which is AGAIN recursively searching EVERY NODE. \\n\\nIn essence that is very redundant which I think is what\\'s causing your code to exceed the time limit. You can instead try this\\n- Search the node\\'s children\\n- Add the depth of the children to a list\\n- Return the max value of the depths of the children\\n\\nImplement the above recursively and it should work."
                    },
                    {
                        "username": "fantazer",
                        "content": "[@drvnprgrmr](/drvnprgrmr) the failed testcase is long af, so I am assuming that everything is ok, just too slow. (Time Limit Exceeded, 22 / 38 testcases passed)\n\n[4,null,9,null,2,null,0,null,7,null,6,null,4,null,7,null,7,null,7,null,1,null,4,null,0,null,7,null,3,null,1,null,9,null,9,null,3,null,1,null,8,null,5,null,7,null,0,null,5,null,0,null,3,null,9,null,8,null,9,null,7,null,7,null,1,null,5,null,6,null,5,null,6,null,7,null,2,null,1,null,9,null,10,null,9,null,3,null,3,null,1,null,10,null,0,null,10,null,10,null,7,null,9,null,10,null,1,null,7,null,9,null,10,null,10,null,0,null,9,null,8,null,6,null,10,null,3,null,1,null,6,null,0,null,9,null,9,null,2,null,7,null,7,null,5,null,8,null,2,null,6,null,6,null,2,null,3,null,5,null,2,null,2,null,3,null,3,null,9,null,10,null,6,null,1,null,2,null,7,null,4,null,4,null,5,null,3,null,9,null,4,null,0,null,0,null,1,null,3,null,4,null,2,null,0,null,3,null,4,null,8,null,7,null,10,null,4,null,1,null,5,null,6,null,8,null,5,null,8,null,5,null,7,null,6,null,5,null,8,null,10,null,8,null,3,null,4,null,4,null,6,null,8,null,8,null,0,null,9,null,3,null,4,null,4,null,6,null,9,null,2,null,0,null,8,null,3,null,7,null,5,null,10,null,3,null,8,null,4,null,8,null,5,null,5,null,2,null,5,null,7,null,9,null,7,null,3,null,3,null,6,null,1,null,3,null,4,null,5,null,3,null,7,null,7,null,7,null,5,null,6,null,9,null,6,null,3,null,8,null,9,null,5,null,7,null,9,null,4,null,8,null,6,null,7,null,10,null,0,null,4,null,10,null,1,null,8,null,9,null,8,null,8,null,8,null,9,null,1,null,8,null,4,null,6,null,1,null,0,null,7,null,1,null,2,null,5,null,8,null,6,null,6,null,8,null,9,null,8,null,5,null,9,null,8,null,6,null,6,null,1,null,8,null,1,null,2,null,6,null,5,null,5,null,4,null,8,null,9,null,3,null,8,null,9,null,0,null,4,null,0,null,9,null,5,null,7,null,3,null,9,null,2,null,2,null,0,null,8,null,0,null,5,null,3,null,7,null,4,null,1,null,4,null,5,null,3,null,9,null,7,null,10,null,7,null,9,null,5,null,5,null,10,null,6,null,2,null,10,null,4,null,10,null,1,null,7,null,8,null,6,null,1,null,2,null,0,null,7,null,6,null,2,null,1,null,2,null,5,null,10,null,1,null,1,null,2,null,2,null,8,null,8,null,0,null,9,null,9,null,1,null,6,null,1,null,2,null,9,null,2,null,2,null,10,null,2,null,2,null,7,null,10,null,9,null,6,null,8,null,3,null,8,null,3,null,9,null,0,null,2,null,2,null,4,null,8,null,10,null,1,null,3,null,2,null,2,null,5,null,8,null,0,null,6,null,2,null,7,null,2,null,9,null,10,null,7,null,7,null,6,null,9,null,0,null,7,null,9,null,7,null,4,null,9,null,10,null,3,null,5,null,10,null,9,null,5,null,0,null,6,null,7,null,9,null,10,null,4,null,8,null,9,null,3,null,0,null,2,null,6,null,3,null,9,null,4,null,10,null,4,null,7,null,10,null,7,null,9,null,6,null,9,null,1,null,6,null,2,null,8,null,2,null,0,null,7]"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I don\\'t know the language this is written in but it seems to me that you\\'re logic is correct. \\nWhat was the test case that failed? Maybe try examining it and walking through your algorithm step by step to see where it went wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1728235,
                "content": [
                    {
                        "username": "Kurtz",
                        "content": "From the description, we don\\'t know if a node has no children, will it be ``self.children == []``, or ``self.children == None``. It will be ideal to add a line indicating that ``self.children = []`` if the node has no children."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "DFS using stack, Detailed Explanation\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3866117/dfs-using-stack-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`BFS` iterative approach, Beats 100% Runtime\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865955/bfs-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Explore the tree\\'s `branches` and `sub-branches`, recursively finding the deepest path possible, and returns the maximum number of levels in the tree, giving us its height!!! Simple!\\n\\n`Here is Recursive Implementation` $$O(N)$$, with Detailed Explanation:\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865642/recursive-sollution-o-n-detailed-explanation/"
                    },
                    {
                        "username": "edsaunders92",
                        "content": "Type hint poor in Python3. Optional would be clearer"
                    },
                    {
                        "username": "fantazer",
                        "content": " 22 / 38 testcases passed\\nTime Limit Exceeded\\n\\n`int maxDepth(struct Node* root) {\\n\\n    if (!root) return 0;\\n    int max = 0;\\n    for (int i = 0; i<root->numChildren; i++){\\n        if (maxDepth(root->children[i]) > max) max = maxDepth(root->children[i]);\\n    }\\n    return 1+max;\\n\\n}`\\n\\nIs this code logically correct, but too unefficient? If so, how can I optimize it? "
                    },
                    {
                        "username": "ribhav_32",
                        "content": "for (int i = 0; i<root->children.size(); i++){\n            mx = max(mx,maxDepth(root->children[i]));\n        }\nreturn 1+mx;\n\njust modify your code as shown above \nbecause you are recursively checking same thing many times by using if condition."
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "[@fantazer](/fantazer) It seems like it\\'s the way your code is written. You are recursively checking the max depth of EVERY NODE first and then using the if condition to set the max variable which is AGAIN recursively searching EVERY NODE. \\n\\nIn essence that is very redundant which I think is what\\'s causing your code to exceed the time limit. You can instead try this\\n- Search the node\\'s children\\n- Add the depth of the children to a list\\n- Return the max value of the depths of the children\\n\\nImplement the above recursively and it should work."
                    },
                    {
                        "username": "fantazer",
                        "content": "[@drvnprgrmr](/drvnprgrmr) the failed testcase is long af, so I am assuming that everything is ok, just too slow. (Time Limit Exceeded, 22 / 38 testcases passed)\n\n[4,null,9,null,2,null,0,null,7,null,6,null,4,null,7,null,7,null,7,null,1,null,4,null,0,null,7,null,3,null,1,null,9,null,9,null,3,null,1,null,8,null,5,null,7,null,0,null,5,null,0,null,3,null,9,null,8,null,9,null,7,null,7,null,1,null,5,null,6,null,5,null,6,null,7,null,2,null,1,null,9,null,10,null,9,null,3,null,3,null,1,null,10,null,0,null,10,null,10,null,7,null,9,null,10,null,1,null,7,null,9,null,10,null,10,null,0,null,9,null,8,null,6,null,10,null,3,null,1,null,6,null,0,null,9,null,9,null,2,null,7,null,7,null,5,null,8,null,2,null,6,null,6,null,2,null,3,null,5,null,2,null,2,null,3,null,3,null,9,null,10,null,6,null,1,null,2,null,7,null,4,null,4,null,5,null,3,null,9,null,4,null,0,null,0,null,1,null,3,null,4,null,2,null,0,null,3,null,4,null,8,null,7,null,10,null,4,null,1,null,5,null,6,null,8,null,5,null,8,null,5,null,7,null,6,null,5,null,8,null,10,null,8,null,3,null,4,null,4,null,6,null,8,null,8,null,0,null,9,null,3,null,4,null,4,null,6,null,9,null,2,null,0,null,8,null,3,null,7,null,5,null,10,null,3,null,8,null,4,null,8,null,5,null,5,null,2,null,5,null,7,null,9,null,7,null,3,null,3,null,6,null,1,null,3,null,4,null,5,null,3,null,7,null,7,null,7,null,5,null,6,null,9,null,6,null,3,null,8,null,9,null,5,null,7,null,9,null,4,null,8,null,6,null,7,null,10,null,0,null,4,null,10,null,1,null,8,null,9,null,8,null,8,null,8,null,9,null,1,null,8,null,4,null,6,null,1,null,0,null,7,null,1,null,2,null,5,null,8,null,6,null,6,null,8,null,9,null,8,null,5,null,9,null,8,null,6,null,6,null,1,null,8,null,1,null,2,null,6,null,5,null,5,null,4,null,8,null,9,null,3,null,8,null,9,null,0,null,4,null,0,null,9,null,5,null,7,null,3,null,9,null,2,null,2,null,0,null,8,null,0,null,5,null,3,null,7,null,4,null,1,null,4,null,5,null,3,null,9,null,7,null,10,null,7,null,9,null,5,null,5,null,10,null,6,null,2,null,10,null,4,null,10,null,1,null,7,null,8,null,6,null,1,null,2,null,0,null,7,null,6,null,2,null,1,null,2,null,5,null,10,null,1,null,1,null,2,null,2,null,8,null,8,null,0,null,9,null,9,null,1,null,6,null,1,null,2,null,9,null,2,null,2,null,10,null,2,null,2,null,7,null,10,null,9,null,6,null,8,null,3,null,8,null,3,null,9,null,0,null,2,null,2,null,4,null,8,null,10,null,1,null,3,null,2,null,2,null,5,null,8,null,0,null,6,null,2,null,7,null,2,null,9,null,10,null,7,null,7,null,6,null,9,null,0,null,7,null,9,null,7,null,4,null,9,null,10,null,3,null,5,null,10,null,9,null,5,null,0,null,6,null,7,null,9,null,10,null,4,null,8,null,9,null,3,null,0,null,2,null,6,null,3,null,9,null,4,null,10,null,4,null,7,null,10,null,7,null,9,null,6,null,9,null,1,null,6,null,2,null,8,null,2,null,0,null,7]"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I don\\'t know the language this is written in but it seems to me that you\\'re logic is correct. \\nWhat was the test case that failed? Maybe try examining it and walking through your algorithm step by step to see where it went wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            }
        ]
    },
    {
        "title": "Remove 9",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565350,
                "content": [
                    {
                        "username": "roc571",
                        "content": "is there any one rememeber there is a leetcode question about how to calculate how many number which contains like number #7?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Anagram Mappings",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1858784,
                "content": [
                    {
                        "username": "RohitSgh",
                        "content": "**Permutation** is perhaps a better term instead of **Anagram**"
                    }
                ]
            }
        ]
    },
    {
        "title": "Transpose Matrix",
        "question_content": "<p>Given a 2D integer array <code>matrix</code>, return <em>the <strong>transpose</strong> of</em> <code>matrix</code>.</p>\n\n<p>The <strong>transpose</strong> of a matrix is the matrix flipped over its main diagonal, switching the matrix&#39;s row and column indices.</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/10/hint_transpose.png\" style=\"width: 600px; height: 197px;\" /></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>Output:</strong> [[1,4,7],[2,5,8],[3,6,9]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3],[4,5,6]]\n<strong>Output:</strong> [[1,4],[2,5],[3,6]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= matrix[i][j] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 146797,
                "title": "c-java-python-easy-understood",
                "content": "**C++:**\\n```cpp\\n    vector<vector<int>> transpose(vector<vector<int>> A) {\\n        int M = A.size(), N = A[0].size();\\n        vector<vector<int>> B(N, vector<int>(M, 0));\\n        for (int j = 0; j < N; j++)\\n            for (int i = 0; i < M; i++)\\n                B[j][i] = A[i][j];\\n        return B;\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int[][] transpose(int[][] A) {\\n        int M = A.length, N = A[0].length;\\n        int[][] B = new int[N][M];\\n        for (int j = 0; j < N; j++)\\n            for (int i = 0; i < M; i++)\\n                B[j][i] = A[i][j];\\n        return B;\\n    }\\n```\\n**Python:**\\n```py\\n    def tranpose(self, M):\\n        return zip(*M)\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    vector<vector<int>> transpose(vector<vector<int>> A) {\\n        int M = A.size(), N = A[0].size();\\n        vector<vector<int>> B(N, vector<int>(M, 0));\\n        for (int j = 0; j < N; j++)\\n            for (int i = 0; i < M; i++)\\n                B[j][i] = A[i][j];\\n        return B;\\n    }\\n```\n```java\\n    public int[][] transpose(int[][] A) {\\n        int M = A.length, N = A[0].length;\\n        int[][] B = new int[N][M];\\n        for (int j = 0; j < N; j++)\\n            for (int i = 0; i < M; i++)\\n                B[j][i] = A[i][j];\\n        return B;\\n    }\\n```\n```py\\n    def tranpose(self, M):\\n        return zip(*M)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 146767,
                "title": "python-1-liner",
                "content": "```\\nclass Solution(object):\\n    def transpose(self, A):\\n        return zip(*A)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def transpose(self, A):\\n        return zip(*A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100127,
                "title": "interview-follow-up-square-matrix",
                "content": "### A Potential Follow-Up Question:\\n> If you were given a `n*n` square matrix, transpose the matrix **in-place**.\\n\\nBefore we answer the follow-up, let\\'s just make sure we\\'re on the same page regarding the original question. The basic idea of transposing a matrix is swapping the rows with the columns. This allows for a reasonably straight-forward implementation. Assuming the original matrix is of size `n*m`, create a new matrix of size `m*n` and assign `outputMatrix[i][j] = matrix[j][i]`. That\\'ll give you your transpose! \\n\\nAs you might have noticed, we are forced to use up space and create an output matrix especially since `n` and `m` aren\\'t necessarily the same. However, what if the matrix was strictly square? \\n___\\n\\n### Logic:\\nIf the matrix was strictly square, then we don\\'t need to waste space creating an output matrix. In fact, we can just use our intput matrix! \\n\\nThe tricky bit here is that we can\\'t just do `matrix[i][j] = matrix[j][i]`. This will result in duplicate matrix cells since we lose `matrix[i][j]` in the process:\\n![image](https://assets.leetcode.com/users/images/7c908b9b-ccc3-4f59-bac5-0dab254bcf1d_1654129769.086754.jpeg)\\n\\nTo avoid this, we\\'ll have to swap these values using a temporary variable:\\n* Store `matrix[i][j]` in `temp`\\n* Set `matrix[i][j] = matrix[j][i]`\\n* Set `matrix[j][i] = temp`\\n\\nAnother thing to be careful of is our nested for-loop. If we simply do `for (int j=0; j<n; j++)`, we end up swapping row and column values _twice_, giving us our original matrix:\\n![image](https://assets.leetcode.com/users/images/6bc8a33a-e7a6-4a7e-8663-2fea1043e081_1654130111.7997172.jpeg)\\n\\nTo avoid this, we want to make sure we\\'re only swapping `i` and `j` once. Therefore, start our nested for-loop at `j = i+1` (the \"+1\" is there since we can skip the diagonals as well).    \\n\\nAnd that\\'s it! Now we\\'re ready to start coding.\\n___\\n### Code:\\nI hope you found this helpful. If you have any questions, suggestions or improvements, feel free to let me know!\\n**Original Question:**\\n> Time complexity: `O(n*m)`\\n> Space complexity: `O(n*m)` for the output matrix.\\n```java\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int n = matrix.length, m = matrix[0].length;\\n        int[][] transposedMatrix = new int[m][n];\\n        \\n        for (int i=0; i<m; i++)\\n            for (int j=0; j<n; j++)\\n                transposedMatrix[i][j] = matrix[j][i];\\n        \\n        return transposedMatrix;\\n    }\\n}\\n```\\n\\n**Follow-up for square matrices:**\\n> Time complexity: `O(n*m)`\\n> Space complexity: `O(1)`\\n```java\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int n = matrix.length;\\n        \\n        for (int i=0; i<n; i++) {\\n            for (int j=i+1; j<n; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        \\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int n = matrix.length, m = matrix[0].length;\\n        int[][] transposedMatrix = new int[m][n];\\n        \\n        for (int i=0; i<m; i++)\\n            for (int j=0; j<n; j++)\\n                transposedMatrix[i][j] = matrix[j][i];\\n        \\n        return transposedMatrix;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int n = matrix.length;\\n        \\n        for (int i=0; i<n; i++) {\\n            for (int j=i+1; j<n; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        \\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100113,
                "title": "c-easiest-w-matrix-creation-filling",
                "content": "**Please upvote the post if you like it  :)**\\n\\nSo, basically we are given an 2D **matrix** of` m*n` and we need to return the **transpose** of this \\n**matrix**\\n\\n***Basic Brute/ Intuitive Approach (C++) :***\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        vector<vector<int>> res(m,vector<int> (n,0)); // matrix creation\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                res[j][i] = matrix[i][j]; // filling the matrix in transpose form\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n****\\n**Time Complexity : O(n*m)**, where `n` is the **row** and `m` is the **column**\\n**Space Complexity : O(n*m)**",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        vector<vector<int>> res(m,vector<int> (n,0)); // matrix creation\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                res[j][i] = matrix[i][j]; // filling the matrix in transpose form\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146790,
                "title": "python-self-explanatory-1-line-solution",
                "content": "```\\nclass Solution:\\n    def transpose(self, A):\\n        return [[A[i][j] for i in range(len(A))] for j in range(len(A[0]))]\\n```\\n**Bonus:**\\n```\\nclass Solution:\\n    def transpose(self, A):\\n        R = len(A)\\n        C = len(A[0])\\n        transpose = []\\n        for c in range(C):\\n            newRow = []\\n            for r in range(R):\\n                newRow.append(A[r][c])\\n            transpose.append(newRow)\\n        return transpose\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def transpose(self, A):\\n        return [[A[i][j] for i in range(len(A))] for j in range(len(A[0]))]\\n```\n```\\nclass Solution:\\n    def transpose(self, A):\\n        R = len(A)\\n        C = len(A[0])\\n        transpose = []\\n        for c in range(C):\\n            newRow = []\\n            for r in range(R):\\n                newRow.append(A[r][c])\\n            transpose.append(newRow)\\n        return transpose\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176903,
                "title": "java-solution-with-additional-checks-to-use-in-place-wherever-we-can",
                "content": "```\\npublic int[][] transpose(int[][] A) {\\n\\t\\tif (A.length == A[0].length) {\\n\\t\\t\\t\\tinPlace(A);\\n\\t\\t\\t\\treturn A;\\n\\t\\t}        \\n\\t\\tint[][] B = new int[A[0].length][A.length];\\n\\t\\tfor (int i=0; i<A.length ; i++) {\\n\\t\\t\\t\\tfor (int j=0; j<A[0].length ; j++) {\\n\\t\\t\\t\\t\\t\\tB[j][i] = A[i][j];\\n\\t\\t\\t\\t}\\n\\t\\t}        \\n\\t\\treturn B;\\n}\\n\\nprivate void inPlace(int[][] A) {\\n\\t\\tint col = 0;\\n\\t\\tfor (int i = 0; i<A.length ; i++) {\\n\\t\\t\\t\\tfor (int j=col ; j<A[0].length ; j++) {\\n\\t\\t\\t\\t\\t\\tint temp = A[i][j];\\n\\t\\t\\t\\t\\t\\tA[i][j] = A[j][i];\\n\\t\\t\\t\\t\\t\\tA[j][i] = temp;\\n\\t\\t\\t}\\n\\t\\t\\t\\tcol++;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] transpose(int[][] A) {\\n\\t\\tif (A.length == A[0].length) {\\n\\t\\t\\t\\tinPlace(A);\\n\\t\\t\\t\\treturn A;\\n\\t\\t}        \\n\\t\\tint[][] B = new int[A[0].length][A.length];\\n\\t\\tfor (int i=0; i<A.length ; i++) {\\n\\t\\t\\t\\tfor (int j=0; j<A[0].length ; j++) {\\n\\t\\t\\t\\t\\t\\tB[j][i] = A[i][j];\\n\\t\\t\\t\\t}\\n\\t\\t}        \\n\\t\\treturn B;\\n}\\n\\nprivate void inPlace(int[][] A) {\\n\\t\\tint col = 0;\\n\\t\\tfor (int i = 0; i<A.length ; i++) {\\n\\t\\t\\t\\tfor (int j=col ; j<A[0].length ; j++) {\\n\\t\\t\\t\\t\\t\\tint temp = A[i][j];\\n\\t\\t\\t\\t\\t\\tA[i][j] = A[j][i];\\n\\t\\t\\t\\t\\t\\tA[j][i] = temp;\\n\\t\\t\\t}\\n\\t\\t\\t\\tcol++;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2100098,
                "title": "python-easy-2-approaches-one-liner",
                "content": "1. ## **Simple array copy** \\n```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        m,n=len(matrix),len(matrix[0])\\n        ans = [[None] * m for _ in range(n)]\\n        for i in range(m):\\n            for j in range(n):\\n                ans[j][i]=matrix[i][j]\\n        \\n        return ans\\n```\\n---\\n\\n\\n2. ## **One liner using Python Built-in**\\n```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        return list(map(list,zip(*matrix))) # we need to explicitly cast as zip returns tuples\\n```\\n\\nThe tests passes with just doing this even if the return type is wrong:\\n```\\nreturn zip(*matrix)\\n```\\n\\n[saja4007](https://leetcode.com/saja4007/) pointed out that `zip` returns tuples instead of list and hence we need to explicitly cast it. Thanks for info [saja4007](https://leetcode.com/saja4007/).\\n\\nAnother one-liner using list comprehension shared by [robbiemu](https://leetcode.com/robbiemu/).\\n\\n```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        return [[matrix[y][x] for y in range(len(matrix))] for x in range(len(matrix[0]))]\\n```\\n\\n---\\n\\n**Time - O(number of elements)**\\n**Space - O(1)** - If you exclude the output array in space calculation.\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        m,n=len(matrix),len(matrix[0])\\n        ans = [[None] * m for _ in range(n)]\\n        for i in range(m):\\n            for j in range(n):\\n                ans[j][i]=matrix[i][j]\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        return list(map(list,zip(*matrix))) # we need to explicitly cast as zip returns tuples\\n```\n```\\nreturn zip(*matrix)\\n```\n```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        return [[matrix[y][x] for y in range(len(matrix))] for x in range(len(matrix[0]))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100497,
                "title": "o-m-n-solution-in-c-easy-to-understand",
                "content": "The idea here is very intuitive...\\nWe create an auxiliary matrix of size nXm, where m is the number of rows in the original matrix and n is the number of columns in the original matrix...\\nNow, we simply traverse the original matrix and fill up the auxiliary matrix in transpose order...\\nTranspose order implies --> matrix[i][j] = auxiliary[j][i] \\n\\n**Pls upvote this thread if you found it helpful**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n\\t\\t//Creating auxiliary matrix of size nXm... n=matrix[0].size and m=matrix.size()\\n        vector<vector<int>> res(matrix[0].size(), vector<int>(matrix.size()));\\n        \\n        for(int i=0;i<matrix.size();i++) {\\n            for(int j=0;j<matrix[0].size();j++) {\\n                res[j][i] = matrix[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n\\t\\t//Creating auxiliary matrix of size nXm... n=matrix[0].size and m=matrix.size()\\n        vector<vector<int>> res(matrix[0].size(), vector<int>(matrix.size()));\\n        \\n        for(int i=0;i<matrix.size();i++) {\\n            for(int j=0;j<matrix[0].size();j++) {\\n                res[j][i] = matrix[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 337289,
                "title": "javascript-1-line-easy-understanding-solution",
                "content": "```\\nvar transpose = function(A) {\\n    return A[0].map((_,  i) => A.map(b => b[i]));\\n};\\n\\n```\\n```\\norigin_matrix  colIndex        origin_col_arr\\n   \\n# 00 01 02                                              00 10 \\n#           ->  0 1 2  ->  [00, 10][01, 11][02 12] ===  01 11\\n# 10 11 12                                              02 12\\n```\\n\\n\\nExplanation:\\nThe outer map just get every `column index`, it\\'s equal to origin\\'s row length,  e.g: 0 1 2,\\nthen we need transform each such `column index` to a real row, 0 ->  [00, 01],  1 -> [01, 11],  2 -> [02, 12]\\nNow have col index `i`, and how to get the origin column vertical array?  A.map(row => row[i]) is what we want.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar transpose = function(A) {\\n    return A[0].map((_,  i) => A.map(b => b[i]));\\n};\\n\\n```\n```\\norigin_matrix  colIndex        origin_col_arr\\n   \\n# 00 01 02                                              00 10 \\n#           ->  0 1 2  ->  [00, 10][01, 11][02 12] ===  01 11\\n# 10 11 12                                              02 12\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 152978,
                "title": "python-3-easy-to-understand-code-explain-itself",
                "content": "```python\\nclass Solution:\\n    def transpose(self, A):\\n        \"\"\"\\n        :type A: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        sol = []\\n        \\n        for c in range(len(A[0])):\\n            tmp = []\\n            for r in range(len(A)):\\n                tmp.append(A[r][c])\\n            \\n            sol.append(tmp)\\n        \\n        return sol\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def transpose(self, A):\\n        \"\"\"\\n        :type A: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        sol = []\\n        \\n        for c in range(len(A[0])):\\n            tmp = []\\n            for r in range(len(A)):\\n                tmp.append(A[r][c])\\n            \\n            sol.append(tmp)\\n        \\n        return sol\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427625,
                "title": "java-easiest-solution-beats-100",
                "content": "```java\\npublic int[][] transpose(int[][] A) {\\n\\t//dimensions\\n\\tint M = A.length; int N = A[0].length;\\n\\n\\t//result matrix (w/ size from transposition)\\n\\tint[][] B = new int[N][M];\\n\\n\\t//iterate thru A\\n\\tfor (int i = 0; i < M; i++) {\\n\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\t//transpose\\n\\t\\t\\tB[j][i] = A[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\treturn B;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int[][] transpose(int[][] A) {\\n\\t//dimensions\\n\\tint M = A.length; int N = A[0].length;\\n\\n\\t//result matrix (w/ size from transposition)\\n\\tint[][] B = new int[N][M];\\n\\n\\t//iterate thru A\\n\\tfor (int i = 0; i < M; i++) {\\n\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\t//transpose\\n\\t\\t\\tB[j][i] = A[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\treturn B;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 718066,
                "title": "python-very-easy-to-understand-solution",
                "content": "This solution is somewhat slow with a runtime only faster than 20% of solutions but I think it\\'s very easy to understand.\\n```\\nclass Solution:\\n    def transpose(self, A: List[List[int]]) -> List[List[int]]:\\n        res = []\\n        n = len(A[0])\\n        for i in range(n):\\n            res.append([row[i] for row in A])\\n        return res\\n```\\n\\nYou could turn it into a one liner but I just feel like this overcomplicates things. i.e.\\n```\\nclass Solution:\\n    def transpose(self, A: List[List[int]]) -> List[List[int]]:\\n        return [[A[i][j] for i in range(len(A))] for j in range(len(A[0]))]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def transpose(self, A: List[List[int]]) -> List[List[int]]:\\n        res = []\\n        n = len(A[0])\\n        for i in range(n):\\n            res.append([row[i] for row in A])\\n        return res\\n```\n```\\nclass Solution:\\n    def transpose(self, A: List[List[int]]) -> List[List[int]]:\\n        return [[A[i][j] for i in range(len(A))] for j in range(len(A[0]))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672188,
                "title": "c-solution",
                "content": "```\\nvector<vector<int>> transpose(vector<vector<int>>& A) {\\n\\tvector<vector<int>> vRes(A[0].size(), vector<int>(A.size(), 0));\\n\\tfor (int i = 0; i < A.size(); i++) {\\n\\t\\tfor (int j = 0; j < A[0].size(); j++) {\\n\\t\\t\\tvRes[j][i] = A[i][j];\\n\\t\\t}\\n\\t}\\n\\treturn vRes;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> transpose(vector<vector<int>>& A) {\\n\\tvector<vector<int>> vRes(A[0].size(), vector<int>(A.size(), 0));\\n\\tfor (int i = 0; i < A.size(); i++) {\\n\\t\\tfor (int j = 0; j < A[0].size(); j++) {\\n\\t\\t\\tvRes[j][i] = A[i][j];\\n\\t\\t}\\n\\t}\\n\\treturn vRes;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 184596,
                "title": "javascript-solution",
                "content": "```\nvar transpose = function(A) {\n    let B = [];\n    let i = -1;\n    while (++i < A[0].length) {\n        if (!B[i]) B[i] = [];\n        let j = -1;\n        while (++j < A.length) {\n            B[i][j] = A[j][i];\n        }\n    }    \n    return B;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar transpose = function(A) {\n    let B = [];\n    let i = -1;\n    while (++i < A[0].length) {\n        if (!B[i]) B[i] = [];\n        let j = -1;\n        while (++j < A.length) {\n            B[i][j] = A[j][i];\n        }\n    }    \n    return B;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2228002,
                "title": "fastest-soln-0ms-beats-100-with-a-key-point-to-remember",
                "content": "![image](https://assets.leetcode.com/users/images/20cc775a-0bd0-4486-bb47-771e587fd7a8_1656776235.6940615.png)\\n\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int i=0,j=0;\\n        int m=matrix.length,n=matrix[0].length;\\n\\t\\t// The only thing to remember here is that we are given MxN matrix \\n\\t\\t// so we decalre our new matrix as NxM taking into consideration \\n\\t\\t// that if we are given a 4x2 matrix , then the transpose will be a 2x4 matrix.\\n        int[][] res= new int [n][m];\\n        for (i=0;i<m;i++)\\n        {\\n            for (j=0;j<n;j++)\\n            {\\n                res[j][i]=matrix[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n***Pls upvote if you find it helpful.***",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int i=0,j=0;\\n        int m=matrix.length,n=matrix[0].length;\\n\\t\\t// The only thing to remember here is that we are given MxN matrix \\n\\t\\t// so we decalre our new matrix as NxM taking into consideration \\n\\t\\t// that if we are given a 4x2 matrix , then the transpose will be a 2x4 matrix.\\n        int[][] res= new int [n][m];\\n        for (i=0;i<m;i++)\\n        {\\n            for (j=0;j<n;j++)\\n            {\\n                res[j][i]=matrix[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101931,
                "title": "c-solution",
                "content": "```\\nvector<vector<int>> transpose(vector<vector<int>>& mat) {\\n        int m= mat.size(), n=mat[0].size();\\n        if (m==n) {\\n                for(int i=0; i<m; i++)\\n                {\\n                for(int j=i+1; j<n; j++)\\n                    swap (mat[i][j], mat[j][i]);\\n                }\\n        }\\n        else\\n        {\\n            vector<vector<int>>ans; vector<int> v;\\n             for(int i=0; i<n; i++)\\n                {\\n                  for(int j=0; j<m; j++)  v.push_back(mat[j][i]) ;\\n                ans.push_back(v); v.clear();\\n                }\\n            return ans;\\n        }\\n        return mat;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> transpose(vector<vector<int>>& mat) {\\n        int m= mat.size(), n=mat[0].size();\\n        if (m==n) {\\n                for(int i=0; i<m; i++)\\n                {\\n                for(int j=i+1; j<n; j++)\\n                    swap (mat[i][j], mat[j][i]);\\n                }\\n        }\\n        else\\n        {\\n            vector<vector<int>>ans; vector<int> v;\\n             for(int i=0; i<n; i++)\\n                {\\n                  for(int j=0; j<m; j++)  v.push_back(mat[j][i]) ;\\n                ans.push_back(v); v.clear();\\n                }\\n            return ans;\\n        }\\n        return mat;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2101209,
                "title": "easy-question-but-beware-of-this-small-mistake",
                "content": "The simple approach is to just make a new matrix and for each element, store the value at (i, j) from the original matrix to the position (j, i) in the answer matrix. \\nThe only small mistake I made twice is that the answer matrix should have number of rows to the number of columns in the original matrix and vice versa. \\n\\n```\\nvector<vector<int>> transpose(vector<vector<int>>& mat) {\\n        int n = mat.size(), m=mat[0].size();\\n        \\n        vector<vector<int>> ans(m, vector<int> (n));\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) ans[j][i] = mat[i][j];\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> transpose(vector<vector<int>>& mat) {\\n        int n = mat.size(), m=mat[0].size();\\n        \\n        vector<vector<int>> ans(m, vector<int> (n));\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) ans[j][i] = mat[i][j];\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2100509,
                "title": "c-easy-understanding-solution",
                "content": "# **C++ Easy Understanding Solution**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<vector<int>>tp(n,vector<int>(m,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                tp[j][i]=matrix[i][j];\\n            }\\n        }\\n        return tp;\\n    }\\n};\\n```\\n# **Please share and Upvote**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<vector<int>>tp(n,vector<int>(m,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                tp[j][i]=matrix[i][j];\\n            }\\n        }\\n        return tp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147991,
                "title": "java-0ms-100-time-100-memory-explained",
                "content": "```\\n// Hello, this is the most optimal solution.\\n// 0ms Java, 100% time 100% memory\\n\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int width = matrix[0].length;\\n        int len = matrix.length;\\n        int[][] result = new int[width][len];\\n        for (int i = 0; i < width; i++){\\n            for (int j = 0; j < len; j++){\\n                result[i][j] = matrix[j][i];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n// First let\\'s understand the requirement, because it is a bit tricky\\n\\n// If they give you a 3x3 array, then the length and width of the array are equal to each other\\n// 123\\n// 456\\n// 789\\n\\n// But if they give you a 2x3 array, or 3x2 array, then you must be careful\\n// If you use matrix.length for both i and j pointers, you\\'ll get out of bounds errors\\n// And even if you control for the out of bounds errors with null checks\\n// You\\'ll still produce the wrong answer\\n// Because a 2x3 array must be returned as a 3x2 array\\n// And a 3x2 array must be returned as 2x3\\n// In other words, whatever the input length and width are\\n// We can set output length = input width,\\n// And output width = input length\\n\\n// The above paragraph isn\\'t immediately obvious from the requirement\\n// But I guess that has something to do with the geometric definition of \"transpose\"\\n\\n//Anyway, let\\'s look at the solution, and then analyze it line by line\\n\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int width = matrix[0].length;\\n        int len = matrix.length;\\n        int[][] result = new int[width][len];\\n        for (int i = 0; i < width; i++){\\n            for (int j = 0; j < len; j++){\\n                result[i][j] = matrix[j][i];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n// Let\\'s look at this line first: int width = matrix[0].length;\\n// The \"width\" of the input matrix will always be the length of its first array (index 0)\\n// This is also known as the \"number of columns in the table\"\\n// And the length will always be the length of the \"array of arrays\", aka, how many rows in the table\\n// So, when we create our result array, we put the width var where the len should be, and vice versa\\n// \"new int[width][len];\"\\n\\n// Likewise, as we loop through the original input matrix, we need to flip the loop termination condition\\n// Normally we would do \"for all the times i is less than matrix.length\\n// But we are living in opposite world, so we do \"for all the times i is less than the width\"\\n// And vice versa for j\\n// Then we just simply do : result[i][j] = matrix[j][i];\\n// Which means \"if we are at cell 0,5 in the input, write the value there to result cell 5,0\"\\n// This is equivalent to writing the top-right value to the bottom-left value\\n\\n// Thanks for listening!\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Hello, this is the most optimal solution.\\n// 0ms Java, 100% time 100% memory\\n\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int width = matrix[0].length;\\n        int len = matrix.length;\\n        int[][] result = new int[width][len];\\n        for (int i = 0; i < width; i++){\\n            for (int j = 0; j < len; j++){\\n                result[i][j] = matrix[j][i];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n// First let\\'s understand the requirement, because it is a bit tricky\\n\\n// If they give you a 3x3 array, then the length and width of the array are equal to each other\\n// 123\\n// 456\\n// 789\\n\\n// But if they give you a 2x3 array, or 3x2 array, then you must be careful\\n// If you use matrix.length for both i and j pointers, you\\'ll get out of bounds errors\\n// And even if you control for the out of bounds errors with null checks\\n// You\\'ll still produce the wrong answer\\n// Because a 2x3 array must be returned as a 3x2 array\\n// And a 3x2 array must be returned as 2x3\\n// In other words, whatever the input length and width are\\n// We can set output length = input width,\\n// And output width = input length\\n\\n// The above paragraph isn\\'t immediately obvious from the requirement\\n// But I guess that has something to do with the geometric definition of \"transpose\"\\n\\n//Anyway, let\\'s look at the solution, and then analyze it line by line\\n\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int width = matrix[0].length;\\n        int len = matrix.length;\\n        int[][] result = new int[width][len];\\n        for (int i = 0; i < width; i++){\\n            for (int j = 0; j < len; j++){\\n                result[i][j] = matrix[j][i];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n// Let\\'s look at this line first: int width = matrix[0].length;\\n// The \"width\" of the input matrix will always be the length of its first array (index 0)\\n// This is also known as the \"number of columns in the table\"\\n// And the length will always be the length of the \"array of arrays\", aka, how many rows in the table\\n// So, when we create our result array, we put the width var where the len should be, and vice versa\\n// \"new int[width][len];\"\\n\\n// Likewise, as we loop through the original input matrix, we need to flip the loop termination condition\\n// Normally we would do \"for all the times i is less than matrix.length\\n// But we are living in opposite world, so we do \"for all the times i is less than the width\"\\n// And vice versa for j\\n// Then we just simply do : result[i][j] = matrix[j][i];\\n// Which means \"if we are at cell 0,5 in the input, write the value there to result cell 5,0\"\\n// This is equivalent to writing the top-right value to the bottom-left value\\n\\n// Thanks for listening!\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557664,
                "title": "easy-javascript-solution",
                "content": "```\\nvar transpose = function(A) {\\n    let result = [];\\n    \\n    for(let i= 0; i<A[0].length; i++){\\n        let currentCol = []\\n        for(let j=0; j<A.length; j++){\\n            currentCol.push(A[j][i])\\n        }\\n        result.push(currentCol);\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar transpose = function(A) {\\n    let result = [];\\n    \\n    for(let i= 0; i<A[0].length; i++){\\n        let currentCol = []\\n        for(let j=0; j<A.length; j++){\\n            currentCol.push(A[j][i])\\n        }\\n        result.push(currentCol);\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2102688,
                "title": "easy-python-solution",
                "content": "```\\ndef transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        l=[]\\n        for i in range(len(matrix[0])):\\n            temp = []\\n            for j in range(len(matrix)):\\n                temp.append(matrix[j][i])\\n            l.append(temp)\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        l=[]\\n        for i in range(len(matrix[0])):\\n            temp = []\\n            for j in range(len(matrix)):\\n                temp.append(matrix[j][i])\\n            l.append(temp)\\n        return l\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 253020,
                "title": "an-in-place-matrix-transpose",
                "content": "The following algorithm is taken from this [GeeksforGeeks post](https://www.geeksforgeeks.org/inplace-m-x-n-size-matrix-transpose/). Note that it has different interface from the one on LeetCode. However, I think the interesting part of matrix transpose is how to do it in-place. So I rewrote the codes from the above post in LeetCode-style below.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void transpose(int* A, int r, int c) {\\n        for (int i = 1, n = r * c; i < r - 1; i++) { \\n\\t\\t    int start = i;\\n\\t\\t    do {\\n\\t\\t\\t    int j = (i * r) % (n - 1); \\n\\t\\t \\t    swap(A[i], A[j]); \\n\\t\\t\\t    i = j;\\n\\t\\t    } while (i != start); \\n\\t    } \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void transpose(int* A, int r, int c) {\\n        for (int i = 1, n = r * c; i < r - 1; i++) { \\n\\t\\t    int start = i;\\n\\t\\t    do {\\n\\t\\t\\t    int j = (i * r) % (n - 1); \\n\\t\\t \\t    swap(A[i], A[j]); \\n\\t\\t\\t    i = j;\\n\\t\\t    } while (i != start); \\n\\t    } \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158312,
                "title": "simple-java-solution",
                "content": "```\\npublic static int[][] transpose(int[][] A){\\n        int result[][] = new int[A[0].length][A.length];\\n\\n        if(A.length == 0){\\n            return result;\\n        }\\n\\n        for(int i = 0; i < A[0].length; i++){\\n            for(int j = 0; j < A.length; j++){\\n                result[i][j] = A[j][i];\\n            }\\n        }\\n\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic static int[][] transpose(int[][] A){\\n        int result[][] = new int[A[0].length][A.length];\\n\\n        if(A.length == 0){\\n            return result;\\n        }\\n\\n        for(int i = 0; i < A[0].length; i++){\\n            for(int j = 0; j < A.length; j++){\\n                result[i][j] = A[j][i];\\n            }\\n        }\\n\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2101282,
                "title": "cpp-solution-95-faster-intuitive-approach-matrix-simulation-two-approaches",
                "content": "__Thank you for checking out my solution, Do Upvote if it helped :)__\\n\\n__\"The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix\\'s row and column indices\".\\nTherefore the idea here is to to fill all the row elements of the given matrix as the column elements of the transpose matrix\\nor the columns elements of the given matrix as the row elements of the transpose matrix.__\\n\\n__Had the given constraints stated that the matrix is square, we could have solved the question in-place.\\nEven now it is possible (not exactly in-place, but without creating a new matrix) as we shall see in the next approach, but its not very intuitive.__\\n\\n__Approach 1 (Recommended):__\\n\\n>Create a matrix which has\\n>>rows = columns of the given matrix \\n>>columns = rows of the given matrix\\n>>i.e. if the given matrix has dimensions [R x C], then our answer matrix will have dimensions as [C x R]\\n\\n>Now Simply Run the loops\\n>>Outer loop from i = 0 to i = column number\\n>>>Inner loop from j = 0 to j = row number, (you can reverse them too)\\n>>>Fill answer[i][j] = matrix [j][i] , [change matrix with answer, if you reverse the above mentioned two loops]\\n\\n>Now return the answer matrix!\\n\\n__Below is the cpp implementation of the above mentioned approach__\\n\\n\\n```\\nclass Solution {  // Runtime: 8 ms, faster than 95.19% of C++ online submissions for Transpose Matrix.\\n                  // Memory Usage: 10.6 MB, less than 43.03% of C++ online submissions for Transpose Matrix.\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) \\n    {\\n         int x = matrix.size(), y = matrix[0].size();          //getting the number of rows and columns \\n         vector<vector<int>> res(y,vector<int>(x));            //Creating a transpose matrix [columns x rows]\\n         for(int i = 0; i < y;i++)\\n             for(int j = 0;j < x; j++)\\n                 res[i][j] = matrix[j][i];                     //Filling the matrix, (i,j)th cell in res is to be filled with (j,i)th cell in matrix\\n        return res;\\n    }\\n};\\n```\\n__Time Complexity : O(Rows * Columns) ~ O(N^2)\\nSpace Complexity : O(Rows * Columns) ~ O(N^2)__\\n>.\\n>.\\n_____\\n__Approach 2 (Just to make the question slightly tough):__\\n\\n__As mentioned before, had the given constraints stated that the matrix is square, we could have solved the question in-place and in less time(jth loop will begin from i). This is because then we would have just swapped the current element and the element on the other side of the diagonal\\ni.e. (i,j)th element with the (j,i)th element.\\nAnd since there would have been a symmetry(shape of a square matrix is not affected by rotation), there would have been no issues with the dimensions.__\\n\\n__Since it won\\'t always be a square, so you can take min of (rows, columns), swap the values by running both the loops to this minimum\\nBut this only works for the matrix of dimension [(min) x (min)], \\nAnd now the problem begins:\\nif rows < columns:__\\n>__(Its More Problematic)\\n>Iterate i from min(R,C) to C\\n>Initialise a temporary vector v__\\n>>Iterate j from 0 to R(rows)\\n>>Keeping pushing the (j)th [current] column elements into a temporary vector\\n>\\n>__Now Push this temporary vector into the matrix\\n>Now that the elements are all pushed, resize the vectors from 0 to MIN, with size(R)__\\n\\n__if rows > columns__\\n>__(Its Relatively easier)\\n>Iterate i from 0 to min(R,C)__\\n>>Iterate j from min(R,C) to R\\n>>Keeping pushing the extra column elements in the (i)th column to the (i)th row\\n>\\n>__Now Resize the matrix to C columns, Since all the rows will with less elements are to be ignored, simply resize to C__\\n\\n__Return the current matrix, here we altered the current matrix to get its transpose__\\n____\\nBelow is the cpp implementation of the above mentioned Approach\\n\\n\\n\\n```\\nclass Solution\\n{ // Runtime: 20 ms, faster than 27.23% of C++ online submissions for Transpose Matrix.\\n  // Memory Usage: 10.6 MB, less than 43.03% of C++ online submissions for Transpose Matrix.\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>> &matrix)\\n    {\\n        int R = matrix.size(), C = matrix[0].size(); // getting the number of rows and columns\\n        int MIN = min(R, C), diff = abs(R - C);\\n        for (int i = 0; i < MIN; i++)     // For a square matrix , just swapping the (i,j)th cell with (j,i)th cell works\\n            for (int j = i; j < MIN; j++) // The dimension is halved because (j,i)th cell is on the other side of the diagonal\\n                swap(matrix[i][j], matrix[j][i]);\\n        if (R < C) // When rows < columns, resizing is an issue\\n        {\\n            for (int i = MIN; i < C; i++)\\n            {\\n                vector<int> v;\\n                for (int j = 0; j < R; j++) // Combining extra columns elements to a since vector\\n                    v.push_back(matrix[j][i]);\\n                matrix.push_back(v); // Adding this combine column vector as a new row to the matrix\\n            }\\n            // Resizing as [C x R]\\n            for (int i = 0; i < MIN; i++) // Resize all the rows with extra elements\\n                matrix[i].resize(R);\\n        }\\n        else if (C < R)// When rows < column, it gets easier\\n        {\\n            for (int i = 0; i < MIN; i++)\\n                for (int j = MIN; j < R; j++)\\n                    matrix[i].push_back(matrix[j][i]); // All the extra column elements in the (i)th column,will be pushed to (i)th row\\n            matrix.resize(C);                          // Since all the rows will with less elements are to be ignored, simply resize to C\\n        }\\n        return matrix;\\n    }\\n};\\n```\\n__Time Complexity : O(Rows * Columns) ~ O(N^2)\\nSpace Complexity : O(Rows * Columns) ~ O(N^2)__",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {  // Runtime: 8 ms, faster than 95.19% of C++ online submissions for Transpose Matrix.\\n                  // Memory Usage: 10.6 MB, less than 43.03% of C++ online submissions for Transpose Matrix.\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) \\n    {\\n         int x = matrix.size(), y = matrix[0].size();          //getting the number of rows and columns \\n         vector<vector<int>> res(y,vector<int>(x));            //Creating a transpose matrix [columns x rows]\\n         for(int i = 0; i < y;i++)\\n             for(int j = 0;j < x; j++)\\n                 res[i][j] = matrix[j][i];                     //Filling the matrix, (i,j)th cell in res is to be filled with (j,i)th cell in matrix\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution\\n{ // Runtime: 20 ms, faster than 27.23% of C++ online submissions for Transpose Matrix.\\n  // Memory Usage: 10.6 MB, less than 43.03% of C++ online submissions for Transpose Matrix.\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>> &matrix)\\n    {\\n        int R = matrix.size(), C = matrix[0].size(); // getting the number of rows and columns\\n        int MIN = min(R, C), diff = abs(R - C);\\n        for (int i = 0; i < MIN; i++)     // For a square matrix , just swapping the (i,j)th cell with (j,i)th cell works\\n            for (int j = i; j < MIN; j++) // The dimension is halved because (j,i)th cell is on the other side of the diagonal\\n                swap(matrix[i][j], matrix[j][i]);\\n        if (R < C) // When rows < columns, resizing is an issue\\n        {\\n            for (int i = MIN; i < C; i++)\\n            {\\n                vector<int> v;\\n                for (int j = 0; j < R; j++) // Combining extra columns elements to a since vector\\n                    v.push_back(matrix[j][i]);\\n                matrix.push_back(v); // Adding this combine column vector as a new row to the matrix\\n            }\\n            // Resizing as [C x R]\\n            for (int i = 0; i < MIN; i++) // Resize all the rows with extra elements\\n                matrix[i].resize(R);\\n        }\\n        else if (C < R)// When rows < column, it gets easier\\n        {\\n            for (int i = 0; i < MIN; i++)\\n                for (int j = MIN; j < R; j++)\\n                    matrix[i].push_back(matrix[j][i]); // All the extra column elements in the (i)th column,will be pushed to (i)th row\\n            matrix.resize(C);                          // Since all the rows will with less elements are to be ignored, simply resize to C\\n        }\\n        return matrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 276103,
                "title": "javascript",
                "content": "```\\nvar transpose = function(A) {\\n    if(A.length === 0) return [];\\n    var w = A[0].length, h = A.length;\\n    var desArr = [];\\n    for(var i = 0; i < w; i ++) {\\n        desArr[i] = [];\\n        for(var j = 0; j < h; j ++){\\n            desArr[i][j] = A[j][i];\\n        }\\n    }\\n    return desArr;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar transpose = function(A) {\\n    if(A.length === 0) return [];\\n    var w = A[0].length, h = A.length;\\n    var desArr = [];\\n    for(var i = 0; i < w; i ++) {\\n        desArr[i] = [];\\n        for(var j = 0; j < h; j ++){\\n            desArr[i][j] = A[j][i];\\n        }\\n    }\\n    return desArr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3676961,
                "title": "c-easy-implementation-using-vectors",
                "content": "vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n     vector<vector<int>> ans;\\n     int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<m;i++){\\n            vector<int>s;\\n            for(int j=0;j<n;j++){\\n                s.push_back(matrix[j][i]);\\n\\n            }\\n            ans.push_back(s);\\n        }\\n        return ans;\\n\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n     vector<vector<int>> ans;\\n     int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<m;i++){\\n            vector<int>s;\\n            for(int j=0;j<n;j++){\\n                s.push_back(matrix[j][i]);\\n\\n            }\\n            ans.push_back(s);\\n        }\\n        return ans;\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3155133,
                "title": "java-easy-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n        int arr[][]=new int[col][row];\\n        for(int i=0;i<col;i++)\\n        {\\n            for(int j=0;j<row;j++)\\n            {\\n            arr[i][j]=matrix[j][i];\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n        int arr[][]=new int[col][row];\\n        for(int i=0;i<col;i++)\\n        {\\n            for(int j=0;j<row;j++)\\n            {\\n            arr[i][j]=matrix[j][i];\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2594470,
                "title": "c-easy-solution-99-9-faster",
                "content": "### **Note:** \\nIn **C#** there are two types or arrays: **Jagged Arrays - Multidimensional Arrays**. The main difference between them that we have to **intialize** every **row** (array) in the **jagged** to specify the length of it (**cols**). There are more differences but i mentioned the one that suites this problem.\\n\\n### **For more info please read the docuentation.**\\n**Multidimensional Arrays:**\\nhttps://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/multidimensional-arrays\\n**Jagged Arrays:**\\nhttps://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/jagged-arrays\\n### **Solution:**\\n\\n\\n\\n```\\npublic class Solution {\\n    public int[][] Transpose(int[][] matrix) {\\n        int row = matrix.Length, col = matrix[0].Length;  // We get the rows and cols of the matrix.\\n        int[][] transpose = new int[col][];  // Declaring a Jagged array\\n        for(int i = 0; i < col; i++){\\n            transpose[i] = new int[row]; // Intialize every row in the jagged array\\n            for(int j = 0; j < row; j++)\\n                transpose[i][j] = matrix[j][i];\\n        }\\n        return transpose;\\n    }\\n}\\n```\\n**Don\\'t Forget To Upvote your homie :). Thank you for reading.**",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] Transpose(int[][] matrix) {\\n        int row = matrix.Length, col = matrix[0].Length;  // We get the rows and cols of the matrix.\\n        int[][] transpose = new int[col][];  // Declaring a Jagged array\\n        for(int i = 0; i < col; i++){\\n            transpose[i] = new int[row]; // Intialize every row in the jagged array\\n            for(int j = 0; j < row; j++)\\n                transpose[i][j] = matrix[j][i];\\n        }\\n        return transpose;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317419,
                "title": "beats-100-other-solutions-list",
                "content": "```\\nclass Solution:\\n    def transpose(self, arr: List[List[int]]) -> List[List[int]]:\\n        big = []\\n        small_lis = []\\n        for i in range(len(arr[0])):\\n            for j in range(len(arr)):\\n                small_lis.append(arr[j][i])\\n            big.append(small_lis)\\n            small_lis = []\\n        return big\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def transpose(self, arr: List[List[int]]) -> List[List[int]]:\\n        big = []\\n        small_lis = []\\n        for i in range(len(arr[0])):\\n            for j in range(len(arr)):\\n                small_lis.append(arr[j][i])\\n            big.append(small_lis)\\n            small_lis = []\\n        return big\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101025,
                "title": "c-easy-transpose-comments-added-daily-leetcoding-challenge-june-day-2",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nHere Swap method in the given matrix will not work because that method is only works well for (nxn) matrix but here matrix size is M*N\\n\\nCode:\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) \\n    {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        \\n        // declare the matrix ans[col][row] instead of ans[row][col] with value 0\\n        // because in res we are going to store result in transpose form (so just change the rows with col)\\n        vector<vector<int>> ans(col,vector<int> (row,0));\\n         \\n        // iterate over the matrix rows\\n        for(int i=0;i<row;i++)\\n        {\\n            // iterate over the columns for each row\\n            for(int j=0;j<col;j++)\\n            {\\n                // store values in new declared matrix in transpose form\\n                ans[j][i] = matrix[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nHere Swap method in the given matrix will not work because that method is only works well for (nxn) matrix but here matrix size is M*N\\n\\nCode:\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) \\n    {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        \\n        // declare the matrix ans[col][row] instead of ans[row][col] with value 0\\n        // because in res we are going to store result in transpose form (so just change the rows with col)\\n        vector<vector<int>> ans(col,vector<int> (row,0));\\n         \\n        // iterate over the matrix rows\\n        for(int i=0;i<row;i++)\\n        {\\n            // iterate over the columns for each row\\n            for(int j=0;j<col;j++)\\n            {\\n                // store values in new declared matrix in transpose form\\n                ans[j][i] = matrix[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100483,
                "title": "java-simple-video-explanation",
                "content": "https://www.youtube.com/watch?v=tSgncG8C2Oo",
                "solutionTags": [
                    "Java"
                ],
                "code": "https://www.youtube.com/watch?v=tSgncG8C2Oo",
                "codeTag": "Unknown"
            },
            {
                "id": 2100232,
                "title": "python3-very-easy-one-liner",
                "content": "```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        return [e for e in zip(*matrix)]\\n```",
                "solutionTags": [
                    "Python",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        return [e for e in zip(*matrix)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620746,
                "title": "python-easy-to-understand-solution-acceptable-in-interviews",
                "content": "def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\\\\\n        \\n        transpose = [] # making an empty list\\n        \\n        for col in range(len(matrix[0])):\\n            transpose.append([]) # Before looping through each column we are append an empty list inside a list. So that we can append each and every value encountered in a particular value to that list.\\n            \\n            for row in range(len(matrix)):\\n                # This is the heart of the code.\\n                # Here I am appending all the values of a column in the the empty list which we just appended\\n                transpose[col].append(matrix[row][col])\\n        return transpose\\n                \\n                \\n# This was the kind of solution which I was looking for. This can be accepted in the interviews. Not the one\\'s which uses zip.\\n                \\n                \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\\\\\n        \\n        transpose = [] # making an empty list\\n        \\n        for col in range(len(matrix[0])):\\n            transpose.append([]) # Before looping through each column we are append an empty list inside a list. So that we can append each and every value encountered in a particular value to that list.\\n            \\n            for row in range(len(matrix)):\\n                # This is the heart of the code.\\n                # Here I am appending all the values of a column in the the empty list which we just appended\\n                transpose[col].append(matrix[row][col])\\n        return transpose\\n                \\n                \\n# This was the kind of solution which I was looking for. This can be accepted in the interviews. Not the one\\'s which uses zip.\\n                \\n                \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1403594,
                "title": "java-follow-up-questions",
                "content": "* Reflect rectangular matrix about primary/main diagonal. \\n* This operation is called transpose where rows and columns get swapped\\n* Extra space can\\'t be avoided because if the matrix is not square, then dimensions of the result matrix swap, so the original matrix can\\'t be used as the result. e.g. 4 x 3 matrix becomes 3 x 4. It can be avoided when the matrix is square.\\n>**T/S:** O(mn)/O(mn), where m x n are the dimensions of the matrix and m may or may not be equal to n.\\n```\\npublic int[][] transpose(int[][] matrix) {\\n\\tvar row = matrix.length;\\n\\tvar col = matrix[0].length;\\n\\tvar trans = new int[col][row];\\n\\tfor (var i = 0; i < row; i++)\\n\\t\\tfor (var j = 0; j < col; j++)\\n\\t\\t\\ttrans[j][i] = matrix[i][j];\\n\\treturn trans;\\n}\\n```\\n*Related questions*\\nReflect square matrix about primary/main diagonal\\n>**T/S:** O(n\\xB2)/O(1), where n x n are the dimensions of the matrix\\n```\\npublic int[][] reflectSquareMatrixAboutPrimaryDiagonal(int[][] matrix) {\\n\\tfor (var i = 0; i < matrix.length; i++)\\n\\t\\tfor (var j = i + 1; j < matrix.length; j++) {\\n\\t\\t\\tvar temp = matrix[i][j];\\n\\t\\t\\tmatrix[i][j] = matrix[j][i];\\n\\t\\t\\tmatrix[j][i] = temp;\\n\\t\\t}\\n\\treturn matrix;\\n}\\n```\\n\\nReflect square matrix about secondary diagonal\\n>**T/S:** O(n\\xB2)/O(1)\\n```\\npublic int[][] reflectSquareMatrixAboutSecondaryDiagonal(int[][] matrix) {\\n\\tint n = matrix.length;\\n\\tfor (int i = 0; i < n - 1; i++)\\n\\t\\tfor (int j = 0; j < n - 1 - i; j++) {\\n\\t\\t\\tint temp = matrix[i][j];\\n\\t\\t\\tmatrix[i][j] = matrix[n - 1 - j][n - 1 - i];\\n\\t\\t\\tmatrix[n - 1 - j][n - 1 - i] = temp;\\n\\t\\t}\\n\\treturn matrix;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] transpose(int[][] matrix) {\\n\\tvar row = matrix.length;\\n\\tvar col = matrix[0].length;\\n\\tvar trans = new int[col][row];\\n\\tfor (var i = 0; i < row; i++)\\n\\t\\tfor (var j = 0; j < col; j++)\\n\\t\\t\\ttrans[j][i] = matrix[i][j];\\n\\treturn trans;\\n}\\n```\n```\\npublic int[][] reflectSquareMatrixAboutPrimaryDiagonal(int[][] matrix) {\\n\\tfor (var i = 0; i < matrix.length; i++)\\n\\t\\tfor (var j = i + 1; j < matrix.length; j++) {\\n\\t\\t\\tvar temp = matrix[i][j];\\n\\t\\t\\tmatrix[i][j] = matrix[j][i];\\n\\t\\t\\tmatrix[j][i] = temp;\\n\\t\\t}\\n\\treturn matrix;\\n}\\n```\n```\\npublic int[][] reflectSquareMatrixAboutSecondaryDiagonal(int[][] matrix) {\\n\\tint n = matrix.length;\\n\\tfor (int i = 0; i < n - 1; i++)\\n\\t\\tfor (int j = 0; j < n - 1 - i; j++) {\\n\\t\\t\\tint temp = matrix[i][j];\\n\\t\\t\\tmatrix[i][j] = matrix[n - 1 - j][n - 1 - i];\\n\\t\\t\\tmatrix[n - 1 - j][n - 1 - i] = temp;\\n\\t\\t}\\n\\treturn matrix;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751053,
                "title": "c-solution-transpose-matrix",
                "content": "```\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** transpose(int** A, int ASize, int* AColSize, int* returnSize, int** returnColumnSizes)\\n{\\n    int i,j,x,y,temp;\\n    x = ASize;\\n    y = *AColSize;\\n    int **B = malloc(sizeof(int *[y]));\\n    *returnColumnSizes = malloc(sizeof(int)* y);\\n    *returnSize = y;\\n    for(i=0;i<y;i++)\\n    {\\n        B[i] = malloc(sizeof(int)* x);\\n        (*returnColumnSizes)[i] = x;\\n    }\\n    \\n    for(i=0;i<y;i++)\\n    {\\n        for(j=0;j<x;j++)\\n        {\\n            B[i][j] = A[j][i];    \\n        }\\n    }\\n    return B;\\n    \\n}\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** transpose(int** A, int ASize, int* AColSize, int* returnSize, int** returnColumnSizes)\\n{\\n    int i,j,x,y,temp;\\n    x = ASize;\\n    y = *AColSize;\\n    int **B = malloc(sizeof(int *[y]));\\n    *returnColumnSizes = malloc(sizeof(int)* y);\\n    *returnSize = y;\\n    for(i=0;i<y;i++)\\n    {\\n        B[i] = malloc(sizeof(int)* x);\\n        (*returnColumnSizes)[i] = x;\\n    }\\n    \\n    for(i=0;i<y;i++)\\n    {\\n        for(j=0;j<x;j++)\\n        {\\n            B[i][j] = A[j][i];    \\n        }\\n    }\\n    return B;\\n    \\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 351437,
                "title": "go-golang-clean-solution",
                "content": "```go\\nfunc transpose(matrix [][]int) [][]int {\\n    m, n := len(matrix), len(matrix[0])\\n    res := make([][]int, n)\\n    for i := range res { res[i] = make([]int, m) }\\n    for i := 0; i < m; i++ {\\n        for j := 0; j < n; j++ {\\n            res[j][i] = matrix[i][j]\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc transpose(matrix [][]int) [][]int {\\n    m, n := len(matrix), len(matrix[0])\\n    res := make([][]int, n)\\n    for i := range res { res[i] = make([]int, m) }\\n    for i := 0; i < m; i++ {\\n        for j := 0; j < n; j++ {\\n            res[j][i] = matrix[i][j]\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 179861,
                "title": "c-solution-with-promotion-matrix-to-almost-quadratic-transposing-and-then-shrinking-it",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& A) {\\n        auto const rows = A.size(), cols = A[0].size(); \\n        auto const minmax = std::minmax(rows, cols);\\n        \\n        if (minmax.first == rows) A.resize(minmax.second, std::vector<int>(minmax.first));\\n        else for (auto &row : A) row.resize(minmax.second);\\n        \\n        for (int i = 0; i < A.size(); ++i) {\\n            for (int j = i + 1; j < A[0].size(); ++j) {\\n                std::swap(A[i][j], A[j][i]);\\n            }\\n        }\\n        \\n        if (minmax.first == rows) for (auto &row : A) row.resize(minmax.first);\\n        else A.resize(minmax.first);\\n\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& A) {\\n        auto const rows = A.size(), cols = A[0].size(); \\n        auto const minmax = std::minmax(rows, cols);\\n        \\n        if (minmax.first == rows) A.resize(minmax.second, std::vector<int>(minmax.first));\\n        else for (auto &row : A) row.resize(minmax.second);\\n        \\n        for (int i = 0; i < A.size(); ++i) {\\n            for (int j = i + 1; j < A[0].size(); ++j) {\\n                std::swap(A[i][j], A[j][i]);\\n            }\\n        }\\n        \\n        if (minmax.first == rows) for (auto &row : A) row.resize(minmax.first);\\n        else A.resize(minmax.first);\\n\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 147063,
                "title": "js-one-line-solution",
                "content": "```js\\n/**\\n * @param {number[][]} A\\n * @return {number[][]}\\n */\\nvar transpose = function(A) {\\n    return A[0].map((val, ind) => A.map(row => row[ind]));\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {number[][]} A\\n * @return {number[][]}\\n */\\nvar transpose = function(A) {\\n    return A[0].map((val, ind) => A.map(row => row[ind]));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3896395,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        result = [[0 for _ in range(len(matrix))] for _ in range(len(matrix[0]))]\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                result[j][i] = matrix[i][j]\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        result = [[0 for _ in range(len(matrix))] for _ in range(len(matrix[0]))]\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                result[j][i] = matrix[i][j]\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743573,
                "title": "simple-and-easy-beats-100",
                "content": "# please upvote if you feel it easy\\uD83D\\uDE0A\\u2764\\n# Code\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int m = matrix[0].length,n=matrix.length;\\n        int[][] tm = new int[m][n];\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++) \\n            {\\n                tm[i][j] = matrix[j][i];\\n            }\\n        }\\n        return tm;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int m = matrix[0].length,n=matrix.length;\\n        int[][] tm = new int[m][n];\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++) \\n            {\\n                tm[i][j] = matrix[j][i];\\n            }\\n        }\\n        return tm;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735204,
                "title": "easy-c-solution",
                "content": "Here is my solution in C++\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        vector<vector<int>> ans;\\n        for (int i=0; i<matrix[0].size(); i++){ //no of cols\\n            vector<int> v;\\n            for (int j= 0; j<matrix.size(); j++){ // no of rows\\n                v.push_back(matrix[j][i]);\\n            }\\n            ans.push_back(v);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        vector<vector<int>> ans;\\n        for (int i=0; i<matrix[0].size(); i++){ //no of cols\\n            vector<int> v;\\n            for (int j= 0; j<matrix.size(); j++){ // no of rows\\n                v.push_back(matrix[j][i]);\\n            }\\n            ans.push_back(v);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567429,
                "title": "easy-java-solution-single-traversal-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n\\t\\t//creating an 2d array of opposite size from row and column\\n        int[][] ans = new int[matrix[0].length][matrix.length];\\n        for(int i = 0 ; i < matrix.length ; i ++){\\n            for(int j = 0 ; j < matrix[0].length; j ++){\\n\\t\\t\\t\\t//storing the element by interchanging the indexs\\n                ans[j][i] = matrix[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n\\t\\t//creating an 2d array of opposite size from row and column\\n        int[][] ans = new int[matrix[0].length][matrix.length];\\n        for(int i = 0 ; i < matrix.length ; i ++){\\n            for(int j = 0 ; j < matrix[0].length; j ++){\\n\\t\\t\\t\\t//storing the element by interchanging the indexs\\n                ans[j][i] = matrix[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528813,
                "title": "python-solution-one-liner-100-faster-zip-em-all",
                "content": "```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        return zip(*matrix)        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        return zip(*matrix)        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386188,
                "title": "simple-solution-in-javascript-easy-to-understand",
                "content": "```\\n// Leetcode 867: Transpose Matrix\\n/**\\n * @param {number[][]} matrix\\n * @return {number[][]}\\n */\\nconst transpose = function (matrix) {\\n  let result = []\\n  for (let i = 0; i < matrix[0].length; i++) {\\n    let inner = []\\n    for (let j = 0; j < matrix.length; j++) {\\n      inner.push(matrix[j][i]);\\n    }\\n    result.push(inner);\\n  }\\n  return result;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Leetcode 867: Transpose Matrix\\n/**\\n * @param {number[][]} matrix\\n * @return {number[][]}\\n */\\nconst transpose = function (matrix) {\\n  let result = []\\n  for (let i = 0; i < matrix[0].length; i++) {\\n    let inner = []\\n    for (let j = 0; j < matrix.length; j++) {\\n      inner.push(matrix[j][i]);\\n    }\\n    result.push(inner);\\n  }\\n  return result;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2102293,
                "title": "java-easy-solution-100-faster-bro",
                "content": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] res = new int[matrix[0].length][matrix.length];\\n        for (int i = 0; i < matrix[0].length; i++) {\\n            for (int j = 0; j < matrix.length; j++) {\\n                res[i][j] = matrix[j][i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] res = new int[matrix[0].length][matrix.length];\\n        for (int i = 0; i < matrix[0].length; i++) {\\n            for (int j = 0; j < matrix.length; j++) {\\n                res[i][j] = matrix[j][i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102224,
                "title": "0ms-easy-to-understand-faster-than-100-of-java-solution",
                "content": "Transpose of a matrix A is B such that\\nA(i,j) = B(j,i)\\n\\nif A a have n row and m columns then B will have m rows and n columns.\\n\\n```\\npublic int[][] transpose(int[][] matrix) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        \\n        int[][] res = new int[col][row];\\n        for(int i = 0;i<row;i++) {\\n            for(int j = 0;j<col;j++) {\\n                res[j][i] = matrix[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\nT(n) = O(m*n)\\nS(n) =O(m*n)\\n\\nRuntime: 1 ms, faster than 100% of Java online submissions for Transpose Matrix.\\nMemory Usage: 48.6 MB, less than 90.25% of Java online submissions for Transpose Matrix.\\n\\nEnjoy",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\npublic int[][] transpose(int[][] matrix) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        \\n        int[][] res = new int[col][row];\\n        for(int i = 0;i<row;i++) {\\n            for(int j = 0;j<col;j++) {\\n                res[j][i] = matrix[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2101370,
                "title": "c-transpose-of-matrix",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n       int n = matrix.size();\\n        int m= matrix[0].size();\\n        vector<vector<int>>res(m,vector<int> (n,0)); //creation of 2d array\\n        for(int i=0;i<n;i++){\\n            //filling of two d array\\n            for(int j=0;j<m;j++){\\n             res[j][i]=matrix[i][j];\\n            }\\n            \\n        }return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n       int n = matrix.size();\\n        int m= matrix[0].size();\\n        vector<vector<int>>res(m,vector<int> (n,0)); //creation of 2d array\\n        for(int i=0;i<n;i++){\\n            //filling of two d array\\n            for(int j=0;j<m;j++){\\n             res[j][i]=matrix[i][j];\\n            }\\n            \\n        }return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101254,
                "title": "transpose-matrix-6-liner-code-easy-readable-code",
                "content": "The idea is just to create 2d matrix with all 0 but of size n*m (if size of original matrix is m*n);\\nNow just put in new matrix like this :\\n```\\n                          v[i][j]=matrix[j][i];\\n```\\nIf want to see the solution for this ->\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) \\n    {\\n        vector<vector<int>> v(matrix[0].size(),vector<int>(matrix.size(),0));\\n        for(int i=0;i<matrix[0].size();i++)\\n        {\\n            for(int j=0;j<matrix.size();j++)\\n            {\\n                v[i][j]=matrix[j][i];\\n            }\\n        }\\n        return v;\\n    }\\n};\\n````\\nPlease **UPVOTE** if you like and understand!!!",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\n                          v[i][j]=matrix[j][i];\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) \\n    {\\n        vector<vector<int>> v(matrix[0].size(),vector<int>(matrix.size(),0));\\n        for(int i=0;i<matrix[0].size();i++)\\n        {\\n            for(int j=0;j<matrix.size();j++)\\n            {\\n                v[i][j]=matrix[j][i];\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100851,
                "title": "c-easy-to-understand-comments",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n\\t\\t\\tint row=matrix.size();\\n\\t\\t\\tint col=matrix[0].size();\\n\\t\\t\\t//create new matrix with all value 0 in it\\n\\t\\t\\tvector<vector<int>>matrix2(col,vector<int>(row,0));\\n\\t\\t\\t\\tfor(int i=0;i<row;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<col;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmatrix2[j][i]=matrix[i][j]; //transpose the matrix\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\treturn matrix2;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n\\t\\t\\tint row=matrix.size();\\n\\t\\t\\tint col=matrix[0].size();\\n\\t\\t\\t//create new matrix with all value 0 in it\\n\\t\\t\\tvector<vector<int>>matrix2(col,vector<int>(row,0));\\n\\t\\t\\t\\tfor(int i=0;i<row;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<col;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmatrix2[j][i]=matrix[i][j]; //transpose the matrix\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2100700,
                "title": "c-use-transpose-property-simple-approach-daily-leetcoding-challenge-june-day-2",
                "content": "**Please upvote if it helps :)**\\n*TC: O(mxn), SC: O(mxn)*\\n\\n**Code:**\\n```\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) \\n    {\\n        //create new matrix of rows = columns of given matrix\\n        //and columns = rows of given matrix\\n        int c=matrix.size(), r=matrix[0].size();\\n        vector<vector<int>> trans(r, vector<int> (c, 0));\\n        \\n        //iterate over the matrix and put i, j index value of the given matrix into j,i index of the trans matrix\\n        for(int i=0; i<matrix.size(); i++)\\n        {\\n            for(int j=0; j<matrix[0].size(); j++)\\n            {\\n               trans[j][i] = matrix[i][j];\\n            }\\n        }\\n        return trans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) \\n    {\\n        //create new matrix of rows = columns of given matrix\\n        //and columns = rows of given matrix\\n        int c=matrix.size(), r=matrix[0].size();\\n        vector<vector<int>> trans(r, vector<int> (c, 0));\\n        \\n        //iterate over the matrix and put i, j index value of the given matrix into j,i index of the trans matrix\\n        for(int i=0; i<matrix.size(); i++)\\n        {\\n            for(int j=0; j<matrix[0].size(); j++)\\n            {\\n               trans[j][i] = matrix[i][j];\\n            }\\n        }\\n        return trans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100662,
                "title": "typescript-javascript-simple-array-from-one-liner-solution-faster-than-100",
                "content": "```typescript\\nfunction transpose(matrix: number[][]): number[][] {\\n  return Array.from({length: matrix[0].length}, (_, r) => \\n    Array.from({length: matrix.length}, (_, c) => matrix[c][r])\\n  );\\n};\\n```\\n\\nRuntime: 81 ms, faster than 100.00% of TypeScript online submissions for Transpose Matrix.\\nMemory Usage: 45.3 MB, less than 77.27% of TypeScript online submissions for Transpose Matrix.\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction transpose(matrix: number[][]): number[][] {\\n  return Array.from({length: matrix[0].length}, (_, r) => \\n    Array.from({length: matrix.length}, (_, c) => matrix[c][r])\\n  );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2100459,
                "title": "c-easiest-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        vector<vector<int>> res(matrix[0].size(), vector<int>(matrix.size())); //to transverse we hv to take col  & row.\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                res[j][i]=matrix[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        vector<vector<int>> res(matrix[0].size(), vector<int>(matrix.size())); //to transverse we hv to take col  & row.\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                res[j][i]=matrix[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100235,
                "title": "kotlin-simple-1-line",
                "content": "```kotlin\\nclass Solution {\\n    fun transpose(matrix: Array<IntArray>): Array<IntArray> = \\n        Array(matrix[0].size) { x -> IntArray(matrix.size) { y -> matrix[y][x] } }       \\n}\\n```\\n\\nArray constructors in Kotlin accept an init function that includes an index as the input ([Array](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/-init-.html), [IntArray](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int-array/-init-.html#init)). Using these, we can complete the whole transposed array population in these init functions by indexing the original array with the opposite axis index.",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nclass Solution {\\n    fun transpose(matrix: Array<IntArray>): Array<IntArray> = \\n        Array(matrix[0].size) { x -> IntArray(matrix.size) { y -> matrix[y][x] } }       \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100205,
                "title": "python-solution",
                "content": "**Time Complexity - O(n^2)**\\n\\n```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        transpose_matrix = []\\n        for j in range(0, len(matrix[0])):\\n            row = []\\n            for i in range(0, len(matrix)):\\n                row.append(matrix[i][j])\\n            transpose_matrix.append(row)\\n        return transpose_matrix\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        transpose_matrix = []\\n        for j in range(0, len(matrix[0])):\\n            row = []\\n            for i in range(0, len(matrix)):\\n                row.append(matrix[i][j])\\n            transpose_matrix.append(row)\\n        return transpose_matrix\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100162,
                "title": "java-kotlin-0ms-faster-than-100-00-simple-solution",
                "content": "Flip row and colum indices to get a new matrix\\n\\n**JAVA - 0ms faster than 100.00%**\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] result = new int[matrix[0].length][];\\n        for (int i = 0; i < matrix[0].length; i++) {\\n            int[] newArr = new int[matrix.length];\\n            for (int j = 0; j < matrix.length; j++) newArr[j] = matrix[j][i];\\n            result[i] = newArr;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n\\n**In case you\\'re using Kotlin**\\n**446ms, faster than 28.57%**\\n\\n```\\nclass Solution {\\n    fun transpose(matrix: Array<IntArray>): Array<IntArray> {\\n        val newMatrix = mutableListOf<IntArray>()\\n        for (i in matrix[0].indices) {\\n            val new = mutableListOf<Int>()\\n            for (j in matrix.indices) new.add(matrix[j][i])\\n            newMatrix.add(new.toIntArray())\\n        }\\n        \\n        return newMatrix.toTypedArray()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] result = new int[matrix[0].length][];\\n        for (int i = 0; i < matrix[0].length; i++) {\\n            int[] newArr = new int[matrix.length];\\n            for (int j = 0; j < matrix.length; j++) newArr[j] = matrix[j][i];\\n            result[i] = newArr;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun transpose(matrix: Array<IntArray>): Array<IntArray> {\\n        val newMatrix = mutableListOf<IntArray>()\\n        for (i in matrix[0].indices) {\\n            val new = mutableListOf<Int>()\\n            for (j in matrix.indices) new.add(matrix[j][i])\\n            newMatrix.add(new.toIntArray())\\n        }\\n        \\n        return newMatrix.toTypedArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778433,
                "title": "javascript-60-ms-100-00",
                "content": "```\\nvar transpose = function(matrix) {\\n    const result = []\\n    for (let i = 0; i < matrix.length; i++) {\\n        for (let j = 0; j < matrix[0].length; j++) {\\n            if (!result[j]) result[j] = [];\\n            result[j].push(matrix[i][j])\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar transpose = function(matrix) {\\n    const result = []\\n    for (let i = 0; i < matrix.length; i++) {\\n        for (let j = 0; j < matrix[0].length; j++) {\\n            if (!result[j]) result[j] = [];\\n            result[j].push(matrix[i][j])\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1733042,
                "title": "clean-easy-c-transpose-of-a-matrix",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        vector<vector<int>>ans(m,vector<int>(n));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans[j][i] = matrix[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\npls feel free to ask your doubts :)\\nand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1573557,
                "title": "with-rust-fast-100",
                "content": "```\\nimpl Solution {\\n    pub fn transpose(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let mut m:Vec<Vec<i32>> = Vec::new();\\n        for (i,_) in matrix[0].iter().enumerate(){\\n            let mut n = Vec::new();\\n            for (j,_) in matrix.iter().enumerate(){\\n                n.insert(j, matrix[j][i]);\\n            }\\n            m.insert(i,n);\\n        }\\n        m\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn transpose(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let mut m:Vec<Vec<i32>> = Vec::new();\\n        for (i,_) in matrix[0].iter().enumerate(){\\n            let mut n = Vec::new();\\n            for (j,_) in matrix.iter().enumerate(){\\n                n.insert(j, matrix[j][i]);\\n            }\\n            m.insert(i,n);\\n        }\\n        m\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1456138,
                "title": "c-simple-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int x = matrix.size();\\n        int y = matrix[0].size();\\n        vector<vector<int>> v(y, vector<int>(x,0));\\n        for(int i=0;i<x;i++){\\n            for(int j=0;j<y;j++){\\n                v[j][i]=matrix[i][j];\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n**Do upvote and ask your doubts in comment!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int x = matrix.size();\\n        int y = matrix[0].size();\\n        vector<vector<int>> v(y, vector<int>(x,0));\\n        for(int i=0;i<x;i++){\\n            for(int j=0;j<y;j++){\\n                v[j][i]=matrix[i][j];\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367326,
                "title": "c-simple-4-liner-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& m) \\n    {\\n        vector<vector<int>> res(m[0].size(), vector<int>(m.size(), -1));\\n        for (int i = 0; i < m.size(); i++)\\n            for (int j = 0; j < m[0].size(); j++)\\n                res[j][i] = m[i][j];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& m) \\n    {\\n        vector<vector<int>> res(m[0].size(), vector<int>(m.size(), -1));\\n        for (int i = 0; i < m.size(); i++)\\n            for (int j = 0; j < m[0].size(); j++)\\n                res[j][i] = m[i][j];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269685,
                "title": "c-solution",
                "content": "```\\nvector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n       vector<vector<int>> result  (m , vector<int> (n, 0));\\n\\t   \\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                result[j][i]=matrix[i][j];\\n        \\n            return result;\\n\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n       vector<vector<int>> result  (m , vector<int> (n, 0));\\n\\t   \\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                result[j][i]=matrix[i][j];\\n        \\n            return result;\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1156092,
                "title": "js-easy-to-understand-3-approaches",
                "content": "```\\nvar transpose = function(arr) {\\n\\n// If same number of rows and cols(no extra array needed)\\n    // for(let i=0;i<arr.length-1;i++){\\n    //     for(let j=i;j<arr[i].length;j++){\\n              // es6 swap using array destructuring  \\n    //         [arr[i][j],arr[j][i]] = [arr[j][i],arr[i][j]]    \\n    \\n    //     }\\n    // }\\n    // return arr;\\n    \\n// If different number of rows and cols\\n    let transposedMat=[];\\n    \\n    for(let i=0;i<arr[0].length;i++){\\n        const temp=[]\\n        for(let j=0;j<arr.length;j++){\\n            temp.push(arr[j][i])\\n        }\\n        transposedMat.push(temp);\\n    }\\n    return transposedMat;\\n};\\n\\n// Another approach for different number of rows and cols\\nvar transpose = function(matrix) {\\n\\n    // creating result array with row length===matrix\\'s col length and col length===matrix\\'s row length\\n    const res=Array.from({length:matrix[0].length}).map(()=>new Array(matrix.length).fill())\\n    \\n    for(let i=0;i<matrix.length;i++){\\n        for(let j=0;j<matrix[i].length;j++){\\n            res[j][i]=matrix[i][j]\\n        }\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar transpose = function(arr) {\\n\\n// If same number of rows and cols(no extra array needed)\\n    // for(let i=0;i<arr.length-1;i++){\\n    //     for(let j=i;j<arr[i].length;j++){\\n              // es6 swap using array destructuring  \\n    //         [arr[i][j],arr[j][i]] = [arr[j][i],arr[i][j]]    \\n    \\n    //     }\\n    // }\\n    // return arr;\\n    \\n// If different number of rows and cols\\n    let transposedMat=[];\\n    \\n    for(let i=0;i<arr[0].length;i++){\\n        const temp=[]\\n        for(let j=0;j<arr.length;j++){\\n            temp.push(arr[j][i])\\n        }\\n        transposedMat.push(temp);\\n    }\\n    return transposedMat;\\n};\\n\\n// Another approach for different number of rows and cols\\nvar transpose = function(matrix) {\\n\\n    // creating result array with row length===matrix\\'s col length and col length===matrix\\'s row length\\n    const res=Array.from({length:matrix[0].length}).map(()=>new Array(matrix.length).fill())\\n    \\n    for(let i=0;i<matrix.length;i++){\\n        for(let j=0;j<matrix[i].length;j++){\\n            res[j][i]=matrix[i][j]\\n        }\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 982178,
                "title": "python-5-lines-o-r-c",
                "content": "```\\n    def transpose(self, A: List[List[int]]) -> List[List[int]]:\\n        res = [[0]*len(A) for row in range(len(A[0]))]\\n        for row in range(len(A)):\\n            for col in range(len(A[0])):\\n                res[col][row] = A[row][col]\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def transpose(self, A: List[List[int]]) -> List[List[int]]:\\n        res = [[0]*len(A) for row in range(len(A[0]))]\\n        for row in range(len(A)):\\n            for col in range(len(A[0])):\\n                res[col][row] = A[row][col]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 519994,
                "title": "elementary-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        public int[][] Transpose(int[][] matrix)\\n        {\\n            int n = matrix.Length;\\n            int m = matrix[0].Length;\\n\\n            int[][] res = new int[m][];\\n\\n            for (int i = 0; i < m; i++)\\n            {\\n                res[i] = new int[n];\\n                for (int j = 0; j < n; j++)\\n                {\\n                    res[i][j] = matrix[j][i];\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        public int[][] Transpose(int[][] matrix)\\n        {\\n            int n = matrix.Length;\\n            int m = matrix[0].Length;\\n\\n            int[][] res = new int[m][];\\n\\n            for (int i = 0; i < m; i++)\\n            {\\n                res[i] = new int[n];\\n                for (int j = 0; j < n; j++)\\n                {\\n                    res[i][j] = matrix[j][i];\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 170799,
                "title": "1-line-solution-in-python-and-scala",
                "content": "**Simple Two Steps**\\n1. Iterate over columns.\\n2. Iterate over rows.\\n\\nOne line solution in python:\\n```\\n    def transpose(self, A):\\n        \"\"\"\\n        :type A: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        return [[row[col] for row in A] for col in range(len(A[0]))]\\n```\\nAnd in scala:\\n```\\n  def transpose(A: Array[Array[Int]]): Array[Array[Int]] = {\\n    A(0).indices.map(col => A.map(row => row(col))).toArray\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n    def transpose(self, A):\\n        \"\"\"\\n        :type A: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        return [[row[col] for row in A] for col in range(len(A[0]))]\\n```\n```\\n  def transpose(A: Array[Array[Int]]): Array[Array[Int]] = {\\n    A(0).indices.map(col => A.map(row => row(col))).toArray\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 149164,
                "title": "a-easy-to-understand-javascript-solution",
                "content": "```\\nvar transpose = function(A) {\\n    var temp = []\\n    var res = []\\n    for(var a = 0;a < A[0].length;a++){\\n      temp = []\\n      for(var b = 0;b < A.length;b++){\\n        temp.push(A[b][a])\\n      }\\n         res.push(temp)\\n    }\\n  return res\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar transpose = function(A) {\\n    var temp = []\\n    var res = []\\n    for(var a = 0;a < A[0].length;a++){\\n      temp = []\\n      for(var b = 0;b < A.length;b++){\\n        temp.push(A[b][a])\\n      }\\n         res.push(temp)\\n    }\\n  return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 147022,
                "title": "first-c-solution-12ms",
                "content": "Note: the  columnSizes is a purely a pointer to pointer as an input parameter, don\\'t reckon it as the name of a pointer array.\\n```\\nint** transpose(int** A, int ARowSize, int *AColSizes, int** columnSizes, int* returnSize) {\\n    int **B = (int **)malloc(sizeof(int *) * (*AColSizes));\\n    for(int i = 0 ; i < *AColSizes; i++) *(B + i) = (int *)malloc(sizeof(int) * ARowSize);\\n    *columnSizes = (int *)malloc(sizeof(int) * (*AColSizes));\\n    for(int i = 0 ; i < *AColSizes; i++) *(*columnSizes + i) = ARowSize;\\n    for(int ColIdx = 0; ColIdx < *AColSizes; ColIdx++){\\n        for(int RowIdx = 0; RowIdx < ARowSize; RowIdx++){\\n            *(*(B + ColIdx) + RowIdx) = *(*(A + RowIdx) + ColIdx);\\n        }\\n    }\\n    *returnSize = *AColSizes;\\n    return B;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint** transpose(int** A, int ARowSize, int *AColSizes, int** columnSizes, int* returnSize) {\\n    int **B = (int **)malloc(sizeof(int *) * (*AColSizes));\\n    for(int i = 0 ; i < *AColSizes; i++) *(B + i) = (int *)malloc(sizeof(int) * ARowSize);\\n    *columnSizes = (int *)malloc(sizeof(int) * (*AColSizes));\\n    for(int i = 0 ; i < *AColSizes; i++) *(*columnSizes + i) = ARowSize;\\n    for(int ColIdx = 0; ColIdx < *AColSizes; ColIdx++){\\n        for(int RowIdx = 0; RowIdx < ARowSize; RowIdx++){\\n            *(*(B + ColIdx) + RowIdx) = *(*(A + RowIdx) + ColIdx);\\n        }\\n    }\\n    *returnSize = *AColSizes;\\n    return B;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 146796,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& A) {\\n        int row = A.size();\\n        int col = A[0].size();\\n        vector<vector<int>> B(col, vector<int>(row));\\n        for(int i = 0 ; i < row ; i++){\\n            for(int j = 0 ; j < col ; j++){\\n                B[j][i] = A[i][j];\\n            }\\n        }\\n        return B;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& A) {\\n        int row = A.size();\\n        int col = A[0].size();\\n        vector<vector<int>> B(col, vector<int>(row));\\n        for(int i = 0 ; i < row ; i++){\\n            for(int j = 0 ; j < col ; j++){\\n                B[j][i] = A[i][j];\\n            }\\n        }\\n        return B;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052438,
                "title": "rows-columns-columns-rows",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n*Matrix transposition is like rotating a grid of numbers by 90 degrees. ```Rows become columns, and columns become rows.```*\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1: Determine Dimensions\\n```\\n// Determine the dimensions of the original matrix\\nint rows = originalMatrix.length;\\nint cols = originalMatrix[0].length;\\n```\\nStep 2: Create a New Matrix\\n\\n```\\n// Create a new matrix with swapped dimensions\\nint[][] transposedMatrix = new int[cols][rows];\\n```\\nStep 3: Iterate Through the Original Matrix\\n\\nStep 4: Swap Elements\\n\\n```\\n// Swap elements to transpose the matrix\\ntransposedMatrix[j][i] = originalMatrix[i][j];\\n```\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] originalMatrix) {\\n        int rows = originalMatrix.length;\\n        int cols = originalMatrix[0].length;\\n        // Original matrix is MxN but the transposed matrix will be NxM \\n        int[][] transposedMatrix = new int[cols][rows];\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                transposedMatrix[j][i] = originalMatrix[i][j];\\n            }\\n        }\\n        \\n        return transposedMatrix;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Rows become columns, and columns become rows.```\n```\\n// Determine the dimensions of the original matrix\\nint rows = originalMatrix.length;\\nint cols = originalMatrix[0].length;\\n```\n```\\n// Create a new matrix with swapped dimensions\\nint[][] transposedMatrix = new int[cols][rows];\\n```\n```\\n// Swap elements to transpose the matrix\\ntransposedMatrix[j][i] = originalMatrix[i][j];\\n```\n```\\nclass Solution {\\n    public int[][] transpose(int[][] originalMatrix) {\\n        int rows = originalMatrix.length;\\n        int cols = originalMatrix[0].length;\\n        // Original matrix is MxN but the transposed matrix will be NxM \\n        int[][] transposedMatrix = new int[cols][rows];\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                transposedMatrix[j][i] = originalMatrix[i][j];\\n            }\\n        }\\n        \\n        return transposedMatrix;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044680,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] arr) {\\n        int n = arr.length;\\n        int m = arr[0].length;\\n\\n        int ans[][] = new int[m][n];\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                ans[j][i] = arr[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] arr) {\\n        int n = arr.length;\\n        int m = arr[0].length;\\n\\n        int ans[][] = new int[m][n];\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                ans[j][i] = arr[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677097,
                "title": "easy-basic-cpp-solution-with-explanation-of-approach",
                "content": "# Intuition\\nJust convert rows to columns.\\n\\n# Approach\\n- Make a new vector with size cols,vector<int>(rows).\\n- Now just travese row wise and assign values in vector column wise.\\n\\n# Complexity\\n- Time complexity:\\n  O(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        vector<vector<int>> v(matrix[0].size(), vector<int>(matrix.size()));\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                v[j][i]=matrix[i][j];\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n# Please upvote if you find it useful!!",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        vector<vector<int>> v(matrix[0].size(), vector<int>(matrix.size()));\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                v[j][i]=matrix[i][j];\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530882,
                "title": "java-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] answer = new int[matrix[0].length][matrix.length];\\n        for(int i=0; i < matrix.length; i++){\\n            for (int j = 0; j < matrix[0].length; j++){\\n                answer[j][i] = matrix[i][j];\\n            } \\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] answer = new int[matrix[0].length][matrix.length];\\n        for(int i=0; i < matrix.length; i++){\\n            for (int j = 0; j < matrix[0].length; j++){\\n                answer[j][i] = matrix[i][j];\\n            } \\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509493,
                "title": "c-sort-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size(); \\n        vector<vector<int>> transposed(n, vector<int>(m));\\n    \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                transposed[j][i] = matrix[i][j];\\n            }\\n        }\\n        \\n        return transposed;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size(); \\n        vector<vector<int>> transposed(n, vector<int>(m));\\n    \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                transposed[j][i] = matrix[i][j];\\n            }\\n        }\\n        \\n        return transposed;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499366,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<vector<int>>ans(n, vector<int>(m));\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            ans[j][i]=matrix[i][j];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        result = [[matrix[i][j] for i in range(len(matrix))] for j in range(len(matrix[0]))]\\n        return result\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        int[][] res =new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                res[i][j]=matrix[j][i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<vector<int>>ans(n, vector<int>(m));\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            ans[j][i]=matrix[i][j];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        result = [[matrix[i][j] for i in range(len(matrix))] for j in range(len(matrix[0]))]\\n        return result\\n```\n```Java []\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        int[][] res =new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                res[i][j]=matrix[j][i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361688,
                "title": "easiest-c-solution-ever-bhai-please-upvote-kar-dena-yar",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        \\n    int n=matrix.size();\\n    int m=matrix[0].size();\\n    vector<vector<int>> ans;\\n    for (int i = 0; i < m; i++)\\n    {\\n        vector<int> v;\\n        for (int j = 0; j < n; j++)\\n        {\\n            v.push_back(matrix[j][i]);\\n        }\\n        ans.push_back(v);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        \\n    int n=matrix.size();\\n    int m=matrix[0].size();\\n    vector<vector<int>> ans;\\n    for (int i = 0; i < m; i++)\\n    {\\n        vector<int> v;\\n        for (int j = 0; j < n; j++)\\n        {\\n            v.push_back(matrix[j][i]);\\n        }\\n        ans.push_back(v);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361120,
                "title": "transpose-matrix-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int i, j, temp;\\n        vector<vector<int>> ans;\\n        vector<int> arr;\\n        for(i=0 ; i<matrix[0].size() ; i++)\\n        {\\n            for(j=0 ; j<matrix.size() ; j++)\\n            {\\n               arr.push_back(matrix[j][i]);\\n            }\\n            ans.push_back(arr);\\n            arr.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int i, j, temp;\\n        vector<vector<int>> ans;\\n        vector<int> arr;\\n        for(i=0 ; i<matrix[0].size() ; i++)\\n        {\\n            for(j=0 ; j<matrix.size() ; j++)\\n            {\\n               arr.push_back(matrix[j][i]);\\n            }\\n            ans.push_back(arr);\\n            arr.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282230,
                "title": "867-java-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Runtime : 0 ms\\n- Beats : 100%\\n- Memory : 43.7 MB\\n- Beats : 16.83%\\n# Code\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] mat) {\\n        int arr[][]=new int[mat[0].length][mat.length] , col = 0;\\n        for(int i[] : mat){\\n            int row = 0;\\n            for(int j : i) arr[row++][col] = j;\\n            col++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] mat) {\\n        int arr[][]=new int[mat[0].length][mat.length] , col = 0;\\n        for(int i[] : mat){\\n            int row = 0;\\n            for(int j : i) arr[row++][col] = j;\\n            col++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098675,
                "title": "0ms-java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        int[][] res =new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                res[i][j]=matrix[j][i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        int[][] res =new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                res[i][j]=matrix[j][i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904218,
                "title": "java-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int ans[][] = new int[n][m];\\n        int i=0,j=0,k=0;\\n        while(k<n){\\n            ans[k][i] = matrix[i][j];\\n            i++;\\n            if(i==m){\\n                i -= m;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int ans[][] = new int[n][m];\\n        int i=0,j=0,k=0;\\n        while(k<n){\\n            ans[k][i] = matrix[i][j];\\n            i++;\\n            if(i==m){\\n                i -= m;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787764,
                "title": "simple-cpp-solution-96-02",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        vector<vector<int>> ans(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++)\\n                ans[i][j]=matrix[j][i];\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        vector<vector<int>> ans(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++)\\n                ans[i][j]=matrix[j][i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2787646,
                "title": "simple-java-solution-100",
                "content": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        \\n        int m = matrix.length;\\n        int n = matrix[0].length; //size\\n        \\n        int result[][] = new int[n][m];\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0;j<n; j++){\\n                  result[j][i] = matrix[i][j];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        \\n        int m = matrix.length;\\n        int n = matrix[0].length; //size\\n        \\n        int result[][] = new int[n][m];\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0;j<n; j++){\\n                  result[j][i] = matrix[i][j];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659964,
                "title": "python-solution-single-line",
                "content": "```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        return [[matrix[i][j] for i in range(len(matrix))] for j in range(len(matrix[0]))]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        return [[matrix[i][j] for i in range(len(matrix))] for j in range(len(matrix[0]))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659951,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        m=[]\\n        for i in range(len(matrix[0])):\\n            n=[]\\n            for j in range(len(matrix)):\\n                n.append(matrix[j][i])\\n            m.append(n)\\n        return m\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        m=[]\\n        for i in range(len(matrix[0])):\\n            n=[]\\n            for j in range(len(matrix)):\\n                n.append(matrix[j][i])\\n            m.append(n)\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536153,
                "title": "java-simple-and-easy-solution",
                "content": "class Solution {\\n\\n    public int[][] transpose(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[][] ans = new int[n][m];\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                ans[j][i] = matrix[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "class Solution {\\n\\n    public int[][] transpose(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[][] ans = new int[n][m];\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                ans[j][i] = matrix[i][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2428973,
                "title": "transpose-of-a-matrix-short-code-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        \\n        vector<vector<int>> final;      //initializing 2d vector\\n        for(int c=0;c<matrix[0].size();c++)  //taking columns first\\n        {\\n            vector<int> ans;\\n            for(int r=0;r<matrix.size();r++)  //taking rows\\n                ans.push_back(matrix[r][c]);  // changing the values of colums into rows\\n            \\n            final.push_back(ans);\\n        }\\n        return final;       \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        \\n        vector<vector<int>> final;      //initializing 2d vector\\n        for(int c=0;c<matrix[0].size();c++)  //taking columns first\\n        {\\n            vector<int> ans;\\n            for(int r=0;r<matrix.size();r++)  //taking rows\\n                ans.push_back(matrix[r][c]);  // changing the values of colums into rows\\n            \\n            final.push_back(ans);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2103218,
                "title": "python-3-one-liner-with-explanation-link",
                "content": "```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        return zip(*matrix[::])\\n    #always gives the transpose of a matrix\\n```\\n  The stackoverflow link on why adding a zip* with works : \\n\\nhttps://stackoverflow.com/questions/29139350/difference-between-ziplist-and-ziplist/29139418\\n**Upvote if you like :)**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        return zip(*matrix[::])\\n    #always gives the transpose of a matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102714,
                "title": "python-one-liner-using-zip",
                "content": "\\n```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        return zip(*matrix)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        return zip(*matrix)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102429,
                "title": "java-beats-100",
                "content": "```\\n\\n\\n\\n\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] ans = new int[matrix[0].length][matrix.length];\\n        int m = 0;        //  for filling rows of ans matrix\\n        int n = 0;         // for filling columns of ans matrix\\n        for(int i=0;i<matrix[0].length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                ans[m][n] = matrix[j][i];             //  column-wise iterating through matrix (given) array\\n            \\n                n++;\\n            }\\n            m++;                          // normal looping in \\'ans\\' array ( since m = row.. therefore increasing row )  and setting  n ( column) = 0 for next iteration in \\'ans\\' array\\n            n = 0;\\n        }\\n        return ans;\\n    }\\n    \\n} \\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\n\\n\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] ans = new int[matrix[0].length][matrix.length];\\n        int m = 0;        //  for filling rows of ans matrix\\n        int n = 0;         // for filling columns of ans matrix\\n        for(int i=0;i<matrix[0].length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                ans[m][n] = matrix[j][i];             //  column-wise iterating through matrix (given) array\\n            \\n                n++;\\n            }\\n            m++;                          // normal looping in \\'ans\\' array ( since m = row.. therefore increasing row )  and setting  n ( column) = 0 for next iteration in \\'ans\\' array\\n            n = 0;\\n        }\\n        return ans;\\n    }\\n    \\n} \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102234,
                "title": "c-simple-code-transpose-matrix",
                "content": "\\n    vector<vector<int>> transpose(vector<vector<int>>& mx) {\\n        \\n        int n=mx.size();\\n        int m=mx[0].size();\\n        \\n        vector<vector<int>>v(m,vector<int>(n));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                v[j][i]=mx[i][j];\\n            }\\n        }\\n        \\n        return v;\\n    }\\n\\n//Up-vote if you Like\\n// ThankYou",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\n    vector<vector<int>> transpose(vector<vector<int>>& mx) {\\n        \\n        int n=mx.size();\\n        int m=mx[0].size();\\n        \\n        vector<vector<int>>v(m,vector<int>(n));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                v[j][i]=mx[i][j];\\n            }\\n        }\\n        \\n        return v;\\n    }\\n\\n//Up-vote if you Like\\n// ThankYou",
                "codeTag": "Unknown"
            },
            {
                "id": 2102202,
                "title": "0ms-faster-then-100-of-java-solution-easy-explanation",
                "content": "Transpose of a matrix A is B such that\\nA(i,j) = B(j,i)\\n\\nif A a have n row and m columns then B will have m rows and n columns.\\n\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int output[][] = new int[matrix[0].length][matrix.length];\\n        \\n        for(int i=0;i<matrix.length;i++) {\\n            for(int j=0;j<matrix[0].length;j++) {\\n                output[j][i] = matrix[i][j];\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```\\nT(n) = O(m*n)\\nS(n) =O(m*n)\\n\\nRuntime: 0 ms, faster than 100% of Java online submissions for Transpose Matrix.\\nMemory Usage: 48.6 MB, less than 90.25% of Java online submissions for Transpose Matrix.\\n\\n\\nCheer~~~~~",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int output[][] = new int[matrix[0].length][matrix.length];\\n        \\n        for(int i=0;i<matrix.length;i++) {\\n            for(int j=0;j<matrix[0].length;j++) {\\n                output[j][i] = matrix[i][j];\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101870,
                "title": "transpose-matrix-java",
                "content": "```\\nint m = matrix.length, n = matrix[0].length;\\n        int[][] ans = new int[n][m];//Making an empty matrix that can be used as the transpose of the matrix\\n        //The number of columns in this matrix will be equal to number of rows of the original matrix and vice-versa.\\n        for (int j = 0; j < n; j++)\\n            //Now traversing the row of the new matrix\\n            for (int i = 0; i < m; i++)\\n                //And picking the element-position in the matrix \\n                ans[j][i] = matrix[i][j];//Transpose of matrix \\n        return ans;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint m = matrix.length, n = matrix[0].length;\\n        int[][] ans = new int[n][m];//Making an empty matrix that can be used as the transpose of the matrix\\n        //The number of columns in this matrix will be equal to number of rows of the original matrix and vice-versa.\\n        for (int j = 0; j < n; j++)\\n            //Now traversing the row of the new matrix\\n            for (int i = 0; i < m; i++)\\n                //And picking the element-position in the matrix \\n                ans[j][i] = matrix[i][j];//Transpose of matrix \\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 2101600,
                "title": "c-easiest-with-o-m-n-easy-to-understand",
                "content": "* class Solution {\\n* public:\\n*     vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n             int a = matrix.size();\\n             int b = matrix[0].size(); \\n             vector<vector<int>> ans(b, vector<int>(a)); // ans is the transpose of matrix \\n             for(int i=0; i<a; i++){ \\n                 for(int j=0; j<b; j++){ \\n                     ans[j][i] = matrix[i][j]; \\n                 }\\n             }\\n             return ans;\\n*     }\\n* };",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\n* public:\\n*     vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n             int a = matrix.size();\\n             int b = matrix[0].size(); \\n             vector<vector<int>> ans(b, vector<int>(a)); // ans is the transpose of matrix \\n             for(int i=0; i<a; i++){ \\n                 for(int j=0; j<b; j++){ \\n                     ans[j][i] = matrix[i][j]; \\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 2101483,
                "title": "c-solution-with-explanation",
                "content": "```\\n```\\n```\\n public int[][] Transpose(int[][] matrix) {\\n        \\n        int rows = matrix.Length;\\n        int cols = matrix[0].Length;\\n        \\n        int[][] transposed = new int[cols][];  //jagged array, array of array\\n        \\n        \\n        \\n        //initialize new Array\\n        for(int i=0; i<cols; i++)\\n        {\\n            transposed[i]=new int[rows];    // jagged arrays needs to be initialized in c#\\n        }\\n        \\n        \\n        //transposing\\n        for(int row=0; row<matrix.Length; row++)\\n        {            \\n            for(int col=0; col<matrix[row].Length; col++)\\n            {                \\n                int ele = matrix[row][col];                \\n                transposed[col][row] = matrix[row][col];  \\n            }\\n        }\\n        \\n        \\n        return transposed;\\n    }\\n```\\n```\\n```",
                "solutionTags": [],
                "code": "```\\n```\n```\\n public int[][] Transpose(int[][] matrix) {\\n        \\n        int rows = matrix.Length;\\n        int cols = matrix[0].Length;\\n        \\n        int[][] transposed = new int[cols][];  //jagged array, array of array\\n        \\n        \\n        \\n        //initialize new Array\\n        for(int i=0; i<cols; i++)\\n        {\\n            transposed[i]=new int[rows];    // jagged arrays needs to be initialized in c#\\n        }\\n        \\n        \\n        //transposing\\n        for(int row=0; row<matrix.Length; row++)\\n        {            \\n            for(int col=0; col<matrix[row].Length; col++)\\n            {                \\n                int ele = matrix[row][col];                \\n                transposed[col][row] = matrix[row][col];  \\n            }\\n        }\\n        \\n        \\n        return transposed;\\n    }\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2100860,
                "title": "easy-c-sol-time-o-m-n-aux-space-o-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) { // Time: O(m*n) :: Aux_Space  : O(m*n) \\n        \\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        vector<vector<int>> res(m,vector<int>(n));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                res[j][i] = matrix[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) { // Time: O(m*n) :: Aux_Space  : O(m*n) \\n        \\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        vector<vector<int>> res(m,vector<int>(n));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                res[j][i] = matrix[i][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2100811,
                "title": "so-it-all-starts-with-easy-qyestion",
                "content": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int ans[][]=new int[matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                ans[j][i]=matrix[i][j];\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int ans[][]=new int[matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                ans[j][i]=matrix[i][j];\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100719,
                "title": "100-0ms-easy-to-understand-meme",
                "content": "**UPVOTE PLEASE**\\n```\\nC++:\\n\\n    vector<vector<int>> transpose(vector<vector<int>> A) {\\n        int M = A.size(), N = A[0].size();\\n        vector<vector<int>> B(N, vector<int>(M, 0));\\n        for (int j = 0; j < N; j++)\\n            for (int i = 0; i < M; i++)\\n                B[j][i] = A[i][j];\\n        return B;\\n    }\\nJava:\\n\\n    public int[][] transpose(int[][] A) {\\n        int M = A.length, N = A[0].length;\\n        int[][] B = new int[N][M];\\n        for (int j = 0; j < N; j++)\\n            for (int i = 0; i < M; i++)\\n                B[j][i] = A[i][j];\\n        return B;\\n    }\\nPython:\\n\\n    def tranpose(self, M):\\n        return zip(*M)\\n```\\n![image](https://assets.leetcode.com/users/images/f4b462cb-b778-4d26-a271-b288e23871d9_1654144775.2911303.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nC++:\\n\\n    vector<vector<int>> transpose(vector<vector<int>> A) {\\n        int M = A.size(), N = A[0].size();\\n        vector<vector<int>> B(N, vector<int>(M, 0));\\n        for (int j = 0; j < N; j++)\\n            for (int i = 0; i < M; i++)\\n                B[j][i] = A[i][j];\\n        return B;\\n    }\\nJava:\\n\\n    public int[][] transpose(int[][] A) {\\n        int M = A.length, N = A[0].length;\\n        int[][] B = new int[N][M];\\n        for (int j = 0; j < N; j++)\\n            for (int i = 0; i < M; i++)\\n                B[j][i] = A[i][j];\\n        return B;\\n    }\\nPython:\\n\\n    def tranpose(self, M):\\n        return zip(*M)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2100625,
                "title": "52-16-faster-to-100-faster-simple-code-explanation-2-methods",
                "content": "So, the first thing is, we should probably ignore the metrics. It\\'s not always correct. And in this case we just have to re-submit again and again till it gets submitted in a time interval when leetcode system is not overloaded.\\n\\n**Although in this case, it\\'s the variable name length.**\\n\\nLook at this 100% solution:\\n![image](https://assets.leetcode.com/users/images/3d14b9af-2efa-4a48-bb6f-fb67b8fd43cd_1654142251.6377287.jpeg)\\n\\nLook at 52.16% one: \\n![image](https://assets.leetcode.com/users/images/2083a5f0-7943-4895-86b0-6647a70ffd0d_1654142270.584384.jpeg)\\n\\nmatrixT is a longer variable name compared to ans. It\\u2019s a tradeoff between having a readable code and saving a small fraction of time.\\n\\nLet\\'s try making the same matrixT as X and see:\\n![image](https://assets.leetcode.com/users/images/f31f1222-1819-4b9e-a22f-e9b75c2791f7_1654142798.5085976.png)\\n\\n**Ignoring all these factors, coming to the code if it\\'s unclear:**\\nWhat\\'s a transpose?\\n![image](https://assets.leetcode.com/users/images/24583cce-5b43-4fbf-a48f-2d6df52f7c26_1654142395.7688913.png)\\nSo, basically we are exchanging the values. Note, we can\\'t do inplace as we require the values of the matrix in the future. Hence the SC will always remain O(R*C)\\n\\nNow, as for the code:\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int m=matrix[0].length;\\n        int n=matrix.length;\\n        int matrixT[][] = new int[m][n];\\n        for (int i=0; i<m;i++)\\n        {\\n            for (int j=0; j<n;j++)\\n            {\\n                matrixT[i][j]=matrix[j][i];\\n            }\\n        }\\n        return matrixT;\\n    }\\n}\\n```\\n\\n**Convert matrixT to X if you want 100%** \\n\\nAlso one more unqiue method which also has same TC O(NM) but uses only one for loop.\\n\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        \\n        int[][] res = new int[n][m];\\n        \\n        for(int i = 0; i < m*n; ++i) {\\n            res[i%n][i/n] = matrix[i/n][i%n];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int m=matrix[0].length;\\n        int n=matrix.length;\\n        int matrixT[][] = new int[m][n];\\n        for (int i=0; i<m;i++)\\n        {\\n            for (int j=0; j<n;j++)\\n            {\\n                matrixT[i][j]=matrix[j][i];\\n            }\\n        }\\n        return matrixT;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        \\n        int[][] res = new int[n][m];\\n        \\n        for(int i = 0; i < m*n; ++i) {\\n            res[i%n][i/n] = matrix[i/n][i%n];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100602,
                "title": "c-easy-solved",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        vector<vector<int>> ans;\\n        int row=matrix.size();//computing size of row\\n        int col=matrix[0].size();//computing size of col\\n        //since transpose is interchange of col and row we interchange row and col place in for loop below\\n        for(int i=0;i<col;i++){\\n            vector<int> temp;\\n            for(int j=0;j<row;j++){\\n                temp.push_back(matrix[j][i]);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n```\\n};",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        vector<vector<int>> ans;\\n        int row=matrix.size();//computing size of row\\n        int col=matrix[0].size();//computing size of col\\n        //since transpose is interchange of col and row we interchange row and col place in for loop below\\n        for(int i=0;i<col;i++){\\n            vector<int> temp;\\n            for(int j=0;j<row;j++){\\n                temp.push_back(matrix[j][i]);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100341,
                "title": "c-easy-to-understand",
                "content": "**TC : O(mn)\\nSC : O(mn)** \\nwhere m and n are matrix dimensions\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<vector<int>> res(n, vector<int> (m));\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                res[j][i] = matrix[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<vector<int>> res(n, vector<int> (m));\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                res[j][i] = matrix[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100173,
                "title": "java-js-simple-fast-explained",
                "content": "\\n1. loop through the columns\\n2. loop through the rows\\n3. put the number in result\\n\\n##### Java Solution || 0ms || Faster Than 100% :\\n```\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] result = new int[matrix[0].length][matrix.length];\\n        for (int col = 0; col < matrix[0].length; col++) {\\n            for (int row = 0; row < matrix.length; row++) {\\n                result[col][row] = matrix[row][col];\\n            }\\n        }\\n        return result;\\n    }\\n```\\n\\n##### JavaScript Solution || 77ms || Faster Than 92.31% : \\n```\\nvar transpose = function(matrix) {\\n    let result = []\\n    for (let col = 0; col < matrix[0].length; col++) {\\n        let list = []\\n        for (element of matrix) list.push(element[col])\\n        result.push(list)\\n    } \\n    return result\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] result = new int[matrix[0].length][matrix.length];\\n        for (int col = 0; col < matrix[0].length; col++) {\\n            for (int row = 0; row < matrix.length; row++) {\\n                result[col][row] = matrix[row][col];\\n            }\\n        }\\n        return result;\\n    }\\n```\n```\\nvar transpose = function(matrix) {\\n    let result = []\\n    for (let col = 0; col < matrix[0].length; col++) {\\n        let list = []\\n        for (element of matrix) list.push(element[col])\\n        result.push(list)\\n    } \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2100156,
                "title": "elixir-approach-and-solution-comprehensions-anonymous-functions-and-enum",
                "content": "Elixir adds a new wrinkle to this problem given variables in Elixir are immutable. What may be a trivial problem with mutable variables needs a bit more effort to tackle in an immutable world. \\n# Approach\\n1. Flatten `matrix` into a single list and capture it into an anonymous function. \\n2. Use a comprehension to count off each new row based on the length of the first row (the count of columns), assigned as `n`.  \\n3. As we step down the rows in the comprehension, drop the first elements of the flattened `matrix` equivalent to the number of rows already stepped through, counted by `i`, using `Enum.drop/2`. \\n4. Use `Enum.take_every/2` to grab the proper values based upon the length of each row, starting with the first item (now exposed by the `Enum.drop/2` function). \\n\\n# Solution\\nRuntime of 393 ms, and memory usage of 50.9 MB. \\n```\\ndefmodule Solution do\\n  @spec transpose(matrix :: [[integer]]) :: [[integer]]\\n  def transpose(matrix = [row | _]) do\\n    n = length(row)\\n\\n    matrix\\n    |> List.flatten()\\n    |> (&(for i <- 1..n, do: Enum.take_every(Enum.drop(&1, i - 1), n))).()\\n  end\\nend\\n```\\n\\n# Testcases\\n```\\n[[1,2,3],[4,5,6],[7,8,9]]\\n[[1,2,3],[4,5,6]]\\n[[1,2],[4,5]]\\n[[1,2],[4,5],[7,8]]\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec transpose(matrix :: [[integer]]) :: [[integer]]\\n  def transpose(matrix = [row | _]) do\\n    n = length(row)\\n\\n    matrix\\n    |> List.flatten()\\n    |> (&(for i <- 1..n, do: Enum.take_every(Enum.drop(&1, i - 1), n))).()\\n  end\\nend\\n```\n```\\n[[1,2,3],[4,5,6],[7,8,9]]\\n[[1,2,3],[4,5,6]]\\n[[1,2],[4,5]]\\n[[1,2],[4,5],[7,8]]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2088497,
                "title": "easy-fastest-java-solution-0ms",
                "content": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int[][] mat=new int[col][row];\\n        for(int i=0;i<col;i++)\\n            for(int j=0;j<row;j++)\\n                mat[i][j]=matrix[j][i];\\n        return mat;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int[][] mat=new int[col][row];\\n        for(int i=0;i<col;i++)\\n            for(int j=0;j<row;j++)\\n                mat[i][j]=matrix[j][i];\\n        return mat;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1992105,
                "title": "transpose-matrix-solution-java",
                "content": "class Solution {\\n  public int[][] transpose(int[][] A) {\\n    int[][] ans = new int[A[0].length][A.length];\\n\\n    for (int i = 0; i < A.length; ++i)\\n      for (int j = 0; j < A[0].length; ++j)\\n        ans[j][i] = A[i][j];\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "class Solution {\\n  public int[][] transpose(int[][] A) {\\n    int[][] ans = new int[A[0].length][A.length];\\n\\n    for (int i = 0; i < A.length; ++i)\\n      for (int j = 0; j < A[0].length; ++j)\\n        ans[j][i] = A[i][j];\\n\\n    return ans;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1770109,
                "title": "simple-java-solution-copy-row-data-to-column",
                "content": "row will be copied to column and column will be copied to row. \\nif original is op[n][m] then new matrix will be [m][n]\\n```\\npublic int[][] transpose(int[][] matrix) {\\n        int[][] op =new int[matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length;i++) {\\n            for(int j=0;j<matrix[0].length;j++) {\\n                op[j][i]=matrix[i][j];\\n            }\\n        }\\n        return op;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] transpose(int[][] matrix) {\\n        int[][] op =new int[matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length;i++) {\\n            for(int j=0;j<matrix[0].length;j++) {\\n                op[j][i]=matrix[i][j];\\n            }\\n        }\\n        return op;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1727899,
                "title": "easy-java-solution-faster-than-100-0ms",
                "content": "If u like it, pls upvote! :)\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int[][] a = new int[m][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                 a[j][i] = matrix[i][j];\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int[][] a = new int[m][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                 a[j][i] = matrix[i][j];\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693792,
                "title": "easy-java-solution-100-faster-with-comments",
                "content": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n//         this thing is for square matrix, bcz, shape of square matrix doesn\\'t change after transpose, \\n        int[][] ans;\\n         if(matrix.length==matrix[0].length){\\n             ans = new int[matrix.length][matrix[0].length]; \\n            for(int a = 0;a<matrix.length;a++){\\n                for(int i=0;i<matrix[0].length;i++){\\n                    ans[a][i] = matrix[i][a];\\n                }\\n            }\\n        }\\n//         now this one is for matrix of any shape, this is different bcz see here i first wrote matrix[0].length and than after than i wrote matrix.length, bcz after the transpose number of rows become the no. of rows and vice versa.\\n        else{\\n            ans = new int[matrix[0].length][matrix.length]; \\n            for(int a = 0;a<matrix.length;a++){\\n                for(int i=0;i<matrix[0].length;i++){\\n//   here be care full bcz for matrix \\'a\\' id the no of rows and \\'i\\' is the no of the columns but for ans it is vice versa.                  \\n                    ans[i][a] = matrix[a][i];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n//         this thing is for square matrix, bcz, shape of square matrix doesn\\'t change after transpose, \\n        int[][] ans;\\n         if(matrix.length==matrix[0].length){\\n             ans = new int[matrix.length][matrix[0].length]; \\n            for(int a = 0;a<matrix.length;a++){\\n                for(int i=0;i<matrix[0].length;i++){\\n                    ans[a][i] = matrix[i][a];\\n                }\\n            }\\n        }\\n//         now this one is for matrix of any shape, this is different bcz see here i first wrote matrix[0].length and than after than i wrote matrix.length, bcz after the transpose number of rows become the no. of rows and vice versa.\\n        else{\\n            ans = new int[matrix[0].length][matrix.length]; \\n            for(int a = 0;a<matrix.length;a++){\\n                for(int i=0;i<matrix[0].length;i++){\\n//   here be care full bcz for matrix \\'a\\' id the no of rows and \\'i\\' is the no of the columns but for ans it is vice versa.                  \\n                    ans[i][a] = matrix[a][i];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1608584,
                "title": "java-solution-with-explanation",
                "content": "```\\n*/ Number of Colmuns in original matrix = Number of Rows in transpose matrix\\nand number of rows in original matrix = number of columns in //transpose matrix\\nso we are creating resultant matrix with row length (matrix[0].length i.e column length of original matrix)\\nand column length as matrix.length (number of rows in original //matrix)\\n*/\\n\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n\\t\\n        int[][] transpose = new int[matrix[0].length][matrix.length];\\n        \\n        \\n        for(int i = 0 ; i < matrix.length ; i++)  \\n             for(int j = 0 ; j < matrix[0].length ; j++) \\n                 transpose[j][i] = matrix[i][j];\\n                         \\n     return transpose; \\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n*/ Number of Colmuns in original matrix = Number of Rows in transpose matrix\\nand number of rows in original matrix = number of columns in //transpose matrix\\nso we are creating resultant matrix with row length (matrix[0].length i.e column length of original matrix)\\nand column length as matrix.length (number of rows in original //matrix)\\n*/\\n\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n\\t\\n        int[][] transpose = new int[matrix[0].length][matrix.length];\\n        \\n        \\n        for(int i = 0 ; i < matrix.length ; i++)  \\n             for(int j = 0 ; j < matrix[0].length ; j++) \\n                 transpose[j][i] = matrix[i][j];\\n                         \\n     return transpose; \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568045,
                "title": "simple-faster-understandable-solution-java-c-c",
                "content": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] transpose = new int[matrix[0].length][matrix.length];\\n        \\n        for(int i=0; i<matrix.length; i++)\\n            for(int j=0; j<matrix[i].length; j++)\\n                transpose[j][i]=matrix[i][j];\\n        \\n        return transpose;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] transpose = new int[matrix[0].length][matrix.length];\\n        \\n        for(int i=0; i<matrix.length; i++)\\n            for(int j=0; j<matrix[i].length; j++)\\n                transpose[j][i]=matrix[i][j];\\n        \\n        return transpose;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1319761,
                "title": "c-solution-with-explaination",
                "content": "the given examples have n* m dimensions of matrix hence to have transpose matrix we need another matrix  of dimensions m*n to store ( extra space will be taken)\\nthe new_matrix(transpose matrixc)[i][j] = old matrix[j][i].\\n**Time complexity - O(m*n)**\\n**space complexity-O(m*n)**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> new_matrix(m, vector<int>(n,0));\\n        for(int i =0; i< m; i++){\\n          for(int j =0; j<n; j++){\\n             new_matrix[i][j] = matrix[j][i];\\n          }\\n        }\\n        return new_matrix;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> new_matrix(m, vector<int>(n,0));\\n        for(int i =0; i< m; i++){\\n          for(int j =0; j<n; j++){\\n             new_matrix[i][j] = matrix[j][i];\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1289104,
                "title": "easiest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<int>> res(m, vector<int>(n,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                res[j][i] = a[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<int>> res(m, vector<int>(n,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                res[j][i] = a[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278548,
                "title": "c-easy",
                "content": "```\\nvector<vector<int>> transpose(vector<vector<int>>& a) {\\n        vector<vector<int>> v(a[0].size());\\n        for(int i = 0 ; i < a[0].size(); i++){\\n            for(int j = 0 ; j < a.size() ; j++){\\n                v[i].push_back(a[j][i]);\\n            }\\n        }\\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> transpose(vector<vector<int>>& a) {\\n        vector<vector<int>> v(a[0].size());\\n        for(int i = 0 ; i < a[0].size(); i++){\\n            for(int j = 0 ; j < a.size() ; j++){\\n                v[i].push_back(a[j][i]);\\n            }\\n        }\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 949385,
                "title": "python-one-line-easy-fast-explained-no-generator",
                "content": "1. Star mark is used to decompose a list\\n2. After decomposed, zip them in another direction\\n3. Voil\\xE0! Short and clean transpose!\\n```python\\n# Platform: leetcode.com\\n# No. 867. Transpose Matrix\\n# Link: https://leetcode.com/problems/transpose-matrix/\\n# Difficulty: Easy\\n# Dev: Chumicat\\n# Date: 2020/11/26\\n# Submission: https://leetcode.com/submissions/detail/424217618/\\n# (Time, Space) Complexity : O(mn), O(mn)\\nclass Solution:\\n    def transpose(self, A: List[List[int]]) -> List[List[int]]:\\n        return zip(*A)\\n```",
                "solutionTags": [],
                "code": "```python\\n# Platform: leetcode.com\\n# No. 867. Transpose Matrix\\n# Link: https://leetcode.com/problems/transpose-matrix/\\n# Difficulty: Easy\\n# Dev: Chumicat\\n# Date: 2020/11/26\\n# Submission: https://leetcode.com/submissions/detail/424217618/\\n# (Time, Space) Complexity : O(mn), O(mn)\\nclass Solution:\\n    def transpose(self, A: List[List[int]]) -> List[List[int]]:\\n        return zip(*A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 728626,
                "title": "ultra-simple-cpp-solution-99-suggestions-for-optimization-are-welcomed",
                "content": "Runtime: 16 ms, faster than 99.48% of C++ online submissions\\nMemory Usage: 10.8 MB, less than 42.13% of C++ online submissions\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& A) {\\n        \\n    long long int i=0,j=0;\\n    vector<vector<int> > M( A[0].size(), vector<int> (A.size(), 0));\\n        \\n        for(i=0;i<A.size();i++)\\n        {\\n        for(j=0;j<A[0].size();j++)\\n            M[j][i]=A[i][j];\\n        }\\n        \\n        return M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& A) {\\n        \\n    long long int i=0,j=0;\\n    vector<vector<int> > M( A[0].size(), vector<int> (A.size(), 0));\\n        \\n        for(i=0;i<A.size();i++)\\n        {\\n        for(j=0;j<A[0].size();j++)\\n            M[j][i]=A[i][j];\\n        }\\n        \\n        return M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709078,
                "title": "c",
                "content": "```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& A) {\\n    \\n        \\n        int lenRow = A.size();\\n        int lenCol = A[0].size();\\n        \\n        vector<vector<int>> result (lenCol, vector<int> (lenRow, 0));\\n        \\n        for (int i = 0; i < lenRow; i++)\\n        {\\n            for (int j = 0; j < lenCol; j++)\\n            {\\n                result[j][i] = A[i][j];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& A) {\\n    \\n        \\n        int lenRow = A.size();\\n        int lenCol = A[0].size();\\n        \\n        vector<vector<int>> result (lenCol, vector<int> (lenRow, 0));\\n        \\n        for (int i = 0; i < lenRow; i++)\\n        {\\n            for (int j = 0; j < lenCol; j++)\\n            {\\n                result[j][i] = A[i][j];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 574690,
                "title": "python-solution-with-one-line-time-94-75",
                "content": "```\\nclass Solution:\\n    def transpose(self, A: List[List[int]]) -> List[List[int]]:\\n        return [n for n in zip(*A)]\\n```\\n`*` means unzip the list as arguments, `zip` means iterate all lists at the same time\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def transpose(self, A: List[List[int]]) -> List[List[int]]:\\n        return [n for n in zip(*A)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399921,
                "title": "three-different-solution-in-python",
                "content": "```\\nclass Solution:\\n    def transpose(self, A: List[List[int]]) -> List[List[int]]:\\n        matrix = []\\n        for i in range(len(A[0])):\\n            matrix1 = []\\n            for j in range(len(A)):\\n                matrix1.append(A[j][i])\\n            matrix.append(matrix1)\\n        return matrix\\n```\\n\\n```\\nimport numpy as np\\nclass Solution:\\n    def transpose(self, A: List[List[int]]) -> List[List[int]]:\\n\\t\\treturn np.transpose(A)\\n   \\n```\\n\\n```\\nclass Solution:\\n    def transpose(self, A: List[List[int]]) -> List[List[int]]:\\n\\t\\t return (list(zip(*A)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def transpose(self, A: List[List[int]]) -> List[List[int]]:\\n        matrix = []\\n        for i in range(len(A[0])):\\n            matrix1 = []\\n            for j in range(len(A)):\\n                matrix1.append(A[j][i])\\n            matrix.append(matrix1)\\n        return matrix\\n```\n```\\nimport numpy as np\\nclass Solution:\\n    def transpose(self, A: List[List[int]]) -> List[List[int]]:\\n\\t\\treturn np.transpose(A)\\n   \\n```\n```\\nclass Solution:\\n    def transpose(self, A: List[List[int]]) -> List[List[int]]:\\n\\t\\t return (list(zip(*A)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248787,
                "title": "simple-c",
                "content": "```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *columnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** transpose(int** A, int ARowSize, int *AColSizes, int** columnSizes, int* returnSize) {\\n    *returnSize = *AColSizes;\\n    int **result = (int **)malloc(sizeof(int *) * (*AColSizes));\\n    *columnSizes = (int *)malloc(sizeof(int) * (*AColSizes));\\n    for (int i = 0; i < *AColSizes; i++) {\\n        result[i] = (int *)malloc(sizeof(int) * ARowSize);\\n        (*columnSizes)[i] = ARowSize;\\n    }\\n    for (int i = 0; i < *AColSizes; i++) {\\n        for (int j = 0; j < ARowSize; j++) {\\n            result[i][j] = A[j][i];\\n        }\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *columnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** transpose(int** A, int ARowSize, int *AColSizes, int** columnSizes, int* returnSize) {\\n    *returnSize = *AColSizes;\\n    int **result = (int **)malloc(sizeof(int *) * (*AColSizes));\\n    *columnSizes = (int *)malloc(sizeof(int) * (*AColSizes));\\n    for (int i = 0; i < *AColSizes; i++) {\\n        result[i] = (int *)malloc(sizeof(int) * ARowSize);\\n        (*columnSizes)[i] = ARowSize;\\n    }\\n    for (int i = 0; i < *AColSizes; i++) {\\n        for (int j = 0; j < ARowSize; j++) {\\n            result[i][j] = A[j][i];\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 220986,
                "title": "rust-4ms",
                "content": "```rust\\nimpl Solution {\\n    pub fn transpose(a: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n\\t\\n        let n_row = a.len();\\n        let n_col = a.get(0).map(|row| row.len()).unwrap_or(0_usize);\\n        \\n        (0..n_col)\\n        .map(|c| {\\n            (0..n_row)\\n                .map(|r| a[r][c])\\n                .collect()\\n        })\\n        .collect()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn transpose(a: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n\\t\\n        let n_row = a.len();\\n        let n_col = a.get(0).map(|row| row.len()).unwrap_or(0_usize);\\n        \\n        (0..n_col)\\n        .map(|c| {\\n            (0..n_row)\\n                .map(|r| a[r][c])\\n                .collect()\\n        })\\n        .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 185864,
                "title": "java-solution",
                "content": "1) Ideally, we would want to do in-place swapping for this problem. This is only possible when the matrix is a square matrix (NxN). If it is not a square matrix, then we would have to create a new MxN matrix where the original matrix is NxM. Below code is hybrid. If input is square matrix then it does in-place swapping. If not, it makes new matrix element. Time: O(N*M), Space: O(N*M) or O(1), depends on the input..\n\n```\nclass Solution {\n    public int[][] transpose(int[][] A) {\n        //if we have a non square matrix, we cannot simply do in-place swapping because it will be index out of bound\n        //so we have to make a new MxN matrix if the input matrix is NxM where N != M\n        int numRows = A.length;\n        int numCols = A[0].length;\n        \n        if(numRows != numCols){\n            int[][] transMatrix = new int[numCols][numRows];\n            int i = 0;\n            for(int[] row : A){\n                for(int j=0;j<numCols;j++){\n                    transMatrix[j][i] = row[j];\n                }\n                i++;\n             }\n            return transMatrix;\n            // if it is a square matrix, we can simply do in-place flipping to save space..\n        } else {\n             for(int i=0;i<numRows;i++){\n                for(int j=1+i;j<numCols;j++){\n                    int temp = A[i][j];\n                    A[i][j] = A[j][i];\n                    A[j][i] = temp;\n                }\n            }\n            return A;\n        }\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public int[][] transpose(int[][] A) {\n        //if we have a non square matrix, we cannot simply do in-place swapping because it will be index out of bound\n        //so we have to make a new MxN matrix if the input matrix is NxM where N != M\n        int numRows = A.length;\n        int numCols = A[0].length;\n        \n        if(numRows != numCols){\n            int[][] transMatrix = new int[numCols][numRows];\n            int i = 0;\n            for(int[] row : A){\n                for(int j=0;j<numCols;j++){\n                    transMatrix[j][i] = row[j];\n                }\n                i++;\n             }\n            return transMatrix;\n            // if it is a square matrix, we can simply do in-place flipping to save space..\n        } else {\n             for(int i=0;i<numRows;i++){\n                for(int j=1+i;j<numCols;j++){\n                    int temp = A[i][j];\n                    A[i][j] = A[j][i];\n                    A[j][i] = temp;\n                }\n            }\n            return A;\n        }\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 146772,
                "title": "java-solution",
                "content": "```\\n    public int[][] transpose(int[][] A) {\\n        if(A == null || A.length == 0 || A[0].length == 0)\\n            return new int[0][0];\\n        int m = A.length, n = A[0].length;\\n        int[][] result = new int[n][m];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                result[j][i] = A[i][j];\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[][] transpose(int[][] A) {\\n        if(A == null || A.length == 0 || A[0].length == 0)\\n            return new int[0][0];\\n        int m = A.length, n = A[0].length;\\n        int[][] result = new int[n][m];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                result[j][i] = A[i][j];\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028144,
                "title": "simple-solution-in-c-just-store-tarnspose-of-the-matrix-int-a-new-matrix-and-return-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int m = matrix.size(); // the number of rows \\n        int n = matrix[0].size(); // the number of columns \\n         vector<vector<int>> t(n,vector<int>(m));\\n        for(int i = 0 ; i<n ; i++){\\n            for(int j = 0 ; j<m ;j++)\\n            {\\n              t[i][j]=matrix[j][i]; // store transpose in a new matrix \\n            }\\n        }\\n        return t; // return the transpose\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int m = matrix.size(); // the number of rows \\n        int n = matrix[0].size(); // the number of columns \\n         vector<vector<int>> t(n,vector<int>(m));\\n        for(int i = 0 ; i<n ; i++){\\n            for(int j = 0 ; j<m ;j++)\\n            {\\n              t[i][j]=matrix[j][i]; // store transpose in a new matrix \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3969794,
                "title": "day-10-transpose-matrix-java-solution",
                "content": "# Intuition\\n<!--  -->\\n\\n# Approach\\n<!--  -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- 0ms -->\\n\\n- Space complexity:\\n<!-- 44.15mb -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] z = new int[matrix[0].length][matrix.length];\\n        for(int i=0; i<matrix[0].length; i++){\\n            for(int j=0; j<matrix.length; j++){\\n                z[i][j]=matrix[j][i];\\n            }\\n        }\\n        return z;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] z = new int[matrix[0].length][matrix.length];\\n        for(int i=0; i<matrix[0].length; i++){\\n            for(int j=0; j<matrix.length; j++){\\n                z[i][j]=matrix[j][i];\\n            }\\n        }\\n        return z;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969788,
                "title": "day-8-transpose-matrix-java-solution",
                "content": "# Intuition\\n<!--  -->\\n\\n# Approach\\n<!--  -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- 0ms -->\\n\\n- Space complexity:\\n<!-- 44.26mb -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] z = new int[matrix[0].length][matrix.length];\\n        for(int i=0; i<matrix[0].length; i++){\\n            for(int j=0; j<matrix.length; j++){\\n                z[i][j]=matrix[j][i];\\n            }\\n        }\\n        return z;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] z = new int[matrix[0].length][matrix.length];\\n        for(int i=0; i<matrix[0].length; i++){\\n            for(int j=0; j<matrix.length; j++){\\n                z[i][j]=matrix[j][i];\\n            }\\n        }\\n        return z;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852695,
                "title": "beats-99-73-users-in-runtime-and-94-70-in-memory-simple-approach",
                "content": "# Intuition\\nI take one empty array after iterating in every column\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(n*m)\\n\\n# Code\\n```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        n = len(matrix)\\n        m = len(matrix[0])\\n        ans = []\\n\\n        for i in range(m):\\n            arr = []\\n            for j in range(n):\\n                arr.append(matrix[j][i])\\n            \\n            ans.append(arr)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        n = len(matrix)\\n        m = len(matrix[0])\\n        ans = []\\n\\n        for i in range(m):\\n            arr = []\\n            for j in range(n):\\n                arr.append(matrix[j][i])\\n            \\n            ans.append(arr)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697208,
                "title": "100-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int n = matrix.length, m = matrix[0].length;\\n        int[][] transposedMatrix = new int[m][n];\\n        \\n        for (int row=0; row<m; row++){\\n            for (int col=0; col<n; col++){\\n                \\n                transposedMatrix[row][col] = matrix[col][row];\\n        }\\n        }\\n        return transposedMatrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int n = matrix.length, m = matrix[0].length;\\n        int[][] transposedMatrix = new int[m][n];\\n        \\n        for (int row=0; row<m; row++){\\n            for (int col=0; col<n; col++){\\n                \\n                transposedMatrix[row][col] = matrix[col][row];\\n        }\\n        }\\n        return transposedMatrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567804,
                "title": "java-magic-transpose-matrix-in-0-runtime-like-a-boss",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCertainly! Here\\'s the intuition behind the code:\\n\\nThe code aims to transpose a given matrix, which involves flipping its rows and columns. To achieve this, a new matrix `ani` is created with dimensions `[matrix[0].length][matrix.length]`. This new matrix will hold the transposed elements.\\n\\nThe code then iterates over each element in the original matrix using two nested loops. The outer loop iterates over the rows of the matrix, and the inner loop iterates over the columns of each row.\\n\\nDuring each iteration, the code accesses the element at index `(i, j)` in the original matrix, where `i` represents the row and `j` represents the column. It assigns this element to the corresponding position `(j, i)` in the `ani` matrix. This swapping of rows and columns effectively transposes the element from the original matrix to the `ani` matrix.\\n\\nAfter completing both loops and filling in all elements of `ani`, it holds the transposed matrix. The code then returns the `ani` matrix as the result.\\n\\nIn essence, the code follows a simple approach of iterating over the original matrix and swapping the positions of rows and columns to achieve the transpose operation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe provided code defines a class `Solution` with a method `transpose` that takes a 2D matrix as input and returns its transpose.\\n\\nHere\\'s the approach taken by the code:\\n\\n1. Create a new 2D array `ani` with dimensions `[matrix[0].length][matrix.length]`. This will be used to store the transposed matrix.\\n\\n2. Iterate over the rows of the input matrix using a `for` loop, with the loop variable `i` ranging from 0 to `matrix.length - 1`.\\n\\n3. Within the outer loop, iterate over the columns of the input matrix using another `for` loop, with the loop variable `j` ranging from 0 to `matrix[i].length - 1`.\\n\\n4. Access the element at index `(j, i)` in the input matrix, and assign it to the corresponding position `(i, j)` in the `ani` array. This effectively transposes the element from the input matrix to the `ani` array.\\n\\n5. After both loops have completed, the `ani` array will hold the transposed matrix.\\n\\n6. Finally, return the `ani` array as the result.\\n\\nIn summary, the code iterates over the elements of the input matrix and assigns them to the corresponding positions in a new array, effectively transposing the matrix.\\n\\n# Complexity\\n- Time complexity:  `O(n * m)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code consists of two nested loops. The outer loop iterates over the rows of the input matrix, and the inner loop iterates over the columns of each row. Since both loops iterate over all elements of the matrix, the time complexity is `O(n * m)`, where n is the number of rows and m is the number of columns in the matrix.\\n\\n- Space complexity: `O(m * n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code uses an additional 2D array ani to store the transposed matrix. The dimensions of this array are `[matrix[0].length][matrix.length]`. Therefore, the space complexity is `O(m * n)`, where m is the number of columns and n is the number of rows in the matrix.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] ani = new int[matrix[0].length][matrix.length];\\n\\n        for(int i = 0; i<matrix.length;i++){\\n            for(int j =0; j< matrix[i].length; j++ ){\\n                ani[j][i] = matrix[i][j];\\n            }\\n        }\\n        return ani;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] ani = new int[matrix[0].length][matrix.length];\\n\\n        for(int i = 0; i<matrix.length;i++){\\n            for(int j =0; j< matrix[i].length; j++ ){\\n                ani[j][i] = matrix[i][j];\\n            }\\n        }\\n        return ani;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509428,
                "title": "java-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] ans = new int[matrix[0].length][matrix.length];\\n        int row = 0;\\n        int col = 0;\\n\\n        for(int i = 0; i < matrix.length; i++) {\\n            for(int j = 0; j < matrix[0].length; j++) {\\n                ans[row][col] = matrix[i][j];\\n\\n                row++;\\n\\n                if(row % ans.length == 0) {\\n                    row = 0;\\n                    col++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] ans = new int[matrix[0].length][matrix.length];\\n        int row = 0;\\n        int col = 0;\\n\\n        for(int i = 0; i < matrix.length; i++) {\\n            for(int j = 0; j < matrix[0].length; j++) {\\n                ans[row][col] = matrix[i][j];\\n\\n                row++;\\n\\n                if(row % ans.length == 0) {\\n                    row = 0;\\n                    col++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364572,
                "title": "easy-to-understand-c-clear-code",
                "content": "\\n\\n# Approach\\nTranspose \\n\\n# Complexity\\n- Time complexity:\\n O(N^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n\\t\\t\\n        vector<vector<int>> res(matrix[0].size(), vector<int>(matrix.size()));\\n        \\n        for(int i=0;i<matrix.size();i++) {\\n            for(int j=0;j<matrix[0].size();j++) {\\n                \\n                res[j][i] = matrix[i][j];// transpose of matrix\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n\\t\\t\\n        vector<vector<int>> res(matrix[0].size(), vector<int>(matrix.size()));\\n        \\n        for(int i=0;i<matrix.size();i++) {\\n            for(int j=0;j<matrix[0].size();j++) {\\n                \\n                res[j][i] = matrix[i][j];// transpose of matrix\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355102,
                "title": "faster-than-88-very-easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[][]}\\n */\\nvar transpose = function(a) {\\n    const  res = []\\n    for(let i  = 0 ; i <a[0].length ;i++){\\n        const d = []\\n        for(let j = 0 ; j < a.length ; j++){\\n            d.push(a[j][i])\\n        }\\n        res.push(d)\\n    }\\n    return res\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[][]}\\n */\\nvar transpose = function(a) {\\n    const  res = []\\n    for(let i  = 0 ; i <a[0].length ;i++){\\n        const d = []\\n        for(let j = 0 ; j < a.length ; j++){\\n            d.push(a[j][i])\\n        }\\n        res.push(d)\\n    }\\n    return res\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3295176,
                "title": "c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        \\n    int n=matrix.size();\\n    int m=matrix[0].size();\\n    vector<vector<int>> ans;\\n    for (int i = 0; i < m; i++)\\n    {\\n        vector<int> v;\\n        for (int j = 0; j < n; j++)\\n            v.push_back(matrix[j][i]);\\n        ans.push_back(v);\\n    }\\n    return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        \\n    int n=matrix.size();\\n    int m=matrix[0].size();\\n    vector<vector<int>> ans;\\n    for (int i = 0; i < m; i++)\\n    {\\n        vector<int> v;\\n        for (int j = 0; j < n; j++)\\n            v.push_back(matrix[j][i]);\\n        ans.push_back(v);\\n    }\\n    return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116244,
                "title": "kotlin-easy-solution-matrix",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    fun transpose(matrix: Array<IntArray>): Array<IntArray> {\\n        val array = Array(matrix[0].size) { IntArray(matrix.size) }\\n        for (i in 0 until matrix.size) {\\n            for (j in 0 until matrix[0].size) {\\n                array[j][i] = matrix[i][j]\\n            }\\n        }\\n        return array\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    fun transpose(matrix: Array<IntArray>): Array<IntArray> {\\n        val array = Array(matrix[0].size) { IntArray(matrix.size) }\\n        for (i in 0 until matrix.size) {\\n            for (j in 0 until matrix[0].size) {\\n                array[j][i] = matrix[i][j]\\n            }\\n        }\\n        return array\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108275,
                "title": "c-easy-and-simplest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAlgorithm:-\\ni Traverse column wise the given matrix and  storing in temp vector\\nii Then push the temp vector in store\\niii Then return store.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->10.9 MB\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int column = matrix[0].size();\\n        vector<vector<int>> store;\\n\\n        for(int i = 0; i<column; i++){\\n            vector<int> temp;\\n            for(int j = 0; j<row; j++){\\n                int tmp = matrix[j][i];\\n                temp.push_back(tmp);\\n            }\\n            store.push_back(temp);\\n        }\\n        return store;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int column = matrix[0].size();\\n        vector<vector<int>> store;\\n\\n        for(int i = 0; i<column; i++){\\n            vector<int> temp;\\n            for(int j = 0; j<row; j++){\\n                int tmp = matrix[j][i];\\n                temp.push_back(tmp);\\n            }\\n            store.push_back(temp);\\n        }\\n        return store;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849209,
                "title": "easy-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] A) {\\n        int R = A.length, C = A[0].length;\\n\\n        //Dimension of new matrix got change\\n        int[][] ans = new int[C][R];\\n        for (int r = 0; r < R; ++r)\\n            for (int c = 0; c < C; ++c) {\\n                ans[c][r] = A[r][c];\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] A) {\\n        int R = A.length, C = A[0].length;\\n\\n        //Dimension of new matrix got change\\n        int[][] ans = new int[C][R];\\n        for (int r = 0; r < R; ++r)\\n            for (int c = 0; c < C; ++c) {\\n                ans[c][r] = A[r][c];\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804372,
                "title": "simple-java-solution-for-beginners-with-runtime-0-ms-beats-100-memory-42-7-mb-beats-97-5",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis question looks simple but hard to get the solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. In this, first we are initializing an empty array with the row size as column of given array and column size of given array.\\n2. Next, iterate through the given array and give the i value and j value as j and i in the result array.Like this, \\n2.1. ```result[j][i] = matrix[i][j]```  \\n3. return the result array\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(2n)$$\\n# Code\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] result = new int[matrix[0].length][matrix.length];\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                result[j][i] = matrix[i][j];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```result[j][i] = matrix[i][j]```\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] result = new int[matrix[0].length][matrix.length];\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                result[j][i] = matrix[i][j];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802188,
                "title": "easy-1ms",
                "content": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int rows=matrix.length;\\n        int column=matrix[0].length;\\n        int[][] resultmatrix=new int[column][rows];\\n        for(int i=0;i<column;i++){\\n            for(int j=0;j<rows;j++){\\n                resultmatrix[i][j]=matrix[j][i];\\n            }\\n        }\\n        return resultmatrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int rows=matrix.length;\\n        int column=matrix[0].length;\\n        int[][] resultmatrix=new int[column][rows];\\n        for(int i=0;i<column;i++){\\n            for(int j=0;j<rows;j++){\\n                resultmatrix[i][j]=matrix[j][i];\\n            }\\n        }\\n        return resultmatrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727643,
                "title": "understandable-solution",
                "content": "```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        trans = []\\n        m,n=len(matrix),len(matrix[0])\\n        for j in range(n):\\n            temp=[]\\n            for i in range(m):\\n                temp.append(matrix[i][j])\\n            trans.append(temp)\\n        return trans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        trans = []\\n        m,n=len(matrix),len(matrix[0])\\n        for j in range(n):\\n            temp=[]\\n            for i in range(m):\\n                temp.append(matrix[i][j])\\n            trans.append(temp)\\n        return trans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672915,
                "title": "java-simple-solution-1ms",
                "content": "```\\npublic int[][] transpose(int[][] matrix) {\\n\\tint row = matrix.length;\\n\\tint col = matrix[0].length;\\n\\tint[][] arr = new int[col][row];\\n\\tfor(int i = 0; i < row; i++) {\\n\\t\\tfor(int j = 0; j < col; j++) {\\n\\t\\t\\tarr[j][i] = matrix[i][j];\\n\\t\\t}\\n\\t}\\n\\treturn arr;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] transpose(int[][] matrix) {\\n\\tint row = matrix.length;\\n\\tint col = matrix[0].length;\\n\\tint[][] arr = new int[col][row];\\n\\tfor(int i = 0; i < row; i++) {\\n\\t\\tfor(int j = 0; j < col; j++) {\\n\\t\\t\\tarr[j][i] = matrix[i][j];\\n\\t\\t}\\n\\t}\\n\\treturn arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2659907,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        vector<vector<int>> v(matrix[0].size(),vector<int> (matrix.size(),0));\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                v[j][i]=matrix[i][j];\\n            }\\n        }\\n        return v;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        vector<vector<int>> v(matrix[0].size(),vector<int> (matrix.size(),0));\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                v[j][i]=matrix[i][j];\\n            }\\n        }\\n        return v;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654566,
                "title": "o-n-n-java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int row = matrix.length;\\n        int colum = matrix[0].length;\\n        int[][] new_matrix = new int[colum][row];\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<colum;j++){\\n                new_matrix[j][i] = matrix[i][j];\\n            }\\n        }\\n        \\n        return new_matrix;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int row = matrix.length;\\n        int colum = matrix[0].length;\\n        int[][] new_matrix = new int[colum][row];\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<colum;j++){\\n                new_matrix[j][i] = matrix[i][j];\\n            }\\n        }\\n        \\n        return new_matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565739,
                "title": "js-simple-solution-o-m-n",
                "content": "```\\nvar transpose = function(matrix) {\\n    let output = new Array(matrix[0].length).fill(null).map(item => new Array(matrix.length).fill(null));\\n    \\n    for (let i = 0; i < matrix.length; i++) {\\n        for (let j = 0; j < matrix[0].length; j++) {\\n            output[j][i] = matrix[i][j];\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar transpose = function(matrix) {\\n    let output = new Array(matrix[0].length).fill(null).map(item => new Array(matrix.length).fill(null));\\n    \\n    for (let i = 0; i < matrix.length; i++) {\\n        for (let j = 0; j < matrix[0].length; j++) {\\n            output[j][i] = matrix[i][j];\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2563223,
                "title": "c-simple-logic",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        vector<vector<int>>v;\\n        for(int i=0;i<matrix[0].size();i++)\\n        {\\n            vector<int>v1;\\n            for(int j=0;j<matrix.size();j++)\\n            {\\n                v1.push_back(matrix[j][i]);\\n            }\\n            v.push_back(v1);\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        vector<vector<int>>v;\\n        for(int i=0;i<matrix[0].size();i++)\\n        {\\n            vector<int>v1;\\n            for(int j=0;j<matrix.size();j++)\\n            {\\n                v1.push_back(matrix[j][i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2549439,
                "title": "easy-python-solution",
                "content": "```class Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        list=[]\\n        for m in matrix:\\n            count=0\\n            for n in m:\\n                count+=1\\n        for j in range(count):\\n            tmp=[]\\n            for i in range(len(matrix)):\\n                tmp.append(matrix[i][j])\\n            list.append(tmp)\\n        return list```",
                "solutionTags": [],
                "code": "```class Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        list=[]\\n        for m in matrix:\\n            count=0\\n            for n in m:\\n                count+=1\\n        for j in range(count):\\n            tmp=[]\\n            for i in range(len(matrix)):\\n                tmp.append(matrix[i][j])\\n            list.append(tmp)\\n        return list```",
                "codeTag": "Java"
            },
            {
                "id": 2509163,
                "title": "c-using-just-one-for-loop-easy-understanding",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        \\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<vector<int>> result(n, vector<int> (m));\\n        \\n        for(int i = 0; i < m * n; i++) {\\n            result[i % n][i / n] = matrix[i / n][i % n]; \\n         }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        \\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<vector<int>> result(n, vector<int> (m));\\n        \\n        for(int i = 0; i < m * n; i++) {\\n            result[i % n][i / n] = matrix[i / n][i % n]; \\n         }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507807,
                "title": "java-o-m-n-solution",
                "content": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        \\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        \\n        int[][] mat = new int[n][m];\\n        \\n        for(int i =0; i<m; i++) {\\n            for(int j =0; j<n; j++) {\\n                if(i == j){\\n                    mat[i][j] = matrix[i][j];\\n                }\\n                else{\\n                    mat[j][i] = matrix[i][j];\\n                }\\n            }\\n        }\\n        \\n        return mat;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        \\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        \\n        int[][] mat = new int[n][m];\\n        \\n        for(int i =0; i<m; i++) {\\n            for(int j =0; j<n; j++) {\\n                if(i == j){\\n                    mat[i][j] = matrix[i][j];\\n                }\\n                else{\\n                    mat[j][i] = matrix[i][j];\\n                }\\n            }\\n        }\\n        \\n        return mat;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503783,
                "title": "java-solution-easy",
                "content": "### Please Upvote !!!\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int[][] ans = new int[n][m];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                ans[i][j] = matrix[j][i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(m * n)\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int[][] ans = new int[n][m];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                ans[i][j] = matrix[j][i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(m * n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434640,
                "title": "transpose-matrix",
                "content": "python 3 solution:\\n```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        m= len(matrix)\\n        n = len(matrix[0])\\n        Transpose=[[0]*m for i in range(n)]\\n        for i in range(m):\\n            for j in range(n):\\n                Transpose[j][i]=matrix[i][j]\\n        return(Transpose)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        m= len(matrix)\\n        n = len(matrix[0])\\n        Transpose=[[0]*m for i in range(n)]\\n        for i in range(m):\\n            for j in range(n):\\n                Transpose[j][i]=matrix[i][j]\\n        return(Transpose)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433537,
                "title": "c-easy-faster-than-84-38-o-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int nrow = matrix.size();\\n        int ncol = matrix[0].size();\\n        vector<vector<int>> ans;\\n        for(int i=0;i<ncol;i++){\\n            vector<int> temp;\\n            for(int j=0;j<nrow;j++){\\n               temp.push_back(matrix[j][i]);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int nrow = matrix.size();\\n        int ncol = matrix[0].size();\\n        vector<vector<int>> ans;\\n        for(int i=0;i<ncol;i++){\\n            vector<int> temp;\\n            for(int j=0;j<nrow;j++){\\n               temp.push_back(matrix[j][i]);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425772,
                "title": "python-2-solutions-easy-90-fast-beginner-friendly",
                "content": "Solution #1 \\n```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        n = len (matrix)\\n        m = len(matrix[0])\\n        mat = [[0 for i in range (n)] for i in range (m) ]\\n        for i in range (m):\\n            for j in range (n):\\n                mat[i][j] = matrix[j][i]\\n            \\n        return mat\\n```\\n\\nSolution #2\\n```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        new = []\\n        for i in range(n):\\n            for j in range(m):\\n                ele = matrix[j][i]\\n                new.append(ele)\\n        b = new\\n        li = [[int(b[m *i+j]) for j in range (m)]for i in range (n)]\\n        return li\\n```\\n\\nReally easy to understand. Upvote if it helped. Thanks",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        n = len (matrix)\\n        m = len(matrix[0])\\n        mat = [[0 for i in range (n)] for i in range (m) ]\\n        for i in range (m):\\n            for j in range (n):\\n                mat[i][j] = matrix[j][i]\\n            \\n        return mat\\n```\n```\\nclass Solution:\\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        new = []\\n        for i in range(n):\\n            for j in range(m):\\n                ele = matrix[j][i]\\n                new.append(ele)\\n        b = new\\n        li = [[int(b[m *i+j]) for j in range (m)]for i in range (n)]\\n        return li\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424717,
                "title": "java-c-easily-explained",
                "content": "```\\n// Java Solution:\\nclass Solution {\\n    public int[][] transpose(int[][] mat) {\\n        int row = mat.length, col = mat[0].length;\\n        int[][] ans = new int[col][row];\\n        for (int i = 0; i < col; i++)\\n            for (int j = 0; j < row; j++)\\n                ans[i][j] = mat[j][i];\\n        return ans;\\n    }\\n}\\n\\n// C++ Solution:\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& mat) {\\n        int row=mat.size();\\n        int col=mat[0].size();\\n        vector<vector<int>> ans(col, vector<int> (row,0));\\n        for(int i=0;i<col;i++){\\n            for(int j=0;j<row;j++){\\n                ans[i][j]=mat[j][i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\n// Java Solution:\\nclass Solution {\\n    public int[][] transpose(int[][] mat) {\\n        int row = mat.length, col = mat[0].length;\\n        int[][] ans = new int[col][row];\\n        for (int i = 0; i < col; i++)\\n            for (int j = 0; j < row; j++)\\n                ans[i][j] = mat[j][i];\\n        return ans;\\n    }\\n}\\n\\n// C++ Solution:\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& mat) {\\n        int row=mat.size();\\n        int col=mat[0].size();\\n        vector<vector<int>> ans(col, vector<int> (row,0));\\n        for(int i=0;i<col;i++){\\n            for(int j=0;j<row;j++){\\n                ans[i][j]=mat[j][i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417160,
                "title": "java-solution-in-o-rows-columns-time-complexity",
                "content": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] result = new int[matrix[0].length][matrix.length];\\n        for(int i = 0; i < matrix.length; i++) \\n            for(int j = 0; j < matrix[0].length; j++) \\n                result[j][i] = matrix[i][j];\\n        return result;\\n    }\\n}\\n```\\nTime Complexity: O(rows * columns)\\nGuy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] result = new int[matrix[0].length][matrix.length];\\n        for(int i = 0; i < matrix.length; i++) \\n            for(int j = 0; j < matrix[0].length; j++) \\n                result[j][i] = matrix[i][j];\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565818,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/transpose-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Copy Directly\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  int [][] ans =new int [matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length ;i++){\\n            for(int j=0 ;j<matrix[i].length;j++){\\n                ans[j][i]=matrix[i][j];\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "_slaay_069",
                        "content": "this\\'ll work only for m x m matrix"
                    },
                    {
                        "username": "pratikyadav8319",
                        "content": "first you need to now what transpose means , than 2nd step create a transpose empty array so that you can store your matrix (normal array) into transpose array its pretty simple\\n\\nlet me  break down here \\uD83D\\uDC47\\n\\ntranspose = column become row and vice versa!\\n \\nso suppose if a (non transpose) 2d matrix initialized like that : int array[] = new int [matrix.length] [matrix[0].length} (its  a normal 2d array which goes rows then column ) (first row then column).\\n\\nbut in transpose you have to create a opposite array like : int[][] ans =new int [matrix[0].length][matrix.length];  (column and row ) (in it you can store or can say transpose your normal array)\\n\\nthan iterate via for loop and fill each  elements form \"matrix\"to your new transpose \"array\" which is like \\narray [ j ][ i ]  = matrix [ i ][ j ]      \\n\\nNote : bc you created earlier a transpose array thats why array[ j ] (column) then [ i ] row happend ,and it tranpose."
                    },
                    {
                        "username": "bdoodo",
                        "content": "Please do not use this in an interview hahaha\\n\\n`var transpose = matrix => matrix[0].map((row, index) => matrix.map(matRow => matRow[index]))`\\n\\nCreated from a joint effort with [@indigoarthur](https://leetcode.com/indigoarthur/)"
                    },
                    {
                        "username": "Adonis21",
                        "content": "I have tried without creating a new array, and instead tried to replace the values, but it is giving me error, but when i tried same thing in my local IDE, its working perfectly fine. Any suggesstion someone might have?"
                    },
                    {
                        "username": "ChNihar",
                        "content": "[@Adonis21](/Adonis21) In transpose a 3*2 matrix will become 2*3 matrix so You have to create a new array as per my observation."
                    },
                    {
                        "username": "kerku",
                        "content": "[@Adonis21](/Adonis21)  i was thinking about completing this w/o creating a new arr, but faced w/ the same issue :) maybe one of the option could be creation of a new array in if statement, when it\\'s not possible to return correct answer with in the same array, and processing the same matrix when it is a square one? but this is just for fun)"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Probably you could try this approach  - https://leetcode.com/problems/transpose-matrix/solutions/3172907/transposing-in-place-python-a-funny-solution/"
                    },
                    {
                        "username": "Adonis21",
                        "content": "Got it, it would not work for matrixes that are not square matrix. So, is there not any solution without making a new matrix?"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int temp;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int  j = i ; j < n ; j++)\\n            {\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\nWhat\\'s the error in this code?\\n(giving runtime error)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "[@user8698Xs](/user8698Xs) because matrix does not have same number of rows and column"
                    },
                    {
                        "username": "vitaliynovak555",
                        "content": "I also wrote similar code, and caught an error when accessing an array element. The problem does not specify that the matrix has the same number of rows and columns, so this is the problem."
                    },
                    {
                        "username": "user8698Xs",
                        "content": "actually this will return the matrix itself, because every element is swapped twice i.e. once  a[i][j] with a[j][i] and vice versa...\nu can put an if ststement to swap only the elemnts of upper triangular matix or lower triangular\n\nI'm also getting runtime error, don't know why!\n\n\nclass Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n\n        int row= matrix.size();\n        int col= matrix[0].size();\n\n        for(int i= 0; i<row ; i++)\n        {\n            for(int j=0; j<col; j++)\n            {\n                if(j>i) // ****************add this condition**************\n                {\n                   swap( matrix[i][j],  matrix[j][i]);\n\n                }\n            }\n        }\n\n        return matrix;\n        \n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "JarJuicy",
                        "content": "return zip(*A)"
                    },
                    {
                        "username": "robin316709150",
                        "content": "`return (zip(*A))`"
                    },
                    {
                        "username": "leetcode_oye_hoye",
                        "content": "Won\\'t swapping the variables not work?"
                    },
                    {
                        "username": "suriyasuresh2507",
                        "content": "yenda dei ithellam oru easy question ah da\\n"
                    }
                ]
            },
            {
                "id": 1736476,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/transpose-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Copy Directly\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  int [][] ans =new int [matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length ;i++){\\n            for(int j=0 ;j<matrix[i].length;j++){\\n                ans[j][i]=matrix[i][j];\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "_slaay_069",
                        "content": "this\\'ll work only for m x m matrix"
                    },
                    {
                        "username": "pratikyadav8319",
                        "content": "first you need to now what transpose means , than 2nd step create a transpose empty array so that you can store your matrix (normal array) into transpose array its pretty simple\\n\\nlet me  break down here \\uD83D\\uDC47\\n\\ntranspose = column become row and vice versa!\\n \\nso suppose if a (non transpose) 2d matrix initialized like that : int array[] = new int [matrix.length] [matrix[0].length} (its  a normal 2d array which goes rows then column ) (first row then column).\\n\\nbut in transpose you have to create a opposite array like : int[][] ans =new int [matrix[0].length][matrix.length];  (column and row ) (in it you can store or can say transpose your normal array)\\n\\nthan iterate via for loop and fill each  elements form \"matrix\"to your new transpose \"array\" which is like \\narray [ j ][ i ]  = matrix [ i ][ j ]      \\n\\nNote : bc you created earlier a transpose array thats why array[ j ] (column) then [ i ] row happend ,and it tranpose."
                    },
                    {
                        "username": "bdoodo",
                        "content": "Please do not use this in an interview hahaha\\n\\n`var transpose = matrix => matrix[0].map((row, index) => matrix.map(matRow => matRow[index]))`\\n\\nCreated from a joint effort with [@indigoarthur](https://leetcode.com/indigoarthur/)"
                    },
                    {
                        "username": "Adonis21",
                        "content": "I have tried without creating a new array, and instead tried to replace the values, but it is giving me error, but when i tried same thing in my local IDE, its working perfectly fine. Any suggesstion someone might have?"
                    },
                    {
                        "username": "ChNihar",
                        "content": "[@Adonis21](/Adonis21) In transpose a 3*2 matrix will become 2*3 matrix so You have to create a new array as per my observation."
                    },
                    {
                        "username": "kerku",
                        "content": "[@Adonis21](/Adonis21)  i was thinking about completing this w/o creating a new arr, but faced w/ the same issue :) maybe one of the option could be creation of a new array in if statement, when it\\'s not possible to return correct answer with in the same array, and processing the same matrix when it is a square one? but this is just for fun)"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Probably you could try this approach  - https://leetcode.com/problems/transpose-matrix/solutions/3172907/transposing-in-place-python-a-funny-solution/"
                    },
                    {
                        "username": "Adonis21",
                        "content": "Got it, it would not work for matrixes that are not square matrix. So, is there not any solution without making a new matrix?"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int temp;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int  j = i ; j < n ; j++)\\n            {\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\nWhat\\'s the error in this code?\\n(giving runtime error)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "[@user8698Xs](/user8698Xs) because matrix does not have same number of rows and column"
                    },
                    {
                        "username": "vitaliynovak555",
                        "content": "I also wrote similar code, and caught an error when accessing an array element. The problem does not specify that the matrix has the same number of rows and columns, so this is the problem."
                    },
                    {
                        "username": "user8698Xs",
                        "content": "actually this will return the matrix itself, because every element is swapped twice i.e. once  a[i][j] with a[j][i] and vice versa...\nu can put an if ststement to swap only the elemnts of upper triangular matix or lower triangular\n\nI'm also getting runtime error, don't know why!\n\n\nclass Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n\n        int row= matrix.size();\n        int col= matrix[0].size();\n\n        for(int i= 0; i<row ; i++)\n        {\n            for(int j=0; j<col; j++)\n            {\n                if(j>i) // ****************add this condition**************\n                {\n                   swap( matrix[i][j],  matrix[j][i]);\n\n                }\n            }\n        }\n\n        return matrix;\n        \n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "JarJuicy",
                        "content": "return zip(*A)"
                    },
                    {
                        "username": "robin316709150",
                        "content": "`return (zip(*A))`"
                    },
                    {
                        "username": "leetcode_oye_hoye",
                        "content": "Won\\'t swapping the variables not work?"
                    },
                    {
                        "username": "suriyasuresh2507",
                        "content": "yenda dei ithellam oru easy question ah da\\n"
                    }
                ]
            },
            {
                "id": 1973956,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/transpose-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Copy Directly\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  int [][] ans =new int [matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length ;i++){\\n            for(int j=0 ;j<matrix[i].length;j++){\\n                ans[j][i]=matrix[i][j];\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "_slaay_069",
                        "content": "this\\'ll work only for m x m matrix"
                    },
                    {
                        "username": "pratikyadav8319",
                        "content": "first you need to now what transpose means , than 2nd step create a transpose empty array so that you can store your matrix (normal array) into transpose array its pretty simple\\n\\nlet me  break down here \\uD83D\\uDC47\\n\\ntranspose = column become row and vice versa!\\n \\nso suppose if a (non transpose) 2d matrix initialized like that : int array[] = new int [matrix.length] [matrix[0].length} (its  a normal 2d array which goes rows then column ) (first row then column).\\n\\nbut in transpose you have to create a opposite array like : int[][] ans =new int [matrix[0].length][matrix.length];  (column and row ) (in it you can store or can say transpose your normal array)\\n\\nthan iterate via for loop and fill each  elements form \"matrix\"to your new transpose \"array\" which is like \\narray [ j ][ i ]  = matrix [ i ][ j ]      \\n\\nNote : bc you created earlier a transpose array thats why array[ j ] (column) then [ i ] row happend ,and it tranpose."
                    },
                    {
                        "username": "bdoodo",
                        "content": "Please do not use this in an interview hahaha\\n\\n`var transpose = matrix => matrix[0].map((row, index) => matrix.map(matRow => matRow[index]))`\\n\\nCreated from a joint effort with [@indigoarthur](https://leetcode.com/indigoarthur/)"
                    },
                    {
                        "username": "Adonis21",
                        "content": "I have tried without creating a new array, and instead tried to replace the values, but it is giving me error, but when i tried same thing in my local IDE, its working perfectly fine. Any suggesstion someone might have?"
                    },
                    {
                        "username": "ChNihar",
                        "content": "[@Adonis21](/Adonis21) In transpose a 3*2 matrix will become 2*3 matrix so You have to create a new array as per my observation."
                    },
                    {
                        "username": "kerku",
                        "content": "[@Adonis21](/Adonis21)  i was thinking about completing this w/o creating a new arr, but faced w/ the same issue :) maybe one of the option could be creation of a new array in if statement, when it\\'s not possible to return correct answer with in the same array, and processing the same matrix when it is a square one? but this is just for fun)"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Probably you could try this approach  - https://leetcode.com/problems/transpose-matrix/solutions/3172907/transposing-in-place-python-a-funny-solution/"
                    },
                    {
                        "username": "Adonis21",
                        "content": "Got it, it would not work for matrixes that are not square matrix. So, is there not any solution without making a new matrix?"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int temp;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int  j = i ; j < n ; j++)\\n            {\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\nWhat\\'s the error in this code?\\n(giving runtime error)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "[@user8698Xs](/user8698Xs) because matrix does not have same number of rows and column"
                    },
                    {
                        "username": "vitaliynovak555",
                        "content": "I also wrote similar code, and caught an error when accessing an array element. The problem does not specify that the matrix has the same number of rows and columns, so this is the problem."
                    },
                    {
                        "username": "user8698Xs",
                        "content": "actually this will return the matrix itself, because every element is swapped twice i.e. once  a[i][j] with a[j][i] and vice versa...\nu can put an if ststement to swap only the elemnts of upper triangular matix or lower triangular\n\nI'm also getting runtime error, don't know why!\n\n\nclass Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n\n        int row= matrix.size();\n        int col= matrix[0].size();\n\n        for(int i= 0; i<row ; i++)\n        {\n            for(int j=0; j<col; j++)\n            {\n                if(j>i) // ****************add this condition**************\n                {\n                   swap( matrix[i][j],  matrix[j][i]);\n\n                }\n            }\n        }\n\n        return matrix;\n        \n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "JarJuicy",
                        "content": "return zip(*A)"
                    },
                    {
                        "username": "robin316709150",
                        "content": "`return (zip(*A))`"
                    },
                    {
                        "username": "leetcode_oye_hoye",
                        "content": "Won\\'t swapping the variables not work?"
                    },
                    {
                        "username": "suriyasuresh2507",
                        "content": "yenda dei ithellam oru easy question ah da\\n"
                    }
                ]
            },
            {
                "id": 1576361,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/transpose-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Copy Directly\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  int [][] ans =new int [matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length ;i++){\\n            for(int j=0 ;j<matrix[i].length;j++){\\n                ans[j][i]=matrix[i][j];\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "_slaay_069",
                        "content": "this\\'ll work only for m x m matrix"
                    },
                    {
                        "username": "pratikyadav8319",
                        "content": "first you need to now what transpose means , than 2nd step create a transpose empty array so that you can store your matrix (normal array) into transpose array its pretty simple\\n\\nlet me  break down here \\uD83D\\uDC47\\n\\ntranspose = column become row and vice versa!\\n \\nso suppose if a (non transpose) 2d matrix initialized like that : int array[] = new int [matrix.length] [matrix[0].length} (its  a normal 2d array which goes rows then column ) (first row then column).\\n\\nbut in transpose you have to create a opposite array like : int[][] ans =new int [matrix[0].length][matrix.length];  (column and row ) (in it you can store or can say transpose your normal array)\\n\\nthan iterate via for loop and fill each  elements form \"matrix\"to your new transpose \"array\" which is like \\narray [ j ][ i ]  = matrix [ i ][ j ]      \\n\\nNote : bc you created earlier a transpose array thats why array[ j ] (column) then [ i ] row happend ,and it tranpose."
                    },
                    {
                        "username": "bdoodo",
                        "content": "Please do not use this in an interview hahaha\\n\\n`var transpose = matrix => matrix[0].map((row, index) => matrix.map(matRow => matRow[index]))`\\n\\nCreated from a joint effort with [@indigoarthur](https://leetcode.com/indigoarthur/)"
                    },
                    {
                        "username": "Adonis21",
                        "content": "I have tried without creating a new array, and instead tried to replace the values, but it is giving me error, but when i tried same thing in my local IDE, its working perfectly fine. Any suggesstion someone might have?"
                    },
                    {
                        "username": "ChNihar",
                        "content": "[@Adonis21](/Adonis21) In transpose a 3*2 matrix will become 2*3 matrix so You have to create a new array as per my observation."
                    },
                    {
                        "username": "kerku",
                        "content": "[@Adonis21](/Adonis21)  i was thinking about completing this w/o creating a new arr, but faced w/ the same issue :) maybe one of the option could be creation of a new array in if statement, when it\\'s not possible to return correct answer with in the same array, and processing the same matrix when it is a square one? but this is just for fun)"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Probably you could try this approach  - https://leetcode.com/problems/transpose-matrix/solutions/3172907/transposing-in-place-python-a-funny-solution/"
                    },
                    {
                        "username": "Adonis21",
                        "content": "Got it, it would not work for matrixes that are not square matrix. So, is there not any solution without making a new matrix?"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int temp;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int  j = i ; j < n ; j++)\\n            {\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\nWhat\\'s the error in this code?\\n(giving runtime error)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "[@user8698Xs](/user8698Xs) because matrix does not have same number of rows and column"
                    },
                    {
                        "username": "vitaliynovak555",
                        "content": "I also wrote similar code, and caught an error when accessing an array element. The problem does not specify that the matrix has the same number of rows and columns, so this is the problem."
                    },
                    {
                        "username": "user8698Xs",
                        "content": "actually this will return the matrix itself, because every element is swapped twice i.e. once  a[i][j] with a[j][i] and vice versa...\nu can put an if ststement to swap only the elemnts of upper triangular matix or lower triangular\n\nI'm also getting runtime error, don't know why!\n\n\nclass Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n\n        int row= matrix.size();\n        int col= matrix[0].size();\n\n        for(int i= 0; i<row ; i++)\n        {\n            for(int j=0; j<col; j++)\n            {\n                if(j>i) // ****************add this condition**************\n                {\n                   swap( matrix[i][j],  matrix[j][i]);\n\n                }\n            }\n        }\n\n        return matrix;\n        \n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "JarJuicy",
                        "content": "return zip(*A)"
                    },
                    {
                        "username": "robin316709150",
                        "content": "`return (zip(*A))`"
                    },
                    {
                        "username": "leetcode_oye_hoye",
                        "content": "Won\\'t swapping the variables not work?"
                    },
                    {
                        "username": "suriyasuresh2507",
                        "content": "yenda dei ithellam oru easy question ah da\\n"
                    }
                ]
            },
            {
                "id": 1796701,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/transpose-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Copy Directly\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  int [][] ans =new int [matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length ;i++){\\n            for(int j=0 ;j<matrix[i].length;j++){\\n                ans[j][i]=matrix[i][j];\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "_slaay_069",
                        "content": "this\\'ll work only for m x m matrix"
                    },
                    {
                        "username": "pratikyadav8319",
                        "content": "first you need to now what transpose means , than 2nd step create a transpose empty array so that you can store your matrix (normal array) into transpose array its pretty simple\\n\\nlet me  break down here \\uD83D\\uDC47\\n\\ntranspose = column become row and vice versa!\\n \\nso suppose if a (non transpose) 2d matrix initialized like that : int array[] = new int [matrix.length] [matrix[0].length} (its  a normal 2d array which goes rows then column ) (first row then column).\\n\\nbut in transpose you have to create a opposite array like : int[][] ans =new int [matrix[0].length][matrix.length];  (column and row ) (in it you can store or can say transpose your normal array)\\n\\nthan iterate via for loop and fill each  elements form \"matrix\"to your new transpose \"array\" which is like \\narray [ j ][ i ]  = matrix [ i ][ j ]      \\n\\nNote : bc you created earlier a transpose array thats why array[ j ] (column) then [ i ] row happend ,and it tranpose."
                    },
                    {
                        "username": "bdoodo",
                        "content": "Please do not use this in an interview hahaha\\n\\n`var transpose = matrix => matrix[0].map((row, index) => matrix.map(matRow => matRow[index]))`\\n\\nCreated from a joint effort with [@indigoarthur](https://leetcode.com/indigoarthur/)"
                    },
                    {
                        "username": "Adonis21",
                        "content": "I have tried without creating a new array, and instead tried to replace the values, but it is giving me error, but when i tried same thing in my local IDE, its working perfectly fine. Any suggesstion someone might have?"
                    },
                    {
                        "username": "ChNihar",
                        "content": "[@Adonis21](/Adonis21) In transpose a 3*2 matrix will become 2*3 matrix so You have to create a new array as per my observation."
                    },
                    {
                        "username": "kerku",
                        "content": "[@Adonis21](/Adonis21)  i was thinking about completing this w/o creating a new arr, but faced w/ the same issue :) maybe one of the option could be creation of a new array in if statement, when it\\'s not possible to return correct answer with in the same array, and processing the same matrix when it is a square one? but this is just for fun)"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Probably you could try this approach  - https://leetcode.com/problems/transpose-matrix/solutions/3172907/transposing-in-place-python-a-funny-solution/"
                    },
                    {
                        "username": "Adonis21",
                        "content": "Got it, it would not work for matrixes that are not square matrix. So, is there not any solution without making a new matrix?"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int temp;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int  j = i ; j < n ; j++)\\n            {\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\nWhat\\'s the error in this code?\\n(giving runtime error)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "[@user8698Xs](/user8698Xs) because matrix does not have same number of rows and column"
                    },
                    {
                        "username": "vitaliynovak555",
                        "content": "I also wrote similar code, and caught an error when accessing an array element. The problem does not specify that the matrix has the same number of rows and columns, so this is the problem."
                    },
                    {
                        "username": "user8698Xs",
                        "content": "actually this will return the matrix itself, because every element is swapped twice i.e. once  a[i][j] with a[j][i] and vice versa...\nu can put an if ststement to swap only the elemnts of upper triangular matix or lower triangular\n\nI'm also getting runtime error, don't know why!\n\n\nclass Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n\n        int row= matrix.size();\n        int col= matrix[0].size();\n\n        for(int i= 0; i<row ; i++)\n        {\n            for(int j=0; j<col; j++)\n            {\n                if(j>i) // ****************add this condition**************\n                {\n                   swap( matrix[i][j],  matrix[j][i]);\n\n                }\n            }\n        }\n\n        return matrix;\n        \n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "JarJuicy",
                        "content": "return zip(*A)"
                    },
                    {
                        "username": "robin316709150",
                        "content": "`return (zip(*A))`"
                    },
                    {
                        "username": "leetcode_oye_hoye",
                        "content": "Won\\'t swapping the variables not work?"
                    },
                    {
                        "username": "suriyasuresh2507",
                        "content": "yenda dei ithellam oru easy question ah da\\n"
                    }
                ]
            },
            {
                "id": 1775237,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/transpose-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Copy Directly\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  int [][] ans =new int [matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length ;i++){\\n            for(int j=0 ;j<matrix[i].length;j++){\\n                ans[j][i]=matrix[i][j];\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "_slaay_069",
                        "content": "this\\'ll work only for m x m matrix"
                    },
                    {
                        "username": "pratikyadav8319",
                        "content": "first you need to now what transpose means , than 2nd step create a transpose empty array so that you can store your matrix (normal array) into transpose array its pretty simple\\n\\nlet me  break down here \\uD83D\\uDC47\\n\\ntranspose = column become row and vice versa!\\n \\nso suppose if a (non transpose) 2d matrix initialized like that : int array[] = new int [matrix.length] [matrix[0].length} (its  a normal 2d array which goes rows then column ) (first row then column).\\n\\nbut in transpose you have to create a opposite array like : int[][] ans =new int [matrix[0].length][matrix.length];  (column and row ) (in it you can store or can say transpose your normal array)\\n\\nthan iterate via for loop and fill each  elements form \"matrix\"to your new transpose \"array\" which is like \\narray [ j ][ i ]  = matrix [ i ][ j ]      \\n\\nNote : bc you created earlier a transpose array thats why array[ j ] (column) then [ i ] row happend ,and it tranpose."
                    },
                    {
                        "username": "bdoodo",
                        "content": "Please do not use this in an interview hahaha\\n\\n`var transpose = matrix => matrix[0].map((row, index) => matrix.map(matRow => matRow[index]))`\\n\\nCreated from a joint effort with [@indigoarthur](https://leetcode.com/indigoarthur/)"
                    },
                    {
                        "username": "Adonis21",
                        "content": "I have tried without creating a new array, and instead tried to replace the values, but it is giving me error, but when i tried same thing in my local IDE, its working perfectly fine. Any suggesstion someone might have?"
                    },
                    {
                        "username": "ChNihar",
                        "content": "[@Adonis21](/Adonis21) In transpose a 3*2 matrix will become 2*3 matrix so You have to create a new array as per my observation."
                    },
                    {
                        "username": "kerku",
                        "content": "[@Adonis21](/Adonis21)  i was thinking about completing this w/o creating a new arr, but faced w/ the same issue :) maybe one of the option could be creation of a new array in if statement, when it\\'s not possible to return correct answer with in the same array, and processing the same matrix when it is a square one? but this is just for fun)"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Probably you could try this approach  - https://leetcode.com/problems/transpose-matrix/solutions/3172907/transposing-in-place-python-a-funny-solution/"
                    },
                    {
                        "username": "Adonis21",
                        "content": "Got it, it would not work for matrixes that are not square matrix. So, is there not any solution without making a new matrix?"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int temp;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int  j = i ; j < n ; j++)\\n            {\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\nWhat\\'s the error in this code?\\n(giving runtime error)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "[@user8698Xs](/user8698Xs) because matrix does not have same number of rows and column"
                    },
                    {
                        "username": "vitaliynovak555",
                        "content": "I also wrote similar code, and caught an error when accessing an array element. The problem does not specify that the matrix has the same number of rows and columns, so this is the problem."
                    },
                    {
                        "username": "user8698Xs",
                        "content": "actually this will return the matrix itself, because every element is swapped twice i.e. once  a[i][j] with a[j][i] and vice versa...\nu can put an if ststement to swap only the elemnts of upper triangular matix or lower triangular\n\nI'm also getting runtime error, don't know why!\n\n\nclass Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n\n        int row= matrix.size();\n        int col= matrix[0].size();\n\n        for(int i= 0; i<row ; i++)\n        {\n            for(int j=0; j<col; j++)\n            {\n                if(j>i) // ****************add this condition**************\n                {\n                   swap( matrix[i][j],  matrix[j][i]);\n\n                }\n            }\n        }\n\n        return matrix;\n        \n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "JarJuicy",
                        "content": "return zip(*A)"
                    },
                    {
                        "username": "robin316709150",
                        "content": "`return (zip(*A))`"
                    },
                    {
                        "username": "leetcode_oye_hoye",
                        "content": "Won\\'t swapping the variables not work?"
                    },
                    {
                        "username": "suriyasuresh2507",
                        "content": "yenda dei ithellam oru easy question ah da\\n"
                    }
                ]
            },
            {
                "id": 1573474,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/transpose-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Copy Directly\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  int [][] ans =new int [matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length ;i++){\\n            for(int j=0 ;j<matrix[i].length;j++){\\n                ans[j][i]=matrix[i][j];\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "_slaay_069",
                        "content": "this\\'ll work only for m x m matrix"
                    },
                    {
                        "username": "pratikyadav8319",
                        "content": "first you need to now what transpose means , than 2nd step create a transpose empty array so that you can store your matrix (normal array) into transpose array its pretty simple\\n\\nlet me  break down here \\uD83D\\uDC47\\n\\ntranspose = column become row and vice versa!\\n \\nso suppose if a (non transpose) 2d matrix initialized like that : int array[] = new int [matrix.length] [matrix[0].length} (its  a normal 2d array which goes rows then column ) (first row then column).\\n\\nbut in transpose you have to create a opposite array like : int[][] ans =new int [matrix[0].length][matrix.length];  (column and row ) (in it you can store or can say transpose your normal array)\\n\\nthan iterate via for loop and fill each  elements form \"matrix\"to your new transpose \"array\" which is like \\narray [ j ][ i ]  = matrix [ i ][ j ]      \\n\\nNote : bc you created earlier a transpose array thats why array[ j ] (column) then [ i ] row happend ,and it tranpose."
                    },
                    {
                        "username": "bdoodo",
                        "content": "Please do not use this in an interview hahaha\\n\\n`var transpose = matrix => matrix[0].map((row, index) => matrix.map(matRow => matRow[index]))`\\n\\nCreated from a joint effort with [@indigoarthur](https://leetcode.com/indigoarthur/)"
                    },
                    {
                        "username": "Adonis21",
                        "content": "I have tried without creating a new array, and instead tried to replace the values, but it is giving me error, but when i tried same thing in my local IDE, its working perfectly fine. Any suggesstion someone might have?"
                    },
                    {
                        "username": "ChNihar",
                        "content": "[@Adonis21](/Adonis21) In transpose a 3*2 matrix will become 2*3 matrix so You have to create a new array as per my observation."
                    },
                    {
                        "username": "kerku",
                        "content": "[@Adonis21](/Adonis21)  i was thinking about completing this w/o creating a new arr, but faced w/ the same issue :) maybe one of the option could be creation of a new array in if statement, when it\\'s not possible to return correct answer with in the same array, and processing the same matrix when it is a square one? but this is just for fun)"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Probably you could try this approach  - https://leetcode.com/problems/transpose-matrix/solutions/3172907/transposing-in-place-python-a-funny-solution/"
                    },
                    {
                        "username": "Adonis21",
                        "content": "Got it, it would not work for matrixes that are not square matrix. So, is there not any solution without making a new matrix?"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int temp;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int  j = i ; j < n ; j++)\\n            {\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\nWhat\\'s the error in this code?\\n(giving runtime error)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "[@user8698Xs](/user8698Xs) because matrix does not have same number of rows and column"
                    },
                    {
                        "username": "vitaliynovak555",
                        "content": "I also wrote similar code, and caught an error when accessing an array element. The problem does not specify that the matrix has the same number of rows and columns, so this is the problem."
                    },
                    {
                        "username": "user8698Xs",
                        "content": "actually this will return the matrix itself, because every element is swapped twice i.e. once  a[i][j] with a[j][i] and vice versa...\nu can put an if ststement to swap only the elemnts of upper triangular matix or lower triangular\n\nI'm also getting runtime error, don't know why!\n\n\nclass Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n\n        int row= matrix.size();\n        int col= matrix[0].size();\n\n        for(int i= 0; i<row ; i++)\n        {\n            for(int j=0; j<col; j++)\n            {\n                if(j>i) // ****************add this condition**************\n                {\n                   swap( matrix[i][j],  matrix[j][i]);\n\n                }\n            }\n        }\n\n        return matrix;\n        \n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "JarJuicy",
                        "content": "return zip(*A)"
                    },
                    {
                        "username": "robin316709150",
                        "content": "`return (zip(*A))`"
                    },
                    {
                        "username": "leetcode_oye_hoye",
                        "content": "Won\\'t swapping the variables not work?"
                    },
                    {
                        "username": "suriyasuresh2507",
                        "content": "yenda dei ithellam oru easy question ah da\\n"
                    }
                ]
            },
            {
                "id": 1574838,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/transpose-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Copy Directly\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  int [][] ans =new int [matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length ;i++){\\n            for(int j=0 ;j<matrix[i].length;j++){\\n                ans[j][i]=matrix[i][j];\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "_slaay_069",
                        "content": "this\\'ll work only for m x m matrix"
                    },
                    {
                        "username": "pratikyadav8319",
                        "content": "first you need to now what transpose means , than 2nd step create a transpose empty array so that you can store your matrix (normal array) into transpose array its pretty simple\\n\\nlet me  break down here \\uD83D\\uDC47\\n\\ntranspose = column become row and vice versa!\\n \\nso suppose if a (non transpose) 2d matrix initialized like that : int array[] = new int [matrix.length] [matrix[0].length} (its  a normal 2d array which goes rows then column ) (first row then column).\\n\\nbut in transpose you have to create a opposite array like : int[][] ans =new int [matrix[0].length][matrix.length];  (column and row ) (in it you can store or can say transpose your normal array)\\n\\nthan iterate via for loop and fill each  elements form \"matrix\"to your new transpose \"array\" which is like \\narray [ j ][ i ]  = matrix [ i ][ j ]      \\n\\nNote : bc you created earlier a transpose array thats why array[ j ] (column) then [ i ] row happend ,and it tranpose."
                    },
                    {
                        "username": "bdoodo",
                        "content": "Please do not use this in an interview hahaha\\n\\n`var transpose = matrix => matrix[0].map((row, index) => matrix.map(matRow => matRow[index]))`\\n\\nCreated from a joint effort with [@indigoarthur](https://leetcode.com/indigoarthur/)"
                    },
                    {
                        "username": "Adonis21",
                        "content": "I have tried without creating a new array, and instead tried to replace the values, but it is giving me error, but when i tried same thing in my local IDE, its working perfectly fine. Any suggesstion someone might have?"
                    },
                    {
                        "username": "ChNihar",
                        "content": "[@Adonis21](/Adonis21) In transpose a 3*2 matrix will become 2*3 matrix so You have to create a new array as per my observation."
                    },
                    {
                        "username": "kerku",
                        "content": "[@Adonis21](/Adonis21)  i was thinking about completing this w/o creating a new arr, but faced w/ the same issue :) maybe one of the option could be creation of a new array in if statement, when it\\'s not possible to return correct answer with in the same array, and processing the same matrix when it is a square one? but this is just for fun)"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Probably you could try this approach  - https://leetcode.com/problems/transpose-matrix/solutions/3172907/transposing-in-place-python-a-funny-solution/"
                    },
                    {
                        "username": "Adonis21",
                        "content": "Got it, it would not work for matrixes that are not square matrix. So, is there not any solution without making a new matrix?"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int temp;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int  j = i ; j < n ; j++)\\n            {\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\nWhat\\'s the error in this code?\\n(giving runtime error)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "[@user8698Xs](/user8698Xs) because matrix does not have same number of rows and column"
                    },
                    {
                        "username": "vitaliynovak555",
                        "content": "I also wrote similar code, and caught an error when accessing an array element. The problem does not specify that the matrix has the same number of rows and columns, so this is the problem."
                    },
                    {
                        "username": "user8698Xs",
                        "content": "actually this will return the matrix itself, because every element is swapped twice i.e. once  a[i][j] with a[j][i] and vice versa...\nu can put an if ststement to swap only the elemnts of upper triangular matix or lower triangular\n\nI'm also getting runtime error, don't know why!\n\n\nclass Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n\n        int row= matrix.size();\n        int col= matrix[0].size();\n\n        for(int i= 0; i<row ; i++)\n        {\n            for(int j=0; j<col; j++)\n            {\n                if(j>i) // ****************add this condition**************\n                {\n                   swap( matrix[i][j],  matrix[j][i]);\n\n                }\n            }\n        }\n\n        return matrix;\n        \n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "JarJuicy",
                        "content": "return zip(*A)"
                    },
                    {
                        "username": "robin316709150",
                        "content": "`return (zip(*A))`"
                    },
                    {
                        "username": "leetcode_oye_hoye",
                        "content": "Won\\'t swapping the variables not work?"
                    },
                    {
                        "username": "suriyasuresh2507",
                        "content": "yenda dei ithellam oru easy question ah da\\n"
                    }
                ]
            },
            {
                "id": 2053573,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/transpose-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Copy Directly\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  int [][] ans =new int [matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length ;i++){\\n            for(int j=0 ;j<matrix[i].length;j++){\\n                ans[j][i]=matrix[i][j];\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "_slaay_069",
                        "content": "this\\'ll work only for m x m matrix"
                    },
                    {
                        "username": "pratikyadav8319",
                        "content": "first you need to now what transpose means , than 2nd step create a transpose empty array so that you can store your matrix (normal array) into transpose array its pretty simple\\n\\nlet me  break down here \\uD83D\\uDC47\\n\\ntranspose = column become row and vice versa!\\n \\nso suppose if a (non transpose) 2d matrix initialized like that : int array[] = new int [matrix.length] [matrix[0].length} (its  a normal 2d array which goes rows then column ) (first row then column).\\n\\nbut in transpose you have to create a opposite array like : int[][] ans =new int [matrix[0].length][matrix.length];  (column and row ) (in it you can store or can say transpose your normal array)\\n\\nthan iterate via for loop and fill each  elements form \"matrix\"to your new transpose \"array\" which is like \\narray [ j ][ i ]  = matrix [ i ][ j ]      \\n\\nNote : bc you created earlier a transpose array thats why array[ j ] (column) then [ i ] row happend ,and it tranpose."
                    },
                    {
                        "username": "bdoodo",
                        "content": "Please do not use this in an interview hahaha\\n\\n`var transpose = matrix => matrix[0].map((row, index) => matrix.map(matRow => matRow[index]))`\\n\\nCreated from a joint effort with [@indigoarthur](https://leetcode.com/indigoarthur/)"
                    },
                    {
                        "username": "Adonis21",
                        "content": "I have tried without creating a new array, and instead tried to replace the values, but it is giving me error, but when i tried same thing in my local IDE, its working perfectly fine. Any suggesstion someone might have?"
                    },
                    {
                        "username": "ChNihar",
                        "content": "[@Adonis21](/Adonis21) In transpose a 3*2 matrix will become 2*3 matrix so You have to create a new array as per my observation."
                    },
                    {
                        "username": "kerku",
                        "content": "[@Adonis21](/Adonis21)  i was thinking about completing this w/o creating a new arr, but faced w/ the same issue :) maybe one of the option could be creation of a new array in if statement, when it\\'s not possible to return correct answer with in the same array, and processing the same matrix when it is a square one? but this is just for fun)"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Probably you could try this approach  - https://leetcode.com/problems/transpose-matrix/solutions/3172907/transposing-in-place-python-a-funny-solution/"
                    },
                    {
                        "username": "Adonis21",
                        "content": "Got it, it would not work for matrixes that are not square matrix. So, is there not any solution without making a new matrix?"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int temp;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int  j = i ; j < n ; j++)\\n            {\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\nWhat\\'s the error in this code?\\n(giving runtime error)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "[@user8698Xs](/user8698Xs) because matrix does not have same number of rows and column"
                    },
                    {
                        "username": "vitaliynovak555",
                        "content": "I also wrote similar code, and caught an error when accessing an array element. The problem does not specify that the matrix has the same number of rows and columns, so this is the problem."
                    },
                    {
                        "username": "user8698Xs",
                        "content": "actually this will return the matrix itself, because every element is swapped twice i.e. once  a[i][j] with a[j][i] and vice versa...\nu can put an if ststement to swap only the elemnts of upper triangular matix or lower triangular\n\nI'm also getting runtime error, don't know why!\n\n\nclass Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n\n        int row= matrix.size();\n        int col= matrix[0].size();\n\n        for(int i= 0; i<row ; i++)\n        {\n            for(int j=0; j<col; j++)\n            {\n                if(j>i) // ****************add this condition**************\n                {\n                   swap( matrix[i][j],  matrix[j][i]);\n\n                }\n            }\n        }\n\n        return matrix;\n        \n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "JarJuicy",
                        "content": "return zip(*A)"
                    },
                    {
                        "username": "robin316709150",
                        "content": "`return (zip(*A))`"
                    },
                    {
                        "username": "leetcode_oye_hoye",
                        "content": "Won\\'t swapping the variables not work?"
                    },
                    {
                        "username": "suriyasuresh2507",
                        "content": "yenda dei ithellam oru easy question ah da\\n"
                    }
                ]
            },
            {
                "id": 2040398,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/transpose-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Copy Directly\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  int [][] ans =new int [matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length ;i++){\\n            for(int j=0 ;j<matrix[i].length;j++){\\n                ans[j][i]=matrix[i][j];\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "_slaay_069",
                        "content": "this\\'ll work only for m x m matrix"
                    },
                    {
                        "username": "pratikyadav8319",
                        "content": "first you need to now what transpose means , than 2nd step create a transpose empty array so that you can store your matrix (normal array) into transpose array its pretty simple\\n\\nlet me  break down here \\uD83D\\uDC47\\n\\ntranspose = column become row and vice versa!\\n \\nso suppose if a (non transpose) 2d matrix initialized like that : int array[] = new int [matrix.length] [matrix[0].length} (its  a normal 2d array which goes rows then column ) (first row then column).\\n\\nbut in transpose you have to create a opposite array like : int[][] ans =new int [matrix[0].length][matrix.length];  (column and row ) (in it you can store or can say transpose your normal array)\\n\\nthan iterate via for loop and fill each  elements form \"matrix\"to your new transpose \"array\" which is like \\narray [ j ][ i ]  = matrix [ i ][ j ]      \\n\\nNote : bc you created earlier a transpose array thats why array[ j ] (column) then [ i ] row happend ,and it tranpose."
                    },
                    {
                        "username": "bdoodo",
                        "content": "Please do not use this in an interview hahaha\\n\\n`var transpose = matrix => matrix[0].map((row, index) => matrix.map(matRow => matRow[index]))`\\n\\nCreated from a joint effort with [@indigoarthur](https://leetcode.com/indigoarthur/)"
                    },
                    {
                        "username": "Adonis21",
                        "content": "I have tried without creating a new array, and instead tried to replace the values, but it is giving me error, but when i tried same thing in my local IDE, its working perfectly fine. Any suggesstion someone might have?"
                    },
                    {
                        "username": "ChNihar",
                        "content": "[@Adonis21](/Adonis21) In transpose a 3*2 matrix will become 2*3 matrix so You have to create a new array as per my observation."
                    },
                    {
                        "username": "kerku",
                        "content": "[@Adonis21](/Adonis21)  i was thinking about completing this w/o creating a new arr, but faced w/ the same issue :) maybe one of the option could be creation of a new array in if statement, when it\\'s not possible to return correct answer with in the same array, and processing the same matrix when it is a square one? but this is just for fun)"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Probably you could try this approach  - https://leetcode.com/problems/transpose-matrix/solutions/3172907/transposing-in-place-python-a-funny-solution/"
                    },
                    {
                        "username": "Adonis21",
                        "content": "Got it, it would not work for matrixes that are not square matrix. So, is there not any solution without making a new matrix?"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int temp;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int  j = i ; j < n ; j++)\\n            {\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\nWhat\\'s the error in this code?\\n(giving runtime error)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "[@user8698Xs](/user8698Xs) because matrix does not have same number of rows and column"
                    },
                    {
                        "username": "vitaliynovak555",
                        "content": "I also wrote similar code, and caught an error when accessing an array element. The problem does not specify that the matrix has the same number of rows and columns, so this is the problem."
                    },
                    {
                        "username": "user8698Xs",
                        "content": "actually this will return the matrix itself, because every element is swapped twice i.e. once  a[i][j] with a[j][i] and vice versa...\nu can put an if ststement to swap only the elemnts of upper triangular matix or lower triangular\n\nI'm also getting runtime error, don't know why!\n\n\nclass Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n\n        int row= matrix.size();\n        int col= matrix[0].size();\n\n        for(int i= 0; i<row ; i++)\n        {\n            for(int j=0; j<col; j++)\n            {\n                if(j>i) // ****************add this condition**************\n                {\n                   swap( matrix[i][j],  matrix[j][i]);\n\n                }\n            }\n        }\n\n        return matrix;\n        \n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "JarJuicy",
                        "content": "return zip(*A)"
                    },
                    {
                        "username": "robin316709150",
                        "content": "`return (zip(*A))`"
                    },
                    {
                        "username": "leetcode_oye_hoye",
                        "content": "Won\\'t swapping the variables not work?"
                    },
                    {
                        "username": "suriyasuresh2507",
                        "content": "yenda dei ithellam oru easy question ah da\\n"
                    }
                ]
            },
            {
                "id": 1565818,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/transpose-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Copy Directly\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  int [][] ans =new int [matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length ;i++){\\n            for(int j=0 ;j<matrix[i].length;j++){\\n                ans[j][i]=matrix[i][j];\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "_slaay_069",
                        "content": "this\\'ll work only for m x m matrix"
                    },
                    {
                        "username": "pratikyadav8319",
                        "content": "first you need to now what transpose means , than 2nd step create a transpose empty array so that you can store your matrix (normal array) into transpose array its pretty simple\\n\\nlet me  break down here \\uD83D\\uDC47\\n\\ntranspose = column become row and vice versa!\\n \\nso suppose if a (non transpose) 2d matrix initialized like that : int array[] = new int [matrix.length] [matrix[0].length} (its  a normal 2d array which goes rows then column ) (first row then column).\\n\\nbut in transpose you have to create a opposite array like : int[][] ans =new int [matrix[0].length][matrix.length];  (column and row ) (in it you can store or can say transpose your normal array)\\n\\nthan iterate via for loop and fill each  elements form \"matrix\"to your new transpose \"array\" which is like \\narray [ j ][ i ]  = matrix [ i ][ j ]      \\n\\nNote : bc you created earlier a transpose array thats why array[ j ] (column) then [ i ] row happend ,and it tranpose."
                    },
                    {
                        "username": "bdoodo",
                        "content": "Please do not use this in an interview hahaha\\n\\n`var transpose = matrix => matrix[0].map((row, index) => matrix.map(matRow => matRow[index]))`\\n\\nCreated from a joint effort with [@indigoarthur](https://leetcode.com/indigoarthur/)"
                    },
                    {
                        "username": "Adonis21",
                        "content": "I have tried without creating a new array, and instead tried to replace the values, but it is giving me error, but when i tried same thing in my local IDE, its working perfectly fine. Any suggesstion someone might have?"
                    },
                    {
                        "username": "ChNihar",
                        "content": "[@Adonis21](/Adonis21) In transpose a 3*2 matrix will become 2*3 matrix so You have to create a new array as per my observation."
                    },
                    {
                        "username": "kerku",
                        "content": "[@Adonis21](/Adonis21)  i was thinking about completing this w/o creating a new arr, but faced w/ the same issue :) maybe one of the option could be creation of a new array in if statement, when it\\'s not possible to return correct answer with in the same array, and processing the same matrix when it is a square one? but this is just for fun)"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Probably you could try this approach  - https://leetcode.com/problems/transpose-matrix/solutions/3172907/transposing-in-place-python-a-funny-solution/"
                    },
                    {
                        "username": "Adonis21",
                        "content": "Got it, it would not work for matrixes that are not square matrix. So, is there not any solution without making a new matrix?"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int temp;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int  j = i ; j < n ; j++)\\n            {\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\nWhat\\'s the error in this code?\\n(giving runtime error)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "[@user8698Xs](/user8698Xs) because matrix does not have same number of rows and column"
                    },
                    {
                        "username": "vitaliynovak555",
                        "content": "I also wrote similar code, and caught an error when accessing an array element. The problem does not specify that the matrix has the same number of rows and columns, so this is the problem."
                    },
                    {
                        "username": "user8698Xs",
                        "content": "actually this will return the matrix itself, because every element is swapped twice i.e. once  a[i][j] with a[j][i] and vice versa...\nu can put an if ststement to swap only the elemnts of upper triangular matix or lower triangular\n\nI'm also getting runtime error, don't know why!\n\n\nclass Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n\n        int row= matrix.size();\n        int col= matrix[0].size();\n\n        for(int i= 0; i<row ; i++)\n        {\n            for(int j=0; j<col; j++)\n            {\n                if(j>i) // ****************add this condition**************\n                {\n                   swap( matrix[i][j],  matrix[j][i]);\n\n                }\n            }\n        }\n\n        return matrix;\n        \n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "JarJuicy",
                        "content": "return zip(*A)"
                    },
                    {
                        "username": "robin316709150",
                        "content": "`return (zip(*A))`"
                    },
                    {
                        "username": "leetcode_oye_hoye",
                        "content": "Won\\'t swapping the variables not work?"
                    },
                    {
                        "username": "suriyasuresh2507",
                        "content": "yenda dei ithellam oru easy question ah da\\n"
                    }
                ]
            },
            {
                "id": 1736476,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/transpose-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Copy Directly\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  int [][] ans =new int [matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length ;i++){\\n            for(int j=0 ;j<matrix[i].length;j++){\\n                ans[j][i]=matrix[i][j];\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "_slaay_069",
                        "content": "this\\'ll work only for m x m matrix"
                    },
                    {
                        "username": "pratikyadav8319",
                        "content": "first you need to now what transpose means , than 2nd step create a transpose empty array so that you can store your matrix (normal array) into transpose array its pretty simple\\n\\nlet me  break down here \\uD83D\\uDC47\\n\\ntranspose = column become row and vice versa!\\n \\nso suppose if a (non transpose) 2d matrix initialized like that : int array[] = new int [matrix.length] [matrix[0].length} (its  a normal 2d array which goes rows then column ) (first row then column).\\n\\nbut in transpose you have to create a opposite array like : int[][] ans =new int [matrix[0].length][matrix.length];  (column and row ) (in it you can store or can say transpose your normal array)\\n\\nthan iterate via for loop and fill each  elements form \"matrix\"to your new transpose \"array\" which is like \\narray [ j ][ i ]  = matrix [ i ][ j ]      \\n\\nNote : bc you created earlier a transpose array thats why array[ j ] (column) then [ i ] row happend ,and it tranpose."
                    },
                    {
                        "username": "bdoodo",
                        "content": "Please do not use this in an interview hahaha\\n\\n`var transpose = matrix => matrix[0].map((row, index) => matrix.map(matRow => matRow[index]))`\\n\\nCreated from a joint effort with [@indigoarthur](https://leetcode.com/indigoarthur/)"
                    },
                    {
                        "username": "Adonis21",
                        "content": "I have tried without creating a new array, and instead tried to replace the values, but it is giving me error, but when i tried same thing in my local IDE, its working perfectly fine. Any suggesstion someone might have?"
                    },
                    {
                        "username": "ChNihar",
                        "content": "[@Adonis21](/Adonis21) In transpose a 3*2 matrix will become 2*3 matrix so You have to create a new array as per my observation."
                    },
                    {
                        "username": "kerku",
                        "content": "[@Adonis21](/Adonis21)  i was thinking about completing this w/o creating a new arr, but faced w/ the same issue :) maybe one of the option could be creation of a new array in if statement, when it\\'s not possible to return correct answer with in the same array, and processing the same matrix when it is a square one? but this is just for fun)"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Probably you could try this approach  - https://leetcode.com/problems/transpose-matrix/solutions/3172907/transposing-in-place-python-a-funny-solution/"
                    },
                    {
                        "username": "Adonis21",
                        "content": "Got it, it would not work for matrixes that are not square matrix. So, is there not any solution without making a new matrix?"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int temp;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int  j = i ; j < n ; j++)\\n            {\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\nWhat\\'s the error in this code?\\n(giving runtime error)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "[@user8698Xs](/user8698Xs) because matrix does not have same number of rows and column"
                    },
                    {
                        "username": "vitaliynovak555",
                        "content": "I also wrote similar code, and caught an error when accessing an array element. The problem does not specify that the matrix has the same number of rows and columns, so this is the problem."
                    },
                    {
                        "username": "user8698Xs",
                        "content": "actually this will return the matrix itself, because every element is swapped twice i.e. once  a[i][j] with a[j][i] and vice versa...\nu can put an if ststement to swap only the elemnts of upper triangular matix or lower triangular\n\nI'm also getting runtime error, don't know why!\n\n\nclass Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n\n        int row= matrix.size();\n        int col= matrix[0].size();\n\n        for(int i= 0; i<row ; i++)\n        {\n            for(int j=0; j<col; j++)\n            {\n                if(j>i) // ****************add this condition**************\n                {\n                   swap( matrix[i][j],  matrix[j][i]);\n\n                }\n            }\n        }\n\n        return matrix;\n        \n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "JarJuicy",
                        "content": "return zip(*A)"
                    },
                    {
                        "username": "robin316709150",
                        "content": "`return (zip(*A))`"
                    },
                    {
                        "username": "leetcode_oye_hoye",
                        "content": "Won\\'t swapping the variables not work?"
                    },
                    {
                        "username": "suriyasuresh2507",
                        "content": "yenda dei ithellam oru easy question ah da\\n"
                    }
                ]
            },
            {
                "id": 1973956,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/transpose-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Copy Directly\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  int [][] ans =new int [matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length ;i++){\\n            for(int j=0 ;j<matrix[i].length;j++){\\n                ans[j][i]=matrix[i][j];\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "_slaay_069",
                        "content": "this\\'ll work only for m x m matrix"
                    },
                    {
                        "username": "pratikyadav8319",
                        "content": "first you need to now what transpose means , than 2nd step create a transpose empty array so that you can store your matrix (normal array) into transpose array its pretty simple\\n\\nlet me  break down here \\uD83D\\uDC47\\n\\ntranspose = column become row and vice versa!\\n \\nso suppose if a (non transpose) 2d matrix initialized like that : int array[] = new int [matrix.length] [matrix[0].length} (its  a normal 2d array which goes rows then column ) (first row then column).\\n\\nbut in transpose you have to create a opposite array like : int[][] ans =new int [matrix[0].length][matrix.length];  (column and row ) (in it you can store or can say transpose your normal array)\\n\\nthan iterate via for loop and fill each  elements form \"matrix\"to your new transpose \"array\" which is like \\narray [ j ][ i ]  = matrix [ i ][ j ]      \\n\\nNote : bc you created earlier a transpose array thats why array[ j ] (column) then [ i ] row happend ,and it tranpose."
                    },
                    {
                        "username": "bdoodo",
                        "content": "Please do not use this in an interview hahaha\\n\\n`var transpose = matrix => matrix[0].map((row, index) => matrix.map(matRow => matRow[index]))`\\n\\nCreated from a joint effort with [@indigoarthur](https://leetcode.com/indigoarthur/)"
                    },
                    {
                        "username": "Adonis21",
                        "content": "I have tried without creating a new array, and instead tried to replace the values, but it is giving me error, but when i tried same thing in my local IDE, its working perfectly fine. Any suggesstion someone might have?"
                    },
                    {
                        "username": "ChNihar",
                        "content": "[@Adonis21](/Adonis21) In transpose a 3*2 matrix will become 2*3 matrix so You have to create a new array as per my observation."
                    },
                    {
                        "username": "kerku",
                        "content": "[@Adonis21](/Adonis21)  i was thinking about completing this w/o creating a new arr, but faced w/ the same issue :) maybe one of the option could be creation of a new array in if statement, when it\\'s not possible to return correct answer with in the same array, and processing the same matrix when it is a square one? but this is just for fun)"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Probably you could try this approach  - https://leetcode.com/problems/transpose-matrix/solutions/3172907/transposing-in-place-python-a-funny-solution/"
                    },
                    {
                        "username": "Adonis21",
                        "content": "Got it, it would not work for matrixes that are not square matrix. So, is there not any solution without making a new matrix?"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int temp;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int  j = i ; j < n ; j++)\\n            {\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\nWhat\\'s the error in this code?\\n(giving runtime error)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "[@user8698Xs](/user8698Xs) because matrix does not have same number of rows and column"
                    },
                    {
                        "username": "vitaliynovak555",
                        "content": "I also wrote similar code, and caught an error when accessing an array element. The problem does not specify that the matrix has the same number of rows and columns, so this is the problem."
                    },
                    {
                        "username": "user8698Xs",
                        "content": "actually this will return the matrix itself, because every element is swapped twice i.e. once  a[i][j] with a[j][i] and vice versa...\nu can put an if ststement to swap only the elemnts of upper triangular matix or lower triangular\n\nI'm also getting runtime error, don't know why!\n\n\nclass Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n\n        int row= matrix.size();\n        int col= matrix[0].size();\n\n        for(int i= 0; i<row ; i++)\n        {\n            for(int j=0; j<col; j++)\n            {\n                if(j>i) // ****************add this condition**************\n                {\n                   swap( matrix[i][j],  matrix[j][i]);\n\n                }\n            }\n        }\n\n        return matrix;\n        \n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "JarJuicy",
                        "content": "return zip(*A)"
                    },
                    {
                        "username": "robin316709150",
                        "content": "`return (zip(*A))`"
                    },
                    {
                        "username": "leetcode_oye_hoye",
                        "content": "Won\\'t swapping the variables not work?"
                    },
                    {
                        "username": "suriyasuresh2507",
                        "content": "yenda dei ithellam oru easy question ah da\\n"
                    }
                ]
            },
            {
                "id": 1576361,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/transpose-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Copy Directly\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  int [][] ans =new int [matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length ;i++){\\n            for(int j=0 ;j<matrix[i].length;j++){\\n                ans[j][i]=matrix[i][j];\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "_slaay_069",
                        "content": "this\\'ll work only for m x m matrix"
                    },
                    {
                        "username": "pratikyadav8319",
                        "content": "first you need to now what transpose means , than 2nd step create a transpose empty array so that you can store your matrix (normal array) into transpose array its pretty simple\\n\\nlet me  break down here \\uD83D\\uDC47\\n\\ntranspose = column become row and vice versa!\\n \\nso suppose if a (non transpose) 2d matrix initialized like that : int array[] = new int [matrix.length] [matrix[0].length} (its  a normal 2d array which goes rows then column ) (first row then column).\\n\\nbut in transpose you have to create a opposite array like : int[][] ans =new int [matrix[0].length][matrix.length];  (column and row ) (in it you can store or can say transpose your normal array)\\n\\nthan iterate via for loop and fill each  elements form \"matrix\"to your new transpose \"array\" which is like \\narray [ j ][ i ]  = matrix [ i ][ j ]      \\n\\nNote : bc you created earlier a transpose array thats why array[ j ] (column) then [ i ] row happend ,and it tranpose."
                    },
                    {
                        "username": "bdoodo",
                        "content": "Please do not use this in an interview hahaha\\n\\n`var transpose = matrix => matrix[0].map((row, index) => matrix.map(matRow => matRow[index]))`\\n\\nCreated from a joint effort with [@indigoarthur](https://leetcode.com/indigoarthur/)"
                    },
                    {
                        "username": "Adonis21",
                        "content": "I have tried without creating a new array, and instead tried to replace the values, but it is giving me error, but when i tried same thing in my local IDE, its working perfectly fine. Any suggesstion someone might have?"
                    },
                    {
                        "username": "ChNihar",
                        "content": "[@Adonis21](/Adonis21) In transpose a 3*2 matrix will become 2*3 matrix so You have to create a new array as per my observation."
                    },
                    {
                        "username": "kerku",
                        "content": "[@Adonis21](/Adonis21)  i was thinking about completing this w/o creating a new arr, but faced w/ the same issue :) maybe one of the option could be creation of a new array in if statement, when it\\'s not possible to return correct answer with in the same array, and processing the same matrix when it is a square one? but this is just for fun)"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Probably you could try this approach  - https://leetcode.com/problems/transpose-matrix/solutions/3172907/transposing-in-place-python-a-funny-solution/"
                    },
                    {
                        "username": "Adonis21",
                        "content": "Got it, it would not work for matrixes that are not square matrix. So, is there not any solution without making a new matrix?"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int temp;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int  j = i ; j < n ; j++)\\n            {\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\nWhat\\'s the error in this code?\\n(giving runtime error)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "[@user8698Xs](/user8698Xs) because matrix does not have same number of rows and column"
                    },
                    {
                        "username": "vitaliynovak555",
                        "content": "I also wrote similar code, and caught an error when accessing an array element. The problem does not specify that the matrix has the same number of rows and columns, so this is the problem."
                    },
                    {
                        "username": "user8698Xs",
                        "content": "actually this will return the matrix itself, because every element is swapped twice i.e. once  a[i][j] with a[j][i] and vice versa...\nu can put an if ststement to swap only the elemnts of upper triangular matix or lower triangular\n\nI'm also getting runtime error, don't know why!\n\n\nclass Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n\n        int row= matrix.size();\n        int col= matrix[0].size();\n\n        for(int i= 0; i<row ; i++)\n        {\n            for(int j=0; j<col; j++)\n            {\n                if(j>i) // ****************add this condition**************\n                {\n                   swap( matrix[i][j],  matrix[j][i]);\n\n                }\n            }\n        }\n\n        return matrix;\n        \n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "JarJuicy",
                        "content": "return zip(*A)"
                    },
                    {
                        "username": "robin316709150",
                        "content": "`return (zip(*A))`"
                    },
                    {
                        "username": "leetcode_oye_hoye",
                        "content": "Won\\'t swapping the variables not work?"
                    },
                    {
                        "username": "suriyasuresh2507",
                        "content": "yenda dei ithellam oru easy question ah da\\n"
                    }
                ]
            },
            {
                "id": 1796701,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/transpose-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Copy Directly\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  int [][] ans =new int [matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length ;i++){\\n            for(int j=0 ;j<matrix[i].length;j++){\\n                ans[j][i]=matrix[i][j];\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "_slaay_069",
                        "content": "this\\'ll work only for m x m matrix"
                    },
                    {
                        "username": "pratikyadav8319",
                        "content": "first you need to now what transpose means , than 2nd step create a transpose empty array so that you can store your matrix (normal array) into transpose array its pretty simple\\n\\nlet me  break down here \\uD83D\\uDC47\\n\\ntranspose = column become row and vice versa!\\n \\nso suppose if a (non transpose) 2d matrix initialized like that : int array[] = new int [matrix.length] [matrix[0].length} (its  a normal 2d array which goes rows then column ) (first row then column).\\n\\nbut in transpose you have to create a opposite array like : int[][] ans =new int [matrix[0].length][matrix.length];  (column and row ) (in it you can store or can say transpose your normal array)\\n\\nthan iterate via for loop and fill each  elements form \"matrix\"to your new transpose \"array\" which is like \\narray [ j ][ i ]  = matrix [ i ][ j ]      \\n\\nNote : bc you created earlier a transpose array thats why array[ j ] (column) then [ i ] row happend ,and it tranpose."
                    },
                    {
                        "username": "bdoodo",
                        "content": "Please do not use this in an interview hahaha\\n\\n`var transpose = matrix => matrix[0].map((row, index) => matrix.map(matRow => matRow[index]))`\\n\\nCreated from a joint effort with [@indigoarthur](https://leetcode.com/indigoarthur/)"
                    },
                    {
                        "username": "Adonis21",
                        "content": "I have tried without creating a new array, and instead tried to replace the values, but it is giving me error, but when i tried same thing in my local IDE, its working perfectly fine. Any suggesstion someone might have?"
                    },
                    {
                        "username": "ChNihar",
                        "content": "[@Adonis21](/Adonis21) In transpose a 3*2 matrix will become 2*3 matrix so You have to create a new array as per my observation."
                    },
                    {
                        "username": "kerku",
                        "content": "[@Adonis21](/Adonis21)  i was thinking about completing this w/o creating a new arr, but faced w/ the same issue :) maybe one of the option could be creation of a new array in if statement, when it\\'s not possible to return correct answer with in the same array, and processing the same matrix when it is a square one? but this is just for fun)"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Probably you could try this approach  - https://leetcode.com/problems/transpose-matrix/solutions/3172907/transposing-in-place-python-a-funny-solution/"
                    },
                    {
                        "username": "Adonis21",
                        "content": "Got it, it would not work for matrixes that are not square matrix. So, is there not any solution without making a new matrix?"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int temp;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int  j = i ; j < n ; j++)\\n            {\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\nWhat\\'s the error in this code?\\n(giving runtime error)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "[@user8698Xs](/user8698Xs) because matrix does not have same number of rows and column"
                    },
                    {
                        "username": "vitaliynovak555",
                        "content": "I also wrote similar code, and caught an error when accessing an array element. The problem does not specify that the matrix has the same number of rows and columns, so this is the problem."
                    },
                    {
                        "username": "user8698Xs",
                        "content": "actually this will return the matrix itself, because every element is swapped twice i.e. once  a[i][j] with a[j][i] and vice versa...\nu can put an if ststement to swap only the elemnts of upper triangular matix or lower triangular\n\nI'm also getting runtime error, don't know why!\n\n\nclass Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n\n        int row= matrix.size();\n        int col= matrix[0].size();\n\n        for(int i= 0; i<row ; i++)\n        {\n            for(int j=0; j<col; j++)\n            {\n                if(j>i) // ****************add this condition**************\n                {\n                   swap( matrix[i][j],  matrix[j][i]);\n\n                }\n            }\n        }\n\n        return matrix;\n        \n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "JarJuicy",
                        "content": "return zip(*A)"
                    },
                    {
                        "username": "robin316709150",
                        "content": "`return (zip(*A))`"
                    },
                    {
                        "username": "leetcode_oye_hoye",
                        "content": "Won\\'t swapping the variables not work?"
                    },
                    {
                        "username": "suriyasuresh2507",
                        "content": "yenda dei ithellam oru easy question ah da\\n"
                    }
                ]
            },
            {
                "id": 1775237,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/transpose-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Copy Directly\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  int [][] ans =new int [matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length ;i++){\\n            for(int j=0 ;j<matrix[i].length;j++){\\n                ans[j][i]=matrix[i][j];\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "_slaay_069",
                        "content": "this\\'ll work only for m x m matrix"
                    },
                    {
                        "username": "pratikyadav8319",
                        "content": "first you need to now what transpose means , than 2nd step create a transpose empty array so that you can store your matrix (normal array) into transpose array its pretty simple\\n\\nlet me  break down here \\uD83D\\uDC47\\n\\ntranspose = column become row and vice versa!\\n \\nso suppose if a (non transpose) 2d matrix initialized like that : int array[] = new int [matrix.length] [matrix[0].length} (its  a normal 2d array which goes rows then column ) (first row then column).\\n\\nbut in transpose you have to create a opposite array like : int[][] ans =new int [matrix[0].length][matrix.length];  (column and row ) (in it you can store or can say transpose your normal array)\\n\\nthan iterate via for loop and fill each  elements form \"matrix\"to your new transpose \"array\" which is like \\narray [ j ][ i ]  = matrix [ i ][ j ]      \\n\\nNote : bc you created earlier a transpose array thats why array[ j ] (column) then [ i ] row happend ,and it tranpose."
                    },
                    {
                        "username": "bdoodo",
                        "content": "Please do not use this in an interview hahaha\\n\\n`var transpose = matrix => matrix[0].map((row, index) => matrix.map(matRow => matRow[index]))`\\n\\nCreated from a joint effort with [@indigoarthur](https://leetcode.com/indigoarthur/)"
                    },
                    {
                        "username": "Adonis21",
                        "content": "I have tried without creating a new array, and instead tried to replace the values, but it is giving me error, but when i tried same thing in my local IDE, its working perfectly fine. Any suggesstion someone might have?"
                    },
                    {
                        "username": "ChNihar",
                        "content": "[@Adonis21](/Adonis21) In transpose a 3*2 matrix will become 2*3 matrix so You have to create a new array as per my observation."
                    },
                    {
                        "username": "kerku",
                        "content": "[@Adonis21](/Adonis21)  i was thinking about completing this w/o creating a new arr, but faced w/ the same issue :) maybe one of the option could be creation of a new array in if statement, when it\\'s not possible to return correct answer with in the same array, and processing the same matrix when it is a square one? but this is just for fun)"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Probably you could try this approach  - https://leetcode.com/problems/transpose-matrix/solutions/3172907/transposing-in-place-python-a-funny-solution/"
                    },
                    {
                        "username": "Adonis21",
                        "content": "Got it, it would not work for matrixes that are not square matrix. So, is there not any solution without making a new matrix?"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int temp;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int  j = i ; j < n ; j++)\\n            {\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\nWhat\\'s the error in this code?\\n(giving runtime error)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "[@user8698Xs](/user8698Xs) because matrix does not have same number of rows and column"
                    },
                    {
                        "username": "vitaliynovak555",
                        "content": "I also wrote similar code, and caught an error when accessing an array element. The problem does not specify that the matrix has the same number of rows and columns, so this is the problem."
                    },
                    {
                        "username": "user8698Xs",
                        "content": "actually this will return the matrix itself, because every element is swapped twice i.e. once  a[i][j] with a[j][i] and vice versa...\nu can put an if ststement to swap only the elemnts of upper triangular matix or lower triangular\n\nI'm also getting runtime error, don't know why!\n\n\nclass Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n\n        int row= matrix.size();\n        int col= matrix[0].size();\n\n        for(int i= 0; i<row ; i++)\n        {\n            for(int j=0; j<col; j++)\n            {\n                if(j>i) // ****************add this condition**************\n                {\n                   swap( matrix[i][j],  matrix[j][i]);\n\n                }\n            }\n        }\n\n        return matrix;\n        \n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "JarJuicy",
                        "content": "return zip(*A)"
                    },
                    {
                        "username": "robin316709150",
                        "content": "`return (zip(*A))`"
                    },
                    {
                        "username": "leetcode_oye_hoye",
                        "content": "Won\\'t swapping the variables not work?"
                    },
                    {
                        "username": "suriyasuresh2507",
                        "content": "yenda dei ithellam oru easy question ah da\\n"
                    }
                ]
            },
            {
                "id": 1573474,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/transpose-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Copy Directly\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  int [][] ans =new int [matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length ;i++){\\n            for(int j=0 ;j<matrix[i].length;j++){\\n                ans[j][i]=matrix[i][j];\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "_slaay_069",
                        "content": "this\\'ll work only for m x m matrix"
                    },
                    {
                        "username": "pratikyadav8319",
                        "content": "first you need to now what transpose means , than 2nd step create a transpose empty array so that you can store your matrix (normal array) into transpose array its pretty simple\\n\\nlet me  break down here \\uD83D\\uDC47\\n\\ntranspose = column become row and vice versa!\\n \\nso suppose if a (non transpose) 2d matrix initialized like that : int array[] = new int [matrix.length] [matrix[0].length} (its  a normal 2d array which goes rows then column ) (first row then column).\\n\\nbut in transpose you have to create a opposite array like : int[][] ans =new int [matrix[0].length][matrix.length];  (column and row ) (in it you can store or can say transpose your normal array)\\n\\nthan iterate via for loop and fill each  elements form \"matrix\"to your new transpose \"array\" which is like \\narray [ j ][ i ]  = matrix [ i ][ j ]      \\n\\nNote : bc you created earlier a transpose array thats why array[ j ] (column) then [ i ] row happend ,and it tranpose."
                    },
                    {
                        "username": "bdoodo",
                        "content": "Please do not use this in an interview hahaha\\n\\n`var transpose = matrix => matrix[0].map((row, index) => matrix.map(matRow => matRow[index]))`\\n\\nCreated from a joint effort with [@indigoarthur](https://leetcode.com/indigoarthur/)"
                    },
                    {
                        "username": "Adonis21",
                        "content": "I have tried without creating a new array, and instead tried to replace the values, but it is giving me error, but when i tried same thing in my local IDE, its working perfectly fine. Any suggesstion someone might have?"
                    },
                    {
                        "username": "ChNihar",
                        "content": "[@Adonis21](/Adonis21) In transpose a 3*2 matrix will become 2*3 matrix so You have to create a new array as per my observation."
                    },
                    {
                        "username": "kerku",
                        "content": "[@Adonis21](/Adonis21)  i was thinking about completing this w/o creating a new arr, but faced w/ the same issue :) maybe one of the option could be creation of a new array in if statement, when it\\'s not possible to return correct answer with in the same array, and processing the same matrix when it is a square one? but this is just for fun)"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Probably you could try this approach  - https://leetcode.com/problems/transpose-matrix/solutions/3172907/transposing-in-place-python-a-funny-solution/"
                    },
                    {
                        "username": "Adonis21",
                        "content": "Got it, it would not work for matrixes that are not square matrix. So, is there not any solution without making a new matrix?"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int temp;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int  j = i ; j < n ; j++)\\n            {\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\nWhat\\'s the error in this code?\\n(giving runtime error)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "[@user8698Xs](/user8698Xs) because matrix does not have same number of rows and column"
                    },
                    {
                        "username": "vitaliynovak555",
                        "content": "I also wrote similar code, and caught an error when accessing an array element. The problem does not specify that the matrix has the same number of rows and columns, so this is the problem."
                    },
                    {
                        "username": "user8698Xs",
                        "content": "actually this will return the matrix itself, because every element is swapped twice i.e. once  a[i][j] with a[j][i] and vice versa...\nu can put an if ststement to swap only the elemnts of upper triangular matix or lower triangular\n\nI'm also getting runtime error, don't know why!\n\n\nclass Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n\n        int row= matrix.size();\n        int col= matrix[0].size();\n\n        for(int i= 0; i<row ; i++)\n        {\n            for(int j=0; j<col; j++)\n            {\n                if(j>i) // ****************add this condition**************\n                {\n                   swap( matrix[i][j],  matrix[j][i]);\n\n                }\n            }\n        }\n\n        return matrix;\n        \n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "JarJuicy",
                        "content": "return zip(*A)"
                    },
                    {
                        "username": "robin316709150",
                        "content": "`return (zip(*A))`"
                    },
                    {
                        "username": "leetcode_oye_hoye",
                        "content": "Won\\'t swapping the variables not work?"
                    },
                    {
                        "username": "suriyasuresh2507",
                        "content": "yenda dei ithellam oru easy question ah da\\n"
                    }
                ]
            },
            {
                "id": 1574838,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/transpose-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Copy Directly\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  int [][] ans =new int [matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length ;i++){\\n            for(int j=0 ;j<matrix[i].length;j++){\\n                ans[j][i]=matrix[i][j];\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "_slaay_069",
                        "content": "this\\'ll work only for m x m matrix"
                    },
                    {
                        "username": "pratikyadav8319",
                        "content": "first you need to now what transpose means , than 2nd step create a transpose empty array so that you can store your matrix (normal array) into transpose array its pretty simple\\n\\nlet me  break down here \\uD83D\\uDC47\\n\\ntranspose = column become row and vice versa!\\n \\nso suppose if a (non transpose) 2d matrix initialized like that : int array[] = new int [matrix.length] [matrix[0].length} (its  a normal 2d array which goes rows then column ) (first row then column).\\n\\nbut in transpose you have to create a opposite array like : int[][] ans =new int [matrix[0].length][matrix.length];  (column and row ) (in it you can store or can say transpose your normal array)\\n\\nthan iterate via for loop and fill each  elements form \"matrix\"to your new transpose \"array\" which is like \\narray [ j ][ i ]  = matrix [ i ][ j ]      \\n\\nNote : bc you created earlier a transpose array thats why array[ j ] (column) then [ i ] row happend ,and it tranpose."
                    },
                    {
                        "username": "bdoodo",
                        "content": "Please do not use this in an interview hahaha\\n\\n`var transpose = matrix => matrix[0].map((row, index) => matrix.map(matRow => matRow[index]))`\\n\\nCreated from a joint effort with [@indigoarthur](https://leetcode.com/indigoarthur/)"
                    },
                    {
                        "username": "Adonis21",
                        "content": "I have tried without creating a new array, and instead tried to replace the values, but it is giving me error, but when i tried same thing in my local IDE, its working perfectly fine. Any suggesstion someone might have?"
                    },
                    {
                        "username": "ChNihar",
                        "content": "[@Adonis21](/Adonis21) In transpose a 3*2 matrix will become 2*3 matrix so You have to create a new array as per my observation."
                    },
                    {
                        "username": "kerku",
                        "content": "[@Adonis21](/Adonis21)  i was thinking about completing this w/o creating a new arr, but faced w/ the same issue :) maybe one of the option could be creation of a new array in if statement, when it\\'s not possible to return correct answer with in the same array, and processing the same matrix when it is a square one? but this is just for fun)"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Probably you could try this approach  - https://leetcode.com/problems/transpose-matrix/solutions/3172907/transposing-in-place-python-a-funny-solution/"
                    },
                    {
                        "username": "Adonis21",
                        "content": "Got it, it would not work for matrixes that are not square matrix. So, is there not any solution without making a new matrix?"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int temp;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int  j = i ; j < n ; j++)\\n            {\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\nWhat\\'s the error in this code?\\n(giving runtime error)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "[@user8698Xs](/user8698Xs) because matrix does not have same number of rows and column"
                    },
                    {
                        "username": "vitaliynovak555",
                        "content": "I also wrote similar code, and caught an error when accessing an array element. The problem does not specify that the matrix has the same number of rows and columns, so this is the problem."
                    },
                    {
                        "username": "user8698Xs",
                        "content": "actually this will return the matrix itself, because every element is swapped twice i.e. once  a[i][j] with a[j][i] and vice versa...\nu can put an if ststement to swap only the elemnts of upper triangular matix or lower triangular\n\nI'm also getting runtime error, don't know why!\n\n\nclass Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n\n        int row= matrix.size();\n        int col= matrix[0].size();\n\n        for(int i= 0; i<row ; i++)\n        {\n            for(int j=0; j<col; j++)\n            {\n                if(j>i) // ****************add this condition**************\n                {\n                   swap( matrix[i][j],  matrix[j][i]);\n\n                }\n            }\n        }\n\n        return matrix;\n        \n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "JarJuicy",
                        "content": "return zip(*A)"
                    },
                    {
                        "username": "robin316709150",
                        "content": "`return (zip(*A))`"
                    },
                    {
                        "username": "leetcode_oye_hoye",
                        "content": "Won\\'t swapping the variables not work?"
                    },
                    {
                        "username": "suriyasuresh2507",
                        "content": "yenda dei ithellam oru easy question ah da\\n"
                    }
                ]
            },
            {
                "id": 2053573,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/transpose-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Copy Directly\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  int [][] ans =new int [matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length ;i++){\\n            for(int j=0 ;j<matrix[i].length;j++){\\n                ans[j][i]=matrix[i][j];\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "_slaay_069",
                        "content": "this\\'ll work only for m x m matrix"
                    },
                    {
                        "username": "pratikyadav8319",
                        "content": "first you need to now what transpose means , than 2nd step create a transpose empty array so that you can store your matrix (normal array) into transpose array its pretty simple\\n\\nlet me  break down here \\uD83D\\uDC47\\n\\ntranspose = column become row and vice versa!\\n \\nso suppose if a (non transpose) 2d matrix initialized like that : int array[] = new int [matrix.length] [matrix[0].length} (its  a normal 2d array which goes rows then column ) (first row then column).\\n\\nbut in transpose you have to create a opposite array like : int[][] ans =new int [matrix[0].length][matrix.length];  (column and row ) (in it you can store or can say transpose your normal array)\\n\\nthan iterate via for loop and fill each  elements form \"matrix\"to your new transpose \"array\" which is like \\narray [ j ][ i ]  = matrix [ i ][ j ]      \\n\\nNote : bc you created earlier a transpose array thats why array[ j ] (column) then [ i ] row happend ,and it tranpose."
                    },
                    {
                        "username": "bdoodo",
                        "content": "Please do not use this in an interview hahaha\\n\\n`var transpose = matrix => matrix[0].map((row, index) => matrix.map(matRow => matRow[index]))`\\n\\nCreated from a joint effort with [@indigoarthur](https://leetcode.com/indigoarthur/)"
                    },
                    {
                        "username": "Adonis21",
                        "content": "I have tried without creating a new array, and instead tried to replace the values, but it is giving me error, but when i tried same thing in my local IDE, its working perfectly fine. Any suggesstion someone might have?"
                    },
                    {
                        "username": "ChNihar",
                        "content": "[@Adonis21](/Adonis21) In transpose a 3*2 matrix will become 2*3 matrix so You have to create a new array as per my observation."
                    },
                    {
                        "username": "kerku",
                        "content": "[@Adonis21](/Adonis21)  i was thinking about completing this w/o creating a new arr, but faced w/ the same issue :) maybe one of the option could be creation of a new array in if statement, when it\\'s not possible to return correct answer with in the same array, and processing the same matrix when it is a square one? but this is just for fun)"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Probably you could try this approach  - https://leetcode.com/problems/transpose-matrix/solutions/3172907/transposing-in-place-python-a-funny-solution/"
                    },
                    {
                        "username": "Adonis21",
                        "content": "Got it, it would not work for matrixes that are not square matrix. So, is there not any solution without making a new matrix?"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int temp;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int  j = i ; j < n ; j++)\\n            {\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\nWhat\\'s the error in this code?\\n(giving runtime error)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "[@user8698Xs](/user8698Xs) because matrix does not have same number of rows and column"
                    },
                    {
                        "username": "vitaliynovak555",
                        "content": "I also wrote similar code, and caught an error when accessing an array element. The problem does not specify that the matrix has the same number of rows and columns, so this is the problem."
                    },
                    {
                        "username": "user8698Xs",
                        "content": "actually this will return the matrix itself, because every element is swapped twice i.e. once  a[i][j] with a[j][i] and vice versa...\nu can put an if ststement to swap only the elemnts of upper triangular matix or lower triangular\n\nI'm also getting runtime error, don't know why!\n\n\nclass Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n\n        int row= matrix.size();\n        int col= matrix[0].size();\n\n        for(int i= 0; i<row ; i++)\n        {\n            for(int j=0; j<col; j++)\n            {\n                if(j>i) // ****************add this condition**************\n                {\n                   swap( matrix[i][j],  matrix[j][i]);\n\n                }\n            }\n        }\n\n        return matrix;\n        \n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "JarJuicy",
                        "content": "return zip(*A)"
                    },
                    {
                        "username": "robin316709150",
                        "content": "`return (zip(*A))`"
                    },
                    {
                        "username": "leetcode_oye_hoye",
                        "content": "Won\\'t swapping the variables not work?"
                    },
                    {
                        "username": "suriyasuresh2507",
                        "content": "yenda dei ithellam oru easy question ah da\\n"
                    }
                ]
            },
            {
                "id": 2040398,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/transpose-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Copy Directly\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  int [][] ans =new int [matrix[0].length][matrix.length];\\n        for(int i=0;i<matrix.length ;i++){\\n            for(int j=0 ;j<matrix[i].length;j++){\\n                ans[j][i]=matrix[i][j];\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "_slaay_069",
                        "content": "this\\'ll work only for m x m matrix"
                    },
                    {
                        "username": "pratikyadav8319",
                        "content": "first you need to now what transpose means , than 2nd step create a transpose empty array so that you can store your matrix (normal array) into transpose array its pretty simple\\n\\nlet me  break down here \\uD83D\\uDC47\\n\\ntranspose = column become row and vice versa!\\n \\nso suppose if a (non transpose) 2d matrix initialized like that : int array[] = new int [matrix.length] [matrix[0].length} (its  a normal 2d array which goes rows then column ) (first row then column).\\n\\nbut in transpose you have to create a opposite array like : int[][] ans =new int [matrix[0].length][matrix.length];  (column and row ) (in it you can store or can say transpose your normal array)\\n\\nthan iterate via for loop and fill each  elements form \"matrix\"to your new transpose \"array\" which is like \\narray [ j ][ i ]  = matrix [ i ][ j ]      \\n\\nNote : bc you created earlier a transpose array thats why array[ j ] (column) then [ i ] row happend ,and it tranpose."
                    },
                    {
                        "username": "bdoodo",
                        "content": "Please do not use this in an interview hahaha\\n\\n`var transpose = matrix => matrix[0].map((row, index) => matrix.map(matRow => matRow[index]))`\\n\\nCreated from a joint effort with [@indigoarthur](https://leetcode.com/indigoarthur/)"
                    },
                    {
                        "username": "Adonis21",
                        "content": "I have tried without creating a new array, and instead tried to replace the values, but it is giving me error, but when i tried same thing in my local IDE, its working perfectly fine. Any suggesstion someone might have?"
                    },
                    {
                        "username": "ChNihar",
                        "content": "[@Adonis21](/Adonis21) In transpose a 3*2 matrix will become 2*3 matrix so You have to create a new array as per my observation."
                    },
                    {
                        "username": "kerku",
                        "content": "[@Adonis21](/Adonis21)  i was thinking about completing this w/o creating a new arr, but faced w/ the same issue :) maybe one of the option could be creation of a new array in if statement, when it\\'s not possible to return correct answer with in the same array, and processing the same matrix when it is a square one? but this is just for fun)"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Probably you could try this approach  - https://leetcode.com/problems/transpose-matrix/solutions/3172907/transposing-in-place-python-a-funny-solution/"
                    },
                    {
                        "username": "Adonis21",
                        "content": "Got it, it would not work for matrixes that are not square matrix. So, is there not any solution without making a new matrix?"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int temp;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int  j = i ; j < n ; j++)\\n            {\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\nWhat\\'s the error in this code?\\n(giving runtime error)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "[@user8698Xs](/user8698Xs) because matrix does not have same number of rows and column"
                    },
                    {
                        "username": "vitaliynovak555",
                        "content": "I also wrote similar code, and caught an error when accessing an array element. The problem does not specify that the matrix has the same number of rows and columns, so this is the problem."
                    },
                    {
                        "username": "user8698Xs",
                        "content": "actually this will return the matrix itself, because every element is swapped twice i.e. once  a[i][j] with a[j][i] and vice versa...\nu can put an if ststement to swap only the elemnts of upper triangular matix or lower triangular\n\nI'm also getting runtime error, don't know why!\n\n\nclass Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n\n        int row= matrix.size();\n        int col= matrix[0].size();\n\n        for(int i= 0; i<row ; i++)\n        {\n            for(int j=0; j<col; j++)\n            {\n                if(j>i) // ****************add this condition**************\n                {\n                   swap( matrix[i][j],  matrix[j][i]);\n\n                }\n            }\n        }\n\n        return matrix;\n        \n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "JarJuicy",
                        "content": "return zip(*A)"
                    },
                    {
                        "username": "robin316709150",
                        "content": "`return (zip(*A))`"
                    },
                    {
                        "username": "leetcode_oye_hoye",
                        "content": "Won\\'t swapping the variables not work?"
                    },
                    {
                        "username": "suriyasuresh2507",
                        "content": "yenda dei ithellam oru easy question ah da\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Subarray Sums Divisible by K",
        "question_content": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the number of non-empty <strong>subarrays</strong> that have a sum divisible by </em><code>k</code>.</p>\n\n<p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,5,0,-2,-3,1], k = 5\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> There are 7 subarrays with a sum divisible by k = 5:\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5], k = 9\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>2 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 413234,
                "title": "whiteboard-explanation",
                "content": "Ok, here comes a \"digestible\" solution for this problem as I\\'ve been struggling with It for quite some time myself.\\n\\nThe key point is utilising Prefix Sum, the accumulative sum of the elements from the beginning of the array. Let us suppose we have an array with numbered elements. and K is the given number \\n\\n![image](https://assets.leetcode.com/users/georgechryso/image_1572022726.png)\\n\\nwhere\\n\\t\\t\\t![image](https://assets.leetcode.com/users/georgechryso/image_1572023089.png)\\n\\nAs you can see, If the remainders of i and j are equal (ri=rj)   the subarray from i to j has a remainder of 0, which means It\\'s the type of subarrays we\\'re looking for. But why though? \\nHere follows the mathematical proof utilising a known formula (1). \\n![image](https://assets.leetcode.com/users/georgechryso/image_1572023360.png)\\n\\n**The idea:**\\n\\nKnowing the above way of recognizing a required subarrray, we can simply traverse the given array from left to right , looking for remainders I\\'ve already seen in the past.\\nIf I come across a remainder I\\'ve already seen, that means that the subarray inbetween is of the required type and therefore needs to be counted. \\n\\n**The implementation:**\\n\\nAs I need to remember the remainder seen so far, I m gonna have to create some sort of a dictionary (fancy hash map) in order to keep track of them. \\n**However** the information that I ve seen a remainder in the past is not enough for the solution of this problem and here\\'s why.\\n\\nLet\\'s say I have an array.  Assuming my case of finding equal remainders is fulfilled, let\\'s observe the schema that follows. \\n![image](https://assets.leetcode.com/users/georgechryso/image_1572024236.png)\\nAs you can see, **r1=r2=r**\\n\\n\\nWhen I reach ri, my algorithm should be able to increment the total count of the wanted subarrays by 1, as my condition of equal remainders is fulfilled. \\n\\n**However**,\\n\\n![image](https://assets.leetcode.com/users/georgechryso/image_1572024740.png)\\n\\nwhen aj is reached you see that the total count of wanted subarrays grows immediately to 3. Therefore incrementing by one would be incorrect, as 2 new wanted subarrays are met during this step. \\nWhat needs to happen here is that the dictionary shouldn\\'t just store the remainder, but the times we\\'ve seen that remainder in the past. \\nLet us then denote with freq an array that stores the frequency of the remainders. As for the remainders themselves, they are already stored as the indices of the array. Let me demonstrate.\\n\\n![image](https://assets.leetcode.com/users/georgechryso/image_1572025240.png)\\n\\nConsidering the possible values a remainder  can have ( modulo K ) , this is a very helpful way of storing key:value pairs. \\nSo if K=2 , possible remainders can be 0,1\\nLikewise if K=5 possible remainders can be 0,1,2,3,4\\nTherefore an array with K elements will be just what I need. \\n\\n**\"But why do I need the damn frequencies?\"** you might ask.\\nRemember that in the previous image, when I met rj, I needed to increment my count by 2?\\nTurns out that the number that I need to increment my counter with **is the frequency of the remainder at its previous step**.  \\nLet\\'s demonstrate that in further detail: \\n\\n![image](https://assets.leetcode.com/users/georgechryso/image_1572025655.png)\\n\\nNotice how on each step, 2 things need to occur:\\n1. \\tThe counter needs to be incremented **accordingly**\\n2. \\tThe frequency has to be incremented by one\\n\\nBut what is \"**accordingly**\"? If you watch how the counter progresses with each step, you will realise that It increments by the last frrequency of the given remainder. \\n\\n![image](https://assets.leetcode.com/users/georgechryso/image_1572026284.png)\\n\\nstep 4\\'s counter is 6. As you can see It increased by 3, which is obviously the frequency of the last step. Generalising on the n\\'th step we have:  \\n\\n![image](https://assets.leetcode.com/users/georgechryso/image_1572026409.png)\\n\\n\\n**So let\\'s write some code.**\\n \\n \\n```\\nvar subarraysDivByK = function(A, K) {\\n\\n    let freq = new Array(K).fill(0); // \"moduloK : Times I\\'ve seen it so far\"\\n\\n\\n    freq[0]=1 //  Explained below\\n\\n    // This is the accumulative sum of the elements of A\\n    let sum = 0;\\n\\n    // The count of wanted subarrays, whose Sum%K= zero\\n    let count=0;\\n\\n    for(let i = 0; i < A.length; i++){\\n\\n        sum=sum+A[i]\\n\\n\\n        var remainder= sum%K\\n\\n        //ALWAYS CHOOSE THE POSITIVE REMAINDER\\n        if(remainder<0)remainder+=K // Explained below\\n\\n\\n        count+=freq[remainder]\\n\\n        freq[remainder]++\\n    }\\n    return count\\n    \\n\\n};\\n```\\n**freq[0]=1 EXPLANATION**\\n\\n![image](https://assets.leetcode.com/users/georgechryso/image_1572026928.png)\\n\\n\\nConsider this case. It\\'s my first time meeting a remainder that equals zero. But wait, doesn\\'t that mean that my subarray\\'s sum is Divisible by K? If freq[0]!=1 then my counter wouldn\\'t increment the first time I met a remainder=0. Therefore I need freq[0]=1 in order for my counter to consider the first subarray with a remainder that equals to zero. \\n\\n\\n**NEGATIVE REMAINDER EXPLANATION**\\n\\n![image](https://assets.leetcode.com/users/georgechryso/image_1572027266.png)\\n\\n**TLDR :** The division of a negative number by a positive can yield positive and negative remainders. Some languages allow negative remainders, that\\'s no bueno. In order for me to ensure I m taking the correct remainder, I\\'m adding K to the negative one, which always yields me the appropriate positive remainder. ( Read up on Euclidean division for more info/ proof)\\n\\n**\"But do I really need to do that ?\"** you may ask. \\nHere\\'s a quick example of what would happen if I allowed negative remainders.\\n![image](https://assets.leetcode.com/users/georgechryso/image_1572027646.png)\\n\\n-1!=1, so my condition wouldnt trigger, and the counter wouldnt increment even though [5,5] is a subarray with a sum divisble by 2  . \\n\\nSorry for the long post, hope I cleared up the topic. \\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```\\nvar subarraysDivByK = function(A, K) {\\n\\n    let freq = new Array(K).fill(0); // \"moduloK : Times I\\'ve seen it so far\"\\n\\n\\n    freq[0]=1 //  Explained below\\n\\n    // This is the accumulative sum of the elements of A\\n    let sum = 0;\\n\\n    // The count of wanted subarrays, whose Sum%K= zero\\n    let count=0;\\n\\n    for(let i = 0; i < A.length; i++){\\n\\n        sum=sum+A[i]\\n\\n\\n        var remainder= sum%K\\n\\n        //ALWAYS CHOOSE THE POSITIVE REMAINDER\\n        if(remainder<0)remainder+=K // Explained below\\n\\n\\n        count+=freq[remainder]\\n\\n        freq[remainder]++\\n    }\\n    return count\\n    \\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 217980,
                "title": "java-o-n-with-hashmap-and-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] A, int K) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        int count = 0, sum = 0;\\n        for(int a : A) {\\n            sum = (sum + a) % K;\\n            if(sum < 0) sum += K;  // Because -1 % 5 = -1, but we need the positive mod 4\\n            count += map.getOrDefault(sum, 0);\\n            map.put(sum, map.getOrDefault(sum, 0) + 1);\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\nAbout the problems - sum of contiguous subarray , prefix sum is a common technique. \\nAnother thing is if sum[0, i] % K == sum[0, j] % K, sum[i + 1, j] is divisible by by K.\\nSo for current index j, we need to find out how many index i (i < j) exit that has the same mod of K.\\nNow it easy to come up with HashMap <mod, frequency>\\n\\nTime Complexity: O(N)\\nSpace Complexity: O(K)\\n\\n------------------------------------\\nAs @davidluoyes Comments, we can just use array, which is faster than HashMap.\\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] A, int K) {\\n        int[] map = new int[K];\\n\\t\\tmap[0] = 1;\\n        int count = 0, sum = 0;\\n        for(int a : A) {\\n            sum = (sum + a) % K;\\n            if(sum < 0) sum += K;  // Because -1 % 5 = -1, but we need the positive mod 4\\n            count += map[sum];\\n            map[sum]++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] A, int K) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        int count = 0, sum = 0;\\n        for(int a : A) {\\n            sum = (sum + a) % K;\\n            if(sum < 0) sum += K;  // Because -1 % 5 = -1, but we need the positive mod 4\\n            count += map.getOrDefault(sum, 0);\\n            map.put(sum, map.getOrDefault(sum, 0) + 1);\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] A, int K) {\\n        int[] map = new int[K];\\n\\t\\tmap[0] = 1;\\n        int count = 0, sum = 0;\\n        for(int a : A) {\\n            sum = (sum + a) % K;\\n            if(sum < 0) sum += K;  // Because -1 % 5 = -1, but we need the positive mod 4\\n            count += map[sum];\\n            map[sum]++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 217985,
                "title": "java-c-python-prefix-sum",
                "content": "Calculate the prefix sum and count it.\\nIn c++ and java, `a % K + K` takes care of the cases where `a < 0`.\\n\\n**Java, use HashMap**\\n```\\n    public int subarraysDivByK(int[] A, int K) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        count.put(0, 1);\\n        int prefix = 0, res = 0;\\n        for (int a : A) {\\n            prefix = (prefix + a % K + K) % K;\\n            res += count.getOrDefault(prefix, 0);\\n            count.put(prefix, count.getOrDefault(prefix, 0) + 1);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java, Use Array**\\n```\\n    public int subarraysDivByK(int[] A, int K) {\\n        int[] count = new int[K];\\n        count[0] = 1;\\n        int prefix = 0, res = 0;\\n        for (int a : A) {\\n            prefix = (prefix + a % K + K) % K;\\n            res += count[prefix]++;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++\\uFF0CUsing vecotor:**\\n```\\n    int subarraysDivByK(vector<int>& A, int K) {\\n        vector<int> count(K);\\n        count[0] = 1;\\n        int prefix = 0, res = 0;\\n        for (int a : A) {\\n            prefix = (prefix + a % K + K) % K;\\n            res += count[prefix]++;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```\\n    def subarraysDivByK(self, A, K):\\n        res = 0\\n        prefix = 0\\n        count = [1] + [0] * K\\n        for a in A:\\n            prefix = (prefix + a) % K\\n            res += count[prefix]\\n            count[prefix] += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    public int subarraysDivByK(int[] A, int K) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        count.put(0, 1);\\n        int prefix = 0, res = 0;\\n        for (int a : A) {\\n            prefix = (prefix + a % K + K) % K;\\n            res += count.getOrDefault(prefix, 0);\\n            count.put(prefix, count.getOrDefault(prefix, 0) + 1);\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int subarraysDivByK(int[] A, int K) {\\n        int[] count = new int[K];\\n        count[0] = 1;\\n        int prefix = 0, res = 0;\\n        for (int a : A) {\\n            prefix = (prefix + a % K + K) % K;\\n            res += count[prefix]++;\\n        }\\n        return res;\\n    }\\n```\n```\\n    int subarraysDivByK(vector<int>& A, int K) {\\n        vector<int> count(K);\\n        count[0] = 1;\\n        int prefix = 0, res = 0;\\n        for (int a : A) {\\n            prefix = (prefix + a % K + K) % K;\\n            res += count[prefix]++;\\n        }\\n        return res;\\n    }\\n```\n```\\n    def subarraysDivByK(self, A, K):\\n        res = 0\\n        prefix = 0\\n        count = [1] + [0] * K\\n        for a in A:\\n            prefix = (prefix + a) % K\\n            res += count[prefix]\\n            count[prefix] += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 217962,
                "title": "java-clean-o-n-number-theory-prefix-sums",
                "content": "**Logic:**\\nI am already going to assume that you know about prefix sums before you read this.\\nWe can all agree that for an array int[] A, where N = len(A), that there are N prefix sums.\\nprefix[0] = A[0], prefix[1] = A[0] + A[1],  ... prefix[i] = A[0] + ... + A[i].\\n\\nThen to calculate how many subarrays are divisible by K is logically equivalent to saying, how many ways can we pair up all prefix sum pairs (i,j) where i < j \\nsuch that (prefix[j] - prefix[i]) % K == 0.\\n\\nJust from that information alone we easily get a O(n^2) solution.\\nCompute all prefix sums, then check all pair to see if k divides the  difference between them.\\n\\nHowever, if we just exploit some information w.r.t to the remainder of each prefix sum we can manipulate this into a linear algorithm. Here\\'s how.\\n\\n**Number Theory Part**\\nI noted above that we need to find all prefix sum pairs (i,j) such tha (p[j] - p[i]) % K == 0.\\nBut this is only true, **if and only if** ```p[j] % K == p[i] % K``` \\nWhy is this?\\n\\nAccording the the division algorithm we can express p[j] and p[i] in the following way.\\np[j] = b*K + r0 where 0 <= r0 < K\\np[i] = a*K + r1 where 0<= r1 < K\\n\\nThen ```p[j] - p[i] = (b*K + r0) - (a*K + r1) ``` \\n```= b*K - a*K + r0 - r1 = K*(b-a) + r0 - r1```\\nAgain: ```p[j] - p[i] = K*(b-a) + (r0-r1)```, in other words\\n```K``` only ```divides p[j] - p[i]``` iff ```r0-r1 = 0 <-> r0 = r1``` QED\\n\\nBut we should not forget about elements in the array that do not need a pairing, namely those that are are divisible by K. That\\'s why I add mod[0] at the end.\\n\\nAlso counting pairs => N choose 2 = > n*(n-1) / 2. \\n\\n\\n\\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] A, int K) {\\n        //There K mod groups 0...K-1\\n        //For each prefix sum that does not have remainder 0 it needs to be paired with 1 with the same remainder\\n        //this is so the remainders cancel out.\\n        int N = A.length;\\n        int[] modGroups = new int[K];\\n        int sum = 0;\\n        for (int i = 0; i < N; i++){\\n            sum += A[i];\\n            int group = sum % K;\\n            \\n            if (group < 0) group += K; //Java has negative modulus so correct it\\n            modGroups[group]++;\\n        }\\n        \\n        int total = 0;\\n        for (int x : modGroups){\\n             if (x > 1) total += (x*(x-1)) / 2;\\n        }\\n        //Dont forget all numbers that divide K\\n        return total + modGroups[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```p[j] % K == p[i] % K```\n```p[j] - p[i] = (b*K + r0) - (a*K + r1) ```\n```= b*K - a*K + r0 - r1 = K*(b-a) + r0 - r1```\n```p[j] - p[i] = K*(b-a) + (r0-r1)```\n```K```\n```divides p[j] - p[i]```\n```r0-r1 = 0 <-> r0 = r1```\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] A, int K) {\\n        //There K mod groups 0...K-1\\n        //For each prefix sum that does not have remainder 0 it needs to be paired with 1 with the same remainder\\n        //this is so the remainders cancel out.\\n        int N = A.length;\\n        int[] modGroups = new int[K];\\n        int sum = 0;\\n        for (int i = 0; i < N; i++){\\n            sum += A[i];\\n            int group = sum % K;\\n            \\n            if (group < 0) group += K; //Java has negative modulus so correct it\\n            modGroups[group]++;\\n        }\\n        \\n        int total = 0;\\n        for (int x : modGroups){\\n             if (x > 1) total += (x*(x-1)) / 2;\\n        }\\n        //Dont forget all numbers that divide K\\n        return total + modGroups[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070694,
                "title": "thought-process-to-reach-the-solution-c",
                "content": "# Understanding the Question\\n**Subarray Sums divisible by k**. Let\\'s break the question down in small steps. \\n- Firstly, we need subarray sums. There are n*(n-1)/2 of these for an n-length array.\\n- Secondly, we need to count the number of subarray sums divisible by k (given).\\n\\nSo the first approach that inevitably comes to mind is to loop over all the possible subarrays, taking their sums and checking if they are divisible by k. But as soon as this comes to one\\'s mind, one must also realize that this is an extremely naive solution as it is.\\nWe would need to choose the starting and ending points (O(n) each) and then loop over the subarray to calculate its sum (again O(n)), giving a total of $O(n^3)$ time complexity, which is not permitted by the constraints given.\\n\\nThe next thing one may think is of using prefix sum array, to reduce the calculation of the sum to $O(n^2)$, but this will still not make the cut.\\n\\n# Look for Hints in the Constraints\\nThe constraints are as follows:\\n$$1 <= n <= 3*10^4$$\\n$$-10^4 <= nums[i] <= 10^4$$\\n$$2 <= k <= 10^4$$\\n\\nAs we can see, the constraints won\\'t permit an $O(n^2)$, and hence we need to make use of all the information in the question in such a way that we can do this in $O(nlogn)$ or less.\\n\\n# A Curious Observation\\nLet us consider the following example:\\n`nums = [4,5,0,-2,-3,1], k = 5`\\nIf we consider the prefix sum of the above array and the remainders when they are divided by k (i.e `prefixSum[i]%k`), we get the following:\\n```\\nprefixSum = [4, 9, 9, 7, 4, 5]\\n   ..%k   = [4, 4, 4, 2, 4, 0]\\n```\\nFor any subarray `[i..j]` whose sum is divisible by k, we can easily see that `prefixSum[j] - prefixSum[i-1] = 0`.\\nThus if there are any repetitions in our prefixSum%k array, that represents a required subarray.\\n\\nSo if we have the count of every possible value of prefixSum%k, we can determine if there are any subarray that end at the current index and the sum is divisible by k.\\n\\n# Approach\\nWe loop over the array, calculating the prefixSum on the way. We don\\'t need to store this as they are never reused. We maintain the count of every `sum%k` we can get. \\nIf we get a repitition, this index can be paired by any of the other indices that have the same `sum%k`, and hence contributes `count[sum%k]` to the total.\\n\\nFor considering the case of the prefixSums being themselves divisible by k and the case of the whole array being a subarray whose sum is divisible by k, we need to initialize `count[0] = 1`.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n + k)$$\\n\\n- Space complexity: $$O(k)$$\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> sums(k, 0);\\n        sums[0]++;\\n        int cnt = 0;\\n        int currSum = 0;\\n        for(int i = 0; i<n; i++) {\\n            currSum = (currSum + nums[i]%k + k)%k;\\n            cnt += sums[currSum];\\n            sums[currSum]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\nInstead of using an array to store the counts, we can also use `unordered_map<int, int>` provided by STL (or hash map, as provided by your language) which will not incur the initialization cost of $O(k)$.\\n\\n<hr/>\\n\\nIf you liked this post, please **upvote** it!\\nFeel free to ask any doubts or put any suggestions in the comments.",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nprefixSum = [4, 9, 9, 7, 4, 5]\\n   ..%k   = [4, 4, 4, 2, 4, 0]\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> sums(k, 0);\\n        sums[0]++;\\n        int cnt = 0;\\n        int currSum = 0;\\n        for(int i = 0; i<n; i++) {\\n            currSum = (currSum + nums[i]%k + k)%k;\\n            cnt += sums[currSum];\\n            sums[currSum]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 217979,
                "title": "pictured-explanation-python-o-n-clean-solution-8-lines",
                "content": "```\\nclass Solution:\\n    def subarraysDivByK(self, A, K):\\n        result,mod_map,running_sum = 0 ,{},0\\n        mod_map[0]=1\\n        for i in range(len(A)):\\n            running_sum+=A[i]\\n            if mod_map.get(running_sum%K) != None:\\n                val = mod_map.get(running_sum%K)\\n                result+=val\\n                mod_map[running_sum%K]=val+1\\n            else:\\n                mod_map[running_sum%K]=1\\n        return result\\n```\\n\\nRunning Sum[i]%K == Running Sum[j]%k that means we have sum(i,j) which is divisible by K.\\nThus, we keep HashMap = {RunningSum%K : Frequency_Count}\\nTime Complexity : O(n)\\nSpace Complexity : O(K) - As map keys are always Modulus of K with running sum.\\n\\nAfter Reading other solutions, revised to store mod values in an list of size (K+1), as retreival from list is faster than Dictionary.\\n```\\nclass Solution:\\n    def subarraysDivByK(self, A, K):\\n        result,running_sum = 0,0\\n        mod_array = [1] + [0]*K\\n        for i in range(len(A)):\\n            running_sum+=A[i]\\n            result+=mod_array[running_sum%K]\\n            mod_array[running_sum%K]+=1\\n        return result\\n```\\n![image](https://assets.leetcode.com/users/ramanahuja/image_1547352267.png)\\n![image](https://assets.leetcode.com/users/ramanahuja/image_1547352278.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subarraysDivByK(self, A, K):\\n        result,mod_map,running_sum = 0 ,{},0\\n        mod_map[0]=1\\n        for i in range(len(A)):\\n            running_sum+=A[i]\\n            if mod_map.get(running_sum%K) != None:\\n                val = mod_map.get(running_sum%K)\\n                result+=val\\n                mod_map[running_sum%K]=val+1\\n            else:\\n                mod_map[running_sum%K]=1\\n        return result\\n```\n```\\nclass Solution:\\n    def subarraysDivByK(self, A, K):\\n        result,running_sum = 0,0\\n        mod_array = [1] + [0]*K\\n        for i in range(len(A)):\\n            running_sum+=A[i]\\n            result+=mod_array[running_sum%K]\\n            mod_array[running_sum%K]+=1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070481,
                "title": "python3-prefix-sum-frequency-table-explained",
                "content": "**Intuition**\\n - The techniques we are using here are **prefix sum** and **frequency table**. The idea came from the problem when it asked about **contiguous subarrays sum** and **return the total number** (Many other solutions/discussions mentioned that when the question is asking about return the total number of something, there is a very good chance that it is a dp problem. Note that this solution is also a dp solution and the specfic thchniques we used here are **prefix sum** and **frequency table**).\\n     - What is prefix sum?\\n        - prefix sum also called cumulative sum, is an array with the same size as the original array, where the ```ith``` element represents the sum of the elements in the origianl array up to the ```ith``` position.\\n        e.g., arr = [1,2,3,4,5], prefixSum = [1,3,6,10,15]\\n        - prefix sum will allow us to get the sum of a contiguous subarray in O(1), e.g., get the sum of elements from i=1 to i=3, we do prefixSum[3] - prefix[0].\\n        - Note that the solution in this post doesn\\'t explicitly using a prefix sum array, but it is better to think about the process of getting the remainder in the prefix sum way.\\n\\n     - What is frequency table?\\n        - A frequency table lists a set of values and how often each one appears.\\n        - Frequency table will allow us to get the number of the occurances of some value while scanning an array in O(1), frequency can be stored using a list or a hashmap.\\n\\n**Algorithm**\\n\\n - Now what we really want to do for this problem is, at each position ```i```, we want to know the number of contiguous subarray end at ```i``` that have a sum divisible by ```k```. Since we want the sum divisible by ```k``` all that matters is the remainder should be 0. \\n     - If the prefixSum at ```i``` has a remainder of ```r```, we just need to find how many of the previous prefixSum before ```i``` also has a remainder of ```r```. This can be done using the frequency table to store the frequency of previous remainders.\\n     - When the previous prefixSum and the current prefixSum have the same remainder, it means the continues subarray in between has a sum which is divisable by ```k```.\\n     - e.g., \\n```\\n    k = 3, nums = [1,2,3]\\n                                    before       i=0,        i=1,        i=2\\n    nums                         =                1,          2,          3\\n    prefixSum                    =    0,          1,          3,          6\\n    remainder of prefixSum       =    0,          1,          0,          0\\n    frequency table of remainder =  {0:1}     {0:1,1:1}   {0:2,1:1}   {0:3,1:1}\\n    increase res by              =    0,          0,          1,          2\\n    res                          =    0,          0,          1,          3\\n```\\n\\n**Time Complexity: O(n)**\\n\\n```python\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        # frequency table to store the frequency of the remainder\\n        remainderFrq = defaultdict(int)\\n        # Empty sub array will have a sum of 0 and remainder of 0, thus the frequency of 0 is 1 before we go into the array\\n        remainderFrq[0] = 1\\n        \\n        res = prefixSum = 0\\n        for n in nums:\\n            # Adding n to the prefixSum, so we have the prefixSum up to the ith position.\\n            prefixSum += n\\n            # Get the remainder of the current prefixSum.\\n            remainder = prefixSum % k\\n            # We need to increase the result before update the frequency table.\\n            # Because we are counting how many previous prefixSum have the same remainder.\\n            res += remainderFrq[remainder]\\n            # Update the frequency table.\\n            remainderFrq[remainder] += 1\\n        return res\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```ith```\n```ith```\n```i```\n```i```\n```k```\n```k```\n```i```\n```r```\n```i```\n```r```\n```k```\n```\\n    k = 3, nums = [1,2,3]\\n                                    before       i=0,        i=1,        i=2\\n    nums                         =                1,          2,          3\\n    prefixSum                    =    0,          1,          3,          6\\n    remainder of prefixSum       =    0,          1,          0,          0\\n    frequency table of remainder =  {0:1}     {0:1,1:1}   {0:2,1:1}   {0:3,1:1}\\n    increase res by              =    0,          0,          1,          2\\n    res                          =    0,          0,          1,          3\\n```\n```python\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        # frequency table to store the frequency of the remainder\\n        remainderFrq = defaultdict(int)\\n        # Empty sub array will have a sum of 0 and remainder of 0, thus the frequency of 0 is 1 before we go into the array\\n        remainderFrq[0] = 1\\n        \\n        res = prefixSum = 0\\n        for n in nums:\\n            # Adding n to the prefixSum, so we have the prefixSum up to the ith position.\\n            prefixSum += n\\n            # Get the remainder of the current prefixSum.\\n            remainder = prefixSum % k\\n            # We need to increase the result before update the frequency table.\\n            # Because we are counting how many previous prefixSum have the same remainder.\\n            res += remainderFrq[remainder]\\n            # Update the frequency table.\\n            remainderFrq[remainder] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 614673,
                "title": "c-easy-to-understand-o-n-hashmap-cumulative-sum",
                "content": "The solution makes use of a hashMap and works in a single pass.\\nThe solution section gives something that is confusing for me so here is a more understandable solution:\\n\\n1. curr_sum here is denoting the traditional cumulative sum at any point during the traversal of the arrray\\n2. Now curr_sum%k at any point gives the remainder,this can either be 0 or any other number.\\n3. Whatever the remainder is we are simply putting in the map thereby preparing a mapping of all the possible remainders from all the possible sum and storing their frequency as the values.\\n4. The only thing and the most important this is to understand why this line of code works and why it gives the desired outputs.\\nif(mp.find(rem)!=mp.end())\\n            count+=mp[rem];\\nWe are increasing the count by the number of times the given remainder has been seen.\\nI am considering it a fact that :\\nIf the remainders of array upto i and array upto j are equal (ri=rj),\\nthen subarray from i to j has a remainder of 0,\\nwhich means It\\'s the type of subarrays we\\'re looking for!\\nLook here: https://leetcode.com/problems/subarray-sums-divisible-by-k/discuss/413234/DETAILED-WHITEBOARD!-BEATS-100-(Do-you-really-want-to-understand-It)\\n\\nNow lets dry run the code with this concept to drill it in.\\n\\nA = [4,5,0,-2,-3,1], K = 5 \\nA = 4, curr_sum = 4, curr_sum%K = 4 map now is: 0-->1, 4-->1 RESULT: []\\n\\nA = 5, curr_sum = 9, curr_sum%K = 4 map now is: 0-->1, 4-->2 So this means we found a remainder that was already there! count+=1 RESULT: ([5], ) (added one more)\\n\\nA = 0, curr_sum = 9, curr_sum%K = 4 map now is: 0-->1, 4-->3 So this means we found a remainder that was already there! count+=2 RESULT: ([5,0], [5], [0]) (added two more)\\n\\nA = -2, curr_sum = 7, curr_sum%K = 2 map now is: 0-->1, 4-->3, 2-->1\\nRESULT: ([5,0], [5], [0])\\n\\n\\nA = -3, curr_sum = 4, curr_sum%K = 4 map now is: 0-->1, 4-->4, 2-->1 So this means we found a remainder that was already there! count+=3 RESULT: ([5,0], [5], [0], [5,0,-2,-3], [0,-2,-3], [-2,-3]) (added three more)\\n\\n\\nA = 1, curr_sum = 5, curr_sum%K = 0 map now is: 0-->2, 4-->4, 2-->1 So this means we found a remainder that was already there! count+=1 RESULT: ([5,0], [5], [0], [5,0,-2,-3], [0,-2,-3], [-2,-3], [4,5,0,-2,-3,1]) (added one more)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& A, int K) {\\n        int n = A.size();\\n        if(n==0) return 0;\\n        \\n        int i = 0, count = 0;\\n        int curr_sum = 0;\\n        unordered_map<int, int> mp;\\n        mp[0] = 1;// this is done because initial cumulative sum = 0 and that sum%k will be equal to 0 always\\n        \\n        while(i<n)\\n        {\\n            curr_sum+= A[i++];\\n            int rem = curr_sum % K;\\n            if(rem<0) rem += K;\\n            \\n            if(mp.find(rem)!=mp.end())\\n                count+=mp[rem];\\n            \\n            mp[rem]++;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& A, int K) {\\n        int n = A.size();\\n        if(n==0) return 0;\\n        \\n        int i = 0, count = 0;\\n        int curr_sum = 0;\\n        unordered_map<int, int> mp;\\n        mp[0] = 1;// this is done because initial cumulative sum = 0 and that sum%k will be equal to 0 always\\n        \\n        while(i<n)\\n        {\\n            curr_sum+= A[i++];\\n            int rem = curr_sum % K;\\n            if(rem<0) rem += K;\\n            \\n            if(mp.find(rem)!=mp.end())\\n                count+=mp[rem];\\n            \\n            mp[rem]++;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310767,
                "title": "python-concise-explanation-and-proof",
                "content": "\\n\\n### Notation\\n```sum(i, j)``` denoted as summation from ```a[i] + a[i + 1] + .... + a[j - 1]```\\n\\nHere is a trick, if j > i\\n```\\nsum(i, j) = sum(0, j) - sum(0, i)\\n```\\nSince sum(i, j) is divisible by k, which means\\n\\n```sum(i , j) % k == 0```\\n\\nReplace sum(i, j) by sum(0, j) - sum(0, i)\\n( sum(0,j) - sum(0, i) ) % k == 0 which imply ``` sum(0,j) - sum(0, i) = n * k ``` \\nwhere n is integer but we don\\'t know what exactly n is.\\n\\n``` python\\n# shift position from sum(0,j) - sum(0, i) = n * k\\nsum(0, i) = sum(0,j) - n * k \\n# Then mod k both side\\nsum(0, i) % k = ( sum(0,j) - n * k ) % k \\n``` \\n\\n\\nHere is math formula of modulo operation from https://en.wikipedia.org/wiki/Modulo_operation\\n```\\n(a + b) mod n = [(a mod n) + (b mod n)] mod n\\n(a mod n) mod n = a mod n\\n```\\n\\nApply ```(a + b) mod n = [(a mod n) + (b mod n)] mod n``` on\\n\\n```\\nsum(0, i) % k = ( sum(0,j) - n * k ) % k \\n```\\nSuch that\\n```\\nsum(0, i) % k = ( sum(0,j) % k - (n * k) % k ) % k \\n```\\n(n * k) % k is zero, because n * k is divisible by k, such that\\n```\\nsum(0, i) % k = ( sum(0,j) % k ) % k \\n```\\nThen apply ```(a mod n) mod n = a mod n``` on ```( sum(0, j) % k ) % k ``` such that\\n```\\nsum(0, i) % k = ( sum(0,j) % k ) % k = sum(0,j) % k\\n```\\nThat is the proof why ```sum(0, i) % k = sum(0,j) % k``` if sum(i, j) is divisible by K\\n\\nLet\\'s use a dictionary(as known as HashMap) to store all ```sum(0, i) % k```\\nand group by  ```sum(0, i) % k``` as key\\n\\n```python\\nacc = 0        \\nfor i in range(len_A):\\n\\tacc += A[i]       \\n\\tkey = acc % K # value of sum(0, i) % k\\n\\n\\tif key in d: # save how many times sum(0, i) % k is same\\n\\t\\td[key] += 1 \\n\\telse:\\n\\t\\td[key] = 1\\n```\\n\\nand if we found a bigger sum(0, j) latter, and ```d[sum(0, j) % k]``` means how many \\n```sum(0, i) % k``` == ```sum(0, j) % k``` that satisfy the prevoius proof\\n\\n### sum(i, j) is divisible by K if\\n```sum(0, i) % k = sum(0,j) % k``` \\n\\nthen we add d[sum(0, j) % k] to answer\\n\\n```python\\nclass Solution:\\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\\n        ans = 0\\n        d = {0: 1}\\n        len_A = len(A)\\n        acc = 0        \\n        for i in range(len_A):\\n            acc += A[i]       \\n            key = acc % K\\n            \\n            if key in d:\\n                ans += d[key]\\n                d[key] += 1\\n            else:\\n                d[key] = 1\\n            \\n        return ans\\n```\\n\\nWhy we need ```d = {0: 1}``` ?\\nConsider ```sum(i, j) % k == 0 and i == 0```\\nwhich means ```sum(0, j) % k == 0``` and should count into the answer\\n\\nThe solution is familiar from https://leetcode.com/problems/subarray-sum-equals-k/\\n\\nAlso, since ```key % k```, which means ```0 <= key < k``` therefore we can use an array instead of hashmap\\nhere is an optimized solution.\\n\\n```python\\nclass Solution:\\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\\n        res = 0\\n        d = [1] + [0] * K # range of key is 0 <= key < K because key always mod by K\\n        acc = 0\\n        for a in A:\\n            acc = (acc + a) % K # it\\'s works because a % k % k % k .... n times is still same as a % k \\n            if d[acc]:\\n                res += d[acc]\\n            d[acc] += 1            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```sum(i, j)```\n```a[i] + a[i + 1] + .... + a[j - 1]```\n```\\nsum(i, j) = sum(0, j) - sum(0, i)\\n```\n```sum(i , j) % k == 0```\n``` sum(0,j) - sum(0, i) = n * k ```\n``` python\\n# shift position from sum(0,j) - sum(0, i) = n * k\\nsum(0, i) = sum(0,j) - n * k \\n# Then mod k both side\\nsum(0, i) % k = ( sum(0,j) - n * k ) % k \\n```\n```\\n(a + b) mod n = [(a mod n) + (b mod n)] mod n\\n(a mod n) mod n = a mod n\\n```\n```(a + b) mod n = [(a mod n) + (b mod n)] mod n```\n```\\nsum(0, i) % k = ( sum(0,j) - n * k ) % k \\n```\n```\\nsum(0, i) % k = ( sum(0,j) % k - (n * k) % k ) % k \\n```\n```\\nsum(0, i) % k = ( sum(0,j) % k ) % k \\n```\n```(a mod n) mod n = a mod n```\n```( sum(0, j) % k ) % k ```\n```\\nsum(0, i) % k = ( sum(0,j) % k ) % k = sum(0,j) % k\\n```\n```sum(0, i) % k = sum(0,j) % k```\n```sum(0, i) % k```\n```sum(0, i) % k```\n```python\\nacc = 0        \\nfor i in range(len_A):\\n\\tacc += A[i]       \\n\\tkey = acc % K # value of sum(0, i) % k\\n\\n\\tif key in d: # save how many times sum(0, i) % k is same\\n\\t\\td[key] += 1 \\n\\telse:\\n\\t\\td[key] = 1\\n```\n```d[sum(0, j) % k]```\n```sum(0, i) % k```\n```sum(0, j) % k```\n```sum(0, i) % k = sum(0,j) % k```\n```python\\nclass Solution:\\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\\n        ans = 0\\n        d = {0: 1}\\n        len_A = len(A)\\n        acc = 0        \\n        for i in range(len_A):\\n            acc += A[i]       \\n            key = acc % K\\n            \\n            if key in d:\\n                ans += d[key]\\n                d[key] += 1\\n            else:\\n                d[key] = 1\\n            \\n        return ans\\n```\n```d = {0: 1}```\n```sum(i, j) % k == 0 and i == 0```\n```sum(0, j) % k == 0```\n```key % k```\n```0 <= key < k```\n```python\\nclass Solution:\\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\\n        res = 0\\n        d = [1] + [0] * K # range of key is 0 <= key < K because key always mod by K\\n        acc = 0\\n        for a in A:\\n            acc = (acc + a) % K # it\\'s works because a % k % k % k .... n times is still same as a % k \\n            if d[acc]:\\n                res += d[acc]\\n            d[acc] += 1            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859080,
                "title": "detailed-explanation-of-math-behind-o-n-solution",
                "content": "Other questions that can be solved using the prefix-sum technique:\\n* https://leetcode.com/problems/subarray-sum-equals-k/\\n* https://leetcode.com/problems/make-sum-divisible-by-p/ \\n* https://leetcode.com/problems/continuous-subarray-sum/\\n* https://leetcode.com/problems/contiguous-array/ \\n* https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/\\n\\nLet me know if I missed any :) \\n\\n![image](https://assets.leetcode.com/users/images/3236cc56-ce92-4a76-9ac8-d4ef318553ba_1600903914.1804485.png)\\n![image](https://assets.leetcode.com/users/images/5db75dd0-116f-459c-add3-e52240ece40e_1600903044.7818098.png)\\n![image](https://assets.leetcode.com/users/images/d83f41ba-9ab0-4fdc-b143-acf4d68012a5_1600902936.0417461.png)\\n\\n\\nAlso to clarify, `(F[i] - F[j])` where `j < i`, is equal to the sum of the subarray from `arr[j]` to `arr[i]`, i.e. `sum(arr[j:i])` , NOT inclusive of `i`\\n\\nEx:\\n`arr = [1, 2, 3, 4]`\\n`F = [0, 1, 3, 6, 10]`\\nso, for example, `F[3]-F[1] = 6-1 = 5 = sum(arr[1:3])`\\n\\n\\nPython:\\n```\\nclass Solution:\\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\\n        prefix_sum = 0\\n        sums = {0: 1}\\n        answer = 0\\n        for num in A:\\n            prefix_sum += num\\n            key = prefix_sum%K\\n            if key in sums:\\n                answer += sums[key]\\n                sums[key] += 1\\n                continue\\n            sums[key] = 1\\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\\n        prefix_sum = 0\\n        sums = {0: 1}\\n        answer = 0\\n        for num in A:\\n            prefix_sum += num\\n            key = prefix_sum%K\\n            if key in sums:\\n                answer += sums[key]\\n                sums[key] += 1\\n                continue\\n            sums[key] = 1\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661398,
                "title": "c-one-pass-prefix-sum-approach-with-explanation",
                "content": "Consider the subarray sum equals `K` problem. Here, we need to find let\\'s say a right pointer `R` and a left pointer `L` which forms a subarray from `L to R`[inclusive] whose sum equals `K`.  I.e,\\n\\n`sum[R] - sum[L-1] = K` -> (sum of subarray upto R) - (sum of subarray upto L)  = K\\n\\nNow, building on top of that for this problem, what happens when we take `MOD K` throughout the above equation.\\n\\n1. `(sum[R] - sum[L-1]) MOD K = (n * K) MOD K` -- Here, I\\'ve introduced another number `n (>=0)` as we require sum to be a multiple of `K`\\n2. `sum[R] MOD K - sum[L-1] MOD K = 0`\\n3. `sum[R] MOD K = sum[L-1] MOD K`\\n\\nIf ends up to find prefix sums whose `MOD K` are equal. We just need to keep doing prefix sums `MOD K` as we iterate from one end of the array to another and keep a track of what we have found till now. Whenever we encounter a prefix sum whose `MOD K` was already found, then that means we found two prefix sums satisfying Equation 3 above. That\\'s it!! We are DONE.\\n\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& A, int K) {\\n\\n        int pref = 0; // prefix sum\\n        vector<int> cPref(K); //sum will not exceed K as we are taking modulo at every step\\n        cPref[pref]++; // adding 0 as prefix sum, base case\\n        \\n        int answer = 0; // count of number of subarrays whose sum is divisible by K\\n        \\n        for(int i = 0; i < A.size(); i++) {\\n            \\n            pref = (pref + A[i]) % K; // Here, we take modulo of prefix sum as outlined in the explanation\\n            \\n            if(pref < 0) pref += K; // since -1 mod 5 and 4 mod 5 are equivalent, we will keep only positives since we like them :)\\n                        \\n            answer += cPref[pref]; // if we have already found pref, then increase the answer count\\n            \\n            cPref[pref]++; // add pref seen count by 1\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& A, int K) {\\n\\n        int pref = 0; // prefix sum\\n        vector<int> cPref(K); //sum will not exceed K as we are taking modulo at every step\\n        cPref[pref]++; // adding 0 as prefix sum, base case\\n        \\n        int answer = 0; // count of number of subarrays whose sum is divisible by K\\n        \\n        for(int i = 0; i < A.size(); i++) {\\n            \\n            pref = (pref + A[i]) % K; // Here, we take modulo of prefix sum as outlined in the explanation\\n            \\n            if(pref < 0) pref += K; // since -1 mod 5 and 4 mod 5 are equivalent, we will keep only positives since we like them :)\\n                        \\n            answer += cPref[pref]; // if we have already found pref, then increase the answer count\\n            \\n            cPref[pref]++; // add pref seen count by 1\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070594,
                "title": "java-explained-in-detail-simple-fast-solution-prefix-sum-hash-table-counting",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n<br>\\n\\n---\\n\\n## Approach\\n\\nWhen it comes to Sum of Subarray, the use of Prefix Sum is especially important.\\n\\nPrefix Sum is the sum of the current integer with the previous integer in the array (Prefix).\\n\\nExample: nums = [1,2,3,4,5] has the prefix sum array of prefixSum = [1,3,6,10,15], where the nums[0] + 1 = 1, nums[1] + nums[0] = 2 + 1 = 3, nums[2] + nums[1] = 3 + 3 = 6, and so on.\\n\\nUsing the example above, we can determine the subarray sum of any subarray using prefix sum.\\n\\nTo get the subarray sum of nums[2] to nums[4] == 3 + 4 + 5 == 12, we can get from prefixSum[5] - prefixSum[1] == 15 - 3 == 12.\\n\\nWith Prefix Sum, we can evaluate if any subarray sum is divisible by \\'k\\', if two prefix sums have the same remainder of \\'k\\'.\\n\\nFor Example, nums = [4,2,3], k = 5, with two prefix sum, 4 [4] and 9 [4,2,3].\\n\\nBoth remainders are 4, with the subarray between the prefix sum 9 [4,2,3] - 4 [4] == 5 [2,3], which is divisible by 5.\\n\\n<br>\\n\\n---\\n\\n# Prefix Sum & Hash Table\\n\\n## Complexity\\n- Time Complexity: O(n),\\nwhere \\'n\\' is the length of \\'nums\\'.\\nIn fact, in actual is \\'2n\\' as we traverse \\'nums\\' once and the HashMap once, with the worst time complexity of the HashMap being \\'n\\'.\\n\\n- Space Complexity: O(n),\\nwhere \\'n\\' is the length of \\'nums\\'.\\nThe worst case is when all the prefix sums in \\'nums\\' have different remainders with \\'k\\', resulting in the maximum size of the HashMap to be \\'n\\'.\\n\\n<br>\\n\\n## Java - With Explanation\\n```\\nclass Solution {\\npublic int subarraysDivByK(int[] nums, int k) {\\n\\n        // Use the HashMap to record the frequency of all the prefix sum remainders.\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0, remainder = 0; i < nums.length; i++) {\\n            // Note that the integer in \\'nums\\' can be negative.\\n            // Thus, we need to adjust the negative remainder to positive remainder.\\n            // Below accounts for both negative and positive remainders.\\n            // We can also check if the remainder is negative, then add a \\'k\\' to make the remainder positive.\\n            // For Example, nums = [-2,3,2], k = 5,\\n            // remainder for the prefix sum of [-2,1,3] are -2, 1 and 3 respectively.\\n            // We know that [3,2] sum to 5, which is divisible by 5.\\n            // After converting -2 to 3, by adding 5, it has the same remainder with prefix sum 3.\\n            remainder = ((remainder + nums[i]) % k + k) % k;\\n            map.put(remainder, map.getOrDefault(remainder, 0) + 1);\\n        }\\n        // The result contains all the prefix sum with remainder 0,\\n        // as all the prefix sum with remainder of 0 is itself divisible by \\'k\\'.\\n        // However, do note that the prefix sum with remainder 0 also able to form subarray sums that is divisible by \\'k\\'\\n        // with one another, which will be calculated next.\\n        // For Example: nums = [5,5,5,5], k = 5,\\n        // The prefix sum of [5,10,15,20] are themselves divisible by 5, while also forming subarray sums divisible by 5\\n        // with 10 [5,5] - 5 [5] == 5, 15 [5,5,5] - 5 [5] == 10, etc.\\n        int result = map.getOrDefault(0, 0);\\n\\n        // The prefix sums with the same remainder can form subarray sums that is divisible by \\'k\\' with each other.\\n        // For each remainder, the number of subarray that is divisible by \\'k\\' is the number of combinations from the frequency.\\n        // Equation for the number of combinations of n items is n * \"(n - 1) / 2\".\\n        for (int frequency : map.values())\\n            result += frequency * (frequency - 1) / 2;\\n\\n        return result;\\n    }\\n}\\n```\\n<br>\\n\\n## Java - Clean Code\\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0, remainder = 0; i < nums.length; i++) {\\n            remainder = ((remainder + nums[i]) % k + k) % k;\\n            map.put(remainder, map.getOrDefault(remainder, 0) + 1);\\n        }\\n        int result = map.getOrDefault(0, 0);\\n        for (int frequency : map.values())\\n            result += frequency * (frequency - 1) / 2;\\n        return result;\\n    }\\n}\\n```\\n<br>\\n\\n---\\n\\n# Prefix Sum & Counting\\n\\n## Complexity\\n- Time Complexity: O(n + k),\\nwhere \\'n\\' is the length of \\'nums\\'.\\nWe traverse \\'nums\\' once and the counting array of size \\'k\\' once.\\n\\n- Space Complexity: O(k),\\nas we create a counting array of size \\'k\\'.\\n\\n<br>\\n\\n## Java - With Explanation\\n```\\nclass Solution {\\npublic int subarraysDivByK(int[] nums, int k) {\\n\\n        // Use counting array to record the frequency of all the prefix sum remainders.\\n        int[] counting = new int[k];\\n        for (int i = 0, remainder = 0; i < nums.length; i++) {\\n            // Note that the integer in \\'nums\\' can be negative.\\n            // Thus, we need to adjust the negative remainder to positive remainder.\\n            // Below accounts for both negative and positive remainders.\\n            // We can also check if the remainder is negative, then add a \\'k\\' to make the remainder positive.\\n            // For Example, nums = [-2,3,2], k = 5,\\n            // remainder for the prefix sum of [-2,1,3] are -2, 1 and 3 respectively.\\n            // We know that [3,2] sum to 5, which is divisible by 5.\\n            // After converting -2 to 3, by adding 5, it has the same remainder with prefix sum 3.\\n            remainder = ((remainder + nums[i]) % k + k) % k;\\n            counting[remainder]++;\\n        }\\n\\n        // The result contains all the prefix sum with remainder 0,\\n        // as all the prefix sum with remainder of 0 is itself divisible by \\'k\\'.\\n        // However, do note that the prefix sum with remainder 0 also able to form subarray sums that is divisible by \\'k\\'\\n        // with one another, which will be calculated next.\\n        // For Example: nums = [5,5,5,5], k = 5,\\n        // The prefix sum of [5,10,15,20] are themselves divisible by 5, while also forming subarray sums divisible by 5\\n        // with 10 [5,5] - 5 [5] == 5, 15 [5,5,5] - 5 [5] == 10, etc.\\n        int result = counting[0];\\n\\n        // The prefix sums with the same remainder can form subarray sums that is divisible by \\'k\\' with each other.\\n        // For each remainder, the number of subarray that is divisible by \\'k\\' is the number of combinations from the frequency.\\n        // Equation for the number of combinations of n items is n * \"(n - 1) / 2\".\\n        for (int frequency : counting)\\n            result += frequency * (frequency - 1) / 2;\\n\\n        return result;\\n    }\\n}\\n```\\n<br>\\n\\n## Java - Clean Code\\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        int[] counting = new int[k];\\n        for (int i = 0, remainder = 0; i < nums.length; i++) {\\n            remainder = ((remainder + nums[i]) % k + k) % k;\\n            counting[remainder]++;\\n        }\\n        int result = counting[0];\\n        for (int frequency : counting)\\n            result += frequency * (frequency - 1) / 2;\\n        return result;\\n    }\\n}\\n```\\n\\n<br>\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic int subarraysDivByK(int[] nums, int k) {\\n\\n        // Use the HashMap to record the frequency of all the prefix sum remainders.\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0, remainder = 0; i < nums.length; i++) {\\n            // Note that the integer in \\'nums\\' can be negative.\\n            // Thus, we need to adjust the negative remainder to positive remainder.\\n            // Below accounts for both negative and positive remainders.\\n            // We can also check if the remainder is negative, then add a \\'k\\' to make the remainder positive.\\n            // For Example, nums = [-2,3,2], k = 5,\\n            // remainder for the prefix sum of [-2,1,3] are -2, 1 and 3 respectively.\\n            // We know that [3,2] sum to 5, which is divisible by 5.\\n            // After converting -2 to 3, by adding 5, it has the same remainder with prefix sum 3.\\n            remainder = ((remainder + nums[i]) % k + k) % k;\\n            map.put(remainder, map.getOrDefault(remainder, 0) + 1);\\n        }\\n        // The result contains all the prefix sum with remainder 0,\\n        // as all the prefix sum with remainder of 0 is itself divisible by \\'k\\'.\\n        // However, do note that the prefix sum with remainder 0 also able to form subarray sums that is divisible by \\'k\\'\\n        // with one another, which will be calculated next.\\n        // For Example: nums = [5,5,5,5], k = 5,\\n        // The prefix sum of [5,10,15,20] are themselves divisible by 5, while also forming subarray sums divisible by 5\\n        // with 10 [5,5] - 5 [5] == 5, 15 [5,5,5] - 5 [5] == 10, etc.\\n        int result = map.getOrDefault(0, 0);\\n\\n        // The prefix sums with the same remainder can form subarray sums that is divisible by \\'k\\' with each other.\\n        // For each remainder, the number of subarray that is divisible by \\'k\\' is the number of combinations from the frequency.\\n        // Equation for the number of combinations of n items is n * \"(n - 1) / 2\".\\n        for (int frequency : map.values())\\n            result += frequency * (frequency - 1) / 2;\\n\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0, remainder = 0; i < nums.length; i++) {\\n            remainder = ((remainder + nums[i]) % k + k) % k;\\n            map.put(remainder, map.getOrDefault(remainder, 0) + 1);\\n        }\\n        int result = map.getOrDefault(0, 0);\\n        for (int frequency : map.values())\\n            result += frequency * (frequency - 1) / 2;\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic int subarraysDivByK(int[] nums, int k) {\\n\\n        // Use counting array to record the frequency of all the prefix sum remainders.\\n        int[] counting = new int[k];\\n        for (int i = 0, remainder = 0; i < nums.length; i++) {\\n            // Note that the integer in \\'nums\\' can be negative.\\n            // Thus, we need to adjust the negative remainder to positive remainder.\\n            // Below accounts for both negative and positive remainders.\\n            // We can also check if the remainder is negative, then add a \\'k\\' to make the remainder positive.\\n            // For Example, nums = [-2,3,2], k = 5,\\n            // remainder for the prefix sum of [-2,1,3] are -2, 1 and 3 respectively.\\n            // We know that [3,2] sum to 5, which is divisible by 5.\\n            // After converting -2 to 3, by adding 5, it has the same remainder with prefix sum 3.\\n            remainder = ((remainder + nums[i]) % k + k) % k;\\n            counting[remainder]++;\\n        }\\n\\n        // The result contains all the prefix sum with remainder 0,\\n        // as all the prefix sum with remainder of 0 is itself divisible by \\'k\\'.\\n        // However, do note that the prefix sum with remainder 0 also able to form subarray sums that is divisible by \\'k\\'\\n        // with one another, which will be calculated next.\\n        // For Example: nums = [5,5,5,5], k = 5,\\n        // The prefix sum of [5,10,15,20] are themselves divisible by 5, while also forming subarray sums divisible by 5\\n        // with 10 [5,5] - 5 [5] == 5, 15 [5,5,5] - 5 [5] == 10, etc.\\n        int result = counting[0];\\n\\n        // The prefix sums with the same remainder can form subarray sums that is divisible by \\'k\\' with each other.\\n        // For each remainder, the number of subarray that is divisible by \\'k\\' is the number of combinations from the frequency.\\n        // Equation for the number of combinations of n items is n * \"(n - 1) / 2\".\\n        for (int frequency : counting)\\n            result += frequency * (frequency - 1) / 2;\\n\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        int[] counting = new int[k];\\n        for (int i = 0, remainder = 0; i < nums.length; i++) {\\n            remainder = ((remainder + nums[i]) % k + k) % k;\\n            counting[remainder]++;\\n        }\\n        int result = counting[0];\\n        for (int frequency : counting)\\n            result += frequency * (frequency - 1) / 2;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070544,
                "title": "prefix-sum-hashmap-o-n-java-video-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![Screenshot 2023-01-19 at 6.30.26 AM.png](https://assets.leetcode.com/users/images/be6861d3-b420-4e3a-942c-8c095df986c4_1674090042.4095156.png)\\n\\n# Prefix Sum: \\n    Prefix Sum = The Running Sum of an array.\\n    The sum b/w any 2 elements  = PS[j]-PS[i-1]\\n    for ex: j = 4, i = 2\\n    [0,-2,-3] = 4-9 = 5\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore the mod of PS in a hashmap.\\nPS = PS%k\\nAt any given point ans +=hashMap.get(PS);\\n\\nhttps://youtu.be/_ilORd6FFN8\\n\\n![74u6vs.jpg](https://assets.leetcode.com/users/images/3a7fdd78-c9fa-4782-93a3-384c1a0236d4_1674090834.9908051.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\\n        int prefixSum = 0;\\n        int ans = 0;\\n        hashMap.put(0,1);\\n        for(int i = 0;i<nums.length;i++){\\n            prefixSum = (prefixSum + nums[i])%k;\\n            if(prefixSum<0) prefixSum +=k;\\n            if(hashMap.containsKey(prefixSum)){\\n                \\n                    ans = ans+hashMap.get(prefixSum);\\n                \\n                \\n                hashMap.put(prefixSum,hashMap.get(prefixSum)+1);\\n            }else{\\n                hashMap.put(prefixSum,1);\\n            }\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\\n        int prefixSum = 0;\\n        int ans = 0;\\n        hashMap.put(0,1);\\n        for(int i = 0;i<nums.length;i++){\\n            prefixSum = (prefixSum + nums[i])%k;\\n            if(prefixSum<0) prefixSum +=k;\\n            if(hashMap.containsKey(prefixSum)){\\n                \\n                    ans = ans+hashMap.get(prefixSum);\\n                \\n                \\n                hashMap.put(prefixSum,hashMap.get(prefixSum)+1);\\n            }else{\\n                hashMap.put(prefixSum,1);\\n            }\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070827,
                "title": "c-easy-solution-prefix-sum-approach-heavily-commented",
                "content": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFPrefix Sum Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n<iframe src=\"https://leetcode.com/playground/AutTJUmv/shared\" frameBorder=\"0\" width=\"800\" height=\"700\"></iframe>\\n\\n***Time Complexity : `O(N)`\\nSpace Complexity : `O(N)`***\\n![image](https://assets.leetcode.com/users/images/815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFPrefix Sum Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n<iframe src=\"https://leetcode.com/playground/AutTJUmv/shared\" frameBorder=\"0\" width=\"800\" height=\"700\"></iframe>\\n\\n***Time Complexity : `O(N)`\\nSpace Complexity : `O(N)`***\\n![image](https://assets.leetcode.com/users/images/815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png)\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2602607,
                "title": "java-2-approaches-fully-explained",
                "content": "# 1. Brute force approach (TLE):\\n``` \\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        // check all possible subarrays,\\n        // take their sum, increment the count if divisible by k\\n        int total = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int sum = 0;\\n            for (int j = i; j < nums.length; j++) {\\n                sum += nums[j];\\n                if (sum % k == 0) total++;\\n            }\\n        }\\n\\n        return total;\\n    }\\n}\\n\\n```\\n### Time complexity: $$O(n^2)$$\\n---\\n# 2. Optimal approach (using hashmap):\\nWe will be using a hashmap to store **remainders** of the running sum of our array at each index.\\n\\nThe logic behind this is that if we encounter a remainder which was already encountered before, it means that the *sum of the subarray from from the index right next to that point to our current point is divisible by `k`*.\\n\\n Say at index `i`, we got a remainder `x`, after that we got the same remainder `x` at index `j`.\\n **It means that the sum of the subarray from index `i + 1` to `j` is divisble by `k`** (or we can say that the sum of the subarray from index `i + 1` to `j` yields a remainder `0` when divided by `k`).\\n\\n Say sum till index `i` is `S1` and sum till index `j` is `S2`.\\n We observed that:\\n```\\nRemainder at index i = Remainder at index j\\n    S2 % k = S1 % k\\n => S2 % k - S1 % k = 0\\n => (S2 - S1) % k = 0\\n => (Sum of subarray from i + 1 to j) % k = 0\\n```\\n![image.png](https://assets.leetcode.com/users/images/4a928fb0-9085-42ee-9b55-dddeaa92d48b_1674125899.4396439.png)\\n\\n\\nSay the frequency of a remainder `x` is `3`.\\nIt means that **at `3` points, remainder `3` was encountered**.\\n\\nSo if we draw a subarray from the next index of all those `3` points to our current index, we will get a sum divisible by `k`, so we will add that `3` to our answer.\\n\\nAt the end we will increment `3` to `4` (the count of `x`) because our current index is one more point where we have encountered `x`.\\n\\nSo next time we enounter `x` again, we will be able to draw `4` subarrays from `4` points and add `4` to our answer.\\n\\n![image.png](https://assets.leetcode.com/users/images/88ff4e8d-e3a9-4f6b-87ed-b71ae421f7b3_1674126767.6063952.png)\\n\\n## Code:\\n\\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        // map to store the remainders and number of times they\\'ve been encountered\\n        Map<Integer, Integer> map = new HashMap<>();\\n        // our sum is initially 0, and 0 is also divisible by k\\n        // there would be a case when remainder would actually be zero\\n        // so the array from the beginning to that index is our candidate subarray\\n        // so to address that case, so we put <0, 1> initially\\n        map.put(0, 1);\\n        int runningSum = 0, ans = 0;\\n        for (int n : nums) {\\n            runningSum += n;            // add the element to the running sum\\n            int rem = runningSum % k;   // get the remainder by k of our running sum so far\\n            if (rem < 0) {              // in case remainder < 0, \\n                rem += k;               // add divisor (k) to make it +ve\\n            }\\n            // if we already encountered the remainder, we add the frequency mapped to it\\n            // that frequency is nothing but the number of subarrays whose sum has given that remainder \\n            ans += map.getOrDefault(rem, 0);\\n            // after that, we increment the frequency of that remainder,\\n            // because we have encountered it again so the number of subarrays increases by 1\\n            map.put(rem , 1 + map.getOrDefault(rem, 0));\\n        }\\n\\n        return ans;     // return the answer\\n    }\\n}\\n```\\n---\\n### Clean solution:\\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        int runningSum = 0, ans = 0;\\n        for (int n : nums) {\\n            runningSum += n;            \\n            int rem = runningSum % k;   \\n            if (rem < 0) {\\n                rem += k;     \\n            }          \\n            ans += map.getOrDefault(rem, 0);\\n            map.put(rem , 1 + map.getOrDefault(rem, 0));\\n        }\\n\\n        return ans;     \\n    }\\n}\\n```\\n#### Time complexity: $$O(n)$$\\n#### Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Counting",
                    "Prefix Sum"
                ],
                "code": "``` \\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        // check all possible subarrays,\\n        // take their sum, increment the count if divisible by k\\n        int total = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int sum = 0;\\n            for (int j = i; j < nums.length; j++) {\\n                sum += nums[j];\\n                if (sum % k == 0) total++;\\n            }\\n        }\\n\\n        return total;\\n    }\\n}\\n\\n```\n```\\nRemainder at index i = Remainder at index j\\n    S2 % k = S1 % k\\n => S2 % k - S1 % k = 0\\n => (S2 - S1) % k = 0\\n => (Sum of subarray from i + 1 to j) % k = 0\\n```\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        // map to store the remainders and number of times they\\'ve been encountered\\n        Map<Integer, Integer> map = new HashMap<>();\\n        // our sum is initially 0, and 0 is also divisible by k\\n        // there would be a case when remainder would actually be zero\\n        // so the array from the beginning to that index is our candidate subarray\\n        // so to address that case, so we put <0, 1> initially\\n        map.put(0, 1);\\n        int runningSum = 0, ans = 0;\\n        for (int n : nums) {\\n            runningSum += n;            // add the element to the running sum\\n            int rem = runningSum % k;   // get the remainder by k of our running sum so far\\n            if (rem < 0) {              // in case remainder < 0, \\n                rem += k;               // add divisor (k) to make it +ve\\n            }\\n            // if we already encountered the remainder, we add the frequency mapped to it\\n            // that frequency is nothing but the number of subarrays whose sum has given that remainder \\n            ans += map.getOrDefault(rem, 0);\\n            // after that, we increment the frequency of that remainder,\\n            // because we have encountered it again so the number of subarrays increases by 1\\n            map.put(rem , 1 + map.getOrDefault(rem, 0));\\n        }\\n\\n        return ans;     // return the answer\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        int runningSum = 0, ans = 0;\\n        for (int n : nums) {\\n            runningSum += n;            \\n            int rem = runningSum % k;   \\n            if (rem < 0) {\\n                rem += k;     \\n            }          \\n            ans += map.getOrDefault(rem, 0);\\n            map.put(rem , 1 + map.getOrDefault(rem, 0));\\n        }\\n\\n        return ans;     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070599,
                "title": "day-19-explanation-with-diagram-prefix-sum-and-hashmap-o-n-time-and-o-n-space",
                "content": "\\n# Intuition\\nWe will use hashmap or array and also use the concept of prefix sum to solve this problem.\\n![WhatsApp Image 2023-01-19 at 7.06.08 AM.jpeg](https://assets.leetcode.com/users/images/7ec413ac-360c-4a90-98a2-64dccd7cb91f_1674092298.9756303.jpeg)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize an empty vector called \"output\" of size \"k\" to keep track of the count of subarrays that have the same remainder when divided by \"k\".\\n2. Initialize a variable \"prefixMod\" to store the current prefix sum modulo \"k\" and a variable \"res\" to store the total count of subarrays that have a remainder of 0 when divided by \"k\".\\n3. Set the first element of \"output\" to 1, this is because the first prefix sum would have a remainder of 0.\\n4. Iterate through each element \"nums[i]\" in the input vector \"nums\".\\n5. Calculate the current prefix sum modulo \"k\" by adding the current element \"nums[i]\" to the previous prefix sum modulo \"k\" and taking the remainder when divided by \"k\".\\n6. Add the count of subarrays that have the same remainder to \"res\" by getting the value of the corresponding index in the \"output\" vector.\\n7. Increase the count of subarrays that have the same remainder by 1 by incrementing the value of the corresponding index in the \"output\" vector.\\n8. Return the total count of subarrays that have a remainder of 0 when divided by \"k\" stored in \"res\".\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        vector<int> output(k, 0);\\n        // prefixModSum is used to store sum of all prefix mods\\n        int prefixModSum = 0;\\n        int res = 0;\\n        output[0] = 1;\\n        for(int i = 0; i < nums.size(); i++){\\n            // (nums[i] % k + k) is used to avoid nagative remsinder\\n            prefixModSum = (prefixModSum + nums[i] % k + k) % k;\\n            //If in test case, only positive number given like [5,0,5,3] then\\n            //prefixModSum = prefixModSum + nums[i] % k;\\n            // Add the count of subarrays that have the same remainder\\n            res = res + output[prefixModSum];\\n            output[prefixModSum]++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        int[] output = new int[k];\\n        // prefixModSum is used to store sum of all prefix mods\\n        int prefixMod = 0;\\n        int res = 0;\\n        output[0] = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            // (nums[i] % k + k) is used to avoid negative remainder\\n            prefixMod = (prefixMod + nums[i] % k + k) % k;\\n            //If in test case, only positive number given like [5,0,5,3] then\\n            //prefixModSum = prefixModSum + nums[i] % k;\\n            // Add the count of subarrays that have the same remainder\\n            res = res + output[prefixMod];\\n            output[prefixMod]++;\\n        }\\n        return res;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        output = [0]*k\\n        prefix_mod = 0\\n        res = 0\\n        output[0] = 1\\n        for i in range(len(nums)):\\n            # (nums[i] % k + k) is used to avoid negative remainder\\n            prefix_mod = (prefix_mod + nums[i] % k + k) % k\\n            # Add the count of subarrays that have the same remainder\\n            res = res + output[prefix_mod]\\n            output[prefix_mod] += 1\\n        return res\\n\\n```\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Complexity\\n- Time complexity: **O(n)** // where n is the size of arr\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)** // we are using extra space of size n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        vector<int> output(k, 0);\\n        // prefixModSum is used to store sum of all prefix mods\\n        int prefixModSum = 0;\\n        int res = 0;\\n        output[0] = 1;\\n        for(int i = 0; i < nums.size(); i++){\\n            // (nums[i] % k + k) is used to avoid nagative remsinder\\n            prefixModSum = (prefixModSum + nums[i] % k + k) % k;\\n            //If in test case, only positive number given like [5,0,5,3] then\\n            //prefixModSum = prefixModSum + nums[i] % k;\\n            // Add the count of subarrays that have the same remainder\\n            res = res + output[prefixModSum];\\n            output[prefixModSum]++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        int[] output = new int[k];\\n        // prefixModSum is used to store sum of all prefix mods\\n        int prefixMod = 0;\\n        int res = 0;\\n        output[0] = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            // (nums[i] % k + k) is used to avoid negative remainder\\n            prefixMod = (prefixMod + nums[i] % k + k) % k;\\n            //If in test case, only positive number given like [5,0,5,3] then\\n            //prefixModSum = prefixModSum + nums[i] % k;\\n            // Add the count of subarrays that have the same remainder\\n            res = res + output[prefixMod];\\n            output[prefixMod]++;\\n        }\\n        return res;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        output = [0]*k\\n        prefix_mod = 0\\n        res = 0\\n        output[0] = 1\\n        for i in range(len(nums)):\\n            # (nums[i] % k + k) is used to avoid negative remainder\\n            prefix_mod = (prefix_mod + nums[i] % k + k) % k\\n            # Add the count of subarrays that have the same remainder\\n            res = res + output[prefix_mod]\\n            output[prefix_mod] += 1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501299,
                "title": "learn-the-prefix-sum-pattern-python-solution-extra-problems-to-help-you",
                "content": "So whenver I see `subarray` I usually think prefix or suffix sum.\\n\\nI am also not fond of mathematical explanations of programming questions unless the question is maths based and even then, I still am not a fan of formal mathermical language if you can explain things better. (not saying this question is maths based, but I did see formal math explanations of it for some reason).\\n\\nHere\\'s 2 questions that will help you learn more about this pattern: \\n`560. Subarray Sum Equals K. https://leetcode.com/problems/subarray-sum-equals-k/ `\\n\\n\\n\\n**560 will teach how to cumulatively keep track of a sum using a dictionary(hasmap) with a count.**\\nThis is essentially what a continous subarray is. It is the sum of all previous nums up to a certain index.\\n\\n`solution for 560`:\\n\\n\\tclass Solution:\\n\\t\\t\\'\\'\\'\\n\\t\\tTime: O(n)\\n\\t\\tSpace: O(n)\\n\\t\\t\\'\\'\\'\\n\\t\\tdef subarraySum(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tfreq, prefix_sum, total = {0:1}, 0, 0\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tprefix_sum += num\\n\\t\\t\\t\\ttotal += freq.get(prefix_sum-k, 0)\\n\\t\\t\\t\\tfreq[prefix_sum] = freq.get(prefix_sum, 0) + 1\\n\\n\\t\\t\\treturn total\\n\\t\\n\\n`523. Continuous Subarray Sum https://leetcode.com/problems/continuous-subarray-sum/`\\n\\n**523 will teach that you can use modulo to cumulatively sum elements in an array whilst keeping track of where you are in nums index wise whilst also checking if the current subarray sum (prefix sum) adheres to some condition. That may be that k is a multiple of a number, divisble by k, etc.**\\n\\nsolution for 523:\\n\\n\\t class Solution:\\n\\t \\t\\'\\'\\'\\n\\t\\tTime: O(n)\\n\\t\\tSpace: O(k) where k is the amount of keys the dictionary will have to hold \\n\\t\\tdepending on how many prefix sum remainders it generates as we go through nums.\\n\\t\\t\\'\\'\\'\\n\\t\\tdef checkSubarraySum(self, nums: List[int], k: int) -> bool:\\n\\t\\t\\td = {0:-1}\\n\\t\\t\\tprefix_sum = 0\\n\\n\\t\\t\\tfor i, num in enumerate(nums):\\n\\t\\t\\t\\t# if we see this remainder again it means prefix_sum is a multiple of k\\n\\t\\t\\t\\tprefix_sum = (prefix_sum + num) % k\\n\\n\\t\\t\\t\\tif prefix_sum not in d:\\n\\t\\t\\t\\t\\td[prefix_sum] = i\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif i - d[prefix_sum] >= 2:\\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False\\n\\n                \\n        \\nAnd thus, that is how I solved this question pretty fast using those ideas I learnt from the above question, below:\\n\\n\\t\\n\\tclass Solution:\\n\\t\\tdef subarraysDivByK(self, nums: List[int], k: int) -> int:\\n\\t\\t\\td = {0: 1}\\n\\t\\t\\tprefix_sum, count = 0, 0\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tprefix_sum = (prefix_sum + num) % k\\n\\t\\t\\t\\tcount += d.get(prefix_sum, 0)\\n\\n\\t\\t\\t\\t# make the new prefix_sum key be whatever the old value was + 1\\n\\t\\t\\t\\td[prefix_sum] = d.get(prefix_sum, 0) + 1\\n\\n\\t\\t\\treturn count\\n\\nSomeone may also ask, why modulo at all? Well that\\'s because that\\'s what it\\'s meant for. It\\'s way to map some value into memory in a clock like fashion if that value somehow leads to the same mapping against another value.\\ni.e in this case, 2 different subarrays with the same sum are both divisble by k so they end up pointing to the same key.\\n(try learn about consistent hashing - the algorithm behind load balancing - and how hashmaps are designed for more details).\\n\\njust a note, a very simple hashmap can use soemthing like, `some_number % some_prime_number` to map to a key in a hashmap. \\n\\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "class Solution:\\n\\t\\t\\'\\'\\'\\n\\t\\tTime: O(n)\\n\\t\\tSpace: O(n)\\n\\t\\t\\'\\'\\'\\n\\t\\tdef subarraySum(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tfreq, prefix_sum, total = {0:1}",
                "codeTag": "Java"
            },
            {
                "id": 3070571,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=eo4oVvR8Nhs&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=19) if you are interested.\\n\\n---\\n\\n**\\uD83D\\uDCCC Question: Why do we convert the Negative prefix sum modulo into its equivalent positive mod?**\\n\\n**\\uD83D\\uDCCC Answer (By community member jit):** \\n\\nMany languages implement the % operator differently for negative numbers such that m % n is negative if m is negative, so we need to treat that case specially. For example, -3 % 10 would equal -3 in a bunch of languages like c, c++, and java, but equals 7 in languages like python.\\n\\nIf we\\'re trying to group the values into congruence classes mod k, we want all of our \"groups\" to be positive. hence, we need to convert for languages that won\\'t automatically do it for us\\n\\nHere\\'s a common way to calculate the \"positive mod\" of two numbers:\\n\\n```cpp\\nint mod(int x, int k) {\\n    // Returns the value of (x % k)\\n    return (x % k + k) % k;\\n}\\n```\\n\\n<iframe src=\"https://leetcode.com/playground/W7o3JDLL/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Rust"
                ],
                "code": "```cpp\\nint mod(int x, int k) {\\n    // Returns the value of (x % k)\\n    return (x % k + k) % k;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3071672,
                "title": "simple-c-o-n-beats-100-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo if think of naive approach that can be done by checking all the subarrays are dvisible by k or not .And that will be done by using two two loops in O(n^2). So we dont want TLE ,so we have to optimize..\\nSo directly coming to point there is a property of prefix sum here that if we subtract two pref sums and they are divsible by k then their individual remainders are same i.e\\n`If (Pref[i]-Pref[j])%k==0 `\\n`then pref[i]%k==pref[j]%k`\\ncan be easily proved using `number = divisor \\xD7 quotient + remainder`\\nso `pref[i]=d*qi +r1`\\n   `pref[j]=d*qj +r2`\\n   `pref[i]-pref[j]`=`d*(qi-qj) +(r1-r2)`\\n  d*(qi-qj) is already divisble by k now if `(r1-r2)%k=0`\\n Since r1 and r2 are both less than k  so `r1=r2;`\\n So if two prefix sums have same remainders they are also divisble by k \\nSo After All this main idea is if two pref sums have same remainder they add  up to answer because the subarray between them have sum divisible by k \\ne.g\\nk=3\\n aray nums: 1 3 `5 4` 5 6 7\\n pref sums: 1 4 9 13 18 24 31\\ntaking this 1 4 `9 13` 18 24 31\\nwe know 13 -4 = 9 %3=0\\napplying property 13%3=1 and 4%3 =1\\nso subarray between 4 and 13 pref sum will be divible by k\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo we can loop through the array and store a prefix sum in a variable and keep checking its remainder if its same with other it will add up to our answer . \\nWe need to store the occurences of remainder in an array of size k beacuse remainders are form `o to k-1` .\\nAnd we also need to initialize pref[0]=1 because whole array can be divisible or individual pref sums can be divisible by k (i.e when ever remanider is zero )\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Naive approach**\\n```\\n         for(int i=0;i<n;i++){\\n             int sum=arr[i];\\n             if(sum%k==0)c++;\\n             for(int j=i+1;j<n;j++){\\n                 sum+=arr[j];\\n             if(sum%k==0)c++;\\n             }\\n         } \\n         return c;\\n\\n```\\n**Optimized Using Prefix sum Property**\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int ans=0;\\n\\t    vector<int>pref(k,0);\\n\\t    int sum=0;\\n\\t    pref[0]++;\\n\\t    for(int i=0;i<n;i++){\\n\\t        sum+=arr[i];\\n\\t        int rem=(sum%k+k)%k;\\n\\t        ans+=pref[rem];\\n\\t        pref[rem]++;\\n\\t    }\\n\\t    return ans;\\n       \\n\\n    }\\n};\\n```\\n**UpVote If HELPFULL\\uD83D\\uDD3C\\uD83D\\uDD3C**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n         for(int i=0;i<n;i++){\\n             int sum=arr[i];\\n             if(sum%k==0)c++;\\n             for(int j=i+1;j<n;j++){\\n                 sum+=arr[j];\\n             if(sum%k==0)c++;\\n             }\\n         } \\n         return c;\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int ans=0;\\n\\t    vector<int>pref(k,0);\\n\\t    int sum=0;\\n\\t    pref[0]++;\\n\\t    for(int i=0;i<n;i++){\\n\\t        sum+=arr[i];\\n\\t        int rem=(sum%k+k)%k;\\n\\t        ans+=pref[rem];\\n\\t        pref[rem]++;\\n\\t    }\\n\\t    return ans;\\n       \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 218015,
                "title": "python-solution",
                "content": "We initialize the result `res = 0`. We iterate over `A`, and use a variable `summ` to keep track of prefix sum up to current index `i` modulo `K`, i.e., `summ = (A[0] + ... A[i]) % K`. If some subarray ending with `i` has sum divisible by `K`, it means that `(A[j] + ... + A[i]) % K == 0` for some `j < i`, which equivalently means that `(A[0] + ... + A[j]) % K == summ`. If we use to dictionary `dic` to count the number of appearances of all prefix sums modulo `K` ending with `j` for all `j < i`, then the number of subarrays ending with `i` that has sum divisible by `K` is `dic[summ]`, so we increment `res`: `res += dic[summ]`, and increment the count of `summ`: `dic[summ] += 1`. Finally, we return `res`.\\n\\nTime complexity: `O(n)`, space complexity: `O(K)`.\\n\\n```\\nclass Solution(object):\\n    def subarraysDivByK(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: int\\n        \"\"\"\\n        summ = 0\\n        res = 0\\n        dic = {0:1}\\n        for a in A:\\n            summ = (summ + a) % K\\n            if summ in dic:\\n                res += dic[summ]\\n                dic[summ] += 1\\n            else:\\n                dic[summ] = 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def subarraysDivByK(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: int\\n        \"\"\"\\n        summ = 0\\n        res = 0\\n        dic = {0:1}\\n        for a in A:\\n            summ = (summ + a) % K\\n            if summ in dic:\\n                res += dic[summ]\\n                dic[summ] += 1\\n            else:\\n                dic[summ] = 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 217976,
                "title": "c-simple-slow-dp",
                "content": "Note that this solution has O(n * n) worst case complexity; but I got stuck during the contest and this is was the best I could come up with :)\\n\\nIf we find a sum divisible by K at index ```i```, then we can just add the number of subarrays for interval [i + 1, n). So, if we start from the end of the array, and record number of subarrays for each index, then for the next index ```i``` we only need to check till we find the first divisible sum ```[i, j]```, and add pre-calculated number of subarrays for index ```j + 1```.\\n\\n![image](https://assets.leetcode.com/users/votrubac/image_1589515276.png)\\n\\n```\\nint subarraysDivByK(vector<int>& A, int K) {\\n  vector<int> dp(A.size() + 1, 0);\\n  for (int i = A.size() - 1; i >= 0; --i)\\n    for (int j = i, sum = 0; j < A.size(); ++j) {\\n      sum += A[j];\\n      if (sum % K == 0) {\\n        dp[i] = 1 + dp[j + 1];\\n        break;\\n      }\\n    }\\n  return accumulate(begin(dp), end(dp), 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```i```\n```i```\n```[i, j]```\n```j + 1```\n```\\nint subarraysDivByK(vector<int>& A, int K) {\\n  vector<int> dp(A.size() + 1, 0);\\n  for (int i = A.size() - 1; i >= 0; --i)\\n    for (int j = i, sum = 0; j < A.size(); ++j) {\\n      sum += A[j];\\n      if (sum % K == 0) {\\n        dp[i] = 1 + dp[j + 1];\\n        break;\\n      }\\n    }\\n  return accumulate(begin(dp), end(dp), 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 808672,
                "title": "easy-understanding-c",
                "content": "\\n      class Solution {\\n      public:\\n          int subarraysDivByK(vector<int>& A, int k) {\\n              unordered_map<int,int> map;\\n              map[0]++;\\n              int cumsum=0;\\n              int count=0;\\n              for(int i=0;i<A.size();i++){\\n                  cumsum+=A[i];\\n                  int remainder=cumsum%k;\\n                  if(remainder<0) remainder+=k; // since -1 mod 5 and 4 mod 5 are equivalent\\n                  if(map.count(remainder)>0){\\n                      count+=map[remainder];//if we have already found remainder, then increase the count\\n                  }\\n                  map[remainder]++;\\n              }\\n              return count;\\n          }\\n      };\\n\\t  \\n[check out this to get better understanding](https://www.youtube.com/watch?v=ufXxc8Vty9A)\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n      public:\\n          int subarraysDivByK(vector<int>& A, int k) {\\n              unordered_map<int,int> map;\\n              map[0]++;\\n              int cumsum=0;\\n              int count=0;\\n              for(int i=0;i<A.size();i++){\\n                  cumsum+=A[i];\\n                  int remainder=cumsum%k;\\n                  if(remainder<0) remainder+=k; // since -1 mod 5 and 4 mod 5 are equivalent\\n                  if(map.count(remainder)>0){\\n                      count+=map[remainder];//if we have already found remainder, then increase the count\\n                  }",
                "codeTag": "Java"
            },
            {
                "id": 344436,
                "title": "simple-python-dp-solution",
                "content": "Please see and vote for my solution for these similar problems.\\n[560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/discuss/344431/Simple-Python-DP-solution)\\n[974. Subarray Sums Divisible by K](https://leetcode.com/problems/subarray-sums-divisible-by-k/discuss/344436/Simple-Python-DP-solution)\\n[325. Maximum Size Subarray Sum Equals k](https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/discuss/344432/Simple-Python-DP-solution)\\n[1074. Number of Submatrices That Sum to Target](https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/discuss/344440/Simple-Python-DP-solution)\\n[363. Max Sum of Rectangle No Larger Than K](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/discuss/445540/Python-bisect-solution-(960ms-beat-71.25))\\n\\n```\\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\\n        preSums = {0: 1}\\n        s = 0\\n        res = 0\\n        for x in A:\\n            s = (s + x) % K\\n            res += preSums.get(s, 0)\\n            preSums[s] = preSums.get(s, 0) + 1\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\\n        preSums = {0: 1}\\n        s = 0\\n        res = 0\\n        for x in A:\\n            s = (s + x) % K\\n            res += preSums.get(s, 0)\\n            preSums[s] = preSums.get(s, 0) + 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3071084,
                "title": "java-solution-with-comments",
                "content": "\\n\\n\\n# Code 1\\n```\\nclass Solution {\\n    // method to find the number of subarrays whose sum is divisible by k\\n    public int subarraysDivByK(int[] nums, int k) {\\n        // create an array to store the count of remainder for each index\\n        int [] remainderArray = new int[k];\\n // initialize the first element of remainder array as 1 \\n        remainderArray[0] = 1;\\n        // initialize sum and count as 0\\n        int sum = 0, count = 0;\\n        // iterate through the given array\\n        for(int a : nums){\\n            // update the sum by adding current element to previous sum\\n            sum = (sum + a) % k;\\n            // if sum is negative, add k to make it positive\\n            if(sum < 0) sum += k;\\n            // add the count of subarrays with same remainder to the count\\n            count += remainderArray[sum];\\n            // increment the count of current remainder\\n            remainderArray[sum]++;\\n        }\\n        // return the final count\\n        return count;\\n    }\\n}\\n\\n```\\n# code 2\\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        // Create a HashMap to store the remainder count\\n        Map<Integer, Integer> remainderCount = new HashMap<>();\\n        // Initialize the count of 0 remainder to 1\\n        remainderCount.put(0, 1);\\n        // Initialize the sum to 0\\n        int sum = 0;\\n        // Initialize the result to 0\\n        int result = 0;\\n        // Iterate through the array\\n        for(int a : nums){\\n            // Add the current element to the sum\\n            sum = (sum + a) % k;\\n            // If the sum is negative, add k to make it positive\\n            if(sum < 0) sum += k;\\n            // If the remainder count map contains the current remainder, add the count to the result\\n            if(remainderCount.containsKey(sum)){\\n                result += remainderCount.get(sum);\\n            }\\n            // Add the current remainder to the remainder count map\\n            remainderCount.put(sum, remainderCount.getOrDefault(sum, 0) + 1);\\n        }\\n        // Return the result\\n        return result;\\n    }\\n}\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // method to find the number of subarrays whose sum is divisible by k\\n    public int subarraysDivByK(int[] nums, int k) {\\n        // create an array to store the count of remainder for each index\\n        int [] remainderArray = new int[k];\\n // initialize the first element of remainder array as 1 \\n        remainderArray[0] = 1;\\n        // initialize sum and count as 0\\n        int sum = 0, count = 0;\\n        // iterate through the given array\\n        for(int a : nums){\\n            // update the sum by adding current element to previous sum\\n            sum = (sum + a) % k;\\n            // if sum is negative, add k to make it positive\\n            if(sum < 0) sum += k;\\n            // add the count of subarrays with same remainder to the count\\n            count += remainderArray[sum];\\n            // increment the count of current remainder\\n            remainderArray[sum]++;\\n        }\\n        // return the final count\\n        return count;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        // Create a HashMap to store the remainder count\\n        Map<Integer, Integer> remainderCount = new HashMap<>();\\n        // Initialize the count of 0 remainder to 1\\n        remainderCount.put(0, 1);\\n        // Initialize the sum to 0\\n        int sum = 0;\\n        // Initialize the result to 0\\n        int result = 0;\\n        // Iterate through the array\\n        for(int a : nums){\\n            // Add the current element to the sum\\n            sum = (sum + a) % k;\\n            // If the sum is negative, add k to make it positive\\n            if(sum < 0) sum += k;\\n            // If the remainder count map contains the current remainder, add the count to the result\\n            if(remainderCount.containsKey(sum)){\\n                result += remainderCount.get(sum);\\n            }\\n            // Add the current remainder to the remainder count map\\n            remainderCount.put(sum, remainderCount.getOrDefault(sum, 0) + 1);\\n        }\\n        // Return the result\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488733,
                "title": "java-linear-hashmap-solution",
                "content": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int K) {\\n        if(nums==null || nums.length==0) return 0;\\n        \\n        int ans=0;\\n        int remSum=0;\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        map.put(0,1);           //Freq of 0 as remainder is 1\\n        \\n        for(int i=0;i<nums.length;i++){\\n            remSum+=nums[i];\\n            int temp=remSum%K;\\n            if(temp<0) temp+=K;\\n            if(map.containsKey(temp)){\\n                ans+=map.get(temp);\\n            }\\n            map.put(temp,map.getOrDefault(temp,0)+1);\\n        }\\n        return ans;\\n    }\\n}   \\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int K) {\\n        if(nums==null || nums.length==0) return 0;\\n        \\n        int ans=0;\\n        int remSum=0;\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        map.put(0,1);           //Freq of 0 as remainder is 1\\n        \\n        for(int i=0;i<nums.length;i++){\\n            remSum+=nums[i];\\n            int temp=remSum%K;\\n            if(temp<0) temp+=K;\\n            if(map.containsKey(temp)){\\n                ans+=map.get(temp);\\n            }\\n            map.put(temp,map.getOrDefault(temp,0)+1);\\n        }\\n        return ans;\\n    }\\n}   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071047,
                "title": "easy-solution-full-explanation-c-python3-simple-solution",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                            Please Upvote If You Find It Helpful.\\n```\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int count=0, sm=0, mod=0; // Initialize variables to keep track of count, running sum and remainder\\n        unordered_map<int, int> mp; // Initialize an unordered_map to keep track of the number of occurrences of each remainder\\n        mp[mod]++; // Add the initial remainder (0) to the map with a count of 1\\n        for(int i=0;i<nums.size();i++){\\n            sm += nums[i]; // Update the running sum\\n            mod = sm%k; // Update the remainder\\n            if(mod < 0)\\n                mod += k; // If the remainder is negative, add k to make it positive\\n            if(mp.find(mod)!=mp.end()){ // Check if the remainder is already present in the map\\n                count += mp[mod]; // If it is, add the number of occurrences of that remainder to the count\\n                mp[mod]++; // Increment the count for that remainder in the map\\n            }\\n            else\\n                mp[mod]++; // If the remainder is not present in the map, add it with a count of 1\\n        }\\n        return count;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        count = 0 # Initialize variable to keep track of count\\n        sm = 0 # Initialize variable to keep track of running sum\\n        mod = 0 # Initialize variable to store remainder\\n        mp = {} # Initialize dictionary to keep track of the number of occurrences of each remainder\\n        mp[mod] = 1 # Initial remainder is 0\\n        for i in range(len(nums)):\\n            sm += nums[i] # Update running sum\\n            mod = sm % k # Update remainder\\n            if mod < 0:\\n                mod += k # If remainder is negative, add k to make it positive\\n            if mod in mp:\\n                count += mp[mod] # If remainder is already present in dictionary, add the number of occurrences of that remainder to the count\\n                mp[mod] += 1 # Increment the count for that remainder in the dictionary\\n            else:\\n                mp[mod] = 1 # If remainder is not present in the dictionary, add it with a count of 1\\n        return count\\n\\n```\\n```\\n                                        Give a \\uD83D\\uDC4D\\n```\\nIf you find the solution helpful please support and connect on [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\n                            Please Upvote If You Find It Helpful.\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int count=0, sm=0, mod=0; // Initialize variables to keep track of count, running sum and remainder\\n        unordered_map<int, int> mp; // Initialize an unordered_map to keep track of the number of occurrences of each remainder\\n        mp[mod]++; // Add the initial remainder (0) to the map with a count of 1\\n        for(int i=0;i<nums.size();i++){\\n            sm += nums[i]; // Update the running sum\\n            mod = sm%k; // Update the remainder\\n            if(mod < 0)\\n                mod += k; // If the remainder is negative, add k to make it positive\\n            if(mp.find(mod)!=mp.end()){ // Check if the remainder is already present in the map\\n                count += mp[mod]; // If it is, add the number of occurrences of that remainder to the count\\n                mp[mod]++; // Increment the count for that remainder in the map\\n            }\\n            else\\n                mp[mod]++; // If the remainder is not present in the map, add it with a count of 1\\n        }\\n        return count;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        count = 0 # Initialize variable to keep track of count\\n        sm = 0 # Initialize variable to keep track of running sum\\n        mod = 0 # Initialize variable to store remainder\\n        mp = {} # Initialize dictionary to keep track of the number of occurrences of each remainder\\n        mp[mod] = 1 # Initial remainder is 0\\n        for i in range(len(nums)):\\n            sm += nums[i] # Update running sum\\n            mod = sm % k # Update remainder\\n            if mod < 0:\\n                mod += k # If remainder is negative, add k to make it positive\\n            if mod in mp:\\n                count += mp[mod] # If remainder is already present in dictionary, add the number of occurrences of that remainder to the count\\n                mp[mod] += 1 # Increment the count for that remainder in the dictionary\\n            else:\\n                mp[mod] = 1 # If remainder is not present in the dictionary, add it with a count of 1\\n        return count\\n\\n```\n```\\n                                        Give a \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1685120,
                "title": "multiple-c-solutions-with-explanations-time-complexity-o-n",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- If we modular any number with ***k*** the result will always be less than k.\\n- Here we took a ***k*** size array to store the number of occurrences of every number from 0 to k.\\n- From start to end we\\u2019ll count the occurrences, if ***index 2 have modules value 3 & also index 5 have the same value, then from 2 to 5 elements will be divisible with k.***\\n- To store the sum we\\u2019ll first mod the element, but that could be negative. So, if we add k with it and mod it again it will be positive.\\n- Them in the array mp, we\\u2019ll store all the occurrence count. We\\u2019ve done ***sum%k*** because the sum value could be greater than k, by this we\\u2019ll keep it in our range.\\n- Then we\\u2019ll traverse the array and use the formula ***nC2,*** to calculate the total number.\\n- Edge case: for 0 the formula is ***nC2+n.*** We added the no of 0th element in the count array before starting to avoid this extra calculation.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01: Using Vector\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int sum=0, count=0;\\n        int n=nums.size();\\n        vector<int> mp(k, 0);\\n        \\n        for(auto x:nums){\\n            sum += (x%k+k)%k;\\n            mp[sum%k]++;\\n        }\\n        count = mp[0];\\n        \\n        for(int a:mp){\\n            count +=  (a*(a-1))/2;\\n        }\\n        \\n        return count;\\n    }\\n};**\\n\\n//Solution 02: Using Map\\n**class Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int sum=0, count=0;\\n        int n=nums.size();\\n        unordered_map<int, int> mp;\\n        \\n        for(auto x:nums){\\n            sum += x;\\n            mp[(sum%k + k)%k]++;\\n        }\\n        count = mp[0];\\n        \\n        for(auto x:mp){\\n            int a = x.second;\\n            count +=  (a*(a-1))/2;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01: Using Vector\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int sum=0, count=0;\\n        int n=nums.size();\\n        vector<int> mp(k, 0);\\n        \\n        for(auto x:nums){\\n            sum += (x%k+k)%k;\\n            mp[sum%k]++;\\n        }\\n        count = mp[0];\\n        \\n        for(int a:mp){\\n            count +=  (a*(a-1))/2;\\n        }\\n        \\n        return count;\\n    }\\n};**\\n\\n//Solution 02: Using Map\\n**class Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int sum=0, count=0;\\n        int n=nums.size();\\n        unordered_map<int, int> mp;\\n        \\n        for(auto x:nums){\\n            sum += x;\\n            mp[(sum%k + k)%k]++;\\n        }\\n        count = mp[0];\\n        \\n        for(auto x:mp){\\n            int a = x.second;\\n            count +=  (a*(a-1))/2;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222760,
                "title": "need-explanation-eli5",
                "content": "**Edit; summary of learnings**\\n\\nThanks [`@maobubu`][] for the help!\\n\\n**Problem**\\n\\nGiven an array  `A`  of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by  `K`.\\n\\n**Terms**\\n\\nTerm | Description | More\\n---- | ---- | ----\\n`A` | Defined in `Problem`.\\n`K` | Defined in `Problem`.\\n`A[i, j]` | Sum of values between `i` and `j`, inclusive. ![image](https://assets.leetcode.com/users/overattribution/image_1548308429.png).\\n`P` | Prefix sum of subarray where ![image](https://assets.leetcode.com/users/overattribution/image_1548308453.png). | [geeksforgeeks][]\\n`n` | `A.length`\\n\\n**Observations**\\n\\n*Observation 1:*\\n\\nThis observation taken from [geeksforgeeks][] article.\\n\\nHow to sum sub-array in a given range using prefix array: ![image](https://assets.leetcode.com/users/overattribution/image_1548308478.png)\\n\\nWe want to find sub-arrays divisible by `K`, so let\\'s put `P` in terms of `K`:  ![image](https://assets.leetcode.com/users/overattribution/image_1548308508.png), where `q` is some quotient and `r` is some remainder.\\n\\nWith this new definition of `P[i]` we can restate `A[i, j]` as follows: \\n![image](https://assets.leetcode.com/users/overattribution/image_1548308542.png)\\n\\nLet\\'s play with the algebra here to see what we can learn:\\n![image](https://assets.leetcode.com/users/overattribution/image_1548308572.png)\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1548308602.png) is obviously divisible by `K`.\\n\\n`A[i, j]` will be divisible when ![r_1=r_2][]. What about the larger set of r-values when ![r_1-r_2_mod_K][]? Is that possible?\\n\\n*Observation 2:*\\n\\nThis observation inpsired by [`@ramanahuja`][]\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1548304734.png)\\n\\n1. Add `1` to `A[i, j]`. ![r_1][], but not ![r_2][], would also increase by 1. Repeat this until ![r_1][] is set to `0` (when `A[i, j]` is divisible by `K`).\\n2. Continue incrementing by `1` until ![r_1=r_2][] again.\\n\\nHow many times would we increment?\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1548383417.png)\\n\\nThus, ![A_i_j][] is divisible by `K` only when ![r_2_colored][] == ![r_1_colored][].\\n\\n**Implementation**\\n\\nWe\\'re looking for all permutations where ![r_2_colored][] == ![r_1_colored][]. We can build a prefix remainder of sums `R` where `R[i] = P[i]%K`.\\n\\nFor example (thanks again [`@maobubu`][]):\\n\\n```\\nA = [4,5,0,-2,-3,1], K = 5\\nP = [4,9,9,7,4,5]\\nR =[4,4,4,2,4,0]\\n```\\n\\nNow the problem becomes the easier problem of: How many permutations of `i` and `j` can we choose such that `R[i] = R[j]` and `0<=i<j<n`?\\n\\n[geeksforgeeks]: https://www.geeksforgeeks.org/count-sub-arrays-sum-divisible-k/\\n[`@ramanahuja`]: https://leetcode.com/problems/subarray-sums-divisible-by-k/discuss/217979/Pictured-Explanation-Python-O(n)-Clean-Solution-8-Lines!\\n[`@maobubu`]: https://leetcode.com/maobubu\\n\\n[r_1]: https://assets.leetcode.com/users/overattribution/image_1548308783.png\\n[r_2]: https://assets.leetcode.com/users/overattribution/image_1548308750.png\\n[r_1=r_2]: https://assets.leetcode.com/users/overattribution/image_1548308869.png\\n[A_i_j]: https://assets.leetcode.com/users/overattribution/image_1548308907.png\\n[r_2_colored]: https://assets.leetcode.com/users/overattribution/image_1548308930.png\\n[r_1_colored]: https://assets.leetcode.com/users/overattribution/image_1548308949.png\\n[r_1-r_2]: https://assets.leetcode.com/users/overattribution/image_1548308631.png\\n[r_1-r_2_mod_K]: https://assets.leetcode.com/users/overattribution/image_1548634938.png\\n\\n**Original question**\\n\\nI\\'m looking for a good end-to-end explanation of the prefix count solution. I\\'ve seen many answers here wave away the answer in a few lines of text. And then there are long-drawn-out youtube videos talking about the line-by-line algorithm to solve. I\\'m looking to understand why this works intuitively.\\n\\nCan someone explain like I\\'ve never seen a prefix count before? (I get what it is in theory but not much practice applying it).\\n\\nLeetcode has an explanation here: https://leetcode.com/articles/subarray-sums-divisible-by-k/. But I don\\'t understand much of it.\\n\\n**Question 1**\\n\\n> **Intuition** ... we use prefix sums ... Then, each subarray can be written as P[j] - P[i] (for j > i). Thus, we have P[j] - P[i] equal to 0 modulo K, or equivalently P[i] and P[j] are the same value modulo K.\\n\\nAm I reading that right? `P[j]\\u2212P[i] = 0%K`? Why? And how is this insightful? Wouldn\\'t this be the same as writing `P[j]\\u2212P[i] = 0` given 0 mod anything = 0?\\n\\n**Question 2**\\n\\n> Let\\'s say there are C_x values P[i] \\u2261 x (mod K). Then, there are \\u2211_x (C_x choose 2) possible subarrays.\\n\\nWhat? (in general)\\n\\nWhat is `x`?",
                "solutionTags": [],
                "code": "```\\nA = [4,5,0,-2,-3,1], K = 5\\nP = [4,9,9,7,4,5]\\nR =[4,4,4,2,4,0]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1458072,
                "title": "c-simple-and-short-solution",
                "content": "**Idea:**\\nVery similar to regular subarray sum equals k. https://leetcode.com/problems/subarray-sum-equals-k/discuss/956383/C%2B%2BPython-Simple-and-Short-Solutions-O(n)\\nThe difference is that we store the remainders in the map.\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int count = 0, curr = 0;\\n        unordered_map<int, int> m = {{0, 1}};\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            curr = (curr + nums[i] % k + k) % k;\\n            count += m[curr];\\n            m[curr]++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int count = 0, curr = 0;\\n        unordered_map<int, int> m = {{0, 1}};\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            curr = (curr + nums[i] % k + k) % k;\\n            count += m[curr];\\n            m[curr]++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060120,
                "title": "python3-o-n-hashmap-and-prefix-sum",
                "content": "For n > m\\nAim : (sum(A[:n]) - sum(A[:m]) )%k == 0\\nthen: sum(A[:n])%k == sum(A[:m])%k\\nUse hash table to count the number of sum(A[:m])%k.\\n```\\nclass Solution:\\n    def subarraysDivByK(self, A: List[int], k: int) -> int:\\n        dic = collections.defaultdict(int)\\n        dic[0] = 1\\n        ans = 0\\n        presum = 0\\n        for num in A:\\n            presum += num\\n            ans += dic[presum%k]\\n            dic[presum%k] += 1\\n        return ans\\n\\t```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def subarraysDivByK(self, A: List[int], k: int) -> int:\\n        dic = collections.defaultdict(int)\\n        dic[0] = 1\\n        ans = 0\\n        presum = 0\\n        for num in A:\\n            presum += num\\n            ans += dic[presum%k]\\n            dic[presum%k] += 1\\n        return ans\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1300906,
                "title": "java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        /*\\n        We need to track the frequency of the orccurence of remainder of the cumulative sum.\\n        If a remainder occurs twice, it means the sum between these 2 are divisible by k, and hence the subarray\\n        between these two adds to the solution.\\n        \\n        1. Keep getting the cumulative sum\\n        2. Calculate the remainder and add K to it if it is negative\\n        3. If the remainder has occured before, it means anything between these two, plus the number of times the remainder came before, those many sub arrays are divisible by k. \\n        So add the already seen frequency to the response\\n        4. Update the frequency now and continue\\n        \\n        Note: 0 is seen once in the beginning, ie, when no element is added in cumSum, cumSum = 0 and so 0 has to initialize with frequency 1\\n        */\\n        Map<Integer, Integer> freqMap = new HashMap<>();\\n        freqMap.put(0,1);\\n        int cumSum = 0;\\n        \\n        int resp = 0;\\n        for(int i=1;i<=nums.length;++i) {\\n            cumSum +=nums[i-1];\\n            int rem = cumSum%k < 0? cumSum%k + k : cumSum%k;\\n            if(freqMap.containsKey(rem)) {\\n                resp+=freqMap.get(rem);\\n            }\\n            freqMap.put(rem, freqMap.getOrDefault(rem, 0)+1);\\n        }\\n        \\n        return resp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        /*\\n        We need to track the frequency of the orccurence of remainder of the cumulative sum.\\n        If a remainder occurs twice, it means the sum between these 2 are divisible by k, and hence the subarray\\n        between these two adds to the solution.\\n        \\n        1. Keep getting the cumulative sum\\n        2. Calculate the remainder and add K to it if it is negative\\n        3. If the remainder has occured before, it means anything between these two, plus the number of times the remainder came before, those many sub arrays are divisible by k. \\n        So add the already seen frequency to the response\\n        4. Update the frequency now and continue\\n        \\n        Note: 0 is seen once in the beginning, ie, when no element is added in cumSum, cumSum = 0 and so 0 has to initialize with frequency 1\\n        */\\n        Map<Integer, Integer> freqMap = new HashMap<>();\\n        freqMap.put(0,1);\\n        int cumSum = 0;\\n        \\n        int resp = 0;\\n        for(int i=1;i<=nums.length;++i) {\\n            cumSum +=nums[i-1];\\n            int rem = cumSum%k < 0? cumSum%k + k : cumSum%k;\\n            if(freqMap.containsKey(rem)) {\\n                resp+=freqMap.get(rem);\\n            }\\n            freqMap.put(rem, freqMap.getOrDefault(rem, 0)+1);\\n        }\\n        \\n        return resp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792736,
                "title": "easy-and-simple-explanation-mathematically-in-video-with-intuition-and-approach-in-c-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nHi everyone, i have tried to explain this problem in this video, its a part of prefix sum playlist where i have also discussed other prefix sum problems and tried to connect all of them.\\n\\nhttps://youtu.be/WtjyzPGVMBE\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        map<int,int> mp;\\n        int prefix_sum=0;\\n        mp[0]=1;\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            prefix_sum+=nums[i];\\n            if(prefix_sum<0){\\n                prefix_sum+= ceil(abs(prefix_sum)*1.0/k)*k;\\n            }\\n            prefix_sum%=k;\\n            if(mp.find(prefix_sum)!=mp.end()){\\n                ans+=mp[prefix_sum];\\n\\n            }\\n            mp[prefix_sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        map<int,int> mp;\\n        int prefix_sum=0;\\n        mp[0]=1;\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            prefix_sum+=nums[i];\\n            if(prefix_sum<0){\\n                prefix_sum+= ceil(abs(prefix_sum)*1.0/k)*k;\\n            }\\n            prefix_sum%=k;\\n            if(mp.find(prefix_sum)!=mp.end()){\\n                ans+=mp[prefix_sum];\\n\\n            }\\n            mp[prefix_sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070597,
                "title": "python3-dp-modulo-k-accumulate-99-35",
                "content": "# Intuition\\nStore number of times accumulate was modulo k\\n\\n# Code\\n```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        m, tot = [1] + [0 for i in range(k - 1)], 0\\n        \\n        for i in accumulate(nums):\\n            tot += m[i%k]\\n            m[i%k] += 1\\n        \\n        return tot\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        m, tot = [1] + [0 for i in range(k - 1)], 0\\n        \\n        for i in accumulate(nums):\\n            tot += m[i%k]\\n            m[i%k] += 1\\n        \\n        return tot\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375607,
                "title": "c-hashmap-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        int sum = 0;\\n        mp[0] = 1; // for 0 reminder.\\n        int currSum =0;\\n        int ans =0;\\n        int rem = 0;\\n        for(int i =0;i<nums.size();i++) {\\n            currSum +=nums[i];\\n            rem = currSum%k;\\n\\t\\t\\t//If rem is negative we can convert it into positive by adding k\\n\\t\\t\\t//ex. -27 = -5*5 + (-2) or -27 = -6*5 +3\\n            if(rem <0)\\n                rem+=k;\\n\\t\\t\\t// (sum2-sum1)%k = 0 hence sum2%k = sum1%k\\n            if(mp[rem]) {\\n                ans+= mp[rem];\\n            }\\n            mp[rem]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        int sum = 0;\\n        mp[0] = 1; // for 0 reminder.\\n        int currSum =0;\\n        int ans =0;\\n        int rem = 0;\\n        for(int i =0;i<nums.size();i++) {\\n            currSum +=nums[i];\\n            rem = currSum%k;\\n\\t\\t\\t//If rem is negative we can convert it into positive by adding k\\n\\t\\t\\t//ex. -27 = -5*5 + (-2) or -27 = -6*5 +3\\n            if(rem <0)\\n                rem+=k;\\n\\t\\t\\t// (sum2-sum1)%k = 0 hence sum2%k = sum1%k\\n            if(mp[rem]) {\\n                ans+= mp[rem];\\n            }\\n            mp[rem]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074664,
                "title": "python-3-2-lines-counter-t-m-98-88",
                "content": "```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int, acc = [0]) -> int:\\n\\n        for n in nums: acc.append((acc[-1]+n)%k)\\n\\n        return sum(map(lambda x: x*(x-1), Counter(acc).values()))//2\\n```\\n\\n[https://leetcode.com/problems/subarray-sums-divisible-by-k/submissions/880891757/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int, acc = [0]) -> int:\\n\\n        for n in nums: acc.append((acc[-1]+n)%k)\\n\\n        return sum(map(lambda x: x*(x-1), Counter(acc).values()))//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070642,
                "title": "92-javascript-very-easy-to-understand-with-video-explanation",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\nhttps://youtu.be/xKyxtB3d91E\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarraysDivByK = function(nums, k) {\\n    let map ={}\\n    map[0] = 1;\\n    let count = 0;\\n    let total = 0;\\n\\n    for(let num of nums){\\n        count = (count+num) %k;\\n        if(count<0) count +=k;\\n        if(map[count]) total += map[count]\\n        map[count] = map[count] ? map[count] + 1 : 1\\n    }\\n    return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarraysDivByK = function(nums, k) {\\n    let map ={}\\n    map[0] = 1;\\n    let count = 0;\\n    let total = 0;\\n\\n    for(let num of nums){\\n        count = (count+num) %k;\\n        if(count<0) count +=k;\\n        if(map[count]) total += map[count]\\n        map[count] = map[count] ? map[count] + 1 : 1\\n    }\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1969775,
                "title": "python-sol-well-explained-intution-explained-dictionary-prefix-sum",
                "content": "# EXPLANATION\\n```\\nWe can do this using two nested loops with time complexity = O(n*n) easily\\n< Now we need to optimize our solution >\\n\\nWe can do this in O(n) if we use dictionary + prefix sum\\n\\nLet us take total1 = 67 and total2 = 88 and k = 7\\n67 % 7 = 4\\n88 % 7 = 4\\n\\nSince the mod of both these number with 7 is same \\nI can say that 88 - 67 i.e. 21 is surely divisible by 7\\n\\nyes , the idea is if two totals gives same mod with k then their difference is divisible by k for sure\\n\\nTo proof take any examples by yourself\\n\\nSo what we do is for every item we check if item % k is present in our dictionary\\n            1 . If yes we add the number of times item % k is present in our dictionary\\n\\t\\t\\t2 . Else we add nothing\\n\\t\\t\\t\\n\\t\\t\\tNow we increment d[item % k ] by 1 for future checking\\n\\t\\t\\t\\n\\t\\t\\t\\n```\\n\\n\\n# CODE\\n```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        d = defaultdict(lambda:0)\\n        d[0] = 1\\n        n = len(nums)\\n        summ = 0\\n        ans = 0\\n        for i in range(n):\\n            summ += nums[i]\\n            ans += d[summ%k]\\n            d[summ%k] += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nWe can do this using two nested loops with time complexity = O(n*n) easily\\n< Now we need to optimize our solution >\\n\\nWe can do this in O(n) if we use dictionary + prefix sum\\n\\nLet us take total1 = 67 and total2 = 88 and k = 7\\n67 % 7 = 4\\n88 % 7 = 4\\n\\nSince the mod of both these number with 7 is same \\nI can say that 88 - 67 i.e. 21 is surely divisible by 7\\n\\nyes , the idea is if two totals gives same mod with k then their difference is divisible by k for sure\\n\\nTo proof take any examples by yourself\\n\\nSo what we do is for every item we check if item % k is present in our dictionary\\n            1 . If yes we add the number of times item % k is present in our dictionary\\n\\t\\t\\t2 . Else we add nothing\\n\\t\\t\\t\\n\\t\\t\\tNow we increment d[item % k ] by 1 for future checking\\n\\t\\t\\t\\n\\t\\t\\t\\n```\n```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        d = defaultdict(lambda:0)\\n        d[0] = 1\\n        n = len(nums)\\n        summ = 0\\n        ans = 0\\n        for i in range(n):\\n            summ += nums[i]\\n            ans += d[summ%k]\\n            d[summ%k] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 306932,
                "title": "java-with-explanation",
                "content": "```\\ndefine sum[i, j] as sum from nums[i] to nums[j] for 0 < i < j, \\nsum[i + 1, j] \\n= sum[0, j] - sum[0, i]\\n= q1 * K + r1 - (q2 * K + r2)\\n= (q1 - q2) * k + (r1 - r2)\\nso sum[i + 1, j] is divisible by K if r1 == r2\\n```\\nWe calculate all possible r\\'s and map them to their counts, `map[r] = count`, there are two situations:\\n1. `r != 0`, then `count * (count - 1) / 2` subarrays found\\n2. ` r == 0`, the sum itself is divisible by k, then`count` subarrays found\\n\\nPlease note that when calculate sum % K for sum < 0, we keep adding K to sum until sum is above 0 then mod K.\\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] A, int K) {\\n        int count = 0;\\n        \\n        // Map remainder to its frequency\\n        Map<Integer, Integer> rToFreq = new HashMap<>();\\n        \\n        // Accumulative sum\\n        int accSum = 0;\\n        for (int num : A) { \\n            accSum += num;\\n            while (accSum < 0) {\\n                accSum += K;\\n            }\\n            \\n            int r = (accSum % K + K) % K;\\n            rToFreq.put(r, rToFreq.getOrDefault(r, 0) + 1);\\n        }\\n        \\n        // For subarrays starting from the first element, and share the same remainder\\n        for (int freq : rToFreq.values()) {\\n            if (freq > 1) {\\n                count += freq * (freq - 1) / 2;\\n            }\\n        }\\n        \\n        // For subarrays starting from the first element, and sum divisible by k\\n        count += rToFreq.getOrDefault(0, 0);\\n        \\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\ndefine sum[i, j] as sum from nums[i] to nums[j] for 0 < i < j, \\nsum[i + 1, j] \\n= sum[0, j] - sum[0, i]\\n= q1 * K + r1 - (q2 * K + r2)\\n= (q1 - q2) * k + (r1 - r2)\\nso sum[i + 1, j] is divisible by K if r1 == r2\\n```\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] A, int K) {\\n        int count = 0;\\n        \\n        // Map remainder to its frequency\\n        Map<Integer, Integer> rToFreq = new HashMap<>();\\n        \\n        // Accumulative sum\\n        int accSum = 0;\\n        for (int num : A) { \\n            accSum += num;\\n            while (accSum < 0) {\\n                accSum += K;\\n            }\\n            \\n            int r = (accSum % K + K) % K;\\n            rToFreq.put(r, rToFreq.getOrDefault(r, 0) + 1);\\n        }\\n        \\n        // For subarrays starting from the first element, and share the same remainder\\n        for (int freq : rToFreq.values()) {\\n            if (freq > 1) {\\n                count += freq * (freq - 1) / 2;\\n            }\\n        }\\n        \\n        // For subarrays starting from the first element, and sum divisible by k\\n        count += rToFreq.getOrDefault(0, 0);\\n        \\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073054,
                "title": "c-beats-100-prefix-sum-number-theory-detailed-explanation-and-proof",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA number can be represented in terms of k i.e the divisor  by num=(a*k)+rem;\\n- -  -\\nsay num =11 & k=5 so, num can be represented 11=(2*5)+1;\\n-  -  -\\nlet\\'s assume the array as a1, a2,a3,a4 .....an\\n- - - \\n- let\\'s say dividing a1+a2 by k gives reminder x  and  dividing sum of a1+a2+a3+a4 by k also gives reminder x \\n- - -\\nwe can write (a1+a2)=(a* k)+x; (eq i)  [x is reminder]\\nsimilarly (a1+a2+a3+a4)=(b * k)+x; (eq ii)\\nsubstracting eq i from eq ii we get \\n(a1+a2+a3+a4)-(a1+a2)=(b*k)+x -  ((a* k) +x)\\na3+a4=(b-a)*k+x-x\\na3+a4=(b-a)*k \\n\\na3+a4 is a multiple of k i.e (a3+a4) is divisible by k\\nso, this is a valid subarray \\n- - -\\nlet an array be A={2,2,4,1,3,11,-3,7} and k be 5 \\n- - -\\ninitially sum is 0 (no element is taken)\\nwe store count of 0 is 1 \\nnow traverse the array \\ni) sum is 2 [A[0] is taken],remainder is 2 (sum%5 ) , no 2 is there in the map,increase the count of 2 [m[2]=1]\\nii) sum is 4 [A[1] is taken],remainder is 4(4%5),count of 4 is 0 in the map,increase the count of 4 by 1 [m[4]=1]\\niii) sum is 8 [A[2] is taken],remainder is 3(8%5),count of 3 is 0 in the map,increase the count of 3 by 1 [m[3]=1]\\niv)sum is 9 [A[3] is taken],remainder is 4(9%5),count of 4 is 1 in the map,add this to the ans(ans=1),increase the count of 4 by 1 [m[4]=2]\\nv)sum is 12 [A[4] is taken],remainder is 2(12%5),count of 2 is 1 in the map,add this to the ans(ans=2),increase the count of 2 by 1 [m[2]=2]\\nvi)sum is 23 [A[5] is taken],remainder is 3(23%5),count of 3 is 1 in the map,add this to the ans(ans=3),increase the count of 3 by 1 [m[3]=2]\\nvii)sum is 20 [A[6] is taken],remainder is 0(20%5),count of 0 is 1 in the map,add this to the ans(ans=4),increase the count of 0 by 1 [m[0]=2]\\nviii)sum is 27 [A[7] is taken],remainder is 2(27%5),count of 2 is 2 in the map,add this to the ans(ans=4+2=6),increase the count of 2 by 1 [m[2]=3]\\nhence the total subarrays which are divisible by k is 6\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is now quite clear \\nwe have to traverse the array and take the sum and store the remainder (sum%k) in a hashmap. later if we find same remainder then we have to add the number of times this remainder occurred in the array and count it and add this to our answer.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwe are traversing the array once so complexity is O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe are using a map \\nso space complexity O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        map<int,int> m;\\nint n=nums.size();\\n        m[0]=1;\\n         int sum=0,ans=0;\\n         for(int i=0;i<n;i++)\\n         {\\n             sum+=nums[i];\\n             int rem=((sum%k)+k)%k;// it handles the case for the negative numbers as well\\n             ans+=m[rem]++; // adding to the answer\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Number Theory",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        map<int,int> m;\\nint n=nums.size();\\n        m[0]=1;\\n         int sum=0,ans=0;\\n         for(int i=0;i<n;i++)\\n         {\\n             sum+=nums[i];\\n             int rem=((sum%k)+k)%k;// it handles the case for the negative numbers as well\\n             ans+=m[rem]++; // adding to the answer\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070605,
                "title": "one-pass-best-solution-intuition-approach-complexity-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry to make a prefix sum and store remainder in map.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- maintain an unordered map with initial value mapped to 0 -> 1.\\n- maintain a prefix sum variable.\\n- add current number to sum and find its remainder.\\n    - if remainder is -ve then to make it +ve we add k.\\n- check if remainder already present.\\n    - if yes then add there mp value to ans\\n- also increment that remainder value in mp\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int n = nums.size(),ans=0,sum=0,rem=0;\\n        unordered_map<int,int> mp;\\n        mp[0]=1;\\n        for(int i=0;i<n;i++){\\n            sum+= nums[i];\\n            rem = sum%k;\\n            if(rem<0)rem+=k;\\n            if(mp.count(rem))ans+=mp[rem];\\n            mp[rem]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int n = nums.size(),ans=0,sum=0,rem=0;\\n        unordered_map<int,int> mp;\\n        mp[0]=1;\\n        for(int i=0;i<n;i++){\\n            sum+= nums[i];\\n            rem = sum%k;\\n            if(rem<0)rem+=k;\\n            if(mp.count(rem))ans+=mp[rem];\\n            mp[rem]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070589,
                "title": "python3-292-ms-faster-than-95-05-of-python3-clean-and-easy-to-understand",
                "content": "```\\ndef subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        dict = defaultdict(int)\\n        dict[0] =1\\n        output = 0\\n        Sum = 0\\n        for n in nums:\\n            Sum +=n\\n            m = Sum%k\\n            output += dict[m]\\n            dict[m]+=1\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\ndef subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        dict = defaultdict(int)\\n        dict[0] =1\\n        output = 0\\n        Sum = 0\\n        for n in nums:\\n            Sum +=n\\n            m = Sum%k\\n            output += dict[m]\\n            dict[m]+=1\\n        return output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2489483,
                "title": "c-easy-o-n-solution",
                "content": "Refer to pepcoding youtube video for help\\n\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        unordered_map<int,int> mp;\\n        int ans = 0;\\n        mp[0] = 1;      //edge case for algorithm\\n        \\n        long long sum = 0;\\n\\n        for(int i =0; i<n; i++){\\n            sum+= nums[i];\\n            int rem = sum%k;\\n            \\n            //for negative cases\\n            if(rem<0) rem+=k;\\n                \\n            ans+= mp[rem];\\n            mp[rem]++;            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        unordered_map<int,int> mp;\\n        int ans = 0;\\n        mp[0] = 1;      //edge case for algorithm\\n        \\n        long long sum = 0;\\n\\n        for(int i =0; i<n; i++){\\n            sum+= nums[i];\\n            int rem = sum%k;\\n            \\n            //for negative cases\\n            if(rem<0) rem+=k;\\n                \\n            ans+= mp[rem];\\n            mp[rem]++;            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531567,
                "title": "c-map-solution-very-easy-with-mathematical-explanation-also-explained-negative-remainder",
                "content": "Property Of prefix Sum array\\n\\n    prefix[i] stores the sum till ith index\\n\\n    So if we want to find the sum of all elements from i to j, it can be found by : sum_i_to_j = prefix[j] - prefix[i-1]\\n    also we require that sum_i_to_j should be divisible by K\\n\\n    which means\\n\\n    sum_i_to_j % k = 0\\n\\n    (prefix[j] - prefix[i-1]) % k = 0 --- (1)\\n\\n    any number can be written as dividend = divisor * quotient  + remainder\\n\\n    so lets say prefix[j] = Mk + x ,    and prefix[i-1] = Nk + y\\n\\n    substituting in the above equation\\n\\n    ((Mk + x) - (Nk + y)) % k = 0\\n\\n    ((M-N)k + (x - y)) % k = 0\\n\\n    ((M-N)k%k + (x-y)%k) % k = 0\\n\\n    ((x%k - y%k)%k)%k = (x - y) % k = 0  --- (2)\\n\\n    now from equation 2, we have (x - y) % k = 0, means (x - y should be a multiple of k), so (x - y) = Qk\\n\\n    x = Qk + y\\n\\n    x%k = y%k\\n\\n    so we infer from the above relation that, if at any point we find the remainder, and there exist a point till where we get the same remainder, the subarray enclosed in between those (excluding the left point)\\n    will be divisible by K\\n\\n    Now what to do if the remainder comes out to be negative\\n\\n    for example when in C++, when we do -1 % 2 , we get the result as -1 , whereas in reality the remainder is 1\\n    so the remedy here is to just add the divisor whenever the remainder is -ve\\n\\n    so if remainder < 0, remainder += k;\\n\\t\\n```\\n\\tclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        mp[0] = 1;\\n        int sum = 0;\\n        int cnt = 0;\\n        for (int x : nums) {\\n            sum += x;\\n            int rem = sum % k;\\n            if (rem < 0) rem += k;\\n            cnt += mp[rem];\\n            mp[rem]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\tclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        mp[0] = 1;\\n        int sum = 0;\\n        int cnt = 0;\\n        for (int x : nums) {\\n            sum += x;\\n            int rem = sum % k;\\n            if (rem < 0) rem += k;\\n            cnt += mp[rem];\\n            mp[rem]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312061,
                "title": "6-line-c-solution-with-explanation",
                "content": "This is quite similar to [Leetcode 560](https://leetcode.com/problems/subarray-sum-equals-k/).\\n\\nLet **sum(i,j)** be the sum of all elements in array from index i upto but not including index j, where i < j.\\n\\nTo solve this problem, let\\'s first apply it into the prefix sum setting. We know any subarray sum **sum(i,j)** can be formulated into difference between 2 prefix sum : **sum(0,j)-sum(0,i)**. \\n\\nIn order for a subarray sum to be divisible by K, we can setup an equation.\\n\\n* \\tsum(i,j) = n\\\\*K\\n* \\tsum(0,j)-sum(0,i) = n\\\\*K\\n* \\tsum(0,j)-n\\\\*K = sum(0,i)\\n* \\t(sum(0,j)-n\\\\*K)%K = sum(0,i)%K\\n* \\tsum(0,j)%K = sum(0,i)%K\\n\\nso, we can define **sum(0,i)%K** as variable **mod** and keep track it in the prefix_sum dictionary. For each index **j**, we simply add count of **sum(0,i)%K** to our result.\\n\\nNote we need to cast negative mod to positive for correct count.\\n\\n```\\nint subarraysDivByK(vector<int>& A, int K) {\\n\\tunordered_map<int, int> prefix_sum = {{0,1}};\\n\\tint ctr = 0, mod = 0;\\n\\tfor (int x : A)\\n\\t\\tmod = (mod+(x%K)+K)%K,\\n\\t\\tctr += prefix_sum[mod]++;\\n\\treturn ctr;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint subarraysDivByK(vector<int>& A, int K) {\\n\\tunordered_map<int, int> prefix_sum = {{0,1}};\\n\\tint ctr = 0, mod = 0;\\n\\tfor (int x : A)\\n\\t\\tmod = (mod+(x%K)+K)%K,\\n\\t\\tctr += prefix_sum[mod]++;\\n\\treturn ctr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 218591,
                "title": "o-n-python-solution-and-comparison-with-problem-560-subarray-sum-equals-k",
                "content": "This problem is similar with problem [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/description/).\\n\\nThey both use Prefix Sum and a data structure to record useful information linearly. \\nThe only difference is **this problem** needs at most O(K) space to record the count of each possible reminder, while **problem 560.** may need O(N) space to record the count of each possible prefix sum.\\n\\nFor this problem, as K is fixed, we could use **an array** instead of a hashmap to access and increment the count for each possible reminder, while for **problem 560.** we need constant time access to each possible difference (prefix sum - current number), thus a hashmap is better.\\n\\nSolution for this problem:\\n```\\nclass Solution(object):\\n    def subarraysDivByK(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: int\\n        \"\"\"\\n        preSumDict = {0:1} # could use Array\\n        preSum = 0\\n        ans = 0\\n        for i in A:\\n            preSum = (preSum + i) % K\\n            if preSum in preSumDict:\\n                preSumDict[preSum] += 1\\n            else:\\n                preSumDict[preSum] = 1\\n        # print preSumDict\\n        ans = sum(map(lambda x: x*(x-1)/2, preSumDict.values()))\\n        return ans\\n```\\n\\nSolution to problem [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/description/)\\n```\\nclass Solution(object):\\n    def subarraySum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        preSumDict = {0:1}\\n        preSum = 0\\n        ans = 0\\n        for i in nums:\\n            preSum += i\\n            if preSum - k in preSumDict:\\n                ans += preSumDict[preSum - k]\\n            if preSum in preSumDict:\\n                preSumDict[preSum] += 1\\n            else:\\n                preSumDict[preSum] = 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def subarraysDivByK(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: int\\n        \"\"\"\\n        preSumDict = {0:1} # could use Array\\n        preSum = 0\\n        ans = 0\\n        for i in A:\\n            preSum = (preSum + i) % K\\n            if preSum in preSumDict:\\n                preSumDict[preSum] += 1\\n            else:\\n                preSumDict[preSum] = 1\\n        # print preSumDict\\n        ans = sum(map(lambda x: x*(x-1)/2, preSumDict.values()))\\n        return ans\\n```\n```\\nclass Solution(object):\\n    def subarraySum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        preSumDict = {0:1}\\n        preSum = 0\\n        ans = 0\\n        for i in nums:\\n            preSum += i\\n            if preSum - k in preSumDict:\\n                ans += preSumDict[preSum - k]\\n            if preSum in preSumDict:\\n                preSumDict[preSum] += 1\\n            else:\\n                preSumDict[preSum] = 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071488,
                "title": "easy-c-solution-two-line-code-easy-approach",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a variable \"count\" to keep track of the number of subarrays that are divisible by k, and a variable \"sum\" to keep track of the current sum of the subarray.\\n2. Initialize an unordered_map \"m\" with key as 0 and value as 1. This is done to handle the edge case where the entire array is divisible by k.\\n3. Iterate through the elements of the array \"nums\" using a range-based for loop.\\n4. In each iteration, calculate the current sum of the subarray by adding the current element to the current sum and taking the remainder of the sum modulo k.\\n5. If the sum is negative, add k to make it positive.\\n6. Using the current sum as the key, increment the value of the corresponding key in the map \"m\".\\n7. Add the value of the current key in the map \"m\" to the \"count\" variable.\\n8. Finally, return the \"count\" variable as the number of subarrays that are divisible by k.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is O(n). This is because the code iterates through the array once, and performs a constant time operation on the unordered_map for each element. The unordered_map has a constant time complexity for operations like insertion and lookup, so the overall time complexity is O(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is O(min(n,k)), because the code uses an unordered_map to keep track of the remainders of the subarrays when divided by k. The size of the map is determined by the number of distinct remainders encountered in the array, which is at most min(n,k), where n is the size of the input array and k is the divisor. As we can see the size of the map will be at most k, so the space complexity is O(k).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int count = 0, sum = 0;\\n        unordered_map<int, int> m{{0, 1}};\\n        for(int num : nums) {\\n            sum = (sum + num) % k;\\n            if(sum < 0) sum += k;\\n            count += m[sum]++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n**If you found this helpful, give it an upvote to show your appreciation and motivate me to continue providing solutions!**\\n***Want to connect?***\\n[https://www.linkedin.com/in/anubhav-raj-927083220/]()\\n![Your paragraph text (2).png](https://assets.leetcode.com/users/images/93766302-a6c6-4c88-a7a4-d2c8e5be49e8_1674110355.5723789.png)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int count = 0, sum = 0;\\n        unordered_map<int, int> m{{0, 1}};\\n        for(int num : nums) {\\n            sum = (sum + num) % k;\\n            if(sum < 0) sum += k;\\n            count += m[sum]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071027,
                "title": "96-faster-code",
                "content": "# C++ code\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> sums(k, 0);\\n        sums[0]++;\\n        int cnt = 0;\\n        int currSum = 0;\\n        for(int i = 0; i<n; i++) {\\n            currSum = (currSum + nums[i]%k + k)%k;\\n            cnt += sums[currSum];\\n            sums[currSum]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n*please upvote if helped*",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> sums(k, 0);\\n        sums[0]++;\\n        int cnt = 0;\\n        int currSum = 0;\\n        for(int i = 0; i<n; i++) {\\n            currSum = (currSum + nums[i]%k + k)%k;\\n            cnt += sums[currSum];\\n            sums[currSum]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070592,
                "title": "simple-explanation",
                "content": "# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\uD835\\uDDD7\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDD4\\uD835\\uDDFD\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF5 \\uD835\\uDDD8\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\n\\uD835\\uDDD6\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDEE\\uD835\\uDDFF\\uD835\\uDDF2 \\uD835\\uDDEE\\uD835\\uDDFD\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDF2\\uD835\\uDDF0\\uD835\\uDDF6\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF2\\uD835\\uDDF1\\nhttps://youtu.be/gDEfAqJ8cGA\\n# Complexity\\n- Time complexity: $$O(n+k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar subarraysDivByK = function(nums, k) {\\n    let prefixRem = 0, res = 0\\n    let map = {}\\n    for (let i = 0; i < k; i++) {\\n        map[i] = 0\\n    }\\n    map[0] = 1\\n\\n    for (let num of nums) {\\n        prefixRem = (prefixRem + num % k + k) % k\\n        res += map[prefixRem]\\n        map[prefixRem]++\\n    }\\n    return res\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subarraysDivByK = function(nums, k) {\\n    let prefixRem = 0, res = 0\\n    let map = {}\\n    for (let i = 0; i < k; i++) {\\n        map[i] = 0\\n    }\\n    map[0] = 1\\n\\n    for (let num of nums) {\\n        prefixRem = (prefixRem + num % k + k) % k\\n        res += map[prefixRem]\\n        map[prefixRem]++\\n    }\\n    return res\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3070451,
                "title": "daily-leetcoding-challenge-january-day-19",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subarray-sums-divisible-by-k/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subarray-sums-divisible-by-k/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2779403,
                "title": "python-3-line-o-n-i-have-no-idea-what-i-wrote-but-it-works",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    # subarray [i, j] is divisible by k iff sum([0, j]) % k equals to\\n    # sum([0, i]) % k. this gives me idea to use hashtable. I hash\\n    # the remainders of sums at each index. Then we compare and count\\n    # them. I\\'d never write code like this at work though, completely\\n    # unreadable, 0 chance to pass the review...\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        sums = [0]\\n        for n in nums: sums.append(sums[-1] + n)\\n        return sum([v * (v - 1) // 2 for v in Counter([n % k for n in sums]).values()])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # subarray [i, j] is divisible by k iff sum([0, j]) % k equals to\\n    # sum([0, i]) % k. this gives me idea to use hashtable. I hash\\n    # the remainders of sums at each index. Then we compare and count\\n    # them. I\\'d never write code like this at work though, completely\\n    # unreadable, 0 chance to pass the review...\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        sums = [0]\\n        for n in nums: sums.append(sums[-1] + n)\\n        return sum([v * (v - 1) // 2 for v in Counter([n % k for n in sums]).values()])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691338,
                "title": "2-approaches-using-map-vector-with-prefix-sum-both-approaches-simple-easy-c",
                "content": "Implementation\\n\\n**Using Unodered Map & Prefix Sum\\nTime Complexity = O(N), Space Complexity = O(K)**\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n         // taking a map to store the key as a remainder and value as its fequency\\n        unordered_map<int, int> mp;  \\n        mp[0] = 1;\\n        int sum = 0, count = 0;\\n        \\n        for(int itr = 0; itr < nums.size(); itr++){\\n            // adding current element into sum\\n            sum += nums[itr];\\n            \\n            // finding the remainder of the sum\\n            int sumMod = sum % k;\\n            \\n            // to handle the negative sumMod case, i.e nums[-1,2,9], k = 2\\n            // whenver sumMod is less than 0, then add k into it\\n            if(sumMod < 0) sumMod += k;\\n            \\n            // add the frequency of sumMod into count, if its not present into map, then 0 will get added, otherwise the frequency of sumMod key will get added            \\n            count += mp[sumMod];\\n            \\n            // increase the frequency of sumMod into map by 1\\n            mp[sumMod]++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n\\n\\n**Using Vector & Prefix Sum\\nTime Complexity = O(N), Space Complexity = O(K)**\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n         // taking a vector as a map to calculate the frequency if a remainder\\n        vector<int> mp(k+1, 0);\\n        mp[0] = 1;\\n        int sum = 0, count = 0;\\n        \\n        for(int itr = 0; itr < nums.size(); itr++){\\n            // adding current element into sum\\n            sum += nums[itr];\\n            \\n            // finding the remainder of the sum\\n            int sumMod = sum % k;\\n            \\n            // to handle the negative sumMod case, i.e nums[-1,2,9], k = 2\\n            // whenver sumMod is less than 0, then add k into it\\n            if(sumMod < 0) sumMod += k;\\n            \\n            // add the frequency of sumMod into count, if its not present into vector, then 0 will get added, otherwise the frequency of sumMod will get added            \\n            count += mp[sumMod];\\n            \\n            // increase the frequency of sumMod into map by 1\\n            mp[sumMod]++;\\n        }\\n        return count;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n         // taking a map to store the key as a remainder and value as its fequency\\n        unordered_map<int, int> mp;  \\n        mp[0] = 1;\\n        int sum = 0, count = 0;\\n        \\n        for(int itr = 0; itr < nums.size(); itr++){\\n            // adding current element into sum\\n            sum += nums[itr];\\n            \\n            // finding the remainder of the sum\\n            int sumMod = sum % k;\\n            \\n            // to handle the negative sumMod case, i.e nums[-1,2,9], k = 2\\n            // whenver sumMod is less than 0, then add k into it\\n            if(sumMod < 0) sumMod += k;\\n            \\n            // add the frequency of sumMod into count, if its not present into map, then 0 will get added, otherwise the frequency of sumMod key will get added            \\n            count += mp[sumMod];\\n            \\n            // increase the frequency of sumMod into map by 1\\n            mp[sumMod]++;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n         // taking a vector as a map to calculate the frequency if a remainder\\n        vector<int> mp(k+1, 0);\\n        mp[0] = 1;\\n        int sum = 0, count = 0;\\n        \\n        for(int itr = 0; itr < nums.size(); itr++){\\n            // adding current element into sum\\n            sum += nums[itr];\\n            \\n            // finding the remainder of the sum\\n            int sumMod = sum % k;\\n            \\n            // to handle the negative sumMod case, i.e nums[-1,2,9], k = 2\\n            // whenver sumMod is less than 0, then add k into it\\n            if(sumMod < 0) sumMod += k;\\n            \\n            // add the frequency of sumMod into count, if its not present into vector, then 0 will get added, otherwise the frequency of sumMod will get added            \\n            count += mp[sumMod];\\n            \\n            // increase the frequency of sumMod into map by 1\\n            mp[sumMod]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306932,
                "title": "remainder-logic-explained-with-comments-c",
                "content": "We don\\'t need to find subarrays with sum K , rather we need to find subarrays with sum divisible by K.\\n\\nSo, using remainder theorem is useful here.\\n\\nIf we have an index i, whose prefixsum(i) % k = x, \\nand index j, whose prefixsum(j) % k = x,\\n\\nthen from remainder theorem, \\n**(prefixsum(i) - prefixsum(j))% k = x - x = 0**\\n\\n**That is, the subarray (i , j] has a sum which is divisible by k**\\n\\nOnce we understand this logic, our goal is to find frequency of all such indices, whose prefix sum % k is the same, because the subarray enclosed by any 2 such indices will yield a sum divisible by k.\\nFor instance, if I have 5 indices whose prefix sum % k is 1, then choosing any 2 of them yields a unique subarray whose sum is divisible by k.\\nSo, the formula nC2 can be used, where n is the frequency calculated.\\n\\nHere is the code with explanations:\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        \\n        vector<int> check(k , 0);// stores frequency of (running sum % k)\\n        \\n        int n = nums.size();\\n        int running_sum = 0;\\n        \\n        check[0] = 1; // important to know that running sum is 0 before starting!\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            \\n            running_sum += nums[i];\\n            \\n            int rem = (k + (running_sum % k)) % k;//for handling negative mod, a % b is same as (b + (a % b)) % b\\n            \\n            check[rem]++;//incrementing the frequency of that modulus\\n        }\\n        \\n        int res = 0;\\n        \\n        for(int i = 0 ; i < k ; i ++){\\n            \\n            int x = check[i];//x now stores the number of indices whose (running sum % k) is i\\n            \\n            res += (x * (x - 1)) / 2; \\n            // nC2 is used as any two indices with same modulus can be chosen to make a subarray whose sum is multiple of k\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        \\n        vector<int> check(k , 0);// stores frequency of (running sum % k)\\n        \\n        int n = nums.size();\\n        int running_sum = 0;\\n        \\n        check[0] = 1; // important to know that running sum is 0 before starting!\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            \\n            running_sum += nums[i];\\n            \\n            int rem = (k + (running_sum % k)) % k;//for handling negative mod, a % b is same as (b + (a % b)) % b\\n            \\n            check[rem]++;//incrementing the frequency of that modulus\\n        }\\n        \\n        int res = 0;\\n        \\n        for(int i = 0 ; i < k ; i ++){\\n            \\n            int x = check[i];//x now stores the number of indices whose (running sum % k) is i\\n            \\n            res += (x * (x - 1)) / 2; \\n            // nC2 is used as any two indices with same modulus can be chosen to make a subarray whose sum is multiple of k\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 578400,
                "title": "python3-solution-based-on-subarray-sum-equals-k",
                "content": "[560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) Solution:\\n```\\nclass Solution:\\n    def subarraySum(self, nums: List[int], k: int) -> int:\\n        result,total,hmap = 0,0,{}\\n        for num in nums:\\n            hmap[total] = hmap.get(total,0) + 1\\n            total += num\\n            if hmap.get(total-k):\\n                result += hmap[total-k]\\n        return result\\n```\\n\\n[974. Subarray Sums Divisible by K](https://leetcode.com/problems/subarray-sums-divisible-by-k/) Solution:\\n```\\nclass Solution:\\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\\n        hmap,total,result = {},0,0\\n        for num in A:\\n            hmap[total] = hmap.get(total,0) + 1\\n            total += num\\n            total %= K\\n            if hmap.get(total):\\n                result += hmap[total]\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def subarraySum(self, nums: List[int], k: int) -> int:\\n        result,total,hmap = 0,0,{}\\n        for num in nums:\\n            hmap[total] = hmap.get(total,0) + 1\\n            total += num\\n            if hmap.get(total-k):\\n                result += hmap[total-k]\\n        return result\\n```\n```\\nclass Solution:\\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\\n        hmap,total,result = {},0,0\\n        for num in A:\\n            hmap[total] = hmap.get(total,0) + 1\\n            total += num\\n            total %= K\\n            if hmap.get(total):\\n                result += hmap[total]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226259,
                "title": "c-196ms-beat-100",
                "content": "Time complexity: **O(A)**, Space: **O(K)**\\n**Explanation**:\\nThe main idea is based on the following 4 facts:\\n1. **Sum(i, j) = Sum(j) - Sum(i)**\\n2. if **Sum(j) % K == Sum(i) % K**, then **Sum(i, j) % K** = (Sum(j) - Sum(i)) % K = Sum(j) % K - Sum(i) % K **= 0**.  \\n3. if **Abs(Sum(j) % K - Sum(i) % K) == K**, then **Sum(i, j) % K** = Abs(Sum(j) % K - Sum(i) % K) % K **= 0**\\n4. In any other cases, Sum(i, j) % K <> 0\\n\\nAs an optimization, we can use non-negative remainders as the dictionary key. If we get a negative remainder, we can use (K + remainder) as the key because of Fact 3. Then, when we have C subarrays (all start from index 0) which have the same key, any subarray of (subarray(j) - subarray(i)) is an result. So totally we get (C * (C - 1) / 2) results for one key.\\n\\nThe C# code is as the below:\\n```\\npublic class Solution {\\n    public int SubarraysDivByK(int[] A, int K) {\\n        var countDict = new Dictionary<int, int>();\\n        var sum = 0;\\n        foreach (var a in A) {\\n            sum += a;\\n            var k = sum % K;\\n            if (k < 0) {\\n                k = K + k;\\n            }\\n            countDict[k] = countDict.ContainsKey(k) ?\\n                countDict[k] + 1 : 1;\\n        }\\n        var ret = countDict.ContainsKey(0) ? countDict[0] : 0;\\n        foreach (var count in countDict.Values) {\\n            ret += count * (count - 1) >> 1;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int SubarraysDivByK(int[] A, int K) {\\n        var countDict = new Dictionary<int, int>();\\n        var sum = 0;\\n        foreach (var a in A) {\\n            sum += a;\\n            var k = sum % K;\\n            if (k < 0) {\\n                k = K + k;\\n            }\\n            countDict[k] = countDict.ContainsKey(k) ?\\n                countDict[k] + 1 : 1;\\n        }\\n        var ret = countDict.ContainsKey(0) ? countDict[0] : 0;\\n        foreach (var count in countDict.Values) {\\n            ret += count * (count - 1) >> 1;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683224,
                "title": "map-most-optimized-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int ans = 0;\\n        unordered_map<int,int> mp;\\n        mp[0]++;\\n        int sum = 0;\\n        for(auto &i: nums){\\n            sum += i;\\n            sum = ((sum)%k+k)%k;\\n            ans += mp[sum];\\n            mp[sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int ans = 0;\\n        unordered_map<int,int> mp;\\n        mp[0]++;\\n        int sum = 0;\\n        for(auto &i: nums){\\n            sum += i;\\n            sum = ((sum)%k+k)%k;\\n            ans += mp[sum];\\n            mp[sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071686,
                "title": "detailed-explanation-with-pictures-clear-intuition-c",
                "content": "# Intuition\\nLet\\'s suppose there is a subarray with sum A with gives remainder r on diving it by k.\\nAnother subarray with sum B gives same remainder r on dividing by k.\\nLet m and n be the quotients of both divisions then we can say that :-\\n##### A = k*m + r\\n##### B = K*n + r\\n\\n##### Thus, A - B = k*(m-n)\\nThis implies subarray starting from length m and including all elements upto length n would be divisible by k.\\n\\nFor eg :-\\n\\n```\\nnums = [4 , 5 , 0 , -2 , -3 , 1], k = 5\\n       |--|                          (4) % k = 4\\n       |------------------|          (4+5+0+-2+-3) % k = 4\\n    Hence,\\n            |-------------|  this subarray is divisible by k as explianed.\\n```\\n### **Edge Case :-**\\nWhat if we get negative reminder , then we add k to that remainder. But, Why ?\\nLet\\'s say \\n##### A = k*m - r  \\n##### A = k*m - k + k - r= k(m-1) + (k - r)\\n\\n**The remainder got transformed from -r to (k-r)**\\nFor eg:-\\nIf sum gives remainder = -3 on dividing it by 5\\nThen, Since  -3 is analogous to +2. Rather than storing -3 in map we store the rem as +2 in hashmap. \\n\\n# Approach\\n- Initialize total to 0. \\n- Increase the frequency of 0 (as we also have to count subarrays sums which are mutiple of k) and store the frequency of remainders in hashmap.\\n- If remainder is negative add k to it.\\n- Thereafter, if this remainder has previously occurred then we say there exists a subarray whcih is divisible by k. Increment total by frequency of that remainder.\\n( For eg :- If previous of frequency of remainder in map is m then, there are m starting points of subarrays which will extend upto this curr point and all of these subarrays will be divisible by k ). \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n## Please Please Upvote if it helps !!\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int K) {\\n        int n = size(nums);\\n        if(n==0) return 0;\\n        \\n        int i = 0, total = 0;\\n        int currSum = 0;\\n        unordered_map<int, int> mp;\\n        mp[0] = 1;\\n        \\n        while(i<n)\\n        {\\n            currSum+= nums[i];\\n            int rem = currSum % K;\\n            if(rem<0) rem += K;\\n            if(mp.count(rem))\\n                total += mp[rem];\\n            mp[rem]++;\\n            i++;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nnums = [4 , 5 , 0 , -2 , -3 , 1], k = 5\\n       |--|                          (4) % k = 4\\n       |------------------|          (4+5+0+-2+-3) % k = 4\\n    Hence,\\n            |-------------|  this subarray is divisible by k as explianed.\\n```\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int K) {\\n        int n = size(nums);\\n        if(n==0) return 0;\\n        \\n        int i = 0, total = 0;\\n        int currSum = 0;\\n        unordered_map<int, int> mp;\\n        mp[0] = 1;\\n        \\n        while(i<n)\\n        {\\n            currSum+= nums[i];\\n            int rem = currSum % K;\\n            if(rem<0) rem += K;\\n            if(mp.count(rem))\\n                total += mp[rem];\\n            mp[rem]++;\\n            i++;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071221,
                "title": "golang-prefix-sum-map",
                "content": "# Code\\n```\\nfunc subarraysDivByK(nums []int, k int) int {\\n    var ans int = 0\\n    var sum int = 0\\n    Map := make(map[int]int)\\n    Map[0] = 1\\n    for i := 0; i < len(nums); i++ {\\n        sum = (((sum + nums[i]) % k) + k) % k\\n        ans += Map[sum]\\n        Map[sum]++\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nfunc subarraysDivByK(nums []int, k int) int {\\n    var ans int = 0\\n    var sum int = 0\\n    Map := make(map[int]int)\\n    Map[0] = 1\\n    for i := 0; i < len(nums); i++ {\\n        sum = (((sum + nums[i]) % k) + k) % k\\n        ans += Map[sum]\\n        Map[sum]++\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3071143,
                "title": "simple-and-code-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n    // Use the HashMap to record the frequency of all the prefix sum remainders.\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0, remainder; i < nums.length; i++) {\\n            if (i > 0) nums[i] += nums[i - 1];\\n            // Note that the integer in \\'nums\\' can be negative.\\n            // Thus, we need to adjust the negative remainder to positive remainder.\\n            // Below accounts for both negative and positive remainders.\\n            // We can also check if the remainder is negative, then add a \\'k\\' to make the remainder positive.\\n            // For Example, nums = [-2,3,2], k = 5,\\n            // remainder for the prefix sum of [-2,1,3] are -2, 1 and 3 respectively.\\n            // We know that [3,2] sum to 5, which is divisible by 5.\\n            // After converting -2 to 3, by adding 5, it has the same remainder with prefix sum 3.\\n            remainder = (nums[i] % k + k) % k;\\n            map.put(remainder, map.getOrDefault(remainder, 0) + 1);\\n        }\\n        // The result contains all the prefix sum with remainder 0,\\n        // as all the prefix sum with remainder of 0 is itself divisible by \\'k\\'.\\n        // However, do note that the prefix sum with remainder 0 also able to form subarray sums that is divisible by \\'k\\'\\n        // with one another, which will be calculated next.\\n        // For Example: nums = [5,5,5,5], k = 5,\\n        // The prefix sum of [5,10,15,20] are themselves divisible by 5, while also forming subarray sums divisible by 5\\n        // with 10 [5,5] - 5 [5] == 5, 15 [5,5,5] - 5 [5] == 10, etc.\\n        int result = map.getOrDefault(0, 0);\\n\\n        // The prefix sums with the same remainder can form subarray sums that is divisible by \\'k\\' with each other.\\n        for (int frequency : map.values())\\n            result += frequency * (frequency - 1) / 2;\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n    // Use the HashMap to record the frequency of all the prefix sum remainders.\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0, remainder; i < nums.length; i++) {\\n            if (i > 0) nums[i] += nums[i - 1];\\n            // Note that the integer in \\'nums\\' can be negative.\\n            // Thus, we need to adjust the negative remainder to positive remainder.\\n            // Below accounts for both negative and positive remainders.\\n            // We can also check if the remainder is negative, then add a \\'k\\' to make the remainder positive.\\n            // For Example, nums = [-2,3,2], k = 5,\\n            // remainder for the prefix sum of [-2,1,3] are -2, 1 and 3 respectively.\\n            // We know that [3,2] sum to 5, which is divisible by 5.\\n            // After converting -2 to 3, by adding 5, it has the same remainder with prefix sum 3.\\n            remainder = (nums[i] % k + k) % k;\\n            map.put(remainder, map.getOrDefault(remainder, 0) + 1);\\n        }\\n        // The result contains all the prefix sum with remainder 0,\\n        // as all the prefix sum with remainder of 0 is itself divisible by \\'k\\'.\\n        // However, do note that the prefix sum with remainder 0 also able to form subarray sums that is divisible by \\'k\\'\\n        // with one another, which will be calculated next.\\n        // For Example: nums = [5,5,5,5], k = 5,\\n        // The prefix sum of [5,10,15,20] are themselves divisible by 5, while also forming subarray sums divisible by 5\\n        // with 10 [5,5] - 5 [5] == 5, 15 [5,5,5] - 5 [5] == 10, etc.\\n        int result = map.getOrDefault(0, 0);\\n\\n        // The prefix sums with the same remainder can form subarray sums that is divisible by \\'k\\' with each other.\\n        for (int frequency : map.values())\\n            result += frequency * (frequency - 1) / 2;\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071105,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        unordered_map<int,int> mp;\\n        mp[0]=1;\\n        int s=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            s+=nums[i];\\n            int r=s%k;\\n            if(r<0)\\n                r+=k;\\n            if(mp.find(r)!=mp.end())\\n                ans+=mp[r];\\n            mp[r]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        unordered_map<int,int> mp;\\n        mp[0]=1;\\n        int s=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            s+=nums[i];\\n            int r=s%k;\\n            if(r<0)\\n                r+=k;\\n            if(mp.find(r)!=mp.end())\\n                ans+=mp[r];\\n            mp[r]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070469,
                "title": "easy-solution-using-hashmap-and-prefix-sum-intuition-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we have to find the subarrays which divides by k so we have taken HashMap to count the frequencies of the same subarray which have equal sum and for that we calculate sum at every point by using Prefix sum approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we have to find the subarrays which divides by k so we have taken HashMap to count the frequencies of the same subarray which have equal sum and for that we calculate sum at every point by using Prefix sum approach\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] arr, int k) {\\n        int n = arr.length;\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        int sum = 0;\\n        int count = 0;\\n        for(int i = 0; i<n; i++){\\n            sum+=arr[i];\\n            if(sum%k==0)\\n                count++;\\n            int rem = sum%k;\\n            if(rem<0)\\n                rem = rem+k;\\n            if(hm.containsKey(rem))\\n                count+=hm.get(rem);\\n            hm.put(rem,hm.getOrDefault(rem,0)+1);\\n        }\\n        return count;\\n    }\\n}\\n\\n// Please Upvote :)\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] arr, int k) {\\n        int n = arr.length;\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        int sum = 0;\\n        int count = 0;\\n        for(int i = 0; i<n; i++){\\n            sum+=arr[i];\\n            if(sum%k==0)\\n                count++;\\n            int rem = sum%k;\\n            if(rem<0)\\n                rem = rem+k;\\n            if(hm.containsKey(rem))\\n                count+=hm.get(rem);\\n            hm.put(rem,hm.getOrDefault(rem,0)+1);\\n        }\\n        return count;\\n    }\\n}\\n\\n// Please Upvote :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430616,
                "title": "using-prefix-sum-technique-c-commented",
                "content": "```\\n// Btw, I did these problems is this order, that also turned to be bit helpful for me:\\n\\n// Subarray Sum Equals K\\n// Continuous Subarray Sum\\n// Subarray Sum Divisible by K\\n\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        // remainder with thier count store\\n        unordered_map<int,int>mp;\\n        // base case -->[4,0] k=4 \\n        mp[0]++;\\n        // prefix sum array\\n        int runningsum=0;\\n        int ans=0;\\n        for(int i=0;i<size(nums);i++)\\n        {\\n            runningsum+=nums[i];\\n            int rem = runningsum%k;\\n            if(rem<0)rem+=k; // property of remainder if found negative\\n                            //3 % 2 returns 1. However, -3 % 2 is -1 \\n            if(mp.find(rem)!=mp.end())\\n            {\\n                // if rem is found      \\n                ans+=mp[rem];\\n                 mp[rem]++; // incre the count \\n            }\\n            else{\\n                mp[rem]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n// Btw, I did these problems is this order, that also turned to be bit helpful for me:\\n\\n// Subarray Sum Equals K\\n// Continuous Subarray Sum\\n// Subarray Sum Divisible by K\\n\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        // remainder with thier count store\\n        unordered_map<int,int>mp;\\n        // base case -->[4,0] k=4 \\n        mp[0]++;\\n        // prefix sum array\\n        int runningsum=0;\\n        int ans=0;\\n        for(int i=0;i<size(nums);i++)\\n        {\\n            runningsum+=nums[i];\\n            int rem = runningsum%k;\\n            if(rem<0)rem+=k; // property of remainder if found negative\\n                            //3 % 2 returns 1. However, -3 % 2 is -1 \\n            if(mp.find(rem)!=mp.end())\\n            {\\n                // if rem is found      \\n                ans+=mp[rem];\\n                 mp[rem]++; // incre the count \\n            }\\n            else{\\n                mp[rem]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378870,
                "title": "easy-c-linear-time-o-n",
                "content": "int subarraysDivByK(vector<int>& nums, int k) \\n    {\\n            unordered_map<int,int> st;\\n            st[0]=1;\\n            int val=0,c=0,temp=0;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n               val+=nums[i];\\n                    while(val<0)\\n                            val+=k;\\n                    if(st.find(val%k)!=st.end())\\n                   {\\n                            \\n                            c+=st[val%k];\\n                            st[val%k]++;\\n                    }\\n                    else st[val%k]++;\\n            }\\n            return c;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "int subarraysDivByK(vector<int>& nums, int k) \\n    {\\n            unordered_map<int,int> st;\\n            st[0]=1;\\n            int val=0,c=0,temp=0;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n               val+=nums[i];\\n                    while(val<0)\\n                            val+=k;\\n                    if(st.find(val%k)!=st.end())\\n                   {\\n                            \\n                            c+=st[val%k];\\n                            st[val%k]++;\\n                    }\\n                    else st[val%k]++;\\n            }\\n            return c;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1812586,
                "title": "cpp-easy-approach-hints-solution",
                "content": "# Explanation\\n\\n1.This problem is similar to subarray with sum equal to K.\\n2.There, We calculate sum for every element. We check if that sum is already in the hashmap,if yes means we have encountered subarray with that sum.\\n3.This works because if  two positions i,j in an array and if  sum[j]-k = sum[i] ,means \\n sum[j]-sum[i] = k .Hence we we get (2.)\\n \\n Similarly, Applying same analogy to division by K,\\n If at two positions in an array if sum/k leaves same remainder, then means sum[j]-sum[i] if divisible by k;\\n \\nLets understand with one example,\\n \\n Let sum[i] = 5 and k = 3\\n\\t sum[i]%k = 2     -----(1)-------\\n Also, sum[j] = 14 \\n\\t sum[j]%k =  2   -----(1)-------\\n \\n So,essentially, sum[j]-sum[i] has to be equla to k inorder to have same remainder at ith and jth position.\\n \\n**Edge Case**\\n if sum is -ve, then its remainder will not be sum%K,\\n \\n we have to do (sum + k)%k, to get its correct remainder.\\n(why ? try with some examples , you will get it ) \\n\\nOne more case can be sum+k still < 0,then you can do\\nsum = -(abs(sum)%k);\\nNow if you do (sum_k)%k, you will get right remainder.\\n\\n(This might be confusing at first, try with some more examples and dry run for more clarity :) )\\n\\n\\n\\n# Code\\n\\n```\\nclass Solution {\\npublic:\\n     int subarraysDivByK(vector<int>& nums, int k) {\\n         \\n         unordered_map<int,int> m;\\n         int sum = 0;\\n         int rem = 0;\\n         m[rem]++;\\n         \\n         int c = 0;\\n         for(int i=0;i<nums.size();i++){\\n             sum += nums[i];\\n             if(sum < 0){\\n                 sum = -(abs(sum)%k);\\n             }\\n             rem = (sum+k)%k;\\n             \\n             if(m[rem]){\\n                 cout<<rem<<\" \";\\n                 c += m[rem];\\n             }else if(rem%k == 0){\\n                 c++;\\n             }\\n             m[rem]++;\\n         }\\n         return c;\\n    }\\n};\\n\\n```\\n**Please Upvote if you liked the explanation.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int subarraysDivByK(vector<int>& nums, int k) {\\n         \\n         unordered_map<int,int> m;\\n         int sum = 0;\\n         int rem = 0;\\n         m[rem]++;\\n         \\n         int c = 0;\\n         for(int i=0;i<nums.size();i++){\\n             sum += nums[i];\\n             if(sum < 0){\\n                 sum = -(abs(sum)%k);\\n             }\\n             rem = (sum+k)%k;\\n             \\n             if(m[rem]){\\n                 cout<<rem<<\" \";\\n                 c += m[rem];\\n             }else if(rem%k == 0){\\n                 c++;\\n             }\\n             m[rem]++;\\n         }\\n         return c;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1810686,
                "title": "easy-understanding-java-solution",
                "content": "\\n\\tpublic int subarraysDivByK(int[] nums, int k) {\\n        int count = 0;\\n        int temp = 0;\\n        HashMap<Integer , Integer> map = new HashMap<>();\\n        HashMap<Integer , Integer> res = new HashMap<>();\\n        int sum = 0;\\n        for(int i : nums){\\n            sum += i;\\n            int rem = sum % k;\\n            while(rem < 0) {\\n                rem += k;\\n            }\\n            if(map.containsKey(rem)) {\\n                int tmp = map.get(rem) + 1;\\n                map.put(rem , tmp);\\n                temp = comb(tmp);\\n                res.put(rem , temp);\\n            } else map.put(rem , 1);\\n        }\\n        for(int i : res.keySet()){\\n            count += res.get(i);\\n        }\\n        if(map.containsKey(0)){\\n            count += map.get(0);\\n        }\\n        return count;\\n    }\\n\\n    private int comb(int a){\\n        return ((a-1)*a)/2;\\n    }\\n\\n",
                "solutionTags": [
                    "Java",
                    "Combinatorics"
                ],
                "code": "\\n\\tpublic int subarraysDivByK(int[] nums, int k) {\\n        int count = 0;\\n        int temp = 0;\\n        HashMap<Integer , Integer> map = new HashMap<>();\\n        HashMap<Integer , Integer> res = new HashMap<>();\\n        int sum = 0;\\n        for(int i : nums){\\n            sum += i;\\n            int rem = sum % k;\\n            while(rem < 0) {\\n                rem += k;\\n            }\\n            if(map.containsKey(rem)) {\\n                int tmp = map.get(rem) + 1;\\n                map.put(rem , tmp);\\n                temp = comb(tmp);\\n                res.put(rem , temp);\\n            } else map.put(rem , 1);\\n        }\\n        for(int i : res.keySet()){\\n            count += res.get(i);\\n        }\\n        if(map.containsKey(0)){\\n            count += map.get(0);\\n        }\\n        return count;\\n    }\\n\\n    private int comb(int a){\\n        return ((a-1)*a)/2;\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1652944,
                "title": "python3-brute-to-optimal",
                "content": "The **brute force** method would be to generate the subarray sum of all the possible subarrays and check whether this is divisible by k or not.\\n\\n\\nLet us suppose we have an array [1,2,3,4]\\n\\nOur subarrays starting from 1 would be [1] , [1,2] , [1,2,3] , [1,2,3,4]\\nSubarrays starting from 2 would be [2] , [2,3] , [2,3,4]\\nSubarrays starting from 3 would be [3] , [3,4]\\nSubarrays starting from 4 would be [4]\\n\\nThis is exactly what we would be doing in our code. And while generating all the subarrays, we will keep maintaining the sum and check whether it is divisible by k or not at each iteration.\\n\\n```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n\\t\\tanswer = 0\\n        n = len(nums)\\n        for start in range(n):\\n            for end in range(start,n):\\n                subarraySum = sum(nums[start:end+1])\\n                if subarraySum % k == 0:\\n                    answer += 1\\n        return answer\\n```\\nWe are maintaining two for loops for our start and end index and the calculating our sum inside it, so basically 3 loops.\\nTC - O(N^3) \\nSC- O(1)\\n\\n\\n**Better Solution**\\nWe can remove the third loop to sum the subarray by maintaining a variable and adding each element on the go.\\n\\n```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n\\t\\t\\n\\t\\t#variable to store our answer\\n\\t\\tanswer = 0\\n        n = len(nums)\\n\\t\\t\\n\\t\\t#loop to maintain the start point of our array\\n        for start in range(n):\\n            subarraySum = 0\\n\\t\\t\\t\\n\\t\\t\\t#inner loop to go from start till the end\\n            for end in range(start,n):\\n                \\n\\t\\t\\t\\t#Adding the current element\\n\\t\\t\\t\\tsubarraySum += nums[end]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#Checking our condition and updating our answer\\n                if subarraySum % k == 0:\\n                    answer += 1\\n        return answer\\n```\\n\\nTC - O(N^2)\\nSc - O(1)\\n\\n**Optimal Solution**\\n\\nThe most optimal solution will be to use hashmaps to store the previous sums(prefixsums).\\nBut the question *\"How to check if subarray sum is **divisible by k** by using prefixSum?\"*  still persists.\\n\\nFor this, we can store the occurence of prefixSum % k at every iteration.\\nIf we have already seen this (prefixSum%k), we will add the number of occurences of this to our answer.\\n\\n\\n\\nA---------------B \\n\\nA------------------------------C\\n\\nLet us say if subarray from A to B has sum s and remainder r1 (s%k = r1)\\nAnd if subarray from A to C has sum s1 but remainder r1 (s1%k = r1)\\n\\nAs the remainder is same, we can definitely say that subarray sum from B to C will definitely be divisible by k.\\n\\nDry run on any example of your choice and things would be crystal clear.\\n\\n```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n\\t\\n\\t\\t#Hashmap to store remainders of prefixsum. We have to count the number of subaarays hence storing hashmap[0] = 1 as we have 0 sum at starting\\n        memo = {0:1}\\n        answer = 0\\n        prefixSum = 0\\n\\t\\t\\n        for i in range(len(nums)):\\n            prefixSum += nums[i]\\n            prefixSum %= k\\n\\t\\t\\t\\n            if prefixSum in memo:\\n                answer += memo[prefixSum]\\n                memo[prefixSum] += 1\\n            else:\\n                memo[prefixSum] = 1\\n\\t\\t\\t\\t\\n        return answer\\n        \\n```\\nTC - O(N) Only one loop\\nSC - O(k) Hashmap will have only k entries from 0 to k-1 as we are just storing the remainders\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n\\t\\tanswer = 0\\n        n = len(nums)\\n        for start in range(n):\\n            for end in range(start,n):\\n                subarraySum = sum(nums[start:end+1])\\n                if subarraySum % k == 0:\\n                    answer += 1\\n        return answer\\n```\n```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n\\t\\t\\n\\t\\t#variable to store our answer\\n\\t\\tanswer = 0\\n        n = len(nums)\\n\\t\\t\\n\\t\\t#loop to maintain the start point of our array\\n        for start in range(n):\\n            subarraySum = 0\\n\\t\\t\\t\\n\\t\\t\\t#inner loop to go from start till the end\\n            for end in range(start,n):\\n                \\n\\t\\t\\t\\t#Adding the current element\\n\\t\\t\\t\\tsubarraySum += nums[end]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#Checking our condition and updating our answer\\n                if subarraySum % k == 0:\\n                    answer += 1\\n        return answer\\n```\n```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n\\t\\n\\t\\t#Hashmap to store remainders of prefixsum. We have to count the number of subaarays hence storing hashmap[0] = 1 as we have 0 sum at starting\\n        memo = {0:1}\\n        answer = 0\\n        prefixSum = 0\\n\\t\\t\\n        for i in range(len(nums)):\\n            prefixSum += nums[i]\\n            prefixSum %= k\\n\\t\\t\\t\\n            if prefixSum in memo:\\n                answer += memo[prefixSum]\\n                memo[prefixSum] += 1\\n            else:\\n                memo[prefixSum] = 1\\n\\t\\t\\t\\t\\n        return answer\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493597,
                "title": "python3-prefix-sum",
                "content": "Solution -  Here we use prefix sum concept where we find prefix%k and store it in hmap\\nSo concept is if prefix sum till index i is s1 and prefix sum till index j is s2 where j>i and  s1%k==s2%k . Then s2-s1 is divisible by k. for ex consider this (s1,s2,k) = (25,46,7). So here we find remainder and store in map and check if same remainder comes we do ans+=hmap[rem] . we are adding hmap[rem] because we are checking how many times that remainder has come before and if prefix%k==0 we do ans+=1.\\n\\n```\\n#TIME COMPLEXITY - O(N)\\n#SPACE COMPLEXITY -O(N)\\nimport collections\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        hmap=collections.defaultdict(int)\\n        prefix,cnt=0,0\\n        for i in range(len(nums)):\\n            prefix+=nums[i]\\n            if prefix%k==0:\\n                cnt+=1\\n            if prefix%k in hmap:\\n                cnt+=hmap[prefix%k]\\n            hmap[prefix%k]+=1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\n#TIME COMPLEXITY - O(N)\\n#SPACE COMPLEXITY -O(N)\\nimport collections\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        hmap=collections.defaultdict(int)\\n        prefix,cnt=0,0\\n        for i in range(len(nums)):\\n            prefix+=nums[i]\\n            if prefix%k==0:\\n                cnt+=1\\n            if prefix%k in hmap:\\n                cnt+=hmap[prefix%k]\\n            hmap[prefix%k]+=1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247862,
                "title": "java-clean-concise-code-faster-than-67-73",
                "content": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n\\t\\n        /*\\n\\t\\t1. if number is divisible by k --> number%k =0\\n\\t\\t2. if number%k < 0 ---> (number%k) +k   is the actual result\\n        3. nums [4,5,0,-2,-3,1] --> sum[4,9,9,7,4,5]    (cumulative sum)\\n        4. (0+-2+-3) = sum[indexOf(-3)]-sum[indexOf(0)-1||0 if the start]  = sum[4]-sum[1] = -5\\n        \\n\\t\\t5. Modulus is also can be cumulative!\\n               nums[4,5,0,-2,-3,1] --> modOfSums [4,4,4,2,4,0]\\n\\t\\t\\t\\tmod of(4,5,0) --> modOfSums[2]-0 = 4\\n\\t\\t\\t\\t\\n             clear? now guess what? \\n\\t\\t\\t \\n       6. Subarrays that have a sum divisible by k are discovered by values of modOfSums, how???\\n\\t\\t\\tEach repeated number in it tells us about a new divisiblity by k.\\n\\t\\t\\tEach new divisiblity will increment the count of subarrays, by what?\\n\\t\\t\\t- Increment it by # of times the number repeated!  \\n\\t\\t  Prove it yourself!\\n\\t\\t  \\n\\t\\t  And so, to check repeated numbers .. we use the hashMap!\\n\\t  */\\n\\t \\n        int n = nums.length;\\n\\t\\tint [] cumulativeMods = new int[n];   //store cumulative modulus\\n        int count =0;   //count subarrays\\n\\t\\tHashMap <Integer,Integer> repeatedMonitor = new HashMap<>();\\n\\t\\t\\n        repeatedMonitor.put(0,1);  \\n\\t\\t//magic hidden zero :P,  next appearing of 0 in cumulative will be the second to the monitor, \\n\\t\\t//if you love to know why, do search xD\\n\\t\\t\\n        cumulativeMods[0]= nums[0]%k<0? (nums[0]%k)+k : nums[0]%k;\\n        \\n\\t\\t//Fill cumulativeMods array\\n        for(int i=1; i<n; i++){\\n            cumulativeMods[i] = cumulativeMods[i-1]+nums[i];\\n            cumulativeMods[i] = cumulativeMods[i]%k <0? (cumulativeMods[i]%k)+k: cumulativeMods[i]%k;\\n        }               \\n        \\n\\t\\t//count contiguous subarrays by monitoring the repeated items in cumulativeMods\\n        int toAdd=0;\\n        for(int i=0; i<n; i++){\\n            toAdd = repeatedMonitor.getOrDefault(cumulativeMods[i],0); \\n            count+= toAdd;\\n            repeatedMonitor.put(cumulativeMods[i], toAdd+1);\\n        }\\n        return count;        \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n\\t\\n        /*\\n\\t\\t1. if number is divisible by k --> number%k =0\\n\\t\\t2. if number%k < 0 ---> (number%k) +k   is the actual result\\n        3. nums [4,5,0,-2,-3,1] --> sum[4,9,9,7,4,5]    (cumulative sum)\\n        4. (0+-2+-3) = sum[indexOf(-3)]-sum[indexOf(0)-1||0 if the start]  = sum[4]-sum[1] = -5\\n        \\n\\t\\t5. Modulus is also can be cumulative!\\n               nums[4,5,0,-2,-3,1] --> modOfSums [4,4,4,2,4,0]\\n\\t\\t\\t\\tmod of(4,5,0) --> modOfSums[2]-0 = 4\\n\\t\\t\\t\\t\\n             clear? now guess what? \\n\\t\\t\\t \\n       6. Subarrays that have a sum divisible by k are discovered by values of modOfSums, how???\\n\\t\\t\\tEach repeated number in it tells us about a new divisiblity by k.\\n\\t\\t\\tEach new divisiblity will increment the count of subarrays, by what?\\n\\t\\t\\t- Increment it by # of times the number repeated!  \\n\\t\\t  Prove it yourself!\\n\\t\\t  \\n\\t\\t  And so, to check repeated numbers .. we use the hashMap!\\n\\t  */\\n\\t \\n        int n = nums.length;\\n\\t\\tint [] cumulativeMods = new int[n];   //store cumulative modulus\\n        int count =0;   //count subarrays\\n\\t\\tHashMap <Integer,Integer> repeatedMonitor = new HashMap<>();\\n\\t\\t\\n        repeatedMonitor.put(0,1);  \\n\\t\\t//magic hidden zero :P,  next appearing of 0 in cumulative will be the second to the monitor, \\n\\t\\t//if you love to know why, do search xD\\n\\t\\t\\n        cumulativeMods[0]= nums[0]%k<0? (nums[0]%k)+k : nums[0]%k;\\n        \\n\\t\\t//Fill cumulativeMods array\\n        for(int i=1; i<n; i++){\\n            cumulativeMods[i] = cumulativeMods[i-1]+nums[i];\\n            cumulativeMods[i] = cumulativeMods[i]%k <0? (cumulativeMods[i]%k)+k: cumulativeMods[i]%k;\\n        }               \\n        \\n\\t\\t//count contiguous subarrays by monitoring the repeated items in cumulativeMods\\n        int toAdd=0;\\n        for(int i=0; i<n; i++){\\n            toAdd = repeatedMonitor.getOrDefault(cumulativeMods[i],0); \\n            count+= toAdd;\\n            repeatedMonitor.put(cumulativeMods[i], toAdd+1);\\n        }\\n        return count;        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104162,
                "title": "java-brute-force-and-prefix-sum-comments-explained",
                "content": "```\\nclass Solution {\\n    //TLE\\n//     public int subarraysDivByK(int[] A, int K) {\\n//         int result = 0;\\n//         for (int i =0; i < A.length;i++){\\n//             int j = i;\\n//             int sum = 0;\\n//             while (j < A.length){\\n//                 sum += A[j];\\n//                 j++;\\n//                 if (sum % K == 0){\\n//                     result++;\\n//                     sum = 0;\\n//                 }\\n//             }\\n            \\n//         }\\n//         return result;\\n//     }\\n    \\n        public int subarraysDivByK(int[] A, int K) {\\n        int result = 0;\\n        int[] sum = new int[A.length+1];\\n        sum[0] = A[0];\\n        \\n        //prefix sum\\n        for (int i = 1;i<A.length;i++)\\n            sum[i] = sum[i-1] + A[i];\\n        \\n        // to make sure that the sum % k will leave us how much is needed to make it divisible by k\\n        // in between two reminders we are sure the sub array is completely divisible by K\\n        // ading K is to avoid overflow\\n        int[] count = new int[K];\\n        for (int i : sum)\\n            count[(i % K + K) % K]++;\\n        \\n        // for each of the available reminders we take NC2 to get the total\\n        for (int i : count)\\n            result += i * (i -1) / 2;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    //TLE\\n//     public int subarraysDivByK(int[] A, int K) {\\n//         int result = 0;\\n//         for (int i =0; i < A.length;i++){\\n//             int j = i;\\n//             int sum = 0;\\n//             while (j < A.length){\\n//                 sum += A[j];\\n//                 j++;\\n//                 if (sum % K == 0){\\n//                     result++;\\n//                     sum = 0;\\n//                 }\\n//             }\\n            \\n//         }\\n//         return result;\\n//     }\\n    \\n        public int subarraysDivByK(int[] A, int K) {\\n        int result = 0;\\n        int[] sum = new int[A.length+1];\\n        sum[0] = A[0];\\n        \\n        //prefix sum\\n        for (int i = 1;i<A.length;i++)\\n            sum[i] = sum[i-1] + A[i];\\n        \\n        // to make sure that the sum % k will leave us how much is needed to make it divisible by k\\n        // in between two reminders we are sure the sub array is completely divisible by K\\n        // ading K is to avoid overflow\\n        int[] count = new int[K];\\n        for (int i : sum)\\n            count[(i % K + K) % K]++;\\n        \\n        // for each of the available reminders we take NC2 to get the total\\n        for (int i : count)\\n            result += i * (i -1) / 2;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 652086,
                "title": "java-clean-code-solution-hashmap-data-structure",
                "content": "class Solution {\\n    public int subarraysDivByK(int[] A, int K) {\\n        \\n        int[] map = new int[K];\\n        map[0] = 1;\\n        int sum = 0, result = 0;\\n        for(int i = 0; i < A.length; i++) {\\n            sum = (sum + A[i]) % K;\\n            if(sum < 0) sum += K;\\n            result += map[sum];\\n            ++map[sum];\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\nTime Complexity: O(N)\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int subarraysDivByK(int[] A, int K) {\\n        \\n        int[] map = new int[K];\\n        map[0] = 1;\\n        int sum = 0, result = 0;\\n        for(int i = 0; i < A.length; i++) {\\n            sum = (sum + A[i]) % K;\\n            if(sum < 0) sum += K;\\n            result += map[sum];\\n            ++map[sum];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3268478,
                "title": "easy-and-simple-explanation-mathematically-in-video-with-intuition-and-approach-in-c-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHi everyone, i have tried to explain this problem in this video, its a part of prefix sum playlist where i have also discussed other prefix sum problems and tried to connect all of them. \\nhttps://www.youtube.com/watch?v=WtjyzPGVMBE\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        map<int,int> mp;\\n        int prefix_sum=0;\\n        mp[0]=1;\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            prefix_sum+=nums[i];\\n            if(prefix_sum < 0){\\n                prefix_sum+=ceil(abs(prefix_sum)*1.0/k)*k;\\n            } \\n\\n            prefix_sum%=k;\\n            if(mp.find(prefix_sum)!=mp.end()){\\n                ans+=mp[prefix_sum];\\n            }\\n            mp[prefix_sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        map<int,int> mp;\\n        int prefix_sum=0;\\n        mp[0]=1;\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            prefix_sum+=nums[i];\\n            if(prefix_sum < 0){\\n                prefix_sum+=ceil(abs(prefix_sum)*1.0/k)*k;\\n            } \\n\\n            prefix_sum%=k;\\n            if(mp.find(prefix_sum)!=mp.end()){\\n                ans+=mp[prefix_sum];\\n            }\\n            mp[prefix_sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073460,
                "title": "prefix-sum-number-theory-intuition-o-n-time-o-k-space",
                "content": "# Intuition\\nApproach is based on the idea of prefix sums and a bit of number theory. I have discussed both below.\\n\\n**How prefix sum helps:**\\n\\nPrefix sums help us in calculating sub-array sum of an array A, given the start index and end index of the sub-array. Please see below how:\\n\\nSuppose an A array of size n, where the ith element is `ai`:\\n\\n`A = [a1, a2, a3, a4, a5, ..., am-1, am, am+1, ..., an-3, an-2, an-1]`\\n\\nThe prefix sum array would be:\\n\\n`P = [p1, p2, p3, p4, p5, ..., pm-1, pm, pm+1, ..., pn-3, pn-2, pn-1]`\\n\\nLet\\'s take a sub-array with start and end index as i & j, such that:\\n\\ni <= j and Prefix sum of i = pi, Prefix sum of j = pj\\n \\n |----------pi------->| i\\n |------------------------pj------>| j\\n[p1, p2, p3, ..., pi-1, pi, pi+1, ..., pj, pj+1, ... pn-2, pn-1]\\n\\nThus, if we want sum of all the elements in the sub-array from i to j\\nwe can easily calculate it using `(pj - pi)` in `O(1)` time.\\n\\n**Why do we need number theory here?**\\n\\nWe only need to understand about the modulus operator and few properties related to it.\\n\\nIf a number **n** is divisible by **k**, then the remainder should be 0, given k != 0.\\nor, `n%k = 0`\\n\\nNow let\\'s assume `n = a - b`, we can replace `n` in `n % k`, to get the following:\\n`(a - b) % k = 0`\\n\\nThere are few properties of modulus(%):\\n\\n```\\n(a + b) % c = (a % c + b % c) % c\\n(a \\u2212 b) % c = (a % c \\u2212 b % c) % c\\n(a \\u2217 b) % c = (a % c \\u2217 b % c) % c\\n```\\n \\nFollowing the above, we can re-write `(a - b) % k = 0` as the below:\\n\\n`(a % k - b % k) % k = 0 = 0 % k`\\n\\nFrom the above we can say:\\n`a % k - b % k = 0`\\n\\nor, `a % k = b % k`\\n\\nLet\\'s use both of the above observations to derive our approach.\\n\\n# Approach\\n\\nLet say, the sum of sub-array from index i to j is `S`, where i < j. Given the prefix sum of the array, we have prefix sum of i is pi and prefix sum of j is pj.\\n\\nThen we can say:\\n\\n`S = pj - pi`\\n\\nNow if `S % k == 0`, then the  sum of sub-array index i to j is divisible by k and we increment the count by 1.\\n\\nLet\\'s replace `S = pj - pi` in `S % k == 0`, \\n\\n`(pj - pi) % k = 0` which implies `(pj % k - pi % k) % k = 0 % k`\\n\\nor,  `pj % k - pi % k = 0` or `pj % k = pi % k`\\n\\nThus, we conclude that if we find the same modulus of prefix sum at i and j (i < j), then we can be sure that the sub-array sum from i to j is divisible by k.\\n\\nNow, since there can be mutiple such prefix sums that repeat, we store the count of the prefix sum modulo k. Whenever, we find a repeating prefix sum we can increment the count by that number.\\n\\nThere are 2 gotchas here.\\n\\n**Gotcha#1**\\nSince, we have negative numbers too the we must take some care when calculating the modulo of a negative number.\\n\\nLets say we are dividing -5 by 2, then there can be 2 case:\\n\\n```\\ncase 1: \\n     -5 | 2\\n (-) -6 | -3\\n ---------- \\n      1  as the remainder\\n```\\n\\n```\\ncase 2: \\n     -5 | 2\\n (-) -4 | -2\\n ---------- \\n     -1  as the remainder\\n\\n```\\n\\nThus, we would miss a sub-arry if this negative remainder is not handled. As seen above, 1 and -1 differ by 2. We can handle this case by adding k to the negative remainder.  \\n\\n**Gotcha#2**\\n\\nIf the prefix sum at i is divisible by k, i.e. `pi % k == 0`, then the remainder would be 0 and the very first time 0 remainder would be encountered we would have the frequency as 0 and our final count would be short by 1. \\nThus to handle this we set the frequency of remainder 0 as 1 at the begining.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$. As we are only traversing  the array once. \\n  \\n- Space complexity: $$O(k)$$. Since we are storing the frequencies of the remainders. Thus there can be k remainders when dividing a number by k(0, 1, 2, 3 ... k-1).\\n\\n\\n# Code\\n\\n**Python**\\n```\\nclass Solution(object):\\n    def subarraysDivByK(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        s = defaultdict(int) # set()\\n        pref = 0\\n        count = 0\\n        s[0] = 1\\n\\n        for i, n in enumerate(nums):\\n            pref += n\\n            target = pref%k\\n\\n            if target < 0: target += k\\n\\n            if target in s: count += s[target]\\n\\n            s[target] += 1\\n\\n        return count\\n```\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int, int> hashmap; // prefix%k and it\\'s frequency\\n        hashmap.insert({0, 1});\\n        \\n        int prefix = 0;\\n        \\n        int total = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            prefix = (prefix + nums[i])%k;\\n            \\n            if(prefix < 0) prefix += k;\\n            \\n            if(hashmap.find(prefix%k) != hashmap.end()){\\n                total += hashmap[prefix%k];\\n            }\\n            \\n            hashmap[prefix%k]++;            \\n        }\\n        \\n        return total;\\n    }\\n};\\n```\\n\\nPlease feel free to ask in the comments if you have any doubts or suggest an edit. Thank you for reading. Hope you crack that dream job!\\uD83D\\uDE00",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n(a + b) % c = (a % c + b % c) % c\\n(a \\u2212 b) % c = (a % c \\u2212 b % c) % c\\n(a \\u2217 b) % c = (a % c \\u2217 b % c) % c\\n```\n```\\ncase 1: \\n     -5 | 2\\n (-) -6 | -3\\n ---------- \\n      1  as the remainder\\n```\n```\\ncase 2: \\n     -5 | 2\\n (-) -4 | -2\\n ---------- \\n     -1  as the remainder\\n\\n```\n```\\nclass Solution(object):\\n    def subarraysDivByK(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        s = defaultdict(int) # set()\\n        pref = 0\\n        count = 0\\n        s[0] = 1\\n\\n        for i, n in enumerate(nums):\\n            pref += n\\n            target = pref%k\\n\\n            if target < 0: target += k\\n\\n            if target in s: count += s[target]\\n\\n            s[target] += 1\\n\\n        return count\\n```\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int, int> hashmap; // prefix%k and it\\'s frequency\\n        hashmap.insert({0, 1});\\n        \\n        int prefix = 0;\\n        \\n        int total = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            prefix = (prefix + nums[i])%k;\\n            \\n            if(prefix < 0) prefix += k;\\n            \\n            if(hashmap.find(prefix%k) != hashmap.end()){\\n                total += hashmap[prefix%k];\\n            }\\n            \\n            hashmap[prefix%k]++;            \\n        }\\n        \\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072705,
                "title": "simple-and-easy-to-understand-c",
                "content": "# Intuition\\nJust using the prefix sum and some basic maths\\n# Approach\\ndifference between the prefixsum remainder after divide by \\'k\\'\\n\\n# Complexity\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int>rem;\\n        int ans=0;\\n        int n=nums.size();\\n        vector<int>prefixsum;\\n        prefixsum.push_back(nums[0]);\\n        for(int i=1;i<n;i++){\\n            prefixsum.push_back(nums[i]+prefixsum[i-1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            int r=prefixsum[i]%k;\\n             if(r==0)\\n            ans++;\\n            if(r<0)\\n             r=k+r;\\n             if(rem[r]!=0)\\n            ans+=rem[r];\\n            rem[r]++;  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int>rem;\\n        int ans=0;\\n        int n=nums.size();\\n        vector<int>prefixsum;\\n        prefixsum.push_back(nums[0]);\\n        for(int i=1;i<n;i++){\\n            prefixsum.push_back(nums[i]+prefixsum[i-1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            int r=prefixsum[i]%k;\\n             if(r==0)\\n            ans++;\\n            if(r<0)\\n             r=k+r;\\n             if(rem[r]!=0)\\n            ans+=rem[r];\\n            rem[r]++;  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072125,
                "title": "java-c-100-solution-using-hashmap-subarray-sums-divisible-by-k",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        HashMap<Integer,Integer> prefixSum = new HashMap<>();\\n        int ans=0,currPrefix=0;\\n        prefixSum.put(0,1);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            currPrefix = (currPrefix + nums[i] % k + k) % k;\\n            ans+=prefixSum.getOrDefault(currPrefix,0);\\n            prefixSum.put(currPrefix%k,prefixSum.getOrDefault(currPrefix,0)+1);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        map<int,int> prefixSum;\\n        int ans=0,currPrefix=0;\\n        prefixSum[0]++;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            currPrefix = (currPrefix + nums[i] % k + k) % k;\\n            ans+=prefixSum[currPrefix%k];\\n            prefixSum[currPrefix%k]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        HashMap<Integer,Integer> prefixSum = new HashMap<>();\\n        int ans=0,currPrefix=0;\\n        prefixSum.put(0,1);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            currPrefix = (currPrefix + nums[i] % k + k) % k;\\n            ans+=prefixSum.getOrDefault(currPrefix,0);\\n            prefixSum.put(currPrefix%k,prefixSum.getOrDefault(currPrefix,0)+1);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        map<int,int> prefixSum;\\n        int ans=0,currPrefix=0;\\n        prefixSum[0]++;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            currPrefix = (currPrefix + nums[i] % k + k) % k;\\n            ans+=prefixSum[currPrefix%k];\\n            prefixSum[currPrefix%k]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071714,
                "title": "easy-video-explaination-step-by-step-explanation-o-1-o-n-o-n",
                "content": "# Explanation\\nWe will delve into the problem by breaking it down into five key elements:\\n- The problem definition,\\n- Approach: Our method for solving it,\\n- An example for better understanding of the code \\n  (*You won\\'t want to miss this ~ 2:33 - 5:58*)\\u2B50,\\n- Intuition: The reasoning behind the code,\\n- An analysis of the complexity\\n\\n**Don\\'t miss out:** *The content is explained in an easy-to-understand manner. I\\'m certain it will be very useful*\\uD83D\\uDC41\\uFE0F\\n\\nhttps://www.youtube.com/watch?v=9JSdaolVhts\\n\\n***If you found value in this video, please consider supporting the effort that went into creating it. Your support is greatly appreciated***\\uD83D\\uDC3F\\uFE0F\\n\\n### Approach:\\n- Prefix Sum ~ to find the sum of all subarrays in the given array. \\n- Hash Map ~ to store the remainder of each sum when divided by k.\\n- For each sum, check if the remainder already exists in the hash map.\\n-  If it does, increment the count by the number of times the remainder was found in the hash map.\\n- If the remainder is zero, increment the count by 1. \\n- Finally, return the count.\\n\\n### Complexity\\n- **Time complexity** ~ O(n)\\n- **Space complexity** ~ O(n)\\n\\n- **Note:** The unordered_map internally uses a hash table to store the elements, so the average case time complexity of operations like searching, insertion, and deletion is O(1).\\nHowever, in the worst case, due to collisions, the time complexity can be O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n    int count = 0; // variable to store the number of subarrays with sum divisible by k\\n    int prefix_sum = 0; // variable to store the prefix sum of subarrays\\n    unordered_map<int, int> remainder_count; // hashmap to store the count of remainders when prefix_sum is divided by k\\n\\n    for (int i = 0; i < nums.size(); i++) {\\n        prefix_sum += nums[i]; // adding current element to prefix_sum\\n        int remainder = (prefix_sum % k + k) % k; // To handle negative numbers, we add k to make sure the remainder is positive\\n        if (remainder_count.find(remainder) != remainder_count.end()) {\\n            count += remainder_count[remainder]; // if remainder already exists, add the count of that remainder to count\\n        }\\n        if (remainder == 0) {\\n            count++; // if remainder is zero, increment count by 1\\n        }\\n        remainder_count[remainder]++; // increment count of remainder in remainder_count map\\n    }\\n\\n    return count;\\n}\\n\\n};\\n```\\n![upvotee.jpg](https://assets.leetcode.com/users/images/e9ab2638-b67e-4627-b3b2-9a9a22f0846e_1674113681.4102023.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n    int count = 0; // variable to store the number of subarrays with sum divisible by k\\n    int prefix_sum = 0; // variable to store the prefix sum of subarrays\\n    unordered_map<int, int> remainder_count; // hashmap to store the count of remainders when prefix_sum is divided by k\\n\\n    for (int i = 0; i < nums.size(); i++) {\\n        prefix_sum += nums[i]; // adding current element to prefix_sum\\n        int remainder = (prefix_sum % k + k) % k; // To handle negative numbers, we add k to make sure the remainder is positive\\n        if (remainder_count.find(remainder) != remainder_count.end()) {\\n            count += remainder_count[remainder]; // if remainder already exists, add the count of that remainder to count\\n        }\\n        if (remainder == 0) {\\n            count++; // if remainder is zero, increment count by 1\\n        }\\n        remainder_count[remainder]++; // increment count of remainder in remainder_count map\\n    }\\n\\n    return count;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071438,
                "title": "fastest-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(K)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        lst=[0]*k\\n        n=len(nums)\\n        sm=0\\n        for i in range(n):\\n            sm+=nums[i]\\n            lst[sm%k]+=1\\n        st=lst[0]\\n        ct=(st*(2+(st-1)))//2\\n        for i in range(1,k):\\n            x=lst[i]\\n            ct+=(x*(x-1))//2\\n        return ct\\n\\n\\n        \\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        lst=[0]*k\\n        n=len(nums)\\n        sm=0\\n        for i in range(n):\\n            sm+=nums[i]\\n            lst[sm%k]+=1\\n        st=lst[0]\\n        ct=(st*(2+(st-1)))//2\\n        for i in range(1,k):\\n            x=lst[i]\\n            ct+=(x*(x-1))//2\\n        return ct\\n\\n\\n        \\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071287,
                "title": "c-begineer-friendly-easy-understanding-heap-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=6nD404xYEMw/\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int>mp;\\n\\n        int currentSum=0;\\n        int ans =0;\\n        mp[0]++;\\n\\n        for(auto x:nums){\\n            currentSum+=x;\\n            int mod = (currentSum %k +k)%k;\\n\\n            // check if mod already present\\n            if(mp.find(mod)!=mp.end()){\\n                ans+=mp[mod];\\n            }\\n            mp[mod]++;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Ordered Map",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int>mp;\\n\\n        int currentSum=0;\\n        int ans =0;\\n        mp[0]++;\\n\\n        for(auto x:nums){\\n            currentSum+=x;\\n            int mod = (currentSum %k +k)%k;\\n\\n            // check if mod already present\\n            if(mp.find(mod)!=mp.end()){\\n                ans+=mp[mod];\\n            }\\n            mp[mod]++;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071264,
                "title": "c-clean-code-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe brute-force solution is that we iterate over each subarray and check if the subarray sum is divisible by k but this solution will give us TLE given the constraints.\\n#### So, the main question is whelther you can access all subarrays in a better way (less than O(n^2))?\\n\\nThe answer to the above question is **PREFIX SUM ARRAY**.\\nUsing Prefix sum array we can access all the subarrays in O(n).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Construct a prefix sum array\\n2. Find modulo of every element of prefix sum array with \\'k\\'\\n3. Find the required pairs using frequency stored in map\\n4. Rest explaination in comments.\\n# Complexity\\n- Time complexity: O(nLogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**Optimized Solution**: Prefix Array can be replaced by an variable to store the current_sum and map can be replaced by an array of size \\'k\\'.\\nThis will reduce the time complexity to O(n). \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> prefix_nums(n,0);\\n        prefix_nums[0] = nums[0]%k;\\n        if(prefix_nums[0] < 0){\\n            prefix_nums[0] += k;\\n        }\\n        for(int i=1; i<n; i++){\\n            prefix_nums[i] = prefix_nums[i-1] + nums[i];\\n            prefix_nums[i] %= k;\\n            if(prefix_nums[i] < 0){\\n                prefix_nums[i] += k;\\n            }\\n        }\\n        \\n        // here we are done creating a prefixArray\\n        // i.e. when nums = [4,5,0,-2,-3,1] && k = 5\\n        // the prefix array would be \\n        // prefix_nums = [4,9,9,7,4,5]\\n        // but we aren\\'t done yet, we also take its modulo with k\\n        // so, final prefix_nums = [4,4,4,2,4,0]\\n        // at this point its quiet intuitive why the answer is 7 in this case\\n        // but still here are the index-pairs\\n        // (0,1), (0,2), (0,4)\\n        // (1,2), (1,4)\\n        // (2,4)\\n        // (5,5) --> this can be treated as a special case\\n\\n        map<int,int> m;\\n        int ans{};\\n        for(int i=0; i<n; i++){\\n            ans += m[prefix_nums[i]];\\n            m[prefix_nums[i]]++;\\n            if(prefix_nums[i] == 0)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n`Do Upvote if you found it HELPFUL`\\n`Till then Happy Coding`\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> prefix_nums(n,0);\\n        prefix_nums[0] = nums[0]%k;\\n        if(prefix_nums[0] < 0){\\n            prefix_nums[0] += k;\\n        }\\n        for(int i=1; i<n; i++){\\n            prefix_nums[i] = prefix_nums[i-1] + nums[i];\\n            prefix_nums[i] %= k;\\n            if(prefix_nums[i] < 0){\\n                prefix_nums[i] += k;\\n            }\\n        }\\n        \\n        // here we are done creating a prefixArray\\n        // i.e. when nums = [4,5,0,-2,-3,1] && k = 5\\n        // the prefix array would be \\n        // prefix_nums = [4,9,9,7,4,5]\\n        // but we aren\\'t done yet, we also take its modulo with k\\n        // so, final prefix_nums = [4,4,4,2,4,0]\\n        // at this point its quiet intuitive why the answer is 7 in this case\\n        // but still here are the index-pairs\\n        // (0,1), (0,2), (0,4)\\n        // (1,2), (1,4)\\n        // (2,4)\\n        // (5,5) --> this can be treated as a special case\\n\\n        map<int,int> m;\\n        int ans{};\\n        for(int i=0; i<n; i++){\\n            ans += m[prefix_nums[i]];\\n            m[prefix_nums[i]]++;\\n            if(prefix_nums[i] == 0)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071003,
                "title": "2-java-solutions-using-map-using-array",
                "content": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int K) {\\n     Map<Integer,Integer> freq=new HashMap<>();\\n        freq.put(0,1);\\n        int prefix=0,res=0;\\n        for(int num:nums){\\n            prefix = (prefix + num % K + K) % K;\\n            res += freq.getOrDefault(prefix, 0);\\n            freq.put(prefix, freq.getOrDefault(prefix, 0) + 1);\\n        }  \\n        return res;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int K) {\\n        int[] count = new int[K];\\n        count[0] = 1;\\n        int prefix = 0, res = 0;\\n        for (int num : Nums) {\\n            prefix = (prefix + num % K + K) % K;\\n            res += count[prefix]++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int K) {\\n     Map<Integer,Integer> freq=new HashMap<>();\\n        freq.put(0,1);\\n        int prefix=0,res=0;\\n        for(int num:nums){\\n            prefix = (prefix + num % K + K) % K;\\n            res += freq.getOrDefault(prefix, 0);\\n            freq.put(prefix, freq.getOrDefault(prefix, 0) + 1);\\n        }  \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int K) {\\n        int[] count = new int[K];\\n        count[0] = 1;\\n        int prefix = 0, res = 0;\\n        for (int num : Nums) {\\n            prefix = (prefix + num % K + K) % K;\\n            res += count[prefix]++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070583,
                "title": "very-short-solution-with-detailed-explanation-remainders-stored-in-hash-table",
                "content": "# Approach\\nSay we have subarray $$A$$ comprised of two non overlapping subarrays $$B_1,B_2$$.\\nSuppose that they have sums $$a, b_1, b_2$$, respectively. How are the properties of any of them being divisible by $$k$$ related to each other.\\nWe have that $$b_2=a-b_1$$, so that $$b_2$$ is zero $$mod \\\\, k$$ if any only if $$a$$ and $$b_1$$ have the same remainder $$mod \\\\, k$$.\\nHence we can scan the arry linearly once, check how often we have seen any remainder for subarrays of the type $$nums[:i]$$ so far and use the above observation to compute the number of subarrays ending at i that have sum divisible by $$k$$, then just update the total count accordingly.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(k)$$ at worst.\\n\\n# Code\\n```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        l=len(nums)\\n        remainders={0:1}\\n        pre=0\\n        total=0\\n        for i in range(l):\\n            pre+=nums[i]\\n            rem=pre%k\\n            remainders.setdefault(rem,0)\\n            total+=remainders[rem]\\n            remainders[rem]+=1\\n            \\n        return total\\n\\n      \\n      \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        l=len(nums)\\n        remainders={0:1}\\n        pre=0\\n        total=0\\n        for i in range(l):\\n            pre+=nums[i]\\n            rem=pre%k\\n            remainders.setdefault(rem,0)\\n            total+=remainders[rem]\\n            remainders[rem]+=1\\n            \\n        return total\\n\\n      \\n      \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070485,
                "title": "easy-c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialized count and sum to 0 initially.\\n2. Created an map with 0 values as 1.\\n3. Then in loop doing cummulative sum of all arrived elements. the finding reminder and if that reminder occured more then once incrementing it with count. then incrementing reminder position in map.\\n4. returning the count.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int n=nums.size(),i=0,count=0,sum=0;\\n        unordered_map<int, int> x;\\n        x[0] = 1;\\n        while(i<n){\\n            sum+=nums[i];\\n            int rem=sum%k;\\n            if(rem<0) rem+=k;\\n            if(x[rem]!=0) count+=x[rem];\\n            x[rem]++;\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int n=nums.size(),i=0,count=0,sum=0;\\n        unordered_map<int, int> x;\\n        x[0] = 1;\\n        while(i<n){\\n            sum+=nums[i];\\n            int rem=sum%k;\\n            if(rem<0) rem+=k;\\n            if(x[rem]!=0) count+=x[rem];\\n            x[rem]++;\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679519,
                "title": "c-solution",
                "content": "```\\nint subarraysDivByK(vector<int>& nums, int k) {\\n       unordered_map<int,int>m;\\n        m[0]=1;\\n        int sum=0;\\n        int result=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            int rem=sum%k;\\n            if(rem<0)\\n                rem+=k;\\n            if(m.find(rem)!=m.end())\\n            {\\n                result+=m[rem];\\n            }\\n            m[rem]++;\\n            \\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint subarraysDivByK(vector<int>& nums, int k) {\\n       unordered_map<int,int>m;\\n        m[0]=1;\\n        int sum=0;\\n        int result=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            int rem=sum%k;\\n            if(rem<0)\\n                rem+=k;\\n            if(m.find(rem)!=m.end())\\n            {\\n                result+=m[rem];\\n            }\\n            m[rem]++;\\n            \\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2479413,
                "title": "leetcode-the-hard-way-hash-map-prefix-sum-with-explanation",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // for basic knowledge on prefix sum, please check out\\n\\t// https://wingkwong.github.io/leetcode-the-hard-way/tutorials/basic-topics/prefix-sum#overview\\n    vector<int> generatePrefixSum(vector<int>& a) {\\n        int n = a.size();\\n        vector<int> pref(n);\\n        pref[0] = a[0];\\n        for (int i = 1; i < n; i++) pref[i] = pref[i - 1] + a[i];\\n        return pref;\\n    }\\n\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        // generate prefix sum\\n        vector<int> pref = generatePrefixSum(nums);\\n        // store the modular cnt\\n        vector<int> m(k);\\n        // base value\\n        m[0] = 1;\\n        // init ans\\n        int ans = 0;\\n        // iterate each sum\\n        for (auto& x : pref) {\\n            // if x is negative, turn it to positive modular equivalent\\n            if (x < 0) x = (x % k + k) % k;\\n            // we need to find pairs such that (pref[j] - pref[i]) % k == 0\\n            // hence, we look for pref[j] % k == pref[i] % k\\n            // proof ..? \\n            // pref[j] = a * k + x\\n            // pref[i] = b * k + y\\n            // pref[j] - pref[i] = (a * k + x) - (b * k + y)\\n            // pref[j] - pref[i] = k * (a - b) + (x - y)\\n            // -> (pref[j] - pref[i]) % k == 0 if & only if (x - y) == 0\\n            m[x % k]++;\\n        }\\n        // n choose 2\\n        for (auto& x : m) ans += x * (x - 1) / 2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // for basic knowledge on prefix sum, please check out\\n\\t// https://wingkwong.github.io/leetcode-the-hard-way/tutorials/basic-topics/prefix-sum#overview\\n    vector<int> generatePrefixSum(vector<int>& a) {\\n        int n = a.size();\\n        vector<int> pref(n);\\n        pref[0] = a[0];\\n        for (int i = 1; i < n; i++) pref[i] = pref[i - 1] + a[i];\\n        return pref;\\n    }\\n\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        // generate prefix sum\\n        vector<int> pref = generatePrefixSum(nums);\\n        // store the modular cnt\\n        vector<int> m(k);\\n        // base value\\n        m[0] = 1;\\n        // init ans\\n        int ans = 0;\\n        // iterate each sum\\n        for (auto& x : pref) {\\n            // if x is negative, turn it to positive modular equivalent\\n            if (x < 0) x = (x % k + k) % k;\\n            // we need to find pairs such that (pref[j] - pref[i]) % k == 0\\n            // hence, we look for pref[j] % k == pref[i] % k\\n            // proof ..? \\n            // pref[j] = a * k + x\\n            // pref[i] = b * k + y\\n            // pref[j] - pref[i] = (a * k + x) - (b * k + y)\\n            // pref[j] - pref[i] = k * (a - b) + (x - y)\\n            // -> (pref[j] - pref[i]) % k == 0 if & only if (x - y) == 0\\n            m[x % k]++;\\n        }\\n        // n choose 2\\n        for (auto& x : m) ans += x * (x - 1) / 2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349108,
                "title": "hashmap-java",
                "content": "```\\nThe approch here is , we store remainders and its freq in a Hashmap. if we encounter a remainder frequency twice\\nit means we have a subarray sum starting from index 0 to that particular index where frequency was 2 minus sum\\nfrom index 0 to index where remainder frequency was 1 , this subarray sum is divisible by p.\\n\\nclass Solution {\\n    public int subarraysDivByK(int[] arr, int k) {\\n         int result = 0;\\n        \\n        Map<Integer , Integer>map = new HashMap<>();\\n        map.put(0 , 1);\\n        \\n        int sum = 0;\\n        int rem = 0;\\n        \\n        for(int i = 0; i < arr.length; i++){\\n            sum += arr[i];\\n            rem = sum % k;\\n            \\n            if(rem < 0)\\n                rem += k;\\n            \\n            if(map.containsKey(rem)){\\n                result += map.get(rem);\\n                map.put(rem , map.get(rem)+1);\\n            }\\n            else{\\n                map.put(rem , 1);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nThe approch here is , we store remainders and its freq in a Hashmap. if we encounter a remainder frequency twice\\nit means we have a subarray sum starting from index 0 to that particular index where frequency was 2 minus sum\\nfrom index 0 to index where remainder frequency was 1 , this subarray sum is divisible by p.\\n\\nclass Solution {\\n    public int subarraysDivByK(int[] arr, int k) {\\n         int result = 0;\\n        \\n        Map<Integer , Integer>map = new HashMap<>();\\n        map.put(0 , 1);\\n        \\n        int sum = 0;\\n        int rem = 0;\\n        \\n        for(int i = 0; i < arr.length; i++){\\n            sum += arr[i];\\n            rem = sum % k;\\n            \\n            if(rem < 0)\\n                rem += k;\\n            \\n            if(map.containsKey(rem)){\\n                result += map.get(rem);\\n                map.put(rem , map.get(rem)+1);\\n            }\\n            else{\\n                map.put(rem , 1);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2302654,
                "title": "easy-c-with-explanation-in-steps-with-pictures",
                "content": "\\uD83D\\uDD25 **Please upvote, It is FREE from your side**\\nAlgorithm --> \\n\\n![image](https://assets.leetcode.com/users/images/4aa41689-2ecb-4d94-bdc0-9543541a7f61_1658211835.8275175.png)\\n![image](https://assets.leetcode.com/users/images/934d5243-7f1e-4551-a358-ecd8db5e3e90_1658211852.4913683.png)\\n\\n**Dry run through the Algo Youll understand**\\n\\n\\n```\\n#define um unordered_map<int, int>\\n#define vc vector<int>\\n#define dvc vector<vector<int>>\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        um reminders_freq;\\n        int n = nums.size();\\n        int sum = 0;\\n        reminders_freq[0] = 1;\\n        int ans = 0;\\n        for(int i = 0; i<n; i++){\\n            sum+=nums[i];\\n            int rem = sum%k;\\n            if(rem<0){\\n                rem = k+rem;\\n            }\\n            if(reminders_freq.find(rem)!=reminders_freq.end()){\\n                reminders_freq[rem]++;\\n                ans+=(reminders_freq[rem]-1);\\n            }else{\\n                reminders_freq[rem] = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define um unordered_map<int, int>\\n#define vc vector<int>\\n#define dvc vector<vector<int>>\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        um reminders_freq;\\n        int n = nums.size();\\n        int sum = 0;\\n        reminders_freq[0] = 1;\\n        int ans = 0;\\n        for(int i = 0; i<n; i++){\\n            sum+=nums[i];\\n            int rem = sum%k;\\n            if(rem<0){\\n                rem = k+rem;\\n            }\\n            if(reminders_freq.find(rem)!=reminders_freq.end()){\\n                reminders_freq[rem]++;\\n                ans+=(reminders_freq[rem]-1);\\n            }else{\\n                reminders_freq[rem] = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288372,
                "title": "python3-detailed-explanation-using-comments",
                "content": "***Please upvote if you found this helpful!***\\n```\\t\\n\\tclass Solution:\\n\\t\\tdef subarraysDivByK(self, nums: List[int], k: int) -> int:\\n\\t\\t\\td = {0:1}\\n\\n        # i take dictionary with 0 : 1 because \\n        # if i find a subarray sum = 0, which is ofc divisble by k,\\n        # then i need to add freq. of remainder = 0 to the array;\\n        # which should be 1 otherwise i wont be adding anything.\\n        # example:\\n        # arr = {0,3,-3,.....} k = 5\\n        # when i find (3+(-3)) = 0 , 0 is divisible by 5 so i need to add\\n        # it to my ans. so i would do something like : \\n        # if sum%k in hashmap: add freq of that, but sum is 0%5 = 0\\n        # so 0 should have inital mapping to 1;\\n        # Hope it clears it!\\n\\n        ans = cum_sum = 0\\n        for i,num in enumerate(nums):\\n            cum_sum += num\\n            rem = cum_sum % k\\n            if rem < 0:\\n                rem += k\\n            if rem in d:\\n                ans += d[rem]\\n                d[rem] += 1\\n            else:\\n                d[rem] = 1\\n        return ans\\n```\\n\\n    #Explanation:\\n    # sum(i,j)     = sum(0,j) - sum(0,i)\\n    #              = (q1*k + rem1) - (q2*k + rem2)\\n    #              = k*(q1-q2) + (rem1-rem2)\\n    # if sum(i,j) is divisble by k (LHS) so for lhs = rhs; rem1 = rem2 \\n    # should be satisfied.\\n    # meaning ==> sum(o,i)%k should be equal to sum(o,j)%k;\\n    # meaning ==> if the remainder till the ith element is rem1 and remainder\\n    # till the jth element is rem2 and they are equal, then it means remainder of       \\n\\t# {subarray(i,j)_sum} will be 0 when divided by k.\\n\\t```\\n",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\t\\n\\tclass Solution:\\n\\t\\tdef subarraysDivByK(self, nums: List[int], k: int) -> int:\\n\\t\\t\\td = {0:1}\\n\\n        # i take dictionary with 0 : 1 because \\n        # if i find a subarray sum = 0, which is ofc divisble by k,\\n        # then i need to add freq. of remainder = 0 to the array;\\n        # which should be 1 otherwise i wont be adding anything.\\n        # example:\\n        # arr = {0,3,-3,.....} k = 5\\n        # when i find (3+(-3)) = 0 , 0 is divisible by 5 so i need to add\\n        # it to my ans. so i would do something like : \\n        # if sum%k in hashmap: add freq of that, but sum is 0%5 = 0\\n        # so 0 should have inital mapping to 1;\\n        # Hope it clears it!\\n\\n        ans = cum_sum = 0\\n        for i,num in enumerate(nums):\\n            cum_sum += num\\n            rem = cum_sum % k\\n            if rem < 0:\\n                rem += k\\n            if rem in d:\\n                ans += d[rem]\\n                d[rem] += 1\\n            else:\\n                d[rem] = 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271394,
                "title": "easy-java-implementation-with-explanation",
                "content": "Approach:\\n* We will use a Hash map and store the count of remainders in the Map.\\n* Iterate throught the list and calculate the sum till each value.\\n* find the remainder of the sum at each index and store it in the map\\n* if that remainder already exist in the map, this means the sum of the sum array from that idx to current index is divisible by k.\\n* So add the count present for that remainder to the final count and increment the value in map\\n* return the final count.\\n\\nHere -ve remainder are special case if we encounter and -ve remainder make is +ve by adding k. (we can add k to a -ve remainder to make it +ve remainder)\\n\\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        map.put(0,1);\\n        int count = 0, sum = 0;\\n        \\n        for(int i=0;i<nums.length;i++){  \\n            sum+= nums[i];\\n            \\n            int remainder = sum%k;\\n            if(remainder < 0) remainder += k;\\n            \\n            if(map.containsKey(remainder)){\\n                count+= map.get(remainder);\\n                map.put(remainder, map.get(remainder)+1);\\n            }else{\\n                map.put(remainder,1);\\n            }  \\n        }\\n        return count; \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        map.put(0,1);\\n        int count = 0, sum = 0;\\n        \\n        for(int i=0;i<nums.length;i++){  \\n            sum+= nums[i];\\n            \\n            int remainder = sum%k;\\n            if(remainder < 0) remainder += k;\\n            \\n            if(map.containsKey(remainder)){\\n                count+= map.get(remainder);\\n                map.put(remainder, map.get(remainder)+1);\\n            }else{\\n                map.put(remainder,1);\\n            }  \\n        }\\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938049,
                "title": "cpp-hash-maps-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k){\\n        \\n    \\n        unordered_map<int,int>m;\\n        int sum=0;\\n        int count=0;\\n        for(int i =0;i<nums.size();i++){\\n            sum+=nums[i];\\n            int rem = sum%k;\\n            if(rem==0)count++;\\n            if(rem<0)rem+=k;\\n            if(m.find(rem)!=m.end())count+=m[rem];\\n               m[rem]++;\\n        }\\n               return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k){\\n        \\n    \\n        unordered_map<int,int>m;\\n        int sum=0;\\n        int count=0;\\n        for(int i =0;i<nums.size();i++){\\n            sum+=nums[i];\\n            int rem = sum%k;\\n            if(rem==0)count++;\\n            if(rem<0)rem+=k;\\n            if(m.find(rem)!=m.end())count+=m[rem];\\n               m[rem]++;\\n        }\\n               return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776799,
                "title": "java-picture-detail-explanation-prefix-sum-hashmap-easy-solution",
                "content": "![image](https://assets.leetcode.com/users/images/26096b71-7cae-4446-9476-e8a34a75dcfd_1645044102.108473.jpeg)\\n* While iterating through the array if we can store the prefixSum at each index in a HashMap and at the same time check if a prefixSum exists for the current runningSum%k. we\\'ll use use a HashMap to compute and store the prefix sums as Keys and the corresponding frequencies as Values. \\n* we\\'ll use the almost same approach which we used in the leetcode problem 560. If you want detail explanation then ->\\nHere is the link of the problem\\n[https://leetcode.com/problems/subarray-sum-equals-k/discuss/1532102/java-picture-explanation-2-methods-prefix-sum-hashmap-easy-solution]\\n\\n**Please have a look on above problem & After following this problem you will get an idea how to solve this problem**\\n\\n```\\n Map<Integer,Integer> p= new HashMap();\\n       p.put(0,1);\\n        int runningsum=0,count=0;\\n        \\n     for(int i=0;i<nums.length;i++){\\n         runningsum+=nums[i];\\n         int j=runningsum%k;\\n         if(j<0) j+=k;\\n         if(p.containsKey(j)){\\n         count+=p.get(j);\\n     }\\n             p.put(j,p.getOrDefault(j,0)+1);\\n           \\n     }\\n        return count;\\n        \\n```\\n\\nif you like it , then please upvote it",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\n Map<Integer,Integer> p= new HashMap();\\n       p.put(0,1);\\n        int runningsum=0,count=0;\\n        \\n     for(int i=0;i<nums.length;i++){\\n         runningsum+=nums[i];\\n         int j=runningsum%k;\\n         if(j<0) j+=k;\\n         if(p.containsKey(j)){\\n         count+=p.get(j);\\n     }\\n             p.put(j,p.getOrDefault(j,0)+1);\\n           \\n     }\\n        return count;\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1759644,
                "title": "c-elegant-and-simple-code",
                "content": "This is very similar to leetcode 560. Subarray Sum Equals K problem.  For mod operations, I defined a macro to handle negative values. \\n\\n```\\nclass Solution {\\n    #define mod(x, k) ((((x) % (k)) + k) % k)\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int count = 0;\\n        int sum = 0;\\n\\n        vector<int> m(k, 0);\\n\\t\\t// we have at least one element in the history beforehand because \\n\\t\\t// the sum of the empty subarray is zero and can be divided by K\\n\\t\\tm[0] = 1;\\n\\n        for (auto &num : nums) {\\n            sum += num;\\n\\t\\t\\t// i <= j\\n\\t\\t\\t// sum(nums[i..j]) = sum(nums[0..j]) - sum(nums[0..i])\\n\\t\\t\\t// sum(nums[i..j]) % K = (sum(nums[0..j]) - sum(nums[0..i])) % K\\n\\t\\t\\t// if sum(nums[i..j]) can be divided by K, it means sum(nums[i..j]) % K = 0\\n\\t\\t\\t// therefore (sum(nums[0..j]) - sum(nums[0..i])) % K should be 0\\n\\t\\t\\t// sum(nums[0..j]) % K = sum(nums[0..i]) % K\\n            count += m[mod(sum, k)]; \\n\\t\\t\\t// Add new mod in the history\\n            m[mod(sum, k)]++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    #define mod(x, k) ((((x) % (k)) + k) % k)\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int count = 0;\\n        int sum = 0;\\n\\n        vector<int> m(k, 0);\\n\\t\\t// we have at least one element in the history beforehand because \\n\\t\\t// the sum of the empty subarray is zero and can be divided by K\\n\\t\\tm[0] = 1;\\n\\n        for (auto &num : nums) {\\n            sum += num;\\n\\t\\t\\t// i <= j\\n\\t\\t\\t// sum(nums[i..j]) = sum(nums[0..j]) - sum(nums[0..i])\\n\\t\\t\\t// sum(nums[i..j]) % K = (sum(nums[0..j]) - sum(nums[0..i])) % K\\n\\t\\t\\t// if sum(nums[i..j]) can be divided by K, it means sum(nums[i..j]) % K = 0\\n\\t\\t\\t// therefore (sum(nums[0..j]) - sum(nums[0..i])) % K should be 0\\n\\t\\t\\t// sum(nums[0..j]) % K = sum(nums[0..i]) % K\\n            count += m[mod(sum, k)]; \\n\\t\\t\\t// Add new mod in the history\\n            m[mod(sum, k)]++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679181,
                "title": "python-3-prefix-sum-solution",
                "content": "```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        count = collections.defaultdict(int)\\n        count[0] = 1\\n        sum_num = 0\\n        ans = 0\\n        for num in nums:\\n            sum_num += num\\n            if (sum_num % k) in count:\\n                ans += count[sum_num % k]\\n            count[sum_num % k] += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        count = collections.defaultdict(int)\\n        count[0] = 1\\n        sum_num = 0\\n        ans = 0\\n        for num in nums:\\n            sum_num += num\\n            if (sum_num % k) in count:\\n                ans += count[sum_num % k]\\n            count[sum_num % k] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630380,
                "title": "974-subarray-sums-divisible-by-k-2-approaches-o-n-k-and-o-n-with-explaination",
                "content": "## Approach 1: O(n+k) time and O(k) space \\n**Intuition:** If prefix sum till index i=Si and prefix sum till index j=Sj,\\nThen, if Si%k=rem1 and Sj%k=rem2\\nif both sums leave same remainder, \\nSi%k=Sj%k => (Sj%k-Si%k)Si%k=0 \\nThat means subarray sum from (i+1) to j will be divisible by k;\\n```\\n nums [i]                    = [ 4  5  0  -2  -3  1  ] and k=5\\n prefix sum till index i     = [ 4  9  9   7   4  5  ]\\n prefix sum till index i%k   = [ 4  4  4   2   4  0  ]\\n```\\nNow if n terms of prefix sum leave the same remainder, means you may choose any 2 of them ans subarray between them will be div by k. So count the prefix sum in each residue class. In above example-\\n```\\nresidue class : count : countC2\\n0             |   1   | 0\\n1             |   0   | 0\\n2             |   1   | 0\\n3             |   0   | 0\\n4             |   4   | 4C2=6 \\n```\\nNow for each residue class calculate how much subsets in between them vy nC2=count * (count-1)/2\\n\\nNow add the subarrays with prefix sum as 0 directly(whole prefix divisible by k)= 1\\n\\nso total count here will be 0+0+0+0+6+1=7\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        long long sum=0;\\n        vector<int> residueclass(k,0);\\n        for(auto &n:nums){\\n            sum+=n;\\n            int rem=sum%k;\\n            if(rem<0)rem+=k;\\n            residueclass[rem]++;\\n        }\\n        sum=residueclass[0];\\n        \\n        while(k--){\\n            sum+=(long long)residueclass[k]*(residueclass[k]-1)/2;\\n            // cout<<i<<\",\"<<sum<<\" \";\\n        }\\n        return sum;\\n    }\\n};\\n```\\n## Approach 2: O(n) time and O(k) space \\nWe can optimize the above approach by \\n1. avoiding multiplications and doing additions\\n2. making solution O(n) independent of k in time complexity\\n\\n**Intuition:** whenever we get a residue of prefix_sum[i] we match it with the prefix_sum of same residue class that occured before element i. Eg\\n```\\n nums [i]                    = [ 4  5  0  -2  -3  1  ] and k=5\\n prefix sum till index i     = [ 4  9  9   7   4  5  ]\\n prefix sum till index i%k   = [ 4 ] // 4 residue not occured before\\n prefix sum till index i%k   = [ 4  4 ] // 4 occured 1 times before, 1 eligible subset [5]\\n prefix sum till index i%k   = [ 4  4  4 ]// 4 occured 2 times before, 2 eligible subset [5, 0] and [0]\\n prefix sum till index i%k   = [ 4  4  4   2 ]// 2 residue not occured before\\n prefix sum till index i%k   = [ 4  4  4   2   4 ]// 4 occured 3 times before, 3 eligible subset [5, 0, -2, -3], [0, -2, -3], [-2, -3]\\n prefix sum till index i%k   = [ 4  4  4   2   4  0  ]// 0 residue not occured before, 0 prefix sum means whole sum till current index is divisible by k so 1 elligible subset [4, 5, 0, -2, -3, 1]\\n```\\nSo, there are 7 subarrays with a sum divisible by k = 5:\\n [5] , [5, 0] , [0] , [5, 0, -2, -3] , [0, -2, -3] , [-2, -3] , [4, 5, 0, -2, -3, 1]\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        long long sum=0,count=0;\\n        vector<int> residueclass(k,0);\\n        for(auto &n:nums){\\n            sum+=n;\\n            int rem=sum%k;\\n            if(rem<0)rem+=k;\\n            count+=residueclass[rem];\\n            residueclass[rem]++;\\n        }\\n        count+=residueclass[0];\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n nums [i]                    = [ 4  5  0  -2  -3  1  ] and k=5\\n prefix sum till index i     = [ 4  9  9   7   4  5  ]\\n prefix sum till index i%k   = [ 4  4  4   2   4  0  ]\\n```\n```\\nresidue class : count : countC2\\n0             |   1   | 0\\n1             |   0   | 0\\n2             |   1   | 0\\n3             |   0   | 0\\n4             |   4   | 4C2=6 \\n```\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        long long sum=0;\\n        vector<int> residueclass(k,0);\\n        for(auto &n:nums){\\n            sum+=n;\\n            int rem=sum%k;\\n            if(rem<0)rem+=k;\\n            residueclass[rem]++;\\n        }\\n        sum=residueclass[0];\\n        \\n        while(k--){\\n            sum+=(long long)residueclass[k]*(residueclass[k]-1)/2;\\n            // cout<<i<<\",\"<<sum<<\" \";\\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\n nums [i]                    = [ 4  5  0  -2  -3  1  ] and k=5\\n prefix sum till index i     = [ 4  9  9   7   4  5  ]\\n prefix sum till index i%k   = [ 4 ] // 4 residue not occured before\\n prefix sum till index i%k   = [ 4  4 ] // 4 occured 1 times before, 1 eligible subset [5]\\n prefix sum till index i%k   = [ 4  4  4 ]// 4 occured 2 times before, 2 eligible subset [5, 0] and [0]\\n prefix sum till index i%k   = [ 4  4  4   2 ]// 2 residue not occured before\\n prefix sum till index i%k   = [ 4  4  4   2   4 ]// 4 occured 3 times before, 3 eligible subset [5, 0, -2, -3], [0, -2, -3], [-2, -3]\\n prefix sum till index i%k   = [ 4  4  4   2   4  0  ]// 0 residue not occured before, 0 prefix sum means whole sum till current index is divisible by k so 1 elligible subset [4, 5, 0, -2, -3, 1]\\n```\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        long long sum=0,count=0;\\n        vector<int> residueclass(k,0);\\n        for(auto &n:nums){\\n            sum+=n;\\n            int rem=sum%k;\\n            if(rem<0)rem+=k;\\n            count+=residueclass[rem];\\n            residueclass[rem]++;\\n        }\\n        count+=residueclass[0];\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1337657,
                "title": "c-solution-with-proper-comments-o-n",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int result =0, sum =0, remainder =0;\\n        unordered_map<int, int>mp; // map to store  thefrtequency of remainders of sum \\n        mp[0] =1;\\n        for(int i =0; i< nums.size(); i++){\\n            //add nums[i] to sum\\n            sum += nums[i];\\n            remainder = (sum% k);\\n            //if remainder of sum and k comes to be negative than add the remainder to k  and make remainder a positive value\\n            if( 0 > remainder){\\n                remainder += k;\\n            }\\n            //check if remiander is present in map or not:\\n            if(mp.find(remainder) != mp.end()){\\n                //add it to the result\\n                //this means we have frequency of remainder greater than one \\n                result += mp[remainder];\\n            }\\n         mp[remainder]++;\\n           \\n            \\n        }\\n        return result;\\n    }\\n};\\n```\\n**comment if have doubts and plesae upvote if you find this helpful**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int result =0, sum =0, remainder =0;\\n        unordered_map<int, int>mp; // map to store  thefrtequency of remainders of sum \\n        mp[0] =1;\\n        for(int i =0; i< nums.size(); i++){\\n            //add nums[i] to sum\\n            sum += nums[i];\\n            remainder = (sum% k);\\n            //if remainder of sum and k comes to be negative than add the remainder to k  and make remainder a positive value\\n            if( 0 > remainder){\\n                remainder += k;\\n            }\\n            //check if remiander is present in map or not:\\n            if(mp.find(remainder) != mp.end()){\\n                //add it to the result\\n                //this means we have frequency of remainder greater than one \\n                result += mp[remainder];\\n            }\\n         mp[remainder]++;\\n           \\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1290340,
                "title": "c-o-n-and-hashmap-with-math-explanation",
                "content": "This is vrey similar to the other [Subarray Sum Equal K](https://leetcode.com/problems/subarray-sum-equals-k/), and I use the main idea of that solution which is to use the cumulative sum. Here is the difference however, we are looking for intervals such that:\\n```\\ncum_sum[i] - sum_sum[j] = nk\\n```\\nNow if we expand on the term above, we will get the below nice equation:\\n```\\ncum_sum[i] = x1k + y1 , cum_sum[j] = x2k + y2\\n==> cum_sum[i] - cum_sum[j] = (x1-x2)k + (y1-y2) = nk\\n==> x1-x2 == n && y1-y2 == 0\\n==> y1==y2\\n```\\nIn another words, we are looking for subarrays that have the same residuals on K. Now, from here it is simple, just keep track of the residual of the cumulative sum in a hash map and see if you have seen it before, if so add to the result, otherwise, keep updating the map.\\n\\nHowever, there is a catch which you might ignore if using C++. In C++, the result of mod could be negative unlike Python (assuming K or denomitator is positive here):\\n\\n```\\nC++: -3 % 4 = -3   ==> -3 = (0 * 4 + (-3))\\nPython: -3 % 4 = 1 ==> -3 = (-1 * 4 + (1))\\n```\\n\\nSo in C++, you need to check if the mod is negative and if so, find the complement of it by adding the K. That\\'s it. Here is the code..\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    /*\\n    state         cum_sum     cum_sum%k       map                       ans\\n    -1              NA          NA           (0,1)                       0\\n    0               4           4            (0,1),(4,1)                 0\\n    1               9           4            (0,1),(4,2)                0+1 = 1\\n    2               9           4            (0,1),(4,3)                1+2 = 3\\n    3               7           2            (0,1),(4,3),(2,1)           3\\n    4               4           4            (0,1),(4,4),(2,1)           3+3 = 6\\n    5               5           0            (0,2),(4,4)(2,1)            6+1=7\\n    */\\n    \\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int, int> m;\\n        m[0] = 1;\\n        \\n        int sum = 0, ans = 0;\\n        for(int i=0; i < nums.size(); ++i) {\\n            sum += nums[i];\\n            \\n            // in cpp, mod gives negative value (unlike Python)\\n            // i.e in Python -2 % 3 = 1, in c++: -2 % 3 = -2\\n            int target = sum % k;\\n            if(target < 0)\\n                target += k;\\n            \\n            if(m.count(target) != 0) {\\n                ans += m[target];\\n                m[target] += 1;\\n            } else\\n                m[target] = 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\ncum_sum[i] - sum_sum[j] = nk\\n```\n```\\ncum_sum[i] = x1k + y1 , cum_sum[j] = x2k + y2\\n==> cum_sum[i] - cum_sum[j] = (x1-x2)k + (y1-y2) = nk\\n==> x1-x2 == n && y1-y2 == 0\\n==> y1==y2\\n```\n```\\nC++: -3 % 4 = -3   ==> -3 = (0 * 4 + (-3))\\nPython: -3 % 4 = 1 ==> -3 = (-1 * 4 + (1))\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    /*\\n    state         cum_sum     cum_sum%k       map                       ans\\n    -1              NA          NA           (0,1)                       0\\n    0               4           4            (0,1),(4,1)                 0\\n    1               9           4            (0,1),(4,2)                0+1 = 1\\n    2               9           4            (0,1),(4,3)                1+2 = 3\\n    3               7           2            (0,1),(4,3),(2,1)           3\\n    4               4           4            (0,1),(4,4),(2,1)           3+3 = 6\\n    5               5           0            (0,2),(4,4)(2,1)            6+1=7\\n    */\\n    \\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int, int> m;\\n        m[0] = 1;\\n        \\n        int sum = 0, ans = 0;\\n        for(int i=0; i < nums.size(); ++i) {\\n            sum += nums[i];\\n            \\n            // in cpp, mod gives negative value (unlike Python)\\n            // i.e in Python -2 % 3 = 1, in c++: -2 % 3 = -2\\n            int target = sum % k;\\n            if(target < 0)\\n                target += k;\\n            \\n            if(m.count(target) != 0) {\\n                ans += m[target];\\n                m[target] += 1;\\n            } else\\n                m[target] = 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234104,
                "title": "python-sol-with-detailed-explanation",
                "content": "\\n\\t\\t\\n\\t\\t# the logic is pretty simple and similar to subarray sum equal to k\\n        # we keep doing the cumalative sum and if the sum divided by k is in d\\n        # then it is sure that we had an subarray which was divisble by k\\n        # so we will add the val of count with last val of that remainder \\n        \\n        \\n        d = {0:1}\\n        \\n        count = 0\\n        \\n        sums = 0\\n        for i in range(len(A)):\\n            sums+=A[i]\\n            \\n            if sums%K in d:\\n                count+= d[sums%K]\\n                \\n                d[sums%K]+=1\\n                \\n            else:\\n                d[sums%K]=1\\n\\n        return count\\n\\t\\t\\n**If you like it please upvote**\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n\\t\\t\\n\\t\\t# the logic is pretty simple and similar to subarray sum equal to k\\n        # we keep doing the cumalative sum and if the sum divided by k is in d\\n        # then it is sure that we had an subarray which was divisble by k\\n        # so we will add the val of count with last val of that remainder \\n        \\n        \\n        d = {0:1}\\n        \\n        count = 0\\n        \\n        sums = 0\\n        for i in range(len(A)):\\n            sums+=A[i]\\n            \\n            if sums%K in d:\\n                count+= d[sums%K]\\n                \\n                d[sums%K]+=1\\n                \\n            else:\\n                d[sums%K]=1\\n\\n        return count\\n\\t\\t\\n**If you like it please upvote**\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1204321,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        map<int,int>m;\\n        \\n        int prefix=0,ans=0;m[0]=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n                   prefix=(prefix+nums[i]%k +k) %k;\\n            ans+=(m[prefix]);\\n            m[prefix]++;\\n             \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        map<int,int>m;\\n        \\n        int prefix=0,ans=0;m[0]=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n                   prefix=(prefix+nums[i]%k +k) %k;\\n            ans+=(m[prefix]);\\n            m[prefix]++;\\n             \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1018049,
                "title": "c-99-99-faster-code-with-video-link",
                "content": "Plz upvote if you get this question .\\n\\nhttps://www.youtube.com/watch?v=ufXxc8Vty9A\\n\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int sum=0;\\n        int ans=0;\\n        unordered_map<int,int> umap;\\n        umap[0]=1;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            int remainder=sum%k;\\n            if(remainder<0)remainder=remainder+k;\\n            if(umap.find(remainder)==umap.end())umap[remainder]++;\\n            else{ans+=umap[remainder];umap[remainder]++;}\\n        }\\n        \\n        return ans;\\n        }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Function"
                ],
                "code": "class Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int sum=0;\\n        int ans=0;\\n        unordered_map<int,int> umap;\\n        umap[0]=1;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            int remainder=sum%k;\\n            if(remainder<0)remainder=remainder+k;\\n            if(umap.find(remainder)==umap.end())umap[remainder]++;\\n            else{ans+=umap[remainder];umap[remainder]++;}",
                "codeTag": "Java"
            },
            {
                "id": 1011028,
                "title": "simple-java-solution-using-hashmap-with-video-explaination",
                "content": "https://www.youtube.com/watch?v=QM0klnvTQzk\\n\\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] A, int K) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int sum = 0;\\n        map.put(0,1);\\n        int rem = 0;\\n        int ans = 0;\\n        for(int i = 0; i<A.length;i++){\\n            sum += A[i];\\n            \\n            rem = sum % K;\\n            if(rem < 0) {\\n                rem = rem +K;\\n            }\\n            if(!map.containsKey(rem)) {\\n                map.put(rem, 1);\\n            }\\n            else {\\n                ans += map.get(rem);\\n                 map.put(rem, map.get(rem)+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] A, int K) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int sum = 0;\\n        map.put(0,1);\\n        int rem = 0;\\n        int ans = 0;\\n        for(int i = 0; i<A.length;i++){\\n            sum += A[i];\\n            \\n            rem = sum % K;\\n            if(rem < 0) {\\n                rem = rem +K;\\n            }\\n            if(!map.containsKey(rem)) {\\n                map.put(rem, 1);\\n            }\\n            else {\\n                ans += map.get(rem);\\n                 map.put(rem, map.get(rem)+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961135,
                "title": "javascript-solution-with-detailed-explanation-that-beats-96",
                "content": "Let there be a subarray (i, j) whose sum is divisible by k\\n  sum(i, j) = sum(0, j) - sum(0, i-1)\\nSum for any subarray can be written as q*k + rem where q \\nis a quotient and rem is remainder\\nThus,     \\n    sum(i, j) = (q1 * k + rem1) - (q2 * k + rem2)\\n    sum(i, j) = (q1 - q2)k + rem1-rem2\\n     \\nWe see, for sum(i, j) i.e. for sum of any subarray to be\\ndivisible by k, the RHS should also be divisible by k.\\n(q1 - q2)k is obviously divisible by k, for (rem1-rem2) to \\nfollow the same, rem1 = rem2 where\\n    rem1 = Sum of subarray (0, j) % k\\n    rem2 = Sum of subarray (0, i-1) % k \\n\\nSo if any sub-array sum from index i\\u2019th to j\\u2019th is divisible by k then we can saya[0]+\\u2026a[i-1] (mod k) = a[0]+\\u2026+a[j] (mod k)\\n\\nThe above explanation is provided by Ekta Goel.\\n\\nSo we need to find such a pair of indices (i, j) that they satisfy the above condition. Here is the algorithm :\\n\\n    Make an auxiliary array of size k as Mod[k] . This array holds the count of each remainder we are getting after dividing cumulative sum till any index in arr[].\\n    Now start calculating cumulative sum and simultaneously take it\\u2019s mod with K, whichever remainder we get increment count by 1 for remainder as index in Mod[] auxiliary array. Sub-array by each pair of positions with same value of ( cumSum % k) constitute a continuous range whose sum is divisible by K.\\n    Now traverse Mod[] auxiliary array, for any Mod[i] > 1 we can choose any two pair of indices for sub-array by (Mod[i]*(Mod[i] \\u2013 1))/2 number of ways . Do the same for all remainders < k and sum up the result that will be the number all possi\\n\\n    ble sub-arrays divisible by K.\\n\\n```\\nvar subarraysDivByK = function (A, K) {\\n    // create auxiliary hash array to count frequency \\n    // of remainders \\n    let mod = new Array(K),cumSum = 0,result=0;\\n    mod.fill(0);\\n        // Traverse original array and compute cumulative \\n    // sum take remainder of this current cumulative \\n    // sum and increase count by 1 for this remainder \\n    // in mod[] array \\n    for (let i = 0; i < A.length; i++) {\\n        cumSum += A[i];\\n        // as the sum can be negative, taking modulo twice \\n        mod[((cumSum % K) + K) % K]++; \\n    }\\n        // Traverse mod[] \\n    for (let i = 0; i < K; i++) \\n        // If there are more than one prefix subarrays \\n        // with a particular mod value. \\n        if (mod[i] > 1) result += (mod[i] * (mod[i] - 1)) / 2; \\n        \\n    // add the elements which are divisible by k itself \\n    // i.e., the elements whose sum = 0 \\n    result += mod[0]; \\n    return result; \\n    };\\n\\t",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Let there be a subarray (i, j) whose sum is divisible by k\\n  sum(i, j) = sum(0, j) - sum(0, i-1)\\nSum for any subarray can be written as q*k + rem where q \\nis a quotient and rem is remainder\\nThus,     \\n    sum(i, j) = (q1 * k + rem1) - (q2 * k + rem2)\\n    sum(i, j) = (q1 - q2)k + rem1-rem2\\n     \\nWe see, for sum(i, j) i.e. for sum of any subarray to be\\ndivisible by k, the RHS should also be divisible by k.\\n(q1 - q2)k is obviously divisible by k, for (rem1-rem2) to \\nfollow the same, rem1 = rem2 where\\n    rem1 = Sum of subarray (0, j) % k\\n    rem2 = Sum of subarray (0, i-1) % k \\n\\nSo if any sub-array sum from index i\\u2019th to j\\u2019th is divisible by k then we can saya[0]+\\u2026a[i-1] (mod k) = a[0]+\\u2026+a[j] (mod k)\\n\\nThe above explanation is provided by Ekta Goel.\\n\\nSo we need to find such a pair of indices (i, j) that they satisfy the above condition. Here is the algorithm :\\n\\n    Make an auxiliary array of size k as Mod[k] . This array holds the count of each remainder we are getting after dividing cumulative sum till any index in arr[].\\n    Now start calculating cumulative sum and simultaneously take it\\u2019s mod with K, whichever remainder we get increment count by 1 for remainder as index in Mod[] auxiliary array. Sub-array by each pair of positions with same value of ( cumSum % k) constitute a continuous range whose sum is divisible by K.\\n    Now traverse Mod[] auxiliary array, for any Mod[i] > 1 we can choose any two pair of indices for sub-array by (Mod[i]*(Mod[i] \\u2013 1))/2 number of ways . Do the same for all remainders < k and sum up the result that will be the number all possi\\n\\n    ble sub-arrays divisible by K.\\n\\n```\\nvar subarraysDivByK = function (A, K) {\\n    // create auxiliary hash array to count frequency \\n    // of remainders \\n    let mod = new Array(K),cumSum = 0,result=0;\\n    mod.fill(0);\\n        // Traverse original array and compute cumulative \\n    // sum take remainder of this current cumulative \\n    // sum and increase count by 1 for this remainder \\n    // in mod[] array \\n    for (let i = 0; i < A.length; i++) {\\n        cumSum += A[i];\\n        // as the sum can be negative, taking modulo twice \\n        mod[((cumSum % K) + K) % K]++; \\n    }\\n        // Traverse mod[] \\n    for (let i = 0; i < K; i++) \\n        // If there are more than one prefix subarrays \\n        // with a particular mod value. \\n        if (mod[i] > 1) result += (mod[i] * (mod[i] - 1)) / 2; \\n        \\n    // add the elements which are divisible by k itself \\n    // i.e., the elements whose sum = 0 \\n    result += mod[0]; \\n    return result; \\n    };\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 909563,
                "title": "java-hashmap-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int subarraysDivByK(int[] A, int k) {\\n        \\n        int ans=0;\\n        int sum=0;\\n        int rem=0;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        hm.put(0,1);\\n        \\n        for(int i=0;i<A.length;i++)\\n        {\\n            sum+=A[i];\\n            rem=sum%k;\\n            \\n            if(rem<0)\\n            {\\n                rem+=k;\\n            }\\n            \\n            if(hm.containsKey(rem))\\n            {\\n                ans+=hm.get(rem);\\n                hm.put(rem,hm.get(rem)+1);\\n            }\\n            else\\n            {\\n                hm.put(rem,1);\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public int subarraysDivByK(int[] A, int k) {\\n        \\n        int ans=0;\\n        int sum=0;\\n        int rem=0;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        hm.put(0,1);\\n        \\n        for(int i=0;i<A.length;i++)\\n        {\\n            sum+=A[i];\\n            rem=sum%k;\\n            \\n            if(rem<0)\\n            {\\n                rem+=k;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 868484,
                "title": "prefixsum",
                "content": "```\\nclass Solution {\\n    \\n    //time O(n)\\n    public int subarraysDivByK(int[] a, int k) {\\n\\n        if (a==null|| a.length==0) return 0;\\n    \\n        //1.\\n        //in order to reduce time complexity, \\n        //instead of directly getting subarraySum,\\n        //we can leverage prefixSum, \\n        //since, subarraySum(a,b) = prefixSum(b) - prefixSum(a-1)\\n        \\n        //2.\\n        //get the mod-value frequency for all of the prefixSums.\\n        int[] mod = new int[k];\\n        int prefixSum =0;\\n        for(int i =0;i<a.length;i++) {\\n            prefixSum += a[i];\\n            int j = prefixSum%k; \\n            if (j<0) j=j+k; //when prefixSum is negative\\n            mod[j]++; \\n        }\\n\\n        //3. \\n        //the number of cases where you pick 2 out of n.-> nC2 = n(n-1)/2\\n        //mods for corresonding prefixsums will be cancelled out\\n        int cnt=0;\\n        for(int i=0;i<k;i++) {\\n            int n = mod[i];\\n            cnt+= n*(n-1)/2; \\n        }\\n        \\n        //4. \\n        //the case where you pick 1,\\n        //where subarraya are from the element 0.\\n        cnt+= mod[0];\\n        return cnt;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    //time O(n)\\n    public int subarraysDivByK(int[] a, int k) {\\n\\n        if (a==null|| a.length==0) return 0;\\n    \\n        //1.\\n        //in order to reduce time complexity, \\n        //instead of directly getting subarraySum,\\n        //we can leverage prefixSum, \\n        //since, subarraySum(a,b) = prefixSum(b) - prefixSum(a-1)\\n        \\n        //2.\\n        //get the mod-value frequency for all of the prefixSums.\\n        int[] mod = new int[k];\\n        int prefixSum =0;\\n        for(int i =0;i<a.length;i++) {\\n            prefixSum += a[i];\\n            int j = prefixSum%k; \\n            if (j<0) j=j+k; //when prefixSum is negative\\n            mod[j]++; \\n        }\\n\\n        //3. \\n        //the number of cases where you pick 2 out of n.-> nC2 = n(n-1)/2\\n        //mods for corresonding prefixsums will be cancelled out\\n        int cnt=0;\\n        for(int i=0;i<k;i++) {\\n            int n = mod[i];\\n            cnt+= n*(n-1)/2; \\n        }\\n        \\n        //4. \\n        //the case where you pick 1,\\n        //where subarraya are from the element 0.\\n        cnt+= mod[0];\\n        return cnt;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372786,
                "title": "easy-peasy-python-solution-with-comments-o-n-clean-solution",
                "content": "\\tdef subarraysDivByK(self, A: List[int], K: int) -> int:\\n        res, mp, prefix_sm = 0, {}, 0\\n        # means, I can find zero sum in map\\n        # this is need when I getting a continuing sum of K and I want to see if I can find 0 in mp\\n        mp[0] = 1 \\n        for i in range(len(A)):\\n            prefix_sm += A[i]\\n            needed = prefix_sm % K\\n            if needed in mp:\\n                # assume I get value(sm) 14 and K = 5, then I will check whether in the past\\n                # I can find 4 and also how many times(mp[needed]).\\n                res += mp[needed]\\n                mp[needed] += 1\\n            else:\\n                mp[needed] = 1\\n        return res",
                "solutionTags": [
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "\\tdef subarraysDivByK(self, A: List[int], K: int) -> int:\\n        res, mp, prefix_sm = 0, {}, 0\\n        # means, I can find zero sum in map\\n        # this is need when I getting a continuing sum of K and I want to see if I can find 0 in mp\\n        mp[0] = 1 \\n        for i in range(len(A)):\\n            prefix_sm += A[i]\\n            needed = prefix_sm % K\\n            if needed in mp:\\n                # assume I get value(sm) 14 and K = 5, then I will check whether in the past\\n                # I can find 4 and also how many times(mp[needed]).\\n                res += mp[needed]\\n                mp[needed] += 1\\n            else:\\n                mp[needed] = 1\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 256639,
                "title": "python-7-line-o-n-solution",
                "content": "we can use \\'sum\\' as the sum of the numbers we have traversed, and we store the sum % K in a counter called \\'dic\\'. when we arrive at index i and get current sum % K, once there has already been sum % K in dic, then the sum from the index we stored it in advance to index i should be the multiple of K\\n```python\\nclass Solution:\\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\\n        dic = collections.Counter()\\n        dic[0], res, sum = 1, 0, 0\\n        for a in A:\\n            sum += a\\n            res += dic[sum % K]\\n            dic[sum % K] += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\\n        dic = collections.Counter()\\n        dic[0], res, sum = 1, 0, 0\\n        for a in A:\\n            sum += a\\n            res += dic[sum % K]\\n            dic[sum % K] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 217982,
                "title": "java-11ms-9-liner-prefix-sum-without-hashmap-time-o-n",
                "content": "1. First calculate the number of prefix sums that can be divided by K;\\n2. Then calculate the number of non-prefix sums that can be divided by K, \\ne,g, if there are 3 preSums, all % K == 1, \\na.) sum1 = [a1], we have 0 non-preSum can be divided by K;\\nb.) sum 3 = [a1, a2, a3], accordingly we have 1 non-preSum, sum3 - sum1 = [a2, a3],  can be divided by K;\\nc.) sum5 = [a1, a2, a3, a4, a5], we have 2 non-preSums,  that is , sum5 - sum1 = [a2, a3, a4, a5] and sum5 - sum3 = [a4, a5], can be divided by K. \\nTherefore, we have 0 + 1 + 2 = 3 `non-preSums` counted in the solution;\\n\\n**Analysis:**\\n\\n**Time: O(n), space: O(K).**\\n\\n```\\n    public int subarraysDivByK(int[] A, int K) {\\n        int[] sameMod = new int[K]; // count the number of the prefix sums with same remainder against modouls K.\\n        int sum = 0, ans = 0;\\n        for (int a : A) {\\n            sum += a; // prefix sum.\\n            int r = (sum % K + K) % K;  // remainder;\\n            if (r == 0) ++ans; // If the prefix sum can be divided by K.\\n            ans += sameMod[r]++; // The prefix sum share same remainder with already found sameMode[r] ones.\\n        }\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int subarraysDivByK(int[] A, int K) {\\n        int[] sameMod = new int[K]; // count the number of the prefix sums with same remainder against modouls K.\\n        int sum = 0, ans = 0;\\n        for (int a : A) {\\n            sum += a; // prefix sum.\\n            int r = (sum % K + K) % K;  // remainder;\\n            if (r == 0) ++ans; // If the prefix sum can be divided by K.\\n            ans += sameMod[r]++; // The prefix sum share same remainder with already found sameMode[r] ones.\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3075336,
                "title": "c-using-hashmap-t-c-o-n-s-c-o-k",
                "content": "```\\nclass Solution {\\n\\n\\t/*\\n\\t\\tTime Complexity : O(N)\\n\\t\\tSpace Complexity : O(K),  as atmost all the remainders would be less than K\\n\\t*/\\n\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int, int> rem_count;\\n        rem_count[0] = 1;\\n        \\n        int ans = 0, currSum = 0;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            currSum += nums[i];\\n            \\n            int rem = currSum %k;\\n            if(rem<0) rem += k;\\n            \\n            if(rem_count.find(rem) != rem_count.end()){\\n                ans += rem_count[rem];\\n            }\\n            \\n            rem_count[rem]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n\\t/*\\n\\t\\tTime Complexity : O(N)\\n\\t\\tSpace Complexity : O(K),  as atmost all the remainders would be less than K\\n\\t*/\\n\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int, int> rem_count;\\n        rem_count[0] = 1;\\n        \\n        int ans = 0, currSum = 0;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            currSum += nums[i];\\n            \\n            int rem = currSum %k;\\n            if(rem<0) rem += k;\\n            \\n            if(rem_count.find(rem) != rem_count.end()){\\n                ans += rem_count[rem];\\n            }\\n            \\n            rem_count[rem]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074673,
                "title": "java-prefix-sum-o-n-time-beats-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCompute the prefix sum for each element in the array. For each prefix sum value, if we divide it by k and compute the remainder, then we can conclude that a given sub array is divisible by k if the modulo value for the prefix sums at the beginning and ending index of the sub array have the same value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Iterate over the `nums` array and keep a running sum count of the sum of all the elements so far. The sum at each index is the prefix sum for that index.\\n2. Divide each prefix sum by k and compute the remainder. If this value is negative, add k to it to change it to positive.\\n3. For each element of the input array we check if the current remainder value has been encountered before, and if so, how many times. We add that count to our total count of sub arrays divisible by k.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int subarraysDivByK(int[] nums, int k) {\\n    int prefixSum = 0;\\n    int ans = 0;\\n    int[] modulo = new int[k];\\n\\n    for (int i=0; i < nums.length; i++) {\\n      prefixSum += nums[i];\\n      int key = prefixSum % k;\\n\\n      // If the key is negative, add k to it to convert it to positive.\\n      key += key >= 0 ? 0 : k;\\n      \\n      ans += modulo[key];\\n\\n      // key = 0 means that the currrent element by itself is divisible by k.\\n      // We handle this special case of a single element sub array by checking for this condition separately.\\n      ans += key == 0 ? 1 : 0;\\n      modulo[key]++;\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n  public int subarraysDivByK(int[] nums, int k) {\\n    int prefixSum = 0;\\n    int ans = 0;\\n    int[] modulo = new int[k];\\n\\n    for (int i=0; i < nums.length; i++) {\\n      prefixSum += nums[i];\\n      int key = prefixSum % k;\\n\\n      // If the key is negative, add k to it to convert it to positive.\\n      key += key >= 0 ? 0 : k;\\n      \\n      ans += modulo[key];\\n\\n      // key = 0 means that the currrent element by itself is divisible by k.\\n      // We handle this special case of a single element sub array by checking for this condition separately.\\n      ans += key == 0 ? 1 : 0;\\n      modulo[key]++;\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073716,
                "title": "c-simple-prefix",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> pre(k);\\n        pre[0]=1;\\n        int ans=0,sum=0;\\n        for(int x : nums){\\n             sum =(sum + x%k +k) %k;\\n             ans += pre[sum];\\n             pre[sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> pre(k);\\n        pre[0]=1;\\n        int ans=0,sum=0;\\n        for(int x : nums){\\n             sum =(sum + x%k +k) %k;\\n             ans += pre[sum];\\n             pre[sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073232,
                "title": "100-0-ms-faster-one-pass",
                "content": "\\n# UPVOTE PLS\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n    int subarraysDivByK(vector<int>& nums, int k,int pre=0,int re=0) {\\n        vector<int> map(k,0);\\n        map[0]=1;\\n        for(int i: nums){\\n            pre=(pre+i%k+k)%k;\\n            re+=map[pre]++;\\n        }return re;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    int subarraysDivByK(vector<int>& nums, int k,int pre=0,int re=0) {\\n        vector<int> map(k,0);\\n        map[0]=1;\\n        for(int i: nums){\\n            pre=(pre+i%k+k)%k;\\n            re+=map[pre]++;\\n        }return re;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3073160,
                "title": "prefix-sum-o-n-solution-c",
                "content": "The problem is based on the concept of using prefix sums to compute the total number of subarrays that are divisible by `k`.\\n\\nThe sum of the subarray `i + 1` to `j` (inclusive) is computed by `prefixSum[j] - prefixSum[i]`.our task is to determine the number of pairs `(i, j)` where `i < j` and `prefixSum[j] - prefix[i]) % k = 0`i.e `prefixSum[i] % k = prefixSum[j] % k`.\\n\\nNow if remainder for `prefixSum[i] % k` is `R1` and remainder for `prefixSum[j] % k` is `R2` then subarray from `i+1` to `j` is divisible by `k` if `R1=R2`.Since while subtracting `prefixSum`, both remainder will got subtracted and the sum value remains for that subarray becomes divisible by k.\\n\\n`ans` : ***for storing result value.***\\n`m` : ***map for storing remainder and it\\'s frequency***.\\n`preSum`: ***current prefix sum.***\\n\\n# Algorithm \\n1. Iterate over all elements in `num` array.\\n2. For each index `i`, compute the current prefix sum and `(preSum%k+k)%k`*(why? see note below)*.\\n3. Add the number of subarrays encountered till now that have the same remainder to the result `ans`.\\n4. In the end, we include the remainder of the subarray in the the map `m` for future matches.\\n\\n**NOTE:** If subarray sum value becomes negative then modulus return a negative remainder. Hence to make remainder positive by `(prefixSum%k+k)%k`.\\n# Complexity\\n- Time complexity: O($$n$$)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) \\n    {\\n        int ans = 0,preSum = 0;\\n        unordered_map<int,int> m;\\n        m[0]++;  \\n        //  0 remainder added in map so as \\n        //  if any preSum if divisible by k then \\n        //  it must be added to the result variable ans.\\n        for(auto &x:nums)\\n        {\\n            preSum += x;\\n            if(m.find((preSum%k+k)%k) != m.end())\\n                ans += m[(preSum%k+k)%k];\\n            m[(preSum%k+k)%k]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) \\n    {\\n        int ans = 0,preSum = 0;\\n        unordered_map<int,int> m;\\n        m[0]++;  \\n        //  0 remainder added in map so as \\n        //  if any preSum if divisible by k then \\n        //  it must be added to the result variable ans.\\n        for(auto &x:nums)\\n        {\\n            preSum += x;\\n            if(m.find((preSum%k+k)%k) != m.end())\\n                ans += m[(preSum%k+k)%k];\\n            m[(preSum%k+k)%k]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072861,
                "title": "javascript-3-solutions-brute-force-optimal-approach",
                "content": "\\n**Approach #1: Naive Brute Force**\\n\\n```\\n// Time complexity: O(n^3)\\n// Space complexity: O(1)\\n\\nconst subarraysDivByK = function(nums, k) {\\n\\tconst n = nums.length;\\n\\tlet count = 0;\\n\\t\\n\\tfor (let i = 0; i < n; i++) {\\n\\t\\tfor (let j = i; j < n; j++) {\\n\\t\\t\\tlet sum = 0;\\n\\t\\t\\t\\n\\t\\t\\tfor (let index = i; index <= j; index++) \\n\\t\\t\\t\\tsum += nums[index];\\n\\t\\t\\t\\n\\t\\t\\tif (sum % k === 0)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn count;\\n};\\n```\\n\\n**Approach #2: Optimized Brute Force**\\n\\n```\\n// Time complexity: O(n^2)\\n// Space complexity: O(1)\\n\\nconst subarraysDivByK = function(nums, k) {\\n\\tconst n = nums.length;\\n\\tlet count = 0;\\n\\t\\n\\tfor (let i = 0; i < n; i++) {\\n\\t\\tlet prefixSum = 0;\\n\\t\\t\\n\\t\\tfor (let j = i; j < n; j++) {\\n\\t\\t\\tprefixSum += nums[j];\\n\\t\\t\\t\\n\\t\\t\\tif (prefixSum % k === 0)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn count;\\n};\\n```\\n\\n**Approach #3: Prefix Sums and Counting**\\n\\n```\\n// Time complexity: O(n)\\n// Space complexity: O(k)\\n\\nconst subarraysDivByK = function(nums, k) {\\n\\tlet count = 0, sum = 0;\\n\\t\\n\\tconst freq = new Array(k).fill(0);\\n\\tfreq[0] = 1;\\n\\t\\n\\tfor (const n of nums) {\\n\\t\\tsum = (sum + n) % k;\\n\\t   \\n\\t\\tif (sum < 0)\\n\\t\\t\\tsum += k;\\n\\t\\t\\n\\t\\tcount += freq[sum];\\n\\t\\tfreq[sum]++;\\n\\t}\\n\\t\\n\\treturn count;\\n};\\n```\\n\\n**Please upvote if you find these solutions useful. Happy Coding!**",
                "solutionTags": [
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```\\n// Time complexity: O(n^3)\\n// Space complexity: O(1)\\n\\nconst subarraysDivByK = function(nums, k) {\\n\\tconst n = nums.length;\\n\\tlet count = 0;\\n\\t\\n\\tfor (let i = 0; i < n; i++) {\\n\\t\\tfor (let j = i; j < n; j++) {\\n\\t\\t\\tlet sum = 0;\\n\\t\\t\\t\\n\\t\\t\\tfor (let index = i; index <= j; index++) \\n\\t\\t\\t\\tsum += nums[index];\\n\\t\\t\\t\\n\\t\\t\\tif (sum % k === 0)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn count;\\n};\\n```\n```\\n// Time complexity: O(n^2)\\n// Space complexity: O(1)\\n\\nconst subarraysDivByK = function(nums, k) {\\n\\tconst n = nums.length;\\n\\tlet count = 0;\\n\\t\\n\\tfor (let i = 0; i < n; i++) {\\n\\t\\tlet prefixSum = 0;\\n\\t\\t\\n\\t\\tfor (let j = i; j < n; j++) {\\n\\t\\t\\tprefixSum += nums[j];\\n\\t\\t\\t\\n\\t\\t\\tif (prefixSum % k === 0)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn count;\\n};\\n```\n```\\n// Time complexity: O(n)\\n// Space complexity: O(k)\\n\\nconst subarraysDivByK = function(nums, k) {\\n\\tlet count = 0, sum = 0;\\n\\t\\n\\tconst freq = new Array(k).fill(0);\\n\\tfreq[0] = 1;\\n\\t\\n\\tfor (const n of nums) {\\n\\t\\tsum = (sum + n) % k;\\n\\t   \\n\\t\\tif (sum < 0)\\n\\t\\t\\tsum += k;\\n\\t\\t\\n\\t\\tcount += freq[sum];\\n\\t\\tfreq[sum]++;\\n\\t}\\n\\t\\n\\treturn count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3072495,
                "title": "easy-to-understand-not-using-map-prefix-sum-c-less-line-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n/*let take an example\\nnums = [4,-2,-3,-4] k=5;*/\\n# Code\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& v, int k) {\\n        int p=0;//prefix sum\\n        int n=v.size();\\n        vector<int> cp(k);\\n        cp[p]++; //0 is divisble by k increase it frequency ;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            p=(p+v[i])%k;\\nif(p<0) p+=k;  /* at i=2 p became -ve meane abs(p)  more required for divisible k so my current sum is p+=*/\\nans+=cp[p];  //if any number p repeat means their must k in between them so store the frequency in ans;\\n            cp[p]++;\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& v, int k) {\\n        int p=0;//prefix sum\\n        int n=v.size();\\n        vector<int> cp(k);\\n        cp[p]++; //0 is divisble by k increase it frequency ;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            p=(p+v[i])%k;\\nif(p<0) p+=k;  /* at i=2 p became -ve meane abs(p)  more required for divisible k so my current sum is p+=*/\\nans+=cp[p];  //if any number p repeat means their must k in between them so store the frequency in ans;\\n            cp[p]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3072434,
                "title": "easy-to-understand-prefixsum-hashmap-binary-search",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeKotlin/src/main/kotlin/leetcode/medium/array/prefixsum/SubarraySumEqualModuloK.kt",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3072188,
                "title": "easy-c-solution-commented-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        // getting prefix sum\\n        int psum = 0;\\n        int res = 0;\\n\\n        // hash map to store the frequency of the prefix sum such that when we encounter it again, \\n        // we know the number of subarrays that can be trimmed from the current subarray such that the sum is divisible by k\\n        unordered_map<int,int> hash;\\n        hash[0] = 1;\\n\\n        int n = nums.size();\\n\\n        for (int i = 0 ; i < n; i++) {\\n            // getting the prefix sum\\n            psum += nums[i];\\n\\n            // getting the modded value\\n            int modded = psum % k;\\n\\n            // if the modded value is negative, we add k to it to make it positive\\n            if (modded < 0) modded += k;\\n\\n            // if the modded value is already present in the hash map, \\n            // we add the frequency of the modded value to the result since it is the number of ways \\n            // we can trim the current subarray such that the sum is divisible by k\\n            res += hash[modded];\\n\\n            // we increment the frequency of the modded value in the hash map\\n            hash[modded]++;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        // getting prefix sum\\n        int psum = 0;\\n        int res = 0;\\n\\n        // hash map to store the frequency of the prefix sum such that when we encounter it again, \\n        // we know the number of subarrays that can be trimmed from the current subarray such that the sum is divisible by k\\n        unordered_map<int,int> hash;\\n        hash[0] = 1;\\n\\n        int n = nums.size();\\n\\n        for (int i = 0 ; i < n; i++) {\\n            // getting the prefix sum\\n            psum += nums[i];\\n\\n            // getting the modded value\\n            int modded = psum % k;\\n\\n            // if the modded value is negative, we add k to it to make it positive\\n            if (modded < 0) modded += k;\\n\\n            // if the modded value is already present in the hash map, \\n            // we add the frequency of the modded value to the result since it is the number of ways \\n            // we can trim the current subarray such that the sum is divisible by k\\n            res += hash[modded];\\n\\n            // we increment the frequency of the modded value in the hash map\\n            hash[modded]++;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072124,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N + K)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(K)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        mp[0] = 1;\\n        int ans = 0, sum = 0;\\n        for(auto x : nums) {\\n            sum = ((sum + x) % k + k) % k;\\n            if(mp[sum]) ans += mp[sum];\\n            mp[sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        mp[0] = 1;\\n        int ans = 0, sum = 0;\\n        for(auto x : nums) {\\n            sum = ((sum + x) % k + k) % k;\\n            if(mp[sum]) ans += mp[sum];\\n            mp[sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071860,
                "title": "c-java-easy-solution-clean-o-n-number-theory-prefix-sums",
                "content": "\\n\\n\\n# Approach\\nI am already going to assume that you know about prefix sums before you read this.\\nWe can all agree that for an array int[] A, where N = len(A), that there are N prefix sums.\\nprefix[0] = A[0], prefix[1] = A[0] + A[1], ... prefix[i] = A[0] + ... + A[i].\\n\\nThen to calculate how many subarrays are divisible by K is logically equivalent to saying, how many ways can we pair up all prefix sum pairs (i,j) where i < j\\nsuch that (prefix[j] - prefix[i]) % K == 0.\\n\\nJust from that information alone we easily get a O(n^2) solution.\\nCompute all prefix sums, then check all pair to see if k divides the difference between them.\\n\\nHowever, if we just exploit some information w.r.t to the remainder of each prefix sum we can manipulate this into a linear algorithm. Here\\'s how.\\n\\nNumber Theory Part\\nI noted above that we need to find all prefix sum pairs (i,j) such tha (`p[j] - p[i]`) % `K == 0`.\\nBut this is only true, if and only if p`[j] % K == p[i] % K`\\nWhy is this?\\n\\nAccording the the division algorithm we can express p[j] and p[i] in the following way.\\n`p[j] = bK + r0` where `0 <= r0 < K`\\n`p[i] = aK + r1` where `0<= r1 < K`\\n\\nThen `p[j] - p[i]` = (b*K + r0) - (a*K + r1)\\n= `b*K - a*K + r0 - r1 = K*(b-a) + r0 - r1`\\nAgain: `p[j] - p[i]` = `K*(b-a) + (r0-r1)`, in other words\\nK only divides `p[j] - p[i]` iff `r0-r1 = 0 <-> r0 = r1 `QED\\n\\nBut we should not forget about elements in the array that do not need a pairing, namely those that are are divisible by K. That\\'s why I add mod[0] at the end.\\n\\nAlso counting pairs => N choose 2 = >` n*(n-1) / 2`.\\n![image.png](https://assets.leetcode.com/users/images/2df8d01f-0a55-4b4a-b188-9c31a1ad5931_1674115996.4609025.png)\\n\\n# Code\\n\\n```Java []\\nclass Solution {\\n    public int subarraysDivByK(int[] A, int K) {\\n        //There K mod groups 0...K-1\\n        //For each prefix sum that does not have remainder 0 it needs to be paired with 1 with the same remainder\\n        //this is so the remainders cancel out.\\n        int N = A.length;\\n        int[] modGroups = new int[K];\\n        int sum = 0;\\n        for (int i = 0; i < N; i++){\\n            sum += A[i];\\n            int group = sum % K;\\n            \\n            if (group < 0) group += K; //Java has negative modulus so correct it\\n            modGroups[group]++;\\n        }\\n        \\n        int total = 0;\\n        for (int x : modGroups){\\n             if (x > 1) total += (x*(x-1)) / 2;\\n        }\\n        //Dont forget all numbers that divide K\\n        return total + modGroups[0];\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    //This function return the mod of negative and positive integer with k;\\n    //In c++ when we have neg number mod k then we get that negative number so \\n    //to make all the number positive and less than k we are taking mod with k.\\n    int negMod(int n,int mod){\\n        \\n        if(n<0){//if our number is negative \\n            n=abs(n)%mod;\\n            return (-n+mod)%mod;\\n        }\\n        //if our number is postive \\n        return n%mod;\\n    }\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        //now we are having two variables cur and ans in cur variable we are\\n        //storing the cur sum mod k\\n        //in ans we are storing the occurance of subarray which is divisible by k\\n        int cur=0,ans=0;\\n        unordered_map<int,int>m;\\n        //initially our cur sum is empty so we have make our map of 0 to increase to 1.\\n        m[0]++;\\n        \\n        for(int num:nums){\\n            \\n            cur=(cur+negMod(num,k))%k;//adding the mod value to cur\\n            \\n            if(m.count(cur)){//if we have cur number in the map so there must be an subarray \\n                //between them with sum =0\\n                ans+=m[cur];\\n                \\n            }\\n            //incrementing the cur value\\n            m[cur]++;\\n        }\\n        //return the ans\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes.\\nLet me know in comment if i can do better.\\nLets connect on [Linkedin](https://www.linkedin.com/in/kailas-rathod/)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int subarraysDivByK(int[] A, int K) {\\n        //There K mod groups 0...K-1\\n        //For each prefix sum that does not have remainder 0 it needs to be paired with 1 with the same remainder\\n        //this is so the remainders cancel out.\\n        int N = A.length;\\n        int[] modGroups = new int[K];\\n        int sum = 0;\\n        for (int i = 0; i < N; i++){\\n            sum += A[i];\\n            int group = sum % K;\\n            \\n            if (group < 0) group += K; //Java has negative modulus so correct it\\n            modGroups[group]++;\\n        }\\n        \\n        int total = 0;\\n        for (int x : modGroups){\\n             if (x > 1) total += (x*(x-1)) / 2;\\n        }\\n        //Dont forget all numbers that divide K\\n        return total + modGroups[0];\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    //This function return the mod of negative and positive integer with k;\\n    //In c++ when we have neg number mod k then we get that negative number so \\n    //to make all the number positive and less than k we are taking mod with k.\\n    int negMod(int n,int mod){\\n        \\n        if(n<0){//if our number is negative \\n            n=abs(n)%mod;\\n            return (-n+mod)%mod;\\n        }\\n        //if our number is postive \\n        return n%mod;\\n    }\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        //now we are having two variables cur and ans in cur variable we are\\n        //storing the cur sum mod k\\n        //in ans we are storing the occurance of subarray which is divisible by k\\n        int cur=0,ans=0;\\n        unordered_map<int,int>m;\\n        //initially our cur sum is empty so we have make our map of 0 to increase to 1.\\n        m[0]++;\\n        \\n        for(int num:nums){\\n            \\n            cur=(cur+negMod(num,k))%k;//adding the mod value to cur\\n            \\n            if(m.count(cur)){//if we have cur number in the map so there must be an subarray \\n                //between them with sum =0\\n                ans+=m[cur];\\n                \\n            }\\n            //incrementing the cur value\\n            m[cur]++;\\n        }\\n        //return the ans\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071772,
                "title": "simpe-logic-java-code-o-n-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMapping USnig\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n    int n = nums.length, res = 0, cummSum = 0;\\n        int map[] = new int[k];\\n        map[0] = 1;\\n        for(int num: nums) {\\n            cummSum += num % k;\\n            cummSum = (cummSum < 0)? (cummSum + k) % k: cummSum % k;\\n            res += map[cummSum]++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n    int n = nums.length, res = 0, cummSum = 0;\\n        int map[] = new int[k];\\n        map[0] = 1;\\n        for(int num: nums) {\\n            cummSum += num % k;\\n            cummSum = (cummSum < 0)? (cummSum + k) % k: cummSum % k;\\n            res += map[cummSum]++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071274,
                "title": "java-c-easiest-explanation-line-by-line-explanation",
                "content": "// Subarray Sums Divisible by K\\n# Algorithm\\n**Step 1**: Get cumulative sum \\n**Step 2**: fetch remainder\\n**Step 3**: Check if remainder is in HashMap\\n**Step 4**: Add the count of remainder from HashMap\\n**Step 5**: Return Count\\nIf remainder less than 0, add the divisor\\n\\n*Java*\\n```\\nclass Solution {\\n\\tpublic int subarraysDivByK(int[] nums, int k) {\\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\tmap.put(0, 1);\\n\\t\\tint count = 0;\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t\\tint remainder = sum % k;\\n\\t\\t\\tif (remainder < 0) remainder += k;\\n\\t\\t\\tif (map.containsKey(remainder)) {\\n\\t\\t\\t\\tcount += map.get(remainder);\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(remainder, map.getOrDefault(remainder, 0) + 1);\\n\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int> map;\\n        map[0]=1;\\n        int cumulative_sum=0;\\n        int count=0;\\n        for(int i=0; i<nums.size(); i++){\\n            cumulative_sum+=nums[i];\\n            int remainder = cumulative_sum%k;\\n            if(remainder<0) remainder+=k;\\n            if(map.count(remainder)){\\n                count+=map[remainder];\\n            }\\n            map[remainder]++;\\n        }\\n        return count;\\n    }\\n}; \\n``",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tpublic int subarraysDivByK(int[] nums, int k) {\\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\tmap.put(0, 1);\\n\\t\\tint count = 0;\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t\\tint remainder = sum % k;\\n\\t\\t\\tif (remainder < 0) remainder += k;\\n\\t\\t\\tif (map.containsKey(remainder)) {\\n\\t\\t\\t\\tcount += map.get(remainder);\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(remainder, map.getOrDefault(remainder, 0) + 1);\\n\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071233,
                "title": "less-intuitive-solution-but-good-algo-to-solve-this",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntution is same as that of the prefix sum only.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nyou traverse the complete array and on every index to calculate the sum and then take modulo of the sum at every index with number (k-which is given). and store its count in a map, now do this for every index and when you reach the remainder same as that you have stored in the map earlier, you ADD THE PREVIOUS COUNT TO THE ANS FIRST AND ADD THE COUNT CORRESPONDING TO THE NEW INDEX AFTER THAT.\\n\\nEDGE CASE HANDLING - if there are negative remainders , DONT MAP THEM DIRECTLY, you have to map them to a number corresponding to its positive side, which is calculated by addaing (k) tot he negative number and then doing similar operations on it as that of a positive remainder.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();//size of the nums array\\n        int sum = 0;\\n        int rem = 0;\\n        int ans = 0;//storing the final count\\n        unordered_map<int,int> map;\\n        map[rem] = 1;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sum += nums[i];//pehle sum me add kiya us index ko\\n            rem = sum % k;//fir uska modulo liya jo bhi k given hai.remainder nikala\\n            if(rem>=0)//agar remainder positive hai to bas..uska map me jo previous count pda hua hai usko add krna aur fir uska count ko badhana ,, pehle previous add fir new increase\\n            {\\n                if(map.count(rem)==1)\\n                {\\n                    ans+=map[rem];\\n                }\\n                map[rem]++;\\n            }\\n\\n            //agar negative remainder aajata hai to... usko uske corresponding positive side ke integer se map krke uska count badhao jo ki milega by adding +7 to the negative remainder.\\n            else\\n            {\\n                rem = rem + k;\\n                if(map.count(rem)==1)\\n                {\\n                    ans+=map[rem];\\n                }\\n                map[rem]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();//size of the nums array\\n        int sum = 0;\\n        int rem = 0;\\n        int ans = 0;//storing the final count\\n        unordered_map<int,int> map;\\n        map[rem] = 1;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sum += nums[i];//pehle sum me add kiya us index ko\\n            rem = sum % k;//fir uska modulo liya jo bhi k given hai.remainder nikala\\n            if(rem>=0)//agar remainder positive hai to bas..uska map me jo previous count pda hua hai usko add krna aur fir uska count ko badhana ,, pehle previous add fir new increase\\n            {\\n                if(map.count(rem)==1)\\n                {\\n                    ans+=map[rem];\\n                }\\n                map[rem]++;\\n            }\\n\\n            //agar negative remainder aajata hai to... usko uske corresponding positive side ke integer se map krke uska count badhao jo ki milega by adding +7 to the negative remainder.\\n            else\\n            {\\n                rem = rem + k;\\n                if(map.count(rem)==1)\\n                {\\n                    ans+=map[rem];\\n                }\\n                map[rem]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070998,
                "title": "prefix-sum-with-remainder-table",
                "content": "# Intuition & approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nthe basic idea to solve is to find each window which has sum divisible by k. To find such window we will maintain a map which will keep the track of the remainder and we will just check what is the frequency of remainder of current sum and that frequency is added to answer\\nin case of negative  remainder make it positive by adding k to it\\n\\n\\n\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n\\n        map<int,int> mp;\\n        int sum=0,ans=0;\\n        for(int i:nums){\\n            sum+=i;\\n            int temp=sum%k;\\n            \\n            if(temp<0)temp=k+temp;\\n            \\n            ans+=mp[temp];\\n            \\n            mp[temp]++;\\n            if(temp==0)ans++;\\n            \\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n\\n        map<int,int> mp;\\n        int sum=0,ans=0;\\n        for(int i:nums){\\n            sum+=i;\\n            int temp=sum%k;\\n            \\n            if(temp<0)temp=k+temp;\\n            \\n            ans+=mp[temp];\\n            \\n            mp[temp]++;\\n            if(temp==0)ans++;\\n            \\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070828,
                "title": "java-hashmap-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        Map<Integer,Integer> map=new HashMap<>();\\n        int sum=0;\\n        int res=0;\\n        for(int i:nums)\\n        {\\n            sum+=i;\\n            map.put(((sum%k)+k)%k,map.getOrDefault(((sum%k)+k)%k,0)+1);\\n        }\\n        for(int i:map.keySet())\\n        {\\n            int val=map.get(i);\\n            if(val>1)res+=((val*(val-1))/2);\\n        }\\n\\n        return res+(map.get(0)!=null?map.get(0):0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        Map<Integer,Integer> map=new HashMap<>();\\n        int sum=0;\\n        int res=0;\\n        for(int i:nums)\\n        {\\n            sum+=i;\\n            map.put(((sum%k)+k)%k,map.getOrDefault(((sum%k)+k)%k,0)+1);\\n        }\\n        for(int i:map.keySet())\\n        {\\n            int val=map.get(i);\\n            if(val>1)res+=((val*(val-1))/2);\\n        }\\n\\n        return res+(map.get(0)!=null?map.get(0):0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070728,
                "title": "java-c-prefix-sum-beats-98-approach-explained-hashtable",
                "content": "## Approach:\\n\\n* For each index i, count all prev prefix sums in the array which has modulo same as of curr prefix sum(at idx i) and add it to result.\\n`Use HashTable to store the counts of prefix sum modulo.`\\n* Also, for a `-ve number` num, `num%k<0`, we have to change it to `+ve mod` because modulo of a number can lie in the range of `0 to k-1` only.\\n\\nLet, num = -2, k=3 then `res=(-2)%3=-2`, for changing it to +ve mod add k to res.\\nChanging to +ve mod, `-2+3 = 1`, So, `res=(-2)%3=1`.\\n\\n![image.png](https://assets.leetcode.com/users/images/059599f6-1784-4eaa-861d-0cb9cbf57d72_1674096562.5566626.png)\\n\\n\\n## Complexity:\\n- Time complexity: O(n)\\n- Space complexity: O(k)\\n\\n## Code\\n``` java []\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        int[] freq = new int[k]; //mod value can only be in range of 0 to k-1\\n        freq[0]=1;\\n        int prefixSum=0, subArrays=0;\\n        for(int x:nums)\\n        {\\n            prefixSum+=x;\\n            int mod = prefixSum%k;\\n            //changing -ve mod to +ve mod because mod can only in the range of 0 to k-1\\n            if(mod<0){ \\n                mod+=k;\\n            }\\n            //adding the prev count of mod to subarrays and incrementing freq[mod] as well\\n            subArrays+=freq[mod]++; \\n        }\\n        return subArrays;\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        vector<int> freq(k); //mod value can only be in range of 0 to k-1\\n        freq[0]=1; \\n        int prefixSum=0, subArrays=0;\\n        for(auto x:nums)\\n        {\\n            prefixSum+=x;\\n            int mod = prefixSum%k;\\n            //changing -ve mod to +ve mod because mod can only in the range of 0 to k-1\\n            if(mod<0){ \\n                mod+=k;\\n            }\\n            //adding the prev count of mod to subarrays and incrementing freq[mod] as well\\n            subArrays+=freq[mod]++; \\n        }\\n        return subArrays;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        int[] freq = new int[k]; //mod value can only be in range of 0 to k-1\\n        freq[0]=1;\\n        int prefixSum=0, subArrays=0;\\n        for(int x:nums)\\n        {\\n            prefixSum+=x;\\n            int mod = prefixSum%k;\\n            //changing -ve mod to +ve mod because mod can only in the range of 0 to k-1\\n            if(mod<0){ \\n                mod+=k;\\n            }\\n            //adding the prev count of mod to subarrays and incrementing freq[mod] as well\\n            subArrays+=freq[mod]++; \\n        }\\n        return subArrays;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        vector<int> freq(k); //mod value can only be in range of 0 to k-1\\n        freq[0]=1; \\n        int prefixSum=0, subArrays=0;\\n        for(auto x:nums)\\n        {\\n            prefixSum+=x;\\n            int mod = prefixSum%k;\\n            //changing -ve mod to +ve mod because mod can only in the range of 0 to k-1\\n            if(mod<0){ \\n                mod+=k;\\n            }\\n            //adding the prev count of mod to subarrays and incrementing freq[mod] as well\\n            subArrays+=freq[mod]++; \\n        }\\n        return subArrays;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070673,
                "title": "javascript-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse a prefix sum modulo `k` to count the subarrays that sum `0` modulo `k`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate the array indices `i` from 0 to n-1 while adding a prefix sum modulo `k` and consider the following non-exclusive two cases.\\n1.- When the subarray from `0` to `i`, sums to zero then add one to the answer.\\n2.- When we can remove a previous subarray to make the sum ending at `i` zero. In this case use a map, or an array to count the previous subarray values. If you find one that has the same sum as the current, then that means you can subtract that other subarray from the current and make it sum to zero.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ from iterating the array once\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$ from storing k previous sums.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst subarraysDivByK = (nums, k)=>{\\n    const prevsums = Array(k).fill(0);\\n    const mod = (n, m)=> (n % m + m) % m;\\n    let ans = 0, prev = 0;\\n    for(const num of nums){\\n        prev = mod(prev + num, k)\\n        if(prev == 0) ans++;\\n        ans+=prevsums[prev];\\n        prevsums[prev]++;\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```\\nconst subarraysDivByK = (nums, k)=>{\\n    const prevsums = Array(k).fill(0);\\n    const mod = (n, m)=> (n % m + m) % m;\\n    let ans = 0, prev = 0;\\n    for(const num of nums){\\n        prev = mod(prev + num, k)\\n        if(prev == 0) ans++;\\n        ans+=prevsums[prev];\\n        prevsums[prev]++;\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3070670,
                "title": "java-using-prefix-sum-with-hasmap",
                "content": "#### **\\uD83D\\uDCCCIntuition\\uD83D\\uDCCC**: \\n\\n1. To solve this problem is to use a prefix sum array, where the value at each index i represents the sum of all elements from index 0 to i. \\n1. Then, for each subarray, we can calculate its sum by subtracting the prefix sum at the start index from the prefix sum at the end index + 1. \\n1. We can use a hash table or an array to keep track of the number of times each possible remainder has been seen, and add the count of the remainder k - (current sum % k) to the final count.\\n\\n\\n\\n#### \\uD83D\\uDCCC\\uD83C\\uDFAFHere\\'s a step-by-step breakdown of the approach:\\uD83D\\uDCCC\\uD83C\\uDFAF\\n\\n* Create an empty HashMap to store the count of each remainder as key-value pairs. The key will be the remainder, and the value will be the count of that remainder.\\n\\n* Add an initial count of 1 for the remainder 0 to the HashMap. This is necessary because a subarray with no elements will have a sum of 0, which is divisible by any k.\\n\\n* Create a variable \"count\" to keep track of the total number of subarrays whose sum is divisible by k, and a variable \"sum\" to keep track of the current sum of the elements in the current subarray.\\n \\n* Iterate through each element of the input array A using a for-each loop.\\n\\n* In each iteration, add the current element to the current sum and then take the remainder of that sum when divided by k. This gives us the remainder of the current sum when divided by k.\\n \\n* If the remainder is negative, add k to it, to make it positive.\\n \\n* Check if there is already a count for the current remainder in the HashMap. If there is, add that count to our \"count\" variable, because all of those subarrays also have a sum that is divisible by k.\\n \\n* Add the current remainder to the HashMap, with a count of 1 if it doesn\\'t already exist, or increase the count by 1 if it does exist.\\n \\n* Return the final count of subarrays whose sum is divisible by k.\\n\\n**Code in Java:**\\n\\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] A, int K) {\\n       HashMap<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        int count = 0, sum = 0;\\n        for (int num : A) {\\n            sum = (sum + num) % K;\\n            if (sum < 0) {\\n                sum += K;\\n            }\\n            if (map.containsKey(sum)) {\\n                count += map.get(sum);\\n            }\\n            map.put(sum, map.getOrDefault(sum, 0) + 1);\\n        }\\n        return count;    \\n    }\\n}\\n```\\n**\\uD83D\\uDE80Time and Space  Complexity:\\uD83D\\uDE80**\\n\\nThis approach has a time complexity of O(n) and a space complexity of O(min(n,k)) as it uses a HashMap to store the remainder count and iterates through the array once.\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] A, int K) {\\n       HashMap<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        int count = 0, sum = 0;\\n        for (int num : A) {\\n            sum = (sum + num) % K;\\n            if (sum < 0) {\\n                sum += K;\\n            }\\n            if (map.containsKey(sum)) {\\n                count += map.get(sum);\\n            }\\n            map.put(sum, map.getOrDefault(sum, 0) + 1);\\n        }\\n        return count;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070615,
                "title": "js-prefix-sum-and-frequency-mapping-explanation",
                "content": "## Intuition\\n- To get the sum of a potential subarray, first prefix sum the entire array.  Then just find the difference between the sum at the endpoints of the subarray.\\n- Even with this information, the brute force approach requires a nested loop with an O(n^2) time complexity.\\n- We\\'re only interested in subarray sums divisible by `k`, so for any 2 indexes `i` and `j` where `i != j` we want `psum[i]%k == psum[j]%k`.\\n\\nAs an illustration, look at example 1:\\n```\\nk = 5\\nnums, prefix sums, and prefix sums % k look like this:\\n [4,5,0,-2,-3,1]\\n0 4 9 9  7  4 5\\n0 4 4 4  2  4 0\\n\\nLook at ps%k again with the matching subarrays:\\n0 4 4 4  2  4 0\\n [4,5,0,-2,-3,1]    // 0\\n   [5]              // 4\\n   [5,0]            // 4\\n   [5,0,-2,-3]      // 4\\n     [0]            // 4\\n     [0,-2,-3]      // 4\\n       [-2,-3]      // 4\\n```\\n- If there are `n` points with the same psum%k, the number of pairs of these points is `n*(n-1)/2`, so 2 points could designate 1 subarray, 3 points could designate 3 subarrays, 4 points 6, etc.\\n\\n## Approach\\n- Prefix sum the running sum of `nums` % `k`.\\n- Frequency map the values.\\n- For each count `n` > 1, add `n(n-1)/2` to the total number of divisible subarrays.\\n\\n## Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n## Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarraysDivByK = function(nums, k) \\n{\\n    /* Keep track of running sums mod k */\\n    let modSums = [0];\\n    for(let i=0; i<nums.length; i++)\\n    {\\n        let sum = ((modSums[i]+nums[i])%k+k)%k;  // Will convert negatives.\\n        modSums.push(sum);\\n    }\\n\\n    /*\\n        Positions with the same sum mod k can be the endpoints\\n        of a k-divisible subarray.  Find the # of pairings for\\n        each with the formula n(n-1)/2.\\n    */\\n\\n    /* Count each mod occurrence. */\\n    let modCounts = Array(k).fill(0);\\n    for(let ms of modSums)\\n        modCounts[ms]++;\\n\\n    /* Calculate # of subarrays. */\\n    let subs = modCounts.reduce((acc,val)=>acc+(val>1?val*(val-1)/2:0),0);\\n    return subs;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```\\nk = 5\\nnums, prefix sums, and prefix sums % k look like this:\\n [4,5,0,-2,-3,1]\\n0 4 9 9  7  4 5\\n0 4 4 4  2  4 0\\n\\nLook at ps%k again with the matching subarrays:\\n0 4 4 4  2  4 0\\n [4,5,0,-2,-3,1]    // 0\\n   [5]              // 4\\n   [5,0]            // 4\\n   [5,0,-2,-3]      // 4\\n     [0]            // 4\\n     [0,-2,-3]      // 4\\n       [-2,-3]      // 4\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarraysDivByK = function(nums, k) \\n{\\n    /* Keep track of running sums mod k */\\n    let modSums = [0];\\n    for(let i=0; i<nums.length; i++)\\n    {\\n        let sum = ((modSums[i]+nums[i])%k+k)%k;  // Will convert negatives.\\n        modSums.push(sum);\\n    }\\n\\n    /*\\n        Positions with the same sum mod k can be the endpoints\\n        of a k-divisible subarray.  Find the # of pairings for\\n        each with the formula n(n-1)/2.\\n    */\\n\\n    /* Count each mod occurrence. */\\n    let modCounts = Array(k).fill(0);\\n    for(let ms of modSums)\\n        modCounts[ms]++;\\n\\n    /* Calculate # of subarrays. */\\n    let subs = modCounts.reduce((acc,val)=>acc+(val>1?val*(val-1)/2:0),0);\\n    return subs;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3070527,
                "title": "java-easy-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep track of count of subarrays till index i whose sum % k = {0,1,..,k-1}. Add that count to answer when sum % k = 0.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor keeping track of count of sum % k, we can use a hashmap.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N + K) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        int sum = 0, count = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n\\n        for (int num : nums) {\\n            sum += num;\\n            int key = (sum % k + k) % k; // k is added to handle negative remainders [-4 % 9 = -5 and (-5 + 9) % 9 = 4]\\n            count += map.getOrDefault(key, 0);\\n            map.put(key, map.getOrDefault(key, 0) + 1);\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        int sum = 0, count = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n\\n        for (int num : nums) {\\n            sum += num;\\n            int key = (sum % k + k) % k; // k is added to handle negative remainders [-4 % 9 = -5 and (-5 + 9) % 9 = 4]\\n            count += map.getOrDefault(key, 0);\\n            map.put(key, map.getOrDefault(key, 0) + 1);\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070490,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n       int sum=0,cnt=0;\\n       HashMap<Integer,Integer>hm=new HashMap<>();\\n       hm.put(0,1);\\n       for(int i=0;i<nums.length;i++){\\n           sum+=nums[i];\\n\\n           int diff=sum%k;\\n\\n           if(diff<0){\\n               diff+=k;\\n           }\\n\\n           if(hm.containsKey(diff)){\\n               cnt+=hm.get(diff);\\n           }\\n           hm.put(diff,hm.getOrDefault(diff,0)+1);\\n       }\\n    return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n       int sum=0,cnt=0;\\n       HashMap<Integer,Integer>hm=new HashMap<>();\\n       hm.put(0,1);\\n       for(int i=0;i<nums.length;i++){\\n           sum+=nums[i];\\n\\n           int diff=sum%k;\\n\\n           if(diff<0){\\n               diff+=k;\\n           }\\n\\n           if(hm.containsKey(diff)){\\n               cnt+=hm.get(diff);\\n           }\\n           hm.put(diff,hm.getOrDefault(diff,0)+1);\\n       }\\n    return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746022,
                "title": "c-with-explanation",
                "content": "```\\npublic class Solution {\\n    public int SubarraysDivByK(int[] nums, int k) {\\n        Dictionary<int, int> map = new Dictionary<int, int>();\\n        int prefixSum = 0;\\n        int count = 0;\\n        //insert an extra 0 because if a sum is divisible by k so we have to add it in the answer\\n        map[0] = 1;\\n        for(int i = 0; i < nums.Length; i++){\\n            // Prefix sum which will have sum of all previous elements.\\n            prefixSum += nums[i];\\n            \\n            // Mod by k\\n            int rem = prefixSum % k;\\n            //if the remainder is negative then its positve complementary will be (rem+k) \\n            if(rem < 0)\\n                rem += k;\\n           \\n            if(map.ContainsKey(rem)){\\n\\t\\t\\t//diff = prefix[b] - prefix[a] = 0 => prefix[b] = prefix[a] \\n                count += map[rem];\\n                map[rem] += 1;\\n            }      \\n            else{\\n                map[rem] = 1;\\n            }\\n            \\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int SubarraysDivByK(int[] nums, int k) {\\n        Dictionary<int, int> map = new Dictionary<int, int>();\\n        int prefixSum = 0;\\n        int count = 0;\\n        //insert an extra 0 because if a sum is divisible by k so we have to add it in the answer\\n        map[0] = 1;\\n        for(int i = 0; i < nums.Length; i++){\\n            // Prefix sum which will have sum of all previous elements.\\n            prefixSum += nums[i];\\n            \\n            // Mod by k\\n            int rem = prefixSum % k;\\n            //if the remainder is negative then its positve complementary will be (rem+k) \\n            if(rem < 0)\\n                rem += k;\\n           \\n            if(map.ContainsKey(rem)){\\n\\t\\t\\t//diff = prefix[b] - prefix[a] = 0 => prefix[b] = prefix[a] \\n                count += map[rem];\\n                map[rem] += 1;\\n            }      \\n            else{\\n                map[rem] = 1;\\n            }\\n            \\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745201,
                "title": "easy-to-understand-solution-by-using-hashmap-prefix-sum-java",
                "content": "\\tclass Solution {\\n\\t\\tpublic int subarraysDivByK(int[] nums, int k) {\\n\\t\\t\\tHashMap <Integer, Integer>map = new HashMap<>();\\n\\t\\t\\tmap.put(0,1);\\n\\t\\t\\t//0 is seen once in the beginning, when no element is added in sum and sum = 0 and so 0 has to initialize with frequency 1\\n\\t\\t\\t//edge case \\n\\t\\t\\t\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int i = 0;i<nums.length; i++){\\n\\t\\t\\t\\tsum += nums[i];\\n\\t\\t\\t\\t int rem = sum%k < 0? sum%k + k : sum%k;\\n\\t\\t\\t\\t// if the remainder comes negative then add k to the remainder and then store it to map;\\n\\t\\t\\t\\tif(map.containsKey(rem)) {\\n\\t\\t\\t\\t\\tans+=map.get(rem);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmap.put(rem,map.getOrDefault(rem,0)+1);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}   \\n\\n\\n\\t/*the remainder has occured before, it means anything between these two,\\n\\tplus the number of times the remainder came before, those many sub arrays are divisible by k.\\n\\tSo add the already seen frequency to the response .\\n\\tUpdate  frequency now and continue.*/",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n\\t\\tpublic int subarraysDivByK(int[] nums, int k) {\\n\\t\\t\\tHashMap <Integer, Integer>map = new HashMap<>();\\n\\t\\t\\tmap.put(0,1);\\n\\t\\t\\t//0 is seen once in the beginning, when no element is added in sum and sum = 0 and so 0 has to initialize with frequency 1\\n\\t\\t\\t//edge case \\n\\t\\t\\t\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int i = 0;i<nums.length; i++){\\n\\t\\t\\t\\tsum += nums[i];\\n\\t\\t\\t\\t int rem = sum%k < 0? sum%k + k : sum%k;\\n\\t\\t\\t\\t// if the remainder comes negative then add k to the remainder and then store it to map;\\n\\t\\t\\t\\tif(map.containsKey(rem)) {\\n\\t\\t\\t\\t\\tans+=map.get(rem);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2737699,
                "title": "o-n-c-clean-solution-using-hashmaps",
                "content": "**Solution**-->\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int> map;\\n        map[0]=1;\\n        int ans=0;\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            int re=sum%k;\\n            if(re<0) re+=k;\\n            ans+=map[re];\\n            map[re]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int> map;\\n        map[0]=1;\\n        int ans=0;\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            int re=sum%k;\\n            if(re<0) re+=k;\\n            ans+=map[re];\\n            map[re]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2688641,
                "title": "python3-solution-prefix-sum-o-n",
                "content": "`Time Complexity` : `O(n)`\\n`Space Complexity` : `O(k)`\\n```\\nclass Solution:\\n    def subarraysDivByK(self, A, K):\\n        csum, ans = 0, 0\\n        D = [0] * K\\n        D[0] = 1\\n        for i in A:\\n            csum = (csum + i) % K\\n            ans += D[csum]\\n            D[csum] += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def subarraysDivByK(self, A, K):\\n        csum, ans = 0, 0\\n        D = [0] * K\\n        D[0] = 1\\n        for i in A:\\n            csum = (csum + i) % K\\n            ans += D[csum]\\n            D[csum] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654708,
                "title": "0-n-c-solution-with-prefix-sum-and-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int presum=0;\\n        int ans=0;\\n        map<int, int> mp;\\n        \\n    //insert an extra 0 because if a sum is divisible by k so we have to add it in the answer\\n        mp.insert({0,1}); \\n        \\n        // we add the frequency of a remainder to the answer\\n        for(int i=0; i<n; i++){\\n            presum += nums[i];\\n            int temp=presum%k;\\n            if(temp<0)\\n            //if the remainder is negative then its positve complementary will be (rem+k) \\n                temp += k;\\n            if(mp.find(temp) != mp.end()){\\n                ans += mp[temp];\\n                mp[temp]++;   \\n            }\\n            else\\n                mp[temp]=1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int presum=0;\\n        int ans=0;\\n        map<int, int> mp;\\n        \\n    //insert an extra 0 because if a sum is divisible by k so we have to add it in the answer\\n        mp.insert({0,1}",
                "codeTag": "Java"
            },
            {
                "id": 2513697,
                "title": "javascript-solution-easy-to-understand-brute-force-optimal-solution",
                "content": "**Brute Force Solution**\\n```\\n\\t// Time Complexity: O(n^2), Space Complexity: O(1)\\n\\tlet count = 0;\\n    \\n    for (let i = 0; i < nums.length; ++i) {\\n        let sum = 0;\\n        for (let j = i; j < nums.length; ++j) {\\n            sum += nums[j];\\n            if (sum % k === 0)\\n                ++count;\\n        }\\n    }\\n    \\n    return count;\\n```\\n\\n**Optimal Solution**\\n```\\n\\t// Time Complexity: O(n), Space Complexity: O(n)\\n\\tlet count = 0;\\n    let freqMap = new Map();\\n    freqMap.set(0, 1);\\n    let prefixSum = 0;\\n    \\n    for (let num of nums) {\\n        prefixSum += num;\\n        let mod = prefixSum % k;\\n        mod = mod < 0 ? mod + k : mod;\\n        let val = freqMap.get(mod) === undefined ? 0 : freqMap.get(mod);\\n        \\n        count += val;\\n        freqMap.set(mod, val + 1);\\n    }\\n    \\n    return count;\\n```\\n\\n**Added a similar problem in comments.**\\n*Do like, upvote & comment*",
                "solutionTags": [],
                "code": "```\\n\\t// Time Complexity: O(n^2), Space Complexity: O(1)\\n\\tlet count = 0;\\n    \\n    for (let i = 0; i < nums.length; ++i) {\\n        let sum = 0;\\n        for (let j = i; j < nums.length; ++j) {\\n            sum += nums[j];\\n            if (sum % k === 0)\\n                ++count;\\n        }\\n    }\\n    \\n    return count;\\n```\n```\\n\\t// Time Complexity: O(n), Space Complexity: O(n)\\n\\tlet count = 0;\\n    let freqMap = new Map();\\n    freqMap.set(0, 1);\\n    let prefixSum = 0;\\n    \\n    for (let num of nums) {\\n        prefixSum += num;\\n        let mod = prefixSum % k;\\n        mod = mod < 0 ? mod + k : mod;\\n        let val = freqMap.get(mod) === undefined ? 0 : freqMap.get(mod);\\n        \\n        count += val;\\n        freqMap.set(mod, val + 1);\\n    }\\n    \\n    return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2491973,
                "title": "advance-map-technique-with-explanation-subarray-sums-divisible-by-k-best",
                "content": "\\nIf we try linear O(n*n) logic: we get TLE->\\uD83D\\uDE10\\n\\nUnusable Code:\\nclass Solution {\\npublic:\\n\\t\\tint subarraysDivByK(vector<int>& arr, int k) {\\n        int i=0,ans=0;\\n    while(i<arr.size())\\n    {\\n        if(arr[i]%k==0)\\n            ans++;\\n        for(int j = i+1;j<arr.size();j++)\\n        {\\n            arr[i]+=arr[j];\\n            if(arr[i]%k==0)\\n                ans++;\\n        }\\n        i++;\\n    }\\n        return ans;\\n    }\\n};\\n\\n```\\nThat\\'s why we try to solve it with map: \\n\\nProcedure: \\n1. We do cumulativeSum or linear sum to check the mod value -> linearSum%k\\n2. If the mod value already found in the map then we do ans++ ; Here we add the value of the map-key; so we write ==>    ans+= (m[remainder]);\\n3. logic link: https://www.youtube.com/watch?v=ufXxc8Vty9A\\n\\ncode prepared by me: \\nclass Solution\\n{\\npublic:\\n    int subarraysDivByK(vector<int> &arr, int k)\\n    {\\n        map<int, int> m;\\n        int ans = 0;\\n        m.insert({0,1});\\n        int linearSum = 0;\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            linearSum+=arr[i];\\n            int remainder = linearSum % k;\\n            if(remainder < 0 )remainder+=k;  // ar[i] can be negetive;\\n            if (m.find(remainder) != m.end())\\n            {\\n                ans+= (m[remainder]);\\n                m[remainder]++;\\n            }\\n            else\\n            {\\n                m.insert({remainder,1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n# please upvote, if u liked the solution\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nThat\\'s why we try to solve it with map: \\n\\nProcedure: \\n1. We do cumulativeSum or linear sum to check the mod value -> linearSum%k\\n2. If the mod value already found in the map then we do ans++ ; Here we add the value of the map-key; so we write ==>    ans+= (m[remainder]);\\n3. logic link: https://www.youtube.com/watch?v=ufXxc8Vty9A\\n\\ncode prepared by me: \\nclass Solution\\n{\\npublic:\\n    int subarraysDivByK(vector<int> &arr, int k)\\n    {\\n        map<int, int> m;\\n        int ans = 0;\\n        m.insert({0,1});\\n        int linearSum = 0;\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            linearSum+=arr[i];\\n            int remainder = linearSum % k;\\n            if(remainder < 0 )remainder+=k;  // ar[i] can be negetive;\\n            if (m.find(remainder) != m.end())\\n            {\\n                ans+= (m[remainder]);\\n                m[remainder]++;\\n            }\\n            else\\n            {\\n                m.insert({remainder,1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n# please upvote, if u liked the solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419721,
                "title": "java-solution-easy-and-faster",
                "content": "\\t**Solution 1**\\n\\tpublic int subarraysDivByK(int[] nums, int k) {\\n        int[] map = new int[k];\\n\\t\\tmap[0] = 1;\\n\\t\\tint runningSum = 0;\\n\\t\\tint count = 0;\\n\\t\\t\\n\\t\\tfor(int n : nums) {\\n\\t\\t\\trunningSum += n;\\n\\t\\t\\tint reminder = runningSum % k;\\n\\t\\t\\tif(reminder < 0) { reminder += k; }\\n\\t\\t\\tcount += map[reminder];\\n\\t\\t\\tmap[reminder]++;\\n\\t\\t}\\n\\t\\treturn count;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t**Solution 2**\\n\\tpublic int subarraysDivByK(int[] nums, int k) {\\n\\t\\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n\\t\\tint runningSum = 0;\\n\\t\\tint count = 0;\\n\\t\\t\\n\\t\\tmap.put(0, 1);\\n\\t\\t\\n\\t\\tfor(int i=0; i<nums.length; i++) {\\n\\t\\t\\trunningSum += nums[i];\\n\\t\\t\\tint reminder = runningSum % k;\\n\\t\\t\\tif(reminder < 0) {\\n\\t\\t\\t\\treminder += k;\\n\\t\\t\\t}\\n\\t\\t\\tif(map.containsKey(reminder)) {\\n\\t\\t\\t\\tcount += map.get(reminder);\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(reminder, map.getOrDefault(reminder, 0)+1);\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}",
                "solutionTags": [],
                "code": "\\t**Solution 1**\\n\\tpublic int subarraysDivByK(int[] nums, int k) {\\n        int[] map = new int[k];\\n\\t\\tmap[0] = 1;\\n\\t\\tint runningSum = 0;\\n\\t\\tint count = 0;\\n\\t\\t\\n\\t\\tfor(int n : nums) {\\n\\t\\t\\trunningSum += n;\\n\\t\\t\\tint reminder = runningSum % k;\\n\\t\\t\\tif(reminder < 0) { reminder += k; }\\n\\t\\t\\tcount += map[reminder];\\n\\t\\t\\tmap[reminder]++;\\n\\t\\t}\\n\\t\\treturn count;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t**Solution 2**\\n\\tpublic int subarraysDivByK(int[] nums, int k) {\\n\\t\\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n\\t\\tint runningSum = 0;\\n\\t\\tint count = 0;\\n\\t\\t\\n\\t\\tmap.put(0, 1);\\n\\t\\t\\n\\t\\tfor(int i=0; i<nums.length; i++) {\\n\\t\\t\\trunningSum += nums[i];\\n\\t\\t\\tint reminder = runningSum % k;\\n\\t\\t\\tif(reminder < 0) {\\n\\t\\t\\t\\treminder += k;\\n\\t\\t\\t}\\n\\t\\t\\tif(map.containsKey(reminder)) {\\n\\t\\t\\t\\tcount += map.get(reminder);\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(reminder, map.getOrDefault(reminder, 0)+1);\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2383567,
                "title": "c-clean-solution-with-explanation-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n\\t\\t// take an ans variable\\n        int ans = 0;                   \\n\\t\\t// initialize a map of int, int and insert {0,1} as 0 occurs first time for sum\\n        unordered_map<int, int> mapp;\\n        mapp.insert({0,1});\\n        // initialize presum = 0 and remainder rem = 0 which will be used in further calculations\\n        int presum = 0;\\n        \\n        int rem = 0;\\n\\t\\t\\n\\t\\t// Logic\\n\\t\\t/*\\n\\t\\t\\t1. We will traverse the entire given array/vector.\\n\\t\\t\\t2. While traversing we will add the element in our presum, i.e presum += nums[i] .\\n\\t\\t\\t3. Now we will do the % of presum and k and store it in rem that we have created.\\n\\t\\t\\t4. We need to take care of negative value of rem. If it is < 0, then we will add k to the remainder to make it positive.\\n\\t\\t\\t5. Now we will check if rem already exist in the map. If it exist then we will add it\\'s frequency to ans variable \\n\\t\\t\\t and then increment rem\\'s value in map, i.e. mapp[rem]++,  else we will add it in the map.\\n\\t\\t\\t6. At last we will return ans.\\n\\t\\t*/\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            presum += nums[i];\\n            rem = presum % k;\\n            if(rem < 0) \\n                rem += k;\\n            \\n            if(mapp.find(rem) != mapp.end())\\n            {\\n                ans += mapp[rem];\\n                mapp[rem]++;\\n            }\\n            else\\n            {\\n                mapp.insert({rem,1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n\\t\\t// take an ans variable\\n        int ans = 0;                   \\n\\t\\t// initialize a map of int, int and insert {0,1} as 0 occurs first time for sum\\n        unordered_map<int, int> mapp;\\n        mapp.insert({0,1});\\n        // initialize presum = 0 and remainder rem = 0 which will be used in further calculations\\n        int presum = 0;\\n        \\n        int rem = 0;\\n\\t\\t\\n\\t\\t// Logic\\n\\t\\t/*\\n\\t\\t\\t1. We will traverse the entire given array/vector.\\n\\t\\t\\t2. While traversing we will add the element in our presum, i.e presum += nums[i] .\\n\\t\\t\\t3. Now we will do the % of presum and k and store it in rem that we have created.\\n\\t\\t\\t4. We need to take care of negative value of rem. If it is < 0, then we will add k to the remainder to make it positive.\\n\\t\\t\\t5. Now we will check if rem already exist in the map. If it exist then we will add it\\'s frequency to ans variable \\n\\t\\t\\t and then increment rem\\'s value in map, i.e. mapp[rem]++,  else we will add it in the map.\\n\\t\\t\\t6. At last we will return ans.\\n\\t\\t*/\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            presum += nums[i];\\n            rem = presum % k;\\n            if(rem < 0) \\n                rem += k;\\n            \\n            if(mapp.find(rem) != mapp.end())\\n            {\\n                ans += mapp[rem];\\n                mapp[rem]++;\\n            }\\n            else\\n            {\\n                mapp.insert({rem,1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254550,
                "title": "subarray-sums-divisible-by-k-java-easy-hashmap",
                "content": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        hm.put(0,1);\\n        int ans=0;\\n        int rem=0;\\n        int sum=0;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            rem=sum%k;\\n            \\n            if(rem<0){\\n                rem+=k;\\n            }\\n            \\n            if(hm.containsKey(rem)){\\n                ans+=hm.get(rem);\\n                hm.put(rem,hm.get(rem)+1);\\n            }else{\\n                hm.put(rem,1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        hm.put(0,1);\\n        int ans=0;\\n        int rem=0;\\n        int sum=0;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            rem=sum%k;\\n            \\n            if(rem<0){\\n                rem+=k;\\n            }\\n            \\n            if(hm.containsKey(rem)){\\n                ans+=hm.get(rem);\\n                hm.put(rem,hm.get(rem)+1);\\n            }else{\\n                hm.put(rem,1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240658,
                "title": "c-unordered-map-prefix-sum",
                "content": "```\\nint subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int>m1;\\n        int n=nums.size();\\n        int sum=0;\\n        int rem=0;\\n        int ans=0;\\n        for(int i=0;i<n;++i){\\n            sum=sum+nums[i];\\n            rem=sum%k;\\n            if(rem<0){\\n                rem=rem+k; //convert negative remainder to positive\\n            }\\n            if(rem==0){\\n                ans++; //for single digit\\n            }\\n            if(m1.find(rem)!=m1.end()){\\n                ans=ans+m1[rem];\\n                m1[rem]++; //remainder exists in the map so increase the count\\n            }\\n            else{\\n                m1[rem]++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nint subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int>m1;\\n        int n=nums.size();\\n        int sum=0;\\n        int rem=0;\\n        int ans=0;\\n        for(int i=0;i<n;++i){\\n            sum=sum+nums[i];\\n            rem=sum%k;\\n            if(rem<0){\\n                rem=rem+k; //convert negative remainder to positive\\n            }\\n            if(rem==0){\\n                ans++; //for single digit\\n            }\\n            if(m1.find(rem)!=m1.end()){\\n                ans=ans+m1[rem];\\n                m1[rem]++; //remainder exists in the map so increase the count\\n            }\\n            else{\\n                m1[rem]++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2185923,
                "title": "python-3-prefix-sum-o-n-o-k",
                "content": "```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        modCount = collections.Counter([0])\\n        res = 0\\n        prefix = 0\\n        \\n        for num in nums:\\n            prefix = (prefix + num) % k\\n            res += modCount[prefix]\\n            modCount[prefix] += 1\\n        \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        modCount = collections.Counter([0])\\n        res = 0\\n        prefix = 0\\n        \\n        for num in nums:\\n            prefix = (prefix + num) % k\\n            res += modCount[prefix]\\n            modCount[prefix] += 1\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2163640,
                "title": "c-easy-and-understandable-basic-maths-concept",
                "content": "This question requires basic concept we used in maths for solving problems in class 10!!!\\nWe have to find a subarray whose sum is divisible by a given number. \\n## Brute Force\\nThe brute force will be to generate all subarray and add their elements then find the count.\\nTime complexity will be O(N^3) to generate subarray and then O(N) to add the subarray elements.\\nYou can **optimise the time complexity of generating subarrays** to O(N^2)\\n\\n## Optimised Approach\\nSay there is two sum S1, S2. These numbers on dividing with k gives remainder x. Thus, these numbers can be written as\\nS1= kn+x\\nS2= km+x\\nSo if we can see S2-S1 = (km+x) - (kn+x) = k(m-n) which is divisible by k. Hence, this is what we have to find!!!\\nIf we have remainder negative just add k to it as it makes positive and pair to k for divisibility.\\n\\nSo basic idea is get current sum, find remainder(donot forget to check negative remainder case), then store their frequency in map. If you get same remainder, add the frequency to your array.\\n\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int> remCount;\\n        int res=0,rem=0,sum=0;\\n        remCount[rem] = 1;\\n        for(int i=0;i<nums.size();i++) {\\n            sum += nums[i];\\n            rem = sum%k;\\n            rem = (rem < 0) ? (rem+k):rem;\\n            if(remCount.find(rem) != remCount.end()) {\\n                res += remCount[rem];\\n            }\\n            ++remCount[rem];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int> remCount;\\n        int res=0,rem=0,sum=0;\\n        remCount[rem] = 1;\\n        for(int i=0;i<nums.size();i++) {\\n            sum += nums[i];\\n            rem = sum%k;\\n            rem = (rem < 0) ? (rem+k):rem;\\n            if(remCount.find(rem) != remCount.end()) {\\n                res += remCount[rem];\\n            }\\n            ++remCount[rem];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131998,
                "title": "prefix-sum-in-python-with-working-explanation",
                "content": "```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        count = [0] * k\\n        s = 0\\n        for x in nums:\\n            s += x % k\\n            count[s % k] += 1\\n        result = count[0]\\n        for c in count:\\n            result += (c * (c - 1)) // 2\\n        return result\\n```\\nFor example,\\nLet **nums = [4, 5, 0,-2,-3, 1]** and K =5\\n1. Creating count array of [0 value size k] i.e. [0, 0, 0, 0, 0, 0]\\n1. Sum =  4, 9, 9, 7, 4, 5\\n1. Sum % K =  4, 4, 4, 2, 4, 0\\n1. count[1,0, 1, 0, 4, 0]\\n1. Calculation:\\n* starting value of result = count[0] = 1\\n* count[2] = 1 times 2  i.e. result += 1(1-1)//2 = 1 + 0 = 1\\n* count[4] = 4 times 4  i.e. result += 4(4-1)//2 = 1 + 6 = 7",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        count = [0] * k\\n        s = 0\\n        for x in nums:\\n            s += x % k\\n            count[s % k] += 1\\n        result = count[0]\\n        for c in count:\\n            result += (c * (c - 1)) // 2\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2103243,
                "title": "python3-using-dictionary",
                "content": "```\\nclass Solution:\\n    def subarraysDivByK(self, arr: List[int], k: int) -> int:\\n        dic = {0:1}\\n        curr_sum = 0\\n        subArrays = 0\\n        for i in range(len(arr)):\\n            curr_sum+=arr[i]\\n            rem = curr_sum % k\\n            if rem<0:\\n                rem+=k\\n            if rem in dic:\\n                subArrays+=dic[rem]\\n                dic[rem]+=1\\n            else:\\n                dic[rem]=1\\n        return subArrays\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarraysDivByK(self, arr: List[int], k: int) -> int:\\n        dic = {0:1}\\n        curr_sum = 0\\n        subArrays = 0\\n        for i in range(len(arr)):\\n            curr_sum+=arr[i]\\n            rem = curr_sum % k\\n            if rem<0:\\n                rem+=k\\n            if rem in dic:\\n                subArrays+=dic[rem]\\n                dic[rem]+=1\\n            else:\\n                dic[rem]=1\\n        return subArrays\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016413,
                "title": "na-ve-and-clever-approach-o-n-n-and-o-n-use-of-hashmap-as-well-as-prefix-sum",
                "content": "Naive Approach o(n^2) \\n\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        vector<int> pre_sum;\\n        int sum=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            pre_sum.push_back(sum);\\n        }\\n        int temp=0;\\n        // for(int i=0;i<pre_sum.size();i++) cout<<pre_sum[i]<<\" \";\\n        for(int i=0;i<pre_sum.size();i++){\\n            if(abs(pre_sum[i])%k==0) temp++;\\n        }\\n        \\n        for(int i=0;i<pre_sum.size()-1;i++){\\n        for(int j=i+1;j<pre_sum.size();j++) {\\n            if(abs(pre_sum[j]-pre_sum[i])%k==0) temp++;\\n            }\\n        }\\n        return temp;\\n    }\\n    \\n Clever Approach \\n    O(n) \\n    \\n        int subarraysDivByK(vector<int>& nums, int k) {\\n        vector<int> pre_sum;\\n        map<int,int> mpp;\\n        \\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            int rem=sum%k;\\n            if(rem>=0) mpp[rem]++;\\n            else mpp[rem+k]++;\\n        }\\n        int temp=0;\\n        for(auto it=mpp.begin();it!=mpp.end();it++){\\n            int ele=it->first;\\n            int freq=it->second;\\n            if(freq>1 && ele!=0){\\n                temp+=(freq)*(freq-1)/2;\\n            }\\n            else if(ele==0){\\n                temp+=freq+(freq)*(freq-1)/2;\\n            }\\n        }\\n        \\nIn this question i have maintained a map which contains the freq of remainders(0,1,2,3,4,...,k-1) by the prefix sum of each element of the given vector and as we know 0 remainder means that sum is divisible by k and the freq of prefix sums that have remainder 0 are the ones that individually had the sum divisible by 0 as well as each suarrays of those elements which have sum %k==0 so i used the formulae of freq*(freq-1)/2+freq and for all those prefix sums that have the same remainder i have used a formula of frq*(freq-1)/2",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "Naive Approach o(n^2) \\n\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        vector<int> pre_sum;\\n        int sum=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            pre_sum.push_back(sum);\\n        }\\n        int temp=0;\\n        // for(int i=0;i<pre_sum.size();i++) cout<<pre_sum[i]<<\" \";\\n        for(int i=0;i<pre_sum.size();i++){\\n            if(abs(pre_sum[i])%k==0) temp++;\\n        }\\n        \\n        for(int i=0;i<pre_sum.size()-1;i++){\\n        for(int j=i+1;j<pre_sum.size();j++) {\\n            if(abs(pre_sum[j]-pre_sum[i])%k==0) temp++;\\n            }\\n        }\\n        return temp;\\n    }\\n    \\n Clever Approach \\n    O(n) \\n    \\n        int subarraysDivByK(vector<int>& nums, int k) {\\n        vector<int> pre_sum;\\n        map<int,int> mpp;\\n        \\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            int rem=sum%k;\\n            if(rem>=0) mpp[rem]++;\\n            else mpp[rem+k]++;\\n        }\\n        int temp=0;\\n        for(auto it=mpp.begin();it!=mpp.end();it++){\\n            int ele=it->first;\\n            int freq=it->second;\\n            if(freq>1 && ele!=0){\\n                temp+=(freq)*(freq-1)/2;\\n            }\\n            else if(ele==0){\\n                temp+=freq+(freq)*(freq-1)/2;\\n            }\\n        }\\n        \\nIn this question i have maintained a map which contains the freq of remainders(0,1,2,3,4,...,k-1) by the prefix sum of each element of the given vector and as we know 0 remainder means that sum is divisible by k and the freq of prefix sums that have remainder 0 are the ones that individually had the sum divisible by 0 as well as each suarrays of those elements which have sum %k==0 so i used the formulae of freq*(freq-1)/2+freq and for all those prefix sums that have the same remainder i have used a formula of frq*(freq-1)/2",
                "codeTag": "C++"
            },
            {
                "id": 1855257,
                "title": "c-map-easy-to-understand",
                "content": "\\nRuntime: 56 ms, faster than 85.21% of C++ online submissions for Subarray Sums Divisible by K.\\nMemory Usage: 31.6 MB, less than 54.97% of C++ online submissions for Subarray Sums Divisible by K.\\n\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int answer = 0;\\n        int prefixSum = 0;\\n        \\n        unordered_map<int,int> mp;\\n        mp[prefixSum]=1;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            prefixSum +=nums[i];\\n            //handle mod of -ve integer\\n            prefixSum = ((prefixSum%k)+k)%k;\\n            \\n            if(mp.find(prefixSum)!=mp.end()){\\n                answer+=mp[prefixSum];\\n                mp[prefixSum]+=1;\\n            }\\n            else{\\n                mp[prefixSum]=1;\\n            }\\n            \\n        }\\n        return answer;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int answer = 0;\\n        int prefixSum = 0;\\n        \\n        unordered_map<int,int> mp;\\n        mp[prefixSum]=1;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            prefixSum +=nums[i];\\n            //handle mod of -ve integer\\n            prefixSum = ((prefixSum%k)+k)%k;\\n            \\n            if(mp.find(prefixSum)!=mp.end()){\\n                answer+=mp[prefixSum];\\n                mp[prefixSum]+=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1777244,
                "title": "east-c-hashmap",
                "content": "```\\nint subarraysDivByK(vector<int> &nums, int k)\\n{\\n    int n = nums.size();\\n    int count = 0;\\n    int s = 0;\\n    int r;\\n\\n    unordered_map<int, int> dp;\\n    dp[0] = 1;\\n\\n    for (int i = 0; i < n; ++i)\\n    {\\n        s += nums[i];\\n        r = s % k;\\n\\n        if (r < 0)\\n            r += k;\\n\\n        if (dp.count(r))\\n            ++dp[r];\\n\\n        else\\n            dp[r] = 1;\\n\\n        count += (dp[r] - 1);\\n    }\\n\\n    return count;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint subarraysDivByK(vector<int> &nums, int k)\\n{\\n    int n = nums.size();\\n    int count = 0;\\n    int s = 0;\\n    int r;\\n\\n    unordered_map<int, int> dp;\\n    dp[0] = 1;\\n\\n    for (int i = 0; i < n; ++i)\\n    {\\n        s += nums[i];\\n        r = s % k;\\n\\n        if (r < 0)\\n            r += k;\\n\\n        if (dp.count(r))\\n            ++dp[r];\\n\\n        else\\n            dp[r] = 1;\\n\\n        count += (dp[r] - 1);\\n    }\\n\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1669317,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        int ans=0;\\n        \\n        HashMap <Integer, Integer> map = new HashMap<>();\\n        \\n        map.put(0,1);\\n        int sum=0;\\n        int rem=0;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            rem=sum%k;\\n            if(rem<0){\\n                rem+=k;\\n            }\\n            \\n            if(map.containsKey(rem)){\\n                ans+=map.get(rem);\\n                map.put(rem,map.get(rem)+1);\\n            }else{\\n                map.put(rem,1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n        int ans=0;\\n        \\n        HashMap <Integer, Integer> map = new HashMap<>();\\n        \\n        map.put(0,1);\\n        int sum=0;\\n        int rem=0;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            rem=sum%k;\\n            if(rem<0){\\n                rem+=k;\\n            }\\n            \\n            if(map.containsKey(rem)){\\n                ans+=map.get(rem);\\n                map.put(rem,map.get(rem)+1);\\n            }else{\\n                map.put(rem,1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590461,
                "title": "c-count-the-frequency-of-remainders-explained",
                "content": "![image](https://assets.leetcode.com/users/images/86dca490-61af-4f43-a6ef-da1b39fd7baf_1637521262.453946.png)\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int i = 0 , j = 0;\\n        int sum = 0;\\n        unordered_map<int ,int> remainderMap;\\n        int ans = 0;\\n        while(j < nums.size())\\n        {\\n            sum += nums[j];\\n            //why ? because in C++ or java -2%5 = -2 so make the remainders +ve by adding K\\n            remainderMap[((sum%k)+k)%k]++;\\n            \\n            j++;\\n        }\\n        \\n        for(auto x: remainderMap)\\n        {\\n            int rem = x.first;\\n            int count = x.second;\\n            \\n            if(rem == 0)\\n            {\\n                ans += count;\\n            }\\n            \\n            ans += (count*(count-1))/2;\\n        \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        int i = 0 , j = 0;\\n        int sum = 0;\\n        unordered_map<int ,int> remainderMap;\\n        int ans = 0;\\n        while(j < nums.size())\\n        {\\n            sum += nums[j];\\n            //why ? because in C++ or java -2%5 = -2 so make the remainders +ve by adding K\\n            remainderMap[((sum%k)+k)%k]++;\\n            \\n            j++;\\n        }\\n        \\n        for(auto x: remainderMap)\\n        {\\n            int rem = x.first;\\n            int count = x.second;\\n            \\n            if(rem == 0)\\n            {\\n                ans += count;\\n            }\\n            \\n            ans += (count*(count-1))/2;\\n        \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586150,
                "title": "c-hashmap-solution",
                "content": "**Please Upvote if you like the Solution!**\\n\\n    class Solution {\\n    public:\\n    int subarraysDivByK(vector<int>& nums, int k) \\n    {\\n        int res=0;\\n        \\n        unordered_map<int,int> mp;//contain the remainder with its frequency\\n        \\n        mp[0]=1;\\n        int sum=0;\\n        int rem=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            rem=sum%k;\\n            \\n            if(rem<0)\\n                rem+=k;\\n            \\n            if(mp.find(rem)!=mp.end())\\n            {\\n                res+=mp[rem];\\n                mp[rem]+=1;\\n            }\\n            else\\n                mp[rem]=1;\\n        }\\n        return res;\\n    }\\n    };",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n    public:\\n    int subarraysDivByK(vector<int>& nums, int k) \\n    {\\n        int res=0;\\n        \\n        unordered_map<int,int> mp;//contain the remainder with its frequency\\n        \\n        mp[0]=1;\\n        int sum=0;\\n        int rem=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            rem=sum%k;\\n            \\n            if(rem<0)\\n                rem+=k;\\n            \\n            if(mp.find(rem)!=mp.end())\\n            {\\n                res+=mp[rem];\\n                mp[rem]+=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1467090,
                "title": "java-faster-than-99-8-and-c-faster-than-97-6",
                "content": "**Java Code:**\\n```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n\\t\\t//stores the remainders\\n        int m[]=new int[k];\\n        int sum=0;\\n        int count=0;\\n        m[0]=1;\\n        for(int x: nums){\\n            sum+=x;\\n            int rem=sum%k;\\n            if(rem<0) rem+=k;\\n            count+=m[rem];\\n            m[rem]++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n**C++ Code:**\\n```\\nclass Solution {\\npublic:\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        //stores the remainders\\n        int m[k];\\n        memset(m,0,sizeof(m));\\n        int sum=0;\\n        int count=0;\\n        m[0]=1;\\n        for(int x: nums){\\n            sum+=x;\\n            int rem=sum%k;\\n            if(rem<0) rem+=k;\\n            count+=m[rem];\\n            m[rem]++;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subarraysDivByK(int[] nums, int k) {\\n\\t\\t//stores the remainders\\n        int m[]=new int[k];\\n        int sum=0;\\n        int count=0;\\n        m[0]=1;\\n        for(int x: nums){\\n            sum+=x;\\n            int rem=sum%k;\\n            if(rem<0) rem+=k;\\n            count+=m[rem];\\n            m[rem]++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432257,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        pre=[0]\\n        hs={0:1}\\n        c=0\\n        for i in range(len(nums)):\\n            z=pre[-1]+nums[i]\\n            c=c+hs.get(z%k,0)\\n            hs[z%k]=hs.get(z%k,0)+1\\n\\n            \\n            pre.append(z)\\n        \\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        pre=[0]\\n        hs={0:1}\\n        c=0\\n        for i in range(len(nums)):\\n            z=pre[-1]+nums[i]\\n            c=c+hs.get(z%k,0)\\n            hs[z%k]=hs.get(z%k,0)+1\\n\\n            \\n            pre.append(z)\\n        \\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273849,
                "title": "python3-sweet-elegant-implementation",
                "content": "```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n            \\n        dic=defaultdict(int)\\n        dic[0]=1\\n        \\n        count,pre=0,0\\n        for num in nums:\\n            pre=(pre+num)%k\\n            if pre in dic:\\n                count+=dic[pre]\\n            dic[pre]+=1\\n\\n        return count\\n\\t\\t\\n\\t\\t#  for any query comment\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n            \\n        dic=defaultdict(int)\\n        dic[0]=1\\n        \\n        count,pre=0,0\\n        for num in nums:\\n            pre=(pre+num)%k\\n            if pre in dic:\\n                count+=dic[pre]\\n            dic[pre]+=1\\n\\n        return count\\n\\t\\t\\n\\t\\t#  for any query comment\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245867,
                "title": "prefix-sum-js-solution",
                "content": "```\\nvar subarraysDivByK = function(nums, k) {\\n    if (nums === null || nums.length === 0) {\\n        return 0;\\n    }\\n    let prefixSum = 0, m = new Map(), count = 0;\\n    m.set(0,1);\\n    for (let i = 0; i < nums.length; i++) {\\n        prefixSum = (prefixSum + nums[i]) % k;\\n        if (prefixSum < 0) prefixSum += k;\\n        if (m.has(prefixSum)) count += m.get(prefixSum);\\n        m.set(prefixSum, m.get(prefixSum) + 1 || 1);\\n    }\\n    return count;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subarraysDivByK = function(nums, k) {\\n    if (nums === null || nums.length === 0) {\\n        return 0;\\n    }\\n    let prefixSum = 0, m = new Map(), count = 0;\\n    m.set(0,1);\\n    for (let i = 0; i < nums.length; i++) {\\n        prefixSum = (prefixSum + nums[i]) % k;\\n        if (prefixSum < 0) prefixSum += k;\\n        if (m.has(prefixSum)) count += m.get(prefixSum);\\n        m.set(prefixSum, m.get(prefixSum) + 1 || 1);\\n    }\\n    return count;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565082,
                "content": [
                    {
                        "username": "lucyG",
                        "content": "When I tried to solve this problem, I didn\\'t come up with **Prefix Sum** at all.\\n\\nMy question for you guys who thought of using Prefix Sum to solve it is how/why did you know that you gonna use Prefix Sum for it? \\n\\nI could only come up with the following possilbe reasons:\\n1. It looks like a problem that Prefix Sum could help with;\\n2. This is a problem related to Array & Modulo;\\n3. You just have a feeling...\\n\\nReally appreciate it."
                    },
                    {
                        "username": "CodeID99",
                        "content": "Hi, I first solved this problem with O(n**2), then moved to a find a better solution. Since it\\'s asking for a subarray, there is not much I could think of, except sliding window and prefix sum. Sliding window won\\'t work for this problem, so I solved it with prefix sum."
                    },
                    {
                        "username": "akansha_01",
                        "content": "damm true :)\\n"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "[@zarif98sjs](/zarif98sjs) How long is that experience?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, the first thing to see is that constraints are such that n^2 was directly out of scope. Sorting is also out of question since that ruins the subarrays so in a way n.log(n) was also out. With only O(n) complexity possible, there are not much things left apart from prefix sum. Plus having an O(n^2) solution would make this problem a dumb one, so knew in the first minute itself that we cant do without cumulative i.e prefix sum."
                    },
                    {
                        "username": "kandiana",
                        "content": "I figured it from the math point of view + from the algorithms I considered for the previous daily problem?\\nSubarray sum = difference between two prefix sums, it will be divided by k if prefix sums have the same mod k value. Hence I need to count mod k values and then caclulate the number of pairs for each count (for 0: n * (n + 1) / 2, for the rest: n * ( n - 1) / 2)\\n"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "Similar problems. I just recognize the pattern now"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "I guess from the experience of solving similar problems."
                    },
                    {
                        "username": "istewartbinks",
                        "content": "I came up with prefix sum. It\\'s asking for a contiguous subarray sum (mod k), which is easy to get in n^2 time if you have a prefix sum. I\\'ve done problems like this before. If I didn\\'t know what prefix sum was, I wouldn\\'t know how to answer this problem.\\n\\nConsider it pattern matching."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "There is a similar problem. Leetcode 560. Subarray Sum Equals K. Try that. Then you can instantly identify this needs a prefix sum."
                    },
                    {
                        "username": "arghyadas",
                        "content": "The SubArray week is far better than TREE and GRAPH Week\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@cwooldridge](/cwooldridge) \\nThat\\'s the fun of arrays. The answer is in front of you, but you aren\\'t able to identify it."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I disagree, graph question in general have similar solutions and better patterns. I feel subarrays and array questions in general require alot more creativity and have much more clever solutions"
                    },
                    {
                        "username": "mayank-01",
                        "content": "so true..\\uD83D\\uDE02"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "truee......"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "True dat!\\n"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "True\\uD83D\\uDE02"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This would be very easy if you could use a double for loop .\\nThe official answer requires you to have a god-tier understanding of math.\\nI don\\'t see how it is possible for people to solve questions like this blind and during a coding interview "
                    },
                    {
                        "username": "deciduousflame538",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run the outer loop till the length of array starting from 0, and the inner loop from a value equal to j and till the length of array. \\nfor(int i = 0; i < size; ++i)\\nfor(int j = i ; j<size; ++j)"
                    },
                    {
                        "username": "sandipt335",
                        "content": "[@ironmonger1](/ironmonger1) doesnt help either my good sir"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run both loops till end but start the second loop from one place after the initial loop"
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I am solving it by using double for loop only, but i got stuck with till what value i have to run both loops. Could you pls help me with this\\n"
                    },
                    {
                        "username": "jkulanko",
                        "content": "I highly recommend anyone who is serious about mastering leetcode to follow the usaco.guide website.  There's more there than you'll ever use in leetcode but if you enjoy or want to get good at competitive programming I recommend it.  There is a problem exactly like this https://usaco.guide/problems/usaco-595-subsequences-summing-to-sevens/solution.  I remembered this problem and was able to come up with the O(n) solution in minutes.  I've been working through the modules for about a month and my leetcode rating has jumped 150 points"
                    },
                    {
                        "username": "algoacer",
                        "content": "Thanks for this recommendation. Any tips you would like to share for someone going to start doing usaco? Thanks.."
                    },
                    {
                        "username": "user1421n",
                        "content": "To be honnest, it took me sometime to undestand the transition from one idea to another, I think if there is more explanation, it will be better, but it's okay"
                    },
                    {
                        "username": "jkulanko",
                        "content": "[@MaratKhakim](/MaratKhakim)  I recommend going through it level and topic wise. I.E. do the bronze modules first topic by topic. Do problems on each topic until you\\u2019re sick of them or think you\\u2019ve mastered the topic"
                    },
                    {
                        "username": "MaratKhakim",
                        "content": "Thanks.  [@Jacob Kulanko](/jkulanko)How are you studying there? Learning topicwise and solving problems on usaco? Please, share your study techniques"
                    },
                    {
                        "username": "jkulanko",
                        "content": "Here\\u2019s a follow up problem if anyone wants to try a slightly harder but similar problem: https://atcoder.jp/contests/abc164/tasks/abc164_d"
                    },
                    {
                        "username": "Hrushi73",
                        "content": "great share, I am going to follow this problem set\\n"
                    },
                    {
                        "username": "legitroman",
                        "content": "Thanks for the share! It was very helpful."
                    },
                    {
                        "username": "truthsayer_Inshadows",
                        "content": "use a hash map to keep track of the remainder of the running sum of the array modulo k. For each index i in the array, we calculate the running sum from index 0 to i, and find its remainder when divided by k. We then check if the remainder already exists in the hash map. If it does, it means that there is a subarray with a sum that is divisible by k, and we increment the count of subarrays. If the remainder doesn\\'t exist in the hash map, we add it to the hash map with a count of 1.\\n\\n\\n```cpp\\n\\nint subarraySum(vector<int>& nums, int k) {\\n    int count = 0;\\n    int running_sum = 0;\\n    unordered_map<int, int> remainder_count;\\n    remainder_count[0] = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        running_sum += nums[i];\\n        int remainder = running_sum % k;\\n        if (remainder_count.find(remainder) != remainder_count.end()) {\\n            count += remainder_count[remainder];\\n        }\\n        if (remainder_count.find(remainder) == remainder_count.end()) {\\n            remainder_count[remainder] = 1;\\n        } else {\\n            remainder_count[remainder]++;\\n        }\\n    }\\n    return count;\\n}\\n\\n```\\n## Test case dry run:\\nLet\\'s say nums = {4,5,0,-2,-3,1} and k = 5\\n\\nInitialize count = 0, running_sum = 0, remainder_count = {0: 1}\\nIterate through the array, starting at index 0:\\ni = 0, nums[i] = 4, running_sum = 4, remainder = 4 % 5 = 4, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 1, nums[i] = 5, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 2, nums[i] = 0, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 3, nums[i] = -2, running_sum = 7, remainder = 7 % 5 = 2, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 4, nums[i] = -3, running_sum = 4, remainder = 4 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 5, nums[i] = 1, running_sum = 5, remainder = 5 % 5 = 0, remainder in remainder_count, so increment count by 1\\nReturn count = 5\\nSo the output is 5.\\n\\n# Don\\'t leave without upvoting ^_^\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@vinaygottipamula](/vinaygottipamula)\\n plz explain the intiution behind rem<0 then rem+=k."
                    },
                    {
                        "username": "jskipper2020",
                        "content": "how do you know that a repeated remainder means there is +(remainder) in the answer?"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "But the output is 7, and yes it is coming when we run the above code. There is a small mistake in your dry run method..Please note that.\n\nWe are increasing the count value only when we find the remainder in hashtable with the existing hash value (of the remainder) not with 1. \nHope you get it :-)\n\nU also missed this condition in your code\nif(remainder<0)remainder+=k;"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**Bruteforce to Optimization**\nThe naïve bruteforce solution would be - for all possible subarray start and end indexes, calculate the sum. So, the algorithm becomes $O(n^3)$. We can optimize this using the prefix sum idea. $SubarraySum(i,j) = PrefixSum(j) - PrefixSum(i-1)$. This reduces the time complexity to $O(n^2)$.\n\nNow, for this problem,\n$$\nPrefixSum(j) - PrefixSum(i-1) = 0 \\  [modulo \\ k]\n$$\n$$ \n=> PrefixSum(j) = PrefixSum(i-1) \\ [modulo \\ k]\n$$\n\nSo, we can get rid of the loop and count the frequency of the current prefix sum to solve the problem. The final time complexity would be $O(n)$. The only corner case would be negative modulos."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "[@Babu_frik](/Babu_frik) The modulus is negative when the prefix sum is negative. In that case, you have to add `k` to the mod to make it positive. "
                    },
                    {
                        "username": "Babu_frik",
                        "content": "When is it negative modulus? Can you please throw insight on that case?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is an excellent hint and explanation! I always get TLE on all my solutions so this was very helpful. For people trying out this approach, also take note of how to handle $$PrefixSum(0 - 1)$$ for subarrays starting at $$i=0$$. "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Leetcode January TREES -> ARRAYS "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem Statement is simple to understand, but deducing `prefix + currElem % K + K` is a whole different level of problem"
                    },
                    {
                        "username": "prototye",
                        "content": "can you tell me the thought process and in general explanation on how we came up with this prefix + nums[i] % k + k thing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "With brute force approach, we could we could solve 66/73 testcases. After that, I get TLE. Can anyone tell me the approach to optimize it? "
                    },
                    {
                        "username": "taj_1",
                        "content": "[@mayank-01](/mayank-01) \\npublic int subarraysDivByK(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j<nums.length;j++){\\n                int sum = 0;\\n                for(int l=i;l<=j;l++){\\n                    sum+=nums[l];\\n                }\\n                if(sum%k==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "mayank-01",
                        "content": "can anyone share the brute force code."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "You can use a solution in which calculate prefix sums and at every stage calculate remainder with \\'K\\'  and store it in unordered map along with their frequencies Can be done in O(n) time .iI will post solution for this in a while"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Is it supposed to be done in O(n) or O(n^2) ?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) yeah that\\'s the one thing that can always be done. But I need to learn the optimization techniques instead of just copying the solutions every time :("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i passed 68 with O(n^2) now go to solution tab that\\'s what i am going to do"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach:\n* For each index i, count all previous prefix sums in the array which has modulo same as of current prefix sum (at idx i) and add it to result.\n`Use HashTable to store the counts of prefix sum modulo`.\n* Also, for a -ve number num, num%k<0, we have to change it to +ve mod because modulo of a number can lie in the range of 0 to k-1 only.\n\nLet, num = -2, k=3 then `res=(-2)%3=-2`, for changing it to +ve mod add k to res.\nChanging to +ve mod, `-2+3 = 1`, So, `res=(-2)%3=1`.\n\n### Complexity: O(n) time and O(k) space"
                    },
                    {
                        "username": "a_parth",
                        "content": "but why we need to calculate +ve modulo. Why we can\\'t go ahead with -ve modulo?"
                    }
                ]
            },
            {
                "id": 1764320,
                "content": [
                    {
                        "username": "lucyG",
                        "content": "When I tried to solve this problem, I didn\\'t come up with **Prefix Sum** at all.\\n\\nMy question for you guys who thought of using Prefix Sum to solve it is how/why did you know that you gonna use Prefix Sum for it? \\n\\nI could only come up with the following possilbe reasons:\\n1. It looks like a problem that Prefix Sum could help with;\\n2. This is a problem related to Array & Modulo;\\n3. You just have a feeling...\\n\\nReally appreciate it."
                    },
                    {
                        "username": "CodeID99",
                        "content": "Hi, I first solved this problem with O(n**2), then moved to a find a better solution. Since it\\'s asking for a subarray, there is not much I could think of, except sliding window and prefix sum. Sliding window won\\'t work for this problem, so I solved it with prefix sum."
                    },
                    {
                        "username": "akansha_01",
                        "content": "damm true :)\\n"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "[@zarif98sjs](/zarif98sjs) How long is that experience?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, the first thing to see is that constraints are such that n^2 was directly out of scope. Sorting is also out of question since that ruins the subarrays so in a way n.log(n) was also out. With only O(n) complexity possible, there are not much things left apart from prefix sum. Plus having an O(n^2) solution would make this problem a dumb one, so knew in the first minute itself that we cant do without cumulative i.e prefix sum."
                    },
                    {
                        "username": "kandiana",
                        "content": "I figured it from the math point of view + from the algorithms I considered for the previous daily problem?\\nSubarray sum = difference between two prefix sums, it will be divided by k if prefix sums have the same mod k value. Hence I need to count mod k values and then caclulate the number of pairs for each count (for 0: n * (n + 1) / 2, for the rest: n * ( n - 1) / 2)\\n"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "Similar problems. I just recognize the pattern now"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "I guess from the experience of solving similar problems."
                    },
                    {
                        "username": "istewartbinks",
                        "content": "I came up with prefix sum. It\\'s asking for a contiguous subarray sum (mod k), which is easy to get in n^2 time if you have a prefix sum. I\\'ve done problems like this before. If I didn\\'t know what prefix sum was, I wouldn\\'t know how to answer this problem.\\n\\nConsider it pattern matching."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "There is a similar problem. Leetcode 560. Subarray Sum Equals K. Try that. Then you can instantly identify this needs a prefix sum."
                    },
                    {
                        "username": "arghyadas",
                        "content": "The SubArray week is far better than TREE and GRAPH Week\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@cwooldridge](/cwooldridge) \\nThat\\'s the fun of arrays. The answer is in front of you, but you aren\\'t able to identify it."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I disagree, graph question in general have similar solutions and better patterns. I feel subarrays and array questions in general require alot more creativity and have much more clever solutions"
                    },
                    {
                        "username": "mayank-01",
                        "content": "so true..\\uD83D\\uDE02"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "truee......"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "True dat!\\n"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "True\\uD83D\\uDE02"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This would be very easy if you could use a double for loop .\\nThe official answer requires you to have a god-tier understanding of math.\\nI don\\'t see how it is possible for people to solve questions like this blind and during a coding interview "
                    },
                    {
                        "username": "deciduousflame538",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run the outer loop till the length of array starting from 0, and the inner loop from a value equal to j and till the length of array. \\nfor(int i = 0; i < size; ++i)\\nfor(int j = i ; j<size; ++j)"
                    },
                    {
                        "username": "sandipt335",
                        "content": "[@ironmonger1](/ironmonger1) doesnt help either my good sir"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run both loops till end but start the second loop from one place after the initial loop"
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I am solving it by using double for loop only, but i got stuck with till what value i have to run both loops. Could you pls help me with this\\n"
                    },
                    {
                        "username": "jkulanko",
                        "content": "I highly recommend anyone who is serious about mastering leetcode to follow the usaco.guide website.  There's more there than you'll ever use in leetcode but if you enjoy or want to get good at competitive programming I recommend it.  There is a problem exactly like this https://usaco.guide/problems/usaco-595-subsequences-summing-to-sevens/solution.  I remembered this problem and was able to come up with the O(n) solution in minutes.  I've been working through the modules for about a month and my leetcode rating has jumped 150 points"
                    },
                    {
                        "username": "algoacer",
                        "content": "Thanks for this recommendation. Any tips you would like to share for someone going to start doing usaco? Thanks.."
                    },
                    {
                        "username": "user1421n",
                        "content": "To be honnest, it took me sometime to undestand the transition from one idea to another, I think if there is more explanation, it will be better, but it's okay"
                    },
                    {
                        "username": "jkulanko",
                        "content": "[@MaratKhakim](/MaratKhakim)  I recommend going through it level and topic wise. I.E. do the bronze modules first topic by topic. Do problems on each topic until you\\u2019re sick of them or think you\\u2019ve mastered the topic"
                    },
                    {
                        "username": "MaratKhakim",
                        "content": "Thanks.  [@Jacob Kulanko](/jkulanko)How are you studying there? Learning topicwise and solving problems on usaco? Please, share your study techniques"
                    },
                    {
                        "username": "jkulanko",
                        "content": "Here\\u2019s a follow up problem if anyone wants to try a slightly harder but similar problem: https://atcoder.jp/contests/abc164/tasks/abc164_d"
                    },
                    {
                        "username": "Hrushi73",
                        "content": "great share, I am going to follow this problem set\\n"
                    },
                    {
                        "username": "legitroman",
                        "content": "Thanks for the share! It was very helpful."
                    },
                    {
                        "username": "truthsayer_Inshadows",
                        "content": "use a hash map to keep track of the remainder of the running sum of the array modulo k. For each index i in the array, we calculate the running sum from index 0 to i, and find its remainder when divided by k. We then check if the remainder already exists in the hash map. If it does, it means that there is a subarray with a sum that is divisible by k, and we increment the count of subarrays. If the remainder doesn\\'t exist in the hash map, we add it to the hash map with a count of 1.\\n\\n\\n```cpp\\n\\nint subarraySum(vector<int>& nums, int k) {\\n    int count = 0;\\n    int running_sum = 0;\\n    unordered_map<int, int> remainder_count;\\n    remainder_count[0] = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        running_sum += nums[i];\\n        int remainder = running_sum % k;\\n        if (remainder_count.find(remainder) != remainder_count.end()) {\\n            count += remainder_count[remainder];\\n        }\\n        if (remainder_count.find(remainder) == remainder_count.end()) {\\n            remainder_count[remainder] = 1;\\n        } else {\\n            remainder_count[remainder]++;\\n        }\\n    }\\n    return count;\\n}\\n\\n```\\n## Test case dry run:\\nLet\\'s say nums = {4,5,0,-2,-3,1} and k = 5\\n\\nInitialize count = 0, running_sum = 0, remainder_count = {0: 1}\\nIterate through the array, starting at index 0:\\ni = 0, nums[i] = 4, running_sum = 4, remainder = 4 % 5 = 4, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 1, nums[i] = 5, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 2, nums[i] = 0, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 3, nums[i] = -2, running_sum = 7, remainder = 7 % 5 = 2, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 4, nums[i] = -3, running_sum = 4, remainder = 4 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 5, nums[i] = 1, running_sum = 5, remainder = 5 % 5 = 0, remainder in remainder_count, so increment count by 1\\nReturn count = 5\\nSo the output is 5.\\n\\n# Don\\'t leave without upvoting ^_^\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@vinaygottipamula](/vinaygottipamula)\\n plz explain the intiution behind rem<0 then rem+=k."
                    },
                    {
                        "username": "jskipper2020",
                        "content": "how do you know that a repeated remainder means there is +(remainder) in the answer?"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "But the output is 7, and yes it is coming when we run the above code. There is a small mistake in your dry run method..Please note that.\n\nWe are increasing the count value only when we find the remainder in hashtable with the existing hash value (of the remainder) not with 1. \nHope you get it :-)\n\nU also missed this condition in your code\nif(remainder<0)remainder+=k;"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**Bruteforce to Optimization**\nThe naïve bruteforce solution would be - for all possible subarray start and end indexes, calculate the sum. So, the algorithm becomes $O(n^3)$. We can optimize this using the prefix sum idea. $SubarraySum(i,j) = PrefixSum(j) - PrefixSum(i-1)$. This reduces the time complexity to $O(n^2)$.\n\nNow, for this problem,\n$$\nPrefixSum(j) - PrefixSum(i-1) = 0 \\  [modulo \\ k]\n$$\n$$ \n=> PrefixSum(j) = PrefixSum(i-1) \\ [modulo \\ k]\n$$\n\nSo, we can get rid of the loop and count the frequency of the current prefix sum to solve the problem. The final time complexity would be $O(n)$. The only corner case would be negative modulos."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "[@Babu_frik](/Babu_frik) The modulus is negative when the prefix sum is negative. In that case, you have to add `k` to the mod to make it positive. "
                    },
                    {
                        "username": "Babu_frik",
                        "content": "When is it negative modulus? Can you please throw insight on that case?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is an excellent hint and explanation! I always get TLE on all my solutions so this was very helpful. For people trying out this approach, also take note of how to handle $$PrefixSum(0 - 1)$$ for subarrays starting at $$i=0$$. "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Leetcode January TREES -> ARRAYS "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem Statement is simple to understand, but deducing `prefix + currElem % K + K` is a whole different level of problem"
                    },
                    {
                        "username": "prototye",
                        "content": "can you tell me the thought process and in general explanation on how we came up with this prefix + nums[i] % k + k thing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "With brute force approach, we could we could solve 66/73 testcases. After that, I get TLE. Can anyone tell me the approach to optimize it? "
                    },
                    {
                        "username": "taj_1",
                        "content": "[@mayank-01](/mayank-01) \\npublic int subarraysDivByK(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j<nums.length;j++){\\n                int sum = 0;\\n                for(int l=i;l<=j;l++){\\n                    sum+=nums[l];\\n                }\\n                if(sum%k==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "mayank-01",
                        "content": "can anyone share the brute force code."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "You can use a solution in which calculate prefix sums and at every stage calculate remainder with \\'K\\'  and store it in unordered map along with their frequencies Can be done in O(n) time .iI will post solution for this in a while"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Is it supposed to be done in O(n) or O(n^2) ?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) yeah that\\'s the one thing that can always be done. But I need to learn the optimization techniques instead of just copying the solutions every time :("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i passed 68 with O(n^2) now go to solution tab that\\'s what i am going to do"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach:\n* For each index i, count all previous prefix sums in the array which has modulo same as of current prefix sum (at idx i) and add it to result.\n`Use HashTable to store the counts of prefix sum modulo`.\n* Also, for a -ve number num, num%k<0, we have to change it to +ve mod because modulo of a number can lie in the range of 0 to k-1 only.\n\nLet, num = -2, k=3 then `res=(-2)%3=-2`, for changing it to +ve mod add k to res.\nChanging to +ve mod, `-2+3 = 1`, So, `res=(-2)%3=1`.\n\n### Complexity: O(n) time and O(k) space"
                    },
                    {
                        "username": "a_parth",
                        "content": "but why we need to calculate +ve modulo. Why we can\\'t go ahead with -ve modulo?"
                    }
                ]
            },
            {
                "id": 1764026,
                "content": [
                    {
                        "username": "lucyG",
                        "content": "When I tried to solve this problem, I didn\\'t come up with **Prefix Sum** at all.\\n\\nMy question for you guys who thought of using Prefix Sum to solve it is how/why did you know that you gonna use Prefix Sum for it? \\n\\nI could only come up with the following possilbe reasons:\\n1. It looks like a problem that Prefix Sum could help with;\\n2. This is a problem related to Array & Modulo;\\n3. You just have a feeling...\\n\\nReally appreciate it."
                    },
                    {
                        "username": "CodeID99",
                        "content": "Hi, I first solved this problem with O(n**2), then moved to a find a better solution. Since it\\'s asking for a subarray, there is not much I could think of, except sliding window and prefix sum. Sliding window won\\'t work for this problem, so I solved it with prefix sum."
                    },
                    {
                        "username": "akansha_01",
                        "content": "damm true :)\\n"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "[@zarif98sjs](/zarif98sjs) How long is that experience?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, the first thing to see is that constraints are such that n^2 was directly out of scope. Sorting is also out of question since that ruins the subarrays so in a way n.log(n) was also out. With only O(n) complexity possible, there are not much things left apart from prefix sum. Plus having an O(n^2) solution would make this problem a dumb one, so knew in the first minute itself that we cant do without cumulative i.e prefix sum."
                    },
                    {
                        "username": "kandiana",
                        "content": "I figured it from the math point of view + from the algorithms I considered for the previous daily problem?\\nSubarray sum = difference between two prefix sums, it will be divided by k if prefix sums have the same mod k value. Hence I need to count mod k values and then caclulate the number of pairs for each count (for 0: n * (n + 1) / 2, for the rest: n * ( n - 1) / 2)\\n"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "Similar problems. I just recognize the pattern now"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "I guess from the experience of solving similar problems."
                    },
                    {
                        "username": "istewartbinks",
                        "content": "I came up with prefix sum. It\\'s asking for a contiguous subarray sum (mod k), which is easy to get in n^2 time if you have a prefix sum. I\\'ve done problems like this before. If I didn\\'t know what prefix sum was, I wouldn\\'t know how to answer this problem.\\n\\nConsider it pattern matching."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "There is a similar problem. Leetcode 560. Subarray Sum Equals K. Try that. Then you can instantly identify this needs a prefix sum."
                    },
                    {
                        "username": "arghyadas",
                        "content": "The SubArray week is far better than TREE and GRAPH Week\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@cwooldridge](/cwooldridge) \\nThat\\'s the fun of arrays. The answer is in front of you, but you aren\\'t able to identify it."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I disagree, graph question in general have similar solutions and better patterns. I feel subarrays and array questions in general require alot more creativity and have much more clever solutions"
                    },
                    {
                        "username": "mayank-01",
                        "content": "so true..\\uD83D\\uDE02"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "truee......"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "True dat!\\n"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "True\\uD83D\\uDE02"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This would be very easy if you could use a double for loop .\\nThe official answer requires you to have a god-tier understanding of math.\\nI don\\'t see how it is possible for people to solve questions like this blind and during a coding interview "
                    },
                    {
                        "username": "deciduousflame538",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run the outer loop till the length of array starting from 0, and the inner loop from a value equal to j and till the length of array. \\nfor(int i = 0; i < size; ++i)\\nfor(int j = i ; j<size; ++j)"
                    },
                    {
                        "username": "sandipt335",
                        "content": "[@ironmonger1](/ironmonger1) doesnt help either my good sir"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run both loops till end but start the second loop from one place after the initial loop"
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I am solving it by using double for loop only, but i got stuck with till what value i have to run both loops. Could you pls help me with this\\n"
                    },
                    {
                        "username": "jkulanko",
                        "content": "I highly recommend anyone who is serious about mastering leetcode to follow the usaco.guide website.  There's more there than you'll ever use in leetcode but if you enjoy or want to get good at competitive programming I recommend it.  There is a problem exactly like this https://usaco.guide/problems/usaco-595-subsequences-summing-to-sevens/solution.  I remembered this problem and was able to come up with the O(n) solution in minutes.  I've been working through the modules for about a month and my leetcode rating has jumped 150 points"
                    },
                    {
                        "username": "algoacer",
                        "content": "Thanks for this recommendation. Any tips you would like to share for someone going to start doing usaco? Thanks.."
                    },
                    {
                        "username": "user1421n",
                        "content": "To be honnest, it took me sometime to undestand the transition from one idea to another, I think if there is more explanation, it will be better, but it's okay"
                    },
                    {
                        "username": "jkulanko",
                        "content": "[@MaratKhakim](/MaratKhakim)  I recommend going through it level and topic wise. I.E. do the bronze modules first topic by topic. Do problems on each topic until you\\u2019re sick of them or think you\\u2019ve mastered the topic"
                    },
                    {
                        "username": "MaratKhakim",
                        "content": "Thanks.  [@Jacob Kulanko](/jkulanko)How are you studying there? Learning topicwise and solving problems on usaco? Please, share your study techniques"
                    },
                    {
                        "username": "jkulanko",
                        "content": "Here\\u2019s a follow up problem if anyone wants to try a slightly harder but similar problem: https://atcoder.jp/contests/abc164/tasks/abc164_d"
                    },
                    {
                        "username": "Hrushi73",
                        "content": "great share, I am going to follow this problem set\\n"
                    },
                    {
                        "username": "legitroman",
                        "content": "Thanks for the share! It was very helpful."
                    },
                    {
                        "username": "truthsayer_Inshadows",
                        "content": "use a hash map to keep track of the remainder of the running sum of the array modulo k. For each index i in the array, we calculate the running sum from index 0 to i, and find its remainder when divided by k. We then check if the remainder already exists in the hash map. If it does, it means that there is a subarray with a sum that is divisible by k, and we increment the count of subarrays. If the remainder doesn\\'t exist in the hash map, we add it to the hash map with a count of 1.\\n\\n\\n```cpp\\n\\nint subarraySum(vector<int>& nums, int k) {\\n    int count = 0;\\n    int running_sum = 0;\\n    unordered_map<int, int> remainder_count;\\n    remainder_count[0] = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        running_sum += nums[i];\\n        int remainder = running_sum % k;\\n        if (remainder_count.find(remainder) != remainder_count.end()) {\\n            count += remainder_count[remainder];\\n        }\\n        if (remainder_count.find(remainder) == remainder_count.end()) {\\n            remainder_count[remainder] = 1;\\n        } else {\\n            remainder_count[remainder]++;\\n        }\\n    }\\n    return count;\\n}\\n\\n```\\n## Test case dry run:\\nLet\\'s say nums = {4,5,0,-2,-3,1} and k = 5\\n\\nInitialize count = 0, running_sum = 0, remainder_count = {0: 1}\\nIterate through the array, starting at index 0:\\ni = 0, nums[i] = 4, running_sum = 4, remainder = 4 % 5 = 4, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 1, nums[i] = 5, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 2, nums[i] = 0, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 3, nums[i] = -2, running_sum = 7, remainder = 7 % 5 = 2, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 4, nums[i] = -3, running_sum = 4, remainder = 4 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 5, nums[i] = 1, running_sum = 5, remainder = 5 % 5 = 0, remainder in remainder_count, so increment count by 1\\nReturn count = 5\\nSo the output is 5.\\n\\n# Don\\'t leave without upvoting ^_^\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@vinaygottipamula](/vinaygottipamula)\\n plz explain the intiution behind rem<0 then rem+=k."
                    },
                    {
                        "username": "jskipper2020",
                        "content": "how do you know that a repeated remainder means there is +(remainder) in the answer?"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "But the output is 7, and yes it is coming when we run the above code. There is a small mistake in your dry run method..Please note that.\n\nWe are increasing the count value only when we find the remainder in hashtable with the existing hash value (of the remainder) not with 1. \nHope you get it :-)\n\nU also missed this condition in your code\nif(remainder<0)remainder+=k;"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**Bruteforce to Optimization**\nThe naïve bruteforce solution would be - for all possible subarray start and end indexes, calculate the sum. So, the algorithm becomes $O(n^3)$. We can optimize this using the prefix sum idea. $SubarraySum(i,j) = PrefixSum(j) - PrefixSum(i-1)$. This reduces the time complexity to $O(n^2)$.\n\nNow, for this problem,\n$$\nPrefixSum(j) - PrefixSum(i-1) = 0 \\  [modulo \\ k]\n$$\n$$ \n=> PrefixSum(j) = PrefixSum(i-1) \\ [modulo \\ k]\n$$\n\nSo, we can get rid of the loop and count the frequency of the current prefix sum to solve the problem. The final time complexity would be $O(n)$. The only corner case would be negative modulos."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "[@Babu_frik](/Babu_frik) The modulus is negative when the prefix sum is negative. In that case, you have to add `k` to the mod to make it positive. "
                    },
                    {
                        "username": "Babu_frik",
                        "content": "When is it negative modulus? Can you please throw insight on that case?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is an excellent hint and explanation! I always get TLE on all my solutions so this was very helpful. For people trying out this approach, also take note of how to handle $$PrefixSum(0 - 1)$$ for subarrays starting at $$i=0$$. "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Leetcode January TREES -> ARRAYS "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem Statement is simple to understand, but deducing `prefix + currElem % K + K` is a whole different level of problem"
                    },
                    {
                        "username": "prototye",
                        "content": "can you tell me the thought process and in general explanation on how we came up with this prefix + nums[i] % k + k thing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "With brute force approach, we could we could solve 66/73 testcases. After that, I get TLE. Can anyone tell me the approach to optimize it? "
                    },
                    {
                        "username": "taj_1",
                        "content": "[@mayank-01](/mayank-01) \\npublic int subarraysDivByK(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j<nums.length;j++){\\n                int sum = 0;\\n                for(int l=i;l<=j;l++){\\n                    sum+=nums[l];\\n                }\\n                if(sum%k==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "mayank-01",
                        "content": "can anyone share the brute force code."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "You can use a solution in which calculate prefix sums and at every stage calculate remainder with \\'K\\'  and store it in unordered map along with their frequencies Can be done in O(n) time .iI will post solution for this in a while"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Is it supposed to be done in O(n) or O(n^2) ?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) yeah that\\'s the one thing that can always be done. But I need to learn the optimization techniques instead of just copying the solutions every time :("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i passed 68 with O(n^2) now go to solution tab that\\'s what i am going to do"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach:\n* For each index i, count all previous prefix sums in the array which has modulo same as of current prefix sum (at idx i) and add it to result.\n`Use HashTable to store the counts of prefix sum modulo`.\n* Also, for a -ve number num, num%k<0, we have to change it to +ve mod because modulo of a number can lie in the range of 0 to k-1 only.\n\nLet, num = -2, k=3 then `res=(-2)%3=-2`, for changing it to +ve mod add k to res.\nChanging to +ve mod, `-2+3 = 1`, So, `res=(-2)%3=1`.\n\n### Complexity: O(n) time and O(k) space"
                    },
                    {
                        "username": "a_parth",
                        "content": "but why we need to calculate +ve modulo. Why we can\\'t go ahead with -ve modulo?"
                    }
                ]
            },
            {
                "id": 1764217,
                "content": [
                    {
                        "username": "lucyG",
                        "content": "When I tried to solve this problem, I didn\\'t come up with **Prefix Sum** at all.\\n\\nMy question for you guys who thought of using Prefix Sum to solve it is how/why did you know that you gonna use Prefix Sum for it? \\n\\nI could only come up with the following possilbe reasons:\\n1. It looks like a problem that Prefix Sum could help with;\\n2. This is a problem related to Array & Modulo;\\n3. You just have a feeling...\\n\\nReally appreciate it."
                    },
                    {
                        "username": "CodeID99",
                        "content": "Hi, I first solved this problem with O(n**2), then moved to a find a better solution. Since it\\'s asking for a subarray, there is not much I could think of, except sliding window and prefix sum. Sliding window won\\'t work for this problem, so I solved it with prefix sum."
                    },
                    {
                        "username": "akansha_01",
                        "content": "damm true :)\\n"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "[@zarif98sjs](/zarif98sjs) How long is that experience?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, the first thing to see is that constraints are such that n^2 was directly out of scope. Sorting is also out of question since that ruins the subarrays so in a way n.log(n) was also out. With only O(n) complexity possible, there are not much things left apart from prefix sum. Plus having an O(n^2) solution would make this problem a dumb one, so knew in the first minute itself that we cant do without cumulative i.e prefix sum."
                    },
                    {
                        "username": "kandiana",
                        "content": "I figured it from the math point of view + from the algorithms I considered for the previous daily problem?\\nSubarray sum = difference between two prefix sums, it will be divided by k if prefix sums have the same mod k value. Hence I need to count mod k values and then caclulate the number of pairs for each count (for 0: n * (n + 1) / 2, for the rest: n * ( n - 1) / 2)\\n"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "Similar problems. I just recognize the pattern now"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "I guess from the experience of solving similar problems."
                    },
                    {
                        "username": "istewartbinks",
                        "content": "I came up with prefix sum. It\\'s asking for a contiguous subarray sum (mod k), which is easy to get in n^2 time if you have a prefix sum. I\\'ve done problems like this before. If I didn\\'t know what prefix sum was, I wouldn\\'t know how to answer this problem.\\n\\nConsider it pattern matching."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "There is a similar problem. Leetcode 560. Subarray Sum Equals K. Try that. Then you can instantly identify this needs a prefix sum."
                    },
                    {
                        "username": "arghyadas",
                        "content": "The SubArray week is far better than TREE and GRAPH Week\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@cwooldridge](/cwooldridge) \\nThat\\'s the fun of arrays. The answer is in front of you, but you aren\\'t able to identify it."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I disagree, graph question in general have similar solutions and better patterns. I feel subarrays and array questions in general require alot more creativity and have much more clever solutions"
                    },
                    {
                        "username": "mayank-01",
                        "content": "so true..\\uD83D\\uDE02"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "truee......"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "True dat!\\n"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "True\\uD83D\\uDE02"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This would be very easy if you could use a double for loop .\\nThe official answer requires you to have a god-tier understanding of math.\\nI don\\'t see how it is possible for people to solve questions like this blind and during a coding interview "
                    },
                    {
                        "username": "deciduousflame538",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run the outer loop till the length of array starting from 0, and the inner loop from a value equal to j and till the length of array. \\nfor(int i = 0; i < size; ++i)\\nfor(int j = i ; j<size; ++j)"
                    },
                    {
                        "username": "sandipt335",
                        "content": "[@ironmonger1](/ironmonger1) doesnt help either my good sir"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run both loops till end but start the second loop from one place after the initial loop"
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I am solving it by using double for loop only, but i got stuck with till what value i have to run both loops. Could you pls help me with this\\n"
                    },
                    {
                        "username": "jkulanko",
                        "content": "I highly recommend anyone who is serious about mastering leetcode to follow the usaco.guide website.  There's more there than you'll ever use in leetcode but if you enjoy or want to get good at competitive programming I recommend it.  There is a problem exactly like this https://usaco.guide/problems/usaco-595-subsequences-summing-to-sevens/solution.  I remembered this problem and was able to come up with the O(n) solution in minutes.  I've been working through the modules for about a month and my leetcode rating has jumped 150 points"
                    },
                    {
                        "username": "algoacer",
                        "content": "Thanks for this recommendation. Any tips you would like to share for someone going to start doing usaco? Thanks.."
                    },
                    {
                        "username": "user1421n",
                        "content": "To be honnest, it took me sometime to undestand the transition from one idea to another, I think if there is more explanation, it will be better, but it's okay"
                    },
                    {
                        "username": "jkulanko",
                        "content": "[@MaratKhakim](/MaratKhakim)  I recommend going through it level and topic wise. I.E. do the bronze modules first topic by topic. Do problems on each topic until you\\u2019re sick of them or think you\\u2019ve mastered the topic"
                    },
                    {
                        "username": "MaratKhakim",
                        "content": "Thanks.  [@Jacob Kulanko](/jkulanko)How are you studying there? Learning topicwise and solving problems on usaco? Please, share your study techniques"
                    },
                    {
                        "username": "jkulanko",
                        "content": "Here\\u2019s a follow up problem if anyone wants to try a slightly harder but similar problem: https://atcoder.jp/contests/abc164/tasks/abc164_d"
                    },
                    {
                        "username": "Hrushi73",
                        "content": "great share, I am going to follow this problem set\\n"
                    },
                    {
                        "username": "legitroman",
                        "content": "Thanks for the share! It was very helpful."
                    },
                    {
                        "username": "truthsayer_Inshadows",
                        "content": "use a hash map to keep track of the remainder of the running sum of the array modulo k. For each index i in the array, we calculate the running sum from index 0 to i, and find its remainder when divided by k. We then check if the remainder already exists in the hash map. If it does, it means that there is a subarray with a sum that is divisible by k, and we increment the count of subarrays. If the remainder doesn\\'t exist in the hash map, we add it to the hash map with a count of 1.\\n\\n\\n```cpp\\n\\nint subarraySum(vector<int>& nums, int k) {\\n    int count = 0;\\n    int running_sum = 0;\\n    unordered_map<int, int> remainder_count;\\n    remainder_count[0] = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        running_sum += nums[i];\\n        int remainder = running_sum % k;\\n        if (remainder_count.find(remainder) != remainder_count.end()) {\\n            count += remainder_count[remainder];\\n        }\\n        if (remainder_count.find(remainder) == remainder_count.end()) {\\n            remainder_count[remainder] = 1;\\n        } else {\\n            remainder_count[remainder]++;\\n        }\\n    }\\n    return count;\\n}\\n\\n```\\n## Test case dry run:\\nLet\\'s say nums = {4,5,0,-2,-3,1} and k = 5\\n\\nInitialize count = 0, running_sum = 0, remainder_count = {0: 1}\\nIterate through the array, starting at index 0:\\ni = 0, nums[i] = 4, running_sum = 4, remainder = 4 % 5 = 4, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 1, nums[i] = 5, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 2, nums[i] = 0, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 3, nums[i] = -2, running_sum = 7, remainder = 7 % 5 = 2, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 4, nums[i] = -3, running_sum = 4, remainder = 4 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 5, nums[i] = 1, running_sum = 5, remainder = 5 % 5 = 0, remainder in remainder_count, so increment count by 1\\nReturn count = 5\\nSo the output is 5.\\n\\n# Don\\'t leave without upvoting ^_^\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@vinaygottipamula](/vinaygottipamula)\\n plz explain the intiution behind rem<0 then rem+=k."
                    },
                    {
                        "username": "jskipper2020",
                        "content": "how do you know that a repeated remainder means there is +(remainder) in the answer?"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "But the output is 7, and yes it is coming when we run the above code. There is a small mistake in your dry run method..Please note that.\n\nWe are increasing the count value only when we find the remainder in hashtable with the existing hash value (of the remainder) not with 1. \nHope you get it :-)\n\nU also missed this condition in your code\nif(remainder<0)remainder+=k;"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**Bruteforce to Optimization**\nThe naïve bruteforce solution would be - for all possible subarray start and end indexes, calculate the sum. So, the algorithm becomes $O(n^3)$. We can optimize this using the prefix sum idea. $SubarraySum(i,j) = PrefixSum(j) - PrefixSum(i-1)$. This reduces the time complexity to $O(n^2)$.\n\nNow, for this problem,\n$$\nPrefixSum(j) - PrefixSum(i-1) = 0 \\  [modulo \\ k]\n$$\n$$ \n=> PrefixSum(j) = PrefixSum(i-1) \\ [modulo \\ k]\n$$\n\nSo, we can get rid of the loop and count the frequency of the current prefix sum to solve the problem. The final time complexity would be $O(n)$. The only corner case would be negative modulos."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "[@Babu_frik](/Babu_frik) The modulus is negative when the prefix sum is negative. In that case, you have to add `k` to the mod to make it positive. "
                    },
                    {
                        "username": "Babu_frik",
                        "content": "When is it negative modulus? Can you please throw insight on that case?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is an excellent hint and explanation! I always get TLE on all my solutions so this was very helpful. For people trying out this approach, also take note of how to handle $$PrefixSum(0 - 1)$$ for subarrays starting at $$i=0$$. "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Leetcode January TREES -> ARRAYS "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem Statement is simple to understand, but deducing `prefix + currElem % K + K` is a whole different level of problem"
                    },
                    {
                        "username": "prototye",
                        "content": "can you tell me the thought process and in general explanation on how we came up with this prefix + nums[i] % k + k thing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "With brute force approach, we could we could solve 66/73 testcases. After that, I get TLE. Can anyone tell me the approach to optimize it? "
                    },
                    {
                        "username": "taj_1",
                        "content": "[@mayank-01](/mayank-01) \\npublic int subarraysDivByK(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j<nums.length;j++){\\n                int sum = 0;\\n                for(int l=i;l<=j;l++){\\n                    sum+=nums[l];\\n                }\\n                if(sum%k==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "mayank-01",
                        "content": "can anyone share the brute force code."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "You can use a solution in which calculate prefix sums and at every stage calculate remainder with \\'K\\'  and store it in unordered map along with their frequencies Can be done in O(n) time .iI will post solution for this in a while"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Is it supposed to be done in O(n) or O(n^2) ?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) yeah that\\'s the one thing that can always be done. But I need to learn the optimization techniques instead of just copying the solutions every time :("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i passed 68 with O(n^2) now go to solution tab that\\'s what i am going to do"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach:\n* For each index i, count all previous prefix sums in the array which has modulo same as of current prefix sum (at idx i) and add it to result.\n`Use HashTable to store the counts of prefix sum modulo`.\n* Also, for a -ve number num, num%k<0, we have to change it to +ve mod because modulo of a number can lie in the range of 0 to k-1 only.\n\nLet, num = -2, k=3 then `res=(-2)%3=-2`, for changing it to +ve mod add k to res.\nChanging to +ve mod, `-2+3 = 1`, So, `res=(-2)%3=1`.\n\n### Complexity: O(n) time and O(k) space"
                    },
                    {
                        "username": "a_parth",
                        "content": "but why we need to calculate +ve modulo. Why we can\\'t go ahead with -ve modulo?"
                    }
                ]
            },
            {
                "id": 1764565,
                "content": [
                    {
                        "username": "lucyG",
                        "content": "When I tried to solve this problem, I didn\\'t come up with **Prefix Sum** at all.\\n\\nMy question for you guys who thought of using Prefix Sum to solve it is how/why did you know that you gonna use Prefix Sum for it? \\n\\nI could only come up with the following possilbe reasons:\\n1. It looks like a problem that Prefix Sum could help with;\\n2. This is a problem related to Array & Modulo;\\n3. You just have a feeling...\\n\\nReally appreciate it."
                    },
                    {
                        "username": "CodeID99",
                        "content": "Hi, I first solved this problem with O(n**2), then moved to a find a better solution. Since it\\'s asking for a subarray, there is not much I could think of, except sliding window and prefix sum. Sliding window won\\'t work for this problem, so I solved it with prefix sum."
                    },
                    {
                        "username": "akansha_01",
                        "content": "damm true :)\\n"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "[@zarif98sjs](/zarif98sjs) How long is that experience?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, the first thing to see is that constraints are such that n^2 was directly out of scope. Sorting is also out of question since that ruins the subarrays so in a way n.log(n) was also out. With only O(n) complexity possible, there are not much things left apart from prefix sum. Plus having an O(n^2) solution would make this problem a dumb one, so knew in the first minute itself that we cant do without cumulative i.e prefix sum."
                    },
                    {
                        "username": "kandiana",
                        "content": "I figured it from the math point of view + from the algorithms I considered for the previous daily problem?\\nSubarray sum = difference between two prefix sums, it will be divided by k if prefix sums have the same mod k value. Hence I need to count mod k values and then caclulate the number of pairs for each count (for 0: n * (n + 1) / 2, for the rest: n * ( n - 1) / 2)\\n"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "Similar problems. I just recognize the pattern now"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "I guess from the experience of solving similar problems."
                    },
                    {
                        "username": "istewartbinks",
                        "content": "I came up with prefix sum. It\\'s asking for a contiguous subarray sum (mod k), which is easy to get in n^2 time if you have a prefix sum. I\\'ve done problems like this before. If I didn\\'t know what prefix sum was, I wouldn\\'t know how to answer this problem.\\n\\nConsider it pattern matching."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "There is a similar problem. Leetcode 560. Subarray Sum Equals K. Try that. Then you can instantly identify this needs a prefix sum."
                    },
                    {
                        "username": "arghyadas",
                        "content": "The SubArray week is far better than TREE and GRAPH Week\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@cwooldridge](/cwooldridge) \\nThat\\'s the fun of arrays. The answer is in front of you, but you aren\\'t able to identify it."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I disagree, graph question in general have similar solutions and better patterns. I feel subarrays and array questions in general require alot more creativity and have much more clever solutions"
                    },
                    {
                        "username": "mayank-01",
                        "content": "so true..\\uD83D\\uDE02"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "truee......"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "True dat!\\n"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "True\\uD83D\\uDE02"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This would be very easy if you could use a double for loop .\\nThe official answer requires you to have a god-tier understanding of math.\\nI don\\'t see how it is possible for people to solve questions like this blind and during a coding interview "
                    },
                    {
                        "username": "deciduousflame538",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run the outer loop till the length of array starting from 0, and the inner loop from a value equal to j and till the length of array. \\nfor(int i = 0; i < size; ++i)\\nfor(int j = i ; j<size; ++j)"
                    },
                    {
                        "username": "sandipt335",
                        "content": "[@ironmonger1](/ironmonger1) doesnt help either my good sir"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run both loops till end but start the second loop from one place after the initial loop"
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I am solving it by using double for loop only, but i got stuck with till what value i have to run both loops. Could you pls help me with this\\n"
                    },
                    {
                        "username": "jkulanko",
                        "content": "I highly recommend anyone who is serious about mastering leetcode to follow the usaco.guide website.  There's more there than you'll ever use in leetcode but if you enjoy or want to get good at competitive programming I recommend it.  There is a problem exactly like this https://usaco.guide/problems/usaco-595-subsequences-summing-to-sevens/solution.  I remembered this problem and was able to come up with the O(n) solution in minutes.  I've been working through the modules for about a month and my leetcode rating has jumped 150 points"
                    },
                    {
                        "username": "algoacer",
                        "content": "Thanks for this recommendation. Any tips you would like to share for someone going to start doing usaco? Thanks.."
                    },
                    {
                        "username": "user1421n",
                        "content": "To be honnest, it took me sometime to undestand the transition from one idea to another, I think if there is more explanation, it will be better, but it's okay"
                    },
                    {
                        "username": "jkulanko",
                        "content": "[@MaratKhakim](/MaratKhakim)  I recommend going through it level and topic wise. I.E. do the bronze modules first topic by topic. Do problems on each topic until you\\u2019re sick of them or think you\\u2019ve mastered the topic"
                    },
                    {
                        "username": "MaratKhakim",
                        "content": "Thanks.  [@Jacob Kulanko](/jkulanko)How are you studying there? Learning topicwise and solving problems on usaco? Please, share your study techniques"
                    },
                    {
                        "username": "jkulanko",
                        "content": "Here\\u2019s a follow up problem if anyone wants to try a slightly harder but similar problem: https://atcoder.jp/contests/abc164/tasks/abc164_d"
                    },
                    {
                        "username": "Hrushi73",
                        "content": "great share, I am going to follow this problem set\\n"
                    },
                    {
                        "username": "legitroman",
                        "content": "Thanks for the share! It was very helpful."
                    },
                    {
                        "username": "truthsayer_Inshadows",
                        "content": "use a hash map to keep track of the remainder of the running sum of the array modulo k. For each index i in the array, we calculate the running sum from index 0 to i, and find its remainder when divided by k. We then check if the remainder already exists in the hash map. If it does, it means that there is a subarray with a sum that is divisible by k, and we increment the count of subarrays. If the remainder doesn\\'t exist in the hash map, we add it to the hash map with a count of 1.\\n\\n\\n```cpp\\n\\nint subarraySum(vector<int>& nums, int k) {\\n    int count = 0;\\n    int running_sum = 0;\\n    unordered_map<int, int> remainder_count;\\n    remainder_count[0] = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        running_sum += nums[i];\\n        int remainder = running_sum % k;\\n        if (remainder_count.find(remainder) != remainder_count.end()) {\\n            count += remainder_count[remainder];\\n        }\\n        if (remainder_count.find(remainder) == remainder_count.end()) {\\n            remainder_count[remainder] = 1;\\n        } else {\\n            remainder_count[remainder]++;\\n        }\\n    }\\n    return count;\\n}\\n\\n```\\n## Test case dry run:\\nLet\\'s say nums = {4,5,0,-2,-3,1} and k = 5\\n\\nInitialize count = 0, running_sum = 0, remainder_count = {0: 1}\\nIterate through the array, starting at index 0:\\ni = 0, nums[i] = 4, running_sum = 4, remainder = 4 % 5 = 4, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 1, nums[i] = 5, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 2, nums[i] = 0, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 3, nums[i] = -2, running_sum = 7, remainder = 7 % 5 = 2, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 4, nums[i] = -3, running_sum = 4, remainder = 4 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 5, nums[i] = 1, running_sum = 5, remainder = 5 % 5 = 0, remainder in remainder_count, so increment count by 1\\nReturn count = 5\\nSo the output is 5.\\n\\n# Don\\'t leave without upvoting ^_^\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@vinaygottipamula](/vinaygottipamula)\\n plz explain the intiution behind rem<0 then rem+=k."
                    },
                    {
                        "username": "jskipper2020",
                        "content": "how do you know that a repeated remainder means there is +(remainder) in the answer?"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "But the output is 7, and yes it is coming when we run the above code. There is a small mistake in your dry run method..Please note that.\n\nWe are increasing the count value only when we find the remainder in hashtable with the existing hash value (of the remainder) not with 1. \nHope you get it :-)\n\nU also missed this condition in your code\nif(remainder<0)remainder+=k;"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**Bruteforce to Optimization**\nThe naïve bruteforce solution would be - for all possible subarray start and end indexes, calculate the sum. So, the algorithm becomes $O(n^3)$. We can optimize this using the prefix sum idea. $SubarraySum(i,j) = PrefixSum(j) - PrefixSum(i-1)$. This reduces the time complexity to $O(n^2)$.\n\nNow, for this problem,\n$$\nPrefixSum(j) - PrefixSum(i-1) = 0 \\  [modulo \\ k]\n$$\n$$ \n=> PrefixSum(j) = PrefixSum(i-1) \\ [modulo \\ k]\n$$\n\nSo, we can get rid of the loop and count the frequency of the current prefix sum to solve the problem. The final time complexity would be $O(n)$. The only corner case would be negative modulos."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "[@Babu_frik](/Babu_frik) The modulus is negative when the prefix sum is negative. In that case, you have to add `k` to the mod to make it positive. "
                    },
                    {
                        "username": "Babu_frik",
                        "content": "When is it negative modulus? Can you please throw insight on that case?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is an excellent hint and explanation! I always get TLE on all my solutions so this was very helpful. For people trying out this approach, also take note of how to handle $$PrefixSum(0 - 1)$$ for subarrays starting at $$i=0$$. "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Leetcode January TREES -> ARRAYS "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem Statement is simple to understand, but deducing `prefix + currElem % K + K` is a whole different level of problem"
                    },
                    {
                        "username": "prototye",
                        "content": "can you tell me the thought process and in general explanation on how we came up with this prefix + nums[i] % k + k thing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "With brute force approach, we could we could solve 66/73 testcases. After that, I get TLE. Can anyone tell me the approach to optimize it? "
                    },
                    {
                        "username": "taj_1",
                        "content": "[@mayank-01](/mayank-01) \\npublic int subarraysDivByK(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j<nums.length;j++){\\n                int sum = 0;\\n                for(int l=i;l<=j;l++){\\n                    sum+=nums[l];\\n                }\\n                if(sum%k==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "mayank-01",
                        "content": "can anyone share the brute force code."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "You can use a solution in which calculate prefix sums and at every stage calculate remainder with \\'K\\'  and store it in unordered map along with their frequencies Can be done in O(n) time .iI will post solution for this in a while"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Is it supposed to be done in O(n) or O(n^2) ?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) yeah that\\'s the one thing that can always be done. But I need to learn the optimization techniques instead of just copying the solutions every time :("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i passed 68 with O(n^2) now go to solution tab that\\'s what i am going to do"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach:\n* For each index i, count all previous prefix sums in the array which has modulo same as of current prefix sum (at idx i) and add it to result.\n`Use HashTable to store the counts of prefix sum modulo`.\n* Also, for a -ve number num, num%k<0, we have to change it to +ve mod because modulo of a number can lie in the range of 0 to k-1 only.\n\nLet, num = -2, k=3 then `res=(-2)%3=-2`, for changing it to +ve mod add k to res.\nChanging to +ve mod, `-2+3 = 1`, So, `res=(-2)%3=1`.\n\n### Complexity: O(n) time and O(k) space"
                    },
                    {
                        "username": "a_parth",
                        "content": "but why we need to calculate +ve modulo. Why we can\\'t go ahead with -ve modulo?"
                    }
                ]
            },
            {
                "id": 1764050,
                "content": [
                    {
                        "username": "lucyG",
                        "content": "When I tried to solve this problem, I didn\\'t come up with **Prefix Sum** at all.\\n\\nMy question for you guys who thought of using Prefix Sum to solve it is how/why did you know that you gonna use Prefix Sum for it? \\n\\nI could only come up with the following possilbe reasons:\\n1. It looks like a problem that Prefix Sum could help with;\\n2. This is a problem related to Array & Modulo;\\n3. You just have a feeling...\\n\\nReally appreciate it."
                    },
                    {
                        "username": "CodeID99",
                        "content": "Hi, I first solved this problem with O(n**2), then moved to a find a better solution. Since it\\'s asking for a subarray, there is not much I could think of, except sliding window and prefix sum. Sliding window won\\'t work for this problem, so I solved it with prefix sum."
                    },
                    {
                        "username": "akansha_01",
                        "content": "damm true :)\\n"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "[@zarif98sjs](/zarif98sjs) How long is that experience?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, the first thing to see is that constraints are such that n^2 was directly out of scope. Sorting is also out of question since that ruins the subarrays so in a way n.log(n) was also out. With only O(n) complexity possible, there are not much things left apart from prefix sum. Plus having an O(n^2) solution would make this problem a dumb one, so knew in the first minute itself that we cant do without cumulative i.e prefix sum."
                    },
                    {
                        "username": "kandiana",
                        "content": "I figured it from the math point of view + from the algorithms I considered for the previous daily problem?\\nSubarray sum = difference between two prefix sums, it will be divided by k if prefix sums have the same mod k value. Hence I need to count mod k values and then caclulate the number of pairs for each count (for 0: n * (n + 1) / 2, for the rest: n * ( n - 1) / 2)\\n"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "Similar problems. I just recognize the pattern now"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "I guess from the experience of solving similar problems."
                    },
                    {
                        "username": "istewartbinks",
                        "content": "I came up with prefix sum. It\\'s asking for a contiguous subarray sum (mod k), which is easy to get in n^2 time if you have a prefix sum. I\\'ve done problems like this before. If I didn\\'t know what prefix sum was, I wouldn\\'t know how to answer this problem.\\n\\nConsider it pattern matching."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "There is a similar problem. Leetcode 560. Subarray Sum Equals K. Try that. Then you can instantly identify this needs a prefix sum."
                    },
                    {
                        "username": "arghyadas",
                        "content": "The SubArray week is far better than TREE and GRAPH Week\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@cwooldridge](/cwooldridge) \\nThat\\'s the fun of arrays. The answer is in front of you, but you aren\\'t able to identify it."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I disagree, graph question in general have similar solutions and better patterns. I feel subarrays and array questions in general require alot more creativity and have much more clever solutions"
                    },
                    {
                        "username": "mayank-01",
                        "content": "so true..\\uD83D\\uDE02"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "truee......"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "True dat!\\n"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "True\\uD83D\\uDE02"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This would be very easy if you could use a double for loop .\\nThe official answer requires you to have a god-tier understanding of math.\\nI don\\'t see how it is possible for people to solve questions like this blind and during a coding interview "
                    },
                    {
                        "username": "deciduousflame538",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run the outer loop till the length of array starting from 0, and the inner loop from a value equal to j and till the length of array. \\nfor(int i = 0; i < size; ++i)\\nfor(int j = i ; j<size; ++j)"
                    },
                    {
                        "username": "sandipt335",
                        "content": "[@ironmonger1](/ironmonger1) doesnt help either my good sir"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run both loops till end but start the second loop from one place after the initial loop"
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I am solving it by using double for loop only, but i got stuck with till what value i have to run both loops. Could you pls help me with this\\n"
                    },
                    {
                        "username": "jkulanko",
                        "content": "I highly recommend anyone who is serious about mastering leetcode to follow the usaco.guide website.  There's more there than you'll ever use in leetcode but if you enjoy or want to get good at competitive programming I recommend it.  There is a problem exactly like this https://usaco.guide/problems/usaco-595-subsequences-summing-to-sevens/solution.  I remembered this problem and was able to come up with the O(n) solution in minutes.  I've been working through the modules for about a month and my leetcode rating has jumped 150 points"
                    },
                    {
                        "username": "algoacer",
                        "content": "Thanks for this recommendation. Any tips you would like to share for someone going to start doing usaco? Thanks.."
                    },
                    {
                        "username": "user1421n",
                        "content": "To be honnest, it took me sometime to undestand the transition from one idea to another, I think if there is more explanation, it will be better, but it's okay"
                    },
                    {
                        "username": "jkulanko",
                        "content": "[@MaratKhakim](/MaratKhakim)  I recommend going through it level and topic wise. I.E. do the bronze modules first topic by topic. Do problems on each topic until you\\u2019re sick of them or think you\\u2019ve mastered the topic"
                    },
                    {
                        "username": "MaratKhakim",
                        "content": "Thanks.  [@Jacob Kulanko](/jkulanko)How are you studying there? Learning topicwise and solving problems on usaco? Please, share your study techniques"
                    },
                    {
                        "username": "jkulanko",
                        "content": "Here\\u2019s a follow up problem if anyone wants to try a slightly harder but similar problem: https://atcoder.jp/contests/abc164/tasks/abc164_d"
                    },
                    {
                        "username": "Hrushi73",
                        "content": "great share, I am going to follow this problem set\\n"
                    },
                    {
                        "username": "legitroman",
                        "content": "Thanks for the share! It was very helpful."
                    },
                    {
                        "username": "truthsayer_Inshadows",
                        "content": "use a hash map to keep track of the remainder of the running sum of the array modulo k. For each index i in the array, we calculate the running sum from index 0 to i, and find its remainder when divided by k. We then check if the remainder already exists in the hash map. If it does, it means that there is a subarray with a sum that is divisible by k, and we increment the count of subarrays. If the remainder doesn\\'t exist in the hash map, we add it to the hash map with a count of 1.\\n\\n\\n```cpp\\n\\nint subarraySum(vector<int>& nums, int k) {\\n    int count = 0;\\n    int running_sum = 0;\\n    unordered_map<int, int> remainder_count;\\n    remainder_count[0] = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        running_sum += nums[i];\\n        int remainder = running_sum % k;\\n        if (remainder_count.find(remainder) != remainder_count.end()) {\\n            count += remainder_count[remainder];\\n        }\\n        if (remainder_count.find(remainder) == remainder_count.end()) {\\n            remainder_count[remainder] = 1;\\n        } else {\\n            remainder_count[remainder]++;\\n        }\\n    }\\n    return count;\\n}\\n\\n```\\n## Test case dry run:\\nLet\\'s say nums = {4,5,0,-2,-3,1} and k = 5\\n\\nInitialize count = 0, running_sum = 0, remainder_count = {0: 1}\\nIterate through the array, starting at index 0:\\ni = 0, nums[i] = 4, running_sum = 4, remainder = 4 % 5 = 4, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 1, nums[i] = 5, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 2, nums[i] = 0, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 3, nums[i] = -2, running_sum = 7, remainder = 7 % 5 = 2, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 4, nums[i] = -3, running_sum = 4, remainder = 4 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 5, nums[i] = 1, running_sum = 5, remainder = 5 % 5 = 0, remainder in remainder_count, so increment count by 1\\nReturn count = 5\\nSo the output is 5.\\n\\n# Don\\'t leave without upvoting ^_^\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@vinaygottipamula](/vinaygottipamula)\\n plz explain the intiution behind rem<0 then rem+=k."
                    },
                    {
                        "username": "jskipper2020",
                        "content": "how do you know that a repeated remainder means there is +(remainder) in the answer?"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "But the output is 7, and yes it is coming when we run the above code. There is a small mistake in your dry run method..Please note that.\n\nWe are increasing the count value only when we find the remainder in hashtable with the existing hash value (of the remainder) not with 1. \nHope you get it :-)\n\nU also missed this condition in your code\nif(remainder<0)remainder+=k;"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**Bruteforce to Optimization**\nThe naïve bruteforce solution would be - for all possible subarray start and end indexes, calculate the sum. So, the algorithm becomes $O(n^3)$. We can optimize this using the prefix sum idea. $SubarraySum(i,j) = PrefixSum(j) - PrefixSum(i-1)$. This reduces the time complexity to $O(n^2)$.\n\nNow, for this problem,\n$$\nPrefixSum(j) - PrefixSum(i-1) = 0 \\  [modulo \\ k]\n$$\n$$ \n=> PrefixSum(j) = PrefixSum(i-1) \\ [modulo \\ k]\n$$\n\nSo, we can get rid of the loop and count the frequency of the current prefix sum to solve the problem. The final time complexity would be $O(n)$. The only corner case would be negative modulos."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "[@Babu_frik](/Babu_frik) The modulus is negative when the prefix sum is negative. In that case, you have to add `k` to the mod to make it positive. "
                    },
                    {
                        "username": "Babu_frik",
                        "content": "When is it negative modulus? Can you please throw insight on that case?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is an excellent hint and explanation! I always get TLE on all my solutions so this was very helpful. For people trying out this approach, also take note of how to handle $$PrefixSum(0 - 1)$$ for subarrays starting at $$i=0$$. "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Leetcode January TREES -> ARRAYS "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem Statement is simple to understand, but deducing `prefix + currElem % K + K` is a whole different level of problem"
                    },
                    {
                        "username": "prototye",
                        "content": "can you tell me the thought process and in general explanation on how we came up with this prefix + nums[i] % k + k thing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "With brute force approach, we could we could solve 66/73 testcases. After that, I get TLE. Can anyone tell me the approach to optimize it? "
                    },
                    {
                        "username": "taj_1",
                        "content": "[@mayank-01](/mayank-01) \\npublic int subarraysDivByK(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j<nums.length;j++){\\n                int sum = 0;\\n                for(int l=i;l<=j;l++){\\n                    sum+=nums[l];\\n                }\\n                if(sum%k==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "mayank-01",
                        "content": "can anyone share the brute force code."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "You can use a solution in which calculate prefix sums and at every stage calculate remainder with \\'K\\'  and store it in unordered map along with their frequencies Can be done in O(n) time .iI will post solution for this in a while"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Is it supposed to be done in O(n) or O(n^2) ?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) yeah that\\'s the one thing that can always be done. But I need to learn the optimization techniques instead of just copying the solutions every time :("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i passed 68 with O(n^2) now go to solution tab that\\'s what i am going to do"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach:\n* For each index i, count all previous prefix sums in the array which has modulo same as of current prefix sum (at idx i) and add it to result.\n`Use HashTable to store the counts of prefix sum modulo`.\n* Also, for a -ve number num, num%k<0, we have to change it to +ve mod because modulo of a number can lie in the range of 0 to k-1 only.\n\nLet, num = -2, k=3 then `res=(-2)%3=-2`, for changing it to +ve mod add k to res.\nChanging to +ve mod, `-2+3 = 1`, So, `res=(-2)%3=1`.\n\n### Complexity: O(n) time and O(k) space"
                    },
                    {
                        "username": "a_parth",
                        "content": "but why we need to calculate +ve modulo. Why we can\\'t go ahead with -ve modulo?"
                    }
                ]
            },
            {
                "id": 1764031,
                "content": [
                    {
                        "username": "lucyG",
                        "content": "When I tried to solve this problem, I didn\\'t come up with **Prefix Sum** at all.\\n\\nMy question for you guys who thought of using Prefix Sum to solve it is how/why did you know that you gonna use Prefix Sum for it? \\n\\nI could only come up with the following possilbe reasons:\\n1. It looks like a problem that Prefix Sum could help with;\\n2. This is a problem related to Array & Modulo;\\n3. You just have a feeling...\\n\\nReally appreciate it."
                    },
                    {
                        "username": "CodeID99",
                        "content": "Hi, I first solved this problem with O(n**2), then moved to a find a better solution. Since it\\'s asking for a subarray, there is not much I could think of, except sliding window and prefix sum. Sliding window won\\'t work for this problem, so I solved it with prefix sum."
                    },
                    {
                        "username": "akansha_01",
                        "content": "damm true :)\\n"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "[@zarif98sjs](/zarif98sjs) How long is that experience?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, the first thing to see is that constraints are such that n^2 was directly out of scope. Sorting is also out of question since that ruins the subarrays so in a way n.log(n) was also out. With only O(n) complexity possible, there are not much things left apart from prefix sum. Plus having an O(n^2) solution would make this problem a dumb one, so knew in the first minute itself that we cant do without cumulative i.e prefix sum."
                    },
                    {
                        "username": "kandiana",
                        "content": "I figured it from the math point of view + from the algorithms I considered for the previous daily problem?\\nSubarray sum = difference between two prefix sums, it will be divided by k if prefix sums have the same mod k value. Hence I need to count mod k values and then caclulate the number of pairs for each count (for 0: n * (n + 1) / 2, for the rest: n * ( n - 1) / 2)\\n"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "Similar problems. I just recognize the pattern now"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "I guess from the experience of solving similar problems."
                    },
                    {
                        "username": "istewartbinks",
                        "content": "I came up with prefix sum. It\\'s asking for a contiguous subarray sum (mod k), which is easy to get in n^2 time if you have a prefix sum. I\\'ve done problems like this before. If I didn\\'t know what prefix sum was, I wouldn\\'t know how to answer this problem.\\n\\nConsider it pattern matching."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "There is a similar problem. Leetcode 560. Subarray Sum Equals K. Try that. Then you can instantly identify this needs a prefix sum."
                    },
                    {
                        "username": "arghyadas",
                        "content": "The SubArray week is far better than TREE and GRAPH Week\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@cwooldridge](/cwooldridge) \\nThat\\'s the fun of arrays. The answer is in front of you, but you aren\\'t able to identify it."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I disagree, graph question in general have similar solutions and better patterns. I feel subarrays and array questions in general require alot more creativity and have much more clever solutions"
                    },
                    {
                        "username": "mayank-01",
                        "content": "so true..\\uD83D\\uDE02"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "truee......"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "True dat!\\n"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "True\\uD83D\\uDE02"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This would be very easy if you could use a double for loop .\\nThe official answer requires you to have a god-tier understanding of math.\\nI don\\'t see how it is possible for people to solve questions like this blind and during a coding interview "
                    },
                    {
                        "username": "deciduousflame538",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run the outer loop till the length of array starting from 0, and the inner loop from a value equal to j and till the length of array. \\nfor(int i = 0; i < size; ++i)\\nfor(int j = i ; j<size; ++j)"
                    },
                    {
                        "username": "sandipt335",
                        "content": "[@ironmonger1](/ironmonger1) doesnt help either my good sir"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run both loops till end but start the second loop from one place after the initial loop"
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I am solving it by using double for loop only, but i got stuck with till what value i have to run both loops. Could you pls help me with this\\n"
                    },
                    {
                        "username": "jkulanko",
                        "content": "I highly recommend anyone who is serious about mastering leetcode to follow the usaco.guide website.  There's more there than you'll ever use in leetcode but if you enjoy or want to get good at competitive programming I recommend it.  There is a problem exactly like this https://usaco.guide/problems/usaco-595-subsequences-summing-to-sevens/solution.  I remembered this problem and was able to come up with the O(n) solution in minutes.  I've been working through the modules for about a month and my leetcode rating has jumped 150 points"
                    },
                    {
                        "username": "algoacer",
                        "content": "Thanks for this recommendation. Any tips you would like to share for someone going to start doing usaco? Thanks.."
                    },
                    {
                        "username": "user1421n",
                        "content": "To be honnest, it took me sometime to undestand the transition from one idea to another, I think if there is more explanation, it will be better, but it's okay"
                    },
                    {
                        "username": "jkulanko",
                        "content": "[@MaratKhakim](/MaratKhakim)  I recommend going through it level and topic wise. I.E. do the bronze modules first topic by topic. Do problems on each topic until you\\u2019re sick of them or think you\\u2019ve mastered the topic"
                    },
                    {
                        "username": "MaratKhakim",
                        "content": "Thanks.  [@Jacob Kulanko](/jkulanko)How are you studying there? Learning topicwise and solving problems on usaco? Please, share your study techniques"
                    },
                    {
                        "username": "jkulanko",
                        "content": "Here\\u2019s a follow up problem if anyone wants to try a slightly harder but similar problem: https://atcoder.jp/contests/abc164/tasks/abc164_d"
                    },
                    {
                        "username": "Hrushi73",
                        "content": "great share, I am going to follow this problem set\\n"
                    },
                    {
                        "username": "legitroman",
                        "content": "Thanks for the share! It was very helpful."
                    },
                    {
                        "username": "truthsayer_Inshadows",
                        "content": "use a hash map to keep track of the remainder of the running sum of the array modulo k. For each index i in the array, we calculate the running sum from index 0 to i, and find its remainder when divided by k. We then check if the remainder already exists in the hash map. If it does, it means that there is a subarray with a sum that is divisible by k, and we increment the count of subarrays. If the remainder doesn\\'t exist in the hash map, we add it to the hash map with a count of 1.\\n\\n\\n```cpp\\n\\nint subarraySum(vector<int>& nums, int k) {\\n    int count = 0;\\n    int running_sum = 0;\\n    unordered_map<int, int> remainder_count;\\n    remainder_count[0] = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        running_sum += nums[i];\\n        int remainder = running_sum % k;\\n        if (remainder_count.find(remainder) != remainder_count.end()) {\\n            count += remainder_count[remainder];\\n        }\\n        if (remainder_count.find(remainder) == remainder_count.end()) {\\n            remainder_count[remainder] = 1;\\n        } else {\\n            remainder_count[remainder]++;\\n        }\\n    }\\n    return count;\\n}\\n\\n```\\n## Test case dry run:\\nLet\\'s say nums = {4,5,0,-2,-3,1} and k = 5\\n\\nInitialize count = 0, running_sum = 0, remainder_count = {0: 1}\\nIterate through the array, starting at index 0:\\ni = 0, nums[i] = 4, running_sum = 4, remainder = 4 % 5 = 4, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 1, nums[i] = 5, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 2, nums[i] = 0, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 3, nums[i] = -2, running_sum = 7, remainder = 7 % 5 = 2, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 4, nums[i] = -3, running_sum = 4, remainder = 4 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 5, nums[i] = 1, running_sum = 5, remainder = 5 % 5 = 0, remainder in remainder_count, so increment count by 1\\nReturn count = 5\\nSo the output is 5.\\n\\n# Don\\'t leave without upvoting ^_^\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@vinaygottipamula](/vinaygottipamula)\\n plz explain the intiution behind rem<0 then rem+=k."
                    },
                    {
                        "username": "jskipper2020",
                        "content": "how do you know that a repeated remainder means there is +(remainder) in the answer?"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "But the output is 7, and yes it is coming when we run the above code. There is a small mistake in your dry run method..Please note that.\n\nWe are increasing the count value only when we find the remainder in hashtable with the existing hash value (of the remainder) not with 1. \nHope you get it :-)\n\nU also missed this condition in your code\nif(remainder<0)remainder+=k;"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**Bruteforce to Optimization**\nThe naïve bruteforce solution would be - for all possible subarray start and end indexes, calculate the sum. So, the algorithm becomes $O(n^3)$. We can optimize this using the prefix sum idea. $SubarraySum(i,j) = PrefixSum(j) - PrefixSum(i-1)$. This reduces the time complexity to $O(n^2)$.\n\nNow, for this problem,\n$$\nPrefixSum(j) - PrefixSum(i-1) = 0 \\  [modulo \\ k]\n$$\n$$ \n=> PrefixSum(j) = PrefixSum(i-1) \\ [modulo \\ k]\n$$\n\nSo, we can get rid of the loop and count the frequency of the current prefix sum to solve the problem. The final time complexity would be $O(n)$. The only corner case would be negative modulos."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "[@Babu_frik](/Babu_frik) The modulus is negative when the prefix sum is negative. In that case, you have to add `k` to the mod to make it positive. "
                    },
                    {
                        "username": "Babu_frik",
                        "content": "When is it negative modulus? Can you please throw insight on that case?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is an excellent hint and explanation! I always get TLE on all my solutions so this was very helpful. For people trying out this approach, also take note of how to handle $$PrefixSum(0 - 1)$$ for subarrays starting at $$i=0$$. "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Leetcode January TREES -> ARRAYS "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem Statement is simple to understand, but deducing `prefix + currElem % K + K` is a whole different level of problem"
                    },
                    {
                        "username": "prototye",
                        "content": "can you tell me the thought process and in general explanation on how we came up with this prefix + nums[i] % k + k thing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "With brute force approach, we could we could solve 66/73 testcases. After that, I get TLE. Can anyone tell me the approach to optimize it? "
                    },
                    {
                        "username": "taj_1",
                        "content": "[@mayank-01](/mayank-01) \\npublic int subarraysDivByK(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j<nums.length;j++){\\n                int sum = 0;\\n                for(int l=i;l<=j;l++){\\n                    sum+=nums[l];\\n                }\\n                if(sum%k==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "mayank-01",
                        "content": "can anyone share the brute force code."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "You can use a solution in which calculate prefix sums and at every stage calculate remainder with \\'K\\'  and store it in unordered map along with their frequencies Can be done in O(n) time .iI will post solution for this in a while"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Is it supposed to be done in O(n) or O(n^2) ?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) yeah that\\'s the one thing that can always be done. But I need to learn the optimization techniques instead of just copying the solutions every time :("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i passed 68 with O(n^2) now go to solution tab that\\'s what i am going to do"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach:\n* For each index i, count all previous prefix sums in the array which has modulo same as of current prefix sum (at idx i) and add it to result.\n`Use HashTable to store the counts of prefix sum modulo`.\n* Also, for a -ve number num, num%k<0, we have to change it to +ve mod because modulo of a number can lie in the range of 0 to k-1 only.\n\nLet, num = -2, k=3 then `res=(-2)%3=-2`, for changing it to +ve mod add k to res.\nChanging to +ve mod, `-2+3 = 1`, So, `res=(-2)%3=1`.\n\n### Complexity: O(n) time and O(k) space"
                    },
                    {
                        "username": "a_parth",
                        "content": "but why we need to calculate +ve modulo. Why we can\\'t go ahead with -ve modulo?"
                    }
                ]
            },
            {
                "id": 1764476,
                "content": [
                    {
                        "username": "lucyG",
                        "content": "When I tried to solve this problem, I didn\\'t come up with **Prefix Sum** at all.\\n\\nMy question for you guys who thought of using Prefix Sum to solve it is how/why did you know that you gonna use Prefix Sum for it? \\n\\nI could only come up with the following possilbe reasons:\\n1. It looks like a problem that Prefix Sum could help with;\\n2. This is a problem related to Array & Modulo;\\n3. You just have a feeling...\\n\\nReally appreciate it."
                    },
                    {
                        "username": "CodeID99",
                        "content": "Hi, I first solved this problem with O(n**2), then moved to a find a better solution. Since it\\'s asking for a subarray, there is not much I could think of, except sliding window and prefix sum. Sliding window won\\'t work for this problem, so I solved it with prefix sum."
                    },
                    {
                        "username": "akansha_01",
                        "content": "damm true :)\\n"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "[@zarif98sjs](/zarif98sjs) How long is that experience?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, the first thing to see is that constraints are such that n^2 was directly out of scope. Sorting is also out of question since that ruins the subarrays so in a way n.log(n) was also out. With only O(n) complexity possible, there are not much things left apart from prefix sum. Plus having an O(n^2) solution would make this problem a dumb one, so knew in the first minute itself that we cant do without cumulative i.e prefix sum."
                    },
                    {
                        "username": "kandiana",
                        "content": "I figured it from the math point of view + from the algorithms I considered for the previous daily problem?\\nSubarray sum = difference between two prefix sums, it will be divided by k if prefix sums have the same mod k value. Hence I need to count mod k values and then caclulate the number of pairs for each count (for 0: n * (n + 1) / 2, for the rest: n * ( n - 1) / 2)\\n"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "Similar problems. I just recognize the pattern now"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "I guess from the experience of solving similar problems."
                    },
                    {
                        "username": "istewartbinks",
                        "content": "I came up with prefix sum. It\\'s asking for a contiguous subarray sum (mod k), which is easy to get in n^2 time if you have a prefix sum. I\\'ve done problems like this before. If I didn\\'t know what prefix sum was, I wouldn\\'t know how to answer this problem.\\n\\nConsider it pattern matching."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "There is a similar problem. Leetcode 560. Subarray Sum Equals K. Try that. Then you can instantly identify this needs a prefix sum."
                    },
                    {
                        "username": "arghyadas",
                        "content": "The SubArray week is far better than TREE and GRAPH Week\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@cwooldridge](/cwooldridge) \\nThat\\'s the fun of arrays. The answer is in front of you, but you aren\\'t able to identify it."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I disagree, graph question in general have similar solutions and better patterns. I feel subarrays and array questions in general require alot more creativity and have much more clever solutions"
                    },
                    {
                        "username": "mayank-01",
                        "content": "so true..\\uD83D\\uDE02"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "truee......"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "True dat!\\n"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "True\\uD83D\\uDE02"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This would be very easy if you could use a double for loop .\\nThe official answer requires you to have a god-tier understanding of math.\\nI don\\'t see how it is possible for people to solve questions like this blind and during a coding interview "
                    },
                    {
                        "username": "deciduousflame538",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run the outer loop till the length of array starting from 0, and the inner loop from a value equal to j and till the length of array. \\nfor(int i = 0; i < size; ++i)\\nfor(int j = i ; j<size; ++j)"
                    },
                    {
                        "username": "sandipt335",
                        "content": "[@ironmonger1](/ironmonger1) doesnt help either my good sir"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run both loops till end but start the second loop from one place after the initial loop"
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I am solving it by using double for loop only, but i got stuck with till what value i have to run both loops. Could you pls help me with this\\n"
                    },
                    {
                        "username": "jkulanko",
                        "content": "I highly recommend anyone who is serious about mastering leetcode to follow the usaco.guide website.  There's more there than you'll ever use in leetcode but if you enjoy or want to get good at competitive programming I recommend it.  There is a problem exactly like this https://usaco.guide/problems/usaco-595-subsequences-summing-to-sevens/solution.  I remembered this problem and was able to come up with the O(n) solution in minutes.  I've been working through the modules for about a month and my leetcode rating has jumped 150 points"
                    },
                    {
                        "username": "algoacer",
                        "content": "Thanks for this recommendation. Any tips you would like to share for someone going to start doing usaco? Thanks.."
                    },
                    {
                        "username": "user1421n",
                        "content": "To be honnest, it took me sometime to undestand the transition from one idea to another, I think if there is more explanation, it will be better, but it's okay"
                    },
                    {
                        "username": "jkulanko",
                        "content": "[@MaratKhakim](/MaratKhakim)  I recommend going through it level and topic wise. I.E. do the bronze modules first topic by topic. Do problems on each topic until you\\u2019re sick of them or think you\\u2019ve mastered the topic"
                    },
                    {
                        "username": "MaratKhakim",
                        "content": "Thanks.  [@Jacob Kulanko](/jkulanko)How are you studying there? Learning topicwise and solving problems on usaco? Please, share your study techniques"
                    },
                    {
                        "username": "jkulanko",
                        "content": "Here\\u2019s a follow up problem if anyone wants to try a slightly harder but similar problem: https://atcoder.jp/contests/abc164/tasks/abc164_d"
                    },
                    {
                        "username": "Hrushi73",
                        "content": "great share, I am going to follow this problem set\\n"
                    },
                    {
                        "username": "legitroman",
                        "content": "Thanks for the share! It was very helpful."
                    },
                    {
                        "username": "truthsayer_Inshadows",
                        "content": "use a hash map to keep track of the remainder of the running sum of the array modulo k. For each index i in the array, we calculate the running sum from index 0 to i, and find its remainder when divided by k. We then check if the remainder already exists in the hash map. If it does, it means that there is a subarray with a sum that is divisible by k, and we increment the count of subarrays. If the remainder doesn\\'t exist in the hash map, we add it to the hash map with a count of 1.\\n\\n\\n```cpp\\n\\nint subarraySum(vector<int>& nums, int k) {\\n    int count = 0;\\n    int running_sum = 0;\\n    unordered_map<int, int> remainder_count;\\n    remainder_count[0] = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        running_sum += nums[i];\\n        int remainder = running_sum % k;\\n        if (remainder_count.find(remainder) != remainder_count.end()) {\\n            count += remainder_count[remainder];\\n        }\\n        if (remainder_count.find(remainder) == remainder_count.end()) {\\n            remainder_count[remainder] = 1;\\n        } else {\\n            remainder_count[remainder]++;\\n        }\\n    }\\n    return count;\\n}\\n\\n```\\n## Test case dry run:\\nLet\\'s say nums = {4,5,0,-2,-3,1} and k = 5\\n\\nInitialize count = 0, running_sum = 0, remainder_count = {0: 1}\\nIterate through the array, starting at index 0:\\ni = 0, nums[i] = 4, running_sum = 4, remainder = 4 % 5 = 4, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 1, nums[i] = 5, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 2, nums[i] = 0, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 3, nums[i] = -2, running_sum = 7, remainder = 7 % 5 = 2, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 4, nums[i] = -3, running_sum = 4, remainder = 4 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 5, nums[i] = 1, running_sum = 5, remainder = 5 % 5 = 0, remainder in remainder_count, so increment count by 1\\nReturn count = 5\\nSo the output is 5.\\n\\n# Don\\'t leave without upvoting ^_^\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@vinaygottipamula](/vinaygottipamula)\\n plz explain the intiution behind rem<0 then rem+=k."
                    },
                    {
                        "username": "jskipper2020",
                        "content": "how do you know that a repeated remainder means there is +(remainder) in the answer?"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "But the output is 7, and yes it is coming when we run the above code. There is a small mistake in your dry run method..Please note that.\n\nWe are increasing the count value only when we find the remainder in hashtable with the existing hash value (of the remainder) not with 1. \nHope you get it :-)\n\nU also missed this condition in your code\nif(remainder<0)remainder+=k;"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**Bruteforce to Optimization**\nThe naïve bruteforce solution would be - for all possible subarray start and end indexes, calculate the sum. So, the algorithm becomes $O(n^3)$. We can optimize this using the prefix sum idea. $SubarraySum(i,j) = PrefixSum(j) - PrefixSum(i-1)$. This reduces the time complexity to $O(n^2)$.\n\nNow, for this problem,\n$$\nPrefixSum(j) - PrefixSum(i-1) = 0 \\  [modulo \\ k]\n$$\n$$ \n=> PrefixSum(j) = PrefixSum(i-1) \\ [modulo \\ k]\n$$\n\nSo, we can get rid of the loop and count the frequency of the current prefix sum to solve the problem. The final time complexity would be $O(n)$. The only corner case would be negative modulos."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "[@Babu_frik](/Babu_frik) The modulus is negative when the prefix sum is negative. In that case, you have to add `k` to the mod to make it positive. "
                    },
                    {
                        "username": "Babu_frik",
                        "content": "When is it negative modulus? Can you please throw insight on that case?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is an excellent hint and explanation! I always get TLE on all my solutions so this was very helpful. For people trying out this approach, also take note of how to handle $$PrefixSum(0 - 1)$$ for subarrays starting at $$i=0$$. "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Leetcode January TREES -> ARRAYS "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem Statement is simple to understand, but deducing `prefix + currElem % K + K` is a whole different level of problem"
                    },
                    {
                        "username": "prototye",
                        "content": "can you tell me the thought process and in general explanation on how we came up with this prefix + nums[i] % k + k thing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "With brute force approach, we could we could solve 66/73 testcases. After that, I get TLE. Can anyone tell me the approach to optimize it? "
                    },
                    {
                        "username": "taj_1",
                        "content": "[@mayank-01](/mayank-01) \\npublic int subarraysDivByK(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j<nums.length;j++){\\n                int sum = 0;\\n                for(int l=i;l<=j;l++){\\n                    sum+=nums[l];\\n                }\\n                if(sum%k==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "mayank-01",
                        "content": "can anyone share the brute force code."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "You can use a solution in which calculate prefix sums and at every stage calculate remainder with \\'K\\'  and store it in unordered map along with their frequencies Can be done in O(n) time .iI will post solution for this in a while"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Is it supposed to be done in O(n) or O(n^2) ?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) yeah that\\'s the one thing that can always be done. But I need to learn the optimization techniques instead of just copying the solutions every time :("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i passed 68 with O(n^2) now go to solution tab that\\'s what i am going to do"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach:\n* For each index i, count all previous prefix sums in the array which has modulo same as of current prefix sum (at idx i) and add it to result.\n`Use HashTable to store the counts of prefix sum modulo`.\n* Also, for a -ve number num, num%k<0, we have to change it to +ve mod because modulo of a number can lie in the range of 0 to k-1 only.\n\nLet, num = -2, k=3 then `res=(-2)%3=-2`, for changing it to +ve mod add k to res.\nChanging to +ve mod, `-2+3 = 1`, So, `res=(-2)%3=1`.\n\n### Complexity: O(n) time and O(k) space"
                    },
                    {
                        "username": "a_parth",
                        "content": "but why we need to calculate +ve modulo. Why we can\\'t go ahead with -ve modulo?"
                    }
                ]
            },
            {
                "id": 1764355,
                "content": [
                    {
                        "username": "lucyG",
                        "content": "When I tried to solve this problem, I didn\\'t come up with **Prefix Sum** at all.\\n\\nMy question for you guys who thought of using Prefix Sum to solve it is how/why did you know that you gonna use Prefix Sum for it? \\n\\nI could only come up with the following possilbe reasons:\\n1. It looks like a problem that Prefix Sum could help with;\\n2. This is a problem related to Array & Modulo;\\n3. You just have a feeling...\\n\\nReally appreciate it."
                    },
                    {
                        "username": "CodeID99",
                        "content": "Hi, I first solved this problem with O(n**2), then moved to a find a better solution. Since it\\'s asking for a subarray, there is not much I could think of, except sliding window and prefix sum. Sliding window won\\'t work for this problem, so I solved it with prefix sum."
                    },
                    {
                        "username": "akansha_01",
                        "content": "damm true :)\\n"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "[@zarif98sjs](/zarif98sjs) How long is that experience?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, the first thing to see is that constraints are such that n^2 was directly out of scope. Sorting is also out of question since that ruins the subarrays so in a way n.log(n) was also out. With only O(n) complexity possible, there are not much things left apart from prefix sum. Plus having an O(n^2) solution would make this problem a dumb one, so knew in the first minute itself that we cant do without cumulative i.e prefix sum."
                    },
                    {
                        "username": "kandiana",
                        "content": "I figured it from the math point of view + from the algorithms I considered for the previous daily problem?\\nSubarray sum = difference between two prefix sums, it will be divided by k if prefix sums have the same mod k value. Hence I need to count mod k values and then caclulate the number of pairs for each count (for 0: n * (n + 1) / 2, for the rest: n * ( n - 1) / 2)\\n"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "Similar problems. I just recognize the pattern now"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "I guess from the experience of solving similar problems."
                    },
                    {
                        "username": "istewartbinks",
                        "content": "I came up with prefix sum. It\\'s asking for a contiguous subarray sum (mod k), which is easy to get in n^2 time if you have a prefix sum. I\\'ve done problems like this before. If I didn\\'t know what prefix sum was, I wouldn\\'t know how to answer this problem.\\n\\nConsider it pattern matching."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "There is a similar problem. Leetcode 560. Subarray Sum Equals K. Try that. Then you can instantly identify this needs a prefix sum."
                    },
                    {
                        "username": "arghyadas",
                        "content": "The SubArray week is far better than TREE and GRAPH Week\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@cwooldridge](/cwooldridge) \\nThat\\'s the fun of arrays. The answer is in front of you, but you aren\\'t able to identify it."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I disagree, graph question in general have similar solutions and better patterns. I feel subarrays and array questions in general require alot more creativity and have much more clever solutions"
                    },
                    {
                        "username": "mayank-01",
                        "content": "so true..\\uD83D\\uDE02"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "truee......"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "True dat!\\n"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "True\\uD83D\\uDE02"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This would be very easy if you could use a double for loop .\\nThe official answer requires you to have a god-tier understanding of math.\\nI don\\'t see how it is possible for people to solve questions like this blind and during a coding interview "
                    },
                    {
                        "username": "deciduousflame538",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run the outer loop till the length of array starting from 0, and the inner loop from a value equal to j and till the length of array. \\nfor(int i = 0; i < size; ++i)\\nfor(int j = i ; j<size; ++j)"
                    },
                    {
                        "username": "sandipt335",
                        "content": "[@ironmonger1](/ironmonger1) doesnt help either my good sir"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run both loops till end but start the second loop from one place after the initial loop"
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I am solving it by using double for loop only, but i got stuck with till what value i have to run both loops. Could you pls help me with this\\n"
                    },
                    {
                        "username": "jkulanko",
                        "content": "I highly recommend anyone who is serious about mastering leetcode to follow the usaco.guide website.  There's more there than you'll ever use in leetcode but if you enjoy or want to get good at competitive programming I recommend it.  There is a problem exactly like this https://usaco.guide/problems/usaco-595-subsequences-summing-to-sevens/solution.  I remembered this problem and was able to come up with the O(n) solution in minutes.  I've been working through the modules for about a month and my leetcode rating has jumped 150 points"
                    },
                    {
                        "username": "algoacer",
                        "content": "Thanks for this recommendation. Any tips you would like to share for someone going to start doing usaco? Thanks.."
                    },
                    {
                        "username": "user1421n",
                        "content": "To be honnest, it took me sometime to undestand the transition from one idea to another, I think if there is more explanation, it will be better, but it's okay"
                    },
                    {
                        "username": "jkulanko",
                        "content": "[@MaratKhakim](/MaratKhakim)  I recommend going through it level and topic wise. I.E. do the bronze modules first topic by topic. Do problems on each topic until you\\u2019re sick of them or think you\\u2019ve mastered the topic"
                    },
                    {
                        "username": "MaratKhakim",
                        "content": "Thanks.  [@Jacob Kulanko](/jkulanko)How are you studying there? Learning topicwise and solving problems on usaco? Please, share your study techniques"
                    },
                    {
                        "username": "jkulanko",
                        "content": "Here\\u2019s a follow up problem if anyone wants to try a slightly harder but similar problem: https://atcoder.jp/contests/abc164/tasks/abc164_d"
                    },
                    {
                        "username": "Hrushi73",
                        "content": "great share, I am going to follow this problem set\\n"
                    },
                    {
                        "username": "legitroman",
                        "content": "Thanks for the share! It was very helpful."
                    },
                    {
                        "username": "truthsayer_Inshadows",
                        "content": "use a hash map to keep track of the remainder of the running sum of the array modulo k. For each index i in the array, we calculate the running sum from index 0 to i, and find its remainder when divided by k. We then check if the remainder already exists in the hash map. If it does, it means that there is a subarray with a sum that is divisible by k, and we increment the count of subarrays. If the remainder doesn\\'t exist in the hash map, we add it to the hash map with a count of 1.\\n\\n\\n```cpp\\n\\nint subarraySum(vector<int>& nums, int k) {\\n    int count = 0;\\n    int running_sum = 0;\\n    unordered_map<int, int> remainder_count;\\n    remainder_count[0] = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        running_sum += nums[i];\\n        int remainder = running_sum % k;\\n        if (remainder_count.find(remainder) != remainder_count.end()) {\\n            count += remainder_count[remainder];\\n        }\\n        if (remainder_count.find(remainder) == remainder_count.end()) {\\n            remainder_count[remainder] = 1;\\n        } else {\\n            remainder_count[remainder]++;\\n        }\\n    }\\n    return count;\\n}\\n\\n```\\n## Test case dry run:\\nLet\\'s say nums = {4,5,0,-2,-3,1} and k = 5\\n\\nInitialize count = 0, running_sum = 0, remainder_count = {0: 1}\\nIterate through the array, starting at index 0:\\ni = 0, nums[i] = 4, running_sum = 4, remainder = 4 % 5 = 4, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 1, nums[i] = 5, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 2, nums[i] = 0, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 3, nums[i] = -2, running_sum = 7, remainder = 7 % 5 = 2, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 4, nums[i] = -3, running_sum = 4, remainder = 4 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 5, nums[i] = 1, running_sum = 5, remainder = 5 % 5 = 0, remainder in remainder_count, so increment count by 1\\nReturn count = 5\\nSo the output is 5.\\n\\n# Don\\'t leave without upvoting ^_^\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@vinaygottipamula](/vinaygottipamula)\\n plz explain the intiution behind rem<0 then rem+=k."
                    },
                    {
                        "username": "jskipper2020",
                        "content": "how do you know that a repeated remainder means there is +(remainder) in the answer?"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "But the output is 7, and yes it is coming when we run the above code. There is a small mistake in your dry run method..Please note that.\n\nWe are increasing the count value only when we find the remainder in hashtable with the existing hash value (of the remainder) not with 1. \nHope you get it :-)\n\nU also missed this condition in your code\nif(remainder<0)remainder+=k;"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**Bruteforce to Optimization**\nThe naïve bruteforce solution would be - for all possible subarray start and end indexes, calculate the sum. So, the algorithm becomes $O(n^3)$. We can optimize this using the prefix sum idea. $SubarraySum(i,j) = PrefixSum(j) - PrefixSum(i-1)$. This reduces the time complexity to $O(n^2)$.\n\nNow, for this problem,\n$$\nPrefixSum(j) - PrefixSum(i-1) = 0 \\  [modulo \\ k]\n$$\n$$ \n=> PrefixSum(j) = PrefixSum(i-1) \\ [modulo \\ k]\n$$\n\nSo, we can get rid of the loop and count the frequency of the current prefix sum to solve the problem. The final time complexity would be $O(n)$. The only corner case would be negative modulos."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "[@Babu_frik](/Babu_frik) The modulus is negative when the prefix sum is negative. In that case, you have to add `k` to the mod to make it positive. "
                    },
                    {
                        "username": "Babu_frik",
                        "content": "When is it negative modulus? Can you please throw insight on that case?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is an excellent hint and explanation! I always get TLE on all my solutions so this was very helpful. For people trying out this approach, also take note of how to handle $$PrefixSum(0 - 1)$$ for subarrays starting at $$i=0$$. "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Leetcode January TREES -> ARRAYS "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem Statement is simple to understand, but deducing `prefix + currElem % K + K` is a whole different level of problem"
                    },
                    {
                        "username": "prototye",
                        "content": "can you tell me the thought process and in general explanation on how we came up with this prefix + nums[i] % k + k thing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "With brute force approach, we could we could solve 66/73 testcases. After that, I get TLE. Can anyone tell me the approach to optimize it? "
                    },
                    {
                        "username": "taj_1",
                        "content": "[@mayank-01](/mayank-01) \\npublic int subarraysDivByK(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j<nums.length;j++){\\n                int sum = 0;\\n                for(int l=i;l<=j;l++){\\n                    sum+=nums[l];\\n                }\\n                if(sum%k==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "mayank-01",
                        "content": "can anyone share the brute force code."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "You can use a solution in which calculate prefix sums and at every stage calculate remainder with \\'K\\'  and store it in unordered map along with their frequencies Can be done in O(n) time .iI will post solution for this in a while"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Is it supposed to be done in O(n) or O(n^2) ?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) yeah that\\'s the one thing that can always be done. But I need to learn the optimization techniques instead of just copying the solutions every time :("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i passed 68 with O(n^2) now go to solution tab that\\'s what i am going to do"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach:\n* For each index i, count all previous prefix sums in the array which has modulo same as of current prefix sum (at idx i) and add it to result.\n`Use HashTable to store the counts of prefix sum modulo`.\n* Also, for a -ve number num, num%k<0, we have to change it to +ve mod because modulo of a number can lie in the range of 0 to k-1 only.\n\nLet, num = -2, k=3 then `res=(-2)%3=-2`, for changing it to +ve mod add k to res.\nChanging to +ve mod, `-2+3 = 1`, So, `res=(-2)%3=1`.\n\n### Complexity: O(n) time and O(k) space"
                    },
                    {
                        "username": "a_parth",
                        "content": "but why we need to calculate +ve modulo. Why we can\\'t go ahead with -ve modulo?"
                    }
                ]
            },
            {
                "id": 1764236,
                "content": [
                    {
                        "username": "lucyG",
                        "content": "When I tried to solve this problem, I didn\\'t come up with **Prefix Sum** at all.\\n\\nMy question for you guys who thought of using Prefix Sum to solve it is how/why did you know that you gonna use Prefix Sum for it? \\n\\nI could only come up with the following possilbe reasons:\\n1. It looks like a problem that Prefix Sum could help with;\\n2. This is a problem related to Array & Modulo;\\n3. You just have a feeling...\\n\\nReally appreciate it."
                    },
                    {
                        "username": "CodeID99",
                        "content": "Hi, I first solved this problem with O(n**2), then moved to a find a better solution. Since it\\'s asking for a subarray, there is not much I could think of, except sliding window and prefix sum. Sliding window won\\'t work for this problem, so I solved it with prefix sum."
                    },
                    {
                        "username": "akansha_01",
                        "content": "damm true :)\\n"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "[@zarif98sjs](/zarif98sjs) How long is that experience?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, the first thing to see is that constraints are such that n^2 was directly out of scope. Sorting is also out of question since that ruins the subarrays so in a way n.log(n) was also out. With only O(n) complexity possible, there are not much things left apart from prefix sum. Plus having an O(n^2) solution would make this problem a dumb one, so knew in the first minute itself that we cant do without cumulative i.e prefix sum."
                    },
                    {
                        "username": "kandiana",
                        "content": "I figured it from the math point of view + from the algorithms I considered for the previous daily problem?\\nSubarray sum = difference between two prefix sums, it will be divided by k if prefix sums have the same mod k value. Hence I need to count mod k values and then caclulate the number of pairs for each count (for 0: n * (n + 1) / 2, for the rest: n * ( n - 1) / 2)\\n"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "Similar problems. I just recognize the pattern now"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "I guess from the experience of solving similar problems."
                    },
                    {
                        "username": "istewartbinks",
                        "content": "I came up with prefix sum. It\\'s asking for a contiguous subarray sum (mod k), which is easy to get in n^2 time if you have a prefix sum. I\\'ve done problems like this before. If I didn\\'t know what prefix sum was, I wouldn\\'t know how to answer this problem.\\n\\nConsider it pattern matching."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "There is a similar problem. Leetcode 560. Subarray Sum Equals K. Try that. Then you can instantly identify this needs a prefix sum."
                    },
                    {
                        "username": "arghyadas",
                        "content": "The SubArray week is far better than TREE and GRAPH Week\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@cwooldridge](/cwooldridge) \\nThat\\'s the fun of arrays. The answer is in front of you, but you aren\\'t able to identify it."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I disagree, graph question in general have similar solutions and better patterns. I feel subarrays and array questions in general require alot more creativity and have much more clever solutions"
                    },
                    {
                        "username": "mayank-01",
                        "content": "so true..\\uD83D\\uDE02"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "truee......"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "True dat!\\n"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "True\\uD83D\\uDE02"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This would be very easy if you could use a double for loop .\\nThe official answer requires you to have a god-tier understanding of math.\\nI don\\'t see how it is possible for people to solve questions like this blind and during a coding interview "
                    },
                    {
                        "username": "deciduousflame538",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run the outer loop till the length of array starting from 0, and the inner loop from a value equal to j and till the length of array. \\nfor(int i = 0; i < size; ++i)\\nfor(int j = i ; j<size; ++j)"
                    },
                    {
                        "username": "sandipt335",
                        "content": "[@ironmonger1](/ironmonger1) doesnt help either my good sir"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run both loops till end but start the second loop from one place after the initial loop"
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I am solving it by using double for loop only, but i got stuck with till what value i have to run both loops. Could you pls help me with this\\n"
                    },
                    {
                        "username": "jkulanko",
                        "content": "I highly recommend anyone who is serious about mastering leetcode to follow the usaco.guide website.  There's more there than you'll ever use in leetcode but if you enjoy or want to get good at competitive programming I recommend it.  There is a problem exactly like this https://usaco.guide/problems/usaco-595-subsequences-summing-to-sevens/solution.  I remembered this problem and was able to come up with the O(n) solution in minutes.  I've been working through the modules for about a month and my leetcode rating has jumped 150 points"
                    },
                    {
                        "username": "algoacer",
                        "content": "Thanks for this recommendation. Any tips you would like to share for someone going to start doing usaco? Thanks.."
                    },
                    {
                        "username": "user1421n",
                        "content": "To be honnest, it took me sometime to undestand the transition from one idea to another, I think if there is more explanation, it will be better, but it's okay"
                    },
                    {
                        "username": "jkulanko",
                        "content": "[@MaratKhakim](/MaratKhakim)  I recommend going through it level and topic wise. I.E. do the bronze modules first topic by topic. Do problems on each topic until you\\u2019re sick of them or think you\\u2019ve mastered the topic"
                    },
                    {
                        "username": "MaratKhakim",
                        "content": "Thanks.  [@Jacob Kulanko](/jkulanko)How are you studying there? Learning topicwise and solving problems on usaco? Please, share your study techniques"
                    },
                    {
                        "username": "jkulanko",
                        "content": "Here\\u2019s a follow up problem if anyone wants to try a slightly harder but similar problem: https://atcoder.jp/contests/abc164/tasks/abc164_d"
                    },
                    {
                        "username": "Hrushi73",
                        "content": "great share, I am going to follow this problem set\\n"
                    },
                    {
                        "username": "legitroman",
                        "content": "Thanks for the share! It was very helpful."
                    },
                    {
                        "username": "truthsayer_Inshadows",
                        "content": "use a hash map to keep track of the remainder of the running sum of the array modulo k. For each index i in the array, we calculate the running sum from index 0 to i, and find its remainder when divided by k. We then check if the remainder already exists in the hash map. If it does, it means that there is a subarray with a sum that is divisible by k, and we increment the count of subarrays. If the remainder doesn\\'t exist in the hash map, we add it to the hash map with a count of 1.\\n\\n\\n```cpp\\n\\nint subarraySum(vector<int>& nums, int k) {\\n    int count = 0;\\n    int running_sum = 0;\\n    unordered_map<int, int> remainder_count;\\n    remainder_count[0] = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        running_sum += nums[i];\\n        int remainder = running_sum % k;\\n        if (remainder_count.find(remainder) != remainder_count.end()) {\\n            count += remainder_count[remainder];\\n        }\\n        if (remainder_count.find(remainder) == remainder_count.end()) {\\n            remainder_count[remainder] = 1;\\n        } else {\\n            remainder_count[remainder]++;\\n        }\\n    }\\n    return count;\\n}\\n\\n```\\n## Test case dry run:\\nLet\\'s say nums = {4,5,0,-2,-3,1} and k = 5\\n\\nInitialize count = 0, running_sum = 0, remainder_count = {0: 1}\\nIterate through the array, starting at index 0:\\ni = 0, nums[i] = 4, running_sum = 4, remainder = 4 % 5 = 4, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 1, nums[i] = 5, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 2, nums[i] = 0, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 3, nums[i] = -2, running_sum = 7, remainder = 7 % 5 = 2, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 4, nums[i] = -3, running_sum = 4, remainder = 4 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 5, nums[i] = 1, running_sum = 5, remainder = 5 % 5 = 0, remainder in remainder_count, so increment count by 1\\nReturn count = 5\\nSo the output is 5.\\n\\n# Don\\'t leave without upvoting ^_^\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@vinaygottipamula](/vinaygottipamula)\\n plz explain the intiution behind rem<0 then rem+=k."
                    },
                    {
                        "username": "jskipper2020",
                        "content": "how do you know that a repeated remainder means there is +(remainder) in the answer?"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "But the output is 7, and yes it is coming when we run the above code. There is a small mistake in your dry run method..Please note that.\n\nWe are increasing the count value only when we find the remainder in hashtable with the existing hash value (of the remainder) not with 1. \nHope you get it :-)\n\nU also missed this condition in your code\nif(remainder<0)remainder+=k;"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**Bruteforce to Optimization**\nThe naïve bruteforce solution would be - for all possible subarray start and end indexes, calculate the sum. So, the algorithm becomes $O(n^3)$. We can optimize this using the prefix sum idea. $SubarraySum(i,j) = PrefixSum(j) - PrefixSum(i-1)$. This reduces the time complexity to $O(n^2)$.\n\nNow, for this problem,\n$$\nPrefixSum(j) - PrefixSum(i-1) = 0 \\  [modulo \\ k]\n$$\n$$ \n=> PrefixSum(j) = PrefixSum(i-1) \\ [modulo \\ k]\n$$\n\nSo, we can get rid of the loop and count the frequency of the current prefix sum to solve the problem. The final time complexity would be $O(n)$. The only corner case would be negative modulos."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "[@Babu_frik](/Babu_frik) The modulus is negative when the prefix sum is negative. In that case, you have to add `k` to the mod to make it positive. "
                    },
                    {
                        "username": "Babu_frik",
                        "content": "When is it negative modulus? Can you please throw insight on that case?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is an excellent hint and explanation! I always get TLE on all my solutions so this was very helpful. For people trying out this approach, also take note of how to handle $$PrefixSum(0 - 1)$$ for subarrays starting at $$i=0$$. "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Leetcode January TREES -> ARRAYS "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem Statement is simple to understand, but deducing `prefix + currElem % K + K` is a whole different level of problem"
                    },
                    {
                        "username": "prototye",
                        "content": "can you tell me the thought process and in general explanation on how we came up with this prefix + nums[i] % k + k thing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "With brute force approach, we could we could solve 66/73 testcases. After that, I get TLE. Can anyone tell me the approach to optimize it? "
                    },
                    {
                        "username": "taj_1",
                        "content": "[@mayank-01](/mayank-01) \\npublic int subarraysDivByK(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j<nums.length;j++){\\n                int sum = 0;\\n                for(int l=i;l<=j;l++){\\n                    sum+=nums[l];\\n                }\\n                if(sum%k==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "mayank-01",
                        "content": "can anyone share the brute force code."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "You can use a solution in which calculate prefix sums and at every stage calculate remainder with \\'K\\'  and store it in unordered map along with their frequencies Can be done in O(n) time .iI will post solution for this in a while"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Is it supposed to be done in O(n) or O(n^2) ?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) yeah that\\'s the one thing that can always be done. But I need to learn the optimization techniques instead of just copying the solutions every time :("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i passed 68 with O(n^2) now go to solution tab that\\'s what i am going to do"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach:\n* For each index i, count all previous prefix sums in the array which has modulo same as of current prefix sum (at idx i) and add it to result.\n`Use HashTable to store the counts of prefix sum modulo`.\n* Also, for a -ve number num, num%k<0, we have to change it to +ve mod because modulo of a number can lie in the range of 0 to k-1 only.\n\nLet, num = -2, k=3 then `res=(-2)%3=-2`, for changing it to +ve mod add k to res.\nChanging to +ve mod, `-2+3 = 1`, So, `res=(-2)%3=1`.\n\n### Complexity: O(n) time and O(k) space"
                    },
                    {
                        "username": "a_parth",
                        "content": "but why we need to calculate +ve modulo. Why we can\\'t go ahead with -ve modulo?"
                    }
                ]
            },
            {
                "id": 1565082,
                "content": [
                    {
                        "username": "lucyG",
                        "content": "When I tried to solve this problem, I didn\\'t come up with **Prefix Sum** at all.\\n\\nMy question for you guys who thought of using Prefix Sum to solve it is how/why did you know that you gonna use Prefix Sum for it? \\n\\nI could only come up with the following possilbe reasons:\\n1. It looks like a problem that Prefix Sum could help with;\\n2. This is a problem related to Array & Modulo;\\n3. You just have a feeling...\\n\\nReally appreciate it."
                    },
                    {
                        "username": "CodeID99",
                        "content": "Hi, I first solved this problem with O(n**2), then moved to a find a better solution. Since it\\'s asking for a subarray, there is not much I could think of, except sliding window and prefix sum. Sliding window won\\'t work for this problem, so I solved it with prefix sum."
                    },
                    {
                        "username": "akansha_01",
                        "content": "damm true :)\\n"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "[@zarif98sjs](/zarif98sjs) How long is that experience?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, the first thing to see is that constraints are such that n^2 was directly out of scope. Sorting is also out of question since that ruins the subarrays so in a way n.log(n) was also out. With only O(n) complexity possible, there are not much things left apart from prefix sum. Plus having an O(n^2) solution would make this problem a dumb one, so knew in the first minute itself that we cant do without cumulative i.e prefix sum."
                    },
                    {
                        "username": "kandiana",
                        "content": "I figured it from the math point of view + from the algorithms I considered for the previous daily problem?\\nSubarray sum = difference between two prefix sums, it will be divided by k if prefix sums have the same mod k value. Hence I need to count mod k values and then caclulate the number of pairs for each count (for 0: n * (n + 1) / 2, for the rest: n * ( n - 1) / 2)\\n"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "Similar problems. I just recognize the pattern now"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "I guess from the experience of solving similar problems."
                    },
                    {
                        "username": "istewartbinks",
                        "content": "I came up with prefix sum. It\\'s asking for a contiguous subarray sum (mod k), which is easy to get in n^2 time if you have a prefix sum. I\\'ve done problems like this before. If I didn\\'t know what prefix sum was, I wouldn\\'t know how to answer this problem.\\n\\nConsider it pattern matching."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "There is a similar problem. Leetcode 560. Subarray Sum Equals K. Try that. Then you can instantly identify this needs a prefix sum."
                    },
                    {
                        "username": "arghyadas",
                        "content": "The SubArray week is far better than TREE and GRAPH Week\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@cwooldridge](/cwooldridge) \\nThat\\'s the fun of arrays. The answer is in front of you, but you aren\\'t able to identify it."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I disagree, graph question in general have similar solutions and better patterns. I feel subarrays and array questions in general require alot more creativity and have much more clever solutions"
                    },
                    {
                        "username": "mayank-01",
                        "content": "so true..\\uD83D\\uDE02"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "truee......"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "True dat!\\n"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "True\\uD83D\\uDE02"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This would be very easy if you could use a double for loop .\\nThe official answer requires you to have a god-tier understanding of math.\\nI don\\'t see how it is possible for people to solve questions like this blind and during a coding interview "
                    },
                    {
                        "username": "deciduousflame538",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run the outer loop till the length of array starting from 0, and the inner loop from a value equal to j and till the length of array. \\nfor(int i = 0; i < size; ++i)\\nfor(int j = i ; j<size; ++j)"
                    },
                    {
                        "username": "sandipt335",
                        "content": "[@ironmonger1](/ironmonger1) doesnt help either my good sir"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run both loops till end but start the second loop from one place after the initial loop"
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I am solving it by using double for loop only, but i got stuck with till what value i have to run both loops. Could you pls help me with this\\n"
                    },
                    {
                        "username": "jkulanko",
                        "content": "I highly recommend anyone who is serious about mastering leetcode to follow the usaco.guide website.  There's more there than you'll ever use in leetcode but if you enjoy or want to get good at competitive programming I recommend it.  There is a problem exactly like this https://usaco.guide/problems/usaco-595-subsequences-summing-to-sevens/solution.  I remembered this problem and was able to come up with the O(n) solution in minutes.  I've been working through the modules for about a month and my leetcode rating has jumped 150 points"
                    },
                    {
                        "username": "algoacer",
                        "content": "Thanks for this recommendation. Any tips you would like to share for someone going to start doing usaco? Thanks.."
                    },
                    {
                        "username": "user1421n",
                        "content": "To be honnest, it took me sometime to undestand the transition from one idea to another, I think if there is more explanation, it will be better, but it's okay"
                    },
                    {
                        "username": "jkulanko",
                        "content": "[@MaratKhakim](/MaratKhakim)  I recommend going through it level and topic wise. I.E. do the bronze modules first topic by topic. Do problems on each topic until you\\u2019re sick of them or think you\\u2019ve mastered the topic"
                    },
                    {
                        "username": "MaratKhakim",
                        "content": "Thanks.  [@Jacob Kulanko](/jkulanko)How are you studying there? Learning topicwise and solving problems on usaco? Please, share your study techniques"
                    },
                    {
                        "username": "jkulanko",
                        "content": "Here\\u2019s a follow up problem if anyone wants to try a slightly harder but similar problem: https://atcoder.jp/contests/abc164/tasks/abc164_d"
                    },
                    {
                        "username": "Hrushi73",
                        "content": "great share, I am going to follow this problem set\\n"
                    },
                    {
                        "username": "legitroman",
                        "content": "Thanks for the share! It was very helpful."
                    },
                    {
                        "username": "truthsayer_Inshadows",
                        "content": "use a hash map to keep track of the remainder of the running sum of the array modulo k. For each index i in the array, we calculate the running sum from index 0 to i, and find its remainder when divided by k. We then check if the remainder already exists in the hash map. If it does, it means that there is a subarray with a sum that is divisible by k, and we increment the count of subarrays. If the remainder doesn\\'t exist in the hash map, we add it to the hash map with a count of 1.\\n\\n\\n```cpp\\n\\nint subarraySum(vector<int>& nums, int k) {\\n    int count = 0;\\n    int running_sum = 0;\\n    unordered_map<int, int> remainder_count;\\n    remainder_count[0] = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        running_sum += nums[i];\\n        int remainder = running_sum % k;\\n        if (remainder_count.find(remainder) != remainder_count.end()) {\\n            count += remainder_count[remainder];\\n        }\\n        if (remainder_count.find(remainder) == remainder_count.end()) {\\n            remainder_count[remainder] = 1;\\n        } else {\\n            remainder_count[remainder]++;\\n        }\\n    }\\n    return count;\\n}\\n\\n```\\n## Test case dry run:\\nLet\\'s say nums = {4,5,0,-2,-3,1} and k = 5\\n\\nInitialize count = 0, running_sum = 0, remainder_count = {0: 1}\\nIterate through the array, starting at index 0:\\ni = 0, nums[i] = 4, running_sum = 4, remainder = 4 % 5 = 4, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 1, nums[i] = 5, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 2, nums[i] = 0, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 3, nums[i] = -2, running_sum = 7, remainder = 7 % 5 = 2, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 4, nums[i] = -3, running_sum = 4, remainder = 4 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 5, nums[i] = 1, running_sum = 5, remainder = 5 % 5 = 0, remainder in remainder_count, so increment count by 1\\nReturn count = 5\\nSo the output is 5.\\n\\n# Don\\'t leave without upvoting ^_^\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@vinaygottipamula](/vinaygottipamula)\\n plz explain the intiution behind rem<0 then rem+=k."
                    },
                    {
                        "username": "jskipper2020",
                        "content": "how do you know that a repeated remainder means there is +(remainder) in the answer?"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "But the output is 7, and yes it is coming when we run the above code. There is a small mistake in your dry run method..Please note that.\n\nWe are increasing the count value only when we find the remainder in hashtable with the existing hash value (of the remainder) not with 1. \nHope you get it :-)\n\nU also missed this condition in your code\nif(remainder<0)remainder+=k;"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**Bruteforce to Optimization**\nThe naïve bruteforce solution would be - for all possible subarray start and end indexes, calculate the sum. So, the algorithm becomes $O(n^3)$. We can optimize this using the prefix sum idea. $SubarraySum(i,j) = PrefixSum(j) - PrefixSum(i-1)$. This reduces the time complexity to $O(n^2)$.\n\nNow, for this problem,\n$$\nPrefixSum(j) - PrefixSum(i-1) = 0 \\  [modulo \\ k]\n$$\n$$ \n=> PrefixSum(j) = PrefixSum(i-1) \\ [modulo \\ k]\n$$\n\nSo, we can get rid of the loop and count the frequency of the current prefix sum to solve the problem. The final time complexity would be $O(n)$. The only corner case would be negative modulos."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "[@Babu_frik](/Babu_frik) The modulus is negative when the prefix sum is negative. In that case, you have to add `k` to the mod to make it positive. "
                    },
                    {
                        "username": "Babu_frik",
                        "content": "When is it negative modulus? Can you please throw insight on that case?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is an excellent hint and explanation! I always get TLE on all my solutions so this was very helpful. For people trying out this approach, also take note of how to handle $$PrefixSum(0 - 1)$$ for subarrays starting at $$i=0$$. "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Leetcode January TREES -> ARRAYS "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem Statement is simple to understand, but deducing `prefix + currElem % K + K` is a whole different level of problem"
                    },
                    {
                        "username": "prototye",
                        "content": "can you tell me the thought process and in general explanation on how we came up with this prefix + nums[i] % k + k thing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "With brute force approach, we could we could solve 66/73 testcases. After that, I get TLE. Can anyone tell me the approach to optimize it? "
                    },
                    {
                        "username": "taj_1",
                        "content": "[@mayank-01](/mayank-01) \\npublic int subarraysDivByK(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j<nums.length;j++){\\n                int sum = 0;\\n                for(int l=i;l<=j;l++){\\n                    sum+=nums[l];\\n                }\\n                if(sum%k==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "mayank-01",
                        "content": "can anyone share the brute force code."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "You can use a solution in which calculate prefix sums and at every stage calculate remainder with \\'K\\'  and store it in unordered map along with their frequencies Can be done in O(n) time .iI will post solution for this in a while"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Is it supposed to be done in O(n) or O(n^2) ?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) yeah that\\'s the one thing that can always be done. But I need to learn the optimization techniques instead of just copying the solutions every time :("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i passed 68 with O(n^2) now go to solution tab that\\'s what i am going to do"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach:\n* For each index i, count all previous prefix sums in the array which has modulo same as of current prefix sum (at idx i) and add it to result.\n`Use HashTable to store the counts of prefix sum modulo`.\n* Also, for a -ve number num, num%k<0, we have to change it to +ve mod because modulo of a number can lie in the range of 0 to k-1 only.\n\nLet, num = -2, k=3 then `res=(-2)%3=-2`, for changing it to +ve mod add k to res.\nChanging to +ve mod, `-2+3 = 1`, So, `res=(-2)%3=1`.\n\n### Complexity: O(n) time and O(k) space"
                    },
                    {
                        "username": "a_parth",
                        "content": "but why we need to calculate +ve modulo. Why we can\\'t go ahead with -ve modulo?"
                    }
                ]
            },
            {
                "id": 1764320,
                "content": [
                    {
                        "username": "lucyG",
                        "content": "When I tried to solve this problem, I didn\\'t come up with **Prefix Sum** at all.\\n\\nMy question for you guys who thought of using Prefix Sum to solve it is how/why did you know that you gonna use Prefix Sum for it? \\n\\nI could only come up with the following possilbe reasons:\\n1. It looks like a problem that Prefix Sum could help with;\\n2. This is a problem related to Array & Modulo;\\n3. You just have a feeling...\\n\\nReally appreciate it."
                    },
                    {
                        "username": "CodeID99",
                        "content": "Hi, I first solved this problem with O(n**2), then moved to a find a better solution. Since it\\'s asking for a subarray, there is not much I could think of, except sliding window and prefix sum. Sliding window won\\'t work for this problem, so I solved it with prefix sum."
                    },
                    {
                        "username": "akansha_01",
                        "content": "damm true :)\\n"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "[@zarif98sjs](/zarif98sjs) How long is that experience?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, the first thing to see is that constraints are such that n^2 was directly out of scope. Sorting is also out of question since that ruins the subarrays so in a way n.log(n) was also out. With only O(n) complexity possible, there are not much things left apart from prefix sum. Plus having an O(n^2) solution would make this problem a dumb one, so knew in the first minute itself that we cant do without cumulative i.e prefix sum."
                    },
                    {
                        "username": "kandiana",
                        "content": "I figured it from the math point of view + from the algorithms I considered for the previous daily problem?\\nSubarray sum = difference between two prefix sums, it will be divided by k if prefix sums have the same mod k value. Hence I need to count mod k values and then caclulate the number of pairs for each count (for 0: n * (n + 1) / 2, for the rest: n * ( n - 1) / 2)\\n"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "Similar problems. I just recognize the pattern now"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "I guess from the experience of solving similar problems."
                    },
                    {
                        "username": "istewartbinks",
                        "content": "I came up with prefix sum. It\\'s asking for a contiguous subarray sum (mod k), which is easy to get in n^2 time if you have a prefix sum. I\\'ve done problems like this before. If I didn\\'t know what prefix sum was, I wouldn\\'t know how to answer this problem.\\n\\nConsider it pattern matching."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "There is a similar problem. Leetcode 560. Subarray Sum Equals K. Try that. Then you can instantly identify this needs a prefix sum."
                    },
                    {
                        "username": "arghyadas",
                        "content": "The SubArray week is far better than TREE and GRAPH Week\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@cwooldridge](/cwooldridge) \\nThat\\'s the fun of arrays. The answer is in front of you, but you aren\\'t able to identify it."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I disagree, graph question in general have similar solutions and better patterns. I feel subarrays and array questions in general require alot more creativity and have much more clever solutions"
                    },
                    {
                        "username": "mayank-01",
                        "content": "so true..\\uD83D\\uDE02"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "truee......"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "True dat!\\n"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "True\\uD83D\\uDE02"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This would be very easy if you could use a double for loop .\\nThe official answer requires you to have a god-tier understanding of math.\\nI don\\'t see how it is possible for people to solve questions like this blind and during a coding interview "
                    },
                    {
                        "username": "deciduousflame538",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run the outer loop till the length of array starting from 0, and the inner loop from a value equal to j and till the length of array. \\nfor(int i = 0; i < size; ++i)\\nfor(int j = i ; j<size; ++j)"
                    },
                    {
                        "username": "sandipt335",
                        "content": "[@ironmonger1](/ironmonger1) doesnt help either my good sir"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run both loops till end but start the second loop from one place after the initial loop"
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I am solving it by using double for loop only, but i got stuck with till what value i have to run both loops. Could you pls help me with this\\n"
                    },
                    {
                        "username": "jkulanko",
                        "content": "I highly recommend anyone who is serious about mastering leetcode to follow the usaco.guide website.  There's more there than you'll ever use in leetcode but if you enjoy or want to get good at competitive programming I recommend it.  There is a problem exactly like this https://usaco.guide/problems/usaco-595-subsequences-summing-to-sevens/solution.  I remembered this problem and was able to come up with the O(n) solution in minutes.  I've been working through the modules for about a month and my leetcode rating has jumped 150 points"
                    },
                    {
                        "username": "algoacer",
                        "content": "Thanks for this recommendation. Any tips you would like to share for someone going to start doing usaco? Thanks.."
                    },
                    {
                        "username": "user1421n",
                        "content": "To be honnest, it took me sometime to undestand the transition from one idea to another, I think if there is more explanation, it will be better, but it's okay"
                    },
                    {
                        "username": "jkulanko",
                        "content": "[@MaratKhakim](/MaratKhakim)  I recommend going through it level and topic wise. I.E. do the bronze modules first topic by topic. Do problems on each topic until you\\u2019re sick of them or think you\\u2019ve mastered the topic"
                    },
                    {
                        "username": "MaratKhakim",
                        "content": "Thanks.  [@Jacob Kulanko](/jkulanko)How are you studying there? Learning topicwise and solving problems on usaco? Please, share your study techniques"
                    },
                    {
                        "username": "jkulanko",
                        "content": "Here\\u2019s a follow up problem if anyone wants to try a slightly harder but similar problem: https://atcoder.jp/contests/abc164/tasks/abc164_d"
                    },
                    {
                        "username": "Hrushi73",
                        "content": "great share, I am going to follow this problem set\\n"
                    },
                    {
                        "username": "legitroman",
                        "content": "Thanks for the share! It was very helpful."
                    },
                    {
                        "username": "truthsayer_Inshadows",
                        "content": "use a hash map to keep track of the remainder of the running sum of the array modulo k. For each index i in the array, we calculate the running sum from index 0 to i, and find its remainder when divided by k. We then check if the remainder already exists in the hash map. If it does, it means that there is a subarray with a sum that is divisible by k, and we increment the count of subarrays. If the remainder doesn\\'t exist in the hash map, we add it to the hash map with a count of 1.\\n\\n\\n```cpp\\n\\nint subarraySum(vector<int>& nums, int k) {\\n    int count = 0;\\n    int running_sum = 0;\\n    unordered_map<int, int> remainder_count;\\n    remainder_count[0] = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        running_sum += nums[i];\\n        int remainder = running_sum % k;\\n        if (remainder_count.find(remainder) != remainder_count.end()) {\\n            count += remainder_count[remainder];\\n        }\\n        if (remainder_count.find(remainder) == remainder_count.end()) {\\n            remainder_count[remainder] = 1;\\n        } else {\\n            remainder_count[remainder]++;\\n        }\\n    }\\n    return count;\\n}\\n\\n```\\n## Test case dry run:\\nLet\\'s say nums = {4,5,0,-2,-3,1} and k = 5\\n\\nInitialize count = 0, running_sum = 0, remainder_count = {0: 1}\\nIterate through the array, starting at index 0:\\ni = 0, nums[i] = 4, running_sum = 4, remainder = 4 % 5 = 4, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 1, nums[i] = 5, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 2, nums[i] = 0, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 3, nums[i] = -2, running_sum = 7, remainder = 7 % 5 = 2, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 4, nums[i] = -3, running_sum = 4, remainder = 4 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 5, nums[i] = 1, running_sum = 5, remainder = 5 % 5 = 0, remainder in remainder_count, so increment count by 1\\nReturn count = 5\\nSo the output is 5.\\n\\n# Don\\'t leave without upvoting ^_^\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@vinaygottipamula](/vinaygottipamula)\\n plz explain the intiution behind rem<0 then rem+=k."
                    },
                    {
                        "username": "jskipper2020",
                        "content": "how do you know that a repeated remainder means there is +(remainder) in the answer?"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "But the output is 7, and yes it is coming when we run the above code. There is a small mistake in your dry run method..Please note that.\n\nWe are increasing the count value only when we find the remainder in hashtable with the existing hash value (of the remainder) not with 1. \nHope you get it :-)\n\nU also missed this condition in your code\nif(remainder<0)remainder+=k;"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**Bruteforce to Optimization**\nThe naïve bruteforce solution would be - for all possible subarray start and end indexes, calculate the sum. So, the algorithm becomes $O(n^3)$. We can optimize this using the prefix sum idea. $SubarraySum(i,j) = PrefixSum(j) - PrefixSum(i-1)$. This reduces the time complexity to $O(n^2)$.\n\nNow, for this problem,\n$$\nPrefixSum(j) - PrefixSum(i-1) = 0 \\  [modulo \\ k]\n$$\n$$ \n=> PrefixSum(j) = PrefixSum(i-1) \\ [modulo \\ k]\n$$\n\nSo, we can get rid of the loop and count the frequency of the current prefix sum to solve the problem. The final time complexity would be $O(n)$. The only corner case would be negative modulos."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "[@Babu_frik](/Babu_frik) The modulus is negative when the prefix sum is negative. In that case, you have to add `k` to the mod to make it positive. "
                    },
                    {
                        "username": "Babu_frik",
                        "content": "When is it negative modulus? Can you please throw insight on that case?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is an excellent hint and explanation! I always get TLE on all my solutions so this was very helpful. For people trying out this approach, also take note of how to handle $$PrefixSum(0 - 1)$$ for subarrays starting at $$i=0$$. "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Leetcode January TREES -> ARRAYS "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem Statement is simple to understand, but deducing `prefix + currElem % K + K` is a whole different level of problem"
                    },
                    {
                        "username": "prototye",
                        "content": "can you tell me the thought process and in general explanation on how we came up with this prefix + nums[i] % k + k thing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "With brute force approach, we could we could solve 66/73 testcases. After that, I get TLE. Can anyone tell me the approach to optimize it? "
                    },
                    {
                        "username": "taj_1",
                        "content": "[@mayank-01](/mayank-01) \\npublic int subarraysDivByK(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j<nums.length;j++){\\n                int sum = 0;\\n                for(int l=i;l<=j;l++){\\n                    sum+=nums[l];\\n                }\\n                if(sum%k==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "mayank-01",
                        "content": "can anyone share the brute force code."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "You can use a solution in which calculate prefix sums and at every stage calculate remainder with \\'K\\'  and store it in unordered map along with their frequencies Can be done in O(n) time .iI will post solution for this in a while"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Is it supposed to be done in O(n) or O(n^2) ?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) yeah that\\'s the one thing that can always be done. But I need to learn the optimization techniques instead of just copying the solutions every time :("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i passed 68 with O(n^2) now go to solution tab that\\'s what i am going to do"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach:\n* For each index i, count all previous prefix sums in the array which has modulo same as of current prefix sum (at idx i) and add it to result.\n`Use HashTable to store the counts of prefix sum modulo`.\n* Also, for a -ve number num, num%k<0, we have to change it to +ve mod because modulo of a number can lie in the range of 0 to k-1 only.\n\nLet, num = -2, k=3 then `res=(-2)%3=-2`, for changing it to +ve mod add k to res.\nChanging to +ve mod, `-2+3 = 1`, So, `res=(-2)%3=1`.\n\n### Complexity: O(n) time and O(k) space"
                    },
                    {
                        "username": "a_parth",
                        "content": "but why we need to calculate +ve modulo. Why we can\\'t go ahead with -ve modulo?"
                    }
                ]
            },
            {
                "id": 1764026,
                "content": [
                    {
                        "username": "lucyG",
                        "content": "When I tried to solve this problem, I didn\\'t come up with **Prefix Sum** at all.\\n\\nMy question for you guys who thought of using Prefix Sum to solve it is how/why did you know that you gonna use Prefix Sum for it? \\n\\nI could only come up with the following possilbe reasons:\\n1. It looks like a problem that Prefix Sum could help with;\\n2. This is a problem related to Array & Modulo;\\n3. You just have a feeling...\\n\\nReally appreciate it."
                    },
                    {
                        "username": "CodeID99",
                        "content": "Hi, I first solved this problem with O(n**2), then moved to a find a better solution. Since it\\'s asking for a subarray, there is not much I could think of, except sliding window and prefix sum. Sliding window won\\'t work for this problem, so I solved it with prefix sum."
                    },
                    {
                        "username": "akansha_01",
                        "content": "damm true :)\\n"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "[@zarif98sjs](/zarif98sjs) How long is that experience?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, the first thing to see is that constraints are such that n^2 was directly out of scope. Sorting is also out of question since that ruins the subarrays so in a way n.log(n) was also out. With only O(n) complexity possible, there are not much things left apart from prefix sum. Plus having an O(n^2) solution would make this problem a dumb one, so knew in the first minute itself that we cant do without cumulative i.e prefix sum."
                    },
                    {
                        "username": "kandiana",
                        "content": "I figured it from the math point of view + from the algorithms I considered for the previous daily problem?\\nSubarray sum = difference between two prefix sums, it will be divided by k if prefix sums have the same mod k value. Hence I need to count mod k values and then caclulate the number of pairs for each count (for 0: n * (n + 1) / 2, for the rest: n * ( n - 1) / 2)\\n"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "Similar problems. I just recognize the pattern now"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "I guess from the experience of solving similar problems."
                    },
                    {
                        "username": "istewartbinks",
                        "content": "I came up with prefix sum. It\\'s asking for a contiguous subarray sum (mod k), which is easy to get in n^2 time if you have a prefix sum. I\\'ve done problems like this before. If I didn\\'t know what prefix sum was, I wouldn\\'t know how to answer this problem.\\n\\nConsider it pattern matching."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "There is a similar problem. Leetcode 560. Subarray Sum Equals K. Try that. Then you can instantly identify this needs a prefix sum."
                    },
                    {
                        "username": "arghyadas",
                        "content": "The SubArray week is far better than TREE and GRAPH Week\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@cwooldridge](/cwooldridge) \\nThat\\'s the fun of arrays. The answer is in front of you, but you aren\\'t able to identify it."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I disagree, graph question in general have similar solutions and better patterns. I feel subarrays and array questions in general require alot more creativity and have much more clever solutions"
                    },
                    {
                        "username": "mayank-01",
                        "content": "so true..\\uD83D\\uDE02"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "truee......"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "True dat!\\n"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "True\\uD83D\\uDE02"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This would be very easy if you could use a double for loop .\\nThe official answer requires you to have a god-tier understanding of math.\\nI don\\'t see how it is possible for people to solve questions like this blind and during a coding interview "
                    },
                    {
                        "username": "deciduousflame538",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run the outer loop till the length of array starting from 0, and the inner loop from a value equal to j and till the length of array. \\nfor(int i = 0; i < size; ++i)\\nfor(int j = i ; j<size; ++j)"
                    },
                    {
                        "username": "sandipt335",
                        "content": "[@ironmonger1](/ironmonger1) doesnt help either my good sir"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run both loops till end but start the second loop from one place after the initial loop"
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I am solving it by using double for loop only, but i got stuck with till what value i have to run both loops. Could you pls help me with this\\n"
                    },
                    {
                        "username": "jkulanko",
                        "content": "I highly recommend anyone who is serious about mastering leetcode to follow the usaco.guide website.  There's more there than you'll ever use in leetcode but if you enjoy or want to get good at competitive programming I recommend it.  There is a problem exactly like this https://usaco.guide/problems/usaco-595-subsequences-summing-to-sevens/solution.  I remembered this problem and was able to come up with the O(n) solution in minutes.  I've been working through the modules for about a month and my leetcode rating has jumped 150 points"
                    },
                    {
                        "username": "algoacer",
                        "content": "Thanks for this recommendation. Any tips you would like to share for someone going to start doing usaco? Thanks.."
                    },
                    {
                        "username": "user1421n",
                        "content": "To be honnest, it took me sometime to undestand the transition from one idea to another, I think if there is more explanation, it will be better, but it's okay"
                    },
                    {
                        "username": "jkulanko",
                        "content": "[@MaratKhakim](/MaratKhakim)  I recommend going through it level and topic wise. I.E. do the bronze modules first topic by topic. Do problems on each topic until you\\u2019re sick of them or think you\\u2019ve mastered the topic"
                    },
                    {
                        "username": "MaratKhakim",
                        "content": "Thanks.  [@Jacob Kulanko](/jkulanko)How are you studying there? Learning topicwise and solving problems on usaco? Please, share your study techniques"
                    },
                    {
                        "username": "jkulanko",
                        "content": "Here\\u2019s a follow up problem if anyone wants to try a slightly harder but similar problem: https://atcoder.jp/contests/abc164/tasks/abc164_d"
                    },
                    {
                        "username": "Hrushi73",
                        "content": "great share, I am going to follow this problem set\\n"
                    },
                    {
                        "username": "legitroman",
                        "content": "Thanks for the share! It was very helpful."
                    },
                    {
                        "username": "truthsayer_Inshadows",
                        "content": "use a hash map to keep track of the remainder of the running sum of the array modulo k. For each index i in the array, we calculate the running sum from index 0 to i, and find its remainder when divided by k. We then check if the remainder already exists in the hash map. If it does, it means that there is a subarray with a sum that is divisible by k, and we increment the count of subarrays. If the remainder doesn\\'t exist in the hash map, we add it to the hash map with a count of 1.\\n\\n\\n```cpp\\n\\nint subarraySum(vector<int>& nums, int k) {\\n    int count = 0;\\n    int running_sum = 0;\\n    unordered_map<int, int> remainder_count;\\n    remainder_count[0] = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        running_sum += nums[i];\\n        int remainder = running_sum % k;\\n        if (remainder_count.find(remainder) != remainder_count.end()) {\\n            count += remainder_count[remainder];\\n        }\\n        if (remainder_count.find(remainder) == remainder_count.end()) {\\n            remainder_count[remainder] = 1;\\n        } else {\\n            remainder_count[remainder]++;\\n        }\\n    }\\n    return count;\\n}\\n\\n```\\n## Test case dry run:\\nLet\\'s say nums = {4,5,0,-2,-3,1} and k = 5\\n\\nInitialize count = 0, running_sum = 0, remainder_count = {0: 1}\\nIterate through the array, starting at index 0:\\ni = 0, nums[i] = 4, running_sum = 4, remainder = 4 % 5 = 4, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 1, nums[i] = 5, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 2, nums[i] = 0, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 3, nums[i] = -2, running_sum = 7, remainder = 7 % 5 = 2, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 4, nums[i] = -3, running_sum = 4, remainder = 4 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 5, nums[i] = 1, running_sum = 5, remainder = 5 % 5 = 0, remainder in remainder_count, so increment count by 1\\nReturn count = 5\\nSo the output is 5.\\n\\n# Don\\'t leave without upvoting ^_^\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@vinaygottipamula](/vinaygottipamula)\\n plz explain the intiution behind rem<0 then rem+=k."
                    },
                    {
                        "username": "jskipper2020",
                        "content": "how do you know that a repeated remainder means there is +(remainder) in the answer?"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "But the output is 7, and yes it is coming when we run the above code. There is a small mistake in your dry run method..Please note that.\n\nWe are increasing the count value only when we find the remainder in hashtable with the existing hash value (of the remainder) not with 1. \nHope you get it :-)\n\nU also missed this condition in your code\nif(remainder<0)remainder+=k;"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**Bruteforce to Optimization**\nThe naïve bruteforce solution would be - for all possible subarray start and end indexes, calculate the sum. So, the algorithm becomes $O(n^3)$. We can optimize this using the prefix sum idea. $SubarraySum(i,j) = PrefixSum(j) - PrefixSum(i-1)$. This reduces the time complexity to $O(n^2)$.\n\nNow, for this problem,\n$$\nPrefixSum(j) - PrefixSum(i-1) = 0 \\  [modulo \\ k]\n$$\n$$ \n=> PrefixSum(j) = PrefixSum(i-1) \\ [modulo \\ k]\n$$\n\nSo, we can get rid of the loop and count the frequency of the current prefix sum to solve the problem. The final time complexity would be $O(n)$. The only corner case would be negative modulos."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "[@Babu_frik](/Babu_frik) The modulus is negative when the prefix sum is negative. In that case, you have to add `k` to the mod to make it positive. "
                    },
                    {
                        "username": "Babu_frik",
                        "content": "When is it negative modulus? Can you please throw insight on that case?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is an excellent hint and explanation! I always get TLE on all my solutions so this was very helpful. For people trying out this approach, also take note of how to handle $$PrefixSum(0 - 1)$$ for subarrays starting at $$i=0$$. "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Leetcode January TREES -> ARRAYS "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem Statement is simple to understand, but deducing `prefix + currElem % K + K` is a whole different level of problem"
                    },
                    {
                        "username": "prototye",
                        "content": "can you tell me the thought process and in general explanation on how we came up with this prefix + nums[i] % k + k thing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "With brute force approach, we could we could solve 66/73 testcases. After that, I get TLE. Can anyone tell me the approach to optimize it? "
                    },
                    {
                        "username": "taj_1",
                        "content": "[@mayank-01](/mayank-01) \\npublic int subarraysDivByK(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j<nums.length;j++){\\n                int sum = 0;\\n                for(int l=i;l<=j;l++){\\n                    sum+=nums[l];\\n                }\\n                if(sum%k==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "mayank-01",
                        "content": "can anyone share the brute force code."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "You can use a solution in which calculate prefix sums and at every stage calculate remainder with \\'K\\'  and store it in unordered map along with their frequencies Can be done in O(n) time .iI will post solution for this in a while"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Is it supposed to be done in O(n) or O(n^2) ?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) yeah that\\'s the one thing that can always be done. But I need to learn the optimization techniques instead of just copying the solutions every time :("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i passed 68 with O(n^2) now go to solution tab that\\'s what i am going to do"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach:\n* For each index i, count all previous prefix sums in the array which has modulo same as of current prefix sum (at idx i) and add it to result.\n`Use HashTable to store the counts of prefix sum modulo`.\n* Also, for a -ve number num, num%k<0, we have to change it to +ve mod because modulo of a number can lie in the range of 0 to k-1 only.\n\nLet, num = -2, k=3 then `res=(-2)%3=-2`, for changing it to +ve mod add k to res.\nChanging to +ve mod, `-2+3 = 1`, So, `res=(-2)%3=1`.\n\n### Complexity: O(n) time and O(k) space"
                    },
                    {
                        "username": "a_parth",
                        "content": "but why we need to calculate +ve modulo. Why we can\\'t go ahead with -ve modulo?"
                    }
                ]
            },
            {
                "id": 1764217,
                "content": [
                    {
                        "username": "lucyG",
                        "content": "When I tried to solve this problem, I didn\\'t come up with **Prefix Sum** at all.\\n\\nMy question for you guys who thought of using Prefix Sum to solve it is how/why did you know that you gonna use Prefix Sum for it? \\n\\nI could only come up with the following possilbe reasons:\\n1. It looks like a problem that Prefix Sum could help with;\\n2. This is a problem related to Array & Modulo;\\n3. You just have a feeling...\\n\\nReally appreciate it."
                    },
                    {
                        "username": "CodeID99",
                        "content": "Hi, I first solved this problem with O(n**2), then moved to a find a better solution. Since it\\'s asking for a subarray, there is not much I could think of, except sliding window and prefix sum. Sliding window won\\'t work for this problem, so I solved it with prefix sum."
                    },
                    {
                        "username": "akansha_01",
                        "content": "damm true :)\\n"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "[@zarif98sjs](/zarif98sjs) How long is that experience?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, the first thing to see is that constraints are such that n^2 was directly out of scope. Sorting is also out of question since that ruins the subarrays so in a way n.log(n) was also out. With only O(n) complexity possible, there are not much things left apart from prefix sum. Plus having an O(n^2) solution would make this problem a dumb one, so knew in the first minute itself that we cant do without cumulative i.e prefix sum."
                    },
                    {
                        "username": "kandiana",
                        "content": "I figured it from the math point of view + from the algorithms I considered for the previous daily problem?\\nSubarray sum = difference between two prefix sums, it will be divided by k if prefix sums have the same mod k value. Hence I need to count mod k values and then caclulate the number of pairs for each count (for 0: n * (n + 1) / 2, for the rest: n * ( n - 1) / 2)\\n"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "Similar problems. I just recognize the pattern now"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "I guess from the experience of solving similar problems."
                    },
                    {
                        "username": "istewartbinks",
                        "content": "I came up with prefix sum. It\\'s asking for a contiguous subarray sum (mod k), which is easy to get in n^2 time if you have a prefix sum. I\\'ve done problems like this before. If I didn\\'t know what prefix sum was, I wouldn\\'t know how to answer this problem.\\n\\nConsider it pattern matching."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "There is a similar problem. Leetcode 560. Subarray Sum Equals K. Try that. Then you can instantly identify this needs a prefix sum."
                    },
                    {
                        "username": "arghyadas",
                        "content": "The SubArray week is far better than TREE and GRAPH Week\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@cwooldridge](/cwooldridge) \\nThat\\'s the fun of arrays. The answer is in front of you, but you aren\\'t able to identify it."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I disagree, graph question in general have similar solutions and better patterns. I feel subarrays and array questions in general require alot more creativity and have much more clever solutions"
                    },
                    {
                        "username": "mayank-01",
                        "content": "so true..\\uD83D\\uDE02"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "truee......"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "True dat!\\n"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "True\\uD83D\\uDE02"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This would be very easy if you could use a double for loop .\\nThe official answer requires you to have a god-tier understanding of math.\\nI don\\'t see how it is possible for people to solve questions like this blind and during a coding interview "
                    },
                    {
                        "username": "deciduousflame538",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run the outer loop till the length of array starting from 0, and the inner loop from a value equal to j and till the length of array. \\nfor(int i = 0; i < size; ++i)\\nfor(int j = i ; j<size; ++j)"
                    },
                    {
                        "username": "sandipt335",
                        "content": "[@ironmonger1](/ironmonger1) doesnt help either my good sir"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run both loops till end but start the second loop from one place after the initial loop"
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I am solving it by using double for loop only, but i got stuck with till what value i have to run both loops. Could you pls help me with this\\n"
                    },
                    {
                        "username": "jkulanko",
                        "content": "I highly recommend anyone who is serious about mastering leetcode to follow the usaco.guide website.  There's more there than you'll ever use in leetcode but if you enjoy or want to get good at competitive programming I recommend it.  There is a problem exactly like this https://usaco.guide/problems/usaco-595-subsequences-summing-to-sevens/solution.  I remembered this problem and was able to come up with the O(n) solution in minutes.  I've been working through the modules for about a month and my leetcode rating has jumped 150 points"
                    },
                    {
                        "username": "algoacer",
                        "content": "Thanks for this recommendation. Any tips you would like to share for someone going to start doing usaco? Thanks.."
                    },
                    {
                        "username": "user1421n",
                        "content": "To be honnest, it took me sometime to undestand the transition from one idea to another, I think if there is more explanation, it will be better, but it's okay"
                    },
                    {
                        "username": "jkulanko",
                        "content": "[@MaratKhakim](/MaratKhakim)  I recommend going through it level and topic wise. I.E. do the bronze modules first topic by topic. Do problems on each topic until you\\u2019re sick of them or think you\\u2019ve mastered the topic"
                    },
                    {
                        "username": "MaratKhakim",
                        "content": "Thanks.  [@Jacob Kulanko](/jkulanko)How are you studying there? Learning topicwise and solving problems on usaco? Please, share your study techniques"
                    },
                    {
                        "username": "jkulanko",
                        "content": "Here\\u2019s a follow up problem if anyone wants to try a slightly harder but similar problem: https://atcoder.jp/contests/abc164/tasks/abc164_d"
                    },
                    {
                        "username": "Hrushi73",
                        "content": "great share, I am going to follow this problem set\\n"
                    },
                    {
                        "username": "legitroman",
                        "content": "Thanks for the share! It was very helpful."
                    },
                    {
                        "username": "truthsayer_Inshadows",
                        "content": "use a hash map to keep track of the remainder of the running sum of the array modulo k. For each index i in the array, we calculate the running sum from index 0 to i, and find its remainder when divided by k. We then check if the remainder already exists in the hash map. If it does, it means that there is a subarray with a sum that is divisible by k, and we increment the count of subarrays. If the remainder doesn\\'t exist in the hash map, we add it to the hash map with a count of 1.\\n\\n\\n```cpp\\n\\nint subarraySum(vector<int>& nums, int k) {\\n    int count = 0;\\n    int running_sum = 0;\\n    unordered_map<int, int> remainder_count;\\n    remainder_count[0] = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        running_sum += nums[i];\\n        int remainder = running_sum % k;\\n        if (remainder_count.find(remainder) != remainder_count.end()) {\\n            count += remainder_count[remainder];\\n        }\\n        if (remainder_count.find(remainder) == remainder_count.end()) {\\n            remainder_count[remainder] = 1;\\n        } else {\\n            remainder_count[remainder]++;\\n        }\\n    }\\n    return count;\\n}\\n\\n```\\n## Test case dry run:\\nLet\\'s say nums = {4,5,0,-2,-3,1} and k = 5\\n\\nInitialize count = 0, running_sum = 0, remainder_count = {0: 1}\\nIterate through the array, starting at index 0:\\ni = 0, nums[i] = 4, running_sum = 4, remainder = 4 % 5 = 4, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 1, nums[i] = 5, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 2, nums[i] = 0, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 3, nums[i] = -2, running_sum = 7, remainder = 7 % 5 = 2, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 4, nums[i] = -3, running_sum = 4, remainder = 4 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 5, nums[i] = 1, running_sum = 5, remainder = 5 % 5 = 0, remainder in remainder_count, so increment count by 1\\nReturn count = 5\\nSo the output is 5.\\n\\n# Don\\'t leave without upvoting ^_^\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@vinaygottipamula](/vinaygottipamula)\\n plz explain the intiution behind rem<0 then rem+=k."
                    },
                    {
                        "username": "jskipper2020",
                        "content": "how do you know that a repeated remainder means there is +(remainder) in the answer?"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "But the output is 7, and yes it is coming when we run the above code. There is a small mistake in your dry run method..Please note that.\n\nWe are increasing the count value only when we find the remainder in hashtable with the existing hash value (of the remainder) not with 1. \nHope you get it :-)\n\nU also missed this condition in your code\nif(remainder<0)remainder+=k;"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**Bruteforce to Optimization**\nThe naïve bruteforce solution would be - for all possible subarray start and end indexes, calculate the sum. So, the algorithm becomes $O(n^3)$. We can optimize this using the prefix sum idea. $SubarraySum(i,j) = PrefixSum(j) - PrefixSum(i-1)$. This reduces the time complexity to $O(n^2)$.\n\nNow, for this problem,\n$$\nPrefixSum(j) - PrefixSum(i-1) = 0 \\  [modulo \\ k]\n$$\n$$ \n=> PrefixSum(j) = PrefixSum(i-1) \\ [modulo \\ k]\n$$\n\nSo, we can get rid of the loop and count the frequency of the current prefix sum to solve the problem. The final time complexity would be $O(n)$. The only corner case would be negative modulos."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "[@Babu_frik](/Babu_frik) The modulus is negative when the prefix sum is negative. In that case, you have to add `k` to the mod to make it positive. "
                    },
                    {
                        "username": "Babu_frik",
                        "content": "When is it negative modulus? Can you please throw insight on that case?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is an excellent hint and explanation! I always get TLE on all my solutions so this was very helpful. For people trying out this approach, also take note of how to handle $$PrefixSum(0 - 1)$$ for subarrays starting at $$i=0$$. "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Leetcode January TREES -> ARRAYS "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem Statement is simple to understand, but deducing `prefix + currElem % K + K` is a whole different level of problem"
                    },
                    {
                        "username": "prototye",
                        "content": "can you tell me the thought process and in general explanation on how we came up with this prefix + nums[i] % k + k thing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "With brute force approach, we could we could solve 66/73 testcases. After that, I get TLE. Can anyone tell me the approach to optimize it? "
                    },
                    {
                        "username": "taj_1",
                        "content": "[@mayank-01](/mayank-01) \\npublic int subarraysDivByK(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j<nums.length;j++){\\n                int sum = 0;\\n                for(int l=i;l<=j;l++){\\n                    sum+=nums[l];\\n                }\\n                if(sum%k==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "mayank-01",
                        "content": "can anyone share the brute force code."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "You can use a solution in which calculate prefix sums and at every stage calculate remainder with \\'K\\'  and store it in unordered map along with their frequencies Can be done in O(n) time .iI will post solution for this in a while"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Is it supposed to be done in O(n) or O(n^2) ?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) yeah that\\'s the one thing that can always be done. But I need to learn the optimization techniques instead of just copying the solutions every time :("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i passed 68 with O(n^2) now go to solution tab that\\'s what i am going to do"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach:\n* For each index i, count all previous prefix sums in the array which has modulo same as of current prefix sum (at idx i) and add it to result.\n`Use HashTable to store the counts of prefix sum modulo`.\n* Also, for a -ve number num, num%k<0, we have to change it to +ve mod because modulo of a number can lie in the range of 0 to k-1 only.\n\nLet, num = -2, k=3 then `res=(-2)%3=-2`, for changing it to +ve mod add k to res.\nChanging to +ve mod, `-2+3 = 1`, So, `res=(-2)%3=1`.\n\n### Complexity: O(n) time and O(k) space"
                    },
                    {
                        "username": "a_parth",
                        "content": "but why we need to calculate +ve modulo. Why we can\\'t go ahead with -ve modulo?"
                    }
                ]
            },
            {
                "id": 1764565,
                "content": [
                    {
                        "username": "lucyG",
                        "content": "When I tried to solve this problem, I didn\\'t come up with **Prefix Sum** at all.\\n\\nMy question for you guys who thought of using Prefix Sum to solve it is how/why did you know that you gonna use Prefix Sum for it? \\n\\nI could only come up with the following possilbe reasons:\\n1. It looks like a problem that Prefix Sum could help with;\\n2. This is a problem related to Array & Modulo;\\n3. You just have a feeling...\\n\\nReally appreciate it."
                    },
                    {
                        "username": "CodeID99",
                        "content": "Hi, I first solved this problem with O(n**2), then moved to a find a better solution. Since it\\'s asking for a subarray, there is not much I could think of, except sliding window and prefix sum. Sliding window won\\'t work for this problem, so I solved it with prefix sum."
                    },
                    {
                        "username": "akansha_01",
                        "content": "damm true :)\\n"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "[@zarif98sjs](/zarif98sjs) How long is that experience?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, the first thing to see is that constraints are such that n^2 was directly out of scope. Sorting is also out of question since that ruins the subarrays so in a way n.log(n) was also out. With only O(n) complexity possible, there are not much things left apart from prefix sum. Plus having an O(n^2) solution would make this problem a dumb one, so knew in the first minute itself that we cant do without cumulative i.e prefix sum."
                    },
                    {
                        "username": "kandiana",
                        "content": "I figured it from the math point of view + from the algorithms I considered for the previous daily problem?\\nSubarray sum = difference between two prefix sums, it will be divided by k if prefix sums have the same mod k value. Hence I need to count mod k values and then caclulate the number of pairs for each count (for 0: n * (n + 1) / 2, for the rest: n * ( n - 1) / 2)\\n"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "Similar problems. I just recognize the pattern now"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "I guess from the experience of solving similar problems."
                    },
                    {
                        "username": "istewartbinks",
                        "content": "I came up with prefix sum. It\\'s asking for a contiguous subarray sum (mod k), which is easy to get in n^2 time if you have a prefix sum. I\\'ve done problems like this before. If I didn\\'t know what prefix sum was, I wouldn\\'t know how to answer this problem.\\n\\nConsider it pattern matching."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "There is a similar problem. Leetcode 560. Subarray Sum Equals K. Try that. Then you can instantly identify this needs a prefix sum."
                    },
                    {
                        "username": "arghyadas",
                        "content": "The SubArray week is far better than TREE and GRAPH Week\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@cwooldridge](/cwooldridge) \\nThat\\'s the fun of arrays. The answer is in front of you, but you aren\\'t able to identify it."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I disagree, graph question in general have similar solutions and better patterns. I feel subarrays and array questions in general require alot more creativity and have much more clever solutions"
                    },
                    {
                        "username": "mayank-01",
                        "content": "so true..\\uD83D\\uDE02"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "truee......"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "True dat!\\n"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "True\\uD83D\\uDE02"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This would be very easy if you could use a double for loop .\\nThe official answer requires you to have a god-tier understanding of math.\\nI don\\'t see how it is possible for people to solve questions like this blind and during a coding interview "
                    },
                    {
                        "username": "deciduousflame538",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run the outer loop till the length of array starting from 0, and the inner loop from a value equal to j and till the length of array. \\nfor(int i = 0; i < size; ++i)\\nfor(int j = i ; j<size; ++j)"
                    },
                    {
                        "username": "sandipt335",
                        "content": "[@ironmonger1](/ironmonger1) doesnt help either my good sir"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run both loops till end but start the second loop from one place after the initial loop"
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I am solving it by using double for loop only, but i got stuck with till what value i have to run both loops. Could you pls help me with this\\n"
                    },
                    {
                        "username": "jkulanko",
                        "content": "I highly recommend anyone who is serious about mastering leetcode to follow the usaco.guide website.  There's more there than you'll ever use in leetcode but if you enjoy or want to get good at competitive programming I recommend it.  There is a problem exactly like this https://usaco.guide/problems/usaco-595-subsequences-summing-to-sevens/solution.  I remembered this problem and was able to come up with the O(n) solution in minutes.  I've been working through the modules for about a month and my leetcode rating has jumped 150 points"
                    },
                    {
                        "username": "algoacer",
                        "content": "Thanks for this recommendation. Any tips you would like to share for someone going to start doing usaco? Thanks.."
                    },
                    {
                        "username": "user1421n",
                        "content": "To be honnest, it took me sometime to undestand the transition from one idea to another, I think if there is more explanation, it will be better, but it's okay"
                    },
                    {
                        "username": "jkulanko",
                        "content": "[@MaratKhakim](/MaratKhakim)  I recommend going through it level and topic wise. I.E. do the bronze modules first topic by topic. Do problems on each topic until you\\u2019re sick of them or think you\\u2019ve mastered the topic"
                    },
                    {
                        "username": "MaratKhakim",
                        "content": "Thanks.  [@Jacob Kulanko](/jkulanko)How are you studying there? Learning topicwise and solving problems on usaco? Please, share your study techniques"
                    },
                    {
                        "username": "jkulanko",
                        "content": "Here\\u2019s a follow up problem if anyone wants to try a slightly harder but similar problem: https://atcoder.jp/contests/abc164/tasks/abc164_d"
                    },
                    {
                        "username": "Hrushi73",
                        "content": "great share, I am going to follow this problem set\\n"
                    },
                    {
                        "username": "legitroman",
                        "content": "Thanks for the share! It was very helpful."
                    },
                    {
                        "username": "truthsayer_Inshadows",
                        "content": "use a hash map to keep track of the remainder of the running sum of the array modulo k. For each index i in the array, we calculate the running sum from index 0 to i, and find its remainder when divided by k. We then check if the remainder already exists in the hash map. If it does, it means that there is a subarray with a sum that is divisible by k, and we increment the count of subarrays. If the remainder doesn\\'t exist in the hash map, we add it to the hash map with a count of 1.\\n\\n\\n```cpp\\n\\nint subarraySum(vector<int>& nums, int k) {\\n    int count = 0;\\n    int running_sum = 0;\\n    unordered_map<int, int> remainder_count;\\n    remainder_count[0] = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        running_sum += nums[i];\\n        int remainder = running_sum % k;\\n        if (remainder_count.find(remainder) != remainder_count.end()) {\\n            count += remainder_count[remainder];\\n        }\\n        if (remainder_count.find(remainder) == remainder_count.end()) {\\n            remainder_count[remainder] = 1;\\n        } else {\\n            remainder_count[remainder]++;\\n        }\\n    }\\n    return count;\\n}\\n\\n```\\n## Test case dry run:\\nLet\\'s say nums = {4,5,0,-2,-3,1} and k = 5\\n\\nInitialize count = 0, running_sum = 0, remainder_count = {0: 1}\\nIterate through the array, starting at index 0:\\ni = 0, nums[i] = 4, running_sum = 4, remainder = 4 % 5 = 4, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 1, nums[i] = 5, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 2, nums[i] = 0, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 3, nums[i] = -2, running_sum = 7, remainder = 7 % 5 = 2, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 4, nums[i] = -3, running_sum = 4, remainder = 4 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 5, nums[i] = 1, running_sum = 5, remainder = 5 % 5 = 0, remainder in remainder_count, so increment count by 1\\nReturn count = 5\\nSo the output is 5.\\n\\n# Don\\'t leave without upvoting ^_^\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@vinaygottipamula](/vinaygottipamula)\\n plz explain the intiution behind rem<0 then rem+=k."
                    },
                    {
                        "username": "jskipper2020",
                        "content": "how do you know that a repeated remainder means there is +(remainder) in the answer?"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "But the output is 7, and yes it is coming when we run the above code. There is a small mistake in your dry run method..Please note that.\n\nWe are increasing the count value only when we find the remainder in hashtable with the existing hash value (of the remainder) not with 1. \nHope you get it :-)\n\nU also missed this condition in your code\nif(remainder<0)remainder+=k;"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**Bruteforce to Optimization**\nThe naïve bruteforce solution would be - for all possible subarray start and end indexes, calculate the sum. So, the algorithm becomes $O(n^3)$. We can optimize this using the prefix sum idea. $SubarraySum(i,j) = PrefixSum(j) - PrefixSum(i-1)$. This reduces the time complexity to $O(n^2)$.\n\nNow, for this problem,\n$$\nPrefixSum(j) - PrefixSum(i-1) = 0 \\  [modulo \\ k]\n$$\n$$ \n=> PrefixSum(j) = PrefixSum(i-1) \\ [modulo \\ k]\n$$\n\nSo, we can get rid of the loop and count the frequency of the current prefix sum to solve the problem. The final time complexity would be $O(n)$. The only corner case would be negative modulos."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "[@Babu_frik](/Babu_frik) The modulus is negative when the prefix sum is negative. In that case, you have to add `k` to the mod to make it positive. "
                    },
                    {
                        "username": "Babu_frik",
                        "content": "When is it negative modulus? Can you please throw insight on that case?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is an excellent hint and explanation! I always get TLE on all my solutions so this was very helpful. For people trying out this approach, also take note of how to handle $$PrefixSum(0 - 1)$$ for subarrays starting at $$i=0$$. "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Leetcode January TREES -> ARRAYS "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem Statement is simple to understand, but deducing `prefix + currElem % K + K` is a whole different level of problem"
                    },
                    {
                        "username": "prototye",
                        "content": "can you tell me the thought process and in general explanation on how we came up with this prefix + nums[i] % k + k thing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "With brute force approach, we could we could solve 66/73 testcases. After that, I get TLE. Can anyone tell me the approach to optimize it? "
                    },
                    {
                        "username": "taj_1",
                        "content": "[@mayank-01](/mayank-01) \\npublic int subarraysDivByK(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j<nums.length;j++){\\n                int sum = 0;\\n                for(int l=i;l<=j;l++){\\n                    sum+=nums[l];\\n                }\\n                if(sum%k==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "mayank-01",
                        "content": "can anyone share the brute force code."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "You can use a solution in which calculate prefix sums and at every stage calculate remainder with \\'K\\'  and store it in unordered map along with their frequencies Can be done in O(n) time .iI will post solution for this in a while"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Is it supposed to be done in O(n) or O(n^2) ?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) yeah that\\'s the one thing that can always be done. But I need to learn the optimization techniques instead of just copying the solutions every time :("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i passed 68 with O(n^2) now go to solution tab that\\'s what i am going to do"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach:\n* For each index i, count all previous prefix sums in the array which has modulo same as of current prefix sum (at idx i) and add it to result.\n`Use HashTable to store the counts of prefix sum modulo`.\n* Also, for a -ve number num, num%k<0, we have to change it to +ve mod because modulo of a number can lie in the range of 0 to k-1 only.\n\nLet, num = -2, k=3 then `res=(-2)%3=-2`, for changing it to +ve mod add k to res.\nChanging to +ve mod, `-2+3 = 1`, So, `res=(-2)%3=1`.\n\n### Complexity: O(n) time and O(k) space"
                    },
                    {
                        "username": "a_parth",
                        "content": "but why we need to calculate +ve modulo. Why we can\\'t go ahead with -ve modulo?"
                    }
                ]
            },
            {
                "id": 1764050,
                "content": [
                    {
                        "username": "lucyG",
                        "content": "When I tried to solve this problem, I didn\\'t come up with **Prefix Sum** at all.\\n\\nMy question for you guys who thought of using Prefix Sum to solve it is how/why did you know that you gonna use Prefix Sum for it? \\n\\nI could only come up with the following possilbe reasons:\\n1. It looks like a problem that Prefix Sum could help with;\\n2. This is a problem related to Array & Modulo;\\n3. You just have a feeling...\\n\\nReally appreciate it."
                    },
                    {
                        "username": "CodeID99",
                        "content": "Hi, I first solved this problem with O(n**2), then moved to a find a better solution. Since it\\'s asking for a subarray, there is not much I could think of, except sliding window and prefix sum. Sliding window won\\'t work for this problem, so I solved it with prefix sum."
                    },
                    {
                        "username": "akansha_01",
                        "content": "damm true :)\\n"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "[@zarif98sjs](/zarif98sjs) How long is that experience?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, the first thing to see is that constraints are such that n^2 was directly out of scope. Sorting is also out of question since that ruins the subarrays so in a way n.log(n) was also out. With only O(n) complexity possible, there are not much things left apart from prefix sum. Plus having an O(n^2) solution would make this problem a dumb one, so knew in the first minute itself that we cant do without cumulative i.e prefix sum."
                    },
                    {
                        "username": "kandiana",
                        "content": "I figured it from the math point of view + from the algorithms I considered for the previous daily problem?\\nSubarray sum = difference between two prefix sums, it will be divided by k if prefix sums have the same mod k value. Hence I need to count mod k values and then caclulate the number of pairs for each count (for 0: n * (n + 1) / 2, for the rest: n * ( n - 1) / 2)\\n"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "Similar problems. I just recognize the pattern now"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "I guess from the experience of solving similar problems."
                    },
                    {
                        "username": "istewartbinks",
                        "content": "I came up with prefix sum. It\\'s asking for a contiguous subarray sum (mod k), which is easy to get in n^2 time if you have a prefix sum. I\\'ve done problems like this before. If I didn\\'t know what prefix sum was, I wouldn\\'t know how to answer this problem.\\n\\nConsider it pattern matching."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "There is a similar problem. Leetcode 560. Subarray Sum Equals K. Try that. Then you can instantly identify this needs a prefix sum."
                    },
                    {
                        "username": "arghyadas",
                        "content": "The SubArray week is far better than TREE and GRAPH Week\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@cwooldridge](/cwooldridge) \\nThat\\'s the fun of arrays. The answer is in front of you, but you aren\\'t able to identify it."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I disagree, graph question in general have similar solutions and better patterns. I feel subarrays and array questions in general require alot more creativity and have much more clever solutions"
                    },
                    {
                        "username": "mayank-01",
                        "content": "so true..\\uD83D\\uDE02"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "truee......"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "True dat!\\n"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "True\\uD83D\\uDE02"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This would be very easy if you could use a double for loop .\\nThe official answer requires you to have a god-tier understanding of math.\\nI don\\'t see how it is possible for people to solve questions like this blind and during a coding interview "
                    },
                    {
                        "username": "deciduousflame538",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run the outer loop till the length of array starting from 0, and the inner loop from a value equal to j and till the length of array. \\nfor(int i = 0; i < size; ++i)\\nfor(int j = i ; j<size; ++j)"
                    },
                    {
                        "username": "sandipt335",
                        "content": "[@ironmonger1](/ironmonger1) doesnt help either my good sir"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run both loops till end but start the second loop from one place after the initial loop"
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I am solving it by using double for loop only, but i got stuck with till what value i have to run both loops. Could you pls help me with this\\n"
                    },
                    {
                        "username": "jkulanko",
                        "content": "I highly recommend anyone who is serious about mastering leetcode to follow the usaco.guide website.  There's more there than you'll ever use in leetcode but if you enjoy or want to get good at competitive programming I recommend it.  There is a problem exactly like this https://usaco.guide/problems/usaco-595-subsequences-summing-to-sevens/solution.  I remembered this problem and was able to come up with the O(n) solution in minutes.  I've been working through the modules for about a month and my leetcode rating has jumped 150 points"
                    },
                    {
                        "username": "algoacer",
                        "content": "Thanks for this recommendation. Any tips you would like to share for someone going to start doing usaco? Thanks.."
                    },
                    {
                        "username": "user1421n",
                        "content": "To be honnest, it took me sometime to undestand the transition from one idea to another, I think if there is more explanation, it will be better, but it's okay"
                    },
                    {
                        "username": "jkulanko",
                        "content": "[@MaratKhakim](/MaratKhakim)  I recommend going through it level and topic wise. I.E. do the bronze modules first topic by topic. Do problems on each topic until you\\u2019re sick of them or think you\\u2019ve mastered the topic"
                    },
                    {
                        "username": "MaratKhakim",
                        "content": "Thanks.  [@Jacob Kulanko](/jkulanko)How are you studying there? Learning topicwise and solving problems on usaco? Please, share your study techniques"
                    },
                    {
                        "username": "jkulanko",
                        "content": "Here\\u2019s a follow up problem if anyone wants to try a slightly harder but similar problem: https://atcoder.jp/contests/abc164/tasks/abc164_d"
                    },
                    {
                        "username": "Hrushi73",
                        "content": "great share, I am going to follow this problem set\\n"
                    },
                    {
                        "username": "legitroman",
                        "content": "Thanks for the share! It was very helpful."
                    },
                    {
                        "username": "truthsayer_Inshadows",
                        "content": "use a hash map to keep track of the remainder of the running sum of the array modulo k. For each index i in the array, we calculate the running sum from index 0 to i, and find its remainder when divided by k. We then check if the remainder already exists in the hash map. If it does, it means that there is a subarray with a sum that is divisible by k, and we increment the count of subarrays. If the remainder doesn\\'t exist in the hash map, we add it to the hash map with a count of 1.\\n\\n\\n```cpp\\n\\nint subarraySum(vector<int>& nums, int k) {\\n    int count = 0;\\n    int running_sum = 0;\\n    unordered_map<int, int> remainder_count;\\n    remainder_count[0] = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        running_sum += nums[i];\\n        int remainder = running_sum % k;\\n        if (remainder_count.find(remainder) != remainder_count.end()) {\\n            count += remainder_count[remainder];\\n        }\\n        if (remainder_count.find(remainder) == remainder_count.end()) {\\n            remainder_count[remainder] = 1;\\n        } else {\\n            remainder_count[remainder]++;\\n        }\\n    }\\n    return count;\\n}\\n\\n```\\n## Test case dry run:\\nLet\\'s say nums = {4,5,0,-2,-3,1} and k = 5\\n\\nInitialize count = 0, running_sum = 0, remainder_count = {0: 1}\\nIterate through the array, starting at index 0:\\ni = 0, nums[i] = 4, running_sum = 4, remainder = 4 % 5 = 4, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 1, nums[i] = 5, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 2, nums[i] = 0, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 3, nums[i] = -2, running_sum = 7, remainder = 7 % 5 = 2, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 4, nums[i] = -3, running_sum = 4, remainder = 4 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 5, nums[i] = 1, running_sum = 5, remainder = 5 % 5 = 0, remainder in remainder_count, so increment count by 1\\nReturn count = 5\\nSo the output is 5.\\n\\n# Don\\'t leave without upvoting ^_^\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@vinaygottipamula](/vinaygottipamula)\\n plz explain the intiution behind rem<0 then rem+=k."
                    },
                    {
                        "username": "jskipper2020",
                        "content": "how do you know that a repeated remainder means there is +(remainder) in the answer?"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "But the output is 7, and yes it is coming when we run the above code. There is a small mistake in your dry run method..Please note that.\n\nWe are increasing the count value only when we find the remainder in hashtable with the existing hash value (of the remainder) not with 1. \nHope you get it :-)\n\nU also missed this condition in your code\nif(remainder<0)remainder+=k;"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**Bruteforce to Optimization**\nThe naïve bruteforce solution would be - for all possible subarray start and end indexes, calculate the sum. So, the algorithm becomes $O(n^3)$. We can optimize this using the prefix sum idea. $SubarraySum(i,j) = PrefixSum(j) - PrefixSum(i-1)$. This reduces the time complexity to $O(n^2)$.\n\nNow, for this problem,\n$$\nPrefixSum(j) - PrefixSum(i-1) = 0 \\  [modulo \\ k]\n$$\n$$ \n=> PrefixSum(j) = PrefixSum(i-1) \\ [modulo \\ k]\n$$\n\nSo, we can get rid of the loop and count the frequency of the current prefix sum to solve the problem. The final time complexity would be $O(n)$. The only corner case would be negative modulos."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "[@Babu_frik](/Babu_frik) The modulus is negative when the prefix sum is negative. In that case, you have to add `k` to the mod to make it positive. "
                    },
                    {
                        "username": "Babu_frik",
                        "content": "When is it negative modulus? Can you please throw insight on that case?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is an excellent hint and explanation! I always get TLE on all my solutions so this was very helpful. For people trying out this approach, also take note of how to handle $$PrefixSum(0 - 1)$$ for subarrays starting at $$i=0$$. "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Leetcode January TREES -> ARRAYS "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem Statement is simple to understand, but deducing `prefix + currElem % K + K` is a whole different level of problem"
                    },
                    {
                        "username": "prototye",
                        "content": "can you tell me the thought process and in general explanation on how we came up with this prefix + nums[i] % k + k thing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "With brute force approach, we could we could solve 66/73 testcases. After that, I get TLE. Can anyone tell me the approach to optimize it? "
                    },
                    {
                        "username": "taj_1",
                        "content": "[@mayank-01](/mayank-01) \\npublic int subarraysDivByK(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j<nums.length;j++){\\n                int sum = 0;\\n                for(int l=i;l<=j;l++){\\n                    sum+=nums[l];\\n                }\\n                if(sum%k==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "mayank-01",
                        "content": "can anyone share the brute force code."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "You can use a solution in which calculate prefix sums and at every stage calculate remainder with \\'K\\'  and store it in unordered map along with their frequencies Can be done in O(n) time .iI will post solution for this in a while"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Is it supposed to be done in O(n) or O(n^2) ?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) yeah that\\'s the one thing that can always be done. But I need to learn the optimization techniques instead of just copying the solutions every time :("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i passed 68 with O(n^2) now go to solution tab that\\'s what i am going to do"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach:\n* For each index i, count all previous prefix sums in the array which has modulo same as of current prefix sum (at idx i) and add it to result.\n`Use HashTable to store the counts of prefix sum modulo`.\n* Also, for a -ve number num, num%k<0, we have to change it to +ve mod because modulo of a number can lie in the range of 0 to k-1 only.\n\nLet, num = -2, k=3 then `res=(-2)%3=-2`, for changing it to +ve mod add k to res.\nChanging to +ve mod, `-2+3 = 1`, So, `res=(-2)%3=1`.\n\n### Complexity: O(n) time and O(k) space"
                    },
                    {
                        "username": "a_parth",
                        "content": "but why we need to calculate +ve modulo. Why we can\\'t go ahead with -ve modulo?"
                    }
                ]
            },
            {
                "id": 1764031,
                "content": [
                    {
                        "username": "lucyG",
                        "content": "When I tried to solve this problem, I didn\\'t come up with **Prefix Sum** at all.\\n\\nMy question for you guys who thought of using Prefix Sum to solve it is how/why did you know that you gonna use Prefix Sum for it? \\n\\nI could only come up with the following possilbe reasons:\\n1. It looks like a problem that Prefix Sum could help with;\\n2. This is a problem related to Array & Modulo;\\n3. You just have a feeling...\\n\\nReally appreciate it."
                    },
                    {
                        "username": "CodeID99",
                        "content": "Hi, I first solved this problem with O(n**2), then moved to a find a better solution. Since it\\'s asking for a subarray, there is not much I could think of, except sliding window and prefix sum. Sliding window won\\'t work for this problem, so I solved it with prefix sum."
                    },
                    {
                        "username": "akansha_01",
                        "content": "damm true :)\\n"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "[@zarif98sjs](/zarif98sjs) How long is that experience?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, the first thing to see is that constraints are such that n^2 was directly out of scope. Sorting is also out of question since that ruins the subarrays so in a way n.log(n) was also out. With only O(n) complexity possible, there are not much things left apart from prefix sum. Plus having an O(n^2) solution would make this problem a dumb one, so knew in the first minute itself that we cant do without cumulative i.e prefix sum."
                    },
                    {
                        "username": "kandiana",
                        "content": "I figured it from the math point of view + from the algorithms I considered for the previous daily problem?\\nSubarray sum = difference between two prefix sums, it will be divided by k if prefix sums have the same mod k value. Hence I need to count mod k values and then caclulate the number of pairs for each count (for 0: n * (n + 1) / 2, for the rest: n * ( n - 1) / 2)\\n"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "Similar problems. I just recognize the pattern now"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "I guess from the experience of solving similar problems."
                    },
                    {
                        "username": "istewartbinks",
                        "content": "I came up with prefix sum. It\\'s asking for a contiguous subarray sum (mod k), which is easy to get in n^2 time if you have a prefix sum. I\\'ve done problems like this before. If I didn\\'t know what prefix sum was, I wouldn\\'t know how to answer this problem.\\n\\nConsider it pattern matching."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "There is a similar problem. Leetcode 560. Subarray Sum Equals K. Try that. Then you can instantly identify this needs a prefix sum."
                    },
                    {
                        "username": "arghyadas",
                        "content": "The SubArray week is far better than TREE and GRAPH Week\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@cwooldridge](/cwooldridge) \\nThat\\'s the fun of arrays. The answer is in front of you, but you aren\\'t able to identify it."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I disagree, graph question in general have similar solutions and better patterns. I feel subarrays and array questions in general require alot more creativity and have much more clever solutions"
                    },
                    {
                        "username": "mayank-01",
                        "content": "so true..\\uD83D\\uDE02"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "truee......"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "True dat!\\n"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "True\\uD83D\\uDE02"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This would be very easy if you could use a double for loop .\\nThe official answer requires you to have a god-tier understanding of math.\\nI don\\'t see how it is possible for people to solve questions like this blind and during a coding interview "
                    },
                    {
                        "username": "deciduousflame538",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run the outer loop till the length of array starting from 0, and the inner loop from a value equal to j and till the length of array. \\nfor(int i = 0; i < size; ++i)\\nfor(int j = i ; j<size; ++j)"
                    },
                    {
                        "username": "sandipt335",
                        "content": "[@ironmonger1](/ironmonger1) doesnt help either my good sir"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run both loops till end but start the second loop from one place after the initial loop"
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I am solving it by using double for loop only, but i got stuck with till what value i have to run both loops. Could you pls help me with this\\n"
                    },
                    {
                        "username": "jkulanko",
                        "content": "I highly recommend anyone who is serious about mastering leetcode to follow the usaco.guide website.  There's more there than you'll ever use in leetcode but if you enjoy or want to get good at competitive programming I recommend it.  There is a problem exactly like this https://usaco.guide/problems/usaco-595-subsequences-summing-to-sevens/solution.  I remembered this problem and was able to come up with the O(n) solution in minutes.  I've been working through the modules for about a month and my leetcode rating has jumped 150 points"
                    },
                    {
                        "username": "algoacer",
                        "content": "Thanks for this recommendation. Any tips you would like to share for someone going to start doing usaco? Thanks.."
                    },
                    {
                        "username": "user1421n",
                        "content": "To be honnest, it took me sometime to undestand the transition from one idea to another, I think if there is more explanation, it will be better, but it's okay"
                    },
                    {
                        "username": "jkulanko",
                        "content": "[@MaratKhakim](/MaratKhakim)  I recommend going through it level and topic wise. I.E. do the bronze modules first topic by topic. Do problems on each topic until you\\u2019re sick of them or think you\\u2019ve mastered the topic"
                    },
                    {
                        "username": "MaratKhakim",
                        "content": "Thanks.  [@Jacob Kulanko](/jkulanko)How are you studying there? Learning topicwise and solving problems on usaco? Please, share your study techniques"
                    },
                    {
                        "username": "jkulanko",
                        "content": "Here\\u2019s a follow up problem if anyone wants to try a slightly harder but similar problem: https://atcoder.jp/contests/abc164/tasks/abc164_d"
                    },
                    {
                        "username": "Hrushi73",
                        "content": "great share, I am going to follow this problem set\\n"
                    },
                    {
                        "username": "legitroman",
                        "content": "Thanks for the share! It was very helpful."
                    },
                    {
                        "username": "truthsayer_Inshadows",
                        "content": "use a hash map to keep track of the remainder of the running sum of the array modulo k. For each index i in the array, we calculate the running sum from index 0 to i, and find its remainder when divided by k. We then check if the remainder already exists in the hash map. If it does, it means that there is a subarray with a sum that is divisible by k, and we increment the count of subarrays. If the remainder doesn\\'t exist in the hash map, we add it to the hash map with a count of 1.\\n\\n\\n```cpp\\n\\nint subarraySum(vector<int>& nums, int k) {\\n    int count = 0;\\n    int running_sum = 0;\\n    unordered_map<int, int> remainder_count;\\n    remainder_count[0] = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        running_sum += nums[i];\\n        int remainder = running_sum % k;\\n        if (remainder_count.find(remainder) != remainder_count.end()) {\\n            count += remainder_count[remainder];\\n        }\\n        if (remainder_count.find(remainder) == remainder_count.end()) {\\n            remainder_count[remainder] = 1;\\n        } else {\\n            remainder_count[remainder]++;\\n        }\\n    }\\n    return count;\\n}\\n\\n```\\n## Test case dry run:\\nLet\\'s say nums = {4,5,0,-2,-3,1} and k = 5\\n\\nInitialize count = 0, running_sum = 0, remainder_count = {0: 1}\\nIterate through the array, starting at index 0:\\ni = 0, nums[i] = 4, running_sum = 4, remainder = 4 % 5 = 4, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 1, nums[i] = 5, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 2, nums[i] = 0, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 3, nums[i] = -2, running_sum = 7, remainder = 7 % 5 = 2, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 4, nums[i] = -3, running_sum = 4, remainder = 4 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 5, nums[i] = 1, running_sum = 5, remainder = 5 % 5 = 0, remainder in remainder_count, so increment count by 1\\nReturn count = 5\\nSo the output is 5.\\n\\n# Don\\'t leave without upvoting ^_^\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@vinaygottipamula](/vinaygottipamula)\\n plz explain the intiution behind rem<0 then rem+=k."
                    },
                    {
                        "username": "jskipper2020",
                        "content": "how do you know that a repeated remainder means there is +(remainder) in the answer?"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "But the output is 7, and yes it is coming when we run the above code. There is a small mistake in your dry run method..Please note that.\n\nWe are increasing the count value only when we find the remainder in hashtable with the existing hash value (of the remainder) not with 1. \nHope you get it :-)\n\nU also missed this condition in your code\nif(remainder<0)remainder+=k;"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**Bruteforce to Optimization**\nThe naïve bruteforce solution would be - for all possible subarray start and end indexes, calculate the sum. So, the algorithm becomes $O(n^3)$. We can optimize this using the prefix sum idea. $SubarraySum(i,j) = PrefixSum(j) - PrefixSum(i-1)$. This reduces the time complexity to $O(n^2)$.\n\nNow, for this problem,\n$$\nPrefixSum(j) - PrefixSum(i-1) = 0 \\  [modulo \\ k]\n$$\n$$ \n=> PrefixSum(j) = PrefixSum(i-1) \\ [modulo \\ k]\n$$\n\nSo, we can get rid of the loop and count the frequency of the current prefix sum to solve the problem. The final time complexity would be $O(n)$. The only corner case would be negative modulos."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "[@Babu_frik](/Babu_frik) The modulus is negative when the prefix sum is negative. In that case, you have to add `k` to the mod to make it positive. "
                    },
                    {
                        "username": "Babu_frik",
                        "content": "When is it negative modulus? Can you please throw insight on that case?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is an excellent hint and explanation! I always get TLE on all my solutions so this was very helpful. For people trying out this approach, also take note of how to handle $$PrefixSum(0 - 1)$$ for subarrays starting at $$i=0$$. "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Leetcode January TREES -> ARRAYS "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem Statement is simple to understand, but deducing `prefix + currElem % K + K` is a whole different level of problem"
                    },
                    {
                        "username": "prototye",
                        "content": "can you tell me the thought process and in general explanation on how we came up with this prefix + nums[i] % k + k thing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "With brute force approach, we could we could solve 66/73 testcases. After that, I get TLE. Can anyone tell me the approach to optimize it? "
                    },
                    {
                        "username": "taj_1",
                        "content": "[@mayank-01](/mayank-01) \\npublic int subarraysDivByK(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j<nums.length;j++){\\n                int sum = 0;\\n                for(int l=i;l<=j;l++){\\n                    sum+=nums[l];\\n                }\\n                if(sum%k==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "mayank-01",
                        "content": "can anyone share the brute force code."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "You can use a solution in which calculate prefix sums and at every stage calculate remainder with \\'K\\'  and store it in unordered map along with their frequencies Can be done in O(n) time .iI will post solution for this in a while"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Is it supposed to be done in O(n) or O(n^2) ?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) yeah that\\'s the one thing that can always be done. But I need to learn the optimization techniques instead of just copying the solutions every time :("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i passed 68 with O(n^2) now go to solution tab that\\'s what i am going to do"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach:\n* For each index i, count all previous prefix sums in the array which has modulo same as of current prefix sum (at idx i) and add it to result.\n`Use HashTable to store the counts of prefix sum modulo`.\n* Also, for a -ve number num, num%k<0, we have to change it to +ve mod because modulo of a number can lie in the range of 0 to k-1 only.\n\nLet, num = -2, k=3 then `res=(-2)%3=-2`, for changing it to +ve mod add k to res.\nChanging to +ve mod, `-2+3 = 1`, So, `res=(-2)%3=1`.\n\n### Complexity: O(n) time and O(k) space"
                    },
                    {
                        "username": "a_parth",
                        "content": "but why we need to calculate +ve modulo. Why we can\\'t go ahead with -ve modulo?"
                    }
                ]
            },
            {
                "id": 1764476,
                "content": [
                    {
                        "username": "lucyG",
                        "content": "When I tried to solve this problem, I didn\\'t come up with **Prefix Sum** at all.\\n\\nMy question for you guys who thought of using Prefix Sum to solve it is how/why did you know that you gonna use Prefix Sum for it? \\n\\nI could only come up with the following possilbe reasons:\\n1. It looks like a problem that Prefix Sum could help with;\\n2. This is a problem related to Array & Modulo;\\n3. You just have a feeling...\\n\\nReally appreciate it."
                    },
                    {
                        "username": "CodeID99",
                        "content": "Hi, I first solved this problem with O(n**2), then moved to a find a better solution. Since it\\'s asking for a subarray, there is not much I could think of, except sliding window and prefix sum. Sliding window won\\'t work for this problem, so I solved it with prefix sum."
                    },
                    {
                        "username": "akansha_01",
                        "content": "damm true :)\\n"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "[@zarif98sjs](/zarif98sjs) How long is that experience?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, the first thing to see is that constraints are such that n^2 was directly out of scope. Sorting is also out of question since that ruins the subarrays so in a way n.log(n) was also out. With only O(n) complexity possible, there are not much things left apart from prefix sum. Plus having an O(n^2) solution would make this problem a dumb one, so knew in the first minute itself that we cant do without cumulative i.e prefix sum."
                    },
                    {
                        "username": "kandiana",
                        "content": "I figured it from the math point of view + from the algorithms I considered for the previous daily problem?\\nSubarray sum = difference between two prefix sums, it will be divided by k if prefix sums have the same mod k value. Hence I need to count mod k values and then caclulate the number of pairs for each count (for 0: n * (n + 1) / 2, for the rest: n * ( n - 1) / 2)\\n"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "Similar problems. I just recognize the pattern now"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "I guess from the experience of solving similar problems."
                    },
                    {
                        "username": "istewartbinks",
                        "content": "I came up with prefix sum. It\\'s asking for a contiguous subarray sum (mod k), which is easy to get in n^2 time if you have a prefix sum. I\\'ve done problems like this before. If I didn\\'t know what prefix sum was, I wouldn\\'t know how to answer this problem.\\n\\nConsider it pattern matching."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "There is a similar problem. Leetcode 560. Subarray Sum Equals K. Try that. Then you can instantly identify this needs a prefix sum."
                    },
                    {
                        "username": "arghyadas",
                        "content": "The SubArray week is far better than TREE and GRAPH Week\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@cwooldridge](/cwooldridge) \\nThat\\'s the fun of arrays. The answer is in front of you, but you aren\\'t able to identify it."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I disagree, graph question in general have similar solutions and better patterns. I feel subarrays and array questions in general require alot more creativity and have much more clever solutions"
                    },
                    {
                        "username": "mayank-01",
                        "content": "so true..\\uD83D\\uDE02"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "truee......"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "True dat!\\n"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "True\\uD83D\\uDE02"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This would be very easy if you could use a double for loop .\\nThe official answer requires you to have a god-tier understanding of math.\\nI don\\'t see how it is possible for people to solve questions like this blind and during a coding interview "
                    },
                    {
                        "username": "deciduousflame538",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run the outer loop till the length of array starting from 0, and the inner loop from a value equal to j and till the length of array. \\nfor(int i = 0; i < size; ++i)\\nfor(int j = i ; j<size; ++j)"
                    },
                    {
                        "username": "sandipt335",
                        "content": "[@ironmonger1](/ironmonger1) doesnt help either my good sir"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run both loops till end but start the second loop from one place after the initial loop"
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I am solving it by using double for loop only, but i got stuck with till what value i have to run both loops. Could you pls help me with this\\n"
                    },
                    {
                        "username": "jkulanko",
                        "content": "I highly recommend anyone who is serious about mastering leetcode to follow the usaco.guide website.  There's more there than you'll ever use in leetcode but if you enjoy or want to get good at competitive programming I recommend it.  There is a problem exactly like this https://usaco.guide/problems/usaco-595-subsequences-summing-to-sevens/solution.  I remembered this problem and was able to come up with the O(n) solution in minutes.  I've been working through the modules for about a month and my leetcode rating has jumped 150 points"
                    },
                    {
                        "username": "algoacer",
                        "content": "Thanks for this recommendation. Any tips you would like to share for someone going to start doing usaco? Thanks.."
                    },
                    {
                        "username": "user1421n",
                        "content": "To be honnest, it took me sometime to undestand the transition from one idea to another, I think if there is more explanation, it will be better, but it's okay"
                    },
                    {
                        "username": "jkulanko",
                        "content": "[@MaratKhakim](/MaratKhakim)  I recommend going through it level and topic wise. I.E. do the bronze modules first topic by topic. Do problems on each topic until you\\u2019re sick of them or think you\\u2019ve mastered the topic"
                    },
                    {
                        "username": "MaratKhakim",
                        "content": "Thanks.  [@Jacob Kulanko](/jkulanko)How are you studying there? Learning topicwise and solving problems on usaco? Please, share your study techniques"
                    },
                    {
                        "username": "jkulanko",
                        "content": "Here\\u2019s a follow up problem if anyone wants to try a slightly harder but similar problem: https://atcoder.jp/contests/abc164/tasks/abc164_d"
                    },
                    {
                        "username": "Hrushi73",
                        "content": "great share, I am going to follow this problem set\\n"
                    },
                    {
                        "username": "legitroman",
                        "content": "Thanks for the share! It was very helpful."
                    },
                    {
                        "username": "truthsayer_Inshadows",
                        "content": "use a hash map to keep track of the remainder of the running sum of the array modulo k. For each index i in the array, we calculate the running sum from index 0 to i, and find its remainder when divided by k. We then check if the remainder already exists in the hash map. If it does, it means that there is a subarray with a sum that is divisible by k, and we increment the count of subarrays. If the remainder doesn\\'t exist in the hash map, we add it to the hash map with a count of 1.\\n\\n\\n```cpp\\n\\nint subarraySum(vector<int>& nums, int k) {\\n    int count = 0;\\n    int running_sum = 0;\\n    unordered_map<int, int> remainder_count;\\n    remainder_count[0] = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        running_sum += nums[i];\\n        int remainder = running_sum % k;\\n        if (remainder_count.find(remainder) != remainder_count.end()) {\\n            count += remainder_count[remainder];\\n        }\\n        if (remainder_count.find(remainder) == remainder_count.end()) {\\n            remainder_count[remainder] = 1;\\n        } else {\\n            remainder_count[remainder]++;\\n        }\\n    }\\n    return count;\\n}\\n\\n```\\n## Test case dry run:\\nLet\\'s say nums = {4,5,0,-2,-3,1} and k = 5\\n\\nInitialize count = 0, running_sum = 0, remainder_count = {0: 1}\\nIterate through the array, starting at index 0:\\ni = 0, nums[i] = 4, running_sum = 4, remainder = 4 % 5 = 4, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 1, nums[i] = 5, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 2, nums[i] = 0, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 3, nums[i] = -2, running_sum = 7, remainder = 7 % 5 = 2, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 4, nums[i] = -3, running_sum = 4, remainder = 4 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 5, nums[i] = 1, running_sum = 5, remainder = 5 % 5 = 0, remainder in remainder_count, so increment count by 1\\nReturn count = 5\\nSo the output is 5.\\n\\n# Don\\'t leave without upvoting ^_^\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@vinaygottipamula](/vinaygottipamula)\\n plz explain the intiution behind rem<0 then rem+=k."
                    },
                    {
                        "username": "jskipper2020",
                        "content": "how do you know that a repeated remainder means there is +(remainder) in the answer?"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "But the output is 7, and yes it is coming when we run the above code. There is a small mistake in your dry run method..Please note that.\n\nWe are increasing the count value only when we find the remainder in hashtable with the existing hash value (of the remainder) not with 1. \nHope you get it :-)\n\nU also missed this condition in your code\nif(remainder<0)remainder+=k;"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**Bruteforce to Optimization**\nThe naïve bruteforce solution would be - for all possible subarray start and end indexes, calculate the sum. So, the algorithm becomes $O(n^3)$. We can optimize this using the prefix sum idea. $SubarraySum(i,j) = PrefixSum(j) - PrefixSum(i-1)$. This reduces the time complexity to $O(n^2)$.\n\nNow, for this problem,\n$$\nPrefixSum(j) - PrefixSum(i-1) = 0 \\  [modulo \\ k]\n$$\n$$ \n=> PrefixSum(j) = PrefixSum(i-1) \\ [modulo \\ k]\n$$\n\nSo, we can get rid of the loop and count the frequency of the current prefix sum to solve the problem. The final time complexity would be $O(n)$. The only corner case would be negative modulos."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "[@Babu_frik](/Babu_frik) The modulus is negative when the prefix sum is negative. In that case, you have to add `k` to the mod to make it positive. "
                    },
                    {
                        "username": "Babu_frik",
                        "content": "When is it negative modulus? Can you please throw insight on that case?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is an excellent hint and explanation! I always get TLE on all my solutions so this was very helpful. For people trying out this approach, also take note of how to handle $$PrefixSum(0 - 1)$$ for subarrays starting at $$i=0$$. "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Leetcode January TREES -> ARRAYS "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem Statement is simple to understand, but deducing `prefix + currElem % K + K` is a whole different level of problem"
                    },
                    {
                        "username": "prototye",
                        "content": "can you tell me the thought process and in general explanation on how we came up with this prefix + nums[i] % k + k thing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "With brute force approach, we could we could solve 66/73 testcases. After that, I get TLE. Can anyone tell me the approach to optimize it? "
                    },
                    {
                        "username": "taj_1",
                        "content": "[@mayank-01](/mayank-01) \\npublic int subarraysDivByK(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j<nums.length;j++){\\n                int sum = 0;\\n                for(int l=i;l<=j;l++){\\n                    sum+=nums[l];\\n                }\\n                if(sum%k==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "mayank-01",
                        "content": "can anyone share the brute force code."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "You can use a solution in which calculate prefix sums and at every stage calculate remainder with \\'K\\'  and store it in unordered map along with their frequencies Can be done in O(n) time .iI will post solution for this in a while"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Is it supposed to be done in O(n) or O(n^2) ?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) yeah that\\'s the one thing that can always be done. But I need to learn the optimization techniques instead of just copying the solutions every time :("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i passed 68 with O(n^2) now go to solution tab that\\'s what i am going to do"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach:\n* For each index i, count all previous prefix sums in the array which has modulo same as of current prefix sum (at idx i) and add it to result.\n`Use HashTable to store the counts of prefix sum modulo`.\n* Also, for a -ve number num, num%k<0, we have to change it to +ve mod because modulo of a number can lie in the range of 0 to k-1 only.\n\nLet, num = -2, k=3 then `res=(-2)%3=-2`, for changing it to +ve mod add k to res.\nChanging to +ve mod, `-2+3 = 1`, So, `res=(-2)%3=1`.\n\n### Complexity: O(n) time and O(k) space"
                    },
                    {
                        "username": "a_parth",
                        "content": "but why we need to calculate +ve modulo. Why we can\\'t go ahead with -ve modulo?"
                    }
                ]
            },
            {
                "id": 1764355,
                "content": [
                    {
                        "username": "lucyG",
                        "content": "When I tried to solve this problem, I didn\\'t come up with **Prefix Sum** at all.\\n\\nMy question for you guys who thought of using Prefix Sum to solve it is how/why did you know that you gonna use Prefix Sum for it? \\n\\nI could only come up with the following possilbe reasons:\\n1. It looks like a problem that Prefix Sum could help with;\\n2. This is a problem related to Array & Modulo;\\n3. You just have a feeling...\\n\\nReally appreciate it."
                    },
                    {
                        "username": "CodeID99",
                        "content": "Hi, I first solved this problem with O(n**2), then moved to a find a better solution. Since it\\'s asking for a subarray, there is not much I could think of, except sliding window and prefix sum. Sliding window won\\'t work for this problem, so I solved it with prefix sum."
                    },
                    {
                        "username": "akansha_01",
                        "content": "damm true :)\\n"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "[@zarif98sjs](/zarif98sjs) How long is that experience?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, the first thing to see is that constraints are such that n^2 was directly out of scope. Sorting is also out of question since that ruins the subarrays so in a way n.log(n) was also out. With only O(n) complexity possible, there are not much things left apart from prefix sum. Plus having an O(n^2) solution would make this problem a dumb one, so knew in the first minute itself that we cant do without cumulative i.e prefix sum."
                    },
                    {
                        "username": "kandiana",
                        "content": "I figured it from the math point of view + from the algorithms I considered for the previous daily problem?\\nSubarray sum = difference between two prefix sums, it will be divided by k if prefix sums have the same mod k value. Hence I need to count mod k values and then caclulate the number of pairs for each count (for 0: n * (n + 1) / 2, for the rest: n * ( n - 1) / 2)\\n"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "Similar problems. I just recognize the pattern now"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "I guess from the experience of solving similar problems."
                    },
                    {
                        "username": "istewartbinks",
                        "content": "I came up with prefix sum. It\\'s asking for a contiguous subarray sum (mod k), which is easy to get in n^2 time if you have a prefix sum. I\\'ve done problems like this before. If I didn\\'t know what prefix sum was, I wouldn\\'t know how to answer this problem.\\n\\nConsider it pattern matching."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "There is a similar problem. Leetcode 560. Subarray Sum Equals K. Try that. Then you can instantly identify this needs a prefix sum."
                    },
                    {
                        "username": "arghyadas",
                        "content": "The SubArray week is far better than TREE and GRAPH Week\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@cwooldridge](/cwooldridge) \\nThat\\'s the fun of arrays. The answer is in front of you, but you aren\\'t able to identify it."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I disagree, graph question in general have similar solutions and better patterns. I feel subarrays and array questions in general require alot more creativity and have much more clever solutions"
                    },
                    {
                        "username": "mayank-01",
                        "content": "so true..\\uD83D\\uDE02"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "truee......"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "True dat!\\n"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "True\\uD83D\\uDE02"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This would be very easy if you could use a double for loop .\\nThe official answer requires you to have a god-tier understanding of math.\\nI don\\'t see how it is possible for people to solve questions like this blind and during a coding interview "
                    },
                    {
                        "username": "deciduousflame538",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run the outer loop till the length of array starting from 0, and the inner loop from a value equal to j and till the length of array. \\nfor(int i = 0; i < size; ++i)\\nfor(int j = i ; j<size; ++j)"
                    },
                    {
                        "username": "sandipt335",
                        "content": "[@ironmonger1](/ironmonger1) doesnt help either my good sir"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run both loops till end but start the second loop from one place after the initial loop"
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I am solving it by using double for loop only, but i got stuck with till what value i have to run both loops. Could you pls help me with this\\n"
                    },
                    {
                        "username": "jkulanko",
                        "content": "I highly recommend anyone who is serious about mastering leetcode to follow the usaco.guide website.  There's more there than you'll ever use in leetcode but if you enjoy or want to get good at competitive programming I recommend it.  There is a problem exactly like this https://usaco.guide/problems/usaco-595-subsequences-summing-to-sevens/solution.  I remembered this problem and was able to come up with the O(n) solution in minutes.  I've been working through the modules for about a month and my leetcode rating has jumped 150 points"
                    },
                    {
                        "username": "algoacer",
                        "content": "Thanks for this recommendation. Any tips you would like to share for someone going to start doing usaco? Thanks.."
                    },
                    {
                        "username": "user1421n",
                        "content": "To be honnest, it took me sometime to undestand the transition from one idea to another, I think if there is more explanation, it will be better, but it's okay"
                    },
                    {
                        "username": "jkulanko",
                        "content": "[@MaratKhakim](/MaratKhakim)  I recommend going through it level and topic wise. I.E. do the bronze modules first topic by topic. Do problems on each topic until you\\u2019re sick of them or think you\\u2019ve mastered the topic"
                    },
                    {
                        "username": "MaratKhakim",
                        "content": "Thanks.  [@Jacob Kulanko](/jkulanko)How are you studying there? Learning topicwise and solving problems on usaco? Please, share your study techniques"
                    },
                    {
                        "username": "jkulanko",
                        "content": "Here\\u2019s a follow up problem if anyone wants to try a slightly harder but similar problem: https://atcoder.jp/contests/abc164/tasks/abc164_d"
                    },
                    {
                        "username": "Hrushi73",
                        "content": "great share, I am going to follow this problem set\\n"
                    },
                    {
                        "username": "legitroman",
                        "content": "Thanks for the share! It was very helpful."
                    },
                    {
                        "username": "truthsayer_Inshadows",
                        "content": "use a hash map to keep track of the remainder of the running sum of the array modulo k. For each index i in the array, we calculate the running sum from index 0 to i, and find its remainder when divided by k. We then check if the remainder already exists in the hash map. If it does, it means that there is a subarray with a sum that is divisible by k, and we increment the count of subarrays. If the remainder doesn\\'t exist in the hash map, we add it to the hash map with a count of 1.\\n\\n\\n```cpp\\n\\nint subarraySum(vector<int>& nums, int k) {\\n    int count = 0;\\n    int running_sum = 0;\\n    unordered_map<int, int> remainder_count;\\n    remainder_count[0] = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        running_sum += nums[i];\\n        int remainder = running_sum % k;\\n        if (remainder_count.find(remainder) != remainder_count.end()) {\\n            count += remainder_count[remainder];\\n        }\\n        if (remainder_count.find(remainder) == remainder_count.end()) {\\n            remainder_count[remainder] = 1;\\n        } else {\\n            remainder_count[remainder]++;\\n        }\\n    }\\n    return count;\\n}\\n\\n```\\n## Test case dry run:\\nLet\\'s say nums = {4,5,0,-2,-3,1} and k = 5\\n\\nInitialize count = 0, running_sum = 0, remainder_count = {0: 1}\\nIterate through the array, starting at index 0:\\ni = 0, nums[i] = 4, running_sum = 4, remainder = 4 % 5 = 4, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 1, nums[i] = 5, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 2, nums[i] = 0, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 3, nums[i] = -2, running_sum = 7, remainder = 7 % 5 = 2, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 4, nums[i] = -3, running_sum = 4, remainder = 4 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 5, nums[i] = 1, running_sum = 5, remainder = 5 % 5 = 0, remainder in remainder_count, so increment count by 1\\nReturn count = 5\\nSo the output is 5.\\n\\n# Don\\'t leave without upvoting ^_^\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@vinaygottipamula](/vinaygottipamula)\\n plz explain the intiution behind rem<0 then rem+=k."
                    },
                    {
                        "username": "jskipper2020",
                        "content": "how do you know that a repeated remainder means there is +(remainder) in the answer?"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "But the output is 7, and yes it is coming when we run the above code. There is a small mistake in your dry run method..Please note that.\n\nWe are increasing the count value only when we find the remainder in hashtable with the existing hash value (of the remainder) not with 1. \nHope you get it :-)\n\nU also missed this condition in your code\nif(remainder<0)remainder+=k;"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**Bruteforce to Optimization**\nThe naïve bruteforce solution would be - for all possible subarray start and end indexes, calculate the sum. So, the algorithm becomes $O(n^3)$. We can optimize this using the prefix sum idea. $SubarraySum(i,j) = PrefixSum(j) - PrefixSum(i-1)$. This reduces the time complexity to $O(n^2)$.\n\nNow, for this problem,\n$$\nPrefixSum(j) - PrefixSum(i-1) = 0 \\  [modulo \\ k]\n$$\n$$ \n=> PrefixSum(j) = PrefixSum(i-1) \\ [modulo \\ k]\n$$\n\nSo, we can get rid of the loop and count the frequency of the current prefix sum to solve the problem. The final time complexity would be $O(n)$. The only corner case would be negative modulos."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "[@Babu_frik](/Babu_frik) The modulus is negative when the prefix sum is negative. In that case, you have to add `k` to the mod to make it positive. "
                    },
                    {
                        "username": "Babu_frik",
                        "content": "When is it negative modulus? Can you please throw insight on that case?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is an excellent hint and explanation! I always get TLE on all my solutions so this was very helpful. For people trying out this approach, also take note of how to handle $$PrefixSum(0 - 1)$$ for subarrays starting at $$i=0$$. "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Leetcode January TREES -> ARRAYS "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem Statement is simple to understand, but deducing `prefix + currElem % K + K` is a whole different level of problem"
                    },
                    {
                        "username": "prototye",
                        "content": "can you tell me the thought process and in general explanation on how we came up with this prefix + nums[i] % k + k thing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "With brute force approach, we could we could solve 66/73 testcases. After that, I get TLE. Can anyone tell me the approach to optimize it? "
                    },
                    {
                        "username": "taj_1",
                        "content": "[@mayank-01](/mayank-01) \\npublic int subarraysDivByK(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j<nums.length;j++){\\n                int sum = 0;\\n                for(int l=i;l<=j;l++){\\n                    sum+=nums[l];\\n                }\\n                if(sum%k==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "mayank-01",
                        "content": "can anyone share the brute force code."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "You can use a solution in which calculate prefix sums and at every stage calculate remainder with \\'K\\'  and store it in unordered map along with their frequencies Can be done in O(n) time .iI will post solution for this in a while"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Is it supposed to be done in O(n) or O(n^2) ?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) yeah that\\'s the one thing that can always be done. But I need to learn the optimization techniques instead of just copying the solutions every time :("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i passed 68 with O(n^2) now go to solution tab that\\'s what i am going to do"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach:\n* For each index i, count all previous prefix sums in the array which has modulo same as of current prefix sum (at idx i) and add it to result.\n`Use HashTable to store the counts of prefix sum modulo`.\n* Also, for a -ve number num, num%k<0, we have to change it to +ve mod because modulo of a number can lie in the range of 0 to k-1 only.\n\nLet, num = -2, k=3 then `res=(-2)%3=-2`, for changing it to +ve mod add k to res.\nChanging to +ve mod, `-2+3 = 1`, So, `res=(-2)%3=1`.\n\n### Complexity: O(n) time and O(k) space"
                    },
                    {
                        "username": "a_parth",
                        "content": "but why we need to calculate +ve modulo. Why we can\\'t go ahead with -ve modulo?"
                    }
                ]
            },
            {
                "id": 1764236,
                "content": [
                    {
                        "username": "lucyG",
                        "content": "When I tried to solve this problem, I didn\\'t come up with **Prefix Sum** at all.\\n\\nMy question for you guys who thought of using Prefix Sum to solve it is how/why did you know that you gonna use Prefix Sum for it? \\n\\nI could only come up with the following possilbe reasons:\\n1. It looks like a problem that Prefix Sum could help with;\\n2. This is a problem related to Array & Modulo;\\n3. You just have a feeling...\\n\\nReally appreciate it."
                    },
                    {
                        "username": "CodeID99",
                        "content": "Hi, I first solved this problem with O(n**2), then moved to a find a better solution. Since it\\'s asking for a subarray, there is not much I could think of, except sliding window and prefix sum. Sliding window won\\'t work for this problem, so I solved it with prefix sum."
                    },
                    {
                        "username": "akansha_01",
                        "content": "damm true :)\\n"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "[@zarif98sjs](/zarif98sjs) How long is that experience?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, the first thing to see is that constraints are such that n^2 was directly out of scope. Sorting is also out of question since that ruins the subarrays so in a way n.log(n) was also out. With only O(n) complexity possible, there are not much things left apart from prefix sum. Plus having an O(n^2) solution would make this problem a dumb one, so knew in the first minute itself that we cant do without cumulative i.e prefix sum."
                    },
                    {
                        "username": "kandiana",
                        "content": "I figured it from the math point of view + from the algorithms I considered for the previous daily problem?\\nSubarray sum = difference between two prefix sums, it will be divided by k if prefix sums have the same mod k value. Hence I need to count mod k values and then caclulate the number of pairs for each count (for 0: n * (n + 1) / 2, for the rest: n * ( n - 1) / 2)\\n"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "Similar problems. I just recognize the pattern now"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "I guess from the experience of solving similar problems."
                    },
                    {
                        "username": "istewartbinks",
                        "content": "I came up with prefix sum. It\\'s asking for a contiguous subarray sum (mod k), which is easy to get in n^2 time if you have a prefix sum. I\\'ve done problems like this before. If I didn\\'t know what prefix sum was, I wouldn\\'t know how to answer this problem.\\n\\nConsider it pattern matching."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "There is a similar problem. Leetcode 560. Subarray Sum Equals K. Try that. Then you can instantly identify this needs a prefix sum."
                    },
                    {
                        "username": "arghyadas",
                        "content": "The SubArray week is far better than TREE and GRAPH Week\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@cwooldridge](/cwooldridge) \\nThat\\'s the fun of arrays. The answer is in front of you, but you aren\\'t able to identify it."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I disagree, graph question in general have similar solutions and better patterns. I feel subarrays and array questions in general require alot more creativity and have much more clever solutions"
                    },
                    {
                        "username": "mayank-01",
                        "content": "so true..\\uD83D\\uDE02"
                    },
                    {
                        "username": "halfengineer",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "truee......"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "True dat!\\n"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "True\\uD83D\\uDE02"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This would be very easy if you could use a double for loop .\\nThe official answer requires you to have a god-tier understanding of math.\\nI don\\'t see how it is possible for people to solve questions like this blind and during a coding interview "
                    },
                    {
                        "username": "deciduousflame538",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run the outer loop till the length of array starting from 0, and the inner loop from a value equal to j and till the length of array. \\nfor(int i = 0; i < size; ++i)\\nfor(int j = i ; j<size; ++j)"
                    },
                    {
                        "username": "sandipt335",
                        "content": "[@ironmonger1](/ironmonger1) doesnt help either my good sir"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@NagarapuNagaVenkataSivaSaiRagh](/NagarapuNagaVenkataSivaSaiRagh) run both loops till end but start the second loop from one place after the initial loop"
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I am solving it by using double for loop only, but i got stuck with till what value i have to run both loops. Could you pls help me with this\\n"
                    },
                    {
                        "username": "jkulanko",
                        "content": "I highly recommend anyone who is serious about mastering leetcode to follow the usaco.guide website.  There's more there than you'll ever use in leetcode but if you enjoy or want to get good at competitive programming I recommend it.  There is a problem exactly like this https://usaco.guide/problems/usaco-595-subsequences-summing-to-sevens/solution.  I remembered this problem and was able to come up with the O(n) solution in minutes.  I've been working through the modules for about a month and my leetcode rating has jumped 150 points"
                    },
                    {
                        "username": "algoacer",
                        "content": "Thanks for this recommendation. Any tips you would like to share for someone going to start doing usaco? Thanks.."
                    },
                    {
                        "username": "user1421n",
                        "content": "To be honnest, it took me sometime to undestand the transition from one idea to another, I think if there is more explanation, it will be better, but it's okay"
                    },
                    {
                        "username": "jkulanko",
                        "content": "[@MaratKhakim](/MaratKhakim)  I recommend going through it level and topic wise. I.E. do the bronze modules first topic by topic. Do problems on each topic until you\\u2019re sick of them or think you\\u2019ve mastered the topic"
                    },
                    {
                        "username": "MaratKhakim",
                        "content": "Thanks.  [@Jacob Kulanko](/jkulanko)How are you studying there? Learning topicwise and solving problems on usaco? Please, share your study techniques"
                    },
                    {
                        "username": "jkulanko",
                        "content": "Here\\u2019s a follow up problem if anyone wants to try a slightly harder but similar problem: https://atcoder.jp/contests/abc164/tasks/abc164_d"
                    },
                    {
                        "username": "Hrushi73",
                        "content": "great share, I am going to follow this problem set\\n"
                    },
                    {
                        "username": "legitroman",
                        "content": "Thanks for the share! It was very helpful."
                    },
                    {
                        "username": "truthsayer_Inshadows",
                        "content": "use a hash map to keep track of the remainder of the running sum of the array modulo k. For each index i in the array, we calculate the running sum from index 0 to i, and find its remainder when divided by k. We then check if the remainder already exists in the hash map. If it does, it means that there is a subarray with a sum that is divisible by k, and we increment the count of subarrays. If the remainder doesn\\'t exist in the hash map, we add it to the hash map with a count of 1.\\n\\n\\n```cpp\\n\\nint subarraySum(vector<int>& nums, int k) {\\n    int count = 0;\\n    int running_sum = 0;\\n    unordered_map<int, int> remainder_count;\\n    remainder_count[0] = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        running_sum += nums[i];\\n        int remainder = running_sum % k;\\n        if (remainder_count.find(remainder) != remainder_count.end()) {\\n            count += remainder_count[remainder];\\n        }\\n        if (remainder_count.find(remainder) == remainder_count.end()) {\\n            remainder_count[remainder] = 1;\\n        } else {\\n            remainder_count[remainder]++;\\n        }\\n    }\\n    return count;\\n}\\n\\n```\\n## Test case dry run:\\nLet\\'s say nums = {4,5,0,-2,-3,1} and k = 5\\n\\nInitialize count = 0, running_sum = 0, remainder_count = {0: 1}\\nIterate through the array, starting at index 0:\\ni = 0, nums[i] = 4, running_sum = 4, remainder = 4 % 5 = 4, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 1, nums[i] = 5, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 2, nums[i] = 0, running_sum = 9, remainder = 9 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 3, nums[i] = -2, running_sum = 7, remainder = 7 % 5 = 2, remainder not in remainder_count, so add remainder to remainder_count with count 1\\ni = 4, nums[i] = -3, running_sum = 4, remainder = 4 % 5 = 4, remainder in remainder_count, so increment count by 1\\ni = 5, nums[i] = 1, running_sum = 5, remainder = 5 % 5 = 0, remainder in remainder_count, so increment count by 1\\nReturn count = 5\\nSo the output is 5.\\n\\n# Don\\'t leave without upvoting ^_^\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@vinaygottipamula](/vinaygottipamula)\\n plz explain the intiution behind rem<0 then rem+=k."
                    },
                    {
                        "username": "jskipper2020",
                        "content": "how do you know that a repeated remainder means there is +(remainder) in the answer?"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "But the output is 7, and yes it is coming when we run the above code. There is a small mistake in your dry run method..Please note that.\n\nWe are increasing the count value only when we find the remainder in hashtable with the existing hash value (of the remainder) not with 1. \nHope you get it :-)\n\nU also missed this condition in your code\nif(remainder<0)remainder+=k;"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**Bruteforce to Optimization**\nThe naïve bruteforce solution would be - for all possible subarray start and end indexes, calculate the sum. So, the algorithm becomes $O(n^3)$. We can optimize this using the prefix sum idea. $SubarraySum(i,j) = PrefixSum(j) - PrefixSum(i-1)$. This reduces the time complexity to $O(n^2)$.\n\nNow, for this problem,\n$$\nPrefixSum(j) - PrefixSum(i-1) = 0 \\  [modulo \\ k]\n$$\n$$ \n=> PrefixSum(j) = PrefixSum(i-1) \\ [modulo \\ k]\n$$\n\nSo, we can get rid of the loop and count the frequency of the current prefix sum to solve the problem. The final time complexity would be $O(n)$. The only corner case would be negative modulos."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "[@Babu_frik](/Babu_frik) The modulus is negative when the prefix sum is negative. In that case, you have to add `k` to the mod to make it positive. "
                    },
                    {
                        "username": "Babu_frik",
                        "content": "When is it negative modulus? Can you please throw insight on that case?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is an excellent hint and explanation! I always get TLE on all my solutions so this was very helpful. For people trying out this approach, also take note of how to handle $$PrefixSum(0 - 1)$$ for subarrays starting at $$i=0$$. "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Leetcode January TREES -> ARRAYS "
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Problem Statement is simple to understand, but deducing `prefix + currElem % K + K` is a whole different level of problem"
                    },
                    {
                        "username": "prototye",
                        "content": "can you tell me the thought process and in general explanation on how we came up with this prefix + nums[i] % k + k thing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "With brute force approach, we could we could solve 66/73 testcases. After that, I get TLE. Can anyone tell me the approach to optimize it? "
                    },
                    {
                        "username": "taj_1",
                        "content": "[@mayank-01](/mayank-01) \\npublic int subarraysDivByK(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j<nums.length;j++){\\n                int sum = 0;\\n                for(int l=i;l<=j;l++){\\n                    sum+=nums[l];\\n                }\\n                if(sum%k==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "mayank-01",
                        "content": "can anyone share the brute force code."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "You can use a solution in which calculate prefix sums and at every stage calculate remainder with \\'K\\'  and store it in unordered map along with their frequencies Can be done in O(n) time .iI will post solution for this in a while"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Is it supposed to be done in O(n) or O(n^2) ?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) yeah that\\'s the one thing that can always be done. But I need to learn the optimization techniques instead of just copying the solutions every time :("
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i passed 68 with O(n^2) now go to solution tab that\\'s what i am going to do"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach:\n* For each index i, count all previous prefix sums in the array which has modulo same as of current prefix sum (at idx i) and add it to result.\n`Use HashTable to store the counts of prefix sum modulo`.\n* Also, for a -ve number num, num%k<0, we have to change it to +ve mod because modulo of a number can lie in the range of 0 to k-1 only.\n\nLet, num = -2, k=3 then `res=(-2)%3=-2`, for changing it to +ve mod add k to res.\nChanging to +ve mod, `-2+3 = 1`, So, `res=(-2)%3=1`.\n\n### Complexity: O(n) time and O(k) space"
                    },
                    {
                        "username": "a_parth",
                        "content": "but why we need to calculate +ve modulo. Why we can\\'t go ahead with -ve modulo?"
                    }
                ]
            },
            {
                "id": 1666947,
                "content": [
                    {
                        "username": "kumardippu",
                        "content": "There should be 15 subarrays which can divide by 5 of [4,5,0,-2,-3,1]\\n[[4, 5, 0, -2, -3, 1], [4, 5, 0, 1], [4, 5 , -2, -3, 1], [4, 5, 1], [4, 0, -2, -3, 1], [4, 0, 1], [4, -2, -3, 1], [4, 1], [5], [5, 0], [5, 0, -2, -3], [5, -2, -3], [0], [0, -2, -3], [-2, -3]]\\n\\nAnybody please explain me about below solution:\\nInput: nums = [4,5,0,-2,-3,1], k = 5\\nOutput: 7\\nExplanation: There are 7 subarrays with a sum divisible by k = 5:\\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Stated in the problem description :- A subarray is a contiguous part of an array."
                    },
                    {
                        "username": "Akarshucet",
                        "content": "The demand of question about continues subarrays"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "continues val from [i..j],  is consider as  a subarray, and which u have done is subsquences, and if we do not consider sequnceing and pick elements then it is subset"
                    },
                    {
                        "username": "arjun202",
                        "content": "a subarray is formed by picking contiguous elements(one after the other), here you are not following this condition. Hope it helps.\\n"
                    },
                    {
                        "username": "mochy",
                        "content": "```\\n(p2-p1) % k = 0\\n=> p2 % k = p1 % k\\n```"
                    },
                    {
                        "username": "a_parth",
                        "content": "Explanation : Why we need to convert -ve modulo to +ve modulo. \\n\\nHere is one TC failing if we do not convert -ve modulo to +ve modulo.\\n\\n`[-4, -1, 5, 5] k=2` and expected `ans=3`\\nPrefix sum array become - `[-4, -5, 0, 5]`\\nPrefix sum array after applying `%` become - [0, -1, 0, 1] gives us `ans=2`.\\n\\nWhy this is happening? Answer is Euclidian Modulo. Here is the explanation of Euclidian Modulo:\\nSuppose we are doing 21%5. And modulo is what we add to make 21 divisible by 5. We have 2 options to do that. Either we deduct 1 or we add 4. Mathematically - \\n`21 = (4*5) + 1` or `21 = (5*5) + (-4)`\\nHere 1 and -4 are modulo. Means we can have two modulo for one modulo operation.\\n\\nIn some languages (java, cpp), modulo of positive number yields positive modulo and negative modulo yields negative modulo. But to make `Si%k == Sj%k` we should expect consistency on `%` operation. So to make operation consistent we are making -ve mod to +ve mod.!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Mayank Sharma](/mayank-01)\nhere is brute force method\n\n```\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        int n=nums.size(),count=0;\n        long int sum=0;\n         sum=nums[0];\n        for(int i=0; i<n; i++){\n           if(nums[i]%k==0){count++;}\n             sum=nums[i];\n            for(int j=i+1; j<n; j++){\n            sum+=nums[j];\n            if(sum%k==0){count++;}\n        }\n               }\n\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": " [@Vijay Bhaskar](/vijay__bhaskar)"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "A really interesting problem, but the chances you actually get asked it is quite low because of the number theory it requires."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i came up a solution with O(n^2) time complexity and I knew it would give me a tle can anyone suggest a hint how to reduce it to O(nlogn) or O(n),\\n\\nGive a hint it would be helpful."
                    },
                    {
                        "username": "jkulanko",
                        "content": "Prefix sum"
                    },
                    {
                        "username": "hossamabdullah",
                        "content": "I couldn\\'t get this part \\n prefix[i+1] = prefix[i] + ((nums[i]%k) +k)%k; \\ncan someone help or point to a resource that could help"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just set run this code u will get ur answer"
                    },
                    {
                        "username": "rohitadarsh02",
                        "content": "Brute force code for this solution\n\n\nclass Solution {\n    public int subarraysDivByK(int[] nums, int k) {\n        int sum=0;\n        int count=0;\n        for(int i=0;i<nums.length;i++){\n            for(int j=i;j<nums.length;j++){\n                sum=sum+nums[j];\n                if( sum%k==0){\n                    count++;\n                }\n                \n            }\n            sum=0;\n        }\n        return count;\n    }\n}\nWith brute force technique i passed 69/73.\n\n"
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "HOW DO I THINK OF IT IN AN INTERVIEW? \\nI got till the prefix, but after that it became a hassle."
                    }
                ]
            },
            {
                "id": 1867289,
                "content": [
                    {
                        "username": "kumardippu",
                        "content": "There should be 15 subarrays which can divide by 5 of [4,5,0,-2,-3,1]\\n[[4, 5, 0, -2, -3, 1], [4, 5, 0, 1], [4, 5 , -2, -3, 1], [4, 5, 1], [4, 0, -2, -3, 1], [4, 0, 1], [4, -2, -3, 1], [4, 1], [5], [5, 0], [5, 0, -2, -3], [5, -2, -3], [0], [0, -2, -3], [-2, -3]]\\n\\nAnybody please explain me about below solution:\\nInput: nums = [4,5,0,-2,-3,1], k = 5\\nOutput: 7\\nExplanation: There are 7 subarrays with a sum divisible by k = 5:\\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Stated in the problem description :- A subarray is a contiguous part of an array."
                    },
                    {
                        "username": "Akarshucet",
                        "content": "The demand of question about continues subarrays"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "continues val from [i..j],  is consider as  a subarray, and which u have done is subsquences, and if we do not consider sequnceing and pick elements then it is subset"
                    },
                    {
                        "username": "arjun202",
                        "content": "a subarray is formed by picking contiguous elements(one after the other), here you are not following this condition. Hope it helps.\\n"
                    },
                    {
                        "username": "mochy",
                        "content": "```\\n(p2-p1) % k = 0\\n=> p2 % k = p1 % k\\n```"
                    },
                    {
                        "username": "a_parth",
                        "content": "Explanation : Why we need to convert -ve modulo to +ve modulo. \\n\\nHere is one TC failing if we do not convert -ve modulo to +ve modulo.\\n\\n`[-4, -1, 5, 5] k=2` and expected `ans=3`\\nPrefix sum array become - `[-4, -5, 0, 5]`\\nPrefix sum array after applying `%` become - [0, -1, 0, 1] gives us `ans=2`.\\n\\nWhy this is happening? Answer is Euclidian Modulo. Here is the explanation of Euclidian Modulo:\\nSuppose we are doing 21%5. And modulo is what we add to make 21 divisible by 5. We have 2 options to do that. Either we deduct 1 or we add 4. Mathematically - \\n`21 = (4*5) + 1` or `21 = (5*5) + (-4)`\\nHere 1 and -4 are modulo. Means we can have two modulo for one modulo operation.\\n\\nIn some languages (java, cpp), modulo of positive number yields positive modulo and negative modulo yields negative modulo. But to make `Si%k == Sj%k` we should expect consistency on `%` operation. So to make operation consistent we are making -ve mod to +ve mod.!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Mayank Sharma](/mayank-01)\nhere is brute force method\n\n```\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        int n=nums.size(),count=0;\n        long int sum=0;\n         sum=nums[0];\n        for(int i=0; i<n; i++){\n           if(nums[i]%k==0){count++;}\n             sum=nums[i];\n            for(int j=i+1; j<n; j++){\n            sum+=nums[j];\n            if(sum%k==0){count++;}\n        }\n               }\n\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": " [@Vijay Bhaskar](/vijay__bhaskar)"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "A really interesting problem, but the chances you actually get asked it is quite low because of the number theory it requires."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i came up a solution with O(n^2) time complexity and I knew it would give me a tle can anyone suggest a hint how to reduce it to O(nlogn) or O(n),\\n\\nGive a hint it would be helpful."
                    },
                    {
                        "username": "jkulanko",
                        "content": "Prefix sum"
                    },
                    {
                        "username": "hossamabdullah",
                        "content": "I couldn\\'t get this part \\n prefix[i+1] = prefix[i] + ((nums[i]%k) +k)%k; \\ncan someone help or point to a resource that could help"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just set run this code u will get ur answer"
                    },
                    {
                        "username": "rohitadarsh02",
                        "content": "Brute force code for this solution\n\n\nclass Solution {\n    public int subarraysDivByK(int[] nums, int k) {\n        int sum=0;\n        int count=0;\n        for(int i=0;i<nums.length;i++){\n            for(int j=i;j<nums.length;j++){\n                sum=sum+nums[j];\n                if( sum%k==0){\n                    count++;\n                }\n                \n            }\n            sum=0;\n        }\n        return count;\n    }\n}\nWith brute force technique i passed 69/73.\n\n"
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "HOW DO I THINK OF IT IN AN INTERVIEW? \\nI got till the prefix, but after that it became a hassle."
                    }
                ]
            },
            {
                "id": 1772221,
                "content": [
                    {
                        "username": "kumardippu",
                        "content": "There should be 15 subarrays which can divide by 5 of [4,5,0,-2,-3,1]\\n[[4, 5, 0, -2, -3, 1], [4, 5, 0, 1], [4, 5 , -2, -3, 1], [4, 5, 1], [4, 0, -2, -3, 1], [4, 0, 1], [4, -2, -3, 1], [4, 1], [5], [5, 0], [5, 0, -2, -3], [5, -2, -3], [0], [0, -2, -3], [-2, -3]]\\n\\nAnybody please explain me about below solution:\\nInput: nums = [4,5,0,-2,-3,1], k = 5\\nOutput: 7\\nExplanation: There are 7 subarrays with a sum divisible by k = 5:\\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Stated in the problem description :- A subarray is a contiguous part of an array."
                    },
                    {
                        "username": "Akarshucet",
                        "content": "The demand of question about continues subarrays"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "continues val from [i..j],  is consider as  a subarray, and which u have done is subsquences, and if we do not consider sequnceing and pick elements then it is subset"
                    },
                    {
                        "username": "arjun202",
                        "content": "a subarray is formed by picking contiguous elements(one after the other), here you are not following this condition. Hope it helps.\\n"
                    },
                    {
                        "username": "mochy",
                        "content": "```\\n(p2-p1) % k = 0\\n=> p2 % k = p1 % k\\n```"
                    },
                    {
                        "username": "a_parth",
                        "content": "Explanation : Why we need to convert -ve modulo to +ve modulo. \\n\\nHere is one TC failing if we do not convert -ve modulo to +ve modulo.\\n\\n`[-4, -1, 5, 5] k=2` and expected `ans=3`\\nPrefix sum array become - `[-4, -5, 0, 5]`\\nPrefix sum array after applying `%` become - [0, -1, 0, 1] gives us `ans=2`.\\n\\nWhy this is happening? Answer is Euclidian Modulo. Here is the explanation of Euclidian Modulo:\\nSuppose we are doing 21%5. And modulo is what we add to make 21 divisible by 5. We have 2 options to do that. Either we deduct 1 or we add 4. Mathematically - \\n`21 = (4*5) + 1` or `21 = (5*5) + (-4)`\\nHere 1 and -4 are modulo. Means we can have two modulo for one modulo operation.\\n\\nIn some languages (java, cpp), modulo of positive number yields positive modulo and negative modulo yields negative modulo. But to make `Si%k == Sj%k` we should expect consistency on `%` operation. So to make operation consistent we are making -ve mod to +ve mod.!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Mayank Sharma](/mayank-01)\nhere is brute force method\n\n```\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        int n=nums.size(),count=0;\n        long int sum=0;\n         sum=nums[0];\n        for(int i=0; i<n; i++){\n           if(nums[i]%k==0){count++;}\n             sum=nums[i];\n            for(int j=i+1; j<n; j++){\n            sum+=nums[j];\n            if(sum%k==0){count++;}\n        }\n               }\n\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": " [@Vijay Bhaskar](/vijay__bhaskar)"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "A really interesting problem, but the chances you actually get asked it is quite low because of the number theory it requires."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i came up a solution with O(n^2) time complexity and I knew it would give me a tle can anyone suggest a hint how to reduce it to O(nlogn) or O(n),\\n\\nGive a hint it would be helpful."
                    },
                    {
                        "username": "jkulanko",
                        "content": "Prefix sum"
                    },
                    {
                        "username": "hossamabdullah",
                        "content": "I couldn\\'t get this part \\n prefix[i+1] = prefix[i] + ((nums[i]%k) +k)%k; \\ncan someone help or point to a resource that could help"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just set run this code u will get ur answer"
                    },
                    {
                        "username": "rohitadarsh02",
                        "content": "Brute force code for this solution\n\n\nclass Solution {\n    public int subarraysDivByK(int[] nums, int k) {\n        int sum=0;\n        int count=0;\n        for(int i=0;i<nums.length;i++){\n            for(int j=i;j<nums.length;j++){\n                sum=sum+nums[j];\n                if( sum%k==0){\n                    count++;\n                }\n                \n            }\n            sum=0;\n        }\n        return count;\n    }\n}\nWith brute force technique i passed 69/73.\n\n"
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "HOW DO I THINK OF IT IN AN INTERVIEW? \\nI got till the prefix, but after that it became a hassle."
                    }
                ]
            },
            {
                "id": 1765323,
                "content": [
                    {
                        "username": "kumardippu",
                        "content": "There should be 15 subarrays which can divide by 5 of [4,5,0,-2,-3,1]\\n[[4, 5, 0, -2, -3, 1], [4, 5, 0, 1], [4, 5 , -2, -3, 1], [4, 5, 1], [4, 0, -2, -3, 1], [4, 0, 1], [4, -2, -3, 1], [4, 1], [5], [5, 0], [5, 0, -2, -3], [5, -2, -3], [0], [0, -2, -3], [-2, -3]]\\n\\nAnybody please explain me about below solution:\\nInput: nums = [4,5,0,-2,-3,1], k = 5\\nOutput: 7\\nExplanation: There are 7 subarrays with a sum divisible by k = 5:\\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Stated in the problem description :- A subarray is a contiguous part of an array."
                    },
                    {
                        "username": "Akarshucet",
                        "content": "The demand of question about continues subarrays"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "continues val from [i..j],  is consider as  a subarray, and which u have done is subsquences, and if we do not consider sequnceing and pick elements then it is subset"
                    },
                    {
                        "username": "arjun202",
                        "content": "a subarray is formed by picking contiguous elements(one after the other), here you are not following this condition. Hope it helps.\\n"
                    },
                    {
                        "username": "mochy",
                        "content": "```\\n(p2-p1) % k = 0\\n=> p2 % k = p1 % k\\n```"
                    },
                    {
                        "username": "a_parth",
                        "content": "Explanation : Why we need to convert -ve modulo to +ve modulo. \\n\\nHere is one TC failing if we do not convert -ve modulo to +ve modulo.\\n\\n`[-4, -1, 5, 5] k=2` and expected `ans=3`\\nPrefix sum array become - `[-4, -5, 0, 5]`\\nPrefix sum array after applying `%` become - [0, -1, 0, 1] gives us `ans=2`.\\n\\nWhy this is happening? Answer is Euclidian Modulo. Here is the explanation of Euclidian Modulo:\\nSuppose we are doing 21%5. And modulo is what we add to make 21 divisible by 5. We have 2 options to do that. Either we deduct 1 or we add 4. Mathematically - \\n`21 = (4*5) + 1` or `21 = (5*5) + (-4)`\\nHere 1 and -4 are modulo. Means we can have two modulo for one modulo operation.\\n\\nIn some languages (java, cpp), modulo of positive number yields positive modulo and negative modulo yields negative modulo. But to make `Si%k == Sj%k` we should expect consistency on `%` operation. So to make operation consistent we are making -ve mod to +ve mod.!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Mayank Sharma](/mayank-01)\nhere is brute force method\n\n```\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        int n=nums.size(),count=0;\n        long int sum=0;\n         sum=nums[0];\n        for(int i=0; i<n; i++){\n           if(nums[i]%k==0){count++;}\n             sum=nums[i];\n            for(int j=i+1; j<n; j++){\n            sum+=nums[j];\n            if(sum%k==0){count++;}\n        }\n               }\n\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": " [@Vijay Bhaskar](/vijay__bhaskar)"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "A really interesting problem, but the chances you actually get asked it is quite low because of the number theory it requires."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i came up a solution with O(n^2) time complexity and I knew it would give me a tle can anyone suggest a hint how to reduce it to O(nlogn) or O(n),\\n\\nGive a hint it would be helpful."
                    },
                    {
                        "username": "jkulanko",
                        "content": "Prefix sum"
                    },
                    {
                        "username": "hossamabdullah",
                        "content": "I couldn\\'t get this part \\n prefix[i+1] = prefix[i] + ((nums[i]%k) +k)%k; \\ncan someone help or point to a resource that could help"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just set run this code u will get ur answer"
                    },
                    {
                        "username": "rohitadarsh02",
                        "content": "Brute force code for this solution\n\n\nclass Solution {\n    public int subarraysDivByK(int[] nums, int k) {\n        int sum=0;\n        int count=0;\n        for(int i=0;i<nums.length;i++){\n            for(int j=i;j<nums.length;j++){\n                sum=sum+nums[j];\n                if( sum%k==0){\n                    count++;\n                }\n                \n            }\n            sum=0;\n        }\n        return count;\n    }\n}\nWith brute force technique i passed 69/73.\n\n"
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "HOW DO I THINK OF IT IN AN INTERVIEW? \\nI got till the prefix, but after that it became a hassle."
                    }
                ]
            },
            {
                "id": 1765276,
                "content": [
                    {
                        "username": "kumardippu",
                        "content": "There should be 15 subarrays which can divide by 5 of [4,5,0,-2,-3,1]\\n[[4, 5, 0, -2, -3, 1], [4, 5, 0, 1], [4, 5 , -2, -3, 1], [4, 5, 1], [4, 0, -2, -3, 1], [4, 0, 1], [4, -2, -3, 1], [4, 1], [5], [5, 0], [5, 0, -2, -3], [5, -2, -3], [0], [0, -2, -3], [-2, -3]]\\n\\nAnybody please explain me about below solution:\\nInput: nums = [4,5,0,-2,-3,1], k = 5\\nOutput: 7\\nExplanation: There are 7 subarrays with a sum divisible by k = 5:\\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Stated in the problem description :- A subarray is a contiguous part of an array."
                    },
                    {
                        "username": "Akarshucet",
                        "content": "The demand of question about continues subarrays"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "continues val from [i..j],  is consider as  a subarray, and which u have done is subsquences, and if we do not consider sequnceing and pick elements then it is subset"
                    },
                    {
                        "username": "arjun202",
                        "content": "a subarray is formed by picking contiguous elements(one after the other), here you are not following this condition. Hope it helps.\\n"
                    },
                    {
                        "username": "mochy",
                        "content": "```\\n(p2-p1) % k = 0\\n=> p2 % k = p1 % k\\n```"
                    },
                    {
                        "username": "a_parth",
                        "content": "Explanation : Why we need to convert -ve modulo to +ve modulo. \\n\\nHere is one TC failing if we do not convert -ve modulo to +ve modulo.\\n\\n`[-4, -1, 5, 5] k=2` and expected `ans=3`\\nPrefix sum array become - `[-4, -5, 0, 5]`\\nPrefix sum array after applying `%` become - [0, -1, 0, 1] gives us `ans=2`.\\n\\nWhy this is happening? Answer is Euclidian Modulo. Here is the explanation of Euclidian Modulo:\\nSuppose we are doing 21%5. And modulo is what we add to make 21 divisible by 5. We have 2 options to do that. Either we deduct 1 or we add 4. Mathematically - \\n`21 = (4*5) + 1` or `21 = (5*5) + (-4)`\\nHere 1 and -4 are modulo. Means we can have two modulo for one modulo operation.\\n\\nIn some languages (java, cpp), modulo of positive number yields positive modulo and negative modulo yields negative modulo. But to make `Si%k == Sj%k` we should expect consistency on `%` operation. So to make operation consistent we are making -ve mod to +ve mod.!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Mayank Sharma](/mayank-01)\nhere is brute force method\n\n```\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        int n=nums.size(),count=0;\n        long int sum=0;\n         sum=nums[0];\n        for(int i=0; i<n; i++){\n           if(nums[i]%k==0){count++;}\n             sum=nums[i];\n            for(int j=i+1; j<n; j++){\n            sum+=nums[j];\n            if(sum%k==0){count++;}\n        }\n               }\n\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": " [@Vijay Bhaskar](/vijay__bhaskar)"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "A really interesting problem, but the chances you actually get asked it is quite low because of the number theory it requires."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i came up a solution with O(n^2) time complexity and I knew it would give me a tle can anyone suggest a hint how to reduce it to O(nlogn) or O(n),\\n\\nGive a hint it would be helpful."
                    },
                    {
                        "username": "jkulanko",
                        "content": "Prefix sum"
                    },
                    {
                        "username": "hossamabdullah",
                        "content": "I couldn\\'t get this part \\n prefix[i+1] = prefix[i] + ((nums[i]%k) +k)%k; \\ncan someone help or point to a resource that could help"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just set run this code u will get ur answer"
                    },
                    {
                        "username": "rohitadarsh02",
                        "content": "Brute force code for this solution\n\n\nclass Solution {\n    public int subarraysDivByK(int[] nums, int k) {\n        int sum=0;\n        int count=0;\n        for(int i=0;i<nums.length;i++){\n            for(int j=i;j<nums.length;j++){\n                sum=sum+nums[j];\n                if( sum%k==0){\n                    count++;\n                }\n                \n            }\n            sum=0;\n        }\n        return count;\n    }\n}\nWith brute force technique i passed 69/73.\n\n"
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "HOW DO I THINK OF IT IN AN INTERVIEW? \\nI got till the prefix, but after that it became a hassle."
                    }
                ]
            },
            {
                "id": 1764511,
                "content": [
                    {
                        "username": "kumardippu",
                        "content": "There should be 15 subarrays which can divide by 5 of [4,5,0,-2,-3,1]\\n[[4, 5, 0, -2, -3, 1], [4, 5, 0, 1], [4, 5 , -2, -3, 1], [4, 5, 1], [4, 0, -2, -3, 1], [4, 0, 1], [4, -2, -3, 1], [4, 1], [5], [5, 0], [5, 0, -2, -3], [5, -2, -3], [0], [0, -2, -3], [-2, -3]]\\n\\nAnybody please explain me about below solution:\\nInput: nums = [4,5,0,-2,-3,1], k = 5\\nOutput: 7\\nExplanation: There are 7 subarrays with a sum divisible by k = 5:\\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Stated in the problem description :- A subarray is a contiguous part of an array."
                    },
                    {
                        "username": "Akarshucet",
                        "content": "The demand of question about continues subarrays"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "continues val from [i..j],  is consider as  a subarray, and which u have done is subsquences, and if we do not consider sequnceing and pick elements then it is subset"
                    },
                    {
                        "username": "arjun202",
                        "content": "a subarray is formed by picking contiguous elements(one after the other), here you are not following this condition. Hope it helps.\\n"
                    },
                    {
                        "username": "mochy",
                        "content": "```\\n(p2-p1) % k = 0\\n=> p2 % k = p1 % k\\n```"
                    },
                    {
                        "username": "a_parth",
                        "content": "Explanation : Why we need to convert -ve modulo to +ve modulo. \\n\\nHere is one TC failing if we do not convert -ve modulo to +ve modulo.\\n\\n`[-4, -1, 5, 5] k=2` and expected `ans=3`\\nPrefix sum array become - `[-4, -5, 0, 5]`\\nPrefix sum array after applying `%` become - [0, -1, 0, 1] gives us `ans=2`.\\n\\nWhy this is happening? Answer is Euclidian Modulo. Here is the explanation of Euclidian Modulo:\\nSuppose we are doing 21%5. And modulo is what we add to make 21 divisible by 5. We have 2 options to do that. Either we deduct 1 or we add 4. Mathematically - \\n`21 = (4*5) + 1` or `21 = (5*5) + (-4)`\\nHere 1 and -4 are modulo. Means we can have two modulo for one modulo operation.\\n\\nIn some languages (java, cpp), modulo of positive number yields positive modulo and negative modulo yields negative modulo. But to make `Si%k == Sj%k` we should expect consistency on `%` operation. So to make operation consistent we are making -ve mod to +ve mod.!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Mayank Sharma](/mayank-01)\nhere is brute force method\n\n```\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        int n=nums.size(),count=0;\n        long int sum=0;\n         sum=nums[0];\n        for(int i=0; i<n; i++){\n           if(nums[i]%k==0){count++;}\n             sum=nums[i];\n            for(int j=i+1; j<n; j++){\n            sum+=nums[j];\n            if(sum%k==0){count++;}\n        }\n               }\n\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": " [@Vijay Bhaskar](/vijay__bhaskar)"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "A really interesting problem, but the chances you actually get asked it is quite low because of the number theory it requires."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i came up a solution with O(n^2) time complexity and I knew it would give me a tle can anyone suggest a hint how to reduce it to O(nlogn) or O(n),\\n\\nGive a hint it would be helpful."
                    },
                    {
                        "username": "jkulanko",
                        "content": "Prefix sum"
                    },
                    {
                        "username": "hossamabdullah",
                        "content": "I couldn\\'t get this part \\n prefix[i+1] = prefix[i] + ((nums[i]%k) +k)%k; \\ncan someone help or point to a resource that could help"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just set run this code u will get ur answer"
                    },
                    {
                        "username": "rohitadarsh02",
                        "content": "Brute force code for this solution\n\n\nclass Solution {\n    public int subarraysDivByK(int[] nums, int k) {\n        int sum=0;\n        int count=0;\n        for(int i=0;i<nums.length;i++){\n            for(int j=i;j<nums.length;j++){\n                sum=sum+nums[j];\n                if( sum%k==0){\n                    count++;\n                }\n                \n            }\n            sum=0;\n        }\n        return count;\n    }\n}\nWith brute force technique i passed 69/73.\n\n"
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "HOW DO I THINK OF IT IN AN INTERVIEW? \\nI got till the prefix, but after that it became a hassle."
                    }
                ]
            },
            {
                "id": 1764358,
                "content": [
                    {
                        "username": "kumardippu",
                        "content": "There should be 15 subarrays which can divide by 5 of [4,5,0,-2,-3,1]\\n[[4, 5, 0, -2, -3, 1], [4, 5, 0, 1], [4, 5 , -2, -3, 1], [4, 5, 1], [4, 0, -2, -3, 1], [4, 0, 1], [4, -2, -3, 1], [4, 1], [5], [5, 0], [5, 0, -2, -3], [5, -2, -3], [0], [0, -2, -3], [-2, -3]]\\n\\nAnybody please explain me about below solution:\\nInput: nums = [4,5,0,-2,-3,1], k = 5\\nOutput: 7\\nExplanation: There are 7 subarrays with a sum divisible by k = 5:\\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Stated in the problem description :- A subarray is a contiguous part of an array."
                    },
                    {
                        "username": "Akarshucet",
                        "content": "The demand of question about continues subarrays"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "continues val from [i..j],  is consider as  a subarray, and which u have done is subsquences, and if we do not consider sequnceing and pick elements then it is subset"
                    },
                    {
                        "username": "arjun202",
                        "content": "a subarray is formed by picking contiguous elements(one after the other), here you are not following this condition. Hope it helps.\\n"
                    },
                    {
                        "username": "mochy",
                        "content": "```\\n(p2-p1) % k = 0\\n=> p2 % k = p1 % k\\n```"
                    },
                    {
                        "username": "a_parth",
                        "content": "Explanation : Why we need to convert -ve modulo to +ve modulo. \\n\\nHere is one TC failing if we do not convert -ve modulo to +ve modulo.\\n\\n`[-4, -1, 5, 5] k=2` and expected `ans=3`\\nPrefix sum array become - `[-4, -5, 0, 5]`\\nPrefix sum array after applying `%` become - [0, -1, 0, 1] gives us `ans=2`.\\n\\nWhy this is happening? Answer is Euclidian Modulo. Here is the explanation of Euclidian Modulo:\\nSuppose we are doing 21%5. And modulo is what we add to make 21 divisible by 5. We have 2 options to do that. Either we deduct 1 or we add 4. Mathematically - \\n`21 = (4*5) + 1` or `21 = (5*5) + (-4)`\\nHere 1 and -4 are modulo. Means we can have two modulo for one modulo operation.\\n\\nIn some languages (java, cpp), modulo of positive number yields positive modulo and negative modulo yields negative modulo. But to make `Si%k == Sj%k` we should expect consistency on `%` operation. So to make operation consistent we are making -ve mod to +ve mod.!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Mayank Sharma](/mayank-01)\nhere is brute force method\n\n```\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        int n=nums.size(),count=0;\n        long int sum=0;\n         sum=nums[0];\n        for(int i=0; i<n; i++){\n           if(nums[i]%k==0){count++;}\n             sum=nums[i];\n            for(int j=i+1; j<n; j++){\n            sum+=nums[j];\n            if(sum%k==0){count++;}\n        }\n               }\n\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": " [@Vijay Bhaskar](/vijay__bhaskar)"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "A really interesting problem, but the chances you actually get asked it is quite low because of the number theory it requires."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i came up a solution with O(n^2) time complexity and I knew it would give me a tle can anyone suggest a hint how to reduce it to O(nlogn) or O(n),\\n\\nGive a hint it would be helpful."
                    },
                    {
                        "username": "jkulanko",
                        "content": "Prefix sum"
                    },
                    {
                        "username": "hossamabdullah",
                        "content": "I couldn\\'t get this part \\n prefix[i+1] = prefix[i] + ((nums[i]%k) +k)%k; \\ncan someone help or point to a resource that could help"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just set run this code u will get ur answer"
                    },
                    {
                        "username": "rohitadarsh02",
                        "content": "Brute force code for this solution\n\n\nclass Solution {\n    public int subarraysDivByK(int[] nums, int k) {\n        int sum=0;\n        int count=0;\n        for(int i=0;i<nums.length;i++){\n            for(int j=i;j<nums.length;j++){\n                sum=sum+nums[j];\n                if( sum%k==0){\n                    count++;\n                }\n                \n            }\n            sum=0;\n        }\n        return count;\n    }\n}\nWith brute force technique i passed 69/73.\n\n"
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "HOW DO I THINK OF IT IN AN INTERVIEW? \\nI got till the prefix, but after that it became a hassle."
                    }
                ]
            },
            {
                "id": 2050483,
                "content": [
                    {
                        "username": "kumardippu",
                        "content": "There should be 15 subarrays which can divide by 5 of [4,5,0,-2,-3,1]\\n[[4, 5, 0, -2, -3, 1], [4, 5, 0, 1], [4, 5 , -2, -3, 1], [4, 5, 1], [4, 0, -2, -3, 1], [4, 0, 1], [4, -2, -3, 1], [4, 1], [5], [5, 0], [5, 0, -2, -3], [5, -2, -3], [0], [0, -2, -3], [-2, -3]]\\n\\nAnybody please explain me about below solution:\\nInput: nums = [4,5,0,-2,-3,1], k = 5\\nOutput: 7\\nExplanation: There are 7 subarrays with a sum divisible by k = 5:\\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Stated in the problem description :- A subarray is a contiguous part of an array."
                    },
                    {
                        "username": "Akarshucet",
                        "content": "The demand of question about continues subarrays"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "continues val from [i..j],  is consider as  a subarray, and which u have done is subsquences, and if we do not consider sequnceing and pick elements then it is subset"
                    },
                    {
                        "username": "arjun202",
                        "content": "a subarray is formed by picking contiguous elements(one after the other), here you are not following this condition. Hope it helps.\\n"
                    },
                    {
                        "username": "mochy",
                        "content": "```\\n(p2-p1) % k = 0\\n=> p2 % k = p1 % k\\n```"
                    },
                    {
                        "username": "a_parth",
                        "content": "Explanation : Why we need to convert -ve modulo to +ve modulo. \\n\\nHere is one TC failing if we do not convert -ve modulo to +ve modulo.\\n\\n`[-4, -1, 5, 5] k=2` and expected `ans=3`\\nPrefix sum array become - `[-4, -5, 0, 5]`\\nPrefix sum array after applying `%` become - [0, -1, 0, 1] gives us `ans=2`.\\n\\nWhy this is happening? Answer is Euclidian Modulo. Here is the explanation of Euclidian Modulo:\\nSuppose we are doing 21%5. And modulo is what we add to make 21 divisible by 5. We have 2 options to do that. Either we deduct 1 or we add 4. Mathematically - \\n`21 = (4*5) + 1` or `21 = (5*5) + (-4)`\\nHere 1 and -4 are modulo. Means we can have two modulo for one modulo operation.\\n\\nIn some languages (java, cpp), modulo of positive number yields positive modulo and negative modulo yields negative modulo. But to make `Si%k == Sj%k` we should expect consistency on `%` operation. So to make operation consistent we are making -ve mod to +ve mod.!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Mayank Sharma](/mayank-01)\nhere is brute force method\n\n```\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        int n=nums.size(),count=0;\n        long int sum=0;\n         sum=nums[0];\n        for(int i=0; i<n; i++){\n           if(nums[i]%k==0){count++;}\n             sum=nums[i];\n            for(int j=i+1; j<n; j++){\n            sum+=nums[j];\n            if(sum%k==0){count++;}\n        }\n               }\n\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": " [@Vijay Bhaskar](/vijay__bhaskar)"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "A really interesting problem, but the chances you actually get asked it is quite low because of the number theory it requires."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i came up a solution with O(n^2) time complexity and I knew it would give me a tle can anyone suggest a hint how to reduce it to O(nlogn) or O(n),\\n\\nGive a hint it would be helpful."
                    },
                    {
                        "username": "jkulanko",
                        "content": "Prefix sum"
                    },
                    {
                        "username": "hossamabdullah",
                        "content": "I couldn\\'t get this part \\n prefix[i+1] = prefix[i] + ((nums[i]%k) +k)%k; \\ncan someone help or point to a resource that could help"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just set run this code u will get ur answer"
                    },
                    {
                        "username": "rohitadarsh02",
                        "content": "Brute force code for this solution\n\n\nclass Solution {\n    public int subarraysDivByK(int[] nums, int k) {\n        int sum=0;\n        int count=0;\n        for(int i=0;i<nums.length;i++){\n            for(int j=i;j<nums.length;j++){\n                sum=sum+nums[j];\n                if( sum%k==0){\n                    count++;\n                }\n                \n            }\n            sum=0;\n        }\n        return count;\n    }\n}\nWith brute force technique i passed 69/73.\n\n"
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "HOW DO I THINK OF IT IN AN INTERVIEW? \\nI got till the prefix, but after that it became a hassle."
                    }
                ]
            },
            {
                "id": 1962537,
                "content": [
                    {
                        "username": "kumardippu",
                        "content": "There should be 15 subarrays which can divide by 5 of [4,5,0,-2,-3,1]\\n[[4, 5, 0, -2, -3, 1], [4, 5, 0, 1], [4, 5 , -2, -3, 1], [4, 5, 1], [4, 0, -2, -3, 1], [4, 0, 1], [4, -2, -3, 1], [4, 1], [5], [5, 0], [5, 0, -2, -3], [5, -2, -3], [0], [0, -2, -3], [-2, -3]]\\n\\nAnybody please explain me about below solution:\\nInput: nums = [4,5,0,-2,-3,1], k = 5\\nOutput: 7\\nExplanation: There are 7 subarrays with a sum divisible by k = 5:\\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Stated in the problem description :- A subarray is a contiguous part of an array."
                    },
                    {
                        "username": "Akarshucet",
                        "content": "The demand of question about continues subarrays"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "continues val from [i..j],  is consider as  a subarray, and which u have done is subsquences, and if we do not consider sequnceing and pick elements then it is subset"
                    },
                    {
                        "username": "arjun202",
                        "content": "a subarray is formed by picking contiguous elements(one after the other), here you are not following this condition. Hope it helps.\\n"
                    },
                    {
                        "username": "mochy",
                        "content": "```\\n(p2-p1) % k = 0\\n=> p2 % k = p1 % k\\n```"
                    },
                    {
                        "username": "a_parth",
                        "content": "Explanation : Why we need to convert -ve modulo to +ve modulo. \\n\\nHere is one TC failing if we do not convert -ve modulo to +ve modulo.\\n\\n`[-4, -1, 5, 5] k=2` and expected `ans=3`\\nPrefix sum array become - `[-4, -5, 0, 5]`\\nPrefix sum array after applying `%` become - [0, -1, 0, 1] gives us `ans=2`.\\n\\nWhy this is happening? Answer is Euclidian Modulo. Here is the explanation of Euclidian Modulo:\\nSuppose we are doing 21%5. And modulo is what we add to make 21 divisible by 5. We have 2 options to do that. Either we deduct 1 or we add 4. Mathematically - \\n`21 = (4*5) + 1` or `21 = (5*5) + (-4)`\\nHere 1 and -4 are modulo. Means we can have two modulo for one modulo operation.\\n\\nIn some languages (java, cpp), modulo of positive number yields positive modulo and negative modulo yields negative modulo. But to make `Si%k == Sj%k` we should expect consistency on `%` operation. So to make operation consistent we are making -ve mod to +ve mod.!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Mayank Sharma](/mayank-01)\nhere is brute force method\n\n```\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        int n=nums.size(),count=0;\n        long int sum=0;\n         sum=nums[0];\n        for(int i=0; i<n; i++){\n           if(nums[i]%k==0){count++;}\n             sum=nums[i];\n            for(int j=i+1; j<n; j++){\n            sum+=nums[j];\n            if(sum%k==0){count++;}\n        }\n               }\n\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": " [@Vijay Bhaskar](/vijay__bhaskar)"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "A really interesting problem, but the chances you actually get asked it is quite low because of the number theory it requires."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i came up a solution with O(n^2) time complexity and I knew it would give me a tle can anyone suggest a hint how to reduce it to O(nlogn) or O(n),\\n\\nGive a hint it would be helpful."
                    },
                    {
                        "username": "jkulanko",
                        "content": "Prefix sum"
                    },
                    {
                        "username": "hossamabdullah",
                        "content": "I couldn\\'t get this part \\n prefix[i+1] = prefix[i] + ((nums[i]%k) +k)%k; \\ncan someone help or point to a resource that could help"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just set run this code u will get ur answer"
                    },
                    {
                        "username": "rohitadarsh02",
                        "content": "Brute force code for this solution\n\n\nclass Solution {\n    public int subarraysDivByK(int[] nums, int k) {\n        int sum=0;\n        int count=0;\n        for(int i=0;i<nums.length;i++){\n            for(int j=i;j<nums.length;j++){\n                sum=sum+nums[j];\n                if( sum%k==0){\n                    count++;\n                }\n                \n            }\n            sum=0;\n        }\n        return count;\n    }\n}\nWith brute force technique i passed 69/73.\n\n"
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "HOW DO I THINK OF IT IN AN INTERVIEW? \\nI got till the prefix, but after that it became a hassle."
                    }
                ]
            },
            {
                "id": 1954102,
                "content": [
                    {
                        "username": "kumardippu",
                        "content": "There should be 15 subarrays which can divide by 5 of [4,5,0,-2,-3,1]\\n[[4, 5, 0, -2, -3, 1], [4, 5, 0, 1], [4, 5 , -2, -3, 1], [4, 5, 1], [4, 0, -2, -3, 1], [4, 0, 1], [4, -2, -3, 1], [4, 1], [5], [5, 0], [5, 0, -2, -3], [5, -2, -3], [0], [0, -2, -3], [-2, -3]]\\n\\nAnybody please explain me about below solution:\\nInput: nums = [4,5,0,-2,-3,1], k = 5\\nOutput: 7\\nExplanation: There are 7 subarrays with a sum divisible by k = 5:\\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Stated in the problem description :- A subarray is a contiguous part of an array."
                    },
                    {
                        "username": "Akarshucet",
                        "content": "The demand of question about continues subarrays"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "continues val from [i..j],  is consider as  a subarray, and which u have done is subsquences, and if we do not consider sequnceing and pick elements then it is subset"
                    },
                    {
                        "username": "arjun202",
                        "content": "a subarray is formed by picking contiguous elements(one after the other), here you are not following this condition. Hope it helps.\\n"
                    },
                    {
                        "username": "mochy",
                        "content": "```\\n(p2-p1) % k = 0\\n=> p2 % k = p1 % k\\n```"
                    },
                    {
                        "username": "a_parth",
                        "content": "Explanation : Why we need to convert -ve modulo to +ve modulo. \\n\\nHere is one TC failing if we do not convert -ve modulo to +ve modulo.\\n\\n`[-4, -1, 5, 5] k=2` and expected `ans=3`\\nPrefix sum array become - `[-4, -5, 0, 5]`\\nPrefix sum array after applying `%` become - [0, -1, 0, 1] gives us `ans=2`.\\n\\nWhy this is happening? Answer is Euclidian Modulo. Here is the explanation of Euclidian Modulo:\\nSuppose we are doing 21%5. And modulo is what we add to make 21 divisible by 5. We have 2 options to do that. Either we deduct 1 or we add 4. Mathematically - \\n`21 = (4*5) + 1` or `21 = (5*5) + (-4)`\\nHere 1 and -4 are modulo. Means we can have two modulo for one modulo operation.\\n\\nIn some languages (java, cpp), modulo of positive number yields positive modulo and negative modulo yields negative modulo. But to make `Si%k == Sj%k` we should expect consistency on `%` operation. So to make operation consistent we are making -ve mod to +ve mod.!"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Mayank Sharma](/mayank-01)\nhere is brute force method\n\n```\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        int n=nums.size(),count=0;\n        long int sum=0;\n         sum=nums[0];\n        for(int i=0; i<n; i++){\n           if(nums[i]%k==0){count++;}\n             sum=nums[i];\n            for(int j=i+1; j<n; j++){\n            sum+=nums[j];\n            if(sum%k==0){count++;}\n        }\n               }\n\n        return count;\n    }\n};\n```"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": " [@Vijay Bhaskar](/vijay__bhaskar)"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "A really interesting problem, but the chances you actually get asked it is quite low because of the number theory it requires."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "i came up a solution with O(n^2) time complexity and I knew it would give me a tle can anyone suggest a hint how to reduce it to O(nlogn) or O(n),\\n\\nGive a hint it would be helpful."
                    },
                    {
                        "username": "jkulanko",
                        "content": "Prefix sum"
                    },
                    {
                        "username": "hossamabdullah",
                        "content": "I couldn\\'t get this part \\n prefix[i+1] = prefix[i] + ((nums[i]%k) +k)%k; \\ncan someone help or point to a resource that could help"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just set run this code u will get ur answer"
                    },
                    {
                        "username": "rohitadarsh02",
                        "content": "Brute force code for this solution\n\n\nclass Solution {\n    public int subarraysDivByK(int[] nums, int k) {\n        int sum=0;\n        int count=0;\n        for(int i=0;i<nums.length;i++){\n            for(int j=i;j<nums.length;j++){\n                sum=sum+nums[j];\n                if( sum%k==0){\n                    count++;\n                }\n                \n            }\n            sum=0;\n        }\n        return count;\n    }\n}\nWith brute force technique i passed 69/73.\n\n"
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "HOW DO I THINK OF IT IN AN INTERVIEW? \\nI got till the prefix, but after that it became a hassle."
                    }
                ]
            },
            {
                "id": 1845379,
                "content": [
                    {
                        "username": "mishragaurav656",
                        "content": "can anyone help me to know why [0,5,0] has 2 as result ."
                    },
                    {
                        "username": "aveen_shetty",
                        "content": "Always shows Time Limit Exceeded what to doo?"
                    },
                    {
                        "username": "aveen_shetty",
                        "content": "Always shows Time Limit Exceeded what to do ?"
                    },
                    {
                        "username": "YoonJeongChoi",
                        "content": "why the input arr [4,5,0,-2,-3,1] in the first case does not make [4, 5, 1] ? isn\\'t a answer?"
                    },
                    {
                        "username": "kandiana",
                        "content": "Only contiguous parts of the array are considered\\n[4, 5, 1] is not one, since you need to throw out 0, -2 and -3 to get it"
                    },
                    {
                        "username": "user1421n",
                        "content": "Hi guys, \\n\\nFor a simple input [-1,2,9] and k=2, we should have output 1, which is the sum of -1 + 2 + 9 = 10 % k = 0\\n\\nThis is the only set that I\\'m seeing, but following Leetcode answer, the answer should be 2.\\n\\nWhat\\'s the other set ?\\n\\nThanks you!"
                    },
                    {
                        "username": "user1421n",
                        "content": "[@kandiana](/kandiana) thank you ! forgive me I\\'m a bit tired"
                    },
                    {
                        "username": "kandiana",
                        "content": "for [-1, 2, 9] there are 6 contiguous subarrays:\\n[-1]\\n[-1, 2]\\n[-1, 2, 9] \\n[2]\\n[2, 9]\\n[9]\\n\\nout of them two fit: \\n[-1, 2, 9] -> 10 % 2 = 0\\n[2] -> 2 % 2 = 0"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/Z3ZfAt6B1rA"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I have done the [Leetcode 560: Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) multiple times and I immediately knew I need Prefix Sum and hashtable to solve this question. But... The modulo is definitely killing me"
                    },
                    {
                        "username": "terrisa0407",
                        "content": "If two different sets of number forming the same sum, do they count as 1 or 2? "
                    },
                    {
                        "username": "kandiana",
                        "content": "as 2\\n\\nfor example, answer for input nums = [2, 2], k = 2 is 3:\\nthere are three contiguous subarrays [2], [2, 2], [2] and they all fit "
                    },
                    {
                        "username": "yuv",
                        "content": "Concept:\\n\\n1. Consecutive sum,\\n\\n2. if A = B (mod K)\\n   then A-B is divisible by K\\n\\n3. Enjoy. "
                    },
                    {
                        "username": "HADES_HOWFF",
                        "content": "First of all I didn\\'t came up with the idea to use prefix sum which hence resulted in writing more lines of with higher complexity. So then I googled it then just came like the flash of lightning that we can do it by prefix sum also  "
                    }
                ]
            },
            {
                "id": 1777663,
                "content": [
                    {
                        "username": "mishragaurav656",
                        "content": "can anyone help me to know why [0,5,0] has 2 as result ."
                    },
                    {
                        "username": "aveen_shetty",
                        "content": "Always shows Time Limit Exceeded what to doo?"
                    },
                    {
                        "username": "aveen_shetty",
                        "content": "Always shows Time Limit Exceeded what to do ?"
                    },
                    {
                        "username": "YoonJeongChoi",
                        "content": "why the input arr [4,5,0,-2,-3,1] in the first case does not make [4, 5, 1] ? isn\\'t a answer?"
                    },
                    {
                        "username": "kandiana",
                        "content": "Only contiguous parts of the array are considered\\n[4, 5, 1] is not one, since you need to throw out 0, -2 and -3 to get it"
                    },
                    {
                        "username": "user1421n",
                        "content": "Hi guys, \\n\\nFor a simple input [-1,2,9] and k=2, we should have output 1, which is the sum of -1 + 2 + 9 = 10 % k = 0\\n\\nThis is the only set that I\\'m seeing, but following Leetcode answer, the answer should be 2.\\n\\nWhat\\'s the other set ?\\n\\nThanks you!"
                    },
                    {
                        "username": "user1421n",
                        "content": "[@kandiana](/kandiana) thank you ! forgive me I\\'m a bit tired"
                    },
                    {
                        "username": "kandiana",
                        "content": "for [-1, 2, 9] there are 6 contiguous subarrays:\\n[-1]\\n[-1, 2]\\n[-1, 2, 9] \\n[2]\\n[2, 9]\\n[9]\\n\\nout of them two fit: \\n[-1, 2, 9] -> 10 % 2 = 0\\n[2] -> 2 % 2 = 0"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/Z3ZfAt6B1rA"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I have done the [Leetcode 560: Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) multiple times and I immediately knew I need Prefix Sum and hashtable to solve this question. But... The modulo is definitely killing me"
                    },
                    {
                        "username": "terrisa0407",
                        "content": "If two different sets of number forming the same sum, do they count as 1 or 2? "
                    },
                    {
                        "username": "kandiana",
                        "content": "as 2\\n\\nfor example, answer for input nums = [2, 2], k = 2 is 3:\\nthere are three contiguous subarrays [2], [2, 2], [2] and they all fit "
                    },
                    {
                        "username": "yuv",
                        "content": "Concept:\\n\\n1. Consecutive sum,\\n\\n2. if A = B (mod K)\\n   then A-B is divisible by K\\n\\n3. Enjoy. "
                    },
                    {
                        "username": "HADES_HOWFF",
                        "content": "First of all I didn\\'t came up with the idea to use prefix sum which hence resulted in writing more lines of with higher complexity. So then I googled it then just came like the flash of lightning that we can do it by prefix sum also  "
                    }
                ]
            },
            {
                "id": 1777661,
                "content": [
                    {
                        "username": "mishragaurav656",
                        "content": "can anyone help me to know why [0,5,0] has 2 as result ."
                    },
                    {
                        "username": "aveen_shetty",
                        "content": "Always shows Time Limit Exceeded what to doo?"
                    },
                    {
                        "username": "aveen_shetty",
                        "content": "Always shows Time Limit Exceeded what to do ?"
                    },
                    {
                        "username": "YoonJeongChoi",
                        "content": "why the input arr [4,5,0,-2,-3,1] in the first case does not make [4, 5, 1] ? isn\\'t a answer?"
                    },
                    {
                        "username": "kandiana",
                        "content": "Only contiguous parts of the array are considered\\n[4, 5, 1] is not one, since you need to throw out 0, -2 and -3 to get it"
                    },
                    {
                        "username": "user1421n",
                        "content": "Hi guys, \\n\\nFor a simple input [-1,2,9] and k=2, we should have output 1, which is the sum of -1 + 2 + 9 = 10 % k = 0\\n\\nThis is the only set that I\\'m seeing, but following Leetcode answer, the answer should be 2.\\n\\nWhat\\'s the other set ?\\n\\nThanks you!"
                    },
                    {
                        "username": "user1421n",
                        "content": "[@kandiana](/kandiana) thank you ! forgive me I\\'m a bit tired"
                    },
                    {
                        "username": "kandiana",
                        "content": "for [-1, 2, 9] there are 6 contiguous subarrays:\\n[-1]\\n[-1, 2]\\n[-1, 2, 9] \\n[2]\\n[2, 9]\\n[9]\\n\\nout of them two fit: \\n[-1, 2, 9] -> 10 % 2 = 0\\n[2] -> 2 % 2 = 0"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/Z3ZfAt6B1rA"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I have done the [Leetcode 560: Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) multiple times and I immediately knew I need Prefix Sum and hashtable to solve this question. But... The modulo is definitely killing me"
                    },
                    {
                        "username": "terrisa0407",
                        "content": "If two different sets of number forming the same sum, do they count as 1 or 2? "
                    },
                    {
                        "username": "kandiana",
                        "content": "as 2\\n\\nfor example, answer for input nums = [2, 2], k = 2 is 3:\\nthere are three contiguous subarrays [2], [2, 2], [2] and they all fit "
                    },
                    {
                        "username": "yuv",
                        "content": "Concept:\\n\\n1. Consecutive sum,\\n\\n2. if A = B (mod K)\\n   then A-B is divisible by K\\n\\n3. Enjoy. "
                    },
                    {
                        "username": "HADES_HOWFF",
                        "content": "First of all I didn\\'t came up with the idea to use prefix sum which hence resulted in writing more lines of with higher complexity. So then I googled it then just came like the flash of lightning that we can do it by prefix sum also  "
                    }
                ]
            },
            {
                "id": 1769151,
                "content": [
                    {
                        "username": "mishragaurav656",
                        "content": "can anyone help me to know why [0,5,0] has 2 as result ."
                    },
                    {
                        "username": "aveen_shetty",
                        "content": "Always shows Time Limit Exceeded what to doo?"
                    },
                    {
                        "username": "aveen_shetty",
                        "content": "Always shows Time Limit Exceeded what to do ?"
                    },
                    {
                        "username": "YoonJeongChoi",
                        "content": "why the input arr [4,5,0,-2,-3,1] in the first case does not make [4, 5, 1] ? isn\\'t a answer?"
                    },
                    {
                        "username": "kandiana",
                        "content": "Only contiguous parts of the array are considered\\n[4, 5, 1] is not one, since you need to throw out 0, -2 and -3 to get it"
                    },
                    {
                        "username": "user1421n",
                        "content": "Hi guys, \\n\\nFor a simple input [-1,2,9] and k=2, we should have output 1, which is the sum of -1 + 2 + 9 = 10 % k = 0\\n\\nThis is the only set that I\\'m seeing, but following Leetcode answer, the answer should be 2.\\n\\nWhat\\'s the other set ?\\n\\nThanks you!"
                    },
                    {
                        "username": "user1421n",
                        "content": "[@kandiana](/kandiana) thank you ! forgive me I\\'m a bit tired"
                    },
                    {
                        "username": "kandiana",
                        "content": "for [-1, 2, 9] there are 6 contiguous subarrays:\\n[-1]\\n[-1, 2]\\n[-1, 2, 9] \\n[2]\\n[2, 9]\\n[9]\\n\\nout of them two fit: \\n[-1, 2, 9] -> 10 % 2 = 0\\n[2] -> 2 % 2 = 0"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/Z3ZfAt6B1rA"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I have done the [Leetcode 560: Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) multiple times and I immediately knew I need Prefix Sum and hashtable to solve this question. But... The modulo is definitely killing me"
                    },
                    {
                        "username": "terrisa0407",
                        "content": "If two different sets of number forming the same sum, do they count as 1 or 2? "
                    },
                    {
                        "username": "kandiana",
                        "content": "as 2\\n\\nfor example, answer for input nums = [2, 2], k = 2 is 3:\\nthere are three contiguous subarrays [2], [2, 2], [2] and they all fit "
                    },
                    {
                        "username": "yuv",
                        "content": "Concept:\\n\\n1. Consecutive sum,\\n\\n2. if A = B (mod K)\\n   then A-B is divisible by K\\n\\n3. Enjoy. "
                    },
                    {
                        "username": "HADES_HOWFF",
                        "content": "First of all I didn\\'t came up with the idea to use prefix sum which hence resulted in writing more lines of with higher complexity. So then I googled it then just came like the flash of lightning that we can do it by prefix sum also  "
                    }
                ]
            },
            {
                "id": 1767764,
                "content": [
                    {
                        "username": "mishragaurav656",
                        "content": "can anyone help me to know why [0,5,0] has 2 as result ."
                    },
                    {
                        "username": "aveen_shetty",
                        "content": "Always shows Time Limit Exceeded what to doo?"
                    },
                    {
                        "username": "aveen_shetty",
                        "content": "Always shows Time Limit Exceeded what to do ?"
                    },
                    {
                        "username": "YoonJeongChoi",
                        "content": "why the input arr [4,5,0,-2,-3,1] in the first case does not make [4, 5, 1] ? isn\\'t a answer?"
                    },
                    {
                        "username": "kandiana",
                        "content": "Only contiguous parts of the array are considered\\n[4, 5, 1] is not one, since you need to throw out 0, -2 and -3 to get it"
                    },
                    {
                        "username": "user1421n",
                        "content": "Hi guys, \\n\\nFor a simple input [-1,2,9] and k=2, we should have output 1, which is the sum of -1 + 2 + 9 = 10 % k = 0\\n\\nThis is the only set that I\\'m seeing, but following Leetcode answer, the answer should be 2.\\n\\nWhat\\'s the other set ?\\n\\nThanks you!"
                    },
                    {
                        "username": "user1421n",
                        "content": "[@kandiana](/kandiana) thank you ! forgive me I\\'m a bit tired"
                    },
                    {
                        "username": "kandiana",
                        "content": "for [-1, 2, 9] there are 6 contiguous subarrays:\\n[-1]\\n[-1, 2]\\n[-1, 2, 9] \\n[2]\\n[2, 9]\\n[9]\\n\\nout of them two fit: \\n[-1, 2, 9] -> 10 % 2 = 0\\n[2] -> 2 % 2 = 0"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/Z3ZfAt6B1rA"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I have done the [Leetcode 560: Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) multiple times and I immediately knew I need Prefix Sum and hashtable to solve this question. But... The modulo is definitely killing me"
                    },
                    {
                        "username": "terrisa0407",
                        "content": "If two different sets of number forming the same sum, do they count as 1 or 2? "
                    },
                    {
                        "username": "kandiana",
                        "content": "as 2\\n\\nfor example, answer for input nums = [2, 2], k = 2 is 3:\\nthere are three contiguous subarrays [2], [2, 2], [2] and they all fit "
                    },
                    {
                        "username": "yuv",
                        "content": "Concept:\\n\\n1. Consecutive sum,\\n\\n2. if A = B (mod K)\\n   then A-B is divisible by K\\n\\n3. Enjoy. "
                    },
                    {
                        "username": "HADES_HOWFF",
                        "content": "First of all I didn\\'t came up with the idea to use prefix sum which hence resulted in writing more lines of with higher complexity. So then I googled it then just came like the flash of lightning that we can do it by prefix sum also  "
                    }
                ]
            },
            {
                "id": 1766786,
                "content": [
                    {
                        "username": "mishragaurav656",
                        "content": "can anyone help me to know why [0,5,0] has 2 as result ."
                    },
                    {
                        "username": "aveen_shetty",
                        "content": "Always shows Time Limit Exceeded what to doo?"
                    },
                    {
                        "username": "aveen_shetty",
                        "content": "Always shows Time Limit Exceeded what to do ?"
                    },
                    {
                        "username": "YoonJeongChoi",
                        "content": "why the input arr [4,5,0,-2,-3,1] in the first case does not make [4, 5, 1] ? isn\\'t a answer?"
                    },
                    {
                        "username": "kandiana",
                        "content": "Only contiguous parts of the array are considered\\n[4, 5, 1] is not one, since you need to throw out 0, -2 and -3 to get it"
                    },
                    {
                        "username": "user1421n",
                        "content": "Hi guys, \\n\\nFor a simple input [-1,2,9] and k=2, we should have output 1, which is the sum of -1 + 2 + 9 = 10 % k = 0\\n\\nThis is the only set that I\\'m seeing, but following Leetcode answer, the answer should be 2.\\n\\nWhat\\'s the other set ?\\n\\nThanks you!"
                    },
                    {
                        "username": "user1421n",
                        "content": "[@kandiana](/kandiana) thank you ! forgive me I\\'m a bit tired"
                    },
                    {
                        "username": "kandiana",
                        "content": "for [-1, 2, 9] there are 6 contiguous subarrays:\\n[-1]\\n[-1, 2]\\n[-1, 2, 9] \\n[2]\\n[2, 9]\\n[9]\\n\\nout of them two fit: \\n[-1, 2, 9] -> 10 % 2 = 0\\n[2] -> 2 % 2 = 0"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/Z3ZfAt6B1rA"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I have done the [Leetcode 560: Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) multiple times and I immediately knew I need Prefix Sum and hashtable to solve this question. But... The modulo is definitely killing me"
                    },
                    {
                        "username": "terrisa0407",
                        "content": "If two different sets of number forming the same sum, do they count as 1 or 2? "
                    },
                    {
                        "username": "kandiana",
                        "content": "as 2\\n\\nfor example, answer for input nums = [2, 2], k = 2 is 3:\\nthere are three contiguous subarrays [2], [2, 2], [2] and they all fit "
                    },
                    {
                        "username": "yuv",
                        "content": "Concept:\\n\\n1. Consecutive sum,\\n\\n2. if A = B (mod K)\\n   then A-B is divisible by K\\n\\n3. Enjoy. "
                    },
                    {
                        "username": "HADES_HOWFF",
                        "content": "First of all I didn\\'t came up with the idea to use prefix sum which hence resulted in writing more lines of with higher complexity. So then I googled it then just came like the flash of lightning that we can do it by prefix sum also  "
                    }
                ]
            },
            {
                "id": 1765562,
                "content": [
                    {
                        "username": "mishragaurav656",
                        "content": "can anyone help me to know why [0,5,0] has 2 as result ."
                    },
                    {
                        "username": "aveen_shetty",
                        "content": "Always shows Time Limit Exceeded what to doo?"
                    },
                    {
                        "username": "aveen_shetty",
                        "content": "Always shows Time Limit Exceeded what to do ?"
                    },
                    {
                        "username": "YoonJeongChoi",
                        "content": "why the input arr [4,5,0,-2,-3,1] in the first case does not make [4, 5, 1] ? isn\\'t a answer?"
                    },
                    {
                        "username": "kandiana",
                        "content": "Only contiguous parts of the array are considered\\n[4, 5, 1] is not one, since you need to throw out 0, -2 and -3 to get it"
                    },
                    {
                        "username": "user1421n",
                        "content": "Hi guys, \\n\\nFor a simple input [-1,2,9] and k=2, we should have output 1, which is the sum of -1 + 2 + 9 = 10 % k = 0\\n\\nThis is the only set that I\\'m seeing, but following Leetcode answer, the answer should be 2.\\n\\nWhat\\'s the other set ?\\n\\nThanks you!"
                    },
                    {
                        "username": "user1421n",
                        "content": "[@kandiana](/kandiana) thank you ! forgive me I\\'m a bit tired"
                    },
                    {
                        "username": "kandiana",
                        "content": "for [-1, 2, 9] there are 6 contiguous subarrays:\\n[-1]\\n[-1, 2]\\n[-1, 2, 9] \\n[2]\\n[2, 9]\\n[9]\\n\\nout of them two fit: \\n[-1, 2, 9] -> 10 % 2 = 0\\n[2] -> 2 % 2 = 0"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/Z3ZfAt6B1rA"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I have done the [Leetcode 560: Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) multiple times and I immediately knew I need Prefix Sum and hashtable to solve this question. But... The modulo is definitely killing me"
                    },
                    {
                        "username": "terrisa0407",
                        "content": "If two different sets of number forming the same sum, do they count as 1 or 2? "
                    },
                    {
                        "username": "kandiana",
                        "content": "as 2\\n\\nfor example, answer for input nums = [2, 2], k = 2 is 3:\\nthere are three contiguous subarrays [2], [2, 2], [2] and they all fit "
                    },
                    {
                        "username": "yuv",
                        "content": "Concept:\\n\\n1. Consecutive sum,\\n\\n2. if A = B (mod K)\\n   then A-B is divisible by K\\n\\n3. Enjoy. "
                    },
                    {
                        "username": "HADES_HOWFF",
                        "content": "First of all I didn\\'t came up with the idea to use prefix sum which hence resulted in writing more lines of with higher complexity. So then I googled it then just came like the flash of lightning that we can do it by prefix sum also  "
                    }
                ]
            },
            {
                "id": 1765418,
                "content": [
                    {
                        "username": "mishragaurav656",
                        "content": "can anyone help me to know why [0,5,0] has 2 as result ."
                    },
                    {
                        "username": "aveen_shetty",
                        "content": "Always shows Time Limit Exceeded what to doo?"
                    },
                    {
                        "username": "aveen_shetty",
                        "content": "Always shows Time Limit Exceeded what to do ?"
                    },
                    {
                        "username": "YoonJeongChoi",
                        "content": "why the input arr [4,5,0,-2,-3,1] in the first case does not make [4, 5, 1] ? isn\\'t a answer?"
                    },
                    {
                        "username": "kandiana",
                        "content": "Only contiguous parts of the array are considered\\n[4, 5, 1] is not one, since you need to throw out 0, -2 and -3 to get it"
                    },
                    {
                        "username": "user1421n",
                        "content": "Hi guys, \\n\\nFor a simple input [-1,2,9] and k=2, we should have output 1, which is the sum of -1 + 2 + 9 = 10 % k = 0\\n\\nThis is the only set that I\\'m seeing, but following Leetcode answer, the answer should be 2.\\n\\nWhat\\'s the other set ?\\n\\nThanks you!"
                    },
                    {
                        "username": "user1421n",
                        "content": "[@kandiana](/kandiana) thank you ! forgive me I\\'m a bit tired"
                    },
                    {
                        "username": "kandiana",
                        "content": "for [-1, 2, 9] there are 6 contiguous subarrays:\\n[-1]\\n[-1, 2]\\n[-1, 2, 9] \\n[2]\\n[2, 9]\\n[9]\\n\\nout of them two fit: \\n[-1, 2, 9] -> 10 % 2 = 0\\n[2] -> 2 % 2 = 0"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/Z3ZfAt6B1rA"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I have done the [Leetcode 560: Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) multiple times and I immediately knew I need Prefix Sum and hashtable to solve this question. But... The modulo is definitely killing me"
                    },
                    {
                        "username": "terrisa0407",
                        "content": "If two different sets of number forming the same sum, do they count as 1 or 2? "
                    },
                    {
                        "username": "kandiana",
                        "content": "as 2\\n\\nfor example, answer for input nums = [2, 2], k = 2 is 3:\\nthere are three contiguous subarrays [2], [2, 2], [2] and they all fit "
                    },
                    {
                        "username": "yuv",
                        "content": "Concept:\\n\\n1. Consecutive sum,\\n\\n2. if A = B (mod K)\\n   then A-B is divisible by K\\n\\n3. Enjoy. "
                    },
                    {
                        "username": "HADES_HOWFF",
                        "content": "First of all I didn\\'t came up with the idea to use prefix sum which hence resulted in writing more lines of with higher complexity. So then I googled it then just came like the flash of lightning that we can do it by prefix sum also  "
                    }
                ]
            },
            {
                "id": 1765399,
                "content": [
                    {
                        "username": "mishragaurav656",
                        "content": "can anyone help me to know why [0,5,0] has 2 as result ."
                    },
                    {
                        "username": "aveen_shetty",
                        "content": "Always shows Time Limit Exceeded what to doo?"
                    },
                    {
                        "username": "aveen_shetty",
                        "content": "Always shows Time Limit Exceeded what to do ?"
                    },
                    {
                        "username": "YoonJeongChoi",
                        "content": "why the input arr [4,5,0,-2,-3,1] in the first case does not make [4, 5, 1] ? isn\\'t a answer?"
                    },
                    {
                        "username": "kandiana",
                        "content": "Only contiguous parts of the array are considered\\n[4, 5, 1] is not one, since you need to throw out 0, -2 and -3 to get it"
                    },
                    {
                        "username": "user1421n",
                        "content": "Hi guys, \\n\\nFor a simple input [-1,2,9] and k=2, we should have output 1, which is the sum of -1 + 2 + 9 = 10 % k = 0\\n\\nThis is the only set that I\\'m seeing, but following Leetcode answer, the answer should be 2.\\n\\nWhat\\'s the other set ?\\n\\nThanks you!"
                    },
                    {
                        "username": "user1421n",
                        "content": "[@kandiana](/kandiana) thank you ! forgive me I\\'m a bit tired"
                    },
                    {
                        "username": "kandiana",
                        "content": "for [-1, 2, 9] there are 6 contiguous subarrays:\\n[-1]\\n[-1, 2]\\n[-1, 2, 9] \\n[2]\\n[2, 9]\\n[9]\\n\\nout of them two fit: \\n[-1, 2, 9] -> 10 % 2 = 0\\n[2] -> 2 % 2 = 0"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/Z3ZfAt6B1rA"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I have done the [Leetcode 560: Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) multiple times and I immediately knew I need Prefix Sum and hashtable to solve this question. But... The modulo is definitely killing me"
                    },
                    {
                        "username": "terrisa0407",
                        "content": "If two different sets of number forming the same sum, do they count as 1 or 2? "
                    },
                    {
                        "username": "kandiana",
                        "content": "as 2\\n\\nfor example, answer for input nums = [2, 2], k = 2 is 3:\\nthere are three contiguous subarrays [2], [2, 2], [2] and they all fit "
                    },
                    {
                        "username": "yuv",
                        "content": "Concept:\\n\\n1. Consecutive sum,\\n\\n2. if A = B (mod K)\\n   then A-B is divisible by K\\n\\n3. Enjoy. "
                    },
                    {
                        "username": "HADES_HOWFF",
                        "content": "First of all I didn\\'t came up with the idea to use prefix sum which hence resulted in writing more lines of with higher complexity. So then I googled it then just came like the flash of lightning that we can do it by prefix sum also  "
                    }
                ]
            },
            {
                "id": 1765292,
                "content": [
                    {
                        "username": "mishragaurav656",
                        "content": "can anyone help me to know why [0,5,0] has 2 as result ."
                    },
                    {
                        "username": "aveen_shetty",
                        "content": "Always shows Time Limit Exceeded what to doo?"
                    },
                    {
                        "username": "aveen_shetty",
                        "content": "Always shows Time Limit Exceeded what to do ?"
                    },
                    {
                        "username": "YoonJeongChoi",
                        "content": "why the input arr [4,5,0,-2,-3,1] in the first case does not make [4, 5, 1] ? isn\\'t a answer?"
                    },
                    {
                        "username": "kandiana",
                        "content": "Only contiguous parts of the array are considered\\n[4, 5, 1] is not one, since you need to throw out 0, -2 and -3 to get it"
                    },
                    {
                        "username": "user1421n",
                        "content": "Hi guys, \\n\\nFor a simple input [-1,2,9] and k=2, we should have output 1, which is the sum of -1 + 2 + 9 = 10 % k = 0\\n\\nThis is the only set that I\\'m seeing, but following Leetcode answer, the answer should be 2.\\n\\nWhat\\'s the other set ?\\n\\nThanks you!"
                    },
                    {
                        "username": "user1421n",
                        "content": "[@kandiana](/kandiana) thank you ! forgive me I\\'m a bit tired"
                    },
                    {
                        "username": "kandiana",
                        "content": "for [-1, 2, 9] there are 6 contiguous subarrays:\\n[-1]\\n[-1, 2]\\n[-1, 2, 9] \\n[2]\\n[2, 9]\\n[9]\\n\\nout of them two fit: \\n[-1, 2, 9] -> 10 % 2 = 0\\n[2] -> 2 % 2 = 0"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/Z3ZfAt6B1rA"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "I have done the [Leetcode 560: Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) multiple times and I immediately knew I need Prefix Sum and hashtable to solve this question. But... The modulo is definitely killing me"
                    },
                    {
                        "username": "terrisa0407",
                        "content": "If two different sets of number forming the same sum, do they count as 1 or 2? "
                    },
                    {
                        "username": "kandiana",
                        "content": "as 2\\n\\nfor example, answer for input nums = [2, 2], k = 2 is 3:\\nthere are three contiguous subarrays [2], [2, 2], [2] and they all fit "
                    },
                    {
                        "username": "yuv",
                        "content": "Concept:\\n\\n1. Consecutive sum,\\n\\n2. if A = B (mod K)\\n   then A-B is divisible by K\\n\\n3. Enjoy. "
                    },
                    {
                        "username": "HADES_HOWFF",
                        "content": "First of all I didn\\'t came up with the idea to use prefix sum which hence resulted in writing more lines of with higher complexity. So then I googled it then just came like the flash of lightning that we can do it by prefix sum also  "
                    }
                ]
            },
            {
                "id": 1765270,
                "content": [
                    {
                        "username": "ohYouCan",
                        "content": "HELP PLEASE . 🙏🏻🙏🏻\n\nSo I had solved a similar problem couple of years ago. So I had an idea about using prefix sum , but I was not able to come up with I have to store remainder or sums or something else( I guess I am really bad at math).\nSo lots of time I know what can be done to solve a particular problem , but I am not able to connect bits , also find it hard to implement.( like how would I do this ?).\n\nAlso I struggle with problems which involves math."
                    },
                    {
                        "username": "kandiana",
                        "content": "you can try to solve pure math problems to get more proficient with applying it in programming\\n\\nremainders are a part of Number Theory, you can look up courses on it, like this one: https://www.coursera.org/learn/number-theory-cryptography#faq"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "practice\\n"
                    },
                    {
                        "username": "ianupam",
                        "content": "Approach 1 mp[sum%k]: \\n                -5%4 = -1 = (-1 * 4 + (-1)) => So remainder here is -1.\\n\\nApproach 2 mp[(sum%k+k)%k]:\\n                -5%4 = 3 = (-2 * 4 + 3) => So remainder here is 3.\\n        Why we are using the Approach 2?"
                    },
                    {
                        "username": "cortexauth",
                        "content": "This question made me feel kinda very dumb, I had the math figured out, I missed at one fact, I can just store the amount of combinations leading to some value mod k . Oh well, I am always bad with such things, idk why \n\nAlso I learned something, if some bound seem useless, it's probably not"
                    },
                    {
                        "username": "shubhamkr3011",
                        "content": "Can anyone tell me why are we only counting the remainders in unordered map ?"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\'  Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e  a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map \\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "ajesk",
                        "content": "My brain is stretched to the limit on this one. I got an o(n^2) solutions of sorts but cant for the love of me figure out how to simplify this down any further...\\n\\nThe thought is to track the number of occurrences of numbers in the sub array starting from `i + 1` and work your way back by applying the current index number, checking the value then saving the count going forward.\\n\\nI can do away with most of the logic in the inner loop and just compile the occurrences into a single mapping, but I feel like that is going to result in the same TLE.\\n\\n ```\\npublic int subarraysDivByK(int[] nums, int k) {\\n        int total = 0;\\n        Map<Integer, Map<Integer, Integer>> sums = new HashMap<>(); \\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            Map<Integer, Integer> currentMapping = new HashMap<>();\\n            int currentInt = nums[i];\\n            currentMapping.put(currentInt, 1);\\n            if (nums[i] % k == 0) total++;\\n\\n            if (i < nums.length - 1) {\\n                for (Map.Entry<Integer, Integer> lastEntry : sums.get(i + 1).entrySet()) {\\n                    int nextInt = currentInt + lastEntry.getKey();\\n                    if (nextInt % k == 0) total += lastEntry.getValue();\\n                    currentMapping.put(nextInt, lastEntry.getValue() + currentMapping.getOrDefault(nextInt, 0));\\n                }\\n            }\\n\\n            sums.put(i, currentMapping);\\n        }\\n\\n        return total;\\n```"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "ajesk",
                        "content": "I just peeked at the solution... right idea, wrong implementation. You can get around the inner loop through some mathematical gymnastics, which I feel is way above my mental abilities for a random daily puzzle lol"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach to reach the solution: https://youtu.be/5dt96hbHfoc"
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Hey there! I really struggled to understand why we needed to use this line `prefixMod = (prefixMod + num % k + k) % k;`.\\n\\nThe basic answer is that we should never have a negative remainder. But many programming languages do not accommodate for this.\\n\\nI found this helpful article that explains the reasoning behind this: \\n\\nhttps://web.archive.org/web/20090717035140if_/javascript.about.com/od/problemsolving/a/modulobug.htm"
                    },
                    {
                        "username": "dev-null0",
                        "content": "O(nk) & O(n^2) both give time limit exceeded.. is this supposed to be done in O(n)?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@udaygupta2801](/udaygupta2801) Negative numbers threw me off"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "YES \\nSuppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "momoxsalameh",
                        "content": "Did anyone find a solution faster than O(n^2)?\\n"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "YES\\nSuppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'ve been noticing lately that these daily challenge problems have unlocked official solutions"
                    }
                ]
            },
            {
                "id": 1765235,
                "content": [
                    {
                        "username": "ohYouCan",
                        "content": "HELP PLEASE . 🙏🏻🙏🏻\n\nSo I had solved a similar problem couple of years ago. So I had an idea about using prefix sum , but I was not able to come up with I have to store remainder or sums or something else( I guess I am really bad at math).\nSo lots of time I know what can be done to solve a particular problem , but I am not able to connect bits , also find it hard to implement.( like how would I do this ?).\n\nAlso I struggle with problems which involves math."
                    },
                    {
                        "username": "kandiana",
                        "content": "you can try to solve pure math problems to get more proficient with applying it in programming\\n\\nremainders are a part of Number Theory, you can look up courses on it, like this one: https://www.coursera.org/learn/number-theory-cryptography#faq"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "practice\\n"
                    },
                    {
                        "username": "ianupam",
                        "content": "Approach 1 mp[sum%k]: \\n                -5%4 = -1 = (-1 * 4 + (-1)) => So remainder here is -1.\\n\\nApproach 2 mp[(sum%k+k)%k]:\\n                -5%4 = 3 = (-2 * 4 + 3) => So remainder here is 3.\\n        Why we are using the Approach 2?"
                    },
                    {
                        "username": "cortexauth",
                        "content": "This question made me feel kinda very dumb, I had the math figured out, I missed at one fact, I can just store the amount of combinations leading to some value mod k . Oh well, I am always bad with such things, idk why \n\nAlso I learned something, if some bound seem useless, it's probably not"
                    },
                    {
                        "username": "shubhamkr3011",
                        "content": "Can anyone tell me why are we only counting the remainders in unordered map ?"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\'  Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e  a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map \\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "ajesk",
                        "content": "My brain is stretched to the limit on this one. I got an o(n^2) solutions of sorts but cant for the love of me figure out how to simplify this down any further...\\n\\nThe thought is to track the number of occurrences of numbers in the sub array starting from `i + 1` and work your way back by applying the current index number, checking the value then saving the count going forward.\\n\\nI can do away with most of the logic in the inner loop and just compile the occurrences into a single mapping, but I feel like that is going to result in the same TLE.\\n\\n ```\\npublic int subarraysDivByK(int[] nums, int k) {\\n        int total = 0;\\n        Map<Integer, Map<Integer, Integer>> sums = new HashMap<>(); \\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            Map<Integer, Integer> currentMapping = new HashMap<>();\\n            int currentInt = nums[i];\\n            currentMapping.put(currentInt, 1);\\n            if (nums[i] % k == 0) total++;\\n\\n            if (i < nums.length - 1) {\\n                for (Map.Entry<Integer, Integer> lastEntry : sums.get(i + 1).entrySet()) {\\n                    int nextInt = currentInt + lastEntry.getKey();\\n                    if (nextInt % k == 0) total += lastEntry.getValue();\\n                    currentMapping.put(nextInt, lastEntry.getValue() + currentMapping.getOrDefault(nextInt, 0));\\n                }\\n            }\\n\\n            sums.put(i, currentMapping);\\n        }\\n\\n        return total;\\n```"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "ajesk",
                        "content": "I just peeked at the solution... right idea, wrong implementation. You can get around the inner loop through some mathematical gymnastics, which I feel is way above my mental abilities for a random daily puzzle lol"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach to reach the solution: https://youtu.be/5dt96hbHfoc"
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Hey there! I really struggled to understand why we needed to use this line `prefixMod = (prefixMod + num % k + k) % k;`.\\n\\nThe basic answer is that we should never have a negative remainder. But many programming languages do not accommodate for this.\\n\\nI found this helpful article that explains the reasoning behind this: \\n\\nhttps://web.archive.org/web/20090717035140if_/javascript.about.com/od/problemsolving/a/modulobug.htm"
                    },
                    {
                        "username": "dev-null0",
                        "content": "O(nk) & O(n^2) both give time limit exceeded.. is this supposed to be done in O(n)?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@udaygupta2801](/udaygupta2801) Negative numbers threw me off"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "YES \\nSuppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "momoxsalameh",
                        "content": "Did anyone find a solution faster than O(n^2)?\\n"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "YES\\nSuppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'ve been noticing lately that these daily challenge problems have unlocked official solutions"
                    }
                ]
            },
            {
                "id": 1765208,
                "content": [
                    {
                        "username": "ohYouCan",
                        "content": "HELP PLEASE . 🙏🏻🙏🏻\n\nSo I had solved a similar problem couple of years ago. So I had an idea about using prefix sum , but I was not able to come up with I have to store remainder or sums or something else( I guess I am really bad at math).\nSo lots of time I know what can be done to solve a particular problem , but I am not able to connect bits , also find it hard to implement.( like how would I do this ?).\n\nAlso I struggle with problems which involves math."
                    },
                    {
                        "username": "kandiana",
                        "content": "you can try to solve pure math problems to get more proficient with applying it in programming\\n\\nremainders are a part of Number Theory, you can look up courses on it, like this one: https://www.coursera.org/learn/number-theory-cryptography#faq"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "practice\\n"
                    },
                    {
                        "username": "ianupam",
                        "content": "Approach 1 mp[sum%k]: \\n                -5%4 = -1 = (-1 * 4 + (-1)) => So remainder here is -1.\\n\\nApproach 2 mp[(sum%k+k)%k]:\\n                -5%4 = 3 = (-2 * 4 + 3) => So remainder here is 3.\\n        Why we are using the Approach 2?"
                    },
                    {
                        "username": "cortexauth",
                        "content": "This question made me feel kinda very dumb, I had the math figured out, I missed at one fact, I can just store the amount of combinations leading to some value mod k . Oh well, I am always bad with such things, idk why \n\nAlso I learned something, if some bound seem useless, it's probably not"
                    },
                    {
                        "username": "shubhamkr3011",
                        "content": "Can anyone tell me why are we only counting the remainders in unordered map ?"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\'  Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e  a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map \\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "ajesk",
                        "content": "My brain is stretched to the limit on this one. I got an o(n^2) solutions of sorts but cant for the love of me figure out how to simplify this down any further...\\n\\nThe thought is to track the number of occurrences of numbers in the sub array starting from `i + 1` and work your way back by applying the current index number, checking the value then saving the count going forward.\\n\\nI can do away with most of the logic in the inner loop and just compile the occurrences into a single mapping, but I feel like that is going to result in the same TLE.\\n\\n ```\\npublic int subarraysDivByK(int[] nums, int k) {\\n        int total = 0;\\n        Map<Integer, Map<Integer, Integer>> sums = new HashMap<>(); \\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            Map<Integer, Integer> currentMapping = new HashMap<>();\\n            int currentInt = nums[i];\\n            currentMapping.put(currentInt, 1);\\n            if (nums[i] % k == 0) total++;\\n\\n            if (i < nums.length - 1) {\\n                for (Map.Entry<Integer, Integer> lastEntry : sums.get(i + 1).entrySet()) {\\n                    int nextInt = currentInt + lastEntry.getKey();\\n                    if (nextInt % k == 0) total += lastEntry.getValue();\\n                    currentMapping.put(nextInt, lastEntry.getValue() + currentMapping.getOrDefault(nextInt, 0));\\n                }\\n            }\\n\\n            sums.put(i, currentMapping);\\n        }\\n\\n        return total;\\n```"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "ajesk",
                        "content": "I just peeked at the solution... right idea, wrong implementation. You can get around the inner loop through some mathematical gymnastics, which I feel is way above my mental abilities for a random daily puzzle lol"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach to reach the solution: https://youtu.be/5dt96hbHfoc"
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Hey there! I really struggled to understand why we needed to use this line `prefixMod = (prefixMod + num % k + k) % k;`.\\n\\nThe basic answer is that we should never have a negative remainder. But many programming languages do not accommodate for this.\\n\\nI found this helpful article that explains the reasoning behind this: \\n\\nhttps://web.archive.org/web/20090717035140if_/javascript.about.com/od/problemsolving/a/modulobug.htm"
                    },
                    {
                        "username": "dev-null0",
                        "content": "O(nk) & O(n^2) both give time limit exceeded.. is this supposed to be done in O(n)?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@udaygupta2801](/udaygupta2801) Negative numbers threw me off"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "YES \\nSuppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "momoxsalameh",
                        "content": "Did anyone find a solution faster than O(n^2)?\\n"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "YES\\nSuppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'ve been noticing lately that these daily challenge problems have unlocked official solutions"
                    }
                ]
            },
            {
                "id": 1765139,
                "content": [
                    {
                        "username": "ohYouCan",
                        "content": "HELP PLEASE . 🙏🏻🙏🏻\n\nSo I had solved a similar problem couple of years ago. So I had an idea about using prefix sum , but I was not able to come up with I have to store remainder or sums or something else( I guess I am really bad at math).\nSo lots of time I know what can be done to solve a particular problem , but I am not able to connect bits , also find it hard to implement.( like how would I do this ?).\n\nAlso I struggle with problems which involves math."
                    },
                    {
                        "username": "kandiana",
                        "content": "you can try to solve pure math problems to get more proficient with applying it in programming\\n\\nremainders are a part of Number Theory, you can look up courses on it, like this one: https://www.coursera.org/learn/number-theory-cryptography#faq"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "practice\\n"
                    },
                    {
                        "username": "ianupam",
                        "content": "Approach 1 mp[sum%k]: \\n                -5%4 = -1 = (-1 * 4 + (-1)) => So remainder here is -1.\\n\\nApproach 2 mp[(sum%k+k)%k]:\\n                -5%4 = 3 = (-2 * 4 + 3) => So remainder here is 3.\\n        Why we are using the Approach 2?"
                    },
                    {
                        "username": "cortexauth",
                        "content": "This question made me feel kinda very dumb, I had the math figured out, I missed at one fact, I can just store the amount of combinations leading to some value mod k . Oh well, I am always bad with such things, idk why \n\nAlso I learned something, if some bound seem useless, it's probably not"
                    },
                    {
                        "username": "shubhamkr3011",
                        "content": "Can anyone tell me why are we only counting the remainders in unordered map ?"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\'  Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e  a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map \\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "ajesk",
                        "content": "My brain is stretched to the limit on this one. I got an o(n^2) solutions of sorts but cant for the love of me figure out how to simplify this down any further...\\n\\nThe thought is to track the number of occurrences of numbers in the sub array starting from `i + 1` and work your way back by applying the current index number, checking the value then saving the count going forward.\\n\\nI can do away with most of the logic in the inner loop and just compile the occurrences into a single mapping, but I feel like that is going to result in the same TLE.\\n\\n ```\\npublic int subarraysDivByK(int[] nums, int k) {\\n        int total = 0;\\n        Map<Integer, Map<Integer, Integer>> sums = new HashMap<>(); \\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            Map<Integer, Integer> currentMapping = new HashMap<>();\\n            int currentInt = nums[i];\\n            currentMapping.put(currentInt, 1);\\n            if (nums[i] % k == 0) total++;\\n\\n            if (i < nums.length - 1) {\\n                for (Map.Entry<Integer, Integer> lastEntry : sums.get(i + 1).entrySet()) {\\n                    int nextInt = currentInt + lastEntry.getKey();\\n                    if (nextInt % k == 0) total += lastEntry.getValue();\\n                    currentMapping.put(nextInt, lastEntry.getValue() + currentMapping.getOrDefault(nextInt, 0));\\n                }\\n            }\\n\\n            sums.put(i, currentMapping);\\n        }\\n\\n        return total;\\n```"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "ajesk",
                        "content": "I just peeked at the solution... right idea, wrong implementation. You can get around the inner loop through some mathematical gymnastics, which I feel is way above my mental abilities for a random daily puzzle lol"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach to reach the solution: https://youtu.be/5dt96hbHfoc"
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Hey there! I really struggled to understand why we needed to use this line `prefixMod = (prefixMod + num % k + k) % k;`.\\n\\nThe basic answer is that we should never have a negative remainder. But many programming languages do not accommodate for this.\\n\\nI found this helpful article that explains the reasoning behind this: \\n\\nhttps://web.archive.org/web/20090717035140if_/javascript.about.com/od/problemsolving/a/modulobug.htm"
                    },
                    {
                        "username": "dev-null0",
                        "content": "O(nk) & O(n^2) both give time limit exceeded.. is this supposed to be done in O(n)?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@udaygupta2801](/udaygupta2801) Negative numbers threw me off"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "YES \\nSuppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "momoxsalameh",
                        "content": "Did anyone find a solution faster than O(n^2)?\\n"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "YES\\nSuppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'ve been noticing lately that these daily challenge problems have unlocked official solutions"
                    }
                ]
            },
            {
                "id": 1765087,
                "content": [
                    {
                        "username": "ohYouCan",
                        "content": "HELP PLEASE . 🙏🏻🙏🏻\n\nSo I had solved a similar problem couple of years ago. So I had an idea about using prefix sum , but I was not able to come up with I have to store remainder or sums or something else( I guess I am really bad at math).\nSo lots of time I know what can be done to solve a particular problem , but I am not able to connect bits , also find it hard to implement.( like how would I do this ?).\n\nAlso I struggle with problems which involves math."
                    },
                    {
                        "username": "kandiana",
                        "content": "you can try to solve pure math problems to get more proficient with applying it in programming\\n\\nremainders are a part of Number Theory, you can look up courses on it, like this one: https://www.coursera.org/learn/number-theory-cryptography#faq"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "practice\\n"
                    },
                    {
                        "username": "ianupam",
                        "content": "Approach 1 mp[sum%k]: \\n                -5%4 = -1 = (-1 * 4 + (-1)) => So remainder here is -1.\\n\\nApproach 2 mp[(sum%k+k)%k]:\\n                -5%4 = 3 = (-2 * 4 + 3) => So remainder here is 3.\\n        Why we are using the Approach 2?"
                    },
                    {
                        "username": "cortexauth",
                        "content": "This question made me feel kinda very dumb, I had the math figured out, I missed at one fact, I can just store the amount of combinations leading to some value mod k . Oh well, I am always bad with such things, idk why \n\nAlso I learned something, if some bound seem useless, it's probably not"
                    },
                    {
                        "username": "shubhamkr3011",
                        "content": "Can anyone tell me why are we only counting the remainders in unordered map ?"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\'  Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e  a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map \\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "ajesk",
                        "content": "My brain is stretched to the limit on this one. I got an o(n^2) solutions of sorts but cant for the love of me figure out how to simplify this down any further...\\n\\nThe thought is to track the number of occurrences of numbers in the sub array starting from `i + 1` and work your way back by applying the current index number, checking the value then saving the count going forward.\\n\\nI can do away with most of the logic in the inner loop and just compile the occurrences into a single mapping, but I feel like that is going to result in the same TLE.\\n\\n ```\\npublic int subarraysDivByK(int[] nums, int k) {\\n        int total = 0;\\n        Map<Integer, Map<Integer, Integer>> sums = new HashMap<>(); \\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            Map<Integer, Integer> currentMapping = new HashMap<>();\\n            int currentInt = nums[i];\\n            currentMapping.put(currentInt, 1);\\n            if (nums[i] % k == 0) total++;\\n\\n            if (i < nums.length - 1) {\\n                for (Map.Entry<Integer, Integer> lastEntry : sums.get(i + 1).entrySet()) {\\n                    int nextInt = currentInt + lastEntry.getKey();\\n                    if (nextInt % k == 0) total += lastEntry.getValue();\\n                    currentMapping.put(nextInt, lastEntry.getValue() + currentMapping.getOrDefault(nextInt, 0));\\n                }\\n            }\\n\\n            sums.put(i, currentMapping);\\n        }\\n\\n        return total;\\n```"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "ajesk",
                        "content": "I just peeked at the solution... right idea, wrong implementation. You can get around the inner loop through some mathematical gymnastics, which I feel is way above my mental abilities for a random daily puzzle lol"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach to reach the solution: https://youtu.be/5dt96hbHfoc"
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Hey there! I really struggled to understand why we needed to use this line `prefixMod = (prefixMod + num % k + k) % k;`.\\n\\nThe basic answer is that we should never have a negative remainder. But many programming languages do not accommodate for this.\\n\\nI found this helpful article that explains the reasoning behind this: \\n\\nhttps://web.archive.org/web/20090717035140if_/javascript.about.com/od/problemsolving/a/modulobug.htm"
                    },
                    {
                        "username": "dev-null0",
                        "content": "O(nk) & O(n^2) both give time limit exceeded.. is this supposed to be done in O(n)?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@udaygupta2801](/udaygupta2801) Negative numbers threw me off"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "YES \\nSuppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "momoxsalameh",
                        "content": "Did anyone find a solution faster than O(n^2)?\\n"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "YES\\nSuppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'ve been noticing lately that these daily challenge problems have unlocked official solutions"
                    }
                ]
            },
            {
                "id": 1765038,
                "content": [
                    {
                        "username": "ohYouCan",
                        "content": "HELP PLEASE . 🙏🏻🙏🏻\n\nSo I had solved a similar problem couple of years ago. So I had an idea about using prefix sum , but I was not able to come up with I have to store remainder or sums or something else( I guess I am really bad at math).\nSo lots of time I know what can be done to solve a particular problem , but I am not able to connect bits , also find it hard to implement.( like how would I do this ?).\n\nAlso I struggle with problems which involves math."
                    },
                    {
                        "username": "kandiana",
                        "content": "you can try to solve pure math problems to get more proficient with applying it in programming\\n\\nremainders are a part of Number Theory, you can look up courses on it, like this one: https://www.coursera.org/learn/number-theory-cryptography#faq"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "practice\\n"
                    },
                    {
                        "username": "ianupam",
                        "content": "Approach 1 mp[sum%k]: \\n                -5%4 = -1 = (-1 * 4 + (-1)) => So remainder here is -1.\\n\\nApproach 2 mp[(sum%k+k)%k]:\\n                -5%4 = 3 = (-2 * 4 + 3) => So remainder here is 3.\\n        Why we are using the Approach 2?"
                    },
                    {
                        "username": "cortexauth",
                        "content": "This question made me feel kinda very dumb, I had the math figured out, I missed at one fact, I can just store the amount of combinations leading to some value mod k . Oh well, I am always bad with such things, idk why \n\nAlso I learned something, if some bound seem useless, it's probably not"
                    },
                    {
                        "username": "shubhamkr3011",
                        "content": "Can anyone tell me why are we only counting the remainders in unordered map ?"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\'  Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e  a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map \\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "ajesk",
                        "content": "My brain is stretched to the limit on this one. I got an o(n^2) solutions of sorts but cant for the love of me figure out how to simplify this down any further...\\n\\nThe thought is to track the number of occurrences of numbers in the sub array starting from `i + 1` and work your way back by applying the current index number, checking the value then saving the count going forward.\\n\\nI can do away with most of the logic in the inner loop and just compile the occurrences into a single mapping, but I feel like that is going to result in the same TLE.\\n\\n ```\\npublic int subarraysDivByK(int[] nums, int k) {\\n        int total = 0;\\n        Map<Integer, Map<Integer, Integer>> sums = new HashMap<>(); \\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            Map<Integer, Integer> currentMapping = new HashMap<>();\\n            int currentInt = nums[i];\\n            currentMapping.put(currentInt, 1);\\n            if (nums[i] % k == 0) total++;\\n\\n            if (i < nums.length - 1) {\\n                for (Map.Entry<Integer, Integer> lastEntry : sums.get(i + 1).entrySet()) {\\n                    int nextInt = currentInt + lastEntry.getKey();\\n                    if (nextInt % k == 0) total += lastEntry.getValue();\\n                    currentMapping.put(nextInt, lastEntry.getValue() + currentMapping.getOrDefault(nextInt, 0));\\n                }\\n            }\\n\\n            sums.put(i, currentMapping);\\n        }\\n\\n        return total;\\n```"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "ajesk",
                        "content": "I just peeked at the solution... right idea, wrong implementation. You can get around the inner loop through some mathematical gymnastics, which I feel is way above my mental abilities for a random daily puzzle lol"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach to reach the solution: https://youtu.be/5dt96hbHfoc"
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Hey there! I really struggled to understand why we needed to use this line `prefixMod = (prefixMod + num % k + k) % k;`.\\n\\nThe basic answer is that we should never have a negative remainder. But many programming languages do not accommodate for this.\\n\\nI found this helpful article that explains the reasoning behind this: \\n\\nhttps://web.archive.org/web/20090717035140if_/javascript.about.com/od/problemsolving/a/modulobug.htm"
                    },
                    {
                        "username": "dev-null0",
                        "content": "O(nk) & O(n^2) both give time limit exceeded.. is this supposed to be done in O(n)?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@udaygupta2801](/udaygupta2801) Negative numbers threw me off"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "YES \\nSuppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "momoxsalameh",
                        "content": "Did anyone find a solution faster than O(n^2)?\\n"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "YES\\nSuppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'ve been noticing lately that these daily challenge problems have unlocked official solutions"
                    }
                ]
            },
            {
                "id": 1765007,
                "content": [
                    {
                        "username": "ohYouCan",
                        "content": "HELP PLEASE . 🙏🏻🙏🏻\n\nSo I had solved a similar problem couple of years ago. So I had an idea about using prefix sum , but I was not able to come up with I have to store remainder or sums or something else( I guess I am really bad at math).\nSo lots of time I know what can be done to solve a particular problem , but I am not able to connect bits , also find it hard to implement.( like how would I do this ?).\n\nAlso I struggle with problems which involves math."
                    },
                    {
                        "username": "kandiana",
                        "content": "you can try to solve pure math problems to get more proficient with applying it in programming\\n\\nremainders are a part of Number Theory, you can look up courses on it, like this one: https://www.coursera.org/learn/number-theory-cryptography#faq"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "practice\\n"
                    },
                    {
                        "username": "ianupam",
                        "content": "Approach 1 mp[sum%k]: \\n                -5%4 = -1 = (-1 * 4 + (-1)) => So remainder here is -1.\\n\\nApproach 2 mp[(sum%k+k)%k]:\\n                -5%4 = 3 = (-2 * 4 + 3) => So remainder here is 3.\\n        Why we are using the Approach 2?"
                    },
                    {
                        "username": "cortexauth",
                        "content": "This question made me feel kinda very dumb, I had the math figured out, I missed at one fact, I can just store the amount of combinations leading to some value mod k . Oh well, I am always bad with such things, idk why \n\nAlso I learned something, if some bound seem useless, it's probably not"
                    },
                    {
                        "username": "shubhamkr3011",
                        "content": "Can anyone tell me why are we only counting the remainders in unordered map ?"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\'  Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e  a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map \\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "ajesk",
                        "content": "My brain is stretched to the limit on this one. I got an o(n^2) solutions of sorts but cant for the love of me figure out how to simplify this down any further...\\n\\nThe thought is to track the number of occurrences of numbers in the sub array starting from `i + 1` and work your way back by applying the current index number, checking the value then saving the count going forward.\\n\\nI can do away with most of the logic in the inner loop and just compile the occurrences into a single mapping, but I feel like that is going to result in the same TLE.\\n\\n ```\\npublic int subarraysDivByK(int[] nums, int k) {\\n        int total = 0;\\n        Map<Integer, Map<Integer, Integer>> sums = new HashMap<>(); \\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            Map<Integer, Integer> currentMapping = new HashMap<>();\\n            int currentInt = nums[i];\\n            currentMapping.put(currentInt, 1);\\n            if (nums[i] % k == 0) total++;\\n\\n            if (i < nums.length - 1) {\\n                for (Map.Entry<Integer, Integer> lastEntry : sums.get(i + 1).entrySet()) {\\n                    int nextInt = currentInt + lastEntry.getKey();\\n                    if (nextInt % k == 0) total += lastEntry.getValue();\\n                    currentMapping.put(nextInt, lastEntry.getValue() + currentMapping.getOrDefault(nextInt, 0));\\n                }\\n            }\\n\\n            sums.put(i, currentMapping);\\n        }\\n\\n        return total;\\n```"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "ajesk",
                        "content": "I just peeked at the solution... right idea, wrong implementation. You can get around the inner loop through some mathematical gymnastics, which I feel is way above my mental abilities for a random daily puzzle lol"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach to reach the solution: https://youtu.be/5dt96hbHfoc"
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Hey there! I really struggled to understand why we needed to use this line `prefixMod = (prefixMod + num % k + k) % k;`.\\n\\nThe basic answer is that we should never have a negative remainder. But many programming languages do not accommodate for this.\\n\\nI found this helpful article that explains the reasoning behind this: \\n\\nhttps://web.archive.org/web/20090717035140if_/javascript.about.com/od/problemsolving/a/modulobug.htm"
                    },
                    {
                        "username": "dev-null0",
                        "content": "O(nk) & O(n^2) both give time limit exceeded.. is this supposed to be done in O(n)?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@udaygupta2801](/udaygupta2801) Negative numbers threw me off"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "YES \\nSuppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "momoxsalameh",
                        "content": "Did anyone find a solution faster than O(n^2)?\\n"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "YES\\nSuppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'ve been noticing lately that these daily challenge problems have unlocked official solutions"
                    }
                ]
            },
            {
                "id": 1764991,
                "content": [
                    {
                        "username": "ohYouCan",
                        "content": "HELP PLEASE . 🙏🏻🙏🏻\n\nSo I had solved a similar problem couple of years ago. So I had an idea about using prefix sum , but I was not able to come up with I have to store remainder or sums or something else( I guess I am really bad at math).\nSo lots of time I know what can be done to solve a particular problem , but I am not able to connect bits , also find it hard to implement.( like how would I do this ?).\n\nAlso I struggle with problems which involves math."
                    },
                    {
                        "username": "kandiana",
                        "content": "you can try to solve pure math problems to get more proficient with applying it in programming\\n\\nremainders are a part of Number Theory, you can look up courses on it, like this one: https://www.coursera.org/learn/number-theory-cryptography#faq"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "practice\\n"
                    },
                    {
                        "username": "ianupam",
                        "content": "Approach 1 mp[sum%k]: \\n                -5%4 = -1 = (-1 * 4 + (-1)) => So remainder here is -1.\\n\\nApproach 2 mp[(sum%k+k)%k]:\\n                -5%4 = 3 = (-2 * 4 + 3) => So remainder here is 3.\\n        Why we are using the Approach 2?"
                    },
                    {
                        "username": "cortexauth",
                        "content": "This question made me feel kinda very dumb, I had the math figured out, I missed at one fact, I can just store the amount of combinations leading to some value mod k . Oh well, I am always bad with such things, idk why \n\nAlso I learned something, if some bound seem useless, it's probably not"
                    },
                    {
                        "username": "shubhamkr3011",
                        "content": "Can anyone tell me why are we only counting the remainders in unordered map ?"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\'  Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e  a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map \\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "ajesk",
                        "content": "My brain is stretched to the limit on this one. I got an o(n^2) solutions of sorts but cant for the love of me figure out how to simplify this down any further...\\n\\nThe thought is to track the number of occurrences of numbers in the sub array starting from `i + 1` and work your way back by applying the current index number, checking the value then saving the count going forward.\\n\\nI can do away with most of the logic in the inner loop and just compile the occurrences into a single mapping, but I feel like that is going to result in the same TLE.\\n\\n ```\\npublic int subarraysDivByK(int[] nums, int k) {\\n        int total = 0;\\n        Map<Integer, Map<Integer, Integer>> sums = new HashMap<>(); \\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            Map<Integer, Integer> currentMapping = new HashMap<>();\\n            int currentInt = nums[i];\\n            currentMapping.put(currentInt, 1);\\n            if (nums[i] % k == 0) total++;\\n\\n            if (i < nums.length - 1) {\\n                for (Map.Entry<Integer, Integer> lastEntry : sums.get(i + 1).entrySet()) {\\n                    int nextInt = currentInt + lastEntry.getKey();\\n                    if (nextInt % k == 0) total += lastEntry.getValue();\\n                    currentMapping.put(nextInt, lastEntry.getValue() + currentMapping.getOrDefault(nextInt, 0));\\n                }\\n            }\\n\\n            sums.put(i, currentMapping);\\n        }\\n\\n        return total;\\n```"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "ajesk",
                        "content": "I just peeked at the solution... right idea, wrong implementation. You can get around the inner loop through some mathematical gymnastics, which I feel is way above my mental abilities for a random daily puzzle lol"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach to reach the solution: https://youtu.be/5dt96hbHfoc"
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Hey there! I really struggled to understand why we needed to use this line `prefixMod = (prefixMod + num % k + k) % k;`.\\n\\nThe basic answer is that we should never have a negative remainder. But many programming languages do not accommodate for this.\\n\\nI found this helpful article that explains the reasoning behind this: \\n\\nhttps://web.archive.org/web/20090717035140if_/javascript.about.com/od/problemsolving/a/modulobug.htm"
                    },
                    {
                        "username": "dev-null0",
                        "content": "O(nk) & O(n^2) both give time limit exceeded.. is this supposed to be done in O(n)?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@udaygupta2801](/udaygupta2801) Negative numbers threw me off"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "YES \\nSuppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "momoxsalameh",
                        "content": "Did anyone find a solution faster than O(n^2)?\\n"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "YES\\nSuppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'ve been noticing lately that these daily challenge problems have unlocked official solutions"
                    }
                ]
            },
            {
                "id": 1764979,
                "content": [
                    {
                        "username": "ohYouCan",
                        "content": "HELP PLEASE . 🙏🏻🙏🏻\n\nSo I had solved a similar problem couple of years ago. So I had an idea about using prefix sum , but I was not able to come up with I have to store remainder or sums or something else( I guess I am really bad at math).\nSo lots of time I know what can be done to solve a particular problem , but I am not able to connect bits , also find it hard to implement.( like how would I do this ?).\n\nAlso I struggle with problems which involves math."
                    },
                    {
                        "username": "kandiana",
                        "content": "you can try to solve pure math problems to get more proficient with applying it in programming\\n\\nremainders are a part of Number Theory, you can look up courses on it, like this one: https://www.coursera.org/learn/number-theory-cryptography#faq"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "practice\\n"
                    },
                    {
                        "username": "ianupam",
                        "content": "Approach 1 mp[sum%k]: \\n                -5%4 = -1 = (-1 * 4 + (-1)) => So remainder here is -1.\\n\\nApproach 2 mp[(sum%k+k)%k]:\\n                -5%4 = 3 = (-2 * 4 + 3) => So remainder here is 3.\\n        Why we are using the Approach 2?"
                    },
                    {
                        "username": "cortexauth",
                        "content": "This question made me feel kinda very dumb, I had the math figured out, I missed at one fact, I can just store the amount of combinations leading to some value mod k . Oh well, I am always bad with such things, idk why \n\nAlso I learned something, if some bound seem useless, it's probably not"
                    },
                    {
                        "username": "shubhamkr3011",
                        "content": "Can anyone tell me why are we only counting the remainders in unordered map ?"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\'  Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e  a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map \\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "ajesk",
                        "content": "My brain is stretched to the limit on this one. I got an o(n^2) solutions of sorts but cant for the love of me figure out how to simplify this down any further...\\n\\nThe thought is to track the number of occurrences of numbers in the sub array starting from `i + 1` and work your way back by applying the current index number, checking the value then saving the count going forward.\\n\\nI can do away with most of the logic in the inner loop and just compile the occurrences into a single mapping, but I feel like that is going to result in the same TLE.\\n\\n ```\\npublic int subarraysDivByK(int[] nums, int k) {\\n        int total = 0;\\n        Map<Integer, Map<Integer, Integer>> sums = new HashMap<>(); \\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            Map<Integer, Integer> currentMapping = new HashMap<>();\\n            int currentInt = nums[i];\\n            currentMapping.put(currentInt, 1);\\n            if (nums[i] % k == 0) total++;\\n\\n            if (i < nums.length - 1) {\\n                for (Map.Entry<Integer, Integer> lastEntry : sums.get(i + 1).entrySet()) {\\n                    int nextInt = currentInt + lastEntry.getKey();\\n                    if (nextInt % k == 0) total += lastEntry.getValue();\\n                    currentMapping.put(nextInt, lastEntry.getValue() + currentMapping.getOrDefault(nextInt, 0));\\n                }\\n            }\\n\\n            sums.put(i, currentMapping);\\n        }\\n\\n        return total;\\n```"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "ajesk",
                        "content": "I just peeked at the solution... right idea, wrong implementation. You can get around the inner loop through some mathematical gymnastics, which I feel is way above my mental abilities for a random daily puzzle lol"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach to reach the solution: https://youtu.be/5dt96hbHfoc"
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Hey there! I really struggled to understand why we needed to use this line `prefixMod = (prefixMod + num % k + k) % k;`.\\n\\nThe basic answer is that we should never have a negative remainder. But many programming languages do not accommodate for this.\\n\\nI found this helpful article that explains the reasoning behind this: \\n\\nhttps://web.archive.org/web/20090717035140if_/javascript.about.com/od/problemsolving/a/modulobug.htm"
                    },
                    {
                        "username": "dev-null0",
                        "content": "O(nk) & O(n^2) both give time limit exceeded.. is this supposed to be done in O(n)?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@udaygupta2801](/udaygupta2801) Negative numbers threw me off"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "YES \\nSuppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "momoxsalameh",
                        "content": "Did anyone find a solution faster than O(n^2)?\\n"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "YES\\nSuppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'ve been noticing lately that these daily challenge problems have unlocked official solutions"
                    }
                ]
            },
            {
                "id": 1764927,
                "content": [
                    {
                        "username": "ohYouCan",
                        "content": "HELP PLEASE . 🙏🏻🙏🏻\n\nSo I had solved a similar problem couple of years ago. So I had an idea about using prefix sum , but I was not able to come up with I have to store remainder or sums or something else( I guess I am really bad at math).\nSo lots of time I know what can be done to solve a particular problem , but I am not able to connect bits , also find it hard to implement.( like how would I do this ?).\n\nAlso I struggle with problems which involves math."
                    },
                    {
                        "username": "kandiana",
                        "content": "you can try to solve pure math problems to get more proficient with applying it in programming\\n\\nremainders are a part of Number Theory, you can look up courses on it, like this one: https://www.coursera.org/learn/number-theory-cryptography#faq"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "practice\\n"
                    },
                    {
                        "username": "ianupam",
                        "content": "Approach 1 mp[sum%k]: \\n                -5%4 = -1 = (-1 * 4 + (-1)) => So remainder here is -1.\\n\\nApproach 2 mp[(sum%k+k)%k]:\\n                -5%4 = 3 = (-2 * 4 + 3) => So remainder here is 3.\\n        Why we are using the Approach 2?"
                    },
                    {
                        "username": "cortexauth",
                        "content": "This question made me feel kinda very dumb, I had the math figured out, I missed at one fact, I can just store the amount of combinations leading to some value mod k . Oh well, I am always bad with such things, idk why \n\nAlso I learned something, if some bound seem useless, it's probably not"
                    },
                    {
                        "username": "shubhamkr3011",
                        "content": "Can anyone tell me why are we only counting the remainders in unordered map ?"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\'  Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e  a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map \\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "ajesk",
                        "content": "My brain is stretched to the limit on this one. I got an o(n^2) solutions of sorts but cant for the love of me figure out how to simplify this down any further...\\n\\nThe thought is to track the number of occurrences of numbers in the sub array starting from `i + 1` and work your way back by applying the current index number, checking the value then saving the count going forward.\\n\\nI can do away with most of the logic in the inner loop and just compile the occurrences into a single mapping, but I feel like that is going to result in the same TLE.\\n\\n ```\\npublic int subarraysDivByK(int[] nums, int k) {\\n        int total = 0;\\n        Map<Integer, Map<Integer, Integer>> sums = new HashMap<>(); \\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            Map<Integer, Integer> currentMapping = new HashMap<>();\\n            int currentInt = nums[i];\\n            currentMapping.put(currentInt, 1);\\n            if (nums[i] % k == 0) total++;\\n\\n            if (i < nums.length - 1) {\\n                for (Map.Entry<Integer, Integer> lastEntry : sums.get(i + 1).entrySet()) {\\n                    int nextInt = currentInt + lastEntry.getKey();\\n                    if (nextInt % k == 0) total += lastEntry.getValue();\\n                    currentMapping.put(nextInt, lastEntry.getValue() + currentMapping.getOrDefault(nextInt, 0));\\n                }\\n            }\\n\\n            sums.put(i, currentMapping);\\n        }\\n\\n        return total;\\n```"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "ajesk",
                        "content": "I just peeked at the solution... right idea, wrong implementation. You can get around the inner loop through some mathematical gymnastics, which I feel is way above my mental abilities for a random daily puzzle lol"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach to reach the solution: https://youtu.be/5dt96hbHfoc"
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Hey there! I really struggled to understand why we needed to use this line `prefixMod = (prefixMod + num % k + k) % k;`.\\n\\nThe basic answer is that we should never have a negative remainder. But many programming languages do not accommodate for this.\\n\\nI found this helpful article that explains the reasoning behind this: \\n\\nhttps://web.archive.org/web/20090717035140if_/javascript.about.com/od/problemsolving/a/modulobug.htm"
                    },
                    {
                        "username": "dev-null0",
                        "content": "O(nk) & O(n^2) both give time limit exceeded.. is this supposed to be done in O(n)?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@udaygupta2801](/udaygupta2801) Negative numbers threw me off"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "YES \\nSuppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "momoxsalameh",
                        "content": "Did anyone find a solution faster than O(n^2)?\\n"
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "YES\\nSuppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'ve been noticing lately that these daily challenge problems have unlocked official solutions"
                    }
                ]
            },
            {
                "id": 1764897,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Think of the how to solve the [subarray sum equals k](https://leetcode.com/problems/subarray-sum-equals-k/description/) problem.\n\n1. Calculate prefix sum of the array and store each prefix sum in some hash-map.\n2. prefix sum of elements ```0 to i``` is ```x``` say. And prefix sum of elements ```0 to j``` is ```y``` say, where ```j > i```. Thus subarray sum of elements ```i+1 to j``` is ```y - x```.\n3. If the  subarray sum equals ```k```, then ```y - x = k``` or ```x = y - k```. Thus if a prefix sum of ```y - k``` exists in the hash-map when we have a prefix sum of ```y``` in hand, we have our solution.\n\n\nWell, we just need to tailor the above solution to fit this problem.\n\nAgain take the case of prefix sums of ```x``` and ```y``` as above. If the subarray sum ```y - x``` is divisible by k, then ```(y - x) % k = 0```  or ```y%k = x%k```.\nThus, we can store the modulo-k of the prefix sums in a hash-map.\nIf we have the current modulo-k of prefix sum as ```z``` and ```z``` is already present in the hash-map, we have a subarray sum divisible by k.\n\nCouple of corner cases.\n1. Have the ```hashmap[0] = 1``` so that any prefix sum of 0 can match that.\n2. Handling negative numbers is a bit tricky, so we can bring them to the positive space without losing the modulo correctness with the help of the following observation -\n```(prefix_sum + n) % k``` is equivalent to ```(prefix_sum + k + (n % k)) % k```. Note, since k is positive, ```k + (n % k)``` is also positive."
                    },
                    {
                        "username": "k0biba",
                        "content": "Could someone explain, why a \"backtracking\" approach would not work or how I could modify mine, so it does? Thanks a lot! \\n\\n \\n     int res = 0;\\n    public int subarraysDivByK(int[] nums, int k) {\\n        helper(-1, nums, k, 0, new ArrayList<>());\\n        return res;\\n    }\\n\\n    void helper(int idx, int[] nums, int k, int currSum, List<Integer> curr){\\n        if(idx != -1 && currSum % k == 0){\\n            res++;\\n            System.out.println(curr.toString());\\n        }\\n        idx++;\\n        if(idx >= nums.length) return;\\n        curr.add(nums[idx]);\\n        helper(idx, nums, k, currSum + nums[idx], curr);\\n        curr = new ArrayList<>();\\n        curr.add(nums[idx]);\\n        helper(idx, nums, k, nums[idx], curr);\\n    }\\n\\n"
                    },
                    {
                        "username": "vermani",
                        "content": "Those who are using c++ and cumulative sum approach, remember that modulo operator in c++ can return negative number too but remainder should always be positive so we have to use something like follows :\\nauto remainder = (cumulativeSum%k+k)%k;"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "I thought only prefix sum (O(n^2)) would do the job. But didn\\'t.  I could never extract the accepted solution idea by myself. What a mathematical concept!!"
                    },
                    {
                        "username": "MaxKhor",
                        "content": "Last week is week of trees and now we are entering week of subarrays"
                    },
                    {
                        "username": "barnik_b",
                        "content": "Isn't this too much math for a cs interview question? I came with the solution that would involve only +ve numbers.\nAre we expected to come with a prefix sum modulo like this during an interview?\n`prefixSum = (prefixSum + num%k + k)%k;`\n\n"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using Map;\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int>mp;\\n        int rem=0;\\n        int sum=0;\\n        int ans=0;\\n        mp[rem]=1;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            rem=sum%k;\\n            if(rem<0){\\n                rem+=k;\\n            }\\n            if(mp.find(rem)!=mp.end()){\\n                ans+=mp[rem];\\n            }\\n            mp[rem]++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        # of remainders\\n        arr =nums\\n        mod =[]\\n        n = len(arr)\\n        for i in range(k + 1):\\n            mod.append(0)\\n        # Traverse original array\\n        # and compute cumulative\\n        # sum take remainder of this\\n        # current cumulative\\n        # sum and increase count by\\n        # 1 for this remainder\\n        # in mod[] array\\n        cumSum = 0\\n        for i in range(n):\\n            cumSum = cumSum + arr[i]\\n            # as the sum can be negative,\\n            # taking modulo twice\\n            mod[((cumSum % k)+k)% k]= mod[((cumSum % k)+k)% k] + 1\\n        result = 0  # Initialize result\\n        # Traverse mod[]\\n        for i in range(k):\\n            # If there are more than\\n            # one prefix subarrays\\n            # with a particular mod value.\\n            if (mod[i] > 1):\\n                result = result + (mod[i]*(mod[i]-1))//2\\n        # add the elements which\\n        # are divisible by k itself\\n        # i.e., the elements whose sum = 0\\n        result = result + mod[0]\\n        return result\\n     "
                    },
                    {
                        "username": "wpopielarski",
                        "content": "cool problem, quite like some hard. Three hints: prefix sum, modulo, and take attention on positions with same modulo values"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "There are three boundary cases for finding the postive sum and negetive.\\n// +ve - +ve (same as -ve - -ve)\\n// +ve - -ve\\n// -ve - +ve\\n"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "or you can actually making the remainder all postive"
                    }
                ]
            },
            {
                "id": 1764889,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Think of the how to solve the [subarray sum equals k](https://leetcode.com/problems/subarray-sum-equals-k/description/) problem.\n\n1. Calculate prefix sum of the array and store each prefix sum in some hash-map.\n2. prefix sum of elements ```0 to i``` is ```x``` say. And prefix sum of elements ```0 to j``` is ```y``` say, where ```j > i```. Thus subarray sum of elements ```i+1 to j``` is ```y - x```.\n3. If the  subarray sum equals ```k```, then ```y - x = k``` or ```x = y - k```. Thus if a prefix sum of ```y - k``` exists in the hash-map when we have a prefix sum of ```y``` in hand, we have our solution.\n\n\nWell, we just need to tailor the above solution to fit this problem.\n\nAgain take the case of prefix sums of ```x``` and ```y``` as above. If the subarray sum ```y - x``` is divisible by k, then ```(y - x) % k = 0```  or ```y%k = x%k```.\nThus, we can store the modulo-k of the prefix sums in a hash-map.\nIf we have the current modulo-k of prefix sum as ```z``` and ```z``` is already present in the hash-map, we have a subarray sum divisible by k.\n\nCouple of corner cases.\n1. Have the ```hashmap[0] = 1``` so that any prefix sum of 0 can match that.\n2. Handling negative numbers is a bit tricky, so we can bring them to the positive space without losing the modulo correctness with the help of the following observation -\n```(prefix_sum + n) % k``` is equivalent to ```(prefix_sum + k + (n % k)) % k```. Note, since k is positive, ```k + (n % k)``` is also positive."
                    },
                    {
                        "username": "k0biba",
                        "content": "Could someone explain, why a \"backtracking\" approach would not work or how I could modify mine, so it does? Thanks a lot! \\n\\n \\n     int res = 0;\\n    public int subarraysDivByK(int[] nums, int k) {\\n        helper(-1, nums, k, 0, new ArrayList<>());\\n        return res;\\n    }\\n\\n    void helper(int idx, int[] nums, int k, int currSum, List<Integer> curr){\\n        if(idx != -1 && currSum % k == 0){\\n            res++;\\n            System.out.println(curr.toString());\\n        }\\n        idx++;\\n        if(idx >= nums.length) return;\\n        curr.add(nums[idx]);\\n        helper(idx, nums, k, currSum + nums[idx], curr);\\n        curr = new ArrayList<>();\\n        curr.add(nums[idx]);\\n        helper(idx, nums, k, nums[idx], curr);\\n    }\\n\\n"
                    },
                    {
                        "username": "vermani",
                        "content": "Those who are using c++ and cumulative sum approach, remember that modulo operator in c++ can return negative number too but remainder should always be positive so we have to use something like follows :\\nauto remainder = (cumulativeSum%k+k)%k;"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "I thought only prefix sum (O(n^2)) would do the job. But didn\\'t.  I could never extract the accepted solution idea by myself. What a mathematical concept!!"
                    },
                    {
                        "username": "MaxKhor",
                        "content": "Last week is week of trees and now we are entering week of subarrays"
                    },
                    {
                        "username": "barnik_b",
                        "content": "Isn't this too much math for a cs interview question? I came with the solution that would involve only +ve numbers.\nAre we expected to come with a prefix sum modulo like this during an interview?\n`prefixSum = (prefixSum + num%k + k)%k;`\n\n"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using Map;\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int>mp;\\n        int rem=0;\\n        int sum=0;\\n        int ans=0;\\n        mp[rem]=1;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            rem=sum%k;\\n            if(rem<0){\\n                rem+=k;\\n            }\\n            if(mp.find(rem)!=mp.end()){\\n                ans+=mp[rem];\\n            }\\n            mp[rem]++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        # of remainders\\n        arr =nums\\n        mod =[]\\n        n = len(arr)\\n        for i in range(k + 1):\\n            mod.append(0)\\n        # Traverse original array\\n        # and compute cumulative\\n        # sum take remainder of this\\n        # current cumulative\\n        # sum and increase count by\\n        # 1 for this remainder\\n        # in mod[] array\\n        cumSum = 0\\n        for i in range(n):\\n            cumSum = cumSum + arr[i]\\n            # as the sum can be negative,\\n            # taking modulo twice\\n            mod[((cumSum % k)+k)% k]= mod[((cumSum % k)+k)% k] + 1\\n        result = 0  # Initialize result\\n        # Traverse mod[]\\n        for i in range(k):\\n            # If there are more than\\n            # one prefix subarrays\\n            # with a particular mod value.\\n            if (mod[i] > 1):\\n                result = result + (mod[i]*(mod[i]-1))//2\\n        # add the elements which\\n        # are divisible by k itself\\n        # i.e., the elements whose sum = 0\\n        result = result + mod[0]\\n        return result\\n     "
                    },
                    {
                        "username": "wpopielarski",
                        "content": "cool problem, quite like some hard. Three hints: prefix sum, modulo, and take attention on positions with same modulo values"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "There are three boundary cases for finding the postive sum and negetive.\\n// +ve - +ve (same as -ve - -ve)\\n// +ve - -ve\\n// -ve - +ve\\n"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "or you can actually making the remainder all postive"
                    }
                ]
            },
            {
                "id": 1764870,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Think of the how to solve the [subarray sum equals k](https://leetcode.com/problems/subarray-sum-equals-k/description/) problem.\n\n1. Calculate prefix sum of the array and store each prefix sum in some hash-map.\n2. prefix sum of elements ```0 to i``` is ```x``` say. And prefix sum of elements ```0 to j``` is ```y``` say, where ```j > i```. Thus subarray sum of elements ```i+1 to j``` is ```y - x```.\n3. If the  subarray sum equals ```k```, then ```y - x = k``` or ```x = y - k```. Thus if a prefix sum of ```y - k``` exists in the hash-map when we have a prefix sum of ```y``` in hand, we have our solution.\n\n\nWell, we just need to tailor the above solution to fit this problem.\n\nAgain take the case of prefix sums of ```x``` and ```y``` as above. If the subarray sum ```y - x``` is divisible by k, then ```(y - x) % k = 0```  or ```y%k = x%k```.\nThus, we can store the modulo-k of the prefix sums in a hash-map.\nIf we have the current modulo-k of prefix sum as ```z``` and ```z``` is already present in the hash-map, we have a subarray sum divisible by k.\n\nCouple of corner cases.\n1. Have the ```hashmap[0] = 1``` so that any prefix sum of 0 can match that.\n2. Handling negative numbers is a bit tricky, so we can bring them to the positive space without losing the modulo correctness with the help of the following observation -\n```(prefix_sum + n) % k``` is equivalent to ```(prefix_sum + k + (n % k)) % k```. Note, since k is positive, ```k + (n % k)``` is also positive."
                    },
                    {
                        "username": "k0biba",
                        "content": "Could someone explain, why a \"backtracking\" approach would not work or how I could modify mine, so it does? Thanks a lot! \\n\\n \\n     int res = 0;\\n    public int subarraysDivByK(int[] nums, int k) {\\n        helper(-1, nums, k, 0, new ArrayList<>());\\n        return res;\\n    }\\n\\n    void helper(int idx, int[] nums, int k, int currSum, List<Integer> curr){\\n        if(idx != -1 && currSum % k == 0){\\n            res++;\\n            System.out.println(curr.toString());\\n        }\\n        idx++;\\n        if(idx >= nums.length) return;\\n        curr.add(nums[idx]);\\n        helper(idx, nums, k, currSum + nums[idx], curr);\\n        curr = new ArrayList<>();\\n        curr.add(nums[idx]);\\n        helper(idx, nums, k, nums[idx], curr);\\n    }\\n\\n"
                    },
                    {
                        "username": "vermani",
                        "content": "Those who are using c++ and cumulative sum approach, remember that modulo operator in c++ can return negative number too but remainder should always be positive so we have to use something like follows :\\nauto remainder = (cumulativeSum%k+k)%k;"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "I thought only prefix sum (O(n^2)) would do the job. But didn\\'t.  I could never extract the accepted solution idea by myself. What a mathematical concept!!"
                    },
                    {
                        "username": "MaxKhor",
                        "content": "Last week is week of trees and now we are entering week of subarrays"
                    },
                    {
                        "username": "barnik_b",
                        "content": "Isn't this too much math for a cs interview question? I came with the solution that would involve only +ve numbers.\nAre we expected to come with a prefix sum modulo like this during an interview?\n`prefixSum = (prefixSum + num%k + k)%k;`\n\n"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using Map;\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int>mp;\\n        int rem=0;\\n        int sum=0;\\n        int ans=0;\\n        mp[rem]=1;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            rem=sum%k;\\n            if(rem<0){\\n                rem+=k;\\n            }\\n            if(mp.find(rem)!=mp.end()){\\n                ans+=mp[rem];\\n            }\\n            mp[rem]++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        # of remainders\\n        arr =nums\\n        mod =[]\\n        n = len(arr)\\n        for i in range(k + 1):\\n            mod.append(0)\\n        # Traverse original array\\n        # and compute cumulative\\n        # sum take remainder of this\\n        # current cumulative\\n        # sum and increase count by\\n        # 1 for this remainder\\n        # in mod[] array\\n        cumSum = 0\\n        for i in range(n):\\n            cumSum = cumSum + arr[i]\\n            # as the sum can be negative,\\n            # taking modulo twice\\n            mod[((cumSum % k)+k)% k]= mod[((cumSum % k)+k)% k] + 1\\n        result = 0  # Initialize result\\n        # Traverse mod[]\\n        for i in range(k):\\n            # If there are more than\\n            # one prefix subarrays\\n            # with a particular mod value.\\n            if (mod[i] > 1):\\n                result = result + (mod[i]*(mod[i]-1))//2\\n        # add the elements which\\n        # are divisible by k itself\\n        # i.e., the elements whose sum = 0\\n        result = result + mod[0]\\n        return result\\n     "
                    },
                    {
                        "username": "wpopielarski",
                        "content": "cool problem, quite like some hard. Three hints: prefix sum, modulo, and take attention on positions with same modulo values"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "There are three boundary cases for finding the postive sum and negetive.\\n// +ve - +ve (same as -ve - -ve)\\n// +ve - -ve\\n// -ve - +ve\\n"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "or you can actually making the remainder all postive"
                    }
                ]
            },
            {
                "id": 1764751,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Think of the how to solve the [subarray sum equals k](https://leetcode.com/problems/subarray-sum-equals-k/description/) problem.\n\n1. Calculate prefix sum of the array and store each prefix sum in some hash-map.\n2. prefix sum of elements ```0 to i``` is ```x``` say. And prefix sum of elements ```0 to j``` is ```y``` say, where ```j > i```. Thus subarray sum of elements ```i+1 to j``` is ```y - x```.\n3. If the  subarray sum equals ```k```, then ```y - x = k``` or ```x = y - k```. Thus if a prefix sum of ```y - k``` exists in the hash-map when we have a prefix sum of ```y``` in hand, we have our solution.\n\n\nWell, we just need to tailor the above solution to fit this problem.\n\nAgain take the case of prefix sums of ```x``` and ```y``` as above. If the subarray sum ```y - x``` is divisible by k, then ```(y - x) % k = 0```  or ```y%k = x%k```.\nThus, we can store the modulo-k of the prefix sums in a hash-map.\nIf we have the current modulo-k of prefix sum as ```z``` and ```z``` is already present in the hash-map, we have a subarray sum divisible by k.\n\nCouple of corner cases.\n1. Have the ```hashmap[0] = 1``` so that any prefix sum of 0 can match that.\n2. Handling negative numbers is a bit tricky, so we can bring them to the positive space without losing the modulo correctness with the help of the following observation -\n```(prefix_sum + n) % k``` is equivalent to ```(prefix_sum + k + (n % k)) % k```. Note, since k is positive, ```k + (n % k)``` is also positive."
                    },
                    {
                        "username": "k0biba",
                        "content": "Could someone explain, why a \"backtracking\" approach would not work or how I could modify mine, so it does? Thanks a lot! \\n\\n \\n     int res = 0;\\n    public int subarraysDivByK(int[] nums, int k) {\\n        helper(-1, nums, k, 0, new ArrayList<>());\\n        return res;\\n    }\\n\\n    void helper(int idx, int[] nums, int k, int currSum, List<Integer> curr){\\n        if(idx != -1 && currSum % k == 0){\\n            res++;\\n            System.out.println(curr.toString());\\n        }\\n        idx++;\\n        if(idx >= nums.length) return;\\n        curr.add(nums[idx]);\\n        helper(idx, nums, k, currSum + nums[idx], curr);\\n        curr = new ArrayList<>();\\n        curr.add(nums[idx]);\\n        helper(idx, nums, k, nums[idx], curr);\\n    }\\n\\n"
                    },
                    {
                        "username": "vermani",
                        "content": "Those who are using c++ and cumulative sum approach, remember that modulo operator in c++ can return negative number too but remainder should always be positive so we have to use something like follows :\\nauto remainder = (cumulativeSum%k+k)%k;"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "I thought only prefix sum (O(n^2)) would do the job. But didn\\'t.  I could never extract the accepted solution idea by myself. What a mathematical concept!!"
                    },
                    {
                        "username": "MaxKhor",
                        "content": "Last week is week of trees and now we are entering week of subarrays"
                    },
                    {
                        "username": "barnik_b",
                        "content": "Isn't this too much math for a cs interview question? I came with the solution that would involve only +ve numbers.\nAre we expected to come with a prefix sum modulo like this during an interview?\n`prefixSum = (prefixSum + num%k + k)%k;`\n\n"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using Map;\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int>mp;\\n        int rem=0;\\n        int sum=0;\\n        int ans=0;\\n        mp[rem]=1;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            rem=sum%k;\\n            if(rem<0){\\n                rem+=k;\\n            }\\n            if(mp.find(rem)!=mp.end()){\\n                ans+=mp[rem];\\n            }\\n            mp[rem]++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        # of remainders\\n        arr =nums\\n        mod =[]\\n        n = len(arr)\\n        for i in range(k + 1):\\n            mod.append(0)\\n        # Traverse original array\\n        # and compute cumulative\\n        # sum take remainder of this\\n        # current cumulative\\n        # sum and increase count by\\n        # 1 for this remainder\\n        # in mod[] array\\n        cumSum = 0\\n        for i in range(n):\\n            cumSum = cumSum + arr[i]\\n            # as the sum can be negative,\\n            # taking modulo twice\\n            mod[((cumSum % k)+k)% k]= mod[((cumSum % k)+k)% k] + 1\\n        result = 0  # Initialize result\\n        # Traverse mod[]\\n        for i in range(k):\\n            # If there are more than\\n            # one prefix subarrays\\n            # with a particular mod value.\\n            if (mod[i] > 1):\\n                result = result + (mod[i]*(mod[i]-1))//2\\n        # add the elements which\\n        # are divisible by k itself\\n        # i.e., the elements whose sum = 0\\n        result = result + mod[0]\\n        return result\\n     "
                    },
                    {
                        "username": "wpopielarski",
                        "content": "cool problem, quite like some hard. Three hints: prefix sum, modulo, and take attention on positions with same modulo values"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "There are three boundary cases for finding the postive sum and negetive.\\n// +ve - +ve (same as -ve - -ve)\\n// +ve - -ve\\n// -ve - +ve\\n"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "or you can actually making the remainder all postive"
                    }
                ]
            },
            {
                "id": 1764742,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Think of the how to solve the [subarray sum equals k](https://leetcode.com/problems/subarray-sum-equals-k/description/) problem.\n\n1. Calculate prefix sum of the array and store each prefix sum in some hash-map.\n2. prefix sum of elements ```0 to i``` is ```x``` say. And prefix sum of elements ```0 to j``` is ```y``` say, where ```j > i```. Thus subarray sum of elements ```i+1 to j``` is ```y - x```.\n3. If the  subarray sum equals ```k```, then ```y - x = k``` or ```x = y - k```. Thus if a prefix sum of ```y - k``` exists in the hash-map when we have a prefix sum of ```y``` in hand, we have our solution.\n\n\nWell, we just need to tailor the above solution to fit this problem.\n\nAgain take the case of prefix sums of ```x``` and ```y``` as above. If the subarray sum ```y - x``` is divisible by k, then ```(y - x) % k = 0```  or ```y%k = x%k```.\nThus, we can store the modulo-k of the prefix sums in a hash-map.\nIf we have the current modulo-k of prefix sum as ```z``` and ```z``` is already present in the hash-map, we have a subarray sum divisible by k.\n\nCouple of corner cases.\n1. Have the ```hashmap[0] = 1``` so that any prefix sum of 0 can match that.\n2. Handling negative numbers is a bit tricky, so we can bring them to the positive space without losing the modulo correctness with the help of the following observation -\n```(prefix_sum + n) % k``` is equivalent to ```(prefix_sum + k + (n % k)) % k```. Note, since k is positive, ```k + (n % k)``` is also positive."
                    },
                    {
                        "username": "k0biba",
                        "content": "Could someone explain, why a \"backtracking\" approach would not work or how I could modify mine, so it does? Thanks a lot! \\n\\n \\n     int res = 0;\\n    public int subarraysDivByK(int[] nums, int k) {\\n        helper(-1, nums, k, 0, new ArrayList<>());\\n        return res;\\n    }\\n\\n    void helper(int idx, int[] nums, int k, int currSum, List<Integer> curr){\\n        if(idx != -1 && currSum % k == 0){\\n            res++;\\n            System.out.println(curr.toString());\\n        }\\n        idx++;\\n        if(idx >= nums.length) return;\\n        curr.add(nums[idx]);\\n        helper(idx, nums, k, currSum + nums[idx], curr);\\n        curr = new ArrayList<>();\\n        curr.add(nums[idx]);\\n        helper(idx, nums, k, nums[idx], curr);\\n    }\\n\\n"
                    },
                    {
                        "username": "vermani",
                        "content": "Those who are using c++ and cumulative sum approach, remember that modulo operator in c++ can return negative number too but remainder should always be positive so we have to use something like follows :\\nauto remainder = (cumulativeSum%k+k)%k;"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "I thought only prefix sum (O(n^2)) would do the job. But didn\\'t.  I could never extract the accepted solution idea by myself. What a mathematical concept!!"
                    },
                    {
                        "username": "MaxKhor",
                        "content": "Last week is week of trees and now we are entering week of subarrays"
                    },
                    {
                        "username": "barnik_b",
                        "content": "Isn't this too much math for a cs interview question? I came with the solution that would involve only +ve numbers.\nAre we expected to come with a prefix sum modulo like this during an interview?\n`prefixSum = (prefixSum + num%k + k)%k;`\n\n"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using Map;\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int>mp;\\n        int rem=0;\\n        int sum=0;\\n        int ans=0;\\n        mp[rem]=1;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            rem=sum%k;\\n            if(rem<0){\\n                rem+=k;\\n            }\\n            if(mp.find(rem)!=mp.end()){\\n                ans+=mp[rem];\\n            }\\n            mp[rem]++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        # of remainders\\n        arr =nums\\n        mod =[]\\n        n = len(arr)\\n        for i in range(k + 1):\\n            mod.append(0)\\n        # Traverse original array\\n        # and compute cumulative\\n        # sum take remainder of this\\n        # current cumulative\\n        # sum and increase count by\\n        # 1 for this remainder\\n        # in mod[] array\\n        cumSum = 0\\n        for i in range(n):\\n            cumSum = cumSum + arr[i]\\n            # as the sum can be negative,\\n            # taking modulo twice\\n            mod[((cumSum % k)+k)% k]= mod[((cumSum % k)+k)% k] + 1\\n        result = 0  # Initialize result\\n        # Traverse mod[]\\n        for i in range(k):\\n            # If there are more than\\n            # one prefix subarrays\\n            # with a particular mod value.\\n            if (mod[i] > 1):\\n                result = result + (mod[i]*(mod[i]-1))//2\\n        # add the elements which\\n        # are divisible by k itself\\n        # i.e., the elements whose sum = 0\\n        result = result + mod[0]\\n        return result\\n     "
                    },
                    {
                        "username": "wpopielarski",
                        "content": "cool problem, quite like some hard. Three hints: prefix sum, modulo, and take attention on positions with same modulo values"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "There are three boundary cases for finding the postive sum and negetive.\\n// +ve - +ve (same as -ve - -ve)\\n// +ve - -ve\\n// -ve - +ve\\n"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "or you can actually making the remainder all postive"
                    }
                ]
            },
            {
                "id": 1764726,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Think of the how to solve the [subarray sum equals k](https://leetcode.com/problems/subarray-sum-equals-k/description/) problem.\n\n1. Calculate prefix sum of the array and store each prefix sum in some hash-map.\n2. prefix sum of elements ```0 to i``` is ```x``` say. And prefix sum of elements ```0 to j``` is ```y``` say, where ```j > i```. Thus subarray sum of elements ```i+1 to j``` is ```y - x```.\n3. If the  subarray sum equals ```k```, then ```y - x = k``` or ```x = y - k```. Thus if a prefix sum of ```y - k``` exists in the hash-map when we have a prefix sum of ```y``` in hand, we have our solution.\n\n\nWell, we just need to tailor the above solution to fit this problem.\n\nAgain take the case of prefix sums of ```x``` and ```y``` as above. If the subarray sum ```y - x``` is divisible by k, then ```(y - x) % k = 0```  or ```y%k = x%k```.\nThus, we can store the modulo-k of the prefix sums in a hash-map.\nIf we have the current modulo-k of prefix sum as ```z``` and ```z``` is already present in the hash-map, we have a subarray sum divisible by k.\n\nCouple of corner cases.\n1. Have the ```hashmap[0] = 1``` so that any prefix sum of 0 can match that.\n2. Handling negative numbers is a bit tricky, so we can bring them to the positive space without losing the modulo correctness with the help of the following observation -\n```(prefix_sum + n) % k``` is equivalent to ```(prefix_sum + k + (n % k)) % k```. Note, since k is positive, ```k + (n % k)``` is also positive."
                    },
                    {
                        "username": "k0biba",
                        "content": "Could someone explain, why a \"backtracking\" approach would not work or how I could modify mine, so it does? Thanks a lot! \\n\\n \\n     int res = 0;\\n    public int subarraysDivByK(int[] nums, int k) {\\n        helper(-1, nums, k, 0, new ArrayList<>());\\n        return res;\\n    }\\n\\n    void helper(int idx, int[] nums, int k, int currSum, List<Integer> curr){\\n        if(idx != -1 && currSum % k == 0){\\n            res++;\\n            System.out.println(curr.toString());\\n        }\\n        idx++;\\n        if(idx >= nums.length) return;\\n        curr.add(nums[idx]);\\n        helper(idx, nums, k, currSum + nums[idx], curr);\\n        curr = new ArrayList<>();\\n        curr.add(nums[idx]);\\n        helper(idx, nums, k, nums[idx], curr);\\n    }\\n\\n"
                    },
                    {
                        "username": "vermani",
                        "content": "Those who are using c++ and cumulative sum approach, remember that modulo operator in c++ can return negative number too but remainder should always be positive so we have to use something like follows :\\nauto remainder = (cumulativeSum%k+k)%k;"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "I thought only prefix sum (O(n^2)) would do the job. But didn\\'t.  I could never extract the accepted solution idea by myself. What a mathematical concept!!"
                    },
                    {
                        "username": "MaxKhor",
                        "content": "Last week is week of trees and now we are entering week of subarrays"
                    },
                    {
                        "username": "barnik_b",
                        "content": "Isn't this too much math for a cs interview question? I came with the solution that would involve only +ve numbers.\nAre we expected to come with a prefix sum modulo like this during an interview?\n`prefixSum = (prefixSum + num%k + k)%k;`\n\n"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using Map;\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int>mp;\\n        int rem=0;\\n        int sum=0;\\n        int ans=0;\\n        mp[rem]=1;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            rem=sum%k;\\n            if(rem<0){\\n                rem+=k;\\n            }\\n            if(mp.find(rem)!=mp.end()){\\n                ans+=mp[rem];\\n            }\\n            mp[rem]++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        # of remainders\\n        arr =nums\\n        mod =[]\\n        n = len(arr)\\n        for i in range(k + 1):\\n            mod.append(0)\\n        # Traverse original array\\n        # and compute cumulative\\n        # sum take remainder of this\\n        # current cumulative\\n        # sum and increase count by\\n        # 1 for this remainder\\n        # in mod[] array\\n        cumSum = 0\\n        for i in range(n):\\n            cumSum = cumSum + arr[i]\\n            # as the sum can be negative,\\n            # taking modulo twice\\n            mod[((cumSum % k)+k)% k]= mod[((cumSum % k)+k)% k] + 1\\n        result = 0  # Initialize result\\n        # Traverse mod[]\\n        for i in range(k):\\n            # If there are more than\\n            # one prefix subarrays\\n            # with a particular mod value.\\n            if (mod[i] > 1):\\n                result = result + (mod[i]*(mod[i]-1))//2\\n        # add the elements which\\n        # are divisible by k itself\\n        # i.e., the elements whose sum = 0\\n        result = result + mod[0]\\n        return result\\n     "
                    },
                    {
                        "username": "wpopielarski",
                        "content": "cool problem, quite like some hard. Three hints: prefix sum, modulo, and take attention on positions with same modulo values"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "There are three boundary cases for finding the postive sum and negetive.\\n// +ve - +ve (same as -ve - -ve)\\n// +ve - -ve\\n// -ve - +ve\\n"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "or you can actually making the remainder all postive"
                    }
                ]
            },
            {
                "id": 1764620,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Think of the how to solve the [subarray sum equals k](https://leetcode.com/problems/subarray-sum-equals-k/description/) problem.\n\n1. Calculate prefix sum of the array and store each prefix sum in some hash-map.\n2. prefix sum of elements ```0 to i``` is ```x``` say. And prefix sum of elements ```0 to j``` is ```y``` say, where ```j > i```. Thus subarray sum of elements ```i+1 to j``` is ```y - x```.\n3. If the  subarray sum equals ```k```, then ```y - x = k``` or ```x = y - k```. Thus if a prefix sum of ```y - k``` exists in the hash-map when we have a prefix sum of ```y``` in hand, we have our solution.\n\n\nWell, we just need to tailor the above solution to fit this problem.\n\nAgain take the case of prefix sums of ```x``` and ```y``` as above. If the subarray sum ```y - x``` is divisible by k, then ```(y - x) % k = 0```  or ```y%k = x%k```.\nThus, we can store the modulo-k of the prefix sums in a hash-map.\nIf we have the current modulo-k of prefix sum as ```z``` and ```z``` is already present in the hash-map, we have a subarray sum divisible by k.\n\nCouple of corner cases.\n1. Have the ```hashmap[0] = 1``` so that any prefix sum of 0 can match that.\n2. Handling negative numbers is a bit tricky, so we can bring them to the positive space without losing the modulo correctness with the help of the following observation -\n```(prefix_sum + n) % k``` is equivalent to ```(prefix_sum + k + (n % k)) % k```. Note, since k is positive, ```k + (n % k)``` is also positive."
                    },
                    {
                        "username": "k0biba",
                        "content": "Could someone explain, why a \"backtracking\" approach would not work or how I could modify mine, so it does? Thanks a lot! \\n\\n \\n     int res = 0;\\n    public int subarraysDivByK(int[] nums, int k) {\\n        helper(-1, nums, k, 0, new ArrayList<>());\\n        return res;\\n    }\\n\\n    void helper(int idx, int[] nums, int k, int currSum, List<Integer> curr){\\n        if(idx != -1 && currSum % k == 0){\\n            res++;\\n            System.out.println(curr.toString());\\n        }\\n        idx++;\\n        if(idx >= nums.length) return;\\n        curr.add(nums[idx]);\\n        helper(idx, nums, k, currSum + nums[idx], curr);\\n        curr = new ArrayList<>();\\n        curr.add(nums[idx]);\\n        helper(idx, nums, k, nums[idx], curr);\\n    }\\n\\n"
                    },
                    {
                        "username": "vermani",
                        "content": "Those who are using c++ and cumulative sum approach, remember that modulo operator in c++ can return negative number too but remainder should always be positive so we have to use something like follows :\\nauto remainder = (cumulativeSum%k+k)%k;"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "I thought only prefix sum (O(n^2)) would do the job. But didn\\'t.  I could never extract the accepted solution idea by myself. What a mathematical concept!!"
                    },
                    {
                        "username": "MaxKhor",
                        "content": "Last week is week of trees and now we are entering week of subarrays"
                    },
                    {
                        "username": "barnik_b",
                        "content": "Isn't this too much math for a cs interview question? I came with the solution that would involve only +ve numbers.\nAre we expected to come with a prefix sum modulo like this during an interview?\n`prefixSum = (prefixSum + num%k + k)%k;`\n\n"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using Map;\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int>mp;\\n        int rem=0;\\n        int sum=0;\\n        int ans=0;\\n        mp[rem]=1;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            rem=sum%k;\\n            if(rem<0){\\n                rem+=k;\\n            }\\n            if(mp.find(rem)!=mp.end()){\\n                ans+=mp[rem];\\n            }\\n            mp[rem]++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        # of remainders\\n        arr =nums\\n        mod =[]\\n        n = len(arr)\\n        for i in range(k + 1):\\n            mod.append(0)\\n        # Traverse original array\\n        # and compute cumulative\\n        # sum take remainder of this\\n        # current cumulative\\n        # sum and increase count by\\n        # 1 for this remainder\\n        # in mod[] array\\n        cumSum = 0\\n        for i in range(n):\\n            cumSum = cumSum + arr[i]\\n            # as the sum can be negative,\\n            # taking modulo twice\\n            mod[((cumSum % k)+k)% k]= mod[((cumSum % k)+k)% k] + 1\\n        result = 0  # Initialize result\\n        # Traverse mod[]\\n        for i in range(k):\\n            # If there are more than\\n            # one prefix subarrays\\n            # with a particular mod value.\\n            if (mod[i] > 1):\\n                result = result + (mod[i]*(mod[i]-1))//2\\n        # add the elements which\\n        # are divisible by k itself\\n        # i.e., the elements whose sum = 0\\n        result = result + mod[0]\\n        return result\\n     "
                    },
                    {
                        "username": "wpopielarski",
                        "content": "cool problem, quite like some hard. Three hints: prefix sum, modulo, and take attention on positions with same modulo values"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "There are three boundary cases for finding the postive sum and negetive.\\n// +ve - +ve (same as -ve - -ve)\\n// +ve - -ve\\n// -ve - +ve\\n"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "or you can actually making the remainder all postive"
                    }
                ]
            },
            {
                "id": 1764585,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Think of the how to solve the [subarray sum equals k](https://leetcode.com/problems/subarray-sum-equals-k/description/) problem.\n\n1. Calculate prefix sum of the array and store each prefix sum in some hash-map.\n2. prefix sum of elements ```0 to i``` is ```x``` say. And prefix sum of elements ```0 to j``` is ```y``` say, where ```j > i```. Thus subarray sum of elements ```i+1 to j``` is ```y - x```.\n3. If the  subarray sum equals ```k```, then ```y - x = k``` or ```x = y - k```. Thus if a prefix sum of ```y - k``` exists in the hash-map when we have a prefix sum of ```y``` in hand, we have our solution.\n\n\nWell, we just need to tailor the above solution to fit this problem.\n\nAgain take the case of prefix sums of ```x``` and ```y``` as above. If the subarray sum ```y - x``` is divisible by k, then ```(y - x) % k = 0```  or ```y%k = x%k```.\nThus, we can store the modulo-k of the prefix sums in a hash-map.\nIf we have the current modulo-k of prefix sum as ```z``` and ```z``` is already present in the hash-map, we have a subarray sum divisible by k.\n\nCouple of corner cases.\n1. Have the ```hashmap[0] = 1``` so that any prefix sum of 0 can match that.\n2. Handling negative numbers is a bit tricky, so we can bring them to the positive space without losing the modulo correctness with the help of the following observation -\n```(prefix_sum + n) % k``` is equivalent to ```(prefix_sum + k + (n % k)) % k```. Note, since k is positive, ```k + (n % k)``` is also positive."
                    },
                    {
                        "username": "k0biba",
                        "content": "Could someone explain, why a \"backtracking\" approach would not work or how I could modify mine, so it does? Thanks a lot! \\n\\n \\n     int res = 0;\\n    public int subarraysDivByK(int[] nums, int k) {\\n        helper(-1, nums, k, 0, new ArrayList<>());\\n        return res;\\n    }\\n\\n    void helper(int idx, int[] nums, int k, int currSum, List<Integer> curr){\\n        if(idx != -1 && currSum % k == 0){\\n            res++;\\n            System.out.println(curr.toString());\\n        }\\n        idx++;\\n        if(idx >= nums.length) return;\\n        curr.add(nums[idx]);\\n        helper(idx, nums, k, currSum + nums[idx], curr);\\n        curr = new ArrayList<>();\\n        curr.add(nums[idx]);\\n        helper(idx, nums, k, nums[idx], curr);\\n    }\\n\\n"
                    },
                    {
                        "username": "vermani",
                        "content": "Those who are using c++ and cumulative sum approach, remember that modulo operator in c++ can return negative number too but remainder should always be positive so we have to use something like follows :\\nauto remainder = (cumulativeSum%k+k)%k;"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "I thought only prefix sum (O(n^2)) would do the job. But didn\\'t.  I could never extract the accepted solution idea by myself. What a mathematical concept!!"
                    },
                    {
                        "username": "MaxKhor",
                        "content": "Last week is week of trees and now we are entering week of subarrays"
                    },
                    {
                        "username": "barnik_b",
                        "content": "Isn't this too much math for a cs interview question? I came with the solution that would involve only +ve numbers.\nAre we expected to come with a prefix sum modulo like this during an interview?\n`prefixSum = (prefixSum + num%k + k)%k;`\n\n"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using Map;\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int>mp;\\n        int rem=0;\\n        int sum=0;\\n        int ans=0;\\n        mp[rem]=1;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            rem=sum%k;\\n            if(rem<0){\\n                rem+=k;\\n            }\\n            if(mp.find(rem)!=mp.end()){\\n                ans+=mp[rem];\\n            }\\n            mp[rem]++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        # of remainders\\n        arr =nums\\n        mod =[]\\n        n = len(arr)\\n        for i in range(k + 1):\\n            mod.append(0)\\n        # Traverse original array\\n        # and compute cumulative\\n        # sum take remainder of this\\n        # current cumulative\\n        # sum and increase count by\\n        # 1 for this remainder\\n        # in mod[] array\\n        cumSum = 0\\n        for i in range(n):\\n            cumSum = cumSum + arr[i]\\n            # as the sum can be negative,\\n            # taking modulo twice\\n            mod[((cumSum % k)+k)% k]= mod[((cumSum % k)+k)% k] + 1\\n        result = 0  # Initialize result\\n        # Traverse mod[]\\n        for i in range(k):\\n            # If there are more than\\n            # one prefix subarrays\\n            # with a particular mod value.\\n            if (mod[i] > 1):\\n                result = result + (mod[i]*(mod[i]-1))//2\\n        # add the elements which\\n        # are divisible by k itself\\n        # i.e., the elements whose sum = 0\\n        result = result + mod[0]\\n        return result\\n     "
                    },
                    {
                        "username": "wpopielarski",
                        "content": "cool problem, quite like some hard. Three hints: prefix sum, modulo, and take attention on positions with same modulo values"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "There are three boundary cases for finding the postive sum and negetive.\\n// +ve - +ve (same as -ve - -ve)\\n// +ve - -ve\\n// -ve - +ve\\n"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "or you can actually making the remainder all postive"
                    }
                ]
            },
            {
                "id": 1764567,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Think of the how to solve the [subarray sum equals k](https://leetcode.com/problems/subarray-sum-equals-k/description/) problem.\n\n1. Calculate prefix sum of the array and store each prefix sum in some hash-map.\n2. prefix sum of elements ```0 to i``` is ```x``` say. And prefix sum of elements ```0 to j``` is ```y``` say, where ```j > i```. Thus subarray sum of elements ```i+1 to j``` is ```y - x```.\n3. If the  subarray sum equals ```k```, then ```y - x = k``` or ```x = y - k```. Thus if a prefix sum of ```y - k``` exists in the hash-map when we have a prefix sum of ```y``` in hand, we have our solution.\n\n\nWell, we just need to tailor the above solution to fit this problem.\n\nAgain take the case of prefix sums of ```x``` and ```y``` as above. If the subarray sum ```y - x``` is divisible by k, then ```(y - x) % k = 0```  or ```y%k = x%k```.\nThus, we can store the modulo-k of the prefix sums in a hash-map.\nIf we have the current modulo-k of prefix sum as ```z``` and ```z``` is already present in the hash-map, we have a subarray sum divisible by k.\n\nCouple of corner cases.\n1. Have the ```hashmap[0] = 1``` so that any prefix sum of 0 can match that.\n2. Handling negative numbers is a bit tricky, so we can bring them to the positive space without losing the modulo correctness with the help of the following observation -\n```(prefix_sum + n) % k``` is equivalent to ```(prefix_sum + k + (n % k)) % k```. Note, since k is positive, ```k + (n % k)``` is also positive."
                    },
                    {
                        "username": "k0biba",
                        "content": "Could someone explain, why a \"backtracking\" approach would not work or how I could modify mine, so it does? Thanks a lot! \\n\\n \\n     int res = 0;\\n    public int subarraysDivByK(int[] nums, int k) {\\n        helper(-1, nums, k, 0, new ArrayList<>());\\n        return res;\\n    }\\n\\n    void helper(int idx, int[] nums, int k, int currSum, List<Integer> curr){\\n        if(idx != -1 && currSum % k == 0){\\n            res++;\\n            System.out.println(curr.toString());\\n        }\\n        idx++;\\n        if(idx >= nums.length) return;\\n        curr.add(nums[idx]);\\n        helper(idx, nums, k, currSum + nums[idx], curr);\\n        curr = new ArrayList<>();\\n        curr.add(nums[idx]);\\n        helper(idx, nums, k, nums[idx], curr);\\n    }\\n\\n"
                    },
                    {
                        "username": "vermani",
                        "content": "Those who are using c++ and cumulative sum approach, remember that modulo operator in c++ can return negative number too but remainder should always be positive so we have to use something like follows :\\nauto remainder = (cumulativeSum%k+k)%k;"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "I thought only prefix sum (O(n^2)) would do the job. But didn\\'t.  I could never extract the accepted solution idea by myself. What a mathematical concept!!"
                    },
                    {
                        "username": "MaxKhor",
                        "content": "Last week is week of trees and now we are entering week of subarrays"
                    },
                    {
                        "username": "barnik_b",
                        "content": "Isn't this too much math for a cs interview question? I came with the solution that would involve only +ve numbers.\nAre we expected to come with a prefix sum modulo like this during an interview?\n`prefixSum = (prefixSum + num%k + k)%k;`\n\n"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using Map;\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int>mp;\\n        int rem=0;\\n        int sum=0;\\n        int ans=0;\\n        mp[rem]=1;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            rem=sum%k;\\n            if(rem<0){\\n                rem+=k;\\n            }\\n            if(mp.find(rem)!=mp.end()){\\n                ans+=mp[rem];\\n            }\\n            mp[rem]++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        # of remainders\\n        arr =nums\\n        mod =[]\\n        n = len(arr)\\n        for i in range(k + 1):\\n            mod.append(0)\\n        # Traverse original array\\n        # and compute cumulative\\n        # sum take remainder of this\\n        # current cumulative\\n        # sum and increase count by\\n        # 1 for this remainder\\n        # in mod[] array\\n        cumSum = 0\\n        for i in range(n):\\n            cumSum = cumSum + arr[i]\\n            # as the sum can be negative,\\n            # taking modulo twice\\n            mod[((cumSum % k)+k)% k]= mod[((cumSum % k)+k)% k] + 1\\n        result = 0  # Initialize result\\n        # Traverse mod[]\\n        for i in range(k):\\n            # If there are more than\\n            # one prefix subarrays\\n            # with a particular mod value.\\n            if (mod[i] > 1):\\n                result = result + (mod[i]*(mod[i]-1))//2\\n        # add the elements which\\n        # are divisible by k itself\\n        # i.e., the elements whose sum = 0\\n        result = result + mod[0]\\n        return result\\n     "
                    },
                    {
                        "username": "wpopielarski",
                        "content": "cool problem, quite like some hard. Three hints: prefix sum, modulo, and take attention on positions with same modulo values"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "There are three boundary cases for finding the postive sum and negetive.\\n// +ve - +ve (same as -ve - -ve)\\n// +ve - -ve\\n// -ve - +ve\\n"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "or you can actually making the remainder all postive"
                    }
                ]
            },
            {
                "id": 1764541,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Think of the how to solve the [subarray sum equals k](https://leetcode.com/problems/subarray-sum-equals-k/description/) problem.\n\n1. Calculate prefix sum of the array and store each prefix sum in some hash-map.\n2. prefix sum of elements ```0 to i``` is ```x``` say. And prefix sum of elements ```0 to j``` is ```y``` say, where ```j > i```. Thus subarray sum of elements ```i+1 to j``` is ```y - x```.\n3. If the  subarray sum equals ```k```, then ```y - x = k``` or ```x = y - k```. Thus if a prefix sum of ```y - k``` exists in the hash-map when we have a prefix sum of ```y``` in hand, we have our solution.\n\n\nWell, we just need to tailor the above solution to fit this problem.\n\nAgain take the case of prefix sums of ```x``` and ```y``` as above. If the subarray sum ```y - x``` is divisible by k, then ```(y - x) % k = 0```  or ```y%k = x%k```.\nThus, we can store the modulo-k of the prefix sums in a hash-map.\nIf we have the current modulo-k of prefix sum as ```z``` and ```z``` is already present in the hash-map, we have a subarray sum divisible by k.\n\nCouple of corner cases.\n1. Have the ```hashmap[0] = 1``` so that any prefix sum of 0 can match that.\n2. Handling negative numbers is a bit tricky, so we can bring them to the positive space without losing the modulo correctness with the help of the following observation -\n```(prefix_sum + n) % k``` is equivalent to ```(prefix_sum + k + (n % k)) % k```. Note, since k is positive, ```k + (n % k)``` is also positive."
                    },
                    {
                        "username": "k0biba",
                        "content": "Could someone explain, why a \"backtracking\" approach would not work or how I could modify mine, so it does? Thanks a lot! \\n\\n \\n     int res = 0;\\n    public int subarraysDivByK(int[] nums, int k) {\\n        helper(-1, nums, k, 0, new ArrayList<>());\\n        return res;\\n    }\\n\\n    void helper(int idx, int[] nums, int k, int currSum, List<Integer> curr){\\n        if(idx != -1 && currSum % k == 0){\\n            res++;\\n            System.out.println(curr.toString());\\n        }\\n        idx++;\\n        if(idx >= nums.length) return;\\n        curr.add(nums[idx]);\\n        helper(idx, nums, k, currSum + nums[idx], curr);\\n        curr = new ArrayList<>();\\n        curr.add(nums[idx]);\\n        helper(idx, nums, k, nums[idx], curr);\\n    }\\n\\n"
                    },
                    {
                        "username": "vermani",
                        "content": "Those who are using c++ and cumulative sum approach, remember that modulo operator in c++ can return negative number too but remainder should always be positive so we have to use something like follows :\\nauto remainder = (cumulativeSum%k+k)%k;"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "I thought only prefix sum (O(n^2)) would do the job. But didn\\'t.  I could never extract the accepted solution idea by myself. What a mathematical concept!!"
                    },
                    {
                        "username": "MaxKhor",
                        "content": "Last week is week of trees and now we are entering week of subarrays"
                    },
                    {
                        "username": "barnik_b",
                        "content": "Isn't this too much math for a cs interview question? I came with the solution that would involve only +ve numbers.\nAre we expected to come with a prefix sum modulo like this during an interview?\n`prefixSum = (prefixSum + num%k + k)%k;`\n\n"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using Map;\\n    int subarraysDivByK(vector<int>& nums, int k) {\\n        unordered_map<int,int>mp;\\n        int rem=0;\\n        int sum=0;\\n        int ans=0;\\n        mp[rem]=1;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            rem=sum%k;\\n            if(rem<0){\\n                rem+=k;\\n            }\\n            if(mp.find(rem)!=mp.end()){\\n                ans+=mp[rem];\\n            }\\n            mp[rem]++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        # of remainders\\n        arr =nums\\n        mod =[]\\n        n = len(arr)\\n        for i in range(k + 1):\\n            mod.append(0)\\n        # Traverse original array\\n        # and compute cumulative\\n        # sum take remainder of this\\n        # current cumulative\\n        # sum and increase count by\\n        # 1 for this remainder\\n        # in mod[] array\\n        cumSum = 0\\n        for i in range(n):\\n            cumSum = cumSum + arr[i]\\n            # as the sum can be negative,\\n            # taking modulo twice\\n            mod[((cumSum % k)+k)% k]= mod[((cumSum % k)+k)% k] + 1\\n        result = 0  # Initialize result\\n        # Traverse mod[]\\n        for i in range(k):\\n            # If there are more than\\n            # one prefix subarrays\\n            # with a particular mod value.\\n            if (mod[i] > 1):\\n                result = result + (mod[i]*(mod[i]-1))//2\\n        # add the elements which\\n        # are divisible by k itself\\n        # i.e., the elements whose sum = 0\\n        result = result + mod[0]\\n        return result\\n     "
                    },
                    {
                        "username": "wpopielarski",
                        "content": "cool problem, quite like some hard. Three hints: prefix sum, modulo, and take attention on positions with same modulo values"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "There are three boundary cases for finding the postive sum and negetive.\\n// +ve - +ve (same as -ve - -ve)\\n// +ve - -ve\\n// -ve - +ve\\n"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "or you can actually making the remainder all postive"
                    }
                ]
            },
            {
                "id": 1764504,
                "content": [
                    {
                        "username": "Unbeknownstguy",
                        "content": "`(prefixMod + num % k + k) % k;`\\ncan anyone explain what does this code mean? Sorry if it sounds like a noob. \\nThanks."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "make sure the remainder are postive i guess"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "sum%k gives the remainder say \\'r\\'. It means if \\'r\\' is subtracted from sum, then sum will be divisible by k.\\nHence we try to find \\'r\\' in the map:\\nif \\'r\\' exist, it means that if we subtract that \\'r\\' or say that subarray from start(as we are using prefixSum), then our current sum will be divisible by k.  "
                    },
                    {
                        "username": "maktinho",
                        "content": "There should be a hint for this problem. O(N^2) solution get TLE at case 67 or 68 and people has no idea what should be done. Only a trick is missing and there is no reason to have a complete solution."
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Complicated math ya? Made it simple: https://youtu.be/fWCsT9nkTnM"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "nums = [0,-5]\\nwhy is the output of the above testcase 1 it should be 0 right \\nsomeone please explain."
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "[@Rishu_Raj_Anand](/Rishu_Raj_Anand)  Yep, right"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@abhinavshukla693](/abhinavshukla693) It doesn\\'t matter what\\'s the \\'k\\' value, 0 will be divisible by all number. "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "because 0 is divisible by any number \\n"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "Could you provide the value of k ?\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "I got the real challenge with negative prefix sum, couldn\\'t think of adding \\'k\\' to it. I was doing wrong by taking modulus of -ve prefix sum before storing in hashmap.\\nSo, if sum%k<0, add \\'k\\' to sum%k before storing in hashMap, it took time to visualize things even after knowing the process. \\n "
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Why Prefix Sum?\\nNeed to calculate sum of every subarray to check sum is divisible by k.\\n# How Prefix Sum?\\nTo check divisibility I need modulo operator.\\nThe range of remainder is from `0,k-1`.\\nFind remainder of sum. Preserve the count of remainder.\\nNow the `prefix sum % k will take us to same remainder again, when the sum is divisible by k`.\\nEdge case : `frequency of remainder 0 starts with 1` to handle contiguous subarray formation.\\n\\nDon\\'t jump to solution directly : [solution](https://leetcode.com/problems/subarray-sums-divisible-by-k/solutions/3070781/on-easy-java-solution/)\\n"
                    },
                    {
                        "username": "GeekErra",
                        "content": "Click this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "<h3>My Intuition for this problem is:</h3>\\n<ul>\\n<li> If two numbers are divisible by k then their sum must also be divisible by k. </ul>\\n</ul>\\n<ul>\\n<li> Now this brings me to think about prefix sum but I couldn\\'t figure out how would I implement it in O(n) time? </li>\\n</ul>"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "[@ngducanh1611](/ngducanh1611)  He mentioned that if the numbers are themselves divisible by k then their sum should also be divisible by k. "
                    },
                    {
                        "username": "cse_shivam98",
                        "content": "try to think in kadane\\'s algo perspective\\n"
                    },
                    {
                        "username": "ngducanh1611",
                        "content": "This theory is still not enough, if two numbers are NOT divisible by k, their sum may still be divisible by k. Ex: 2 and 3 are not divisible by 5 but, (2+3) = 5 is divisible"
                    },
                    {
                        "username": "medmoe",
                        "content": "the only solution that i can think about is nested loops with O(n(n+1)/2)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Hint:\\n\\nIn the worst case, there are O(n^2) subarrays that is divisible by k (e.g. [0,0,0...,0])\\nA solution based on counting the subarray one by one will not work.\\nHow can you count the subarrays (which is essentially a pair of indices that shares an interesting property) without going through them one by one."
                    }
                ]
            },
            {
                "id": 1764488,
                "content": [
                    {
                        "username": "Unbeknownstguy",
                        "content": "`(prefixMod + num % k + k) % k;`\\ncan anyone explain what does this code mean? Sorry if it sounds like a noob. \\nThanks."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "make sure the remainder are postive i guess"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "sum%k gives the remainder say \\'r\\'. It means if \\'r\\' is subtracted from sum, then sum will be divisible by k.\\nHence we try to find \\'r\\' in the map:\\nif \\'r\\' exist, it means that if we subtract that \\'r\\' or say that subarray from start(as we are using prefixSum), then our current sum will be divisible by k.  "
                    },
                    {
                        "username": "maktinho",
                        "content": "There should be a hint for this problem. O(N^2) solution get TLE at case 67 or 68 and people has no idea what should be done. Only a trick is missing and there is no reason to have a complete solution."
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Complicated math ya? Made it simple: https://youtu.be/fWCsT9nkTnM"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "nums = [0,-5]\\nwhy is the output of the above testcase 1 it should be 0 right \\nsomeone please explain."
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "[@Rishu_Raj_Anand](/Rishu_Raj_Anand)  Yep, right"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@abhinavshukla693](/abhinavshukla693) It doesn\\'t matter what\\'s the \\'k\\' value, 0 will be divisible by all number. "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "because 0 is divisible by any number \\n"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "Could you provide the value of k ?\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "I got the real challenge with negative prefix sum, couldn\\'t think of adding \\'k\\' to it. I was doing wrong by taking modulus of -ve prefix sum before storing in hashmap.\\nSo, if sum%k<0, add \\'k\\' to sum%k before storing in hashMap, it took time to visualize things even after knowing the process. \\n "
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Why Prefix Sum?\\nNeed to calculate sum of every subarray to check sum is divisible by k.\\n# How Prefix Sum?\\nTo check divisibility I need modulo operator.\\nThe range of remainder is from `0,k-1`.\\nFind remainder of sum. Preserve the count of remainder.\\nNow the `prefix sum % k will take us to same remainder again, when the sum is divisible by k`.\\nEdge case : `frequency of remainder 0 starts with 1` to handle contiguous subarray formation.\\n\\nDon\\'t jump to solution directly : [solution](https://leetcode.com/problems/subarray-sums-divisible-by-k/solutions/3070781/on-easy-java-solution/)\\n"
                    },
                    {
                        "username": "GeekErra",
                        "content": "Click this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "<h3>My Intuition for this problem is:</h3>\\n<ul>\\n<li> If two numbers are divisible by k then their sum must also be divisible by k. </ul>\\n</ul>\\n<ul>\\n<li> Now this brings me to think about prefix sum but I couldn\\'t figure out how would I implement it in O(n) time? </li>\\n</ul>"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "[@ngducanh1611](/ngducanh1611)  He mentioned that if the numbers are themselves divisible by k then their sum should also be divisible by k. "
                    },
                    {
                        "username": "cse_shivam98",
                        "content": "try to think in kadane\\'s algo perspective\\n"
                    },
                    {
                        "username": "ngducanh1611",
                        "content": "This theory is still not enough, if two numbers are NOT divisible by k, their sum may still be divisible by k. Ex: 2 and 3 are not divisible by 5 but, (2+3) = 5 is divisible"
                    },
                    {
                        "username": "medmoe",
                        "content": "the only solution that i can think about is nested loops with O(n(n+1)/2)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Hint:\\n\\nIn the worst case, there are O(n^2) subarrays that is divisible by k (e.g. [0,0,0...,0])\\nA solution based on counting the subarray one by one will not work.\\nHow can you count the subarrays (which is essentially a pair of indices that shares an interesting property) without going through them one by one."
                    }
                ]
            },
            {
                "id": 1764463,
                "content": [
                    {
                        "username": "Unbeknownstguy",
                        "content": "`(prefixMod + num % k + k) % k;`\\ncan anyone explain what does this code mean? Sorry if it sounds like a noob. \\nThanks."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "make sure the remainder are postive i guess"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "sum%k gives the remainder say \\'r\\'. It means if \\'r\\' is subtracted from sum, then sum will be divisible by k.\\nHence we try to find \\'r\\' in the map:\\nif \\'r\\' exist, it means that if we subtract that \\'r\\' or say that subarray from start(as we are using prefixSum), then our current sum will be divisible by k.  "
                    },
                    {
                        "username": "maktinho",
                        "content": "There should be a hint for this problem. O(N^2) solution get TLE at case 67 or 68 and people has no idea what should be done. Only a trick is missing and there is no reason to have a complete solution."
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Complicated math ya? Made it simple: https://youtu.be/fWCsT9nkTnM"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "nums = [0,-5]\\nwhy is the output of the above testcase 1 it should be 0 right \\nsomeone please explain."
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "[@Rishu_Raj_Anand](/Rishu_Raj_Anand)  Yep, right"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@abhinavshukla693](/abhinavshukla693) It doesn\\'t matter what\\'s the \\'k\\' value, 0 will be divisible by all number. "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "because 0 is divisible by any number \\n"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "Could you provide the value of k ?\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "I got the real challenge with negative prefix sum, couldn\\'t think of adding \\'k\\' to it. I was doing wrong by taking modulus of -ve prefix sum before storing in hashmap.\\nSo, if sum%k<0, add \\'k\\' to sum%k before storing in hashMap, it took time to visualize things even after knowing the process. \\n "
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Why Prefix Sum?\\nNeed to calculate sum of every subarray to check sum is divisible by k.\\n# How Prefix Sum?\\nTo check divisibility I need modulo operator.\\nThe range of remainder is from `0,k-1`.\\nFind remainder of sum. Preserve the count of remainder.\\nNow the `prefix sum % k will take us to same remainder again, when the sum is divisible by k`.\\nEdge case : `frequency of remainder 0 starts with 1` to handle contiguous subarray formation.\\n\\nDon\\'t jump to solution directly : [solution](https://leetcode.com/problems/subarray-sums-divisible-by-k/solutions/3070781/on-easy-java-solution/)\\n"
                    },
                    {
                        "username": "GeekErra",
                        "content": "Click this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "<h3>My Intuition for this problem is:</h3>\\n<ul>\\n<li> If two numbers are divisible by k then their sum must also be divisible by k. </ul>\\n</ul>\\n<ul>\\n<li> Now this brings me to think about prefix sum but I couldn\\'t figure out how would I implement it in O(n) time? </li>\\n</ul>"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "[@ngducanh1611](/ngducanh1611)  He mentioned that if the numbers are themselves divisible by k then their sum should also be divisible by k. "
                    },
                    {
                        "username": "cse_shivam98",
                        "content": "try to think in kadane\\'s algo perspective\\n"
                    },
                    {
                        "username": "ngducanh1611",
                        "content": "This theory is still not enough, if two numbers are NOT divisible by k, their sum may still be divisible by k. Ex: 2 and 3 are not divisible by 5 but, (2+3) = 5 is divisible"
                    },
                    {
                        "username": "medmoe",
                        "content": "the only solution that i can think about is nested loops with O(n(n+1)/2)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Hint:\\n\\nIn the worst case, there are O(n^2) subarrays that is divisible by k (e.g. [0,0,0...,0])\\nA solution based on counting the subarray one by one will not work.\\nHow can you count the subarrays (which is essentially a pair of indices that shares an interesting property) without going through them one by one."
                    }
                ]
            },
            {
                "id": 1764407,
                "content": [
                    {
                        "username": "Unbeknownstguy",
                        "content": "`(prefixMod + num % k + k) % k;`\\ncan anyone explain what does this code mean? Sorry if it sounds like a noob. \\nThanks."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "make sure the remainder are postive i guess"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "sum%k gives the remainder say \\'r\\'. It means if \\'r\\' is subtracted from sum, then sum will be divisible by k.\\nHence we try to find \\'r\\' in the map:\\nif \\'r\\' exist, it means that if we subtract that \\'r\\' or say that subarray from start(as we are using prefixSum), then our current sum will be divisible by k.  "
                    },
                    {
                        "username": "maktinho",
                        "content": "There should be a hint for this problem. O(N^2) solution get TLE at case 67 or 68 and people has no idea what should be done. Only a trick is missing and there is no reason to have a complete solution."
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Complicated math ya? Made it simple: https://youtu.be/fWCsT9nkTnM"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "nums = [0,-5]\\nwhy is the output of the above testcase 1 it should be 0 right \\nsomeone please explain."
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "[@Rishu_Raj_Anand](/Rishu_Raj_Anand)  Yep, right"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@abhinavshukla693](/abhinavshukla693) It doesn\\'t matter what\\'s the \\'k\\' value, 0 will be divisible by all number. "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "because 0 is divisible by any number \\n"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "Could you provide the value of k ?\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "I got the real challenge with negative prefix sum, couldn\\'t think of adding \\'k\\' to it. I was doing wrong by taking modulus of -ve prefix sum before storing in hashmap.\\nSo, if sum%k<0, add \\'k\\' to sum%k before storing in hashMap, it took time to visualize things even after knowing the process. \\n "
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Why Prefix Sum?\\nNeed to calculate sum of every subarray to check sum is divisible by k.\\n# How Prefix Sum?\\nTo check divisibility I need modulo operator.\\nThe range of remainder is from `0,k-1`.\\nFind remainder of sum. Preserve the count of remainder.\\nNow the `prefix sum % k will take us to same remainder again, when the sum is divisible by k`.\\nEdge case : `frequency of remainder 0 starts with 1` to handle contiguous subarray formation.\\n\\nDon\\'t jump to solution directly : [solution](https://leetcode.com/problems/subarray-sums-divisible-by-k/solutions/3070781/on-easy-java-solution/)\\n"
                    },
                    {
                        "username": "GeekErra",
                        "content": "Click this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "<h3>My Intuition for this problem is:</h3>\\n<ul>\\n<li> If two numbers are divisible by k then their sum must also be divisible by k. </ul>\\n</ul>\\n<ul>\\n<li> Now this brings me to think about prefix sum but I couldn\\'t figure out how would I implement it in O(n) time? </li>\\n</ul>"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "[@ngducanh1611](/ngducanh1611)  He mentioned that if the numbers are themselves divisible by k then their sum should also be divisible by k. "
                    },
                    {
                        "username": "cse_shivam98",
                        "content": "try to think in kadane\\'s algo perspective\\n"
                    },
                    {
                        "username": "ngducanh1611",
                        "content": "This theory is still not enough, if two numbers are NOT divisible by k, their sum may still be divisible by k. Ex: 2 and 3 are not divisible by 5 but, (2+3) = 5 is divisible"
                    },
                    {
                        "username": "medmoe",
                        "content": "the only solution that i can think about is nested loops with O(n(n+1)/2)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Hint:\\n\\nIn the worst case, there are O(n^2) subarrays that is divisible by k (e.g. [0,0,0...,0])\\nA solution based on counting the subarray one by one will not work.\\nHow can you count the subarrays (which is essentially a pair of indices that shares an interesting property) without going through them one by one."
                    }
                ]
            },
            {
                "id": 1764379,
                "content": [
                    {
                        "username": "Unbeknownstguy",
                        "content": "`(prefixMod + num % k + k) % k;`\\ncan anyone explain what does this code mean? Sorry if it sounds like a noob. \\nThanks."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "make sure the remainder are postive i guess"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "sum%k gives the remainder say \\'r\\'. It means if \\'r\\' is subtracted from sum, then sum will be divisible by k.\\nHence we try to find \\'r\\' in the map:\\nif \\'r\\' exist, it means that if we subtract that \\'r\\' or say that subarray from start(as we are using prefixSum), then our current sum will be divisible by k.  "
                    },
                    {
                        "username": "maktinho",
                        "content": "There should be a hint for this problem. O(N^2) solution get TLE at case 67 or 68 and people has no idea what should be done. Only a trick is missing and there is no reason to have a complete solution."
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Complicated math ya? Made it simple: https://youtu.be/fWCsT9nkTnM"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "nums = [0,-5]\\nwhy is the output of the above testcase 1 it should be 0 right \\nsomeone please explain."
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "[@Rishu_Raj_Anand](/Rishu_Raj_Anand)  Yep, right"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@abhinavshukla693](/abhinavshukla693) It doesn\\'t matter what\\'s the \\'k\\' value, 0 will be divisible by all number. "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "because 0 is divisible by any number \\n"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "Could you provide the value of k ?\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "I got the real challenge with negative prefix sum, couldn\\'t think of adding \\'k\\' to it. I was doing wrong by taking modulus of -ve prefix sum before storing in hashmap.\\nSo, if sum%k<0, add \\'k\\' to sum%k before storing in hashMap, it took time to visualize things even after knowing the process. \\n "
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Why Prefix Sum?\\nNeed to calculate sum of every subarray to check sum is divisible by k.\\n# How Prefix Sum?\\nTo check divisibility I need modulo operator.\\nThe range of remainder is from `0,k-1`.\\nFind remainder of sum. Preserve the count of remainder.\\nNow the `prefix sum % k will take us to same remainder again, when the sum is divisible by k`.\\nEdge case : `frequency of remainder 0 starts with 1` to handle contiguous subarray formation.\\n\\nDon\\'t jump to solution directly : [solution](https://leetcode.com/problems/subarray-sums-divisible-by-k/solutions/3070781/on-easy-java-solution/)\\n"
                    },
                    {
                        "username": "GeekErra",
                        "content": "Click this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "<h3>My Intuition for this problem is:</h3>\\n<ul>\\n<li> If two numbers are divisible by k then their sum must also be divisible by k. </ul>\\n</ul>\\n<ul>\\n<li> Now this brings me to think about prefix sum but I couldn\\'t figure out how would I implement it in O(n) time? </li>\\n</ul>"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "[@ngducanh1611](/ngducanh1611)  He mentioned that if the numbers are themselves divisible by k then their sum should also be divisible by k. "
                    },
                    {
                        "username": "cse_shivam98",
                        "content": "try to think in kadane\\'s algo perspective\\n"
                    },
                    {
                        "username": "ngducanh1611",
                        "content": "This theory is still not enough, if two numbers are NOT divisible by k, their sum may still be divisible by k. Ex: 2 and 3 are not divisible by 5 but, (2+3) = 5 is divisible"
                    },
                    {
                        "username": "medmoe",
                        "content": "the only solution that i can think about is nested loops with O(n(n+1)/2)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Hint:\\n\\nIn the worst case, there are O(n^2) subarrays that is divisible by k (e.g. [0,0,0...,0])\\nA solution based on counting the subarray one by one will not work.\\nHow can you count the subarrays (which is essentially a pair of indices that shares an interesting property) without going through them one by one."
                    }
                ]
            },
            {
                "id": 1764366,
                "content": [
                    {
                        "username": "Unbeknownstguy",
                        "content": "`(prefixMod + num % k + k) % k;`\\ncan anyone explain what does this code mean? Sorry if it sounds like a noob. \\nThanks."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "make sure the remainder are postive i guess"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "sum%k gives the remainder say \\'r\\'. It means if \\'r\\' is subtracted from sum, then sum will be divisible by k.\\nHence we try to find \\'r\\' in the map:\\nif \\'r\\' exist, it means that if we subtract that \\'r\\' or say that subarray from start(as we are using prefixSum), then our current sum will be divisible by k.  "
                    },
                    {
                        "username": "maktinho",
                        "content": "There should be a hint for this problem. O(N^2) solution get TLE at case 67 or 68 and people has no idea what should be done. Only a trick is missing and there is no reason to have a complete solution."
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Complicated math ya? Made it simple: https://youtu.be/fWCsT9nkTnM"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "nums = [0,-5]\\nwhy is the output of the above testcase 1 it should be 0 right \\nsomeone please explain."
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "[@Rishu_Raj_Anand](/Rishu_Raj_Anand)  Yep, right"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@abhinavshukla693](/abhinavshukla693) It doesn\\'t matter what\\'s the \\'k\\' value, 0 will be divisible by all number. "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "because 0 is divisible by any number \\n"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "Could you provide the value of k ?\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "I got the real challenge with negative prefix sum, couldn\\'t think of adding \\'k\\' to it. I was doing wrong by taking modulus of -ve prefix sum before storing in hashmap.\\nSo, if sum%k<0, add \\'k\\' to sum%k before storing in hashMap, it took time to visualize things even after knowing the process. \\n "
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Why Prefix Sum?\\nNeed to calculate sum of every subarray to check sum is divisible by k.\\n# How Prefix Sum?\\nTo check divisibility I need modulo operator.\\nThe range of remainder is from `0,k-1`.\\nFind remainder of sum. Preserve the count of remainder.\\nNow the `prefix sum % k will take us to same remainder again, when the sum is divisible by k`.\\nEdge case : `frequency of remainder 0 starts with 1` to handle contiguous subarray formation.\\n\\nDon\\'t jump to solution directly : [solution](https://leetcode.com/problems/subarray-sums-divisible-by-k/solutions/3070781/on-easy-java-solution/)\\n"
                    },
                    {
                        "username": "GeekErra",
                        "content": "Click this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "<h3>My Intuition for this problem is:</h3>\\n<ul>\\n<li> If two numbers are divisible by k then their sum must also be divisible by k. </ul>\\n</ul>\\n<ul>\\n<li> Now this brings me to think about prefix sum but I couldn\\'t figure out how would I implement it in O(n) time? </li>\\n</ul>"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "[@ngducanh1611](/ngducanh1611)  He mentioned that if the numbers are themselves divisible by k then their sum should also be divisible by k. "
                    },
                    {
                        "username": "cse_shivam98",
                        "content": "try to think in kadane\\'s algo perspective\\n"
                    },
                    {
                        "username": "ngducanh1611",
                        "content": "This theory is still not enough, if two numbers are NOT divisible by k, their sum may still be divisible by k. Ex: 2 and 3 are not divisible by 5 but, (2+3) = 5 is divisible"
                    },
                    {
                        "username": "medmoe",
                        "content": "the only solution that i can think about is nested loops with O(n(n+1)/2)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Hint:\\n\\nIn the worst case, there are O(n^2) subarrays that is divisible by k (e.g. [0,0,0...,0])\\nA solution based on counting the subarray one by one will not work.\\nHow can you count the subarrays (which is essentially a pair of indices that shares an interesting property) without going through them one by one."
                    }
                ]
            },
            {
                "id": 1764265,
                "content": [
                    {
                        "username": "Unbeknownstguy",
                        "content": "`(prefixMod + num % k + k) % k;`\\ncan anyone explain what does this code mean? Sorry if it sounds like a noob. \\nThanks."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "make sure the remainder are postive i guess"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "sum%k gives the remainder say \\'r\\'. It means if \\'r\\' is subtracted from sum, then sum will be divisible by k.\\nHence we try to find \\'r\\' in the map:\\nif \\'r\\' exist, it means that if we subtract that \\'r\\' or say that subarray from start(as we are using prefixSum), then our current sum will be divisible by k.  "
                    },
                    {
                        "username": "maktinho",
                        "content": "There should be a hint for this problem. O(N^2) solution get TLE at case 67 or 68 and people has no idea what should be done. Only a trick is missing and there is no reason to have a complete solution."
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Complicated math ya? Made it simple: https://youtu.be/fWCsT9nkTnM"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "nums = [0,-5]\\nwhy is the output of the above testcase 1 it should be 0 right \\nsomeone please explain."
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "[@Rishu_Raj_Anand](/Rishu_Raj_Anand)  Yep, right"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@abhinavshukla693](/abhinavshukla693) It doesn\\'t matter what\\'s the \\'k\\' value, 0 will be divisible by all number. "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "because 0 is divisible by any number \\n"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "Could you provide the value of k ?\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "I got the real challenge with negative prefix sum, couldn\\'t think of adding \\'k\\' to it. I was doing wrong by taking modulus of -ve prefix sum before storing in hashmap.\\nSo, if sum%k<0, add \\'k\\' to sum%k before storing in hashMap, it took time to visualize things even after knowing the process. \\n "
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Why Prefix Sum?\\nNeed to calculate sum of every subarray to check sum is divisible by k.\\n# How Prefix Sum?\\nTo check divisibility I need modulo operator.\\nThe range of remainder is from `0,k-1`.\\nFind remainder of sum. Preserve the count of remainder.\\nNow the `prefix sum % k will take us to same remainder again, when the sum is divisible by k`.\\nEdge case : `frequency of remainder 0 starts with 1` to handle contiguous subarray formation.\\n\\nDon\\'t jump to solution directly : [solution](https://leetcode.com/problems/subarray-sums-divisible-by-k/solutions/3070781/on-easy-java-solution/)\\n"
                    },
                    {
                        "username": "GeekErra",
                        "content": "Click this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "<h3>My Intuition for this problem is:</h3>\\n<ul>\\n<li> If two numbers are divisible by k then their sum must also be divisible by k. </ul>\\n</ul>\\n<ul>\\n<li> Now this brings me to think about prefix sum but I couldn\\'t figure out how would I implement it in O(n) time? </li>\\n</ul>"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "[@ngducanh1611](/ngducanh1611)  He mentioned that if the numbers are themselves divisible by k then their sum should also be divisible by k. "
                    },
                    {
                        "username": "cse_shivam98",
                        "content": "try to think in kadane\\'s algo perspective\\n"
                    },
                    {
                        "username": "ngducanh1611",
                        "content": "This theory is still not enough, if two numbers are NOT divisible by k, their sum may still be divisible by k. Ex: 2 and 3 are not divisible by 5 but, (2+3) = 5 is divisible"
                    },
                    {
                        "username": "medmoe",
                        "content": "the only solution that i can think about is nested loops with O(n(n+1)/2)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Hint:\\n\\nIn the worst case, there are O(n^2) subarrays that is divisible by k (e.g. [0,0,0...,0])\\nA solution based on counting the subarray one by one will not work.\\nHow can you count the subarrays (which is essentially a pair of indices that shares an interesting property) without going through them one by one."
                    }
                ]
            },
            {
                "id": 1764187,
                "content": [
                    {
                        "username": "Unbeknownstguy",
                        "content": "`(prefixMod + num % k + k) % k;`\\ncan anyone explain what does this code mean? Sorry if it sounds like a noob. \\nThanks."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "make sure the remainder are postive i guess"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "sum%k gives the remainder say \\'r\\'. It means if \\'r\\' is subtracted from sum, then sum will be divisible by k.\\nHence we try to find \\'r\\' in the map:\\nif \\'r\\' exist, it means that if we subtract that \\'r\\' or say that subarray from start(as we are using prefixSum), then our current sum will be divisible by k.  "
                    },
                    {
                        "username": "maktinho",
                        "content": "There should be a hint for this problem. O(N^2) solution get TLE at case 67 or 68 and people has no idea what should be done. Only a trick is missing and there is no reason to have a complete solution."
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Complicated math ya? Made it simple: https://youtu.be/fWCsT9nkTnM"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "nums = [0,-5]\\nwhy is the output of the above testcase 1 it should be 0 right \\nsomeone please explain."
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "[@Rishu_Raj_Anand](/Rishu_Raj_Anand)  Yep, right"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@abhinavshukla693](/abhinavshukla693) It doesn\\'t matter what\\'s the \\'k\\' value, 0 will be divisible by all number. "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "because 0 is divisible by any number \\n"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "Could you provide the value of k ?\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "I got the real challenge with negative prefix sum, couldn\\'t think of adding \\'k\\' to it. I was doing wrong by taking modulus of -ve prefix sum before storing in hashmap.\\nSo, if sum%k<0, add \\'k\\' to sum%k before storing in hashMap, it took time to visualize things even after knowing the process. \\n "
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Why Prefix Sum?\\nNeed to calculate sum of every subarray to check sum is divisible by k.\\n# How Prefix Sum?\\nTo check divisibility I need modulo operator.\\nThe range of remainder is from `0,k-1`.\\nFind remainder of sum. Preserve the count of remainder.\\nNow the `prefix sum % k will take us to same remainder again, when the sum is divisible by k`.\\nEdge case : `frequency of remainder 0 starts with 1` to handle contiguous subarray formation.\\n\\nDon\\'t jump to solution directly : [solution](https://leetcode.com/problems/subarray-sums-divisible-by-k/solutions/3070781/on-easy-java-solution/)\\n"
                    },
                    {
                        "username": "GeekErra",
                        "content": "Click this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "<h3>My Intuition for this problem is:</h3>\\n<ul>\\n<li> If two numbers are divisible by k then their sum must also be divisible by k. </ul>\\n</ul>\\n<ul>\\n<li> Now this brings me to think about prefix sum but I couldn\\'t figure out how would I implement it in O(n) time? </li>\\n</ul>"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "[@ngducanh1611](/ngducanh1611)  He mentioned that if the numbers are themselves divisible by k then their sum should also be divisible by k. "
                    },
                    {
                        "username": "cse_shivam98",
                        "content": "try to think in kadane\\'s algo perspective\\n"
                    },
                    {
                        "username": "ngducanh1611",
                        "content": "This theory is still not enough, if two numbers are NOT divisible by k, their sum may still be divisible by k. Ex: 2 and 3 are not divisible by 5 but, (2+3) = 5 is divisible"
                    },
                    {
                        "username": "medmoe",
                        "content": "the only solution that i can think about is nested loops with O(n(n+1)/2)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Hint:\\n\\nIn the worst case, there are O(n^2) subarrays that is divisible by k (e.g. [0,0,0...,0])\\nA solution based on counting the subarray one by one will not work.\\nHow can you count the subarrays (which is essentially a pair of indices that shares an interesting property) without going through them one by one."
                    }
                ]
            },
            {
                "id": 1764184,
                "content": [
                    {
                        "username": "Unbeknownstguy",
                        "content": "`(prefixMod + num % k + k) % k;`\\ncan anyone explain what does this code mean? Sorry if it sounds like a noob. \\nThanks."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "make sure the remainder are postive i guess"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "sum%k gives the remainder say \\'r\\'. It means if \\'r\\' is subtracted from sum, then sum will be divisible by k.\\nHence we try to find \\'r\\' in the map:\\nif \\'r\\' exist, it means that if we subtract that \\'r\\' or say that subarray from start(as we are using prefixSum), then our current sum will be divisible by k.  "
                    },
                    {
                        "username": "maktinho",
                        "content": "There should be a hint for this problem. O(N^2) solution get TLE at case 67 or 68 and people has no idea what should be done. Only a trick is missing and there is no reason to have a complete solution."
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Complicated math ya? Made it simple: https://youtu.be/fWCsT9nkTnM"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "nums = [0,-5]\\nwhy is the output of the above testcase 1 it should be 0 right \\nsomeone please explain."
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "[@Rishu_Raj_Anand](/Rishu_Raj_Anand)  Yep, right"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@abhinavshukla693](/abhinavshukla693) It doesn\\'t matter what\\'s the \\'k\\' value, 0 will be divisible by all number. "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "because 0 is divisible by any number \\n"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "Could you provide the value of k ?\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "I got the real challenge with negative prefix sum, couldn\\'t think of adding \\'k\\' to it. I was doing wrong by taking modulus of -ve prefix sum before storing in hashmap.\\nSo, if sum%k<0, add \\'k\\' to sum%k before storing in hashMap, it took time to visualize things even after knowing the process. \\n "
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Why Prefix Sum?\\nNeed to calculate sum of every subarray to check sum is divisible by k.\\n# How Prefix Sum?\\nTo check divisibility I need modulo operator.\\nThe range of remainder is from `0,k-1`.\\nFind remainder of sum. Preserve the count of remainder.\\nNow the `prefix sum % k will take us to same remainder again, when the sum is divisible by k`.\\nEdge case : `frequency of remainder 0 starts with 1` to handle contiguous subarray formation.\\n\\nDon\\'t jump to solution directly : [solution](https://leetcode.com/problems/subarray-sums-divisible-by-k/solutions/3070781/on-easy-java-solution/)\\n"
                    },
                    {
                        "username": "GeekErra",
                        "content": "Click this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "<h3>My Intuition for this problem is:</h3>\\n<ul>\\n<li> If two numbers are divisible by k then their sum must also be divisible by k. </ul>\\n</ul>\\n<ul>\\n<li> Now this brings me to think about prefix sum but I couldn\\'t figure out how would I implement it in O(n) time? </li>\\n</ul>"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "[@ngducanh1611](/ngducanh1611)  He mentioned that if the numbers are themselves divisible by k then their sum should also be divisible by k. "
                    },
                    {
                        "username": "cse_shivam98",
                        "content": "try to think in kadane\\'s algo perspective\\n"
                    },
                    {
                        "username": "ngducanh1611",
                        "content": "This theory is still not enough, if two numbers are NOT divisible by k, their sum may still be divisible by k. Ex: 2 and 3 are not divisible by 5 but, (2+3) = 5 is divisible"
                    },
                    {
                        "username": "medmoe",
                        "content": "the only solution that i can think about is nested loops with O(n(n+1)/2)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Hint:\\n\\nIn the worst case, there are O(n^2) subarrays that is divisible by k (e.g. [0,0,0...,0])\\nA solution based on counting the subarray one by one will not work.\\nHow can you count the subarrays (which is essentially a pair of indices that shares an interesting property) without going through them one by one."
                    }
                ]
            },
            {
                "id": 1764150,
                "content": [
                    {
                        "username": "Unbeknownstguy",
                        "content": "`(prefixMod + num % k + k) % k;`\\ncan anyone explain what does this code mean? Sorry if it sounds like a noob. \\nThanks."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "Suppose while calculating prefix sums at index i+5 your sum is \\'a\\' and at index i it is \\'b\\' Now if (a-b)%k == 0\\nwe can also write that:\\n\\n((a%k)-(b%k))==0 i.e a%k == b%k\\n\\nThat is why we are calcualting remainder and storing in unordered map\\nAlso for negative numbers ,make them positve by incrementing k in them till they become positive"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "make sure the remainder are postive i guess"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "sum%k gives the remainder say \\'r\\'. It means if \\'r\\' is subtracted from sum, then sum will be divisible by k.\\nHence we try to find \\'r\\' in the map:\\nif \\'r\\' exist, it means that if we subtract that \\'r\\' or say that subarray from start(as we are using prefixSum), then our current sum will be divisible by k.  "
                    },
                    {
                        "username": "maktinho",
                        "content": "There should be a hint for this problem. O(N^2) solution get TLE at case 67 or 68 and people has no idea what should be done. Only a trick is missing and there is no reason to have a complete solution."
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Complicated math ya? Made it simple: https://youtu.be/fWCsT9nkTnM"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "nums = [0,-5]\\nwhy is the output of the above testcase 1 it should be 0 right \\nsomeone please explain."
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "[@Rishu_Raj_Anand](/Rishu_Raj_Anand)  Yep, right"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@abhinavshukla693](/abhinavshukla693) It doesn\\'t matter what\\'s the \\'k\\' value, 0 will be divisible by all number. "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "because 0 is divisible by any number \\n"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "Could you provide the value of k ?\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "I got the real challenge with negative prefix sum, couldn\\'t think of adding \\'k\\' to it. I was doing wrong by taking modulus of -ve prefix sum before storing in hashmap.\\nSo, if sum%k<0, add \\'k\\' to sum%k before storing in hashMap, it took time to visualize things even after knowing the process. \\n "
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Why Prefix Sum?\\nNeed to calculate sum of every subarray to check sum is divisible by k.\\n# How Prefix Sum?\\nTo check divisibility I need modulo operator.\\nThe range of remainder is from `0,k-1`.\\nFind remainder of sum. Preserve the count of remainder.\\nNow the `prefix sum % k will take us to same remainder again, when the sum is divisible by k`.\\nEdge case : `frequency of remainder 0 starts with 1` to handle contiguous subarray formation.\\n\\nDon\\'t jump to solution directly : [solution](https://leetcode.com/problems/subarray-sums-divisible-by-k/solutions/3070781/on-easy-java-solution/)\\n"
                    },
                    {
                        "username": "GeekErra",
                        "content": "Click this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "<h3>My Intuition for this problem is:</h3>\\n<ul>\\n<li> If two numbers are divisible by k then their sum must also be divisible by k. </ul>\\n</ul>\\n<ul>\\n<li> Now this brings me to think about prefix sum but I couldn\\'t figure out how would I implement it in O(n) time? </li>\\n</ul>"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "[@ngducanh1611](/ngducanh1611)  He mentioned that if the numbers are themselves divisible by k then their sum should also be divisible by k. "
                    },
                    {
                        "username": "cse_shivam98",
                        "content": "try to think in kadane\\'s algo perspective\\n"
                    },
                    {
                        "username": "ngducanh1611",
                        "content": "This theory is still not enough, if two numbers are NOT divisible by k, their sum may still be divisible by k. Ex: 2 and 3 are not divisible by 5 but, (2+3) = 5 is divisible"
                    },
                    {
                        "username": "medmoe",
                        "content": "the only solution that i can think about is nested loops with O(n(n+1)/2)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Hint:\\n\\nIn the worst case, there are O(n^2) subarrays that is divisible by k (e.g. [0,0,0...,0])\\nA solution based on counting the subarray one by one will not work.\\nHow can you count the subarrays (which is essentially a pair of indices that shares an interesting property) without going through them one by one."
                    }
                ]
            }
        ]
    },
    {
        "title": "Sum of Digits in the Minimum Number",
        "question_content": null,
        "solutions": [],
        "discussions": []
    }
]