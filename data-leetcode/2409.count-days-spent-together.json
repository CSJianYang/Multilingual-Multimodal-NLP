[
    {
        "title": "Design SQL",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1605603,
                "content": [
                    {
                        "username": "sr_vrd",
                        "content": "Note the columns in each table are also 1-indexed."
                    },
                    {
                        "username": "startupveteran",
                        "content": "Why is this question being downvoted so much? Seemed like a fair and legit challenge to me."
                    },
                    {
                        "username": "SleepyPounds",
                        "content": "making the input param possibly invalid and change the function return type to bool would be better. Otherwise, the 'columns' input is unnecessary.  "
                    }
                ]
            },
            {
                "id": 1909533,
                "content": [
                    {
                        "username": "sr_vrd",
                        "content": "Note the columns in each table are also 1-indexed."
                    },
                    {
                        "username": "startupveteran",
                        "content": "Why is this question being downvoted so much? Seemed like a fair and legit challenge to me."
                    },
                    {
                        "username": "SleepyPounds",
                        "content": "making the input param possibly invalid and change the function return type to bool would be better. Otherwise, the 'columns' input is unnecessary.  "
                    }
                ]
            },
            {
                "id": 1957939,
                "content": [
                    {
                        "username": "sr_vrd",
                        "content": "Note the columns in each table are also 1-indexed."
                    },
                    {
                        "username": "startupveteran",
                        "content": "Why is this question being downvoted so much? Seemed like a fair and legit challenge to me."
                    },
                    {
                        "username": "SleepyPounds",
                        "content": "making the input param possibly invalid and change the function return type to bool would be better. Otherwise, the 'columns' input is unnecessary.  "
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Days Spent Together",
        "question_content": "<p>Alice and Bob are traveling to Rome for separate business meetings.</p>\n\n<p>You are given 4 strings <code>arriveAlice</code>, <code>leaveAlice</code>, <code>arriveBob</code>, and <code>leaveBob</code>. Alice will be in the city from the dates <code>arriveAlice</code> to <code>leaveAlice</code> (<strong>inclusive</strong>), while Bob will be in the city from the dates <code>arriveBob</code> to <code>leaveBob</code> (<strong>inclusive</strong>). Each will be a 5-character string in the format <code>&quot;MM-DD&quot;</code>, corresponding to the month and day of the date.</p>\n\n<p>Return<em> the total number of days that Alice and Bob are in Rome together.</em></p>\n\n<p>You can assume that all dates occur in the <strong>same</strong> calendar year, which is <strong>not</strong> a leap year. Note that the number of days per month can be represented as: <code>[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arriveAlice = &quot;08-15&quot;, leaveAlice = &quot;08-18&quot;, arriveBob = &quot;08-16&quot;, leaveBob = &quot;08-19&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Alice will be in Rome from August 15 to August 18. Bob will be in Rome from August 16 to August 19. They are both in Rome together on August 16th, 17th, and 18th, so the answer is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arriveAlice = &quot;10-01&quot;, leaveAlice = &quot;10-31&quot;, arriveBob = &quot;11-01&quot;, leaveBob = &quot;12-31&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There is no day when Alice and Bob are in Rome together, so we return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>All dates are provided in the format <code>&quot;MM-DD&quot;</code>.</li>\n\t<li>Alice and Bob&#39;s arrival dates are <strong>earlier than or equal to</strong> their leaving dates.</li>\n\t<li>The given dates are valid dates of a <strong>non-leap</strong> year.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2587981,
                "title": "c-convert-date-to-number-in-year-explaination",
                "content": "- We just need to convert the given date to number in year.\\n- For example, \"01-13\" (13th January) represents **13th day in year**, \"02-13\" (13th February) represents **44th day in year**.\\n- This problem came in Biweekly Contest on 17th September, 2022, which is **260th day** in year.\\n```cpp\\nint md[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\nclass Solution {\\n\\t// Convert date to respective number in year.\\n    int td(string s) {\\n        int m = s[1] - \\'0\\' + 10*(s[0] - \\'0\\');\\n        int d = s[4] - \\'0\\' + 10*(s[3] - \\'0\\');\\n        --m;\\n        while (m > 0) {\\n            d += md[m];\\n            --m;\\n        }\\n        return d;\\n    }\\npublic:\\n    int countDaysTogether(string sa1, string sa2, string sb1, string sb2) {\\n        int a1 = td(sa1), a2 = td(sa2), b1 = td(sb1), b2 = td(sb2);\\n        int ans = 0;\\n\\t\\t// Check all 365 days in year\\n        for (int i = 0; i < 367; ++i) {\\n            if (a1 <= i && i <= a2 && b1 <= i && i <= b2) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint md[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\nclass Solution {\\n\\t// Convert date to respective number in year.\\n    int td(string s) {\\n        int m = s[1] - \\'0\\' + 10*(s[0] - \\'0\\');\\n        int d = s[4] - \\'0\\' + 10*(s[3] - \\'0\\');\\n        --m;\\n        while (m > 0) {\\n            d += md[m];\\n            --m;\\n        }\\n        return d;\\n    }\\npublic:\\n    int countDaysTogether(string sa1, string sa2, string sb1, string sb2) {\\n        int a1 = td(sa1), a2 = td(sa2), b1 = td(sb1), b2 = td(sb2);\\n        int ans = 0;\\n\\t\\t// Check all 365 days in year\\n        for (int i = 0; i < 367; ++i) {\\n            if (a1 <= i && i <= a2 && b1 <= i && i <= b2) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587931,
                "title": "why-is-this-problem-marked-easy",
                "content": "Just because this problem did not use complex algorithm does not mean it should be marked as easy (at least in timed contest).\\nIt\\u2019s like trying to perfectly balance stack of books on your head within a time frame and say it\\u2019s easy because there is not much physical work to do in that.",
                "solutionTags": [],
                "code": "Just because this problem did not use complex algorithm does not mean it should be marked as easy (at least in timed contest).\\nIt\\u2019s like trying to perfectly balance stack of books on your head within a time frame and say it\\u2019s easy because there is not much physical work to do in that.",
                "codeTag": "Unknown"
            },
            {
                "id": 2587939,
                "title": "stupid-problem-line-sweep-dry-run",
                "content": "**Approach: Map Line Sweep**\\n\\n**Intiution:** We need overlapping intervals, so need to use line sweep.\\n\\n**TC**: O(logN) ~= O(log4) ~= **O(1)** as we are inserting 4 elements into map + O(12) for traversing months.. Since 4 is very small no. even for the worst case, so we can say that its O(1)\\n\\n**SC**: O(4 + 4) ~= **O(1)**: we are using 4 variables + 4 elements in the map, which will be same for the worst case as well, so we can say that its O(1) \\n\\n**Dry Run:**\\nFor sample test case 1 our map will contains: \\n258 +1   259 +1   262 -1   263 -1:\\n\\nhere 258, 259 is the key and values are +1, -1.\\n\\nwe will take commulative some of the values..\\nour values goes like this +1 +2 +1 0\\n\\nwhenever we get 2: means we are in a nested cluster like `[ (  ) ] `: \\nwe are at firt curly bracket, now we know that together part will `) - (` is the answer.\\n\\nnext(it) : it will point the next pointer from current pointer, so `(next(it)->first) - (it->first)`: means 262 - 259 = 3, which is our answer..\\n\\nIf we never able to reach to 2, means there\\'s no cluster like `[()] or [(])` which gives answer. In this case our cluster will be like [] (), so will return 0 as there\\'s nothing common between them.\\n```\\nclass Solution {\\npublic:\\n    int convertMonthToDays(int month){\\n        int months[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        int days = 0;\\n        \\n        // we will skip the current month as we are counting them explicitly.\\n        for(int i = 0; i < month - 1; i++){\\n            days += months[i];\\n        }\\n        return days;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int aliceArriveDayCount = convertMonthToDays(stoi(arriveAlice.substr(0, 2))) + stoi(arriveAlice.substr(3, 2));\\n        int aliceLeaveDayCount = convertMonthToDays(stoi(leaveAlice.substr(0, 2))) + stoi(leaveAlice.substr(3, 2));\\n        \\n        int bobArriveDayCount = convertMonthToDays(stoi(arriveBob.substr(0, 2))) + stoi(arriveBob.substr(3, 2));\\n        int bobLeaveDayCount = convertMonthToDays(stoi(leaveBob.substr(0, 2))) + stoi(leaveBob.substr(3, 2));\\n        \\n        // Line Sweep\\n        map<int, int> map;\\n        \\n\\t\\t// Marking arriving and leaving boundaries.\\n        map[aliceArriveDayCount]++;\\n        map[aliceLeaveDayCount + 1]--;\\n        \\n        map[bobArriveDayCount]++;\\n        map[bobLeaveDayCount + 1]--;\\n\\n        int days = 0, together = 0;\\n        \\n        // At any point we encounter nested intervals [ (  ) ] or [  (  ] ), we can get common days.\\n        // for eg: for sample test case 1 our map will contains\\n        // [258 +1   (259 +1   262 -1]   263 -1), then answer is : 262 - 259 = 3 days : )\\n        \\n        auto it = map.begin();\\n        while(it != map.end()){\\n            together += it->second;\\n            \\n            if(together == 2){\\n                return next(it)->first - it->first;\\n            }\\n            it++;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n**Doubts, Queries, Better Approaches are most welcome** \\uD83C\\uDF3B",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertMonthToDays(int month){\\n        int months[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        int days = 0;\\n        \\n        // we will skip the current month as we are counting them explicitly.\\n        for(int i = 0; i < month - 1; i++){\\n            days += months[i];\\n        }\\n        return days;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int aliceArriveDayCount = convertMonthToDays(stoi(arriveAlice.substr(0, 2))) + stoi(arriveAlice.substr(3, 2));\\n        int aliceLeaveDayCount = convertMonthToDays(stoi(leaveAlice.substr(0, 2))) + stoi(leaveAlice.substr(3, 2));\\n        \\n        int bobArriveDayCount = convertMonthToDays(stoi(arriveBob.substr(0, 2))) + stoi(arriveBob.substr(3, 2));\\n        int bobLeaveDayCount = convertMonthToDays(stoi(leaveBob.substr(0, 2))) + stoi(leaveBob.substr(3, 2));\\n        \\n        // Line Sweep\\n        map<int, int> map;\\n        \\n\\t\\t// Marking arriving and leaving boundaries.\\n        map[aliceArriveDayCount]++;\\n        map[aliceLeaveDayCount + 1]--;\\n        \\n        map[bobArriveDayCount]++;\\n        map[bobLeaveDayCount + 1]--;\\n\\n        int days = 0, together = 0;\\n        \\n        // At any point we encounter nested intervals [ (  ) ] or [  (  ] ), we can get common days.\\n        // for eg: for sample test case 1 our map will contains\\n        // [258 +1   (259 +1   262 -1]   263 -1), then answer is : 262 - 259 = 3 days : )\\n        \\n        auto it = map.begin();\\n        while(it != map.end()){\\n            together += it->second;\\n            \\n            if(together == 2){\\n                return next(it)->first - it->first;\\n            }\\n            it++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587888,
                "title": "days-range-java",
                "content": "\\n**Code:**\\n\\n    int[] months = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int countDaysTogether(String s1, String e1, String s2, String e2) {\\n        int[] a = new int[]{ getVal(s1), getVal(e1) };\\n        int[] b = new int[]{ getVal(s2), getVal(e2) };\\n        if(b[0]>a[1] || a[0]>b[1]) return 0;  // no overlap\\n        \\n        int start = Math.max(a[0], b[0]);\\n        int last = Math.min(a[1], b[1]);\\n        return last-start+1;\\n    }\\n    \\n    // convert date to nth day of year, (1st-365th day)\\n\\tint getVal(String str){\\n        int idx = 0;\\n        int mon = (str.charAt(0)-\\'0\\')*10+(str.charAt(1)-\\'0\\');\\n        int day = (str.charAt(3)-\\'0\\')*10+(str.charAt(4)-\\'0\\');\\n        for(int i=1; i<mon; i++) idx += months[i-1]; // or use prefix sum\\n        return idx+day;\\n    }",
                "solutionTags": [],
                "code": "\\n**Code:**\\n\\n    int[] months = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int countDaysTogether(String s1, String e1, String s2, String e2) {\\n        int[] a = new int[]{ getVal(s1), getVal(e1) };\\n        int[] b = new int[]{ getVal(s2), getVal(e2) };\\n        if(b[0]>a[1] || a[0]>b[1]) return 0;  // no overlap\\n        \\n        int start = Math.max(a[0], b[0]);\\n        int last = Math.min(a[1], b[1]);\\n        return last-start+1;\\n    }\\n    \\n    // convert date to nth day of year, (1st-365th day)\\n\\tint getVal(String str){\\n        int idx = 0;\\n        int mon = (str.charAt(0)-\\'0\\')*10+(str.charAt(1)-\\'0\\');\\n        int day = (str.charAt(3)-\\'0\\')*10+(str.charAt(4)-\\'0\\');\\n        for(int i=1; i<mon; i++) idx += months[i-1]; // or use prefix sum\\n        return idx+day;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2587961,
                "title": "line-sweep-c-with-comments",
                "content": "I learnt this algorithm in last weekly contest.\\n    \\n# Intuition:\\n > Return the total number of days that Alice and Bob are in Rome together\\n\\nThis line gives us straight forward intuition of finding count of **Overlapping events**.\\nThe most optimised algorithm for this is called **Line Sweep Technique**. \\n\\n> A better technique exists which takes constant space and time, but this technique is worth it learning.\\n    \\n # Algorithm:\\n 1. Get the interger form of alice\\'s and bob\\'s start and end day and month\\n 2. After getting integer, get the day number with given day and month number. [For that I wrote function days_convert()]\\n 3. Simply apply Line Sweep Technique and count days with overlapping count of 2 using array `cnt`.\\n\\n**Time** - O(`370`)\\n**Space** - O(`370`)    \\n  # I have attached comments line by line with proper variable naming because there is no use of short code if its not understandable.\\n\\n\\n# C++ \\n    //to extract the count of days before month number given\\n    int days_convert(int month){\\n        vector<int> a{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int count=0;\\n        //we won\\'t include the given month number days because its not complete yet.\\n        for(int i=0;i<=(month-1-1);i++) count+= a[i];\\n        return count;\\n    }\\n    \\n    int countDaysTogether(string a, string la, string b, string lb) {\\n        //Step A:  Get the integer count of day according to 365 numbering \\n       \\n        int alice_arrive_day_count= days_convert((a[0]-\\'0\\')*10+(a[1]-\\'0\\')) + (a[3]-\\'0\\')*10+(a[4]-\\'0\\');\\n        int alice_end_day_count   = days_convert((la[0]-\\'0\\')*10+(la[1]-\\'0\\')) + (la[3]-\\'0\\')*10+(la[4]-\\'0\\');\\n        int bob_arrive_day_count  = days_convert((b[0]-\\'0\\')*10+(b[1]-\\'0\\') ) + (b[3]-\\'0\\')*10+(b[4]-\\'0\\');\\n        int bob_end_day_count     = days_convert((lb[0]-\\'0\\')*10+(lb[1]-\\'0\\')) + (lb[3]-\\'0\\')*10+(lb[4]-\\'0\\');\\n        \\n        \\n        //Step B : Line Sweep Technique\\n        int cnt[370]{};\\n\\t\\t\\n        //Mark Boundaries\\n        cnt[alice_arrive_day_count]++;\\n        cnt[alice_end_day_count+1]--;\\n        cnt[bob_arrive_day_count]++;\\n        cnt[bob_end_day_count+1]--;\\n        \\n        //Take prefix and count days with overlapping count of 2\\n        int days=0, sum=0;\\n        for(int i:cnt){\\n            sum+= i;\\n            //found a count of 2 means , a day where both have their days common\\n            if(sum==2) days++;\\n        }\\n        return days;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "I learnt this algorithm in last weekly contest.\\n    \\n# Intuition:\\n > Return the total number of days that Alice and Bob are in Rome together\\n\\nThis line gives us straight forward intuition of finding count of **Overlapping events**.\\nThe most optimised algorithm for this is called **Line Sweep Technique**. \\n\\n> A better technique exists which takes constant space and time, but this technique is worth it learning.\\n    \\n # Algorithm:\\n 1. Get the interger form of alice\\'s and bob\\'s start and end day and month\\n 2. After getting integer, get the day number with given day and month number. [For that I wrote function days_convert()]\\n 3. Simply apply Line Sweep Technique and count days with overlapping count of 2 using array `cnt`.\\n\\n**Time** - O(`370`)\\n**Space** - O(`370`)    \\n  # I have attached comments line by line with proper variable naming because there is no use of short code if its not understandable.\\n\\n\\n# C++ \\n    //to extract the count of days before month number given\\n    int days_convert(int month){\\n        vector<int> a{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int count=0;\\n        //we won\\'t include the given month number days because its not complete yet.\\n        for(int i=0;i<=(month-1-1);i++) count+= a[i];\\n        return count;\\n    }\\n    \\n    int countDaysTogether(string a, string la, string b, string lb) {\\n        //Step A:  Get the integer count of day according to 365 numbering \\n       \\n        int alice_arrive_day_count= days_convert((a[0]-\\'0\\')*10+(a[1]-\\'0\\')) + (a[3]-\\'0\\')*10+(a[4]-\\'0\\');\\n        int alice_end_day_count   = days_convert((la[0]-\\'0\\')*10+(la[1]-\\'0\\')) + (la[3]-\\'0\\')*10+(la[4]-\\'0\\');\\n        int bob_arrive_day_count  = days_convert((b[0]-\\'0\\')*10+(b[1]-\\'0\\') ) + (b[3]-\\'0\\')*10+(b[4]-\\'0\\');\\n        int bob_end_day_count     = days_convert((lb[0]-\\'0\\')*10+(lb[1]-\\'0\\')) + (lb[3]-\\'0\\')*10+(lb[4]-\\'0\\');\\n        \\n        \\n        //Step B : Line Sweep Technique\\n        int cnt[370]{};\\n\\t\\t\\n        //Mark Boundaries\\n        cnt[alice_arrive_day_count]++;\\n        cnt[alice_end_day_count+1]--;\\n        cnt[bob_arrive_day_count]++;\\n        cnt[bob_end_day_count+1]--;\\n        \\n        //Take prefix and count days with overlapping count of 2\\n        int days=0, sum=0;\\n        for(int i:cnt){\\n            sum+= i;\\n            //found a count of 2 means , a day where both have their days common\\n            if(sum==2) days++;\\n        }\\n        return days;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2588031,
                "title": "python-simple-solution-easy-to-understand-explained",
                "content": "#### Understanding\\n* Find the minimum date of leave between Alice & Bob.\\n* Find the maximum date of arrival between Alice & Bob.\\n* The desire date will be between these two limit.\\n\\n#### Example\\n* Let the input be `arriveAlice = \"08-15\", leaveAlice = \"08-18\", arriveBob = \"08-16\", leaveBob = \"08-19\"`\\n* The minimum date of leave between Alice & Bob is `\"08-18\"`.\\n* The max date of arrival between Alice & Bob is `\"08-16\"`.\\n* Total number of days together will be between these days.\\n\\t* Calculate from `\"08-18\"` the total days in a year using `getDate(date)` method and we get **230** days.\\n\\t* Calculate from `\"08-16\"` the total days in a year using `getDate(date)` method and we get **228** days.\\n* Now substract `230 - 228 + 1`. As days are inclusive so we add 1.\\n* Return the max value between substranct value and 0.\\n\\n##### Code\\n<iframe src=\"https://leetcode.com/playground/6BEiBvaS/shared\" frameBorder=\"0\" width=\"800\" height=\"300\"></iframe>\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "#### Understanding\\n* Find the minimum date of leave between Alice & Bob.\\n* Find the maximum date of arrival between Alice & Bob.\\n* The desire date will be between these two limit.\\n\\n#### Example\\n* Let the input be `arriveAlice = \"08-15\", leaveAlice = \"08-18\", arriveBob = \"08-16\", leaveBob = \"08-19\"`\\n* The minimum date of leave between Alice & Bob is `\"08-18\"`.\\n* The max date of arrival between Alice & Bob is `\"08-16\"`.\\n* Total number of days together will be between these days.\\n\\t* Calculate from `\"08-18\"` the total days in a year using `getDate(date)` method and we get **230** days.\\n\\t* Calculate from `\"08-16\"` the total days in a year using `getDate(date)` method and we get **228** days.\\n* Now substract `230 - 228 + 1`. As days are inclusive so we add 1.\\n* Return the max value between substranct value and 0.\\n\\n##### Code\\n<iframe src=\"https://leetcode.com/playground/6BEiBvaS/shared\" frameBorder=\"0\" width=\"800\" height=\"300\"></iframe>\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2588216,
                "title": "python-explanation-with-pictures-4-line-overlapping-intervals",
                "content": "\\nCount the number of days in the overlapped interval `[second arrive, first leave]`:\\n\\n`overlapped_days = days_before_first_leave - days_before_second_arrive + 1` since its an inclusive range.\\n\\n![image](https://assets.leetcode.com/users/images/8e427dbd-040d-4bd0-8b35-1acb27750eb1_1663435585.724624.png)\\n\\n\\nWe can just count the days from **day_0** (the beginning of this year) till the given date:\\n`overlapped_days = days before end - days before start + 1`\\n\\n\\n![image](https://assets.leetcode.com/users/images/ea0a1d9b-6f9e-4c62-895c-5712a086a9cf_1663435662.367996.png)\\n\\n\\n\\nHow to count the days above:\\n`days = days in whole months + rest days`\\n\\n![image](https://assets.leetcode.com/users/images/85f1a628-44df-4053-8677-77cfa156a2ed_1663435593.0807467.png)\\n\\n\\n**python**\\n\\n```\\ndef countDaysTogether(self, aa: str, la: str, ab: str, lb: str) -> int:\\n        D = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        \\n        def helper(days):\\n            return int(days[-2:]) + sum(D[:int(days[:2]) - 1])\\n        \\n        return max(0, helper(min(la, lb)) - helper(max(aa, ab)) + 1)\\n```",
                "solutionTags": [],
                "code": "```\\ndef countDaysTogether(self, aa: str, la: str, ab: str, lb: str) -> int:\\n        D = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        \\n        def helper(days):\\n            return int(days[-2:]) + sum(D[:int(days[:2]) - 1])\\n        \\n        return max(0, helper(min(la, lb)) - helper(max(aa, ab)) + 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2589668,
                "title": "day-of-year",
                "content": "We use a prefix sum array to convert string dates to the day of the year.\\n\\nThen, we subtract the last and first day when Bob and Alice were together.\\n\\n**C++**\\n```cpp\\nint days[12] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\nint dayOfYear(string &d) {\\n    return days[10 * (d[0] - \\'0\\') + d[1] - \\'0\\' - 1] + 10 * (d[3] - \\'0\\') + d[4] - \\'0\\';\\n}\\nint countDaysTogether(string aa, string la, string ab, string lb) {\\n    return max(0, min(dayOfYear(la), dayOfYear(lb)) - max(dayOfYear(aa), dayOfYear(ab)) + 1);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint days[12] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\nint dayOfYear(string &d) {\\n    return days[10 * (d[0] - \\'0\\') + d[1] - \\'0\\' - 1] + 10 * (d[3] - \\'0\\') + d[4] - \\'0\\';\\n}\\nint countDaysTogether(string aa, string la, string ab, string lb) {\\n    return max(0, min(dayOfYear(la), dayOfYear(lb)) - max(dayOfYear(aa), dayOfYear(ab)) + 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588389,
                "title": "c-easy-to-understand-100",
                "content": "\\n\\tclass Solution {\\n\\tprivate:\\n    int days[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    vector<int> sumDays;\\n\\t\\n\\tpublic:\\n\\tint totalDays(string str){\\n        int month = stoi(str.substr(0, 2)), day = stoi(str.substr(3));    \\n        return sumDays[month - 1] + day;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        sumDays.push_back(0);\\n        for(int i =0;i<12;i++){\\n            sumDays.push_back(sumDays.back() + days[i]);\\n        }\\n        \\n        int arrival = max(totalDays(arriveAlice), totalDays(arriveBob));\\n        int departure = min(totalDays(leaveAlice), totalDays(leaveBob));\\n        int countDays = departure - arrival +1;\\n        \\n\\t\\treturn max(0, countDays);\\n        \\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tprivate:\\n    int days[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}",
                "codeTag": "Java"
            },
            {
                "id": 2587883,
                "title": "simple-solution",
                "content": "I think this is a tricky implementation question, but if we use library function it becomes very easy.\\n* Convert the date into number of days from the **Epoch** *1970-01-01* and find the intersection of the days. Check the comments for timeline\\n\\n```\\n//toEpochDay counts the number of days from the epoch 1970-01-01\\nimport java.time.LocalDate;\\nclass Solution {\\n\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob){\\n        LocalDate d1 = LocalDate.of(2021,Integer.parseInt(arriveAlice.substring(0,2)),Integer.parseInt(arriveAlice.substring(3,5)));\\n        LocalDate d2 = LocalDate.of(2021,Integer.parseInt(leaveAlice.substring(0,2)),Integer.parseInt(leaveAlice.substring(3,5)));\\n        LocalDate d3 = LocalDate.of(2021,Integer.parseInt(arriveBob.substring(0,2)),Integer.parseInt(arriveBob.substring(3,5)));\\n        LocalDate d4 = LocalDate.of(2021,Integer.parseInt(leaveBob.substring(0,2)),Integer.parseInt(leaveBob.substring(3,5)));\\n        long aa = d1.toEpochDay(); //Alice Arrive\\n        long al = d2.toEpochDay(); //Alice Left\\n        long ba = d3.toEpochDay(); //Bob Arrive\\n        long bl = d4.toEpochDay(); //Bob Left\\n        if(al<ba || bl<aa) return 0; //No intersection of days\\n        return (int) ((Math.min(al,bl)-Math.max(aa,ba))+1); //Intersection of days\\n    }\\n}\\n/*\\n    //Intersection of alice and bob\\n       aa.....ba.......bl.....al\\n       aa.....ba.......al......bl\\n       ba.....aa.......bl......al\\n       ba.....aa.......al......bl\\n\\n\\n   //No intersection\\n\\n           aa......al.....ba......bl\\n           ba.....bl.....aa......al\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//toEpochDay counts the number of days from the epoch 1970-01-01\\nimport java.time.LocalDate;\\nclass Solution {\\n\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob){\\n        LocalDate d1 = LocalDate.of(2021,Integer.parseInt(arriveAlice.substring(0,2)),Integer.parseInt(arriveAlice.substring(3,5)));\\n        LocalDate d2 = LocalDate.of(2021,Integer.parseInt(leaveAlice.substring(0,2)),Integer.parseInt(leaveAlice.substring(3,5)));\\n        LocalDate d3 = LocalDate.of(2021,Integer.parseInt(arriveBob.substring(0,2)),Integer.parseInt(arriveBob.substring(3,5)));\\n        LocalDate d4 = LocalDate.of(2021,Integer.parseInt(leaveBob.substring(0,2)),Integer.parseInt(leaveBob.substring(3,5)));\\n        long aa = d1.toEpochDay(); //Alice Arrive\\n        long al = d2.toEpochDay(); //Alice Left\\n        long ba = d3.toEpochDay(); //Bob Arrive\\n        long bl = d4.toEpochDay(); //Bob Left\\n        if(al<ba || bl<aa) return 0; //No intersection of days\\n        return (int) ((Math.min(al,bl)-Math.max(aa,ba))+1); //Intersection of days\\n    }\\n}\\n/*\\n    //Intersection of alice and bob\\n       aa.....ba.......bl.....al\\n       aa.....ba.......al......bl\\n       ba.....aa.......bl......al\\n       ba.....aa.......al......bl\\n\\n\\n   //No intersection\\n\\n           aa......al.....ba......bl\\n           ba.....bl.....aa......al\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588105,
                "title": "c-solution-easy-and-concise",
                "content": "**C++ Solution :-**\\n```\\nclass Solution{\\npublic:\\n    vector<int> days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int countDaysTogether(string aA, string lA, string aB, string lB)\\n    {\\n        /* calculating no of days each date represents. */\\n        int aliceA = accumulate(days.begin(), days.begin() + stoi(aA.substr(0, 2)) - 1, 0) + stoi(aA.substr(3, aA.size()));\\n        int aliceL = accumulate(days.begin(), days.begin() + stoi(lA.substr(0, 2)) - 1, 0) + stoi(lA.substr(3, aA.size()));\\n        int bobA = accumulate(days.begin(), days.begin() + stoi(aB.substr(0, 2)) - 1, 0) + stoi(aB.substr(3, aA.size()));\\n        int bobL = accumulate(days.begin(), days.begin() + stoi(lB.substr(0, 2)) - 1, 0) + stoi(lB.substr(3, aA.size()));\\n\\n        /* we have to choose minimum of leave days and maximum of arrival days\\n           in order to get no of days together. */\\n        int x = min(aliceL, bobL) - max(aliceA, bobA) + 1;\\n        if (x > 0)\\n            return x;\\n        return 0;\\n    }\\n};\\n```\\n**Please Upvote if you found this helpful .**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    vector<int> days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int countDaysTogether(string aA, string lA, string aB, string lB)\\n    {\\n        /* calculating no of days each date represents. */\\n        int aliceA = accumulate(days.begin(), days.begin() + stoi(aA.substr(0, 2)) - 1, 0) + stoi(aA.substr(3, aA.size()));\\n        int aliceL = accumulate(days.begin(), days.begin() + stoi(lA.substr(0, 2)) - 1, 0) + stoi(lA.substr(3, aA.size()));\\n        int bobA = accumulate(days.begin(), days.begin() + stoi(aB.substr(0, 2)) - 1, 0) + stoi(aB.substr(3, aA.size()));\\n        int bobL = accumulate(days.begin(), days.begin() + stoi(lB.substr(0, 2)) - 1, 0) + stoi(lB.substr(3, aA.size()));\\n\\n        /* we have to choose minimum of leave days and maximum of arrival days\\n           in order to get no of days together. */\\n        int x = min(aliceL, bobL) - max(aliceA, bobA) + 1;\\n        if (x > 0)\\n            return x;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587987,
                "title": "java-python-3-convert-to-the-kth-day-in-a-whole-year",
                "content": "Count the number of days from `01-01` to current day, then check the maximum of the arrival days and the minimum of the leaving days, if the former greater than the latter, no together days. otherwise, compute the days from the former to the latter.\\n\\n```java\\n    private static final int[] months = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};  \\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int aa = converToDays(arriveAlice);\\n        int la = converToDays(leaveAlice);\\n        int ab = converToDays(arriveBob);\\n        int lb = converToDays(leaveBob);\\n        int lo = Math.max(aa, ab);\\n        int hi = Math.min(la, lb);\\n        return Math.max(0, hi - lo + 1);\\n    }\\n    private int converToDays(String s) {\\n        int days = Integer.parseInt(s.substring(3));\\n        for (int i = 0; i < Integer.parseInt(s.substring(0, 2)) - 1; ++i) {\\n            days += months[i];\\n        }\\n        return days;\\n    }\\n```\\n```python\\n    months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        \\n        def convertToDays(s: str) -> int:\\n            month = int(s[: 2].lstrip(\\'0\\')) - 1\\n            days = int(s[-2 :].lstrip(\\'0\\'))\\n            return days + sum(self.months[: month])\\n        \\n        aa, la, ab, lb = map(convertToDays, (arriveAlice, leaveAlice, arriveBob, leaveBob))\\n        return max(0, min(la, lb) - max(aa, ab)  + 1)\\n```",
                "solutionTags": [],
                "code": "```java\\n    private static final int[] months = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};  \\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int aa = converToDays(arriveAlice);\\n        int la = converToDays(leaveAlice);\\n        int ab = converToDays(arriveBob);\\n        int lb = converToDays(leaveBob);\\n        int lo = Math.max(aa, ab);\\n        int hi = Math.min(la, lb);\\n        return Math.max(0, hi - lo + 1);\\n    }\\n    private int converToDays(String s) {\\n        int days = Integer.parseInt(s.substring(3));\\n        for (int i = 0; i < Integer.parseInt(s.substring(0, 2)) - 1; ++i) {\\n            days += months[i];\\n        }\\n        return days;\\n    }\\n```\n```python\\n    months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        \\n        def convertToDays(s: str) -> int:\\n            month = int(s[: 2].lstrip(\\'0\\')) - 1\\n            days = int(s[-2 :].lstrip(\\'0\\'))\\n            return days + sum(self.months[: month])\\n        \\n        aa, la, ab, lb = map(convertToDays, (arriveAlice, leaveAlice, arriveBob, leaveBob))\\n        return max(0, min(la, lb) - max(aa, ab)  + 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2587887,
                "title": "parse-dates-and-find-intersection",
                "content": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        start = max(arriveAlice, arriveBob)\\n        sm, sd = map(int, start.split(\"-\"))\\n        end = min(leaveAlice, leaveBob)\\n        em, ed = map(int, end.split(\"-\"))\\n        res = 0\\n        for m in range(sm + 1, em):\\n            res += days[m - 1]\\n        if em > sm:\\n            res += days[sm - 1] - sd + ed + 1\\n        elif em == sm:\\n            res += max(ed - sd + 1, 0)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        start = max(arriveAlice, arriveBob)\\n        sm, sd = map(int, start.split(\"-\"))\\n        end = min(leaveAlice, leaveBob)\\n        em, ed = map(int, end.split(\"-\"))\\n        res = 0\\n        for m in range(sm + 1, em):\\n            res += days[m - 1]\\n        if em > sm:\\n            res += days[sm - 1] - sd + ed + 1\\n        elif em == sm:\\n            res += max(ed - sd + 1, 0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588050,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        arr = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        for i in range(1,12):                #to store total days after i months\\n            arr[i]+=arr[i-1]\\n        arr.insert(0,0)\\n        #converting months into days\\n        a = arr[int(arriveAlice[0:2])-1] + int(arriveAlice[3:])                \\n        b = arr[int(leaveAlice[0:2])-1] + int(leaveAlice[3:])\\n        c = arr[int(arriveBob[0:2])-1] + int(arriveBob[3:])\\n        d = arr[int(leaveBob[0:2])-1] + int(leaveBob[3:])\\n        # print(a,b,c,d)\\n        if a<c:               #if alice arrives before bob arrives\\n            if b<c:           #if alice leaves before bob arrives\\n                return 0\\n            if b>=d:          #if alice leaves after bob leaves\\n                return d-c+1\\n            if b<d:            #if bob leaves after alice leaves\\n                return b-c+1\\n        else:                      #reverse the conditions\\n            if d<a:\\n                return 0\\n            if d>=b:\\n                return b-a+1\\n            if d<b:\\n                return d-a+1",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        arr = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        for i in range(1,12):                #to store total days after i months\\n            arr[i]+=arr[i-1]\\n        arr.insert(0,0)\\n        #converting months into days\\n        a = arr[int(arriveAlice[0:2])-1] + int(arriveAlice[3:])                \\n        b = arr[int(leaveAlice[0:2])-1] + int(leaveAlice[3:])\\n        c = arr[int(arriveBob[0:2])-1] + int(arriveBob[3:])\\n        d = arr[int(leaveBob[0:2])-1] + int(leaveBob[3:])\\n        # print(a,b,c,d)\\n        if a<c:               #if alice arrives before bob arrives\\n            if b<c:           #if alice leaves before bob arrives\\n                return 0\\n            if b>=d:          #if alice leaves after bob leaves\\n                return d-c+1\\n            if b<d:            #if bob leaves after alice leaves\\n                return b-c+1\\n        else:                      #reverse the conditions\\n            if d<a:\\n                return 0\\n            if d>=b:\\n                return b-a+1\\n            if d<b:\\n                return d-a+1",
                "codeTag": "Java"
            },
            {
                "id": 2591264,
                "title": "python-c-java-beginner-level-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q2409. Count Days Spent Together***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def countDaysTogether(self, a1: str, l1: str, a2: str, l2: str) -> int:\\n        def dateConvetor(date:str)->int:\\n            month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n            m,d=int(date[:2]),int(date[3:])\\n            return sum(month[i] for i in range(m - 1)) + d\\n        \\n        ar1=dateConvetor(a1)   \\n        le1=dateConvetor(l1)\\n        ar2=dateConvetor(a2)\\n        le2=dateConvetor(l2)\\n        overlap=min(le1,le2)-max(ar1,ar2)+1\\n        return max(0,overlap)\\n```\\n**Runtime:**  74 ms\\t\\n**Memory Usage:**  17.6 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int a1 = Days(arriveAlice);\\n        int l1 = Days(leaveAlice);\\n        int a2 = Days(arriveBob);\\n        int l2 = Days(leaveBob);\\n        if(l1 < a2 || l2 < a1) return 0;\\n        return Math.abs(Math.max(a1, a2)-Math.min(l1, l2))+1;\\n    }\\n    private int Days(String str){\\n        int[] month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int sum=0,m=Integer.valueOf(str.substring(0,2)),d=Integer.valueOf(str.substring(3,5));\\n        for(int i=0;i<m-1;i++)\\n            sum+=month[i];\\n        return d+sum;\\n    }\\n}\\n```\\n**Runtime:**  1 ms\\t\\t\\n**Memory Usage:**  41 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int dateconvert(string s)\\n    {\\n        vector<int> month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int sum=0,m=stoi(s.substr(0,2)),d=stoi(s.substr(3,2));\\n        for(int i=0;i<m-1;i++)\\n            sum+=month[i];\\n        return (sum+d);\\n    }\\n    \\n    \\n    int countDaysTogether(string aA, string lA, string aB, string lB) {\\n        int a1=dateconvert(aA),a2=dateconvert(aB),l1=dateconvert(lA),l2=dateconvert(lB);\\n        return max(0,min(l1,l2)-max(a1,a2)+1);\\n        \\n    }\\n};\\n```\\n**Runtime:** 0 ms\\t\\n**Memory Usage:**  6 MB\\t\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, a1: str, l1: str, a2: str, l2: str) -> int:\\n        def dateConvetor(date:str)->int:\\n            month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n            m,d=int(date[:2]),int(date[3:])\\n            return sum(month[i] for i in range(m - 1)) + d\\n        \\n        ar1=dateConvetor(a1)   \\n        le1=dateConvetor(l1)\\n        ar2=dateConvetor(a2)\\n        le2=dateConvetor(l2)\\n        overlap=min(le1,le2)-max(ar1,ar2)+1\\n        return max(0,overlap)\\n```\n```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int a1 = Days(arriveAlice);\\n        int l1 = Days(leaveAlice);\\n        int a2 = Days(arriveBob);\\n        int l2 = Days(leaveBob);\\n        if(l1 < a2 || l2 < a1) return 0;\\n        return Math.abs(Math.max(a1, a2)-Math.min(l1, l2))+1;\\n    }\\n    private int Days(String str){\\n        int[] month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int sum=0,m=Integer.valueOf(str.substring(0,2)),d=Integer.valueOf(str.substring(3,5));\\n        for(int i=0;i<m-1;i++)\\n            sum+=month[i];\\n        return d+sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int dateconvert(string s)\\n    {\\n        vector<int> month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int sum=0,m=stoi(s.substr(0,2)),d=stoi(s.substr(3,2));\\n        for(int i=0;i<m-1;i++)\\n            sum+=month[i];\\n        return (sum+d);\\n    }\\n    \\n    \\n    int countDaysTogether(string aA, string lA, string aB, string lB) {\\n        int a1=dateconvert(aA),a2=dateconvert(aB),l1=dateconvert(lA),l2=dateconvert(lB);\\n        return max(0,min(l1,l2)-max(a1,a2)+1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588517,
                "title": "c-easy-to-understand-o-1-solution",
                "content": "**just convert the given date into the number in year**\\n```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n\\t\\t//no. of days elapsed after each months\\n        vector<int> hs={0,0,31,59,90,120,151,181,212,243,273,304,334};\\n\\t\\t\\n        int aliceArrive=hs[(arriveAlice[0]-\\'0\\')*10+(arriveAlice[1]-\\'0\\')]+((arriveAlice[3]-\\'0\\')*10+(arriveAlice[4]-\\'0\\'));\\n        int aliceLeave=hs[(leaveAlice[0]-\\'0\\')*10+(leaveAlice[1]-\\'0\\')]+((leaveAlice[3]-\\'0\\')*10+(leaveAlice[4]-\\'0\\'));\\n        int bobArrive=hs[(arriveBob[0]-\\'0\\')*10+(arriveBob[1]-\\'0\\')]+((arriveBob[3]-\\'0\\')*10+(arriveBob[4]-\\'0\\'));\\n        int bobLeave=hs[(leaveBob[0]-\\'0\\')*10+(leaveBob[1]-\\'0\\')]+((leaveBob[3]-\\'0\\')*10+(leaveBob[4]-\\'0\\'));\\n\\t\\t\\n         //if either of them is leaving before the arrival of other return 0\\n        if(bobLeave<aliceArrive || aliceLeave<bobArrive)\\n            return 0;\\n        return min(aliceLeave,bobLeave)-max(aliceArrive,bobArrive)+1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n\\t\\t//no. of days elapsed after each months\\n        vector<int> hs={0,0,31,59,90,120,151,181,212,243,273,304,334}",
                "codeTag": "Java"
            },
            {
                "id": 2588442,
                "title": "easy-simple-with-dates",
                "content": "```\\nvar countDaysTogether = function(arriveAlice, leaveAlice, arriveBob, leaveBob) {\\n    \\n  const arriveAliceDate = new Date(\\'2001-\\'+arriveAlice);\\n  const leaveAliceDate = new Date(\\'2001-\\'+leaveAlice);\\n  const arriveBobDate = new Date(\\'2001-\\'+arriveBob);\\n  const leaveBobDate = new Date(\\'2001-\\'+leaveBob);\\n  \\n  let arriveMax = new Date(Math.max(arriveAliceDate, arriveBobDate));\\n  let leaveMin = new Date(Math.min(leaveAliceDate, leaveBobDate));\\n  \\n  if(arriveMax>leaveMin) return 0;\\n  return Math.floor((leaveMin-arriveMax)/(1000*60*60*24))+1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countDaysTogether = function(arriveAlice, leaveAlice, arriveBob, leaveBob) {\\n    \\n  const arriveAliceDate = new Date(\\'2001-\\'+arriveAlice);\\n  const leaveAliceDate = new Date(\\'2001-\\'+leaveAlice);\\n  const arriveBobDate = new Date(\\'2001-\\'+arriveBob);\\n  const leaveBobDate = new Date(\\'2001-\\'+leaveBob);\\n  \\n  let arriveMax = new Date(Math.max(arriveAliceDate, arriveBobDate));\\n  let leaveMin = new Date(Math.min(leaveAliceDate, leaveBobDate));\\n  \\n  if(arriveMax>leaveMin) return 0;\\n  return Math.floor((leaveMin-arriveMax)/(1000*60*60*24))+1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588190,
                "title": "simple-python-solution-9-lines-of-code",
                "content": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        monthdays = [-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        \\n        start, end = max(arriveAlice, arriveBob), min(leaveAlice, leaveBob)\\n        \\n        start_month, start_day = int(start[:2]), int(start[3:])\\n        end_month, end_day = int(end[:2]), int(end[3:])\\n        \\n        if start > end: return 0\\n        elif start_month == end_month: \\n            return end_day - start_day + 1\\n        else: \\n            return (monthdays[start_month] - start_day) + sum([monthdays[i] for i in range(start_month + 1, end_month)]) + end_day + 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        monthdays = [-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        \\n        start, end = max(arriveAlice, arriveBob), min(leaveAlice, leaveBob)\\n        \\n        start_month, start_day = int(start[:2]), int(start[3:])\\n        end_month, end_day = int(end[:2]), int(end[3:])\\n        \\n        if start > end: return 0\\n        elif start_month == end_month: \\n            return end_day - start_day + 1\\n        else: \\n            return (monthdays[start_month] - start_day) + sum([monthdays[i] for i in range(start_month + 1, end_month)]) + end_day + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587958,
                "title": "c-mm-dd-to-single-no-easy-simple",
                "content": "**NOTE :**\\n**1.** Just **Read solution 1 time no need to see other Solutions**\\n**2. Don\\'t afraid with size of code** It\\'s **long for easy understanding purpose** only\\n\\n**Solution :**\\nhere I had tried to **reperesent perticular day on number line or say absolute value**\\nlike,\\n**`Jan-01` => 1**\\n**`Jan-15` => 15**\\n**`Feb-01` => 32** (1 + total days of jan)\\n**`Feb-28` => 59** (28 + total days of jan)\\n**`Mar-05` => 64** (5 + total days of jan + total days of feb)\\n\\nso this way we get **all days in absolute value** manner\\n\\n[...,BobAriveAbsoluteDay, AliceAriveAbsoluteDay, ...,BobLeaveAbsoluteDay, AliceLeaveAbsoluteDay,...]\\n\\nat last we have to find common absolute days so\\n\\nthis common days are **start from `max(AliceAriveAbsoluteDay, BobAriveAbsoluteDay)`** and **end at `min(AliceLeaveAbsoluteDay, BobLeaveAbsoluteDay)`**\\n\\n**`ans = min(AliceLeaveAbsoluteDay, BobLeaveAbsoluteDay) - max(AliceAriveAbsoluteDay, BobAriveAbsoluteDay) + 1`**\\n\\nedge case **common days never be negative** so take care of it\\n\\nso final **`ans = max(0, min(AliceLeaveAbsoluteDay, BobLeaveAbsoluteDay) - max(AliceAriveAbsoluteDay, BobAriveAbsoluteDay) + 1)`**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>daysInMonth = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n                             // Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n\\n        int AliceAriveMonth = stoi(arriveAlice.substr(0, 2));\\n        int AliceAriveDay = stoi(arriveAlice.substr(3, 2));\\n        int AliceLeaveMonth = stoi(leaveAlice.substr(0, 2));\\n        int AliceLeaveDay = stoi(leaveAlice.substr(3, 2));\\n\\n        int BobAriveMonth = stoi(arriveBob.substr(0, 2));\\n        int BobAriveDay = stoi(arriveBob.substr(3, 2));\\n        int BobLeaveMonth = stoi(leaveBob.substr(0, 2));\\n        int BobLeaveDay = stoi(leaveBob.substr(3, 2));\\n\\n        int AliceAriveAbsoluteDay = 0;\\n        for (int m = 1; m < AliceAriveMonth; m++)\\n            AliceAriveAbsoluteDay += daysInMonth[m];\\n        AliceAriveAbsoluteDay += AliceAriveDay;\\n\\n        int BobAriveAbsoluteDay = 0;\\n        for (int m = 1; m < BobAriveMonth; m++)\\n            BobAriveAbsoluteDay += daysInMonth[m];\\n        BobAriveAbsoluteDay += BobAriveDay;\\n\\n        int AliceLeaveAbsoluteDay = 0;\\n        for (int m = 1; m < AliceLeaveMonth; m++)\\n            AliceLeaveAbsoluteDay += daysInMonth[m];\\n        AliceLeaveAbsoluteDay += AliceLeaveDay;\\n\\n        int BobLeaveAbsoluteDay = 0;\\n        for (int m = 1; m < BobLeaveMonth; m++)\\n            BobLeaveAbsoluteDay += daysInMonth[m];\\n        BobLeaveAbsoluteDay += BobLeaveDay;\\n\\n        return max(0, min(AliceLeaveAbsoluteDay, BobLeaveAbsoluteDay) - max(AliceAriveAbsoluteDay, BobAriveAbsoluteDay) + 1);\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/09637eca-5b75-4812-b99e-47dd91776279_1663434278.329717.png)\\n\\n\\n**If find Helpful Upvote It \\uD83D\\uDC4D**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>daysInMonth = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n                             // Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n\\n        int AliceAriveMonth = stoi(arriveAlice.substr(0, 2));\\n        int AliceAriveDay = stoi(arriveAlice.substr(3, 2));\\n        int AliceLeaveMonth = stoi(leaveAlice.substr(0, 2));\\n        int AliceLeaveDay = stoi(leaveAlice.substr(3, 2));\\n\\n        int BobAriveMonth = stoi(arriveBob.substr(0, 2));\\n        int BobAriveDay = stoi(arriveBob.substr(3, 2));\\n        int BobLeaveMonth = stoi(leaveBob.substr(0, 2));\\n        int BobLeaveDay = stoi(leaveBob.substr(3, 2));\\n\\n        int AliceAriveAbsoluteDay = 0;\\n        for (int m = 1; m < AliceAriveMonth; m++)\\n            AliceAriveAbsoluteDay += daysInMonth[m];\\n        AliceAriveAbsoluteDay += AliceAriveDay;\\n\\n        int BobAriveAbsoluteDay = 0;\\n        for (int m = 1; m < BobAriveMonth; m++)\\n            BobAriveAbsoluteDay += daysInMonth[m];\\n        BobAriveAbsoluteDay += BobAriveDay;\\n\\n        int AliceLeaveAbsoluteDay = 0;\\n        for (int m = 1; m < AliceLeaveMonth; m++)\\n            AliceLeaveAbsoluteDay += daysInMonth[m];\\n        AliceLeaveAbsoluteDay += AliceLeaveDay;\\n\\n        int BobLeaveAbsoluteDay = 0;\\n        for (int m = 1; m < BobLeaveMonth; m++)\\n            BobLeaveAbsoluteDay += daysInMonth[m];\\n        BobLeaveAbsoluteDay += BobLeaveDay;\\n\\n        return max(0, min(AliceLeaveAbsoluteDay, BobLeaveAbsoluteDay) - max(AliceAriveAbsoluteDay, BobAriveAbsoluteDay) + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592872,
                "title": "c-count-the-number-of-days-till-that-date-beats-100-submission",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>v={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    // function to return total number of days from the starting of the year till given date\\n    int cnt(string a){\\n        int no=0,x=(a[0]-\\'0\\')*10+a[1]-\\'0\\';\\n        no=accumulate(v.begin(),v.begin()+x-1,0);\\n        x=(a[3]-\\'0\\')*10+a[4]-\\'0\\';\\n        no+=x;\\n        return no;\\n    }\\n    int countDaysTogether(string a, string al, string b, string bl) {\\n        int x = cnt(a), y = cnt(b), x2 = cnt(al), y2= cnt(bl);\\n        //max(x,y)----> the day on which the second person arrive\\n        // min(x2,y2) ---> the day on which the first person leave\\n        int ans=max(0,min(x2,y2)-max(x,y)+1); // we took 0 here so that if the intersection is negative or if they didn\\'t spend a single day together then answer will automatically becomes zero\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int>v={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}",
                "codeTag": "Java"
            },
            {
                "id": 2587983,
                "title": "most-stupid-and-time-consuming-problem",
                "content": "How can leetcode accept such questions and mark them as easy?\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2587978,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int countDaysTogether(String aA, String lA, String aB, String lB) {\\n         String from = \"\";\\n         if(aA.compareTo(aB) <= 0) {\\n             from = aB;\\n         }else{\\n             from = aA;\\n         }\\n        String to = \"\";\\n        if(lA.compareTo(lB) <= 0) {\\n             to = lA;\\n         }else{\\n             to = lB;\\n         }\\n        int[] days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int aM = Integer.parseInt(from.substring(0,2));   // aM = arriveMonth\\n        int aD = Integer.parseInt(from.substring(3));    // aD = arriveDate\\n        int lM = Integer.parseInt(to.substring(0,2));    //lM = leaveMonth\\n        int lD = Integer.parseInt(to.substring(3));      //lD = leaveDate\\n        if(lM < aM) return 0;                                  \\n        else if(aM == lM && aD>lD) return 0;        \\n        else if(aM == lM && aD<=lD) {\\n            return lD-aD+1;\\n        }else{\\n           int k = lM-aM-1;\\n            int cntDays = 0;\\n            int temp = aM;\\n            while(k-->0) {\\n                cntDays+=days[temp++];\\n            }\\n            return cntDays+(days[aM-1]-aD)+lD+1;\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDaysTogether(String aA, String lA, String aB, String lB) {\\n         String from = \"\";\\n         if(aA.compareTo(aB) <= 0) {\\n             from = aB;\\n         }else{\\n             from = aA;\\n         }\\n        String to = \"\";\\n        if(lA.compareTo(lB) <= 0) {\\n             to = lA;\\n         }else{\\n             to = lB;\\n         }\\n        int[] days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int aM = Integer.parseInt(from.substring(0,2));   // aM = arriveMonth\\n        int aD = Integer.parseInt(from.substring(3));    // aD = arriveDate\\n        int lM = Integer.parseInt(to.substring(0,2));    //lM = leaveMonth\\n        int lD = Integer.parseInt(to.substring(3));      //lD = leaveDate\\n        if(lM < aM) return 0;                                  \\n        else if(aM == lM && aD>lD) return 0;        \\n        else if(aM == lM && aD<=lD) {\\n            return lD-aD+1;\\n        }else{\\n           int k = lM-aM-1;\\n            int cntDays = 0;\\n            int temp = aM;\\n            while(k-->0) {\\n                cntDays+=days[temp++];\\n            }\\n            return cntDays+(days[aM-1]-aD)+lD+1;\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587884,
                "title": "java-explained",
                "content": "```\\nclass Solution\\n{\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob)\\n    {\\n        int[] days = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        String ar, dp; // ar is the latest arrival date, dp is the earliest departure date\\n        \\n        ar = arriveAlice.compareTo(arriveBob) <= 0 ? arriveBob : arriveAlice;\\n        \\n        dp = leaveAlice.compareTo(leaveBob) <= 0 ? leaveAlice : leaveBob;\\n        \\n        int ret = 1;\\n        \\n        if(ar.compareTo(dp) > 0) // ar is later than dp\\n            return 0;\\n\\n        int amm = Integer.parseInt(ar.substring(0,2)), dmm = Integer.parseInt(dp.substring(0,2)), add = Integer.parseInt(ar.substring(3)), ddd = Integer.parseInt(dp.substring(3));\\n        // Month and day separated for arr and dp values\\n\\t\\t\\n        for(int i = amm+1; i < dmm; i++)\\n            ret += days[i]; // Days of months between arrival and departure(exclusive)\\n        \\n        if(amm == dmm) // If arrival and departure in the same month, day difference is departure - arrival\\n            ret += (ddd-add);\\n        \\n        else // If arrival and departure in different months, day difference is number of days remaining in the arrival month + departure date\\n        {\\n            ret += days[amm]-add;\\n            ret += ddd;\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```\\n\\n**Dry run**\\n\\nConsider the TC : arriveAlice = \"08-15\", leaveAlice = \"08-18\", arriveBob = \"08-16\", leaveBob = \"08-19\" .\\n`ar` would be `08-16` and `dp` = `08-18`\\n`\"08-16\".compareTo(\"08-18\")` is < 0 so we do not return yet. \\nHere, amm, dmm, are equal so the loop doesn\\'t add to the `ret` value.\\nAnd hence the day difference is simply 18-16 (3 days, hence ret initialized with 1).\\n\\nOther case is when the months are different and the difference in dates would be calculated as `(31/30/28) - add + ddd`\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob)\\n    {\\n        int[] days = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        String ar, dp; // ar is the latest arrival date, dp is the earliest departure date\\n        \\n        ar = arriveAlice.compareTo(arriveBob) <= 0 ? arriveBob : arriveAlice;\\n        \\n        dp = leaveAlice.compareTo(leaveBob) <= 0 ? leaveAlice : leaveBob;\\n        \\n        int ret = 1;\\n        \\n        if(ar.compareTo(dp) > 0) // ar is later than dp\\n            return 0;\\n\\n        int amm = Integer.parseInt(ar.substring(0,2)), dmm = Integer.parseInt(dp.substring(0,2)), add = Integer.parseInt(ar.substring(3)), ddd = Integer.parseInt(dp.substring(3));\\n        // Month and day separated for arr and dp values\\n\\t\\t\\n        for(int i = amm+1; i < dmm; i++)\\n            ret += days[i]; // Days of months between arrival and departure(exclusive)\\n        \\n        if(amm == dmm) // If arrival and departure in the same month, day difference is departure - arrival\\n            ret += (ddd-add);\\n        \\n        else // If arrival and departure in different months, day difference is number of days remaining in the arrival month + departure date\\n        {\\n            ret += days[amm]-add;\\n            ret += ddd;\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601983,
                "title": "very-easy-question-visual-explanation-100",
                "content": "This problem is very easy to understand. Just think it deeply and you will surely understand the working. Below I have discussed it in very easy steps.\\n\\n![image](https://assets.leetcode.com/users/images/3d5fd148-7390-47d6-a542-068201b541d6_1663689554.302706.jpeg)\\n\\n**Steps:**\\n* As you can see in the above image, I have marked **circles on 16 Aug (arrive) and 18 Aug(Leave)**.\\n* This is because Bob arrived late, so Alice and Bob will meet late on 16 Aug, or we can say that **take the max from the arrival** of Alice and Bob and store it on the ***start*** variable.\\n* And, Alice has left the place earlier, so their last meet up will be on 18 Aug or we can say that **take the min from their leave** and store it on ***end*** variable.\\n* Now, by using some common sense, we have to\\xA0find the answer, since we have ***start*** and ***end***.\\xA0\\n\\n**Code:**\\n```\\nclass Solution:\\n    def countDaysTogether(self, arAl: str, lAl: str, arBo: str, lBo: str) -> int:\\n        months = [-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        start = max(arAl, arBo)\\n        end = min(lAl, lBo)\\n\\n        startDay = int(start[3:])\\n        startMonth = int(start[:2])\\n        endDay = int(end[3:])\\n        endMonth = int(end[:2])\\n        \\n        if start > end:\\n            return 0\\n        if startMonth == endMonth:\\n            return endDay-startDay+1\\n        elif startMonth < endMonth:\\n            return months[startMonth]-startDay + endDay + 1 + sum(months[m] for m in range(startMonth+1, endMonth))\\n```\\n\\nCheck out: [https://github.com/Iamtripathisatyam](https://github.com/Iamtripathisatyam)\\nThanks to @lcshiung",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arAl: str, lAl: str, arBo: str, lBo: str) -> int:\\n        months = [-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        start = max(arAl, arBo)\\n        end = min(lAl, lBo)\\n\\n        startDay = int(start[3:])\\n        startMonth = int(start[:2])\\n        endDay = int(end[3:])\\n        endMonth = int(end[:2])\\n        \\n        if start > end:\\n            return 0\\n        if startMonth == endMonth:\\n            return endDay-startDay+1\\n        elif startMonth < endMonth:\\n            return months[startMonth]-startDay + endDay + 1 + sum(months[m] for m in range(startMonth+1, endMonth))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593566,
                "title": "c-day-of-year-clean-code",
                "content": "### Solution 1: day of year\\n\\nWe convert each event into \"day of the year\" using a prefixsum for the days in the months before. Then we compute the day when the earlier of the two leaves and subtract from that the day when the later of the day arrieves.\\n\\n```\\n    static int dayOfYear(int m, int d) {\\n        constexpr array<int, 12> dm = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n        return dm[m - 1] + d;\\n    }\\n    \\n    static int dayOfYear(const string& mmdd) {\\n        return dayOfYear(stoi(mmdd.substr(0, 2)), stoi(mmdd.substr(3, 2)));\\n    }\\n\\n    static int countDaysTogether(const string& arriveAlice, const string& leaveAlice,\\n                                 const string& arriveBob, const string& leaveBob) {\\n        const int aa = dayOfYear(arriveAlice);\\n        const int al = dayOfYear(leaveAlice);\\n        const int ba = dayOfYear(arriveBob);\\n        const int bl = dayOfYear(leaveBob);\\n        return max(0, min(al, bl) - max(aa, ba) + 1);\\n    }\\n```\\t\\n\\n_As always: Feedback, comments, and questions are welcome. Please upvote if you like the solution._",
                "solutionTags": [],
                "code": "```\\n    static int dayOfYear(int m, int d) {\\n        constexpr array<int, 12> dm = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n        return dm[m - 1] + d;\\n    }\\n    \\n    static int dayOfYear(const string& mmdd) {\\n        return dayOfYear(stoi(mmdd.substr(0, 2)), stoi(mmdd.substr(3, 2)));\\n    }\\n\\n    static int countDaysTogether(const string& arriveAlice, const string& leaveAlice,\\n                                 const string& arriveBob, const string& leaveBob) {\\n        const int aa = dayOfYear(arriveAlice);\\n        const int al = dayOfYear(leaveAlice);\\n        const int ba = dayOfYear(arriveBob);\\n        const int bl = dayOfYear(leaveBob);\\n        return max(0, min(al, bl) - max(aa, ba) + 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588418,
                "title": "java-with-zero-maths-simple-if-else-easy-to-read",
                "content": "```\\nclass Solution {\\n  // we create  the date is nth day of the year then we simply subtract the problem to intersection part of both or independent to each other\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int arr [] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int month[] = new int[arr.length+1];\\n        for(int i=1;i<month.length;i++){\\n            month[i] = month[i-1] + arr[i-1];\\n        }\\n        \\n \\n        String [] sarri = arriveAlice.split(\"-\");\\n        String [] sarrib = arriveBob.split(\"-\");\\n        String [] sle = leaveAlice.split(\"-\");\\n        String [] sleb = leaveBob.split(\"-\");\\n        \\n        int arri[] = new int[2];\\n        int arrib[] = new int[2];\\n        int le[] = new int[2];\\n        int leb[] = new int[2];\\n        for (int i = 0; i < arri.length; i++) {\\n            arri[i] = Integer.parseInt(sarri[i]);\\n            arrib[i] = Integer.parseInt(sarrib[i]);\\n            le[i] = Integer.parseInt(sle[i]);\\n            leb[i] = Integer.parseInt(sleb[i]);\\n        }\\n       \\n        \\n        int daa = month[arri[0]-1] + arri[1];\\n        int dab = month[arrib[0]-1] + arrib[1];\\n        int dla = month[le[0]-1] + le[1];\\n        int dlb = month[leb[0]-1] + leb[1];\\n        \\n//         System.out.println(daa + \" \" + dla);\\n//         System.out.println(dab + \" \"  + dlb);\\n        if(daa==dlb&&dab==dla){\\n            return 1;\\n        }\\n        else if(daa>=dlb||dab>=dla){\\n            return 0;\\n        }\\n        else if(dab<daa&&dlb>dla){\\n            return dla - daa +1;\\n        }\\n        else if(daa<dab&&dla>dlb){\\n             return dlb - dab +1;\\n        }\\n        else{\\n            if(dla > dlb){\\n                return dlb - daa + 1;\\n            }\\n            else{\\n                return dla - dab + 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n  // we create  the date is nth day of the year then we simply subtract the problem to intersection part of both or independent to each other\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int arr [] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int month[] = new int[arr.length+1];\\n        for(int i=1;i<month.length;i++){\\n            month[i] = month[i-1] + arr[i-1];\\n        }\\n        \\n \\n        String [] sarri = arriveAlice.split(\"-\");\\n        String [] sarrib = arriveBob.split(\"-\");\\n        String [] sle = leaveAlice.split(\"-\");\\n        String [] sleb = leaveBob.split(\"-\");\\n        \\n        int arri[] = new int[2];\\n        int arrib[] = new int[2];\\n        int le[] = new int[2];\\n        int leb[] = new int[2];\\n        for (int i = 0; i < arri.length; i++) {\\n            arri[i] = Integer.parseInt(sarri[i]);\\n            arrib[i] = Integer.parseInt(sarrib[i]);\\n            le[i] = Integer.parseInt(sle[i]);\\n            leb[i] = Integer.parseInt(sleb[i]);\\n        }\\n       \\n        \\n        int daa = month[arri[0]-1] + arri[1];\\n        int dab = month[arrib[0]-1] + arrib[1];\\n        int dla = month[le[0]-1] + le[1];\\n        int dlb = month[leb[0]-1] + leb[1];\\n        \\n//         System.out.println(daa + \" \" + dla);\\n//         System.out.println(dab + \" \"  + dlb);\\n        if(daa==dlb&&dab==dla){\\n            return 1;\\n        }\\n        else if(daa>=dlb||dab>=dla){\\n            return 0;\\n        }\\n        else if(dab<daa&&dlb>dla){\\n            return dla - daa +1;\\n        }\\n        else if(daa<dab&&dla>dlb){\\n             return dlb - dab +1;\\n        }\\n        else{\\n            if(dla > dlb){\\n                return dlb - daa + 1;\\n            }\\n            else{\\n                return dla - dab + 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587959,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int month[13]={0,31,59,90,120,151,181,212,243,273,304,334,365};\\n        int x=month[(arriveAlice[0]-\\'0\\')*10+(arriveAlice[1]-\\'0\\')-1]+(arriveAlice[3]-\\'0\\')*10+(arriveAlice[4]-\\'0\\');\\n        int y=month[(leaveAlice[0]-\\'0\\')*10+(leaveAlice[1]-\\'0\\')-1]+(leaveAlice[3]-\\'0\\')*10+(leaveAlice[4]-\\'0\\');\\n        int a=month[(arriveBob[0]-\\'0\\')*10+(arriveBob[1]-\\'0\\')-1]+(arriveBob[3]-\\'0\\')*10+(arriveBob[4]-\\'0\\');\\n        int b=month[(leaveBob[0]-\\'0\\')*10+(leaveBob[1]-\\'0\\')-1]+(leaveBob[3]-\\'0\\')*10+(leaveBob[4]-\\'0\\');\\n        int k=min(y,b)-max(x,a)+1;\\n        return k<0?0:k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int month[13]={0,31,59,90,120,151,181,212,243,273,304,334,365};\\n        int x=month[(arriveAlice[0]-\\'0\\')*10+(arriveAlice[1]-\\'0\\')-1]+(arriveAlice[3]-\\'0\\')*10+(arriveAlice[4]-\\'0\\');\\n        int y=month[(leaveAlice[0]-\\'0\\')*10+(leaveAlice[1]-\\'0\\')-1]+(leaveAlice[3]-\\'0\\')*10+(leaveAlice[4]-\\'0\\');\\n        int a=month[(arriveBob[0]-\\'0\\')*10+(arriveBob[1]-\\'0\\')-1]+(arriveBob[3]-\\'0\\')*10+(arriveBob[4]-\\'0\\');\\n        int b=month[(leaveBob[0]-\\'0\\')*10+(leaveBob[1]-\\'0\\')-1]+(leaveBob[3]-\\'0\\')*10+(leaveBob[4]-\\'0\\');\\n        int k=min(y,b)-max(x,a)+1;\\n        return k<0?0:k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698314,
                "title": "java-using-standard-time-libraries",
                "content": "```\\nimport java.time.LocalDate;\\nimport java.time.temporal.ChronoUnit;\\n\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        String start = arriveAlice.compareTo(arriveBob) < 0 ? arriveBob : arriveAlice;\\n        String end = leaveAlice.compareTo(leaveBob) < 0 ? leaveAlice : leaveBob;\\n\\n        LocalDate startDate = toLocalDate(start), endDate = toLocalDate(end);\\n\\n        return startDate.isAfter(endDate) ? 0 : (int) ChronoUnit.DAYS.between(startDate, endDate) + 1;\\n    }\\n\\n    private LocalDate toLocalDate(String date) {\\n        return LocalDate.of(2022,Integer.parseInt(date.substring(0, 2)), Integer.parseInt(date.substring(3)));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.time.LocalDate;\\nimport java.time.temporal.ChronoUnit;\\n\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        String start = arriveAlice.compareTo(arriveBob) < 0 ? arriveBob : arriveAlice;\\n        String end = leaveAlice.compareTo(leaveBob) < 0 ? leaveAlice : leaveBob;\\n\\n        LocalDate startDate = toLocalDate(start), endDate = toLocalDate(end);\\n\\n        return startDate.isAfter(endDate) ? 0 : (int) ChronoUnit.DAYS.between(startDate, endDate) + 1;\\n    }\\n\\n    private LocalDate toLocalDate(String date) {\\n        return LocalDate.of(2022,Integer.parseInt(date.substring(0, 2)), Integer.parseInt(date.substring(3)));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608644,
                "title": "c-easy-to-understand",
                "content": "* Converting String of arrival and departure into equivalent Number from 365 day \\n* Then simply calculating difference \\nLike Min (a2 , b2) means who is leaving first \\nand Max (a1 , b1) means who is coming after \\nand difference between both number is ans \\n```\\nclass Solution {\\nvector<int> month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\npublic:\\n\\t int convert(string s) {\\n        int  cnt=0;\\n\\t\\tint mnt=stoi(s.substr(0, 2))-1, d = stoi(s.substr(3, 2));\\n\\t\\tfor (int i = 0; i < mnt; i++)\\n\\t\\t{\\n\\t\\t\\tcnt += month[i];\\n\\t\\t}\\n\\t\\tcnt+=d;\\n\\t\\treturn cnt;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n\\t\\tint a1=convert(arriveAlice),a2=convert(leaveAlice),b1=convert(arriveBob),b2=convert(leaveBob);\\n\\t\\tint ans= (min(a2, b2)) - (max(a1, b1)) + 1;\\n\\t\\tif (ans < 0)\\n\\t\\t{\\n\\t\\t\\tans = 0;\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\nvector<int> month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\npublic:\\n\\t int convert(string s) {\\n        int  cnt=0;\\n\\t\\tint mnt=stoi(s.substr(0, 2))-1, d = stoi(s.substr(3, 2));\\n\\t\\tfor (int i = 0; i < mnt; i++)\\n\\t\\t{\\n\\t\\t\\tcnt += month[i];\\n\\t\\t}\\n\\t\\tcnt+=d;\\n\\t\\treturn cnt;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n\\t\\tint a1=convert(arriveAlice),a2=convert(leaveAlice),b1=convert(arriveBob),b2=convert(leaveBob);\\n\\t\\tint ans= (min(a2, b2)) - (max(a1, b1)) + 1;\\n\\t\\tif (ans < 0)\\n\\t\\t{\\n\\t\\t\\tans = 0;\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600563,
                "title": "the-most-easiest-soln-of-this-problem-java",
                "content": "```\\n    public int countDaysTogether(String aa, String la, String ab, String lb) {\\n        int a[]= new int[]{0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        for(int i=1;i<a.length;i++) a[i]+=a[i-1];\\n        \\n        int aA = a[Integer.parseInt(aa.substring(0,2))-1] +Integer.parseInt(aa.substring(3,5));\\n        int lA = a[Integer.parseInt(la.substring(0,2))-1] +Integer.parseInt(la.substring(3,5));\\n        int aB = a[Integer.parseInt(ab.substring(0,2))-1] +Integer.parseInt(ab.substring(3,5));\\n        int lB = a[Integer.parseInt(lb.substring(0,2))-1] +Integer.parseInt(lb.substring(3,5));\\n        \\n      return Math.max(Math.min(lA,lB) - Math.max(aA,aB) + 1,0);        \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\n    public int countDaysTogether(String aa, String la, String ab, String lb) {\\n        int a[]= new int[]{0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        for(int i=1;i<a.length;i++) a[i]+=a[i-1];\\n        \\n        int aA = a[Integer.parseInt(aa.substring(0,2))-1] +Integer.parseInt(aa.substring(3,5));\\n        int lA = a[Integer.parseInt(la.substring(0,2))-1] +Integer.parseInt(la.substring(3,5));\\n        int aB = a[Integer.parseInt(ab.substring(0,2))-1] +Integer.parseInt(ab.substring(3,5));\\n        int lB = a[Integer.parseInt(lb.substring(0,2))-1] +Integer.parseInt(lb.substring(3,5));\\n        \\n      return Math.max(Math.min(lA,lB) - Math.max(aA,aB) + 1,0);        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2594103,
                "title": "python3-dict-6-lines-w-explan-t-m-32-ms-13-4-mb",
                "content": "```\\nclass Solution:         # Here\\'s the plan:\\n                        #\\n                        # 1) Change each date string to the integer day-of-the-year\\n                        #    1a. split the month and day of the month;\\n                        #    1b. use the dict to determine the days in previous months;\\n                        #    1c. add the integer in 1b. to the days in the month.\\n                        #    \\n                        # 2) Determine the overlap (if any) for their respective leave and arrive dates\\n\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n\\n        d = {1:0,   2:31,  3:59,   4:90,   5:120,  6:151,           # <-- 1b.\\n             7:181, 8:212, 9:243, 10:273, 11:304, 12:334}\\n\\n        def days(date):\\n            mon, day = date.split(\\'-\\')                              # <-- 1a.      \\n            return d[int(mon)]+int(day)                             # <-- 1c.\\n\\n        arrive, leave = (max(days(arriveAlice),days(arriveBob)),    # <-- 2).\\n                         min(days(leaveAlice ),days(leaveBob )))\\n        \\n        return  max(leave-arrive+1,0)",
                "solutionTags": [],
                "code": "class Solution:         # Here\\'s the plan:\\n                        #\\n                        # 1) Change each date string to the integer day-of-the-year\\n                        #    1a. split the month and day of the month;\\n                        #    1b. use the dict to determine the days in previous months;\\n                        #    1c. add the integer in 1b. to the days in the month.\\n                        #    \\n                        # 2) Determine the overlap (if any) for their respective leave and arrive dates\\n\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n\\n        d = {1:0,   2:31,  3:59,   4:90,   5:120,  6:151,           # <-- 1b.\\n             7:181, 8:212, 9:243, 10:273, 11:304, 12:334}",
                "codeTag": "Java"
            },
            {
                "id": 2592385,
                "title": "c-explained-logic-two-approach",
                "content": "**LOGIC:**\\n* days overlap of Alice(a) and Bob(b)\\'s stay is the duration between whoever came late and left first.\\n* If someone already left before other\\'s arrival then there will be no overlap.\\n\\n```\\nwe need to convert date into day\\n\\teg; 01-15 is 15th day of the year.\\n\\teg. 02-12 = days in [month - 1] + 15 \\n\\t\\t\\t  = days [january] + 15 \\n\\t\\t      = 31 + 15 = 46th day of year. \\n```\\n\\n**Approach 1**\\n\\n```\\nclass Solution {\\npublic:\\n    int calendar[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    int convertToDay (string s)\\n    {\\n        int month = (s[0] - \\'0\\') * 10 + (s[1] - \\'0\\'); //eg \"12\" == 1 * 10 + 2\\n        int day = (s[3] - \\'0\\') * 10 + (s[4] - \\'0\\');\\n        \\n        //count total no. of day\\n        while (--month) //decrementing month first coz we don\\'t want to add current month\\'s days eg: (01-12), it\\'s 12th day of year not 31+12th!\\n        {\\n            day += calendar[month];\\n        }\\n        return day;\\n    }\\n    int countDaysTogether(string aa, string la, string ab, string lb) {\\n        \\n        string lastArrive = max(aa, ab);\\n        string firstLeave = min(la, lb);\\n        \\n        if (lastArrive > firstLeave) return 0; \\n        \\n        int arrival = convertToDay(a); \\n        int departure = convertToDay(l);\\n        \\n        return (departure - arrival) + 1; //+1 coz of inclusive\\n    }\\n};\\n```\\n\\n**Approach 2:** \\nsame logic just using presum and stl\\n\\n    int countDaysTogether(string aa, string la, string ab, string lb) {\\n        int month[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        //presum\\n        for (int i = 1; i < 13; i++)\\n            month[i] += month[i-1];\\n        \\n        string a = max(aa, ab);\\n        string l = min(la, lb);\\n        \\n        if (a > l)\\n            return 0; \\n        \\n        int arrival = month[stoi(a.substr(0,2)) - 1] + stoi(a.substr(3)); //month->days + day\\n        int departure = month[stoi(l.substr(0,2)) - 1] + stoi(l.substr(3)) ; \\n        \\n        return (departure - arrival + 1);\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nwe need to convert date into day\\n\\teg; 01-15 is 15th day of the year.\\n\\teg. 02-12 = days in [month - 1] + 15 \\n\\t\\t\\t  = days [january] + 15 \\n\\t\\t      = 31 + 15 = 46th day of year. \\n```\n```\\nclass Solution {\\npublic:\\n    int calendar[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    int convertToDay (string s)\\n    {\\n        int month = (s[0] - \\'0\\') * 10 + (s[1] - \\'0\\'); //eg \"12\" == 1 * 10 + 2\\n        int day = (s[3] - \\'0\\') * 10 + (s[4] - \\'0\\');\\n        \\n        //count total no. of day\\n        while (--month) //decrementing month first coz we don\\'t want to add current month\\'s days eg: (01-12), it\\'s 12th day of year not 31+12th!\\n        {\\n            day += calendar[month];\\n        }\\n        return day;\\n    }\\n    int countDaysTogether(string aa, string la, string ab, string lb) {\\n        \\n        string lastArrive = max(aa, ab);\\n        string firstLeave = min(la, lb);\\n        \\n        if (lastArrive > firstLeave) return 0; \\n        \\n        int arrival = convertToDay(a); \\n        int departure = convertToDay(l);\\n        \\n        return (departure - arrival) + 1; //+1 coz of inclusive\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590798,
                "title": "c-easy-to-understand-100",
                "content": "```\\nint countDaysTogether(string aA, string lA, string aB, string lB) {\\n        int aam = 10*(aA[0]-\\'0\\')+(aA[1]-\\'0\\');\\n        int aad = 10*(aA[3]-\\'0\\')+(aA[4]-\\'0\\');\\n        \\n        int alm = 10*(lA[0]-\\'0\\')+(lA[1]-\\'0\\');\\n        int ald = 10*(lA[3]-\\'0\\')+(lA[4]-\\'0\\');\\n        \\n        int bam = 10*(aB[0]-\\'0\\')+(aB[1]-\\'0\\');\\n        int bad = 10*(aB[3]-\\'0\\')+(aB[4]-\\'0\\');\\n        \\n        int blm = 10*(lB[0]-\\'0\\')+(lB[1]-\\'0\\');\\n        int bld = 10*(lB[3]-\\'0\\')+(lB[4]-\\'0\\');\\n        \\n        cout<<aam<<\" \"<<alm<<endl;\\n        cout<<bam<<\" \"<<blm<<endl;\\n\\n        int arr[13] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 }; \\n         \\n        int AA = arr[aam-1] + aad;\\n        int AL = arr[alm-1] + ald;\\n        \\n        int BA = arr[bam-1] + bad;\\n        int BL = arr[blm-1] + bld;\\n        int count = 0;\\n        if(AA<=BA){\\n            while(BA<=BL && BA<=AL){\\n                count++;\\n                BA++;\\n            }\\n        }else if(BA<=AA){\\n            while(AA<=AL && AA<=BL){\\n                AA++;\\n                count++;\\n            }\\n        }\\n        return count;      \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countDaysTogether(string aA, string lA, string aB, string lB) {\\n        int aam = 10*(aA[0]-\\'0\\')+(aA[1]-\\'0\\');\\n        int aad = 10*(aA[3]-\\'0\\')+(aA[4]-\\'0\\');\\n        \\n        int alm = 10*(lA[0]-\\'0\\')+(lA[1]-\\'0\\');\\n        int ald = 10*(lA[3]-\\'0\\')+(lA[4]-\\'0\\');\\n        \\n        int bam = 10*(aB[0]-\\'0\\')+(aB[1]-\\'0\\');\\n        int bad = 10*(aB[3]-\\'0\\')+(aB[4]-\\'0\\');\\n        \\n        int blm = 10*(lB[0]-\\'0\\')+(lB[1]-\\'0\\');\\n        int bld = 10*(lB[3]-\\'0\\')+(lB[4]-\\'0\\');\\n        \\n        cout<<aam<<\" \"<<alm<<endl;\\n        cout<<bam<<\" \"<<blm<<endl;\\n\\n        int arr[13] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 }; \\n         \\n        int AA = arr[aam-1] + aad;\\n        int AL = arr[alm-1] + ald;\\n        \\n        int BA = arr[bam-1] + bad;\\n        int BL = arr[blm-1] + bld;\\n        int count = 0;\\n        if(AA<=BA){\\n            while(BA<=BL && BA<=AL){\\n                count++;\\n                BA++;\\n            }\\n        }else if(BA<=AA){\\n            while(AA<=AL && AA<=BL){\\n                AA++;\\n                count++;\\n            }\\n        }\\n        return count;      \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2588315,
                "title": "easy-and-concise-code",
                "content": "**Idea:** Just try to find day ranges in 365 days for both alice and bob and find length of overlapping interval (that is arriving day and leaving day in between 1 and 365)\\n```\\npair<int,int> dm(string x)\\n{\\n    \\n    string s = x.substr(0,2);   // find month\\n    string p = x.substr(3,2);  // find day \\n    \\n    int a = stoi(s);  \\n    int b = stoi(p);\\n    \\n    return {a,b};  \\n     \\n}\\npair<int,int> count(pair<int,int>a,pair<int,int>b)\\n{\\n        int pre[13]={0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        for(int i=1;i<=12;i++)  // store days till ith month\\n            pre[i]+=pre[i-1];  \\n             // arriving day no. b/w 1 to 365\\n        int start =      pre[a.first-1]+a.second+1;  //  days till (a.first-1)th month and a.seocnd days of a.first                                                                          // month\\n          // leaving day b/w 1 to 365\\n       int end = pre[b.first-1]+b.second+1;     // | | ly days till (b.first-1)th month and a.seocnd days of                                                                            //  b.first month\\n    \\n       return {start,end};  \\n    \\n}    \\n    \\n\\n\\n\\nclass Solution {\\npublic:\\n    int countDaysTogether(string a, string b, string x, string y) \\n    {\\n       \\n         auto  l1 = dm(a);  // split arriving day and month for alice\\n         auto l2 = dm(b);  //  split leaving day and month for alice\\n         auto  l3 = dm(x);  // split arriving day and month for bob\\n         auto l4 = dm(y);  // split leaving day and month for bob\\n\\t\\t \\n         auto xx = count(l1,l2);  // range of days for alice\\n        \\n         auto yy = count(l3,l4);  // range of days for bob\\n        \\n\\t\\t// find the overlapping interval\\n        int left = max(xx.first,yy.first);\\n        int right = min(xx.second,yy.second);\\n        if(right-left+1>0)\\n        return right-left+1;\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npair<int,int> dm(string x)\\n{\\n    \\n    string s = x.substr(0,2);   // find month\\n    string p = x.substr(3,2);  // find day \\n    \\n    int a = stoi(s);  \\n    int b = stoi(p);\\n    \\n    return {a,b};  \\n     \\n}\\npair<int,int> count(pair<int,int>a,pair<int,int>b)\\n{\\n        int pre[13]={0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        for(int i=1;i<=12;i++)  // store days till ith month\\n            pre[i]+=pre[i-1];  \\n             // arriving day no. b/w 1 to 365\\n        int start =      pre[a.first-1]+a.second+1;  //  days till (a.first-1)th month and a.seocnd days of a.first                                                                          // month\\n          // leaving day b/w 1 to 365\\n       int end = pre[b.first-1]+b.second+1;     // | | ly days till (b.first-1)th month and a.seocnd days of                                                                            //  b.first month\\n    \\n       return {start,end};  \\n    \\n}    \\n    \\n\\n\\n\\nclass Solution {\\npublic:\\n    int countDaysTogether(string a, string b, string x, string y) \\n    {\\n       \\n         auto  l1 = dm(a);  // split arriving day and month for alice\\n         auto l2 = dm(b);  //  split leaving day and month for alice\\n         auto  l3 = dm(x);  // split arriving day and month for bob\\n         auto l4 = dm(y);  // split leaving day and month for bob\\n\\t\\t \\n         auto xx = count(l1,l2);  // range of days for alice\\n        \\n         auto yy = count(l3,l4);  // range of days for bob\\n        \\n\\t\\t// find the overlapping interval\\n        int left = max(xx.first,yy.first);\\n        int right = min(xx.second,yy.second);\\n        if(right-left+1>0)\\n        return right-left+1;\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588235,
                "title": "c-solution",
                "content": "```\\npublic int CountDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        var result = 0;\\n\\n        var arriveAliceDate = DateTime.Parse(arriveAlice);\\n        var leaveAliceDate = DateTime.Parse(leaveAlice);\\n        var arriveBobDate = DateTime.Parse(arriveBob);\\n        var leaveBobDate = DateTime.Parse(leaveBob);\\n\\n        var date = arriveAliceDate;\\n        while (date <= leaveAliceDate)\\n        {\\n            if (date >= arriveBobDate && date <= leaveBobDate)\\n            {\\n                result++;\\n            }\\n\\n            date = date.AddDays(1);\\n        }\\n\\n        return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int CountDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        var result = 0;\\n\\n        var arriveAliceDate = DateTime.Parse(arriveAlice);\\n        var leaveAliceDate = DateTime.Parse(leaveAlice);\\n        var arriveBobDate = DateTime.Parse(arriveBob);\\n        var leaveBobDate = DateTime.Parse(leaveBob);\\n\\n        var date = arriveAliceDate;\\n        while (date <= leaveAliceDate)\\n        {\\n            if (date >= arriveBobDate && date <= leaveBobDate)\\n            {\\n                result++;\\n            }\\n\\n            date = date.AddDays(1);\\n        }\\n\\n        return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588123,
                "title": "c-easy-to-understand-brute-force",
                "content": "Create a 2D matrix for calender and count the overlapping days\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int days[12]={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int count[13][32];                               //2D matrix to count the overlapping days\\n    \\n    void fillday(int am,int ad,int lm,int ld)\\n    {\\n        if(am==lm)                                   //if arrival and leaving month is same \\n        {\\n            for(int d=ad;d<=ld;d++)\\n                count[am][d]++;\\n            return;\\n        }   \\n        for(int d=ad;d<=days[am-1];d++)              //for arriavl month\\n            count[am][d]++;\\n        for(int m=am+1;m<lm;m++)                     //for months after arrival and before leaving\\n            for(int d=1;d<=days[m-1];d++)            //for all days in that month\\n                count[m][d]++;\\n        for(int d=1;d<=ld;d++)                       //for leaving month\\n            count[lm][d]++;\\n    }\\n    int countDaysTogether(string aa, string la, string ab, string lb) \\n    {\\n        int aam=stoi(aa.substr(0,2)),aad=stoi(aa.substr(3,2)),lam=stoi(la.substr(0,2)),lad=stoi(la.substr(3,2));\\n        int abm=stoi(ab.substr(0,2)),abd=stoi(ab.substr(3,2)),lbm=stoi(lb.substr(0,2)),lbd=stoi(lb.substr(3,2));\\n        int ans=0;\\n        memset(count,0,sizeof(count));\\n        fillday(aam,aad,lam,lad);                    //filling days for Alice\\n        fillday(abm,abd,lbm,lbd);                    //filling days for Bob\\n        \\n        for(int m=1;m<13;m++)\\n            for(int d=1;d<=31;d++)\\n                if(count[m][d]==2)  ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int days[12]={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int count[13][32];                               //2D matrix to count the overlapping days\\n    \\n    void fillday(int am,int ad,int lm,int ld)\\n    {\\n        if(am==lm)                                   //if arrival and leaving month is same \\n        {\\n            for(int d=ad;d<=ld;d++)\\n                count[am][d]++;\\n            return;\\n        }   \\n        for(int d=ad;d<=days[am-1];d++)              //for arriavl month\\n            count[am][d]++;\\n        for(int m=am+1;m<lm;m++)                     //for months after arrival and before leaving\\n            for(int d=1;d<=days[m-1];d++)            //for all days in that month\\n                count[m][d]++;\\n        for(int d=1;d<=ld;d++)                       //for leaving month\\n            count[lm][d]++;\\n    }\\n    int countDaysTogether(string aa, string la, string ab, string lb) \\n    {\\n        int aam=stoi(aa.substr(0,2)),aad=stoi(aa.substr(3,2)),lam=stoi(la.substr(0,2)),lad=stoi(la.substr(3,2));\\n        int abm=stoi(ab.substr(0,2)),abd=stoi(ab.substr(3,2)),lbm=stoi(lb.substr(0,2)),lbd=stoi(lb.substr(3,2));\\n        int ans=0;\\n        memset(count,0,sizeof(count));\\n        fillday(aam,aad,lam,lad);                    //filling days for Alice\\n        fillday(abm,abd,lbm,lbd);                    //filling days for Bob\\n        \\n        for(int m=1;m<13;m++)\\n            for(int d=1;d<=31;d++)\\n                if(count[m][d]==2)  ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588061,
                "title": "simple-c-ans-with-explanation",
                "content": "Okay, I know this question is bit frustating but let me try to help you!\\n\\nSolution-\\nFind who arrived later between bob and alice and who departed first.\\nThis daysPassed function is calculating the number of days from the starting of the year.\\n\\nThe difference between those is our ans, and I\\'m adding 1 because days are inclusive (what if both of them arrived the same day? )\\n```\\nclass Solution {\\npublic:\\n    int daysPassed(string date){\\n        int M = stoi(date.substr(0,2));\\n        int D = stoi(date.substr(3,2));\\n        vector<int>days = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        for(int i = 1; i<M; i++){\\n            D += days[i];\\n        }\\n        return D;\\n    }\\n    \\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int ans = 0;\\n        int day1 = max(daysPassed(arriveAlice),daysPassed(arriveBob) );\\n        int day2 = min(daysPassed(leaveAlice),daysPassed(leaveBob));\\n        ans = (day2 - day1 + 1);\\n        if(ans > 0) return ans;\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int daysPassed(string date){\\n        int M = stoi(date.substr(0,2));\\n        int D = stoi(date.substr(3,2));\\n        vector<int>days = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}",
                "codeTag": "Java"
            },
            {
                "id": 2614279,
                "title": "c-calculate-the-day-number-from-the-date",
                "content": "```\\nclass Solution {\\npublic:\\n    int calDays(string s,vector<int>& pref){\\n        int a=stoi(s.substr(0,2));\\n        int b=stoi(s.substr(3));\\n        if(a==1) return b;\\n        return pref[a-2]+b;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        vector<int>months={31,28,31,30,31,30,31,31,30,31,30,31};\\n        vector<int>pref(12);\\n        pref[0]=months[0];\\n        for(int i=1;i<12;i++){\\n            pref[i]=pref[i-1]+months[i];\\n        }\\n\\t\\t\\n        int a=calDays(arriveAlice,pref);\\n        int b=calDays(leaveAlice,pref);\\n        int c=calDays(arriveBob,pref);\\n        int d=calDays(leaveBob,pref);\\n\\t\\t\\n        int ans=min(b,d)-max(a,c)+1;\\n\\t\\t\\n        return ans<0 ? 0: ans;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calDays(string s,vector<int>& pref){\\n        int a=stoi(s.substr(0,2));\\n        int b=stoi(s.substr(3));\\n        if(a==1) return b;\\n        return pref[a-2]+b;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        vector<int>months={31,28,31,30,31,30,31,31,30,31,30,31};\\n        vector<int>pref(12);\\n        pref[0]=months[0];\\n        for(int i=1;i<12;i++){\\n            pref[i]=pref[i-1]+months[i];\\n        }\\n\\t\\t\\n        int a=calDays(arriveAlice,pref);\\n        int b=calDays(leaveAlice,pref);\\n        int c=calDays(arriveBob,pref);\\n        int d=calDays(leaveBob,pref);\\n\\t\\t\\n        int ans=min(b,d)-max(a,c)+1;\\n\\t\\t\\n        return ans<0 ? 0: ans;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591611,
                "title": "c-easy-to-understand-converted-date-into-days-100-faster",
                "content": "**Solution -->**\\n```\\nclass Solution {\\npublic:\\n    int month[13]={0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    int convert(string &s)\\n    {\\n        string m, d;\\n        m+=s[0];\\n        m+=s[1];\\n        \\n        d+=s[3];\\n        d+=s[4];\\n        \\n        int cnt=0, mm, dd;\\n        mm= stoi(m);\\n        dd= stoi(d);\\n        \\n        for(int i=0; i<mm; i++)\\n            cnt+=month[i];            \\n        \\n        cnt+=dd;\\n        return cnt;        \\n    }\\n    int countDaysTogether(string aA, string lA, string aB, string lB)\\n    {\\n        int arr1= convert(aA);\\n        int arr2= convert(aB);\\n        int lev1= convert(lA);\\n        int lev2= convert(lB);\\n        \\n        int arr= max(arr1, arr2);\\n        int lev= min(lev1, lev2);\\n        \\n        if(arr>lev)\\n            return 0;\\n        \\n        return lev-arr+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int month[13]={0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    int convert(string &s)\\n    {\\n        string m, d;\\n        m+=s[0];\\n        m+=s[1];\\n        \\n        d+=s[3];\\n        d+=s[4];\\n        \\n        int cnt=0, mm, dd;\\n        mm= stoi(m);\\n        dd= stoi(d);\\n        \\n        for(int i=0; i<mm; i++)\\n            cnt+=month[i];            \\n        \\n        cnt+=dd;\\n        return cnt;        \\n    }\\n    int countDaysTogether(string aA, string lA, string aB, string lB)\\n    {\\n        int arr1= convert(aA);\\n        int arr2= convert(aB);\\n        int lev1= convert(lA);\\n        int lev2= convert(lB);\\n        \\n        int arr= max(arr1, arr2);\\n        int lev= min(lev1, lev2);\\n        \\n        if(arr>lev)\\n            return 0;\\n        \\n        return lev-arr+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591247,
                "title": "java-easy-to-understand",
                "content": "We need to get the days of the year upto that given date and then compare\\n\\n* We just need to convert the given date to number in year.\\n* For example, \"01-13\" (13th January) represents 13th day in year, \"02-13\" (13th February) represents 44th day in year.\\n* This problem came in Biweekly Contest on 17th September, which is 260th day in year.\\n\\n```\\nclass Solution {\\n    int[] month = new int[]{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        \\n        int a1 = toDays(arriveAlice);\\n        int a2 = toDays(arriveBob);\\n        \\n        int l1 = toDays(leaveAlice);\\n        int l2 = toDays(leaveBob);\\n        \\n        int arr = Math.max(a1, a2);\\n        int lev = Math.min(l1, l2);\\n        \\n        if(arr > lev)\\n            return 0;\\n        else\\n            return lev-arr+1;\\n    }\\n    \\n    public int toDays(String s){\\n        \\n        int m = (s.charAt(0)-\\'0\\')*10 + s.charAt(1)-\\'0\\';\\n        int d = (s.charAt(3)-\\'0\\')*10 + s.charAt(4)-\\'0\\';\\n        \\n        m--;\\n        while(m > 0){\\n            d += month[m];\\n            m--;\\n        }\\n        return d;\\n    }\\n}\\n```\\n\\nwas near to the solution but still failed, \\nresolved by blocker from https://leetcode.com/problems/count-days-spent-together/discuss/2587981/C++-or-Convert-Date-to-Number-in-Year-or-Explaination",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] month = new int[]{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        \\n        int a1 = toDays(arriveAlice);\\n        int a2 = toDays(arriveBob);\\n        \\n        int l1 = toDays(leaveAlice);\\n        int l2 = toDays(leaveBob);\\n        \\n        int arr = Math.max(a1, a2);\\n        int lev = Math.min(l1, l2);\\n        \\n        if(arr > lev)\\n            return 0;\\n        else\\n            return lev-arr+1;\\n    }\\n    \\n    public int toDays(String s){\\n        \\n        int m = (s.charAt(0)-\\'0\\')*10 + s.charAt(1)-\\'0\\';\\n        int d = (s.charAt(3)-\\'0\\')*10 + s.charAt(4)-\\'0\\';\\n        \\n        m--;\\n        while(m > 0){\\n            d += month[m];\\n            m--;\\n        }\\n        return d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589459,
                "title": "python-elegant-short-built-in-date",
                "content": "\\tfrom datetime import date\\n\\n\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(1)\\n\\t\\tMemory: O(1)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef countDaysTogether(self, arrive_alice: str, leave_alice: str, arrive_bob: str, leave_bob: str) -> int:\\n\\t\\t\\tstart = max(self.to_date(arrive_alice), self.to_date(arrive_bob))\\n\\t\\t\\tend = min(self.to_date(leave_alice), self.to_date(leave_bob))\\n\\t\\t\\treturn max((end - start).days + 1, 0)\\n\\n\\t\\t@staticmethod\\n\\t\\tdef to_date(month_day: str) -> date:\\n\\t\\t\\treturn date(2001, *map(int, month_day.split(\\'-\\')))\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tfrom datetime import date\\n\\n\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(1)\\n\\t\\tMemory: O(1)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef countDaysTogether(self, arrive_alice: str, leave_alice: str, arrive_bob: str, leave_bob: str) -> int:\\n\\t\\t\\tstart = max(self.to_date(arrive_alice), self.to_date(arrive_bob))\\n\\t\\t\\tend = min(self.to_date(leave_alice), self.to_date(leave_bob))\\n\\t\\t\\treturn max((end - start).days + 1, 0)\\n\\n\\t\\t@staticmethod\\n\\t\\tdef to_date(month_day: str) -> date:\\n\\t\\t\\treturn date(2001, *map(int, month_day.split(\\'-\\')))\\n",
                "codeTag": "Java"
            },
            {
                "id": 2589333,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {string} arriveAlice\\n * @param {string} leaveAlice\\n * @param {string} arriveBob\\n * @param {string} leaveBob\\n * @return {number}\\n */\\nvar countDaysTogether = function(arriveAlice, leaveAlice, arriveBob, leaveBob) {\\n    \\n    const DAYS_IN_MONTHS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n    \\n    const arrivalDAlice = [parseInt(arriveAlice.substring(0,3)), parseInt(arriveAlice.substring(3,5))]\\n    const arrivalDBob = [parseInt(arriveBob.substring(0,3)), parseInt(arriveBob.substring(3,5))]\\n    \\n    const leaveDAlice = [parseInt(leaveAlice.substring(0,3)), parseInt(leaveAlice.substring(3,5))]\\n    const leaveDBob = [parseInt(leaveBob.substring(0,3)), parseInt(leaveBob.substring(3,5))]\\n    \\n    let bothArrivedDate = -1, bothArrivedMonth = -1;\\n    let bothLeavingDate = -1, bothLeavingMonth = -1;\\n    \\n    // Coming in same month     \\n    if(arrivalDAlice[0] === arrivalDBob[0]){\\n            [bothArrivedDate, bothArrivedMonth] = arrivalDAlice[1] > arrivalDBob[1] ? \\n            [arrivalDAlice[1], arrivalDAlice[0]] : [arrivalDBob[1],arrivalDBob[0]];\\n    }else{\\n         [bothArrivedDate, bothArrivedMonth] = arrivalDAlice[0] > arrivalDBob[0] ? \\n                [arrivalDAlice[1], arrivalDAlice[0]] : [arrivalDBob[1],arrivalDBob[0]];\\n    }\\n    \\n    // leaving date and month    \\n    if(leaveDAlice[0] === leaveDBob[0]){\\n            [bothLeavingDate, bothLeavingMonth] = leaveDAlice[1] < leaveDBob[1] ? \\n            [leaveDAlice[1], leaveDAlice[0]] : [leaveDBob[1],leaveDBob[0]];\\n    }else{\\n         [bothLeavingDate, bothLeavingMonth] = leaveDAlice[0] < leaveDBob[0] ? \\n                [leaveDAlice[1], leaveDAlice[0]] : [leaveDBob[1],leaveDBob[0]];\\n    }\\n   \\n    if(bothLeavingMonth === bothArrivedMonth) \\n    {       \\n        const totalDaysTogether = (bothLeavingDate - bothArrivedDate) + 1\\n        return  totalDaysTogether > 0 ? totalDaysTogether : 0;\\n    }\\n    \\n    if(bothLeavingMonth < bothArrivedMonth) return 0\\n    \\n    \\n    // last case when they come in n month and leave in m month\\n    \\n    let totalDaysTogether = DAYS_IN_MONTHS[bothArrivedMonth - 1] - bothArrivedDate + 1 + bothLeavingDate\\n\\n    \\n    for(let i = bothArrivedMonth;  i < bothLeavingMonth - 1; i++ ) {\\n        totalDaysTogether += DAYS_IN_MONTHS[i]\\n    }\\n    \\n    \\n    return totalDaysTogether\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} arriveAlice\\n * @param {string} leaveAlice\\n * @param {string} arriveBob\\n * @param {string} leaveBob\\n * @return {number}\\n */\\nvar countDaysTogether = function(arriveAlice, leaveAlice, arriveBob, leaveBob) {\\n    \\n    const DAYS_IN_MONTHS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n    \\n    const arrivalDAlice = [parseInt(arriveAlice.substring(0,3)), parseInt(arriveAlice.substring(3,5))]\\n    const arrivalDBob = [parseInt(arriveBob.substring(0,3)), parseInt(arriveBob.substring(3,5))]\\n    \\n    const leaveDAlice = [parseInt(leaveAlice.substring(0,3)), parseInt(leaveAlice.substring(3,5))]\\n    const leaveDBob = [parseInt(leaveBob.substring(0,3)), parseInt(leaveBob.substring(3,5))]\\n    \\n    let bothArrivedDate = -1, bothArrivedMonth = -1;\\n    let bothLeavingDate = -1, bothLeavingMonth = -1;\\n    \\n    // Coming in same month     \\n    if(arrivalDAlice[0] === arrivalDBob[0]){\\n            [bothArrivedDate, bothArrivedMonth] = arrivalDAlice[1] > arrivalDBob[1] ? \\n            [arrivalDAlice[1], arrivalDAlice[0]] : [arrivalDBob[1],arrivalDBob[0]];\\n    }else{\\n         [bothArrivedDate, bothArrivedMonth] = arrivalDAlice[0] > arrivalDBob[0] ? \\n                [arrivalDAlice[1], arrivalDAlice[0]] : [arrivalDBob[1],arrivalDBob[0]];\\n    }\\n    \\n    // leaving date and month    \\n    if(leaveDAlice[0] === leaveDBob[0]){\\n            [bothLeavingDate, bothLeavingMonth] = leaveDAlice[1] < leaveDBob[1] ? \\n            [leaveDAlice[1], leaveDAlice[0]] : [leaveDBob[1],leaveDBob[0]];\\n    }else{\\n         [bothLeavingDate, bothLeavingMonth] = leaveDAlice[0] < leaveDBob[0] ? \\n                [leaveDAlice[1], leaveDAlice[0]] : [leaveDBob[1],leaveDBob[0]];\\n    }\\n   \\n    if(bothLeavingMonth === bothArrivedMonth) \\n    {       \\n        const totalDaysTogether = (bothLeavingDate - bothArrivedDate) + 1\\n        return  totalDaysTogether > 0 ? totalDaysTogether : 0;\\n    }\\n    \\n    if(bothLeavingMonth < bothArrivedMonth) return 0\\n    \\n    \\n    // last case when they come in n month and leave in m month\\n    \\n    let totalDaysTogether = DAYS_IN_MONTHS[bothArrivedMonth - 1] - bothArrivedDate + 1 + bothLeavingDate\\n\\n    \\n    for(let i = bothArrivedMonth;  i < bothLeavingMonth - 1; i++ ) {\\n        totalDaysTogether += DAYS_IN_MONTHS[i]\\n    }\\n    \\n    \\n    return totalDaysTogether\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589286,
                "title": "rust-solution",
                "content": "```\\nconst MONTHS: [i32; 12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n\\nimpl Solution {\\n    pub fn count_days_together(\\n        arrive_alice: String,\\n        leave_alice: String,\\n        arrive_bob: String,\\n        leave_bob: String,\\n    ) -> i32 {\\n        let parse_num_date = |s: String| -> i32 {\\n            let mut it = s.split(\\'-\\').map(|mds| mds.parse::<i32>().unwrap());\\n            let (month, day) = (it.next().unwrap(), it.next().unwrap());\\n            MONTHS[..(month - 1) as usize].iter().sum::<i32>() + day\\n        };\\n\\n        let arrive_alice_day = parse_num_date(arrive_alice);\\n        let leave_alice_day = parse_num_date(leave_alice);\\n        let arrive_bob_day = parse_num_date(arrive_bob);\\n        let leave_bob_day = parse_num_date(leave_bob);\\n\\n        let min_day = arrive_alice_day.max(arrive_bob_day);\\n        let max_day = leave_alice_day.min(leave_bob_day);\\n        0.max(max_day - min_day + 1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nconst MONTHS: [i32; 12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n\\nimpl Solution {\\n    pub fn count_days_together(\\n        arrive_alice: String,\\n        leave_alice: String,\\n        arrive_bob: String,\\n        leave_bob: String,\\n    ) -> i32 {\\n        let parse_num_date = |s: String| -> i32 {\\n            let mut it = s.split(\\'-\\').map(|mds| mds.parse::<i32>().unwrap());\\n            let (month, day) = (it.next().unwrap(), it.next().unwrap());\\n            MONTHS[..(month - 1) as usize].iter().sum::<i32>() + day\\n        };\\n\\n        let arrive_alice_day = parse_num_date(arrive_alice);\\n        let leave_alice_day = parse_num_date(leave_alice);\\n        let arrive_bob_day = parse_num_date(arrive_bob);\\n        let leave_bob_day = parse_num_date(leave_bob);\\n\\n        let min_day = arrive_alice_day.max(arrive_bob_day);\\n        let max_day = leave_alice_day.min(leave_bob_day);\\n        0.max(max_day - min_day + 1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589172,
                "title": "rust-0-ms-day-number-counting-with-detailed-comments",
                "content": "This [solution](https://leetcode.com/submissions/detail/802333989/) employs a straightforward day number counting. It demonstrated **0 ms runtime (100.00%)** and used **2.1 MB memory (100.00%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    // [1] this function translates \"MM-DD\" into day number\\n    pub fn day_number(day_string: String) -> i32\\n    {\\n        let days_in_month: Vec<i32> = vec![31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n        \\n        // [2] parse string to MM and DD\\n        let mm = usize::from_str_radix(&day_string[0..2], 10).unwrap() - 1;\\n        let dd = i32::from_str_radix(&day_string[3..5], 10).unwrap() - 1;\\n        \\n        // [3] get day number (starting from January 1)\\n        days_in_month[0..mm].iter().sum::<i32>() + dd\\n    }\\n    \\n    pub fn count_days_together(arrive_alice: String, leave_alice: String, arrive_bob: String, leave_bob: String) -> i32 \\n    {\\n        // [4] get day numbers for all dates\\n        let day_arrive_alice = Solution::day_number(arrive_alice);\\n        let day_leave_alice  = Solution::day_number(leave_alice);\\n        let day_arrive_bob   = Solution::day_number(arrive_bob);\\n        let day_leave_bob    = Solution::day_number(leave_bob);\\n        \\n        // [5] calculate overlap\\n        let start_day = day_arrive_alice.max(day_arrive_bob);\\n        let end_day   = day_leave_alice.min(day_leave_bob);\\n\\n\\t\\t(end_day - start_day + 1).max(0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution \\n{\\n    // [1] this function translates \"MM-DD\" into day number\\n    pub fn day_number(day_string: String) -> i32\\n    {\\n        let days_in_month: Vec<i32> = vec![31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n        \\n        // [2] parse string to MM and DD\\n        let mm = usize::from_str_radix(&day_string[0..2], 10).unwrap() - 1;\\n        let dd = i32::from_str_radix(&day_string[3..5], 10).unwrap() - 1;\\n        \\n        // [3] get day number (starting from January 1)\\n        days_in_month[0..mm].iter().sum::<i32>() + dd\\n    }\\n    \\n    pub fn count_days_together(arrive_alice: String, leave_alice: String, arrive_bob: String, leave_bob: String) -> i32 \\n    {\\n        // [4] get day numbers for all dates\\n        let day_arrive_alice = Solution::day_number(arrive_alice);\\n        let day_leave_alice  = Solution::day_number(leave_alice);\\n        let day_arrive_bob   = Solution::day_number(arrive_bob);\\n        let day_leave_bob    = Solution::day_number(leave_bob);\\n        \\n        // [5] calculate overlap\\n        let start_day = day_arrive_alice.max(day_arrive_bob);\\n        let end_day   = day_leave_alice.min(day_leave_bob);\\n\\n\\t\\t(end_day - start_day + 1).max(0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589080,
                "title": "c-easy-to-understand-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        // [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        //  1   2   3   4   5   6   7   8   9   10  11  12\\n        \\n        map<int,int> month; //prev completed days\\n        month[01]=0;\\n        month[02]=31;\\n        month[03]=59;\\n        month[04]=90;\\n        month[05]=120;\\n        month[06]=151;\\n        month[07]=181;\\n        month[8]=212;\\n        month[9]=243;\\n        month[10]=273;\\n        month[11]=304;\\n        month[12]=334;\\n\\n        //arrive alice\\n        int aam = stoi(arriveAlice.substr(0,2)); //arrive alice month\\n        int aad = stoi(arriveAlice.substr(3,2)); //arrive alice date\\n        \\n        int lam = stoi(leaveAlice.substr(0,2)); //leave alice month\\n        int lad = stoi(leaveAlice.substr(3,2));  //leave alice date\\n        \\n        int abm = stoi(arriveBob.substr(0,2));  //arrive bob month\\n        int abd = stoi(arriveBob.substr(3,2));  //arrive bob date\\n        \\n        int lbm = stoi(leaveBob.substr(0,2));  //leave bob month\\n        int lbd = stoi(leaveBob.substr(3,2));  //leave bob date\\n        \\n        if(month[lam]+lad < month[abm]+abd || month[lbm]+lbd < month[aam]+aad  ){\\n            return 0;\\n        }\\n       \\n        //Alice arrived first\\n        if(month[aam]+aad <= month[abm]+abd )\\n        {\\n            //Alice leave first\\n            if(month[lam]+lad <= month[lbm]+lbd)\\n            {\\n                return 1 + (month[lam]+lad) - (month[abm]+abd);\\n            }\\n            //Bob leave first\\n            else if(month[lam]+lad > month[lbm]+lbd){\\n                return 1 + (month[lbm]+lbd) - (month[abm]+abd);\\n            }\\n        }\\n        \\n        // Bob arrived first\\n        else if(month[aam]+aad > month[abm]+abd )\\n        {\\n            //Bob leave first\\n            if(month[lbm]+lbd <= month[lam]+lad)\\n            {\\n                return 1 + (month[lbm]+lbd) - (month[aam]+aad);\\n            }\\n            //Alice leave first\\n            else if(month[lbm]+lbd > month[lam]+lad){\\n                return 1 + (month[lam]+lad) - (month[aam]+aad);\\n            }\\n        }\\n        \\n      return 1;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        // [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        //  1   2   3   4   5   6   7   8   9   10  11  12\\n        \\n        map<int,int> month; //prev completed days\\n        month[01]=0;\\n        month[02]=31;\\n        month[03]=59;\\n        month[04]=90;\\n        month[05]=120;\\n        month[06]=151;\\n        month[07]=181;\\n        month[8]=212;\\n        month[9]=243;\\n        month[10]=273;\\n        month[11]=304;\\n        month[12]=334;\\n\\n        //arrive alice\\n        int aam = stoi(arriveAlice.substr(0,2)); //arrive alice month\\n        int aad = stoi(arriveAlice.substr(3,2)); //arrive alice date\\n        \\n        int lam = stoi(leaveAlice.substr(0,2)); //leave alice month\\n        int lad = stoi(leaveAlice.substr(3,2));  //leave alice date\\n        \\n        int abm = stoi(arriveBob.substr(0,2));  //arrive bob month\\n        int abd = stoi(arriveBob.substr(3,2));  //arrive bob date\\n        \\n        int lbm = stoi(leaveBob.substr(0,2));  //leave bob month\\n        int lbd = stoi(leaveBob.substr(3,2));  //leave bob date\\n        \\n        if(month[lam]+lad < month[abm]+abd || month[lbm]+lbd < month[aam]+aad  ){\\n            return 0;\\n        }\\n       \\n        //Alice arrived first\\n        if(month[aam]+aad <= month[abm]+abd )\\n        {\\n            //Alice leave first\\n            if(month[lam]+lad <= month[lbm]+lbd)\\n            {\\n                return 1 + (month[lam]+lad) - (month[abm]+abd);\\n            }\\n            //Bob leave first\\n            else if(month[lam]+lad > month[lbm]+lbd){\\n                return 1 + (month[lbm]+lbd) - (month[abm]+abd);\\n            }\\n        }\\n        \\n        // Bob arrived first\\n        else if(month[aam]+aad > month[abm]+abd )\\n        {\\n            //Bob leave first\\n            if(month[lbm]+lbd <= month[lam]+lad)\\n            {\\n                return 1 + (month[lbm]+lbd) - (month[aam]+aad);\\n            }\\n            //Alice leave first\\n            else if(month[lbm]+lbd > month[lam]+lad){\\n                return 1 + (month[lam]+lad) - (month[aam]+aad);\\n            }\\n        }\\n        \\n      return 1;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588948,
                "title": "c-brute-force-approach-easy-and-understandable-solution",
                "content": "// Don\\'t affraid from the lenght of code you simply follow comment you easily understand \\n\\n\\nclass Solution {\\npublic:\\n    int countDaysTogether(string aA, string lA, string aB, string lB) {\\n\\t  // maa = month of arrive alice ,daa =  days of arrive alice \\n\\t  //mla = month of leave alice , dla = days of leave alice \\n        int maa , daa ;  \\n        int mla ,dla;\\n\\t // mab = month of arrive bob ,dab=  days of arrive bob \\n\\t //mlb = month of leave bob, dlb = days of leave bob\\n        int mab ,dab ;\\n        int mlb ,dlb;\\n     \\n      int count = 0;\\n     \\n            maa = (aA[0] -\\'0\\')*10 +(aA[1]-\\'0\\');\\n            daa = (aA[3] -\\'0\\')*10 +(aA[4]-\\'0\\');\\n         mla = (lA[0] -\\'0\\')*10 +(lA[1]-\\'0\\');\\n         dla = (lA[3] -\\'0\\')*10 +(lA[4]-\\'0\\');\\n         mab = (aB[0] -\\'0\\')*10 +(aB[1]-\\'0\\');\\n         dab = (aB[3] -\\'0\\')*10 +(aB[4]-\\'0\\');\\n         mlb = (lB[0] -\\'0\\')*10 +(lB[1]-\\'0\\');\\n         dlb= (lB[3] -\\'0\\')*10 +(lB[4]-\\'0\\');\\n        //  if  month of leave of alice is less than month of arrival of bob then number of days that Alice and Bob are in    Rome together is zero \\n        if (mla < mab){\\n            return 0;\\n        }\\n\\t\\t //  if  month of leave of alice is equal the month of arrival of bob then we check on which date alice is leave if allice leave date is less than bob arrnival date then number of days that Alice and Bob are in Rome together is zero \\n        else if ((mla == mab) && (dla < dab)){\\n            return 0 ;\\n        }\\n\\t\\t// respectively same approach on bob\\n      else  if (mlb<maa){\\n            return 0;\\n        }\\n     else if ((mlb == maa) && (dlb < daa)){\\n            return 0 ;\\n        }      \\n  // if above criteria  doesnt match then we count the no of days they spent together  \\n      else {  \\n\\t            // we calculate whoes arrive 1st in rome x is the month and y is date .\\n                  int x ,y;\\n                  x = max(maa,mab);\\n                  if (maa == mab){\\n                     y = max(dab,daa);\\n                  }\\n                  else {\\n                    if (maa >mab){\\n                        y = daa ;\\n                    }  \\n                      else {\\n                          y = dab;\\n                      }\\n                  }\\n\\t\\t\\t\\t  // we calculate whoes leave 1st in rome, p is the month and q is date .\\n          int p ,q;\\n          p = min(mla,mlb);\\n              if (mla == mlb ){\\n                  q = min (dlb,dla);\\n              }\\n          else {\\n              if(mla>mlb){\\n                  q = dlb;\\n              }\\n              else {\\n                  q = dla;\\n              }\\n          }\\n          // here we calculate the total no of days alice and bob spent together in rome \\n\\t\\t  // be aware of the month which contain 31 days or 30 days or 29 days ,we make separate case from them\\n              while (x<p){\\n                  if (x<=7){\\n                    if(x==2){\\n                    count += (28-y);\\n                        y=0;\\n                      }\\n                  else if (x %2 == 1  ){\\n                  count += (31-y);\\n                      y =0;\\n                      }\\n                  else {\\n                      count += (30-y);\\n                      y = 0;\\n                  }\\n                  x++;\\n              }\\n                  else  if (x>7){\\n                  if (x %2 == 0  ){\\n                  count += (31-y);\\n                      y =0;\\n                      }\\n                  else {\\n                      count += (30-y);\\n                      y = 0;\\n                  }\\n                  x++;\\n              }\\n              }\\n             if (x == p){\\n                 count += (q-y);\\n             }\\n          }\\n              return count+1;\\n    }\\n               \\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countDaysTogether(string aA, string lA, string aB, string lB) {\\n\\t  // maa = month of arrive alice ,daa =  days of arrive alice \\n\\t  //mla = month of leave alice , dla = days of leave alice \\n        int maa , daa ;  \\n        int mla ,dla;\\n\\t // mab = month of arrive bob ,dab=  days of arrive bob \\n\\t //mlb = month of leave bob, dlb = days of leave bob\\n        int mab ,dab ;\\n        int mlb ,dlb;\\n     \\n      int count = 0;\\n     \\n            maa = (aA[0] -\\'0\\')*10 +(aA[1]-\\'0\\');\\n            daa = (aA[3] -\\'0\\')*10 +(aA[4]-\\'0\\');\\n         mla = (lA[0] -\\'0\\')*10 +(lA[1]-\\'0\\');\\n         dla = (lA[3] -\\'0\\')*10 +(lA[4]-\\'0\\');\\n         mab = (aB[0] -\\'0\\')*10 +(aB[1]-\\'0\\');\\n         dab = (aB[3] -\\'0\\')*10 +(aB[4]-\\'0\\');\\n         mlb = (lB[0] -\\'0\\')*10 +(lB[1]-\\'0\\');\\n         dlb= (lB[3] -\\'0\\')*10 +(lB[4]-\\'0\\');\\n        //  if  month of leave of alice is less than month of arrival of bob then number of days that Alice and Bob are in    Rome together is zero \\n        if (mla < mab){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2588439,
                "title": "silly-problem-easy-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int month[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        string start = max(arriveAlice, arriveBob), end = min(leaveAlice, leaveBob);\\n        if (start <= end) {\\n            int startMonth = stoi(start.substr(0, 2)), startDate = stoi(start.substr(3, 2));\\n            int endMonth = stoi(end.substr(0, 2)), endDate = stoi(end.substr(3, 2));\\n            if (endMonth == startMonth) return endDate - startDate + 1;\\n            int days = month[startMonth] + endDate - startDate + 1;\\n            for (int i = startMonth + 1; i < endMonth; i++) days += month[i];\\n            return days;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int month[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        string start = max(arriveAlice, arriveBob), end = min(leaveAlice, leaveBob);\\n        if (start <= end) {\\n            int startMonth = stoi(start.substr(0, 2)), startDate = stoi(start.substr(3, 2));\\n            int endMonth = stoi(end.substr(0, 2)), endDate = stoi(end.substr(3, 2));\\n            if (endMonth == startMonth) return endDate - startDate + 1;\\n            int days = month[startMonth] + endDate - startDate + 1;\\n            for (int i = startMonth + 1; i < endMonth; i++) days += month[i];\\n            return days;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588351,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string aa, string la, string ab, string lb) {\\n        vector<int> mp = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        int as = getDate(mp, aa), ae = getDate(mp, la);\\n        int bs = getDate(mp, ab), be = getDate(mp, lb);\\n        int res = 0;\\n        for(int i=as; i<=ae; i++) {\\n            if(bs<=i && i<=be) res++;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int getDate(vector<int>& mp, string& s) {\\n        int res = 0, m = stoi(s.substr(0, 2)), d = stoi(s.substr(3, 2));\\n        for(int i=0; i<m-1; i++) res += mp[i];\\n        return res + d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string aa, string la, string ab, string lb) {\\n        vector<int> mp = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        int as = getDate(mp, aa), ae = getDate(mp, la);\\n        int bs = getDate(mp, ab), be = getDate(mp, lb);\\n        int res = 0;\\n        for(int i=as; i<=ae; i++) {\\n            if(bs<=i && i<=be) res++;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int getDate(vector<int>& mp, string& s) {\\n        int res = 0, m = stoi(s.substr(0, 2)), d = stoi(s.substr(3, 2));\\n        for(int i=0; i<m-1; i++) res += mp[i];\\n        return res + d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588277,
                "title": "javascript",
                "content": "```\\nconst countDaysTogether = function(arriveAlice, leaveAlice, arriveBob, leaveBob) {\\n  const months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n  const pref = [0]\\n  for (let i = 0; i < months.length; i++) {\\n      pref.push(pref[i]+months[i])\\n  }\\n  \\n  let [ama, ada] = arriveAlice.split(\\'-\\')\\n  let [aml, adl] = leaveAlice.split(\\'-\\')\\n  let [bma, bda] = arriveBob.split(\\'-\\')\\n  let [bml, bdl] = leaveBob.split(\\'-\\')\\n  \\n  let aA = pref[parseInt(ama)-1] + parseInt(ada)\\n  let aL = pref[parseInt(aml)-1] + parseInt(adl)\\n  \\n  let bA = pref[parseInt(bma)-1] + parseInt(bda)\\n  let bL = pref[parseInt(bml)-1] + parseInt(bdl)\\n  \\n  return Math.max(0, Math.min(aL, bL) - Math.max(aA, bA) + 1)\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nconst countDaysTogether = function(arriveAlice, leaveAlice, arriveBob, leaveBob) {\\n  const months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n  const pref = [0]\\n  for (let i = 0; i < months.length; i++) {\\n      pref.push(pref[i]+months[i])\\n  }\\n  \\n  let [ama, ada] = arriveAlice.split(\\'-\\')\\n  let [aml, adl] = leaveAlice.split(\\'-\\')\\n  let [bma, bda] = arriveBob.split(\\'-\\')\\n  let [bml, bdl] = leaveBob.split(\\'-\\')\\n  \\n  let aA = pref[parseInt(ama)-1] + parseInt(ada)\\n  let aL = pref[parseInt(aml)-1] + parseInt(adl)\\n  \\n  let bA = pref[parseInt(bma)-1] + parseInt(bda)\\n  let bL = pref[parseInt(bml)-1] + parseInt(bdl)\\n  \\n  return Math.max(0, Math.min(aL, bL) - Math.max(aA, bA) + 1)\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588232,
                "title": "u-wanted-bigger-is-it-just-as-she-said",
                "content": "```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int arr[]=new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        int maa=Integer.valueOf(arriveAlice.split(\"-\")[0])-1;\\n        int daa=Integer.valueOf(arriveAlice.split(\"-\")[1])-1;\\n        int mla=Integer.valueOf(leaveAlice.split(\"-\")[0])-1;\\n        int dla=Integer.valueOf(leaveAlice.split(\"-\")[1])-1;\\n        \\n        int mab=Integer.valueOf(arriveBob.split(\"-\")[0])-1;\\n        int dab=Integer.valueOf(arriveBob.split(\"-\")[1])-1;\\n        int mlb=Integer.valueOf(leaveBob.split(\"-\")[0])-1;\\n        int dlb=Integer.valueOf(leaveBob.split(\"-\")[1])-1;\\n        \\n        int year[][]=new int[12][];\\n        for(int i=0;i<12;i++){\\n            year[i]=new int[arr[i]];\\n        }\\n        if(maa==mla){\\n            for(int i=daa;i<=dla;i++){\\n                year[maa][i]++;\\n            }\\n        }else{\\n            for(int i=daa;i<year[maa].length;i++){\\n                year[maa][i]++;\\n            }\\n            for(int i=maa+1;i<mla;i++){\\n                for(int j=0;i<12 && j<arr[i];j++){\\n                    year[i][j]++;\\n                }\\n            }\\n            for(int i=0;i<=dla;i++){\\n                year[mla][i]++;\\n            }\\n        }\\n        \\n        \\n        \\n        if(mab==mlb){\\n            for(int i=dab;i<=dlb;i++){\\n                year[mab][i]++;\\n            }\\n        }else{\\n            for(int i=dab;i<year[mab].length;i++){\\n                year[mab][i]++;\\n            }\\n            for(int i=mab+1;i<mlb;i++){\\n                for(int j=0;i<12 && j<arr[i];j++){\\n                    year[i][j]++;\\n                }\\n            }\\n            for(int i=0;i<=dlb;i++){\\n                year[mlb][i]++;\\n            }\\n        }\\n        int res=0;\\n        for(int[] array: year){\\n            for(int together: array){\\n                if(together==2) res++;\\n                // System.out.print(together+\" \");\\n            }\\n            // System.out.println();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int arr[]=new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        int maa=Integer.valueOf(arriveAlice.split(\"-\")[0])-1;\\n        int daa=Integer.valueOf(arriveAlice.split(\"-\")[1])-1;\\n        int mla=Integer.valueOf(leaveAlice.split(\"-\")[0])-1;\\n        int dla=Integer.valueOf(leaveAlice.split(\"-\")[1])-1;\\n        \\n        int mab=Integer.valueOf(arriveBob.split(\"-\")[0])-1;\\n        int dab=Integer.valueOf(arriveBob.split(\"-\")[1])-1;\\n        int mlb=Integer.valueOf(leaveBob.split(\"-\")[0])-1;\\n        int dlb=Integer.valueOf(leaveBob.split(\"-\")[1])-1;\\n        \\n        int year[][]=new int[12][];\\n        for(int i=0;i<12;i++){\\n            year[i]=new int[arr[i]];\\n        }\\n        if(maa==mla){\\n            for(int i=daa;i<=dla;i++){\\n                year[maa][i]++;\\n            }\\n        }else{\\n            for(int i=daa;i<year[maa].length;i++){\\n                year[maa][i]++;\\n            }\\n            for(int i=maa+1;i<mla;i++){\\n                for(int j=0;i<12 && j<arr[i];j++){\\n                    year[i][j]++;\\n                }\\n            }\\n            for(int i=0;i<=dla;i++){\\n                year[mla][i]++;\\n            }\\n        }\\n        \\n        \\n        \\n        if(mab==mlb){\\n            for(int i=dab;i<=dlb;i++){\\n                year[mab][i]++;\\n            }\\n        }else{\\n            for(int i=dab;i<year[mab].length;i++){\\n                year[mab][i]++;\\n            }\\n            for(int i=mab+1;i<mlb;i++){\\n                for(int j=0;i<12 && j<arr[i];j++){\\n                    year[i][j]++;\\n                }\\n            }\\n            for(int i=0;i<=dlb;i++){\\n                year[mlb][i]++;\\n            }\\n        }\\n        int res=0;\\n        for(int[] array: year){\\n            for(int together: array){\\n                if(together==2) res++;\\n                // System.out.print(together+\" \");\\n            }\\n            // System.out.println();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588208,
                "title": "convert-date-to-the-ith-day-of-the-year",
                "content": "Its a common trick whenever you have dates given there are two possibilities to solve the problem:\\n1) simply brute force travel each day\\n2) convert date to the ith day from a particular reference\\n\\nhere since we are given month and day only so we can safely convert our date to  ith day of the year.\\ni.e(between 0 to 365).\\n(now for the answer we can store the maximum start day and minimum leave day for alice and bob)\\n```\\nclass Solution\\n{\\npublic:\\n    int days[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int convert(string x)\\n    {\\n        int month = stoi(x.substr(0, 2));\\n        int day = stoi(x.substr(3, 2));\\n        int ans = 0;\\n        for (int i = 1; i < month; i++)\\n            ans += days[i];\\n        ans += day;\\n        return ans;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n    {\\n        int aa = convert(arriveAlice);\\n        int al = convert(leaveAlice);\\n        int ba = convert(arriveBob);\\n        int bl = convert(leaveBob);\\n        int start = max(aa, ba);\\n        int leave = min(al, bl);\\n\\n        return max(leave - start + 1, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int days[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int convert(string x)\\n    {\\n        int month = stoi(x.substr(0, 2));\\n        int day = stoi(x.substr(3, 2));\\n        int ans = 0;\\n        for (int i = 1; i < month; i++)\\n            ans += days[i];\\n        ans += day;\\n        return ans;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n    {\\n        int aa = convert(arriveAlice);\\n        int al = convert(leaveAlice);\\n        int ba = convert(arriveBob);\\n        int bl = convert(leaveBob);\\n        int start = max(aa, ba);\\n        int leave = min(al, bl);\\n\\n        return max(leave - start + 1, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588191,
                "title": "too-much-confusion",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int a_s_m=(arriveAlice[0]-\\'0\\')*10 + (arriveAlice[1]-\\'0\\');\\n        int a_s_d=(arriveAlice[3]-\\'0\\')*10 + (arriveAlice[4]-\\'0\\');\\n        int a_e_m=(leaveAlice[0]-\\'0\\')*10 + (leaveAlice[1]-\\'0\\');\\n        int a_e_d=(leaveAlice[3]-\\'0\\')*10 + (leaveAlice[4]-\\'0\\');\\n        \\n        int b_s_m=(arriveBob[0]-\\'0\\')*10 + (arriveBob[1]-\\'0\\');\\n        int b_s_d=(arriveBob[3]-\\'0\\')*10 + (arriveBob[4]-\\'0\\');\\n        int b_e_m=(leaveBob[0]-\\'0\\')*10 + (leaveBob[1]-\\'0\\');\\n        int b_e_d=(leaveBob[3]-\\'0\\')*10 + (leaveBob[4]-\\'0\\');\\n        vector<int> days= {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int common_m_s, common_d_s, common_m_e, common_d_e;\\n        if(a_s_m < b_s_m){\\n            common_m_s=b_s_m;\\n            common_d_s=b_s_d;\\n        }\\n        else if(a_s_m == b_s_m){\\n            common_m_s=b_s_m;\\n            common_d_s=max(a_s_d,b_s_d);\\n        }\\n        else {\\n            common_m_s=a_s_m;\\n            common_d_s=a_s_d;\\n        }\\n        \\n        if(a_e_m < b_e_m){\\n            common_m_e=a_e_m;\\n            common_d_e=a_e_d;\\n        }\\n        else if(a_e_m==b_e_m){\\n            common_m_e=a_e_m;\\n            common_d_e=min(a_e_d,b_e_d);\\n        }\\n        else{\\n            common_m_e=b_e_m;\\n            common_d_e=b_e_d;\\n        }\\n        // cout<<common_m_s<<\" \"<<common_d_s<<\"|\"<<common_m_e<<\" \"<<common_d_e<<endl;\\n        int count=0;\\n        for(int i=common_m_s;i<=common_m_e;i++){\\n            count+=days[i-1];\\n        }\\n        count-=(common_d_s-1);\\n        count-=(days[common_m_e-1]-common_d_e);\\n        if(count>0) \\n            return count;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int a_s_m=(arriveAlice[0]-\\'0\\')*10 + (arriveAlice[1]-\\'0\\');\\n        int a_s_d=(arriveAlice[3]-\\'0\\')*10 + (arriveAlice[4]-\\'0\\');\\n        int a_e_m=(leaveAlice[0]-\\'0\\')*10 + (leaveAlice[1]-\\'0\\');\\n        int a_e_d=(leaveAlice[3]-\\'0\\')*10 + (leaveAlice[4]-\\'0\\');\\n        \\n        int b_s_m=(arriveBob[0]-\\'0\\')*10 + (arriveBob[1]-\\'0\\');\\n        int b_s_d=(arriveBob[3]-\\'0\\')*10 + (arriveBob[4]-\\'0\\');\\n        int b_e_m=(leaveBob[0]-\\'0\\')*10 + (leaveBob[1]-\\'0\\');\\n        int b_e_d=(leaveBob[3]-\\'0\\')*10 + (leaveBob[4]-\\'0\\');\\n        vector<int> days= {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int common_m_s, common_d_s, common_m_e, common_d_e;\\n        if(a_s_m < b_s_m){\\n            common_m_s=b_s_m;\\n            common_d_s=b_s_d;\\n        }\\n        else if(a_s_m == b_s_m){\\n            common_m_s=b_s_m;\\n            common_d_s=max(a_s_d,b_s_d);\\n        }\\n        else {\\n            common_m_s=a_s_m;\\n            common_d_s=a_s_d;\\n        }\\n        \\n        if(a_e_m < b_e_m){\\n            common_m_e=a_e_m;\\n            common_d_e=a_e_d;\\n        }\\n        else if(a_e_m==b_e_m){\\n            common_m_e=a_e_m;\\n            common_d_e=min(a_e_d,b_e_d);\\n        }\\n        else{\\n            common_m_e=b_e_m;\\n            common_d_e=b_e_d;\\n        }\\n        // cout<<common_m_s<<\" \"<<common_d_s<<\"|\"<<common_m_e<<\" \"<<common_d_e<<endl;\\n        int count=0;\\n        for(int i=common_m_s;i<=common_m_e;i++){\\n            count+=days[i-1];\\n        }\\n        count-=(common_d_s-1);\\n        count-=(days[common_m_e-1]-common_d_e);\\n        if(count>0) \\n            return count;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2588094,
                "title": "c-easy-solution",
                "content": "- We create an array with a size of 365, with for each cell, a day.\\n - For both Alice and Bob we will add 1 for each cell or their active days\\n -  The hardest part is to convert the string dates to our year array\\n```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        vector<int> nbDays = {31,28,31,30,31,30,31,31,30,31,30,31};\\n        vector<int> daysSum(13);\\n\\t\\t// We use a prefix sum to have for each month the cumul count of days\\n        for (int i=1; i<13; i++)\\n        {\\n            daysSum[i]=daysSum[i-1]+nbDays[i-1];\\n        }\\n        vector<int> year(366);\\n        int ans = 0;\\n\\t\\t// We use the function substr to get the firsts elements of \"MM-DD\" and the lasts one\\n\\t\\t// the function stoi will convert our string into an integer\\n        int arriveAD=stoi(arriveAlice.substr(3,2)); //arrive Alice Day\\n        int arriveAM=stoi(arriveAlice.substr(0,2)); //arrive Alice Month\\n        int endAD=stoi(leaveAlice.substr(3,2));\\n        int endAM=stoi(leaveAlice.substr(0,2));\\n        int arriveBD=stoi(arriveBob.substr(3,2)); //arrive Bob Day\\n        int arriveBM=stoi(arriveBob.substr(0,2)); //arrive Bob Month\\n        int endBD=stoi(leaveBob.substr(3,2));\\n        int endBM=stoi(leaveBob.substr(0,2));\\n\\t\\t// For i=first day; i<=last day\\n        for (int i=daysSum[arriveAM-1]+arriveAD; i<=daysSum[endAM-1]+endAD; i++)\\n            year[i]++;\\n        for (int i=daysSum[arriveBM-1]+arriveBD; i<=daysSum[endBM-1]+endBD; i++)\\n            year[i]++;\\n\\t\\t\\t// Each day marked with a 2 is a day that both Alice and Bob were together\\n        for (int i=0; i<366; i++)\\n            if (year[i]==2)\\n                ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        vector<int> nbDays = {31,28,31,30,31,30,31,31,30,31,30,31};\\n        vector<int> daysSum(13);\\n\\t\\t// We use a prefix sum to have for each month the cumul count of days\\n        for (int i=1; i<13; i++)\\n        {\\n            daysSum[i]=daysSum[i-1]+nbDays[i-1];\\n        }\\n        vector<int> year(366);\\n        int ans = 0;\\n\\t\\t// We use the function substr to get the firsts elements of \"MM-DD\" and the lasts one\\n\\t\\t// the function stoi will convert our string into an integer\\n        int arriveAD=stoi(arriveAlice.substr(3,2)); //arrive Alice Day\\n        int arriveAM=stoi(arriveAlice.substr(0,2)); //arrive Alice Month\\n        int endAD=stoi(leaveAlice.substr(3,2));\\n        int endAM=stoi(leaveAlice.substr(0,2));\\n        int arriveBD=stoi(arriveBob.substr(3,2)); //arrive Bob Day\\n        int arriveBM=stoi(arriveBob.substr(0,2)); //arrive Bob Month\\n        int endBD=stoi(leaveBob.substr(3,2));\\n        int endBM=stoi(leaveBob.substr(0,2));\\n\\t\\t// For i=first day; i<=last day\\n        for (int i=daysSum[arriveAM-1]+arriveAD; i<=daysSum[endAM-1]+endAD; i++)\\n            year[i]++;\\n        for (int i=daysSum[arriveBM-1]+arriveBD; i<=daysSum[endBM-1]+endBD; i++)\\n            year[i]++;\\n\\t\\t\\t// Each day marked with a 2 is a day that both Alice and Bob were together\\n        for (int i=0; i<366; i++)\\n            if (year[i]==2)\\n                ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588045,
                "title": "c",
                "content": "```\\npublic class Solution\\n{\\n    public int CountDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n    {\\n        DateTime arrive2 = DateTime.Parse(arriveBob + \"-2019\");\\n        DateTime leave2 = DateTime.Parse(leaveBob + \"-2019\");\\n        DateTime arrive1 = DateTime.Parse(arriveAlice + \"-2019\");\\n        DateTime leave1 = DateTime.Parse(leaveAlice + \"-2019\");\\n        var count = 0;\\n        for(DateTime i= arrive1; i <= leave1; i=i.AddDays(1))\\n        {\\n            if(i>=arrive2 && i <= leave2)\\n            {\\n                count++;\\n            }\\n        } \\n        return count;\\n    } \\n}",
                "solutionTags": [],
                "code": "class Solution\\n{\\n    public int CountDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n    {\\n        DateTime arrive2 = DateTime.Parse(arriveBob + \"-2019\");\\n        DateTime leave2 = DateTime.Parse(leaveBob + \"-2019\");\\n        DateTime arrive1 = DateTime.Parse(arriveAlice + \"-2019\");\\n        DateTime leave1 = DateTime.Parse(leaveAlice + \"-2019\");\\n        var count = 0;\\n        for(DateTime i= arrive1; i <= leave1; i=i.AddDays(1))\\n        {\\n            if(i>=arrive2 && i <= leave2)\\n            {\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2587926,
                "title": "python-simple-counting-no-libraries",
                "content": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        if arriveAlice > leaveBob or arriveBob > leaveAlice: return 0\\n        \\n        start = max(arriveAlice, arriveBob)\\n        end = min(leaveAlice, leaveBob)\\n        \\n        days = [0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n\\n        s_month, s_day = map(int,start.split(\\'-\\'))\\n        e_month, e_day = map(int,end.split(\\'-\\'))\\n\\n        if s_month == e_month: return e_day - s_day + 1\\n\\n        count = days[s_month] - s_day + 1\\n\\n        count += sum(days[month] for month in range(s_month + 1, e_month))\\n\\n        count += e_day \\n\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        if arriveAlice > leaveBob or arriveBob > leaveAlice: return 0\\n        \\n        start = max(arriveAlice, arriveBob)\\n        end = min(leaveAlice, leaveBob)\\n        \\n        days = [0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n\\n        s_month, s_day = map(int,start.split(\\'-\\'))\\n        e_month, e_day = map(int,end.split(\\'-\\'))\\n\\n        if s_month == e_month: return e_day - s_day + 1\\n\\n        count = days[s_month] - s_day + 1\\n\\n        count += sum(days[month] for month in range(s_month + 1, e_month))\\n\\n        count += e_day \\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466221,
                "title": "to-count-days-spent-together-c-c-simple-solution",
                "content": "# Approach\\nJust convert start days and end days to numbers for easy calculation purposes.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumdays[13];\\n    int Days[12]={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int totalDays(string str)\\n    {\\n        int month=stoi(str.substr(0,2)), day=stoi(str.substr(3));\\n        return sumdays[month-1]+day;\\n    }\\n\\n\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        sumdays[0]=0;\\n       for(int i=1;i<=12;i++)\\n       {\\n           sumdays[i]=sumdays[i-1]+Days[i-1];\\n       }\\n       int arrival=max(totalDays(arriveAlice),totalDays(arriveBob));\\n       int departure=min(totalDays(leaveAlice),totalDays(leaveBob));\\n       int ans=departure-arrival+1;\\n        return max(0,ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumdays[13];\\n    int Days[12]={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int totalDays(string str)\\n    {\\n        int month=stoi(str.substr(0,2)), day=stoi(str.substr(3));\\n        return sumdays[month-1]+day;\\n    }\\n\\n\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        sumdays[0]=0;\\n       for(int i=1;i<=12;i++)\\n       {\\n           sumdays[i]=sumdays[i-1]+Days[i-1];\\n       }\\n       int arrival=max(totalDays(arriveAlice),totalDays(arriveBob));\\n       int departure=min(totalDays(leaveAlice),totalDays(leaveBob));\\n       int ans=departure-arrival+1;\\n        return max(0,ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326455,
                "title": "beat-98-79-23ms-python3-import-datetime-solution-one-liner-easy-understanding",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom datetime import datetime\\nclass Solution:\\n    def countDaysTogether(self, AA: str, LA: str, AB: str, LB: str) -> int:\\n        start , end = max(AA, AB), min(LA, LB)\\n        if start > end: return 0\\n        x = datetime.strptime(start, \\'%m-%d\\')\\n        y = datetime.strptime(end, \\'%m-%d\\')\\n        return abs((y - x).days)  + 1\\n\\n        #One-liner \\n\\n\\n        return abs((datetime.strptime(min(LA, LB), \\'%m-%d\\') - datetime.strptime(max(AA, AB), \\'%m-%d\\')).days)  + 1 if max(AA, AB) < min(LA, LB) else 0\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "String"
                ],
                "code": "```\\nfrom datetime import datetime\\nclass Solution:\\n    def countDaysTogether(self, AA: str, LA: str, AB: str, LB: str) -> int:\\n        start , end = max(AA, AB), min(LA, LB)\\n        if start > end: return 0\\n        x = datetime.strptime(start, \\'%m-%d\\')\\n        y = datetime.strptime(end, \\'%m-%d\\')\\n        return abs((y - x).days)  + 1\\n\\n        #One-liner \\n\\n\\n        return abs((datetime.strptime(min(LA, LB), \\'%m-%d\\') - datetime.strptime(max(AA, AB), \\'%m-%d\\')).days)  + 1 if max(AA, AB) < min(LA, LB) else 0\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828976,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nint md[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\nclass Solution {\\n    int td(string s) {\\n        int m = s[1] - \\'0\\' + 10*(s[0] - \\'0\\');\\n        int d = s[4] - \\'0\\' + 10*(s[3] - \\'0\\');\\n        --m;\\n        while (m > 0) {\\n            d += md[m];\\n            --m;\\n        }\\n        return d;\\n    }\\npublic:\\n    int countDaysTogether(string sa1, string sa2, string sb1, string sb2) {\\n        int a1 = td(sa1), a2 = td(sa2), b1 = td(sb1), b2 = td(sb2);\\n        int ans = 0;\\n        for (int i = 0; i < 367; ++i) {\\n            if (a1 <= i && i <= a2 && b1 <= i && i <= b2) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint md[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\nclass Solution {\\n    int td(string s) {\\n        int m = s[1] - \\'0\\' + 10*(s[0] - \\'0\\');\\n        int d = s[4] - \\'0\\' + 10*(s[3] - \\'0\\');\\n        --m;\\n        while (m > 0) {\\n            d += md[m];\\n            --m;\\n        }\\n        return d;\\n    }\\npublic:\\n    int countDaysTogether(string sa1, string sa2, string sb1, string sb2) {\\n        int a1 = td(sa1), a2 = td(sa2), b1 = td(sb1), b2 = td(sb2);\\n        int ans = 0;\\n        for (int i = 0; i < 367; ++i) {\\n            if (a1 <= i && i <= a2 && b1 <= i && i <= b2) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641625,
                "title": "c-straightforward-solution",
                "content": "```\\npublic class Solution {\\n    public int CountDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        string start = String.Compare(arriveAlice,arriveBob)>0 ? arriveAlice : arriveBob;\\n        string end = String.Compare(leaveAlice,leaveBob)>0 ? leaveBob : leaveAlice;\\n        int res = (Convert.ToDateTime(end) - Convert.ToDateTime(start)).Days + 1;\\n        return res>0 ? res : 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int CountDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        string start = String.Compare(arriveAlice,arriveBob)>0 ? arriveAlice : arriveBob;\\n        string end = String.Compare(leaveAlice,leaveBob)>0 ? leaveBob : leaveAlice;\\n        int res = (Convert.ToDateTime(end) - Convert.ToDateTime(start)).Days + 1;\\n        return res>0 ? res : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635606,
                "title": "c-with-comments",
                "content": "class Solution {\\npublic:\\n    int days[12]={0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n    //this array adds all the days upto first of each month\\n    int totaldays(string &d)\\n    {\\n        //eg: 08-15\\n        //days[0x10+8-1]+1x10+5=days[8](month aug)+15=243+15=258th day from jan 1st\\n        return days[10*(d[0]-\\'0\\')+d[1]-\\'0\\'-1]+(d[3]-\\'0\\')*10+d[4]-\\'0\\';\\n    }\\n    //this function will add the no of days passed in string date\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        //first we count no of days till the given date in the string\\n       int leaving_days=min(totaldays(leaveAlice),totaldays(leaveBob));\\n        int arriving_days=max(totaldays(arriveAlice),totaldays(arriveBob));\\n        int common_days=leaving_days-arriving_days+1;\\n        return max(0,common_days);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int days[12]={0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334}",
                "codeTag": "Java"
            },
            {
                "id": 2635033,
                "title": "c-easy-to-understand",
                "content": "class Solution {\\nprivate:\\nint days[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\nvector<int> sumDays;\\n\\npublic:\\nint totalDays(string str){\\n    int month = stoi(str.substr(0, 2)), day = stoi(str.substr(3));    \\n    return sumDays[month - 1] + day;\\n}\\nint countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n    sumDays.push_back(0);\\n    for(int i =0;i<12;i++){\\n        sumDays.push_back(sumDays.back() + days[i]);\\n    }\\n    \\n    int arrival = max(totalDays(arriveAlice), totalDays(arriveBob));\\n    int departure = min(totalDays(leaveAlice), totalDays(leaveBob));\\n    int countDays = departure - arrival +1;\\n    \\n\\treturn max(0, countDays);\\n    \\n\\t}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\nprivate:\\nint days[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}",
                "codeTag": "Java"
            },
            {
                "id": 2625298,
                "title": "python3-one-liner",
                "content": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        return max(0, 1 + min(sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(leaveAlice[:2]) - 1)]) + (int(leaveAlice[3:]) - 1), (sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(leaveBob[:2]) - 1)]) + (int(leaveBob[3:]) - 1))) - max(sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(arriveAlice[:2]) - 1)]) + (int(arriveAlice[3:]) - 1), (sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(arriveBob[:2]) - 1)])) + (int(arriveBob[3:]) - 1))) \\n\\n```\\nextremely unreadable one liner. I essentially found the minimum of the leave dates - max of the arrival dates + 1 and that\\'s the overlap. If there is no overlap then it\\'ll be negative so we just return the max of that and 0.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        return max(0, 1 + min(sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(leaveAlice[:2]) - 1)]) + (int(leaveAlice[3:]) - 1), (sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(leaveBob[:2]) - 1)]) + (int(leaveBob[3:]) - 1))) - max(sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(arriveAlice[:2]) - 1)]) + (int(arriveAlice[3:]) - 1), (sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(arriveBob[:2]) - 1)])) + (int(arriveBob[3:]) - 1))) \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609383,
                "title": "c-simple-easy-on-the-eyes-code-w-comments-beats-100",
                "content": "If you count the number of days elapsed since arrival and departure of both Alice and Bob. It\\'s very easy and intuitive to do the rest.\\n\\n```c++\\nclass Solution\\n{\\n\\t// \\t\\t\\t\\t\\t\\t   1   2   3   4   5   6   7   8   9   10  11  12\\n\\tvector<int> daysInMonth{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\n\\tint getDaysCount(string monthAndDate) // return number of days since start of year\\n\\t{\\n\\t\\tint month = stoi(monthAndDate.substr(0, 2)), date = stoi(monthAndDate.substr(3));\\n\\t\\tint days = 0;\\n\\n\\t\\twhile (month--)\\n\\t\\t\\tdays += daysInMonth.at(month);\\n\\n\\t\\treturn days + date;\\n\\t}\\n\\npublic:\\n\\tint countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n\\t{\\n\\t\\tint aliceIn = getDaysCount(arriveAlice), aliceOut = getDaysCount(leaveAlice);\\n\\t\\tint bobIn = getDaysCount(arriveBob), bobOut = getDaysCount(leaveBob);\\n\\n\\t\\tint common = min(aliceOut, bobOut) - max(aliceIn, bobIn) + 1; // (1)\\n\\n\\t\\treturn common > 0 ? common : 0; // (2)\\n\\t}\\n};\\n```\\n\\n**(1)** : `Min(out)` is used to see who left first & `Max(in)` is used to see who came last. Because common days will be between these 2 values.\\n\\n**(2)** : If there isn\\'t any common day(s) between them, then common will obviously be negative but the answer is `0`.",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution\\n{\\n\\t// \\t\\t\\t\\t\\t\\t   1   2   3   4   5   6   7   8   9   10  11  12\\n\\tvector<int> daysInMonth{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\n\\tint getDaysCount(string monthAndDate) // return number of days since start of year\\n\\t{\\n\\t\\tint month = stoi(monthAndDate.substr(0, 2)), date = stoi(monthAndDate.substr(3));\\n\\t\\tint days = 0;\\n\\n\\t\\twhile (month--)\\n\\t\\t\\tdays += daysInMonth.at(month);\\n\\n\\t\\treturn days + date;\\n\\t}\\n\\npublic:\\n\\tint countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n\\t{\\n\\t\\tint aliceIn = getDaysCount(arriveAlice), aliceOut = getDaysCount(leaveAlice);\\n\\t\\tint bobIn = getDaysCount(arriveBob), bobOut = getDaysCount(leaveBob);\\n\\n\\t\\tint common = min(aliceOut, bobOut) - max(aliceIn, bobIn) + 1; // (1)\\n\\n\\t\\treturn common > 0 ? common : 0; // (2)\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598458,
                "title": "easy-python3",
                "content": "\\tclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        day={1:31,2:28,3:31,4:30,5:31,6:30,\\n          7:31,8:31,9:30,10:31,11:30,12:31}\\n        \\n        def calc_days(datestring):\\n            m,d=datestring.split(\"-\")\\n            days=0\\n            for i in range(1,int(m)):\\n                days+=day[i]\\n            days+=int(d)\\n            return days\\n        \\n        pt1=max(calc_days(arriveAlice),calc_days(arriveBob))\\n        pt2=min(calc_days(leaveAlice),calc_days(leaveBob))\\n        \\n        if pt1>pt2:\\n            return 0\\n        else:\\n            return pt2-pt1+1",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        day={1:31,2:28,3:31,4:30,5:31,6:30,\\n          7:31,8:31,9:30,10:31,11:30,12:31}",
                "codeTag": "Java"
            },
            {
                "id": 2596515,
                "title": "java-calculate-day-of-year",
                "content": "```\\nclass Solution {\\n    private int[] days = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int aa = calculateDayOfYear(arriveAlice);\\n        int la = calculateDayOfYear(leaveAlice);\\n\\n        int ab = calculateDayOfYear(arriveBob);\\n        int lb = calculateDayOfYear(leaveBob);\\n        \\n        int laterArrive = Math.max(aa, ab);\\n        int earlierLeave = Math.min(la, lb);\\n        \\n        return earlierLeave - laterArrive < 0 ? 0 : earlierLeave - laterArrive + 1;\\n    }\\n    \\n    private int calculateDayOfYear(String obj){\\n        int month = parceMonth(obj);\\n        int day = parceDay(obj);\\n       \\n        int count = 0;\\n        while(month > 1){\\n            count += days[month - 2];\\n            month--;\\n        }\\n        return count + day;\\n    }\\n    \\n    private int parceMonth(String obj){\\n        return Integer.parseInt(obj.substring(0, 2));\\n    }\\n    \\n    private int parceDay(String obj){\\n        return Integer.parseInt(obj.substring(3, 5));\\n    }\\n}\\n```\\nPlease Upvote if you found this helpful",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int[] days = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int aa = calculateDayOfYear(arriveAlice);\\n        int la = calculateDayOfYear(leaveAlice);\\n\\n        int ab = calculateDayOfYear(arriveBob);\\n        int lb = calculateDayOfYear(leaveBob);\\n        \\n        int laterArrive = Math.max(aa, ab);\\n        int earlierLeave = Math.min(la, lb);\\n        \\n        return earlierLeave - laterArrive < 0 ? 0 : earlierLeave - laterArrive + 1;\\n    }\\n    \\n    private int calculateDayOfYear(String obj){\\n        int month = parceMonth(obj);\\n        int day = parceDay(obj);\\n       \\n        int count = 0;\\n        while(month > 1){\\n            count += days[month - 2];\\n            month--;\\n        }\\n        return count + day;\\n    }\\n    \\n    private int parceMonth(String obj){\\n        return Integer.parseInt(obj.substring(0, 2));\\n    }\\n    \\n    private int parceDay(String obj){\\n        return Integer.parseInt(obj.substring(3, 5));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592748,
                "title": "python-simple-to-understand-solution",
                "content": "Here\\'s the straightforward solution: \\n```\\nclass Solution:\\n    def calculate(self, time):\\n        days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        return sum(days[:int(time.split(\\'-\\')[0]) - 1]) + int(time.split(\\'-\\')[1])\\n\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        alice = [self.calculate(arriveAlice), self.calculate(leaveAlice)]\\n        bob = [self.calculate(arriveBob), self.calculate(leaveBob)]\\n        if bob[0] <= alice[0] <= bob[1]:\\n            if bob[1] <= alice[1]:\\n                return bob[1] - alice[0] + 1\\n            else:\\n                return alice[1] - alice[0] + 1\\n        elif alice[0] <= bob[0] <= alice[1]:\\n            if alice[1] <= bob[1]:\\n                return alice[1] - bob[0] + 1\\n            else:\\n                return bob[1] - bob[0] + 1\\n        else:\\n            return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, time):\\n        days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        return sum(days[:int(time.split(\\'-\\')[0]) - 1]) + int(time.split(\\'-\\')[1])\\n\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        alice = [self.calculate(arriveAlice), self.calculate(leaveAlice)]\\n        bob = [self.calculate(arriveBob), self.calculate(leaveBob)]\\n        if bob[0] <= alice[0] <= bob[1]:\\n            if bob[1] <= alice[1]:\\n                return bob[1] - alice[0] + 1\\n            else:\\n                return alice[1] - alice[0] + 1\\n        elif alice[0] <= bob[0] <= alice[1]:\\n            if alice[1] <= bob[1]:\\n                return alice[1] - bob[0] + 1\\n            else:\\n                return bob[1] - bob[0] + 1\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592247,
                "title": "java-simple-and-short-solution",
                "content": "1) Converting days from char to int\\n2) Calculating total no, of days\\n3) finally calculate the intersecting days and you are good to go\\n```\\nclass Solution {\\n  private  int []   months = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int helper(String s)\\n    {\\n        //converting days from char to Int\\n        int m=s.charAt(1)-\\'0\\'+10*(s.charAt(0)-\\'0\\'); //months\\n           int d=s.charAt(4)-\\'0\\'+10*(s.charAt(3)-\\'0\\'); //days  \\n        //calculating number of days\\n        --m;\\n        while(m>0)\\n        {\\n            d+=months[m];\\n            --m;\\n           }\\n        return d;\\n    }\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n     int a1 = helper(arriveAlice), a2 = helper(leaveAlice), b1 = helper(arriveBob), b2 = helper(leaveBob);\\n       //calculate intersecting days\\n       int ans = 0;\\n        for (int i = 0; i < 370; ++i) {\\n            if (a1 <= i && i <= a2 && b1 <= i && i <= b2) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n          }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  private  int []   months = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int helper(String s)\\n    {\\n        //converting days from char to Int\\n        int m=s.charAt(1)-\\'0\\'+10*(s.charAt(0)-\\'0\\'); //months\\n           int d=s.charAt(4)-\\'0\\'+10*(s.charAt(3)-\\'0\\'); //days  \\n        //calculating number of days\\n        --m;\\n        while(m>0)\\n        {\\n            d+=months[m];\\n            --m;\\n           }\\n        return d;\\n    }\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n     int a1 = helper(arriveAlice), a2 = helper(leaveAlice), b1 = helper(arriveBob), b2 = helper(leaveBob);\\n       //calculate intersecting days\\n       int ans = 0;\\n        for (int i = 0; i < 370; ++i) {\\n            if (a1 <= i && i <= a2 && b1 <= i && i <= b2) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n          }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592212,
                "title": "ok",
                "content": "```\\nint countDaysTogether(string aA, string lA, string aB, string lB) \\n{\\n\\tauto d = [](auto & s)\\n\\t\\t\\t\\t\\t\\t { \\n\\t\\t\\t\\t\\t\\t\\t int m{10*s[0]+s[1]-11*\\'0\\'}, d{10*s[3]+s[4]-11*\\'0\\'};\\n\\t\\t\\t\\t\\t\\t\\t return 30*(m-1) + (m+(m>8))/2 - 2*(m>2) + d;    \\n\\t\\t\\t\\t\\t\\t };\\n\\treturn max(0, min(d(lA), d(lB))-max(d(aA), d(aB))+1);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint countDaysTogether(string aA, string lA, string aB, string lB) \\n{\\n\\tauto d = [](auto & s)\\n\\t\\t\\t\\t\\t\\t { \\n\\t\\t\\t\\t\\t\\t\\t int m{10*s[0]+s[1]-11*\\'0\\'}, d{10*s[3]+s[4]-11*\\'0\\'};\\n\\t\\t\\t\\t\\t\\t\\t return 30*(m-1) + (m+(m>8))/2 - 2*(m>2) + d;    \\n\\t\\t\\t\\t\\t\\t };\\n\\treturn max(0, min(d(lA), d(lB))-max(d(aA), d(aB))+1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2592060,
                "title": "take-it-easy-0ms-100-c",
                "content": "**Please Upvote If U like the solution :**\\n\\n\\n```\\nint countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int ans=0;\\n            vector<int> days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\t\\t\\t\\n\\t\\t\\t//Calculating the sum of days till a particular month\\n            \\n            vector<int> prefixSum ;\\n            int x =0;\\n            prefixSum.push_back(x);\\n            for(int i=0; i< 12;i++){\\n                    x+=days[i];\\n                   prefixSum.push_back(x);\\n            }\\n            int a = stoi(arriveAlice.substr(0,2))  -1;  //Alice Arriving month \\n            int b = stoi(leaveAlice.substr(0,2)) -1;  //Alice Leaving month \\n            int c= stoi(arriveBob.substr(0,2)) -1;  //Bob Arriving month \\n            int d = stoi(leaveBob.substr(0,2)) -1;  //Bob Leaving month \\n            \\n\\t\\t\\t\\n\\t\\t\\t// Now, calculating the particular day corresponding to a date of Alice and Bob \\n\\t\\t\\t\\n            int Aa = prefixSum[a] + stoi(arriveAlice.substr(3,2)) ;\\n            int Al = prefixSum[b ] + stoi(leaveAlice.substr(3,2)) ;\\n            int Ba = prefixSum[c ] + stoi(arriveBob.substr(3,2)) ;\\n            int Bl = prefixSum[d ] + stoi(leaveBob.substr(3,2)) ;\\n            \\n\\t\\t\\t//Comparing \\n            \\n            if((Ba > Al) || (Aa > Bl)){\\n                    ans = 0;\\n            }else if(Ba <= Al && Ba >= Aa){\\n                    if(Al < Bl){\\n                          ans = Al - Ba +1;  \\n                    }else{\\n                          ans = Bl- Ba +1;  \\n                    }\\n            }else if(Aa <= Bl && Aa >= Ba){\\n                    if(Bl < Al){\\n                          ans = Bl - Aa+1;  \\n                    }else{\\n                          ans = Al - Aa+1;  \\n                    }\\n            }\\n           return ans;\\n\\t\\t   }\\n\\n```\\n**THANK YOU**",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nint countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int ans=0;\\n            vector<int> days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\t\\t\\t\\n\\t\\t\\t//Calculating the sum of days till a particular month\\n            \\n            vector<int> prefixSum ;\\n            int x =0;\\n            prefixSum.push_back(x);\\n            for(int i=0; i< 12;i++){\\n                    x+=days[i];\\n                   prefixSum.push_back(x);\\n            }\\n            int a = stoi(arriveAlice.substr(0,2))  -1;  //Alice Arriving month \\n            int b = stoi(leaveAlice.substr(0,2)) -1;  //Alice Leaving month \\n            int c= stoi(arriveBob.substr(0,2)) -1;  //Bob Arriving month \\n            int d = stoi(leaveBob.substr(0,2)) -1;  //Bob Leaving month \\n            \\n\\t\\t\\t\\n\\t\\t\\t// Now, calculating the particular day corresponding to a date of Alice and Bob \\n\\t\\t\\t\\n            int Aa = prefixSum[a] + stoi(arriveAlice.substr(3,2)) ;\\n            int Al = prefixSum[b ] + stoi(leaveAlice.substr(3,2)) ;\\n            int Ba = prefixSum[c ] + stoi(arriveBob.substr(3,2)) ;\\n            int Bl = prefixSum[d ] + stoi(leaveBob.substr(3,2)) ;\\n            \\n\\t\\t\\t//Comparing \\n            \\n            if((Ba > Al) || (Aa > Bl)){\\n                    ans = 0;\\n            }else if(Ba <= Al && Ba >= Aa){\\n                    if(Al < Bl){\\n                          ans = Al - Ba +1;  \\n                    }else{\\n                          ans = Bl- Ba +1;  \\n                    }\\n            }else if(Aa <= Bl && Aa >= Ba){\\n                    if(Bl < Al){\\n                          ans = Bl - Aa+1;  \\n                    }else{\\n                          ans = Al - Aa+1;  \\n                    }\\n            }\\n           return ans;\\n\\t\\t   }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2591768,
                "title": "c-solution-with-explanation-beats-100-o-1-easy-to-understand",
                "content": "**DO A DRY RUN FOR BETTER CLARITY**\\n\\n***PLEASE UP-VOTE***\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int month[13]={0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};  // initialising a month array for every month\\n    \\n    int  convert(string &s)   // function to convert dates to number of days \\n    {\\n        string m,d;        // extracting the character from string and storing into a variable for months\\n        m+=s[0];\\n        m+=s[1];\\n                           // we have to do this as there is an higphen (-) in the given string\\n        \\n         d+=s[3];          //extracting the character from string and storing into a variable for months\\n         d+=s[4];\\n        \\n        int count=0,i,mm,dd;   // count will store the total days for everyones arrival and departure \\n        \\n         mm=stoi(m);          // converting string to integer for months as well as for days \\n         dd=stoi(d);\\n        \\n        \\n        for( i = 0 ; i<mm ; i++){        // calculating total number of days for a given month \\n            count=count+month[i];\\n            \\n        }\\n            \\n          count+=dd;            // adding the number of days in count \\n        return count;\\n        }\\n        \\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) \\n    {\\n        int arralice=convert(arriveAlice);\\n        int leaalice=convert(leaveAlice);\\n        int arrbob=convert(arriveBob);\\n        int leabob=convert(leaveBob);\\n        \\n        int arrivetime=max(arralice,arrbob);\\n        int leavetime=min(leaalice,leabob);\\n        \\n        if(arrivetime>leavetime)       // if this is the case no presence will be posssible for them together \\n            return 0;                  // therefore returning 0\\n       \\n            return leavetime-arrivetime+1;       // this will give intersection of both alice and bobs time\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    int month[13]={0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}",
                "codeTag": "Java"
            },
            {
                "id": 2591757,
                "title": "c-convert-all-day-month-to-specific-i-th-day-easy-but-unefficient-approach",
                "content": "Selft Explainatory Code: Converting {i-th month,j-th day } to particuler indexed day \\nfor e.g.- 1st day of january =>{01-01} =>1.\\n...\\n             31st December=>{12-31} =>365 th day.\\n\\t\\t\\t This Brute Force Approach is just for clear understanding.\\n```\\nclass Solution {\\npublic:\\n    map<vector<int>, int>mp;\\n    int i;\\n    void day_30(int m)\\n    {\\n        for(int d=1;d<=30;d++)\\n        {\\n            mp[{d,m}]=i;\\n            i++;\\n        }\\n        return;\\n    }\\n    void day_31(int m)\\n    {\\n        for(int d=1;d<=31;d++)\\n        {\\n            mp[{d,m}]=i;\\n            i++;\\n        }\\n        return;\\n    }\\n    void day_28(int m)\\n    {\\n        for(int d=1;d<=28;d++)\\n        {\\n            mp[{d,m}]=i;\\n            i++;\\n        }\\n        return;\\n    }\\n    int get_day(string s)\\n    {\\n        string str=s.substr(3);\\n        return stoi(str);\\n    }\\n    int get_month(string s)\\n    {\\n        string str=s.substr(0,3);\\n        return stoi(str);\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        i=1;\\n        day_31(1);\\n        day_28(2);\\n        day_31(3);\\n        day_30(4);\\n        day_31(5);\\n        day_30(6);\\n        day_31(7);\\n        day_31(8);\\n        day_30(9);\\n        day_31(10);\\n        day_30(11);\\n        day_31(12);\\n        \\n        int ad1,ad2,am1,am2;\\n        ad1=get_day(arriveAlice);\\n        ad2=get_day(leaveAlice);\\n        am1=get_month(arriveAlice);\\n        am2=get_month(leaveAlice);\\n        \\n        \\n        \\n        int bd1,bd2,bm1,bm2;\\n        bd1=get_day(arriveBob);\\n        bd2=get_day(leaveBob);\\n        bm1=get_month(arriveBob);\\n        bm2=get_month(leaveBob);\\n        \\n        vector<int>visited(366,-1);\\n        int ans=0;        \\n        \\n        for(int i=mp[{ad1,am1}];i<=mp[{ad2,am2}];i++)\\n        {\\n            visited[i]=0;\\n        }\\n\\n        for(int i=mp[{bd1,bm1}];i<=mp[{bd2,bm2}];i++)\\n        {\\n            if(visited[i]==0)\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nUndoubtly ! Consuming too much extra space.\\nUpvote if you like it.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<vector<int>, int>mp;\\n    int i;\\n    void day_30(int m)\\n    {\\n        for(int d=1;d<=30;d++)\\n        {\\n            mp[{d,m}]=i;\\n            i++;\\n        }\\n        return;\\n    }\\n    void day_31(int m)\\n    {\\n        for(int d=1;d<=31;d++)\\n        {\\n            mp[{d,m}]=i;\\n            i++;\\n        }\\n        return;\\n    }\\n    void day_28(int m)\\n    {\\n        for(int d=1;d<=28;d++)\\n        {\\n            mp[{d,m}]=i;\\n            i++;\\n        }\\n        return;\\n    }\\n    int get_day(string s)\\n    {\\n        string str=s.substr(3);\\n        return stoi(str);\\n    }\\n    int get_month(string s)\\n    {\\n        string str=s.substr(0,3);\\n        return stoi(str);\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        i=1;\\n        day_31(1);\\n        day_28(2);\\n        day_31(3);\\n        day_30(4);\\n        day_31(5);\\n        day_30(6);\\n        day_31(7);\\n        day_31(8);\\n        day_30(9);\\n        day_31(10);\\n        day_30(11);\\n        day_31(12);\\n        \\n        int ad1,ad2,am1,am2;\\n        ad1=get_day(arriveAlice);\\n        ad2=get_day(leaveAlice);\\n        am1=get_month(arriveAlice);\\n        am2=get_month(leaveAlice);\\n        \\n        \\n        \\n        int bd1,bd2,bm1,bm2;\\n        bd1=get_day(arriveBob);\\n        bd2=get_day(leaveBob);\\n        bm1=get_month(arriveBob);\\n        bm2=get_month(leaveBob);\\n        \\n        vector<int>visited(366,-1);\\n        int ans=0;        \\n        \\n        for(int i=mp[{ad1,am1}];i<=mp[{ad2,am2}];i++)\\n        {\\n            visited[i]=0;\\n        }\\n\\n        for(int i=mp[{bd1,bm1}];i<=mp[{bd2,bm2}];i++)\\n        {\\n            if(visited[i]==0)\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591727,
                "title": "java-solution-easy-solution-intersection-of-dates",
                "content": "```java\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n               \\n        int[] month = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n        \\n        String[] alice1 = arriveAlice.split(\"-\");  //Alice Arrival\\n        String[] alice2 = leaveAlice.split(\"-\");  //Alice Departure\\n        String[] bob1 = arriveBob.split(\"-\");   //Bob Arrival \\n        String[] bob2 = leaveBob.split(\"-\");   //Bob Departure\\n        \\n        int d1,d2;\\n        int ma1 = Integer.parseInt(alice1[0]);  //Alice Arrival Month\\n        int mb1 = Integer.parseInt(bob1[0]);  //Bob Arrival Month\\n        int ma2 = Integer.parseInt(alice2[0]);  //Alice Departure Month\\n        int mb2 = Integer.parseInt(bob2[0]);   //Bob Departure Month\\n        \\n        if(ma1 > mb1)\\n            d1 = Integer.parseInt(alice1[1]);\\n        else if(ma1 < mb1)\\n            d1 = Integer.parseInt(bob1[1]);\\n        else \\n            d1 = Math.max(Integer.parseInt(alice1[1]),Integer.parseInt(bob1[1]));\\n        \\n        if(ma2 < mb2)\\n            d2 = Integer.parseInt(alice2[1]);\\n        else if(ma2> mb2)\\n            d2 = Integer.parseInt(bob2[1]);\\n        else \\n            d2 = Math.min(Integer.parseInt(alice2[1]),Integer.parseInt(bob2[1]));\\n    \\n        int m1  = Math.max(ma1,mb1);\\n        int m2  = Math.min(ma2,mb2);\\n     \\n        return Math.max(0,(month[m2-1]+d2)-(month[m1-1]+d1)+1);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n               \\n        int[] month = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334}",
                "codeTag": "Java"
            },
            {
                "id": 2591406,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int[] daysInMonth = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        String startDate = arriveAlice.compareTo(arriveBob) > 0 ? arriveAlice : arriveBob;\\n        String endDate = leaveAlice.compareTo(leaveBob) < 0 ? leaveAlice : leaveBob;\\n        if(startDate.compareTo(endDate) > 0) {\\n            return 0;\\n        }\\n        int startMonth = Integer.parseInt(startDate.substring(0, 2));\\n        int startDay = Integer.parseInt(startDate.substring(3));\\n        int endMonth = Integer.parseInt(endDate.substring(0, 2));\\n        int endDay = Integer.parseInt(endDate.substring(3));\\n        \\n        if(startMonth == endMonth) {\\n            return endDay - startDay + 1;\\n        } else { \\n            int daysSpentTogether = daysInMonth[startMonth - 1] - startDay;\\n            for(int month = startMonth + 1; month < endMonth; month++) {\\n                daysSpentTogether += daysInMonth[month - 1];\\n            }\\n            daysSpentTogether += endDay + 1;\\n            return daysSpentTogether;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int[] daysInMonth = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        String startDate = arriveAlice.compareTo(arriveBob) > 0 ? arriveAlice : arriveBob;\\n        String endDate = leaveAlice.compareTo(leaveBob) < 0 ? leaveAlice : leaveBob;\\n        if(startDate.compareTo(endDate) > 0) {\\n            return 0;\\n        }\\n        int startMonth = Integer.parseInt(startDate.substring(0, 2));\\n        int startDay = Integer.parseInt(startDate.substring(3));\\n        int endMonth = Integer.parseInt(endDate.substring(0, 2));\\n        int endDay = Integer.parseInt(endDate.substring(3));\\n        \\n        if(startMonth == endMonth) {\\n            return endDay - startDay + 1;\\n        } else { \\n            int daysSpentTogether = daysInMonth[startMonth - 1] - startDay;\\n            for(int month = startMonth + 1; month < endMonth; month++) {\\n                daysSpentTogether += daysInMonth[month - 1];\\n            }\\n            daysSpentTogether += endDay + 1;\\n            return daysSpentTogether;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591360,
                "title": "kinda-hard-to-figure-out-the-logic-for-me",
                "content": "```\\nclass Solution\\n{\\n    public:\\n    int days(string d)\\n    {\\n        int mp[12]={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int m=(d[0]-48)*10+(d[1]-48);\\n        int nd=(d[3]-48)*10+(d[4]-48);\\n        int ans=0;\\n        for(int i=0;i<m-1;i++)\\n            ans+=mp[i];\\n        return ans+nd;\\n        \\n    }\\n        int countDaysTogether(string aa, string la, string ab, string lb) \\n        {\\n            \\n            int cnt=0;\\n            for(int i=1;i<=365;i++)\\n            {\\n                if(days(aa)<=i && i<=days(la) && days(ab)<=i && i<=days(lb))\\n                    cnt+=1;\\n            }\\n            return cnt;\\n        }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    int days(string d)\\n    {\\n        int mp[12]={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int m=(d[0]-48)*10+(d[1]-48);\\n        int nd=(d[3]-48)*10+(d[4]-48);\\n        int ans=0;\\n        for(int i=0;i<m-1;i++)\\n            ans+=mp[i];\\n        return ans+nd;\\n        \\n    }\\n        int countDaysTogether(string aa, string la, string ab, string lb) \\n        {\\n            \\n            int cnt=0;\\n            for(int i=1;i<=365;i++)\\n            {\\n                if(days(aa)<=i && i<=days(la) && days(ab)<=i && i<=days(lb))\\n                    cnt+=1;\\n            }\\n            return cnt;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589704,
                "title": "dew-it-very-concise-java-solution-simple-and-logical",
                "content": "Break this into two problems\\n\\n**SUB-PROBLEM 1**\\n* ***Parse date string as the `n`th day of the year***\\nIllustrative examples: `01-01` is the 1st day and `12-31` is the 365th\\n* To achieve this, all we need to do is add\\n(1) the *day of the month* and\\n(2) the *number of days before the month*\\n\\nWe precompute (2) and store in a `cumu` array\\n\\n**SUB-PROBLEM 2**\\n* ***Devise logic to count overlapping days***\\nAssuming that the dates are in the \"`n`th day of the year\" format\\n* Idea 1: The first day at which the overlap *might* begin is `max(arriveAlice, arriveBob)` (3)\\nIdea 2: The last day at which the overlap *might* end is `min(leaveAlice, leaveBob)` (4)\\n\\nSo, is `(4) - (3) + 1` the answer? No\\n* Observation 1: If there IS overlap, `(4) - (3) + 1` will be positive (and equal to the answer we seek)\\nObservation 2: If there is no overlap, `(4) - (3) + 1` will be zero Or negative (in which case, the answer we seek is `0`)\\n\\nSo we return `max(0, (4) - (3) + 1)`\\n\\n```\\nclass Solution {\\n    int[] cumu = {0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};\\n    \\n    public int countDaysTogether(String a, String b, String c, String d) {\\n        return Math.max(0, 1 + Math.min(get(b), get(d)) - Math.max(get(a), get(c)));\\n    }\\n    \\n    private int get(String s) {\\n        String[] split = s.split(\"-\");\\n        return Integer.valueOf(split[1]) + cumu[Integer.valueOf(split[0])];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] cumu = {0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};\\n    \\n    public int countDaysTogether(String a, String b, String c, String d) {\\n        return Math.max(0, 1 + Math.min(get(b), get(d)) - Math.max(get(a), get(c)));\\n    }\\n    \\n    private int get(String s) {\\n        String[] split = s.split(\"-\");\\n        return Integer.valueOf(split[1]) + cumu[Integer.valueOf(split[0])];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589515,
                "title": "convert-date-to-number-in-year-o-1-clean-code-0ms",
                "content": "```\\n```\\n    int countDaysTogether(string aA, string lA, string aBob, string lBob) {\\n        int amA=stoi(aA.substr(0,2));\\n        int lmA=stoi(lA.substr(0,2));\\n        int amB=stoi(aBob.substr(0,2));\\n        int lmB=stoi(lBob.substr(0,2));\\n        \\n        int arr[13]={0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        for(int i=1;i<13;i++)\\n        {\\n            arr[i]=arr[i]+arr[i-1];\\n        }\\n        int temp1=arr[amA-1];\\n        temp1+=stoi(aA.substr(3,5));\\n                    \\n        int temp2=arr[lmA-1];\\n        temp2+=stoi(lA.substr(3,5));\\n        \\n        int temp3=arr[amB-1];\\n        temp3+=stoi(aBob.substr(3,5));\\n                    \\n        int temp4=arr[lmB-1];\\n        temp4+=stoi(lBob.substr(3,5));\\n        \\n        int mx=max(temp1,temp3);\\n        int mn=min(temp2,temp4);\\n        \\n        return max(0,mn-mx+1);\\n                    \\n    }\\n```\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589152,
                "title": "java-solution-complex-but-simple-commented-readable-code",
                "content": "#### If you understood the solution then **please upvote it** !!!\\n```\\nclass Solution {\\n    // Number of days in each month whichh will help us calculate n-th day in 0-365\\n    int[] monthDays = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};  \\n    \\n    // Returns the n-th day in (0-365) days of the year\\n    private int getNthDay(int month, int day) {\\n        int totalDays = 0;\\n        for (int i = 1; i < month; i++) {\\n            totalDays += monthDays[i];\\n        }\\n        \\n        totalDays += day;\\n        return totalDays;\\n    }\\n    \\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        \\n        // We split the string and make an array as {\"MM\", \"DD\"} for Alice\\n        String[] aliceArr = arriveAlice.split(\"-\");\\n        String[] aliceLea = leaveAlice.split(\"-\");\\n        \\n        // We get the month and day when Alice arrived\\n        int aliceArriveMon = Integer.parseInt(aliceArr[0]);\\n        int aliceArriveDay = Integer.parseInt(aliceArr[1]);\\n        \\n        // We get the month and day when Alice left\\n        int aliceLeaveMon = Integer.parseInt(aliceLea[0]);\\n        int aliceLeaveDay = Integer.parseInt(aliceLea[1]);\\n        \\n        \\n        // We split the string and make an array as {\"MM\", \"DD\"} for Bob\\n        String[] bobArr = arriveBob.split(\"-\");\\n        String[] bobLea = leaveBob.split(\"-\");\\n        \\n        // We get the month and day when Bob arrived\\n        int bobArriveMon = Integer.parseInt(bobArr[0]);\\n        int bobArriveDay = Integer.parseInt(bobArr[1]);\\n        \\n        // We get the month and day when Alice left\\n        int bobLeaveMon = Integer.parseInt(bobLea[0]);\\n        int bobLeaveDay = Integer.parseInt(bobLea[1]);\\n        \\n        \\n        // We get the n-th day in 0-365 when Alice arrived and left\\n        int aliceArriveNthDay = getNthDay(aliceArriveMon, aliceArriveDay);\\n        int aliceLeaveNthDay = getNthDay(aliceLeaveMon, aliceLeaveDay);\\n        \\n        // We get the n-th day in 0-365 when Bob arrived and left\\n        int bobArriveNthDay = getNthDay(bobArriveMon, bobArriveDay);\\n        int bobLeaveNthDay = getNthDay(bobLeaveMon, bobLeaveDay);\\n        \\n        \\n        // We initialise a common day count\\n        int commonDays = 0;\\n        \\n        When i falls in their common staying range we increment ans\\n        for (int i = aliceArriveNthDay; i <= aliceLeaveNthDay; i++) {\\n            if (i >= bobArriveNthDay && i <= bobLeaveNthDay) commonDays++;\\n        }\\n        \\n        return ans;\\n        \\n        // int commonDays = Math.min(aliceLeaveNthDay, bobLeaveNthDay) - Math.max(aliceArriveNthDay, bobArriveNthDay) + 1;\\n        // return Math.max(commonDays, 0);\\n    }    \\n}\\n\\n// TC: 4 * O(12) + O(365) => O(1)\\n// SC: 4 * O(2) => O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // Number of days in each month whichh will help us calculate n-th day in 0-365\\n    int[] monthDays = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};  \\n    \\n    // Returns the n-th day in (0-365) days of the year\\n    private int getNthDay(int month, int day) {\\n        int totalDays = 0;\\n        for (int i = 1; i < month; i++) {\\n            totalDays += monthDays[i];\\n        }\\n        \\n        totalDays += day;\\n        return totalDays;\\n    }\\n    \\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        \\n        // We split the string and make an array as {\"MM\", \"DD\"} for Alice\\n        String[] aliceArr = arriveAlice.split(\"-\");\\n        String[] aliceLea = leaveAlice.split(\"-\");\\n        \\n        // We get the month and day when Alice arrived\\n        int aliceArriveMon = Integer.parseInt(aliceArr[0]);\\n        int aliceArriveDay = Integer.parseInt(aliceArr[1]);\\n        \\n        // We get the month and day when Alice left\\n        int aliceLeaveMon = Integer.parseInt(aliceLea[0]);\\n        int aliceLeaveDay = Integer.parseInt(aliceLea[1]);\\n        \\n        \\n        // We split the string and make an array as {\"MM\", \"DD\"} for Bob\\n        String[] bobArr = arriveBob.split(\"-\");\\n        String[] bobLea = leaveBob.split(\"-\");\\n        \\n        // We get the month and day when Bob arrived\\n        int bobArriveMon = Integer.parseInt(bobArr[0]);\\n        int bobArriveDay = Integer.parseInt(bobArr[1]);\\n        \\n        // We get the month and day when Alice left\\n        int bobLeaveMon = Integer.parseInt(bobLea[0]);\\n        int bobLeaveDay = Integer.parseInt(bobLea[1]);\\n        \\n        \\n        // We get the n-th day in 0-365 when Alice arrived and left\\n        int aliceArriveNthDay = getNthDay(aliceArriveMon, aliceArriveDay);\\n        int aliceLeaveNthDay = getNthDay(aliceLeaveMon, aliceLeaveDay);\\n        \\n        // We get the n-th day in 0-365 when Bob arrived and left\\n        int bobArriveNthDay = getNthDay(bobArriveMon, bobArriveDay);\\n        int bobLeaveNthDay = getNthDay(bobLeaveMon, bobLeaveDay);\\n        \\n        \\n        // We initialise a common day count\\n        int commonDays = 0;\\n        \\n        When i falls in their common staying range we increment ans\\n        for (int i = aliceArriveNthDay; i <= aliceLeaveNthDay; i++) {\\n            if (i >= bobArriveNthDay && i <= bobLeaveNthDay) commonDays++;\\n        }\\n        \\n        return ans;\\n        \\n        // int commonDays = Math.min(aliceLeaveNthDay, bobLeaveNthDay) - Math.max(aliceArriveNthDay, bobArriveNthDay) + 1;\\n        // return Math.max(commonDays, 0);\\n    }    \\n}\\n\\n// TC: 4 * O(12) + O(365) => O(1)\\n// SC: 4 * O(2) => O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588941,
                "title": "rust-solution",
                "content": "~~~\\nimpl Solution {\\n    pub fn count_days_together(arrive_alice: String, leave_alice: String, arrive_bob: String, leave_bob: String) -> i32 {\\n        let a = arrive_alice.max(arrive_bob).chars().collect::<Vec<char>>();\\n        let d = leave_alice.min(leave_bob).chars().collect::<Vec<char>>();\\n        \\n        let mut ma = (a[0] as u8 - \\'0\\' as u8) * 10 + a[1] as u8 - \\'0\\' as u8;\\n        let md = (d[0] as u8 - \\'0\\' as u8) * 10 + d[1] as u8 - \\'0\\' as u8;\\n        if ma > md { return 0 }\\n        \\n        let mut ret = 0;\\n        while ma < md {\\n            match ma {\\n                1 | 3 | 5 | 7 | 8 | 10 => { ret += 31; }\\n                2 => { ret += 28; }\\n                _ => { ret += 30; }\\n            }\\n            ma += 1;\\n        }\\n        \\n        let da = (a[3] as u8 - \\'0\\' as u8) * 10 + a[4] as u8 - \\'0\\' as u8;\\n        let dd = (d[3] as u8 - \\'0\\' as u8) * 10 + d[4] as u8 - \\'0\\' as u8;\\n        \\n        0.max(ret as i32 + dd as i32 - da as i32 + 1)\\n        \\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust"
                ],
                "code": "~~~\\nimpl Solution {\\n    pub fn count_days_together(arrive_alice: String, leave_alice: String, arrive_bob: String, leave_bob: String) -> i32 {\\n        let a = arrive_alice.max(arrive_bob).chars().collect::<Vec<char>>();\\n        let d = leave_alice.min(leave_bob).chars().collect::<Vec<char>>();\\n        \\n        let mut ma = (a[0] as u8 - \\'0\\' as u8) * 10 + a[1] as u8 - \\'0\\' as u8;\\n        let md = (d[0] as u8 - \\'0\\' as u8) * 10 + d[1] as u8 - \\'0\\' as u8;\\n        if ma > md { return 0 }\\n        \\n        let mut ret = 0;\\n        while ma < md {\\n            match ma {\\n                1 | 3 | 5 | 7 | 8 | 10 => { ret += 31; }\\n                2 => { ret += 28; }\\n                _ => { ret += 30; }\\n            }\\n            ma += 1;\\n        }\\n        \\n        let da = (a[3] as u8 - \\'0\\' as u8) * 10 + a[4] as u8 - \\'0\\' as u8;\\n        let dd = (d[3] as u8 - \\'0\\' as u8) * 10 + d[4] as u8 - \\'0\\' as u8;\\n        \\n        0.max(ret as i32 + dd as i32 - da as i32 + 1)\\n        \\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2588686,
                "title": "c-easy-to-understanding-solution-small-code",
                "content": "- Just Convert date to which day in year i.e. \"01-15\" is 15th day , like \"02-14\" is 45th day and \"03-27\" is 86th day in year\\n```\\nclass Solution {\\npublic:\\n    int dayInMonths[13] = {0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n\\t// function for converting string in which day in year\\n    int days(string s){\\n        int month = s[1]-\\'0\\' + 10*(s[0]-\\'0\\');\\n        int day = s[4]-\\'0\\' + 10*(s[3]-\\'0\\');\\n        month--;\\n        while(month){\\n            day += dayInMonths[month];\\n            month--;       \\n        }\\n        return day;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int a1 = days(arriveAlice);\\n        int a2 = days(leaveAlice);\\n        int b1 = days(arriveBob);\\n        int b2 = days(leaveBob);\\n\\n        return max(0,min(a2,b2)-max(a1,b1)+1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dayInMonths[13] = {0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n\\t// function for converting string in which day in year\\n    int days(string s){\\n        int month = s[1]-\\'0\\' + 10*(s[0]-\\'0\\');\\n        int day = s[4]-\\'0\\' + 10*(s[3]-\\'0\\');\\n        month--;\\n        while(month){\\n            day += dayInMonths[month];\\n            month--;       \\n        }\\n        return day;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int a1 = days(arriveAlice);\\n        int a2 = days(leaveAlice);\\n        int b1 = days(arriveBob);\\n        int b2 = days(leaveBob);\\n\\n        return max(0,min(a2,b2)-max(a1,b1)+1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588680,
                "title": "c-convert-date-to-days-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int getDays(string s){\\n        vector<int> m = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int days = 0;\\n        int month = stoi(s.substr(0,2));\\n        int date = stoi(s.substr(3,2));\\n        \\n        for(int i=0; i<month-1; i++){\\n            days += m[i];\\n        }\\n        days += date;\\n        return days;\\n    }\\n    \\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int aa = getDays(arriveAlice);\\n        int la = getDays(leaveAlice);\\n        int ab = getDays(arriveBob);\\n        int lb = getDays(leaveBob);\\n        \\n        return max(0,min(la, lb)-max(aa, ab)+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getDays(string s){\\n        vector<int> m = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int days = 0;\\n        int month = stoi(s.substr(0,2));\\n        int date = stoi(s.substr(3,2));\\n        \\n        for(int i=0; i<month-1; i++){\\n            days += m[i];\\n        }\\n        days += date;\\n        return days;\\n    }\\n    \\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int aa = getDays(arriveAlice);\\n        int la = getDays(leaveAlice);\\n        int ab = getDays(arriveBob);\\n        int lb = getDays(leaveBob);\\n        \\n        return max(0,min(la, lb)-max(aa, ab)+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588642,
                "title": "java-easy-solution",
                "content": "First of all calculate the total number of days from 1st jan for each arrival and departure of Alice and Bob since inputs are in the same year.\\nFor example : Arrival time of Bob is \\'03-05\\' which means 5th of March, so total number of days from 1st jan will be 64 days.\\nNow check who will arrive first like for example if Alice arrive first , now the arrival days of Bob should be less than departure of Alice otherwise they will not meet. \\n\\n```\\nclass Solution \\n{\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) \\n    {\\n        int aamon = Integer.parseInt(arriveAlice.substring(0,2));\\n        int aadate = Integer.parseInt(arriveAlice.substring(3));\\n        int almon = Integer.parseInt(leaveAlice.substring(0,2));\\n        int aldate = Integer.parseInt(leaveAlice.substring(3));\\n        int bamon = Integer.parseInt(arriveBob.substring(0,2));\\n        int badate = Integer.parseInt(arriveBob.substring(3));\\n        int blmon = Integer.parseInt(leaveBob.substring(0,2));\\n        int bldate = Integer.parseInt(leaveBob.substring(3));\\n        \\n        int a[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int aarrive=0,aleave=0,barrive=0,bleave=0;\\n        int i;\\n        for(i=0;i<aamon-1;i++)\\n            aarrive+=a[i];\\n        aarrive+=aadate;\\n       \\n        for(i=0;i<almon-1;i++)\\n            aleave+=a[i];\\n        aleave+=aldate;\\n        \\n        for(i=0;i<bamon-1;i++)\\n            barrive+=a[i];\\n        barrive+=badate;\\n      \\n        for(i=0;i<blmon-1;i++)\\n            bleave+=a[i];\\n        bleave+=bldate;\\n      \\n        if(aarrive<=barrive)\\n        {\\n            if(aleave<barrive)\\n                return 0;\\n            else\\n                return Math.min(bleave,aleave)-barrive+1; // this condition is used for checking who will \\n\\t\\t\\t\\t//leave the town first till then only we will count the answer.\\n        }\\n        else\\n        {\\n            if(bleave<aarrive)\\n                return 0;\\n            else\\n            {\\n                return Math.min(bleave,aleave)-aarrive+1;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) \\n    {\\n        int aamon = Integer.parseInt(arriveAlice.substring(0,2));\\n        int aadate = Integer.parseInt(arriveAlice.substring(3));\\n        int almon = Integer.parseInt(leaveAlice.substring(0,2));\\n        int aldate = Integer.parseInt(leaveAlice.substring(3));\\n        int bamon = Integer.parseInt(arriveBob.substring(0,2));\\n        int badate = Integer.parseInt(arriveBob.substring(3));\\n        int blmon = Integer.parseInt(leaveBob.substring(0,2));\\n        int bldate = Integer.parseInt(leaveBob.substring(3));\\n        \\n        int a[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int aarrive=0,aleave=0,barrive=0,bleave=0;\\n        int i;\\n        for(i=0;i<aamon-1;i++)\\n            aarrive+=a[i];\\n        aarrive+=aadate;\\n       \\n        for(i=0;i<almon-1;i++)\\n            aleave+=a[i];\\n        aleave+=aldate;\\n        \\n        for(i=0;i<bamon-1;i++)\\n            barrive+=a[i];\\n        barrive+=badate;\\n      \\n        for(i=0;i<blmon-1;i++)\\n            bleave+=a[i];\\n        bleave+=bldate;\\n      \\n        if(aarrive<=barrive)\\n        {\\n            if(aleave<barrive)\\n                return 0;\\n            else\\n                return Math.min(bleave,aleave)-barrive+1; // this condition is used for checking who will \\n\\t\\t\\t\\t//leave the town first till then only we will count the answer.\\n        }\\n        else\\n        {\\n            if(bleave<aarrive)\\n                return 0;\\n            else\\n            {\\n                return Math.min(bleave,aleave)-aarrive+1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588618,
                "title": "c-0ms-explained",
                "content": "**Approach:**\\n\\n* convert the date into the number of days of that year\\n* example:\\n\\t* \"01-26\" is the 26th day of the year\\n\\t* \"02-26\" is the 57th day of the year\\n* now let alice arrives between a0 and a1 day \\n* and bob arrives between b0 and b1 day\\n* so just check for every day of the year how many days fall in both of the above category\\n\\n**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> v = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int solve(string s)\\n    {\\n        int m = (s[0] - \\'0\\') * 10 + (s[1] - \\'0\\');\\n        int d = (s[3] - \\'0\\') * 10 + (s[4] - \\'0\\');\\n        m--;\\n        while (m > 0)\\n        {\\n            d += v[m];\\n            m--;\\n        }\\n        return d;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n    {\\n        int a0 = solve(arriveAlice);\\n        int a1 = solve(leaveAlice);\\n        int b0 = solve(arriveBob);\\n        int b1 = solve(leaveBob);\\n        int ans = 0;\\n        for (int i = 0; i < 366; i++)\\n            if ((i >= a0 && i <= a1) && (i >= b0 && i <= b1))\\n                ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> v = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int solve(string s)\\n    {\\n        int m = (s[0] - \\'0\\') * 10 + (s[1] - \\'0\\');\\n        int d = (s[3] - \\'0\\') * 10 + (s[4] - \\'0\\');\\n        m--;\\n        while (m > 0)\\n        {\\n            d += v[m];\\n            m--;\\n        }\\n        return d;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n    {\\n        int a0 = solve(arriveAlice);\\n        int a1 = solve(leaveAlice);\\n        int b0 = solve(arriveBob);\\n        int b1 = solve(leaveBob);\\n        int ans = 0;\\n        for (int i = 0; i < 366; i++)\\n            if ((i >= a0 && i <= a1) && (i >= b0 && i <= b1))\\n                ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588594,
                "title": "c-solution-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        vector<int> days {0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int total_days=0;\\n        int aliceArriveMonth = stoi(arriveAlice.substr(0,2)), aliceLeaveMonth = stoi(leaveAlice.substr(0,2)), aliceArriveDay = stoi(arriveAlice.substr(3,2)), aliceLeaveDay = stoi(leaveAlice.substr(3,2));\\n        int bobArriveMonth = stoi(arriveBob.substr(0,2)), bobLeaveMonth = stoi(leaveBob.substr(0,2)), bobArriveDay = stoi(arriveBob.substr(3,2)), bobLeaveDay = stoi(leaveBob.substr(3,2));\\n        if(aliceLeaveMonth<bobArriveMonth || (aliceLeaveMonth==bobArriveMonth && aliceLeaveDay<bobArriveDay) || bobLeaveMonth<aliceArriveMonth || (bobLeaveMonth==aliceArriveMonth && bobLeaveDay<aliceArriveDay)) return 0;\\n        int start = aliceArriveMonth>bobArriveMonth?aliceArriveDay:aliceArriveMonth==bobArriveMonth?max(aliceArriveDay,bobArriveDay):bobArriveDay;\\n        int end = aliceLeaveMonth>bobLeaveMonth?bobLeaveDay:aliceLeaveMonth==bobLeaveMonth?min(aliceLeaveDay,bobLeaveDay):aliceLeaveDay;\\n        for(int i=max(aliceArriveMonth,bobArriveMonth); i<min(aliceLeaveMonth,bobLeaveMonth); ++i)\\n          total_days+=days[i];\\n        total_days+=(end-start+1);\\n        return total_days;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        vector<int> days {0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int total_days=0;\\n        int aliceArriveMonth = stoi(arriveAlice.substr(0,2)), aliceLeaveMonth = stoi(leaveAlice.substr(0,2)), aliceArriveDay = stoi(arriveAlice.substr(3,2)), aliceLeaveDay = stoi(leaveAlice.substr(3,2));\\n        int bobArriveMonth = stoi(arriveBob.substr(0,2)), bobLeaveMonth = stoi(leaveBob.substr(0,2)), bobArriveDay = stoi(arriveBob.substr(3,2)), bobLeaveDay = stoi(leaveBob.substr(3,2));\\n        if(aliceLeaveMonth<bobArriveMonth || (aliceLeaveMonth==bobArriveMonth && aliceLeaveDay<bobArriveDay) || bobLeaveMonth<aliceArriveMonth || (bobLeaveMonth==aliceArriveMonth && bobLeaveDay<aliceArriveDay)) return 0;\\n        int start = aliceArriveMonth>bobArriveMonth?aliceArriveDay:aliceArriveMonth==bobArriveMonth?max(aliceArriveDay,bobArriveDay):bobArriveDay;\\n        int end = aliceLeaveMonth>bobLeaveMonth?bobLeaveDay:aliceLeaveMonth==bobLeaveMonth?min(aliceLeaveDay,bobLeaveDay):aliceLeaveDay;\\n        for(int i=max(aliceArriveMonth,bobArriveMonth); i<min(aliceLeaveMonth,bobLeaveMonth); ++i)\\n          total_days+=days[i];\\n        total_days+=(end-start+1);\\n        return total_days;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588557,
                "title": "c-easy-clean-solution",
                "content": "**C++ Code:**\\n\\n```\\n int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int arr[12] = {31,28,31,30,31,30,31,31,30,31,30,31};\\n        \\n        int ma1 = stoi(arriveAlice.substr(0,2)),ma2 = stoi(arriveBob.substr(0,2));\\n        int mb1 = stoi(leaveAlice.substr(0,2)),mb2 = stoi(leaveBob.substr(0,2));\\n        int da1 = stoi(arriveAlice.substr(3)),da2 = stoi(arriveBob.substr(3));\\n        int db1 = stoi(leaveAlice.substr(3)),db2 = stoi(leaveBob.substr(3));\\n        \\n        int m1 = max(ma1,ma2);\\n        int m2 = min(mb1,mb2);\\n        if(m1>m2) return 0;  // edge case\\n        \\n        int d1,d2;\\n        // date of arrival\\n        if(ma1<ma2) d1 = da2;\\n        else if(ma1>ma2) d1 = da1;\\n        else d1 = max(da1,da2);\\n        \\n        // date of leaving\\n        if(mb1<mb2) d2 = db1;\\n        else if(mb1>mb2) d2 = db2;\\n        else d2 = min(db1,db2);\\n             \\n        if(m1==m2 && d1>d2) return 0; // edge case\\n        if(m1==m2) return d2-d1+1;\\n        else {\\n            int ans = arr[m1-1]-d1+1;\\n            while(m1+1!=m2){\\n             ans += arr[m1];\\n                m1++;\\n            }\\n            ans += d2;\\n            return ans;\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int arr[12] = {31,28,31,30,31,30,31,31,30,31,30,31};\\n        \\n        int ma1 = stoi(arriveAlice.substr(0,2)),ma2 = stoi(arriveBob.substr(0,2));\\n        int mb1 = stoi(leaveAlice.substr(0,2)),mb2 = stoi(leaveBob.substr(0,2));\\n        int da1 = stoi(arriveAlice.substr(3)),da2 = stoi(arriveBob.substr(3));\\n        int db1 = stoi(leaveAlice.substr(3)),db2 = stoi(leaveBob.substr(3));\\n        \\n        int m1 = max(ma1,ma2);\\n        int m2 = min(mb1,mb2);\\n        if(m1>m2) return 0;  // edge case\\n        \\n        int d1,d2;\\n        // date of arrival\\n        if(ma1<ma2) d1 = da2;\\n        else if(ma1>ma2) d1 = da1;\\n        else d1 = max(da1,da2);\\n        \\n        // date of leaving\\n        if(mb1<mb2) d2 = db1;\\n        else if(mb1>mb2) d2 = db2;\\n        else d2 = min(db1,db2);\\n             \\n        if(m1==m2 && d1>d2) return 0; // edge case\\n        if(m1==m2) return d2-d1+1;\\n        else {\\n            int ans = arr[m1-1]-d1+1;\\n            while(m1+1!=m2){\\n             ans += arr[m1];\\n                m1++;\\n            }\\n            ans += d2;\\n            return ans;\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588498,
                "title": "simple-solution-using-map",
                "content": "```\\n   int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        \\n        map<string,int>m;\\n        \\n        m[\"01\"]=0;\\n        m[\"02\"]=31;\\n        m[\"03\"]=59;\\n        m[\"04\"]=90;\\n        m[\"05\"]=120;\\n        m[\"06\"]=151;\\n        m[\"07\"]=181;\\n        m[\"08\"]=212;\\n        m[\"09\"]=243;\\n        m[\"10\"]=273;\\n        m[\"11\"]=304;\\n        m[\"12\"]=334;\\n        \\n        string aam=\"\";\\n        string aad=\"\";\\n        aam+=arriveAlice[0];\\n        aam+=arriveAlice[1];\\n        aad+=arriveAlice[3];\\n        aad+=arriveAlice[4];   \\n        int aliceA= m[(aam)]+stoi(aad);\\n        \\n       \\n     \\n        \\n        string alm=\"\";\\n        string ald=\"\";\\n        \\n         alm+=leaveAlice[0];\\n        alm+=leaveAlice[1];\\n         ald+=leaveAlice[3];\\n        ald+=leaveAlice[4];        \\n        int aliceL= m[(alm)]+stoi(ald);\\n        \\n        \\n        string bam=\"\";\\n        string bad=\"\";\\n        string blm=\"\";\\n        string bld=\"\";\\n        bam+=arriveBob[0];\\n        bam+=arriveBob[1];\\n         bad+=arriveBob[3];\\n        bad+=arriveBob[4];        \\n        int bobA= m[(bam)]+stoi(bad);\\n        \\n         blm+=leaveBob[0];\\n        blm+=leaveBob[1];\\n         bld+=leaveBob[3];\\n        bld+=leaveBob[4];        \\n        int bobL= m[(blm)]+stoi(bld);\\n        \\n        \\n        if(aliceL>=bobA and aliceA<=bobA)return min(bobL, aliceL)-bobA+1;\\n        if(bobL>=aliceA and bobA<=aliceA)return min(aliceL, bobL)-aliceA+1;\\n        \\n        return 0;\\n \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n   int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        \\n        map<string,int>m;\\n        \\n        m[\"01\"]=0;\\n        m[\"02\"]=31;\\n        m[\"03\"]=59;\\n        m[\"04\"]=90;\\n        m[\"05\"]=120;\\n        m[\"06\"]=151;\\n        m[\"07\"]=181;\\n        m[\"08\"]=212;\\n        m[\"09\"]=243;\\n        m[\"10\"]=273;\\n        m[\"11\"]=304;\\n        m[\"12\"]=334;\\n        \\n        string aam=\"\";\\n        string aad=\"\";\\n        aam+=arriveAlice[0];\\n        aam+=arriveAlice[1];\\n        aad+=arriveAlice[3];\\n        aad+=arriveAlice[4];   \\n        int aliceA= m[(aam)]+stoi(aad);\\n        \\n       \\n     \\n        \\n        string alm=\"\";\\n        string ald=\"\";\\n        \\n         alm+=leaveAlice[0];\\n        alm+=leaveAlice[1];\\n         ald+=leaveAlice[3];\\n        ald+=leaveAlice[4];        \\n        int aliceL= m[(alm)]+stoi(ald);\\n        \\n        \\n        string bam=\"\";\\n        string bad=\"\";\\n        string blm=\"\";\\n        string bld=\"\";\\n        bam+=arriveBob[0];\\n        bam+=arriveBob[1];\\n         bad+=arriveBob[3];\\n        bad+=arriveBob[4];        \\n        int bobA= m[(bam)]+stoi(bad);\\n        \\n         blm+=leaveBob[0];\\n        blm+=leaveBob[1];\\n         bld+=leaveBob[3];\\n        bld+=leaveBob[4];        \\n        int bobL= m[(blm)]+stoi(bld);\\n        \\n        \\n        if(aliceL>=bobA and aliceA<=bobA)return min(bobL, aliceL)-bobA+1;\\n        if(bobL>=aliceA and bobA<=aliceA)return min(aliceL, bobL)-aliceA+1;\\n        \\n        return 0;\\n \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588336,
                "title": "easy-solution-please-upvote",
                "content": "Hello, I used intersection in this solution. I can\\'t solve it during contest time but I could solve it myself)\\nIf you dont understand this solution you can leave comment, I will explain you. PLEASE UPVOTE)\\n```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string a, string b, string c, string d) {\\n      int kalendar[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n      int p[100]; p[0] = 0;\\n      for (int i = 1; i <= 12; ++i) {\\n        p[i] = p[i - 1] + kalendar[i];\\n      }\\n      int a1 = ((a[0] - \\'0\\') * 10 + a[1] - \\'0\\');\\n      int a2 = ((a[3] - \\'0\\') * 10 + a[4] - \\'0\\');\\n      int b1 = ((b[0] - \\'0\\') * 10 + b[1] - \\'0\\');\\n      int b2 = ((b[3] - \\'0\\') * 10 + b[4] - \\'0\\');\\n      int c1 = ((c[0] - \\'0\\') * 10 + c[1] - \\'0\\');\\n      int c2 = ((c[3] - \\'0\\') * 10 + c[4] - \\'0\\');\\n      int d1 = ((d[0] - \\'0\\') * 10 + d[1] - \\'0\\');\\n      int d2 = ((d[3] - \\'0\\') * 10 + d[4] - \\'0\\');\\n      int s1 = p[a1 - 1] + a2;\\n      int s2 = p[b1 - 1] + b2;\\n      int s3 = p[c1 - 1] + c2;\\n      int s4 = p[d1 - 1] + d2;\\n      int x = max(s1, s3);\\n      int y = min(s2, s4);\\n      if (y - x < 0) return 0;\\n      return y - x + 1;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string a, string b, string c, string d) {\\n      int kalendar[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n      int p[100]; p[0] = 0;\\n      for (int i = 1; i <= 12; ++i) {\\n        p[i] = p[i - 1] + kalendar[i];\\n      }\\n      int a1 = ((a[0] - \\'0\\') * 10 + a[1] - \\'0\\');\\n      int a2 = ((a[3] - \\'0\\') * 10 + a[4] - \\'0\\');\\n      int b1 = ((b[0] - \\'0\\') * 10 + b[1] - \\'0\\');\\n      int b2 = ((b[3] - \\'0\\') * 10 + b[4] - \\'0\\');\\n      int c1 = ((c[0] - \\'0\\') * 10 + c[1] - \\'0\\');\\n      int c2 = ((c[3] - \\'0\\') * 10 + c[4] - \\'0\\');\\n      int d1 = ((d[0] - \\'0\\') * 10 + d[1] - \\'0\\');\\n      int d2 = ((d[3] - \\'0\\') * 10 + d[4] - \\'0\\');\\n      int s1 = p[a1 - 1] + a2;\\n      int s2 = p[b1 - 1] + b2;\\n      int s3 = p[c1 - 1] + c2;\\n      int s4 = p[d1 - 1] + d2;\\n      int x = max(s1, s3);\\n      int y = min(s2, s4);\\n      if (y - x < 0) return 0;\\n      return y - x + 1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588255,
                "title": "c-naive-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int months[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    int f(string a, string b){\\n        \\n        int m1 = stoi(a.substr(0,2));\\n        int d1 = stoi(a.substr(3,2));\\n        \\n        int m2 = stoi(b.substr(0,2));\\n        int d2 = stoi(b.substr(3,2));\\n                \\n        if(m1==m2) return abs(d1-d2)+1;\\n        \\n        int sum = 0;\\n        \\n        if(m1>m2){\\n            \\n            sum+=abs(months[m2-1]-d2)+d1+1;\\n            \\n            if(m1-m2>1){\\n                \\n                for(int i=m2+1;i<=m1-1;i++) sum+=months[i-1];\\n\\n            }\\n            \\n            return sum;\\n            \\n        } \\n        sum=0;\\n        if(m1<m2){\\n            \\n            sum+=abs(months[m1-1]-d1)+d2+1;\\n            \\n            if(m2-m1>1){\\n                \\n                for(int i=m1+1;i<=m2-1;i++) sum+=months[i-1];\\n\\n            }\\n            return sum;\\n\\n        }\\n        \\n        return sum;\\n\\n    }\\n    \\n    \\n    int countDaysTogether(string a1, string a2, string b1, string b2) {\\n        \\n        \\n        if(a1==b1 and a2==b2) return f(a1, a2);\\n        if(a1<b1 and a2<b2 and a2>b1) return f(a2, b1);\\n        if(b1<a1 and b2<a2 and b2>a1) return f(b2, a1);\\n        if(a2<b1 or b2<a1) return 0;\\n        if(b2<a1 or a2<b1) return 0;\\n        if(b1>a1 and b2>a1 and b1<a2 and b2<a2) return f(b1, b2);\\n        if(a1>b1 and a2>b1 and a1<b2 and a2<b2) return f(a1, a2);        \\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int months[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    int f(string a, string b){\\n        \\n        int m1 = stoi(a.substr(0,2));\\n        int d1 = stoi(a.substr(3,2));\\n        \\n        int m2 = stoi(b.substr(0,2));\\n        int d2 = stoi(b.substr(3,2));\\n                \\n        if(m1==m2) return abs(d1-d2)+1;\\n        \\n        int sum = 0;\\n        \\n        if(m1>m2){\\n            \\n            sum+=abs(months[m2-1]-d2)+d1+1;\\n            \\n            if(m1-m2>1){\\n                \\n                for(int i=m2+1;i<=m1-1;i++) sum+=months[i-1];\\n\\n            }\\n            \\n            return sum;\\n            \\n        } \\n        sum=0;\\n        if(m1<m2){\\n            \\n            sum+=abs(months[m1-1]-d1)+d2+1;\\n            \\n            if(m2-m1>1){\\n                \\n                for(int i=m1+1;i<=m2-1;i++) sum+=months[i-1];\\n\\n            }\\n            return sum;\\n\\n        }\\n        \\n        return sum;\\n\\n    }\\n    \\n    \\n    int countDaysTogether(string a1, string a2, string b1, string b2) {\\n        \\n        \\n        if(a1==b1 and a2==b2) return f(a1, a2);\\n        if(a1<b1 and a2<b2 and a2>b1) return f(a2, b1);\\n        if(b1<a1 and b2<a2 and b2>a1) return f(b2, a1);\\n        if(a2<b1 or b2<a1) return 0;\\n        if(b2<a1 or a2<b1) return 0;\\n        if(b1>a1 and b2>a1 and b1<a2 and b2<a2) return f(b1, b2);\\n        if(a1>b1 and a2>b1 and a1<b2 and a2<b2) return f(a1, a2);        \\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588224,
                "title": "easiest-c-solution-0ms",
                "content": "```\\n  int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n        {\\n            const int monthDays[12] = { 31,\\n                28,\\n                31,\\n                30,\\n                31,\\n                30,\\n                31,\\n                31,\\n                30,\\n                31,\\n                30,\\n                31\\n            };\\n            int Alice_arr_day = stoi(arriveAlice.substr(3, 5)), Alice_arr_month = stoi(arriveAlice.substr(0, 2)), Bob_arr_day = stoi(arriveBob.substr(3, 5)), Bob_arr_month = stoi(arriveBob.substr(0, 2));\\n            int Alice_leave_day = stoi(leaveAlice.substr(3, 5)), Alice_leave_month = stoi(leaveAlice.substr(0, 2)), Bob_leave_day = stoi(leaveBob.substr(3, 5)), Bob_leave_month = stoi(leaveBob.substr(0, 2));\\n            for (int i = 0; i < Alice_arr_month - 1; i++)\\n                Alice_arr_day += monthDays[i];\\n\\n            for (int i = 0; i < Bob_arr_month - 1; i++)\\n                Bob_arr_day += monthDays[i];\\n            for (int i = 0; i < Alice_leave_month - 1; i++)\\n                Alice_leave_day += monthDays[i];\\n\\n            for (int i = 0; i < Bob_leave_month - 1; i++)\\n                Bob_leave_day += monthDays[i];\\n            int arr = max(Alice_arr_day, Bob_arr_day), dep = min(Alice_leave_day, Bob_leave_day);\\n            if (dep < arr) return 0;\\n            return (dep - arr + 1);\\n        }\\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n        {\\n            const int monthDays[12] = { 31,\\n                28,\\n                31,\\n                30,\\n                31,\\n                30,\\n                31,\\n                31,\\n                30,\\n                31,\\n                30,\\n                31\\n            };\\n            int Alice_arr_day = stoi(arriveAlice.substr(3, 5)), Alice_arr_month = stoi(arriveAlice.substr(0, 2)), Bob_arr_day = stoi(arriveBob.substr(3, 5)), Bob_arr_month = stoi(arriveBob.substr(0, 2));\\n            int Alice_leave_day = stoi(leaveAlice.substr(3, 5)), Alice_leave_month = stoi(leaveAlice.substr(0, 2)), Bob_leave_day = stoi(leaveBob.substr(3, 5)), Bob_leave_month = stoi(leaveBob.substr(0, 2));\\n            for (int i = 0; i < Alice_arr_month - 1; i++)\\n                Alice_arr_day += monthDays[i];\\n\\n            for (int i = 0; i < Bob_arr_month - 1; i++)\\n                Bob_arr_day += monthDays[i];\\n            for (int i = 0; i < Alice_leave_month - 1; i++)\\n                Alice_leave_day += monthDays[i];\\n\\n            for (int i = 0; i < Bob_leave_month - 1; i++)\\n                Bob_leave_day += monthDays[i];\\n            int arr = max(Alice_arr_day, Bob_arr_day), dep = min(Alice_leave_day, Bob_leave_day);\\n            if (dep < arr) return 0;\\n            return (dep - arr + 1);\\n        }\\n\\t\\t\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2588158,
                "title": "very-easy-c-convert-date-string-to-absolute-dates-easy-explaination",
                "content": "I feel this problem is quite similar in approach to <a href=\\'https://leetcode.com/problems/merge-intervals/\\'>Merge Intervals Problem </a>.\\n```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        //Firstly calculate the number of days elapsed in the year before current month started\\n        //We\\'ll use this later to get absolute date by adding these values to given date\\n        //You can also create this vector using for loop on [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        vector<int> prefixSumMonths{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n        \\n        int arriveA, leaveA, arriveB, leaveB;\\n        \\n        // Now we store values of absolute dates in these 4 variables i.e. date in the range of [0, 365]\\n        \\n        arriveA = prefixSumMonths[stoi(arriveAlice.substr(0, 2)) - 1] + stoi(arriveAlice.substr(3, 2));\\n        leaveA = prefixSumMonths[stoi(leaveAlice.substr(0, 2)) - 1] + stoi(leaveAlice.substr(3, 2));\\n        arriveB = prefixSumMonths[stoi(arriveBob.substr(0, 2)) - 1] + stoi(arriveBob.substr(3, 2));\\n        leaveB = prefixSumMonths[stoi(leaveBob.substr(0, 2)) - 1] + stoi(leaveBob.substr(3, 2));\\n        \\n        // if this condition occurs then both A & B never spent time together        \\n        if(leaveA < arriveB || leaveB < arriveA)\\n        return 0;\\n        \\n        return abs(max(arriveA, arriveB) - min(leaveA, leaveB)) + 1;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        //Firstly calculate the number of days elapsed in the year before current month started\\n        //We\\'ll use this later to get absolute date by adding these values to given date\\n        //You can also create this vector using for loop on [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        vector<int> prefixSumMonths{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n        \\n        int arriveA, leaveA, arriveB, leaveB;\\n        \\n        // Now we store values of absolute dates in these 4 variables i.e. date in the range of [0, 365]\\n        \\n        arriveA = prefixSumMonths[stoi(arriveAlice.substr(0, 2)) - 1] + stoi(arriveAlice.substr(3, 2));\\n        leaveA = prefixSumMonths[stoi(leaveAlice.substr(0, 2)) - 1] + stoi(leaveAlice.substr(3, 2));\\n        arriveB = prefixSumMonths[stoi(arriveBob.substr(0, 2)) - 1] + stoi(arriveBob.substr(3, 2));\\n        leaveB = prefixSumMonths[stoi(leaveBob.substr(0, 2)) - 1] + stoi(leaveBob.substr(3, 2));\\n        \\n        // if this condition occurs then both A & B never spent time together        \\n        if(leaveA < arriveB || leaveB < arriveA)\\n        return 0;\\n        \\n        return abs(max(arriveA, arriveB) - min(leaveA, leaveB)) + 1;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588118,
                "title": "meaning-less-question-40ms-python",
                "content": "\\tclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        a1,b1 = arriveAlice.split(\"-\")\\n        a1,b1 = int(a1),int(b1)\\n        \\n        a2,b2 = leaveAlice.split(\"-\")\\n        a2,b2 = int(a2),int(b2)\\n        \\n        c1,d1 = arriveBob.split(\"-\")\\n        c1,d1 = int(c1),int(d1)\\n        \\n        c2,d2 = leaveBob.split(\"-\")\\n        c2,d2 = int(c2),int(d2)\\n        \\n        \\n        y = {\\n            1 : 31,\\n            2 : 28,\\n            3 : 31,\\n            4 : 30,\\n            5 :  31,\\n            6 :  30,\\n            7 :  31,\\n            8  : 31,\\n            9  : 30,\\n            10 : 31,\\n            11:  30,\\n            12 : 31\\n        }\\n        \\n        s1 = []\\n        s2 = []\\n        \\n        \\n        flag = 0\\n        while a1<=a2:\\n            \\n            start = b1 if flag ==0 else  1\\n            for date in range(start,y[a1]+1):\\n                if a1==a2 and date>b2:\\n                    break\\n                s1.append(str(date)+\"-\"+str(a1))\\n            flag=1\\n            a1+=1\\n\\n            \\n        # print(s1)\\n        \\n        flag = 0\\n        while c1<=c2:\\n            start = d1 if flag ==0 else  1\\n            for date in range(start,y[c1]+1):\\n                if c1==c2 and date>d2:\\n                    break\\n                s2.append(str(date)+\"-\"+str(c1))\\n            c1+=1\\n            flag=1\\n            \\n        # print(s2)\\n        \\n        s1 = set(s1)\\n        s2 = set(s2)\\n        \\n        s3 = s1.intersection(s2)\\n        \\n        return len(s3)            \\n        \\n        \\n",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        a1,b1 = arriveAlice.split(\"-\")\\n        a1,b1 = int(a1),int(b1)\\n        \\n        a2,b2 = leaveAlice.split(\"-\")\\n        a2,b2 = int(a2),int(b2)\\n        \\n        c1,d1 = arriveBob.split(\"-\")\\n        c1,d1 = int(c1),int(d1)\\n        \\n        c2,d2 = leaveBob.split(\"-\")\\n        c2,d2 = int(c2),int(d2)\\n        \\n        \\n        y = {\\n            1 : 31,\\n            2 : 28,\\n            3 : 31,\\n            4 : 30,\\n            5 :  31,\\n            6 :  30,\\n            7 :  31,\\n            8  : 31,\\n            9  : 30,\\n            10 : 31,\\n            11:  30,\\n            12 : 31\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2588083,
                "title": "easy-solution-map-calender",
                "content": "I am using the approach that i am increase the day count of month in map by 1 when are arriving in map and dec  by 1 when they are leaving.\\nif sum ==2 indicates both were there on that day.\\nI think this is better soln rather than taking care of cases when they will not overlap and and if overlap then count days.\\n```\\nclass Solution {\\npublic:\\n    int days[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n \\n\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n          int startMonthAlice = stoi(arriveAlice.substr(0,2));\\n          int startDateAlice = stoi(arriveAlice.substr(3,2));\\n        \\n          int leaveMonthAlice = stoi(leaveAlice.substr(0,2));\\n          int leaveDateAlice = stoi(leaveAlice.substr(3,2));\\n       \\n        \\n          int startMonthBob = stoi(arriveBob.substr(0,2));\\n          int startDateBob = stoi(arriveBob.substr(3,2));\\n        \\n          int leaveMonthBob = stoi(leaveBob.substr(0,2));\\n          int leaveDateBob = stoi(leaveBob.substr(3,2));\\n       \\n        \\n          map<int,vector<int>>mp;\\n          /*\\n\\t\\t  * since they have mentioned that start and end days are inclusive.\\n\\t\\t  * we need  to handle case even when they are arriving-leaving on same day. \\n\\t\\t  * so creating map of on larger size than no of days in month.\\n\\t\\t  */\\n          for (int i = 1; i <= 12; i++) {\\n              vector<int>vec(days[i]+2, 0);\\n              mp[i] = vec;\\n          }\\n        \\n\\n         mp[startMonthAlice][startDateAlice]++;\\n         mp[leaveMonthAlice][leaveDateAlice+1]--;\\n\\n         mp[startMonthBob][startDateBob]++;\\n         mp[leaveMonthBob][leaveDateBob+1]--;\\n\\n        \\n         int totalDays = 0;\\n         int sum = 0;\\n        \\n         for (int i = 1; i <= 12; i++) {\\n             int size = days[i]+1;\\n             for (int j = 1; j <= size; j++) {\\n                  sum += mp[i][j];\\n                  if (sum == 2 && j != days[i]+1) { //To take care of inclusive day.\\n                      totalDays++;\\n                  }\\n             } \\n         }\\n        \\n        return totalDays;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int days[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n \\n\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n          int startMonthAlice = stoi(arriveAlice.substr(0,2));\\n          int startDateAlice = stoi(arriveAlice.substr(3,2));\\n        \\n          int leaveMonthAlice = stoi(leaveAlice.substr(0,2));\\n          int leaveDateAlice = stoi(leaveAlice.substr(3,2));\\n       \\n        \\n          int startMonthBob = stoi(arriveBob.substr(0,2));\\n          int startDateBob = stoi(arriveBob.substr(3,2));\\n        \\n          int leaveMonthBob = stoi(leaveBob.substr(0,2));\\n          int leaveDateBob = stoi(leaveBob.substr(3,2));\\n       \\n        \\n          map<int,vector<int>>mp;\\n          /*\\n\\t\\t  * since they have mentioned that start and end days are inclusive.\\n\\t\\t  * we need  to handle case even when they are arriving-leaving on same day. \\n\\t\\t  * so creating map of on larger size than no of days in month.\\n\\t\\t  */\\n          for (int i = 1; i <= 12; i++) {\\n              vector<int>vec(days[i]+2, 0);\\n              mp[i] = vec;\\n          }\\n        \\n\\n         mp[startMonthAlice][startDateAlice]++;\\n         mp[leaveMonthAlice][leaveDateAlice+1]--;\\n\\n         mp[startMonthBob][startDateBob]++;\\n         mp[leaveMonthBob][leaveDateBob+1]--;\\n\\n        \\n         int totalDays = 0;\\n         int sum = 0;\\n        \\n         for (int i = 1; i <= 12; i++) {\\n             int size = days[i]+1;\\n             for (int j = 1; j <= size; j++) {\\n                  sum += mp[i][j];\\n                  if (sum == 2 && j != days[i]+1) { //To take care of inclusive day.\\n                      totalDays++;\\n                  }\\n             } \\n         }\\n        \\n        return totalDays;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588069,
                "title": "java-clean-self-explanotary-code-100-faster-time-space",
                "content": "```\\nclass Solution {\\n    int[] daysOfMonth = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int x1 = getDays(arriveAlice);\\n        int y1 = getDays(leaveAlice);\\n        int x2 = getDays(arriveBob);\\n        int y2 = getDays(leaveBob);\\n        if(y1 < x2 || y2 < x1) return 0;\\n        return Math.abs(Math.max(x1, x2)-Math.min(y1, y2))+1;\\n    }\\n    \\n    private int getDays(String str){\\n        int total = 0;\\n        int month = Integer.valueOf(str.substring(0,2));\\n        int days = Integer.valueOf(str.substring(3,5));\\n        for(int i=0;i<month-1;i++){\\n            total += daysOfMonth[i];\\n        }\\n        total += days;\\n        return total;\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] daysOfMonth = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int x1 = getDays(arriveAlice);\\n        int y1 = getDays(leaveAlice);\\n        int x2 = getDays(arriveBob);\\n        int y2 = getDays(leaveBob);\\n        if(y1 < x2 || y2 < x1) return 0;\\n        return Math.abs(Math.max(x1, x2)-Math.min(y1, y2))+1;\\n    }\\n    \\n    private int getDays(String str){\\n        int total = 0;\\n        int month = Integer.valueOf(str.substring(0,2));\\n        int days = Integer.valueOf(str.substring(3,5));\\n        for(int i=0;i<month-1;i++){\\n            total += daysOfMonth[i];\\n        }\\n        total += days;\\n        return total;\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588051,
                "title": "java-date-library",
                "content": "```\\nimport java.text.DateFormat;\\nimport java.text.ParseException;\\nimport java.text.SimpleDateFormat;\\nimport java.util.*;\\n\\nclass Solution {\\n        public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n            int[] aa = Arrays.stream(arriveAlice.split(\"-\")).mapToInt(Integer::parseInt).toArray();\\n            int[] la = Arrays.stream(leaveAlice.split(\"-\")).mapToInt(Integer::parseInt).toArray();\\n\\n            int[] ab = Arrays.stream(arriveBob.split(\"-\")).mapToInt(Integer::parseInt).toArray();\\n            int[] lb = Arrays.stream(leaveBob.split(\"-\")).mapToInt(Integer::parseInt).toArray();\\n\\n            try {\\n                Calendar c = Calendar.getInstance();\\n                DateFormat sourceFormat = new SimpleDateFormat(\"dd/MM/yyyy\");\\n\\n                c.setTime(sourceFormat.parse(aa[1] + \"/\" + aa[0] + \"/2010\"));\\n                int aad = c.get(Calendar.DAY_OF_YEAR);\\n\\n                c.setTime(sourceFormat.parse(la[1] + \"/\" + la[0] + \"/2010\"));\\n                int ald = c.get(Calendar.DAY_OF_YEAR);\\n\\n                c.setTime(sourceFormat.parse(ab[1] + \"/\" + ab[0] + \"/2010\"));\\n                int bad = c.get(Calendar.DAY_OF_YEAR);\\n\\n                c.setTime(sourceFormat.parse(lb[1] + \"/\" + lb[0] + \"/2010\"));\\n                int bld = c.get(Calendar.DAY_OF_YEAR);\\n\\n                int x = Math.max(aad, bad), y = Math.min(ald, bld);\\n                if (x <= y) return 1 + Math.abs(x - y);\\n                return 0;\\n            } catch (Exception ex) {\\n                return 0;\\n            }\\n\\n        }\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.text.DateFormat;\\nimport java.text.ParseException;\\nimport java.text.SimpleDateFormat;\\nimport java.util.*;\\n\\nclass Solution {\\n        public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n            int[] aa = Arrays.stream(arriveAlice.split(\"-\")).mapToInt(Integer::parseInt).toArray();\\n            int[] la = Arrays.stream(leaveAlice.split(\"-\")).mapToInt(Integer::parseInt).toArray();\\n\\n            int[] ab = Arrays.stream(arriveBob.split(\"-\")).mapToInt(Integer::parseInt).toArray();\\n            int[] lb = Arrays.stream(leaveBob.split(\"-\")).mapToInt(Integer::parseInt).toArray();\\n\\n            try {\\n                Calendar c = Calendar.getInstance();\\n                DateFormat sourceFormat = new SimpleDateFormat(\"dd/MM/yyyy\");\\n\\n                c.setTime(sourceFormat.parse(aa[1] + \"/\" + aa[0] + \"/2010\"));\\n                int aad = c.get(Calendar.DAY_OF_YEAR);\\n\\n                c.setTime(sourceFormat.parse(la[1] + \"/\" + la[0] + \"/2010\"));\\n                int ald = c.get(Calendar.DAY_OF_YEAR);\\n\\n                c.setTime(sourceFormat.parse(ab[1] + \"/\" + ab[0] + \"/2010\"));\\n                int bad = c.get(Calendar.DAY_OF_YEAR);\\n\\n                c.setTime(sourceFormat.parse(lb[1] + \"/\" + lb[0] + \"/2010\"));\\n                int bld = c.get(Calendar.DAY_OF_YEAR);\\n\\n                int x = Math.max(aad, bad), y = Math.min(ald, bld);\\n                if (x <= y) return 1 + Math.abs(x - y);\\n                return 0;\\n            } catch (Exception ex) {\\n                return 0;\\n            }\\n\\n        }\\n\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588046,
                "title": "simple-solution-python-brute-force",
                "content": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        alice_arrive_month = int(arriveAlice[0:2])\\n        alice_arrive_day = int(arriveAlice[3:])\\n        bob_arrive_month = int(arriveBob[0:2] )\\n        bob_arrive_day = int(arriveBob[3:] )\\n        alice_leave_month = int(leaveAlice[0:2] )\\n        alice_leave_day = int(leaveAlice[3:])\\n        bob_leave_month = int(leaveBob[0:2] )\\n        bob_leave_day = int(leaveBob[3:] )\\n        count = 0\\n        \\n        b = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        if(arriveAlice == arriveBob and leaveBob == leaveAlice): \\n            if(alice_arrive_month == bob_leave_month): \\n                return alice_leave_day - alice_arrive_day + 1\\n            else: \\n                count += b[alice_arrive_month - 1] - alice_arrive_day + 1\\n                for i in range(alice_arrive_month + 1, alice_leave_month): \\n                    count += b[i-1]\\n                count += alice_leave_day\\n                return count\\n        \\n        if((arriveAlice < arriveBob and leaveAlice < arriveBob) or (arriveBob < arriveAlice and leaveBob < arriveAlice)): \\n            return 0 \\n        \\n        \\n        # when arrival and leave lie in between of the other\\n        if(arriveBob > arriveAlice and leaveBob < leaveAlice): \\n            if(bob_leave_month == bob_arrive_month): \\n                return bob_leave_day - bob_arrive_day + 1\\n            else:\\n                count += b[bob_arrive_month-1] - bob_arrive_day + 1\\n                for i in range(bob_arrive_month + 1, bob_leave_month):\\n                    count += (b[i -1]) \\n                count += bob_leave_day \\n                return count\\n        elif(arriveAlice > arriveBob and leaveAlice < leaveBob): \\n            if(alice_leave_month == alice_arrive_month): \\n                return alice_leave_day - alice_arrive_day + 1\\n            else:\\n                count += (b[alice_arrive_month -1] - alice_arrive_day)  + 1\\n                for i in range(alice_arrive_month + 1, alice_leave_month):\\n                    count += (b[i -1]) \\n                count += alice_leave_day\\n                return count\\n            \\n        # arriveAlice = \"08-15\", leaveAlice = \"08-18\", \\n        # arriveBob = \"08-16\", leaveBob = \"08-19\"\\n        if(arriveBob < leaveAlice and leaveAlice < leaveBob): \\n            if(bob_arrive_month == alice_leave_month): \\n                return alice_leave_day - bob_arrive_day + 1\\n            else: \\n                count += b[bob_arrive_month-1] - bob_arrive_day + 1\\n                for i in range(bob_arrive_month + 1, alice_leave_month): \\n                    count += (b[i -1]) \\n                count += alice_leave_day\\n                return count \\n        \\n\\t\\t# \"08-06\" --> \\n\\t\\t# \"12-08\"  \\n\\t\\t# \"02-04\"\\n\\t\\t# \"09-01\" --> \\n        if(arriveAlice < leaveBob and leaveBob < leaveAlice): \\n            if(alice_arrive_month == bob_leave_month): \\n                return bob_leave_day - alice_arrive_day + 1\\n            else: \\n                count += b[alice_arrive_month-1] - alice_arrive_day + 1\\n                for i in range(alice_arrive_month + 1, bob_leave_month): \\n                    count += (b[i -1]) \\n                count += bob_leave_day\\n                return count \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        alice_arrive_month = int(arriveAlice[0:2])\\n        alice_arrive_day = int(arriveAlice[3:])\\n        bob_arrive_month = int(arriveBob[0:2] )\\n        bob_arrive_day = int(arriveBob[3:] )\\n        alice_leave_month = int(leaveAlice[0:2] )\\n        alice_leave_day = int(leaveAlice[3:])\\n        bob_leave_month = int(leaveBob[0:2] )\\n        bob_leave_day = int(leaveBob[3:] )\\n        count = 0\\n        \\n        b = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        if(arriveAlice == arriveBob and leaveBob == leaveAlice): \\n            if(alice_arrive_month == bob_leave_month): \\n                return alice_leave_day - alice_arrive_day + 1\\n            else: \\n                count += b[alice_arrive_month - 1] - alice_arrive_day + 1\\n                for i in range(alice_arrive_month + 1, alice_leave_month): \\n                    count += b[i-1]\\n                count += alice_leave_day\\n                return count\\n        \\n        if((arriveAlice < arriveBob and leaveAlice < arriveBob) or (arriveBob < arriveAlice and leaveBob < arriveAlice)): \\n            return 0 \\n        \\n        \\n        # when arrival and leave lie in between of the other\\n        if(arriveBob > arriveAlice and leaveBob < leaveAlice): \\n            if(bob_leave_month == bob_arrive_month): \\n                return bob_leave_day - bob_arrive_day + 1\\n            else:\\n                count += b[bob_arrive_month-1] - bob_arrive_day + 1\\n                for i in range(bob_arrive_month + 1, bob_leave_month):\\n                    count += (b[i -1]) \\n                count += bob_leave_day \\n                return count\\n        elif(arriveAlice > arriveBob and leaveAlice < leaveBob): \\n            if(alice_leave_month == alice_arrive_month): \\n                return alice_leave_day - alice_arrive_day + 1\\n            else:\\n                count += (b[alice_arrive_month -1] - alice_arrive_day)  + 1\\n                for i in range(alice_arrive_month + 1, alice_leave_month):\\n                    count += (b[i -1]) \\n                count += alice_leave_day\\n                return count\\n            \\n        # arriveAlice = \"08-15\", leaveAlice = \"08-18\", \\n        # arriveBob = \"08-16\", leaveBob = \"08-19\"\\n        if(arriveBob < leaveAlice and leaveAlice < leaveBob): \\n            if(bob_arrive_month == alice_leave_month): \\n                return alice_leave_day - bob_arrive_day + 1\\n            else: \\n                count += b[bob_arrive_month-1] - bob_arrive_day + 1\\n                for i in range(bob_arrive_month + 1, alice_leave_month): \\n                    count += (b[i -1]) \\n                count += alice_leave_day\\n                return count \\n        \\n\\t\\t# \"08-06\" --> \\n\\t\\t# \"12-08\"  \\n\\t\\t# \"02-04\"\\n\\t\\t# \"09-01\" --> \\n        if(arriveAlice < leaveBob and leaveBob < leaveAlice): \\n            if(alice_arrive_month == bob_leave_month): \\n                return bob_leave_day - alice_arrive_day + 1\\n            else: \\n                count += b[alice_arrive_month-1] - alice_arrive_day + 1\\n                for i in range(alice_arrive_month + 1, bob_leave_month): \\n                    count += (b[i -1]) \\n                count += bob_leave_day\\n                return count \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588035,
                "title": "faster-than-100-brute-force",
                "content": "We have to write functions to calculate no. of days between two dates and another function to find which date is smaller than the other date.\\n\\nNow using, if-checks we can easily find the dates we to should choose and return the number of days between them\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> dayInMonth{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    // compare date returns true if d1<=d2\\n    bool compareDate(string date1,string date2){\\n        int m1 = stoi(date1.substr(0,2));\\n        int d1 = stoi(date1.substr(3,2));\\n        int m2 = stoi(date2.substr(0,2));\\n        int d2 = stoi(date2.substr(3,2));\\n        \\n        if(m1<m2)\\n            return true;\\n        else if(m1==m2){\\n            if(d1<=d2)\\n                return true;\\n            else\\n                return false;\\n        }else\\n            return false;\\n    }\\n    \\n    // stay duration find no of days between d1 and d2\\n    int stayDuration(string date1,string date2){\\n        int m1 = stoi(date1.substr(0,2));\\n        int d1 = stoi(date1.substr(3,2));\\n        int m2 = stoi(date2.substr(0,2));\\n        int d2 = stoi(date2.substr(3,2));\\n        \\n        if(m2>m1){\\n            int days=0;\\n            for(int i=m1;i<=m2;i++){\\n                if(i==m1)\\n                    days+=dayInMonth[i-1]-d1+1;\\n                else if(i==m2)\\n                    days+=d2;\\n                else\\n                    days+=dayInMonth[i-1];\\n            }\\n            \\n            return days;\\n        }else{\\n            return d2-d1+1;\\n        }\\n        \\n    }\\n    \\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        \\n        string d1=arriveAlice,d2=leaveAlice,d3=arriveBob,d4=leaveBob;\\n        if(compareDate(d3,d2) && compareDate(d1,d3) && compareDate(d2,d4))\\n            return stayDuration(d3,d2);\\n        else if(compareDate(d1,d4) && compareDate(d4,d2) && compareDate(d3,d1))\\n            return stayDuration(d1,d4);\\n        else if(compareDate(d3,d1) && compareDate(d2,d4))\\n            return stayDuration(d1,d2);\\n        else if(compareDate(d1,d3) && compareDate(d4,d2))\\n            return stayDuration(d3,d4);\\n        else \\n            return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dayInMonth{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    // compare date returns true if d1<=d2\\n    bool compareDate(string date1,string date2){\\n        int m1 = stoi(date1.substr(0,2));\\n        int d1 = stoi(date1.substr(3,2));\\n        int m2 = stoi(date2.substr(0,2));\\n        int d2 = stoi(date2.substr(3,2));\\n        \\n        if(m1<m2)\\n            return true;\\n        else if(m1==m2){\\n            if(d1<=d2)\\n                return true;\\n            else\\n                return false;\\n        }else\\n            return false;\\n    }\\n    \\n    // stay duration find no of days between d1 and d2\\n    int stayDuration(string date1,string date2){\\n        int m1 = stoi(date1.substr(0,2));\\n        int d1 = stoi(date1.substr(3,2));\\n        int m2 = stoi(date2.substr(0,2));\\n        int d2 = stoi(date2.substr(3,2));\\n        \\n        if(m2>m1){\\n            int days=0;\\n            for(int i=m1;i<=m2;i++){\\n                if(i==m1)\\n                    days+=dayInMonth[i-1]-d1+1;\\n                else if(i==m2)\\n                    days+=d2;\\n                else\\n                    days+=dayInMonth[i-1];\\n            }\\n            \\n            return days;\\n        }else{\\n            return d2-d1+1;\\n        }\\n        \\n    }\\n    \\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        \\n        string d1=arriveAlice,d2=leaveAlice,d3=arriveBob,d4=leaveBob;\\n        if(compareDate(d3,d2) && compareDate(d1,d3) && compareDate(d2,d4))\\n            return stayDuration(d3,d2);\\n        else if(compareDate(d1,d4) && compareDate(d4,d2) && compareDate(d3,d1))\\n            return stayDuration(d1,d4);\\n        else if(compareDate(d3,d1) && compareDate(d2,d4))\\n            return stayDuration(d1,d2);\\n        else if(compareDate(d1,d3) && compareDate(d4,d2))\\n            return stayDuration(d3,d4);\\n        else \\n            return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588026,
                "title": "lengthy-but-easy-to-understand-python3-solution",
                "content": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        month=[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        aam,aad=int(arriveAlice[:2]),int(arriveAlice[3:])\\n        alm,ald=int(leaveAlice[:2]),int(leaveAlice[3:])\\n        bam,bad=int(arriveBob[:2]),int(arriveBob[3:])\\n        blm,bld=int(leaveBob[:2]),int(leaveBob[3:])\\n        \\n        sm,sd,em,ed=0,0,0,0\\n        \\n        \\n        \\n        \\n        def diff(sm,sd,em,ed):\\n            print(sm,sd,em,ed)\\n            if(sm>=em):\\n                if(sm==em and ed-sd+1>0):\\n                    return ed-sd+1\\n                else: \\n                    return 0\\n            \\n            a = (month[sm-1]-sd+1)\\n            b=0\\n            for i in range(sm+1,em):\\n                b+= month[i-1]\\n            c = ed\\n            #print(month[sm-1],aad,c)\\n            diff=a+b+c\\n            return diff\\n        \\n        d = 0\\n        \\n        if aam>=bam and alm>=blm:\\n            if(blm==alm):\\n                ed=min(bld,ald)\\n            else:\\n                ed=bld\\n                \\n            if(aam==bam):\\n                sd=max(aad,bad)\\n            else:\\n                sd=aad\\n                \\n            return diff(aam,sd,blm,ed)\\n            \\n        elif aam<=bam and alm<=blm:\\n            if(blm==alm):\\n                ed=min(bld,ald)\\n            else:\\n                ed=ald\\n                \\n            if(aam==bam):\\n                sd=max(aad,bad)\\n            else:\\n                sd=bad\\n                \\n            return diff(bam,sd,alm,ed)\\n        \\n        elif aam>=bam and alm<=blm:\\n            if(blm==alm):\\n                ed=min(bld,ald)\\n            else:\\n                ed=ald\\n            if(aam==bam):\\n                sd=max(aad,bad)\\n            else:\\n                sd=aad\\n                \\n            return diff(aam,sd,alm,ed)\\n            \\n        elif aam<=bam and blm<=alm:\\n            if(blm==alm):\\n                ed=min(bld,ald)\\n            else:\\n                ed=bld\\n                \\n            if(aam==bam):\\n                sd=max(aad,bad)\\n            else:\\n                sd=bad\\n                \\n            return diff(bam,sd,blm,ed)\\n            \\n        return d\\n\\n        \\n```\\nTime Complexity: O(1) # For looping for the difference of months, will never be greater than 12\\nSpace Complexity:O(1)\\nThere are much better approaches possible",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        month=[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        aam,aad=int(arriveAlice[:2]),int(arriveAlice[3:])\\n        alm,ald=int(leaveAlice[:2]),int(leaveAlice[3:])\\n        bam,bad=int(arriveBob[:2]),int(arriveBob[3:])\\n        blm,bld=int(leaveBob[:2]),int(leaveBob[3:])\\n        \\n        sm,sd,em,ed=0,0,0,0\\n        \\n        \\n        \\n        \\n        def diff(sm,sd,em,ed):\\n            print(sm,sd,em,ed)\\n            if(sm>=em):\\n                if(sm==em and ed-sd+1>0):\\n                    return ed-sd+1\\n                else: \\n                    return 0\\n            \\n            a = (month[sm-1]-sd+1)\\n            b=0\\n            for i in range(sm+1,em):\\n                b+= month[i-1]\\n            c = ed\\n            #print(month[sm-1],aad,c)\\n            diff=a+b+c\\n            return diff\\n        \\n        d = 0\\n        \\n        if aam>=bam and alm>=blm:\\n            if(blm==alm):\\n                ed=min(bld,ald)\\n            else:\\n                ed=bld\\n                \\n            if(aam==bam):\\n                sd=max(aad,bad)\\n            else:\\n                sd=aad\\n                \\n            return diff(aam,sd,blm,ed)\\n            \\n        elif aam<=bam and alm<=blm:\\n            if(blm==alm):\\n                ed=min(bld,ald)\\n            else:\\n                ed=ald\\n                \\n            if(aam==bam):\\n                sd=max(aad,bad)\\n            else:\\n                sd=bad\\n                \\n            return diff(bam,sd,alm,ed)\\n        \\n        elif aam>=bam and alm<=blm:\\n            if(blm==alm):\\n                ed=min(bld,ald)\\n            else:\\n                ed=ald\\n            if(aam==bam):\\n                sd=max(aad,bad)\\n            else:\\n                sd=aad\\n                \\n            return diff(aam,sd,alm,ed)\\n            \\n        elif aam<=bam and blm<=alm:\\n            if(blm==alm):\\n                ed=min(bld,ald)\\n            else:\\n                ed=bld\\n                \\n            if(aam==bam):\\n                sd=max(aad,bad)\\n            else:\\n                sd=bad\\n                \\n            return diff(bam,sd,blm,ed)\\n            \\n        return d\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588003,
                "title": "javascript-easy-to-understand",
                "content": "```\\n\\n  const maxArrival = arriveAlice > arriveBob ? arriveAlice : arriveBob;\\n  const minLeave = leaveAlice < leaveBob ? leaveAlice : leaveBob;\\n\\n  const days_in_months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n\\n  let days_spent_together = 0;\\n\\n  const dayArrived = Number(maxArrival.slice(3));\\n  const monthArrived = Number(maxArrival.slice(0,2));\\n\\n  const dayLeft = Number(minLeave.slice(3));\\n  const monthLeft = Number(minLeave.slice(0,2));\\n\\n  if (maxArrival > minLeave) return 0;\\n\\n  if (monthArrived === monthLeft) {\\n    days_spent_together = dayLeft - dayArrived + 1;\\n  } else {\\n    days_spent_together = days_in_months[monthArrived - 1] - dayArrived + 1;\\n\\n    for (let i = monthArrived; i < monthLeft - 1; i++) {\\n      days_spent_together += days_in_months[i];\\n    }\\n    days_spent_together += dayLeft;\\n  }\\n\\n  return days_spent_together;\\n  \\n  ```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n  const maxArrival = arriveAlice > arriveBob ? arriveAlice : arriveBob;\\n  const minLeave = leaveAlice < leaveBob ? leaveAlice : leaveBob;\\n\\n  const days_in_months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n\\n  let days_spent_together = 0;\\n\\n  const dayArrived = Number(maxArrival.slice(3));\\n  const monthArrived = Number(maxArrival.slice(0,2));\\n\\n  const dayLeft = Number(minLeave.slice(3));\\n  const monthLeft = Number(minLeave.slice(0,2));\\n\\n  if (maxArrival > minLeave) return 0;\\n\\n  if (monthArrived === monthLeft) {\\n    days_spent_together = dayLeft - dayArrived + 1;\\n  } else {\\n    days_spent_together = days_in_months[monthArrived - 1] - dayArrived + 1;\\n\\n    for (let i = monthArrived; i < monthLeft - 1; i++) {\\n      days_spent_together += days_in_months[i];\\n    }\\n    days_spent_together += dayLeft;\\n  }\\n\\n  return days_spent_together;\\n  \\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2587980,
                "title": "easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>pref;\\n    int solve(string aalice){\\n    string first=aalice.substr(0,2);\\n        int k=stoi(first);\\n        k--;\\n        k=pref[k];\\n        string sec=aalice.substr(3,5);\\n        k+=stoi(sec);\\n        k--;\\n        return k;\\n    }\\n    vector<int>temp={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int countDaysTogether(string aalice, string la, string ab, string lb) {\\n        \\n        pref.push_back(0);\\n        for(int i=1;i<12;i++){\\n            int k=temp[i-1]+pref[i-1];\\n            pref.push_back(k);\\n        }\\n        int a=solve(aalice);\\n        int b=solve(la);\\n        int c=solve(ab);\\n        int d=solve(lb);\\n        int x=max(a,c);\\n        int y=min(b,d);\\n        int ans=y-x+1;\\n        if(ans<0){\\n            ans=0;\\n        }\\n        return ans;\\n        //itne ke baad aara \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>pref;\\n    int solve(string aalice){\\n    string first=aalice.substr(0,2);\\n        int k=stoi(first);\\n        k--;\\n        k=pref[k];\\n        string sec=aalice.substr(3,5);\\n        k+=stoi(sec);\\n        k--;\\n        return k;\\n    }\\n    vector<int>temp={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int countDaysTogether(string aalice, string la, string ab, string lb) {\\n        \\n        pref.push_back(0);\\n        for(int i=1;i<12;i++){\\n            int k=temp[i-1]+pref[i-1];\\n            pref.push_back(k);\\n        }\\n        int a=solve(aalice);\\n        int b=solve(la);\\n        int c=solve(ab);\\n        int d=solve(lb);\\n        int x=max(a,c);\\n        int y=min(b,d);\\n        int ans=y-x+1;\\n        if(ans<0){\\n            ans=0;\\n        }\\n        return ans;\\n        //itne ke baad aara \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587940,
                "title": "toughest-brute-force-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int aad = stoi(arriveAlice.substr(3));\\n        int aam = stoi(arriveAlice.substr(0, 2));\\n        int ald = stoi(leaveAlice.substr(3));\\n        int alm = stoi(leaveAlice.substr(0, 2));\\n        \\n        int bad = stoi(arriveBob.substr(3));\\n        int bam = stoi(arriveBob.substr(0, 2));\\n        int bld = stoi(leaveBob.substr(3));\\n        int blm = stoi(leaveBob.substr(0, 2));\\n        \\n        vector<vector<int>> cal1, cal2;\\n        vector<int> md = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        for(int i=0; i<12; i++) {\\n            vector<int> m1(md[i]), m2(md[i]);\\n            cal1.push_back(m1);\\n            cal2.push_back(m2);\\n        }\\n        \\n        if(aam == alm) {\\n            for(int i=aad - 1; i<=ald - 1; i++) cal1[aam - 1][i] = 1;\\n        }\\n        else {\\n            for(int i=aad - 1; i<md[aam - 1]; i++) cal1[aam - 1][i] = 1;\\n            for(int i=0; i<=ald - 1; i++) cal1[alm - 1][i] = 1;\\n            \\n            for(int i=aam-1+1; i<=alm-1-1; i++) {\\n                for(int j=0; j<md[i]; j++) cal1[i][j] = 1;\\n            }\\n        }\\n        \\n        if(bam == blm) {\\n            for(int i=bad - 1; i<=bld - 1; i++) cal2[bam - 1][i] = 1;\\n        }\\n        else {\\n            for(int i=bad - 1; i<md[bam - 1]; i++) cal2[bam - 1][i] = 1;\\n            for(int i=0; i<=bld - 1; i++) cal2[blm - 1][i] = 1;\\n            \\n            for(int i=bam-1+1; i<=blm-1-1; i++) {\\n                for(int j=0; j<md[i]; j++) cal2[i][j] = 1;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0; i<12; i++) {\\n            for(int j=0; j<cal1[i].size(); j++) {\\n                if(cal1[i][j] && cal2[i][j]) ans++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int aad = stoi(arriveAlice.substr(3));\\n        int aam = stoi(arriveAlice.substr(0, 2));\\n        int ald = stoi(leaveAlice.substr(3));\\n        int alm = stoi(leaveAlice.substr(0, 2));\\n        \\n        int bad = stoi(arriveBob.substr(3));\\n        int bam = stoi(arriveBob.substr(0, 2));\\n        int bld = stoi(leaveBob.substr(3));\\n        int blm = stoi(leaveBob.substr(0, 2));\\n        \\n        vector<vector<int>> cal1, cal2;\\n        vector<int> md = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        for(int i=0; i<12; i++) {\\n            vector<int> m1(md[i]), m2(md[i]);\\n            cal1.push_back(m1);\\n            cal2.push_back(m2);\\n        }\\n        \\n        if(aam == alm) {\\n            for(int i=aad - 1; i<=ald - 1; i++) cal1[aam - 1][i] = 1;\\n        }\\n        else {\\n            for(int i=aad - 1; i<md[aam - 1]; i++) cal1[aam - 1][i] = 1;\\n            for(int i=0; i<=ald - 1; i++) cal1[alm - 1][i] = 1;\\n            \\n            for(int i=aam-1+1; i<=alm-1-1; i++) {\\n                for(int j=0; j<md[i]; j++) cal1[i][j] = 1;\\n            }\\n        }\\n        \\n        if(bam == blm) {\\n            for(int i=bad - 1; i<=bld - 1; i++) cal2[bam - 1][i] = 1;\\n        }\\n        else {\\n            for(int i=bad - 1; i<md[bam - 1]; i++) cal2[bam - 1][i] = 1;\\n            for(int i=0; i<=bld - 1; i++) cal2[blm - 1][i] = 1;\\n            \\n            for(int i=bam-1+1; i<=blm-1-1; i++) {\\n                for(int j=0; j<md[i]; j++) cal2[i][j] = 1;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0; i<12; i++) {\\n            for(int j=0; j<cal1[i].size(); j++) {\\n                if(cal1[i][j] && cal2[i][j]) ans++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587938,
                "title": "easy-implementation-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>days{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    set<string>ans;\\n    void store(string &s,string &s1)\\n    {\\n        int a = 0;\\n        a = a*10+(s[0]-\\'0\\');\\n        a = a*10+(s[1]-\\'0\\');\\n        int b = 0;\\n        b = b*10+(s1[0]-\\'0\\');\\n        b = b*10+(s1[1]-\\'0\\');\\n        \\n        int count = 0;\\n        count = count*10+(s[3]-\\'0\\');\\n        count = count*10+(s[4]-\\'0\\');\\n        \\n        int count1 = 0;\\n        count1 = count1*10+(s1[3]-\\'0\\');\\n        count1 = count1*10+(s1[4]-\\'0\\');\\n        while(a<=b)\\n        {\\n            if(a==b)\\n            {\\n                if(count<=count1)\\n                {\\n                    string x = to_string(a);\\n                     x+= \"-\";\\n                     x+=to_string(count);\\n                    ans.insert(x);\\n                    count++;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            else if(a<b)\\n            {\\n                    string x = to_string(a);\\n                     x+= \"-\";\\n                     x+=to_string(count);\\n                    ans.insert(x);\\n                    count++;\\n                    if(count>days[a-1])\\n                    {\\n                        count = 1;\\n                        a = (a)%12;\\n                        a++;\\n                    }\\n            }\\n        }\\n    }\\n    int countDays(string &s,string &s1)\\n    {\\n        int total = 0;\\n        int a = 0;\\n        a = a*10+(s[0]-\\'0\\');\\n        a = a*10+(s[1]-\\'0\\');\\n        int b = 0;\\n        b = b*10+(s1[0]-\\'0\\');\\n        b = b*10+(s1[1]-\\'0\\');\\n        \\n        int count = 0;\\n        count = count*10+(s[3]-\\'0\\');\\n        count = count*10+(s[4]-\\'0\\');\\n        \\n        int count1 = 0;\\n        count1 = count1*10+(s1[3]-\\'0\\');\\n        count1 = count1*10+(s1[4]-\\'0\\');\\n        while(a<=b)\\n        {\\n            if(a==b)\\n            {\\n                if(count<=count1)\\n                {\\n                    string x = to_string(a);\\n                     x+= \"-\";\\n                     x+=to_string(count);\\n                    if(ans.find(x)!=ans.end())total++;\\n                    count++;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            else if(a<b)\\n            {\\n                    string x = to_string(a);\\n                     x+= \"-\";\\n                     x+=to_string(count);\\n                    if(ans.find(x)!=ans.end())total++;\\n                    count++;\\n                    if(count>days[a-1])\\n                    {\\n                        count = 1;\\n                        a = (a)%12;\\n                        a++;\\n                    }\\n            }\\n        }\\n        return total;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        store(arriveAlice,leaveAlice);\\n        return countDays(arriveBob,leaveBob);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>days{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    set<string>ans;\\n    void store(string &s,string &s1)\\n    {\\n        int a = 0;\\n        a = a*10+(s[0]-\\'0\\');\\n        a = a*10+(s[1]-\\'0\\');\\n        int b = 0;\\n        b = b*10+(s1[0]-\\'0\\');\\n        b = b*10+(s1[1]-\\'0\\');\\n        \\n        int count = 0;\\n        count = count*10+(s[3]-\\'0\\');\\n        count = count*10+(s[4]-\\'0\\');\\n        \\n        int count1 = 0;\\n        count1 = count1*10+(s1[3]-\\'0\\');\\n        count1 = count1*10+(s1[4]-\\'0\\');\\n        while(a<=b)\\n        {\\n            if(a==b)\\n            {\\n                if(count<=count1)\\n                {\\n                    string x = to_string(a);\\n                     x+= \"-\";\\n                     x+=to_string(count);\\n                    ans.insert(x);\\n                    count++;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            else if(a<b)\\n            {\\n                    string x = to_string(a);\\n                     x+= \"-\";\\n                     x+=to_string(count);\\n                    ans.insert(x);\\n                    count++;\\n                    if(count>days[a-1])\\n                    {\\n                        count = 1;\\n                        a = (a)%12;\\n                        a++;\\n                    }\\n            }\\n        }\\n    }\\n    int countDays(string &s,string &s1)\\n    {\\n        int total = 0;\\n        int a = 0;\\n        a = a*10+(s[0]-\\'0\\');\\n        a = a*10+(s[1]-\\'0\\');\\n        int b = 0;\\n        b = b*10+(s1[0]-\\'0\\');\\n        b = b*10+(s1[1]-\\'0\\');\\n        \\n        int count = 0;\\n        count = count*10+(s[3]-\\'0\\');\\n        count = count*10+(s[4]-\\'0\\');\\n        \\n        int count1 = 0;\\n        count1 = count1*10+(s1[3]-\\'0\\');\\n        count1 = count1*10+(s1[4]-\\'0\\');\\n        while(a<=b)\\n        {\\n            if(a==b)\\n            {\\n                if(count<=count1)\\n                {\\n                    string x = to_string(a);\\n                     x+= \"-\";\\n                     x+=to_string(count);\\n                    if(ans.find(x)!=ans.end())total++;\\n                    count++;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            else if(a<b)\\n            {\\n                    string x = to_string(a);\\n                     x+= \"-\";\\n                     x+=to_string(count);\\n                    if(ans.find(x)!=ans.end())total++;\\n                    count++;\\n                    if(count>days[a-1])\\n                    {\\n                        count = 1;\\n                        a = (a)%12;\\n                        a++;\\n                    }\\n            }\\n        }\\n        return total;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        store(arriveAlice,leaveAlice);\\n        return countDays(arriveBob,leaveBob);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587933,
                "title": "c-short-and-concise",
                "content": "```\\nint countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        \\n        string start = max(arriveAlice,arriveBob) , end=min(leaveAlice,leaveBob);\\n        vector<int> m = {0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        if(start<=end)\\n        {\\n            int em = stoi(end.substr(0,2))   , ed = stoi(end.substr(3,2)) ;\\n            int sm = stoi(start.substr(0,2)) , sd = stoi(start.substr(3,2)) ;\\n            \\n            if(em != sm)\\n            {\\n                int d = m[sm]-sd;\\n                for(int i=sm+1 ; i<em ; i++)   d += m[i] ; \\n                \\n                return d += ed+1 ;\\n            }            \\n            else  return ed-sd+1 ;\\n        }\\n        return 0 ;   \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        \\n        string start = max(arriveAlice,arriveBob) , end=min(leaveAlice,leaveBob);\\n        vector<int> m = {0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        if(start<=end)\\n        {\\n            int em = stoi(end.substr(0,2))   , ed = stoi(end.substr(3,2)) ;\\n            int sm = stoi(start.substr(0,2)) , sd = stoi(start.substr(3,2)) ;\\n            \\n            if(em != sm)\\n            {\\n                int d = m[sm]-sd;\\n                for(int i=sm+1 ; i<em ; i++)   d += m[i] ; \\n                \\n                return d += ed+1 ;\\n            }            \\n            else  return ed-sd+1 ;\\n        }\\n        return 0 ;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4076719,
                "title": "too-easy-to-understand-code-throughly-explained-beats-runtime-100-memory-85",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, find the largest of the two arrival date and lowest of the two leave date, this will give you the inclusive days they spend together. \\nString compareTo() function is used to get a lexicographical difference.\\nRest of the explanation is in the Code itself. \\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/c11c8b2b-5f82-4300-8a98-bb843d7c37bb_1695388049.2025945.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        //the date at which both will be in the town at the start,\\n        //would be the arrival date of the latecomer (largest of the two arrival date)\\n        String start = arriveAlice.compareTo(arriveBob) >= 0 ? arriveAlice : arriveBob;\\n        //the date at the both will in the town for the last time,\\n        //would be the date of the early leaver (smallest of the two leave date)\\n        String end = leaveAlice.compareTo(leaveBob) >= 0 ? leaveBob : leaveAlice;\\n        \\n        //if one leaves early before the arrival of the second one\\n        //total day spend would be 0\\n        if(start.compareTo(end) > 0){\\n            return 0;\\n        }\\n\\n        //extract months and dates from the string\\n        int total = 0;\\n        int startMonth = Integer.parseInt(start.substring(0, 2));\\n        int startDate = Integer.parseInt(start.substring(3));\\n        int endMonth = Integer.parseInt(end.substring(0, 2));\\n        int endDate = Integer.parseInt(end.substring(3));\\n        \\n        //if the startMonth and endMonth is equal, total days spend\\n        //together would be subtration of endDate - startDate + 1 as startDate is inclusive\\n        if(startMonth == endMonth){\\n            return endDate - startDate + 1;\\n        }\\n\\n        //if months are not equal, then this applies\\n        int[] month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        //add the days per month they stays together\\n        //as startMonth is already running cant take full days of it, same goes for endMonth\\n        //any month inbetween these would be added in total\\n        for(int i = startMonth+1; i < endMonth; i++){\\n            //i-1 as month starts from 1 but index from 0\\n            total += month[i-1];\\n        }\\n\\n        //add the days of first month spend together (total days in the month - lowest \\n        //arrival date + 1(as arrival date is inclusive)) and \\n        //the end date to the total\\n        return total + month[startMonth-1] - startDate + 1 + endDate;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        //the date at which both will be in the town at the start,\\n        //would be the arrival date of the latecomer (largest of the two arrival date)\\n        String start = arriveAlice.compareTo(arriveBob) >= 0 ? arriveAlice : arriveBob;\\n        //the date at the both will in the town for the last time,\\n        //would be the date of the early leaver (smallest of the two leave date)\\n        String end = leaveAlice.compareTo(leaveBob) >= 0 ? leaveBob : leaveAlice;\\n        \\n        //if one leaves early before the arrival of the second one\\n        //total day spend would be 0\\n        if(start.compareTo(end) > 0){\\n            return 0;\\n        }\\n\\n        //extract months and dates from the string\\n        int total = 0;\\n        int startMonth = Integer.parseInt(start.substring(0, 2));\\n        int startDate = Integer.parseInt(start.substring(3));\\n        int endMonth = Integer.parseInt(end.substring(0, 2));\\n        int endDate = Integer.parseInt(end.substring(3));\\n        \\n        //if the startMonth and endMonth is equal, total days spend\\n        //together would be subtration of endDate - startDate + 1 as startDate is inclusive\\n        if(startMonth == endMonth){\\n            return endDate - startDate + 1;\\n        }\\n\\n        //if months are not equal, then this applies\\n        int[] month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        //add the days per month they stays together\\n        //as startMonth is already running cant take full days of it, same goes for endMonth\\n        //any month inbetween these would be added in total\\n        for(int i = startMonth+1; i < endMonth; i++){\\n            //i-1 as month starts from 1 but index from 0\\n            total += month[i-1];\\n        }\\n\\n        //add the days of first month spend together (total days in the month - lowest \\n        //arrival date + 1(as arrival date is inclusive)) and \\n        //the end date to the total\\n        return total + month[startMonth-1] - startDate + 1 + endDate;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064066,
                "title": "c-python-date-to-a-number-solution-with-explanation",
                "content": "First, convert date to a number,\\nfor example, 07-01 = (total days from 01-01 to 06 -30) + 1.\\nSo, we can use prefix sum to calculate total day from 01-01 to current month\\'s last day.\\nAnd add days in current month, we get a number.\\n\\n![image](https://assets.leetcode.com/users/images/c25e375c-6efe-4ed7-915c-7706a911d4ab_1695121965.0763216.png)\\nif the condition is true, they can meet each other in the city.\\nif not, return 0.\\n\\n\\n### python\\n```python\\nprefix = [0]\\nfor x in (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31):\\n    prefix.append(prefix[-1] + x)\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        def calc(day: str) -> int:\\n            m = int(day[:2])\\n            d = int(day[3:])\\n            return prefix[m-1] + d\\n        arriveAlice, leaveAlice = calc(arriveAlice), calc(leaveAlice)\\n        arriveBob, leaveBob = calc(arriveBob), calc(leaveBob)\\n        if max(arriveAlice, arriveBob) <= min(leaveAlice, leaveBob):\\n            return min(leaveAlice, leaveBob) - max(arriveAlice, arriveBob) + 1\\n        return 0\\n```\\n\\n### c++\\n```cpp\\nconst int day_[] {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\nvector<int> prefix {0};\\nint prefix_ = [] () {\\n    for (auto&x: day_)\\n        prefix.emplace_back(x + prefix.back());\\n    return 0;\\n}();\\n\\nint calc (string& day) {\\n    int m = prefix[stoi(day.substr(0, 2)) - 1], d = stoi(day.substr(3, 2));\\n    return m + d;\\n}\\n\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int aa = calc(arriveAlice), la = calc(leaveAlice), ab = calc(arriveBob), lb = calc(leaveBob);\\n        if (max(aa, ab) <= min(la, lb))\\n            return min(la, lb) - max(aa, ab) + 1;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\nprefix = [0]\\nfor x in (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31):\\n    prefix.append(prefix[-1] + x)\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        def calc(day: str) -> int:\\n            m = int(day[:2])\\n            d = int(day[3:])\\n            return prefix[m-1] + d\\n        arriveAlice, leaveAlice = calc(arriveAlice), calc(leaveAlice)\\n        arriveBob, leaveBob = calc(arriveBob), calc(leaveBob)\\n        if max(arriveAlice, arriveBob) <= min(leaveAlice, leaveBob):\\n            return min(leaveAlice, leaveBob) - max(arriveAlice, arriveBob) + 1\\n        return 0\\n```\n```cpp\\nconst int day_[] {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\nvector<int> prefix {0};\\nint prefix_ = [] () {\\n    for (auto&x: day_)\\n        prefix.emplace_back(x + prefix.back());\\n    return 0;\\n}();\\n\\nint calc (string& day) {\\n    int m = prefix[stoi(day.substr(0, 2)) - 1], d = stoi(day.substr(3, 2));\\n    return m + d;\\n}\\n\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int aa = calc(arriveAlice), la = calc(leaveAlice), ab = calc(arriveBob), lb = calc(leaveBob);\\n        if (max(aa, ab) <= min(la, lb))\\n            return min(la, lb) - max(aa, ab) + 1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062216,
                "title": "brute-force-solution-c-commented-code",
                "content": "# Code\\n```\\n// Upvote If it\\'s Helps\\n\\nclass Solution {\\nprivate:\\n    void FillMonth(vector<vector<int>> &nums,string &s,string &e){\\n        int startMonth = (s[0]-\\'0\\')*10 + s[1]-\\'0\\';\\n        int endMonth = (e[0]-\\'0\\')*10 + e[1]-\\'0\\';\\n        int startDay = (s[3]-\\'0\\')*10 + s[4]-\\'0\\';\\n        int endDay = (e[3]-\\'0\\')*10 + e[4]-\\'0\\';\\n\\n        // Case 1 : if start and end month is same\\n        if(startMonth == endMonth){\\n            for(int i=startDay-1;i<endDay;i++){\\n                nums[startMonth-1][i] += 1;\\n            }\\n        }\\n        // Case 2 : if start month and end month is not same\\n        else{\\n            // Adding starting first month\\n            for(int i=startDay-1;i<nums[startMonth-1].size();i++){\\n                nums[startMonth-1][i] += 1;\\n            }\\n            // Adding months between start and end month\\n            for(int i=startMonth;i<endMonth-1;i++){\\n                for(int j=0;j<nums[i].size();j++){\\n                    nums[i][j] += 1;\\n                }\\n            }\\n            // Adding last month\\n            for(int j=0;j<endDay;j++){\\n                nums[endMonth-1][j] += 1;\\n            }\\n        }\\n    }\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        // Creating calender\\n        vector<vector<int>> calender;\\n        // Pushing Jan and feb\\n        vector<int> jan(31,0), feb(28,0);\\n        calender.push_back(jan);\\n        calender.push_back(feb);\\n\\n        int k = 2;\\n        while(k--){\\n            int flag = 0;\\n            for(int i=0;i<5;i++){\\n                if(flag == 0){\\n                    vector<int> temp(31,0);\\n                    calender.push_back(temp);\\n                    flag = 1;\\n                }\\n                else{\\n                    vector<int> temp(30,0);\\n                    calender.push_back(temp);\\n                    flag = 0;\\n                }\\n            }\\n        }\\n\\n        // Now calender is created\\n        // filling the month\\n        FillMonth(calender,arriveAlice,leaveAlice);\\n        FillMonth(calender,arriveBob,leaveBob);\\n\\n        int ans = 0;\\n        for(int i=0;i<12;i++){\\n            for(int j=0;j<calender[i].size();j++){\\n                if(calender[i][j] == 2){\\n                    ans++;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n// Upvote If it\\'s Helps\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Upvote If it\\'s Helps\\n\\nclass Solution {\\nprivate:\\n    void FillMonth(vector<vector<int>> &nums,string &s,string &e){\\n        int startMonth = (s[0]-\\'0\\')*10 + s[1]-\\'0\\';\\n        int endMonth = (e[0]-\\'0\\')*10 + e[1]-\\'0\\';\\n        int startDay = (s[3]-\\'0\\')*10 + s[4]-\\'0\\';\\n        int endDay = (e[3]-\\'0\\')*10 + e[4]-\\'0\\';\\n\\n        // Case 1 : if start and end month is same\\n        if(startMonth == endMonth){\\n            for(int i=startDay-1;i<endDay;i++){\\n                nums[startMonth-1][i] += 1;\\n            }\\n        }\\n        // Case 2 : if start month and end month is not same\\n        else{\\n            // Adding starting first month\\n            for(int i=startDay-1;i<nums[startMonth-1].size();i++){\\n                nums[startMonth-1][i] += 1;\\n            }\\n            // Adding months between start and end month\\n            for(int i=startMonth;i<endMonth-1;i++){\\n                for(int j=0;j<nums[i].size();j++){\\n                    nums[i][j] += 1;\\n                }\\n            }\\n            // Adding last month\\n            for(int j=0;j<endDay;j++){\\n                nums[endMonth-1][j] += 1;\\n            }\\n        }\\n    }\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        // Creating calender\\n        vector<vector<int>> calender;\\n        // Pushing Jan and feb\\n        vector<int> jan(31,0), feb(28,0);\\n        calender.push_back(jan);\\n        calender.push_back(feb);\\n\\n        int k = 2;\\n        while(k--){\\n            int flag = 0;\\n            for(int i=0;i<5;i++){\\n                if(flag == 0){\\n                    vector<int> temp(31,0);\\n                    calender.push_back(temp);\\n                    flag = 1;\\n                }\\n                else{\\n                    vector<int> temp(30,0);\\n                    calender.push_back(temp);\\n                    flag = 0;\\n                }\\n            }\\n        }\\n\\n        // Now calender is created\\n        // filling the month\\n        FillMonth(calender,arriveAlice,leaveAlice);\\n        FillMonth(calender,arriveBob,leaveBob);\\n\\n        int ans = 0;\\n        for(int i=0;i<12;i++){\\n            for(int j=0;j<calender[i].size();j++){\\n                if(calender[i][j] == 2){\\n                    ans++;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n// Upvote If it\\'s Helps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055306,
                "title": "very-easy-jebasraja",
                "content": "# Intuition:KARUNYA UNIVERISTY:::ACCENTURE\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) \\n    {\\n\\n     String[] temp1=arriveAlice.split(\"-\");\\n     String[] temp2=leaveAlice.split(\"-\");\\n     String[] temp3=arriveBob.split(\"-\");\\n     String[] temp4=leaveBob.split(\"-\");\\n    \\n     int[] arriveAlicemonthanddate=new int[2];\\n     int[] leaveAlicemonthanddate=new int[2];\\n     int[] arriveBobmonthanddate=new int[2];\\n     int[] leaveBobmonthanddate=new int[2];\\n\\n     for (int i = 0; i < 2; i++) \\n     {\\n        arriveAlicemonthanddate[i]=Integer.parseInt(temp1[i]);\\n        leaveAlicemonthanddate[i]=Integer.parseInt(temp2[i]);\\n        arriveBobmonthanddate[i]=Integer.parseInt(temp3[i]);\\n        leaveBobmonthanddate[i]=Integer.parseInt(temp4[i]);  \\n     }\\n    \\n     //0 condition\\n   if ((leaveAlicemonthanddate[0]*60)+leaveAlicemonthanddate[1]<(arriveBobmonthanddate[0]*60)+arriveBobmonthanddate[1]) \\n   {\\n     //System.out.println(0);\\n    return 0;   \\n   }\\n   else if ((arriveAlicemonthanddate[0]*60)+arriveAlicemonthanddate[1]>((leaveBobmonthanddate[0])*60)+leaveBobmonthanddate[1]) \\n   {\\n     // System.out.println(0);\\n     return 0;\\n   }\\n   \\n   int startmonth=0;\\n   int startdate=0;\\n\\n   int endmonth=0;\\n   int enddate=0;\\n   \\n   //finding the start month\\n   //alice came late\\n   if ((arriveAlicemonthanddate[0]*60)+arriveAlicemonthanddate[1]>=(arriveBobmonthanddate[0]*60)+arriveBobmonthanddate[1]) \\n   {\\n      //System.out.println(\"sdfs\");\\n     startmonth=arriveAlicemonthanddate[0];\\n     startdate= arriveAlicemonthanddate[1];\\n   }\\n   //bob came late\\n   else\\n   {\\n     // System.out.println(\"sadadad\"+arriveBobmonthanddate[0]+\"-\"+arriveBobmonthanddate[1]);\\n     startmonth=arriveBobmonthanddate[0];\\n     startdate= arriveBobmonthanddate[1];\\n   }\\n   \\n   //finding the end date\\n   if ((leaveAlicemonthanddate[0]*60)+leaveAlicemonthanddate[1]<=(leaveBobmonthanddate[0]*60)+leaveBobmonthanddate[1]) \\n   { \\n      //System.out.println(\"sdfsf\");\\n      endmonth=leaveAlicemonthanddate[0];\\n      enddate=leaveAlicemonthanddate[1];\\n   }\\n   else\\n   {   \\n      //System.out.println(\"sdfsfsf\");\\n      endmonth= leaveBobmonthanddate[0];\\n      enddate=leaveBobmonthanddate[1];\\n   }\\n    \\n\\n   //System.out.println(\"startmonth\"+\" \"+startmonth);\\n   //System.out.println(\"startdate\"+\" \"+startdate);\\n   //System.out.println(\"endmonth\"+\" \"+endmonth);\\n   //System.out.println(\"enddate\"+\" \"+enddate);\\n\\n\\n   HashMap<Integer, Integer> monthDaysMap = new HashMap<>();\\n\\n   // Populate the HashMap with months and their respective days\\n   monthDaysMap.put(1, 31);   // January\\n   monthDaysMap.put(2, 28);   // February (non-leap year)\\n   monthDaysMap.put(3, 31);   // March\\n   monthDaysMap.put(4, 30);   // April\\n   monthDaysMap.put(5, 31);   // May\\n   monthDaysMap.put(6, 30);   // June\\n   monthDaysMap.put(7, 31);   // July\\n   monthDaysMap.put(8, 31);   // August\\n   monthDaysMap.put(9, 30);   // September\\n   monthDaysMap.put(10, 31);  // October\\n   monthDaysMap.put(11, 30);  // November\\n   monthDaysMap.put(12, 31);  // December\\n   \\n   int finalanswer=0;\\n     \\n\\n\\n   for (int i = startmonth; i <=endmonth; i++) \\n   {  \\n      if(startmonth==endmonth)\\n      { \\n        // System.out.println(\"sdfsf\");\\n          finalanswer=Math.abs(startdate-enddate)+1;\\n      } \\n      else if (i==startmonth) \\n      {\\n         finalanswer+=(monthDaysMap.get(startmonth)-startdate)+1;\\n         //System.out.println(finalanswer);\\n      }\\n      else if (i==endmonth) \\n      { \\n         finalanswer+=enddate;\\n          //System.out.println(finalanswer);\\n      }\\n      else\\n      {\\n        finalanswer+=monthDaysMap.get(i);\\n      }\\n   }\\n     \\n  /// System.out.println(finalanswer);\\n\\n   return finalanswer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) \\n    {\\n\\n     String[] temp1=arriveAlice.split(\"-\");\\n     String[] temp2=leaveAlice.split(\"-\");\\n     String[] temp3=arriveBob.split(\"-\");\\n     String[] temp4=leaveBob.split(\"-\");\\n    \\n     int[] arriveAlicemonthanddate=new int[2];\\n     int[] leaveAlicemonthanddate=new int[2];\\n     int[] arriveBobmonthanddate=new int[2];\\n     int[] leaveBobmonthanddate=new int[2];\\n\\n     for (int i = 0; i < 2; i++) \\n     {\\n        arriveAlicemonthanddate[i]=Integer.parseInt(temp1[i]);\\n        leaveAlicemonthanddate[i]=Integer.parseInt(temp2[i]);\\n        arriveBobmonthanddate[i]=Integer.parseInt(temp3[i]);\\n        leaveBobmonthanddate[i]=Integer.parseInt(temp4[i]);  \\n     }\\n    \\n     //0 condition\\n   if ((leaveAlicemonthanddate[0]*60)+leaveAlicemonthanddate[1]<(arriveBobmonthanddate[0]*60)+arriveBobmonthanddate[1]) \\n   {\\n     //System.out.println(0);\\n    return 0;   \\n   }\\n   else if ((arriveAlicemonthanddate[0]*60)+arriveAlicemonthanddate[1]>((leaveBobmonthanddate[0])*60)+leaveBobmonthanddate[1]) \\n   {\\n     // System.out.println(0);\\n     return 0;\\n   }\\n   \\n   int startmonth=0;\\n   int startdate=0;\\n\\n   int endmonth=0;\\n   int enddate=0;\\n   \\n   //finding the start month\\n   //alice came late\\n   if ((arriveAlicemonthanddate[0]*60)+arriveAlicemonthanddate[1]>=(arriveBobmonthanddate[0]*60)+arriveBobmonthanddate[1]) \\n   {\\n      //System.out.println(\"sdfs\");\\n     startmonth=arriveAlicemonthanddate[0];\\n     startdate= arriveAlicemonthanddate[1];\\n   }\\n   //bob came late\\n   else\\n   {\\n     // System.out.println(\"sadadad\"+arriveBobmonthanddate[0]+\"-\"+arriveBobmonthanddate[1]);\\n     startmonth=arriveBobmonthanddate[0];\\n     startdate= arriveBobmonthanddate[1];\\n   }\\n   \\n   //finding the end date\\n   if ((leaveAlicemonthanddate[0]*60)+leaveAlicemonthanddate[1]<=(leaveBobmonthanddate[0]*60)+leaveBobmonthanddate[1]) \\n   { \\n      //System.out.println(\"sdfsf\");\\n      endmonth=leaveAlicemonthanddate[0];\\n      enddate=leaveAlicemonthanddate[1];\\n   }\\n   else\\n   {   \\n      //System.out.println(\"sdfsfsf\");\\n      endmonth= leaveBobmonthanddate[0];\\n      enddate=leaveBobmonthanddate[1];\\n   }\\n    \\n\\n   //System.out.println(\"startmonth\"+\" \"+startmonth);\\n   //System.out.println(\"startdate\"+\" \"+startdate);\\n   //System.out.println(\"endmonth\"+\" \"+endmonth);\\n   //System.out.println(\"enddate\"+\" \"+enddate);\\n\\n\\n   HashMap<Integer, Integer> monthDaysMap = new HashMap<>();\\n\\n   // Populate the HashMap with months and their respective days\\n   monthDaysMap.put(1, 31);   // January\\n   monthDaysMap.put(2, 28);   // February (non-leap year)\\n   monthDaysMap.put(3, 31);   // March\\n   monthDaysMap.put(4, 30);   // April\\n   monthDaysMap.put(5, 31);   // May\\n   monthDaysMap.put(6, 30);   // June\\n   monthDaysMap.put(7, 31);   // July\\n   monthDaysMap.put(8, 31);   // August\\n   monthDaysMap.put(9, 30);   // September\\n   monthDaysMap.put(10, 31);  // October\\n   monthDaysMap.put(11, 30);  // November\\n   monthDaysMap.put(12, 31);  // December\\n   \\n   int finalanswer=0;\\n     \\n\\n\\n   for (int i = startmonth; i <=endmonth; i++) \\n   {  \\n      if(startmonth==endmonth)\\n      { \\n        // System.out.println(\"sdfsf\");\\n          finalanswer=Math.abs(startdate-enddate)+1;\\n      } \\n      else if (i==startmonth) \\n      {\\n         finalanswer+=(monthDaysMap.get(startmonth)-startdate)+1;\\n         //System.out.println(finalanswer);\\n      }\\n      else if (i==endmonth) \\n      { \\n         finalanswer+=enddate;\\n          //System.out.println(finalanswer);\\n      }\\n      else\\n      {\\n        finalanswer+=monthDaysMap.get(i);\\n      }\\n   }\\n     \\n  /// System.out.println(finalanswer);\\n\\n   return finalanswer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046008,
                "title": "rust-const-fn-lookup",
                "content": "# Code\\n```\\nuse std::str::FromStr;\\n\\nimpl Solution {\\n    pub fn count_days_together(arrive_alice: String, leave_alice: String, arrive_bob: String, leave_bob: String) -> i32 {\\n        let starta = str_to_date(&arrive_alice);\\n        let enda = str_to_date(&leave_alice);\\n        let startb = str_to_date(&arrive_bob);\\n        let endb = str_to_date(&leave_bob);\\n        (enda.min(endb) - starta.max(startb) + 1).max(0)\\n    }\\n}\\n\\nfn str_to_date(date: &str) -> i32 {\\n    let (left, right) = date.split_once(\\'-\\').unwrap();\\n    let month = usize::from_str(left).unwrap() - 1;\\n    let day = i32::from_str(right).unwrap() - 1;\\n    day + MONTH_START[month]\\n}\\n\\nconst MONTH_LEN: [i32; 12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n\\nconst MONTH_START: [i32; 12] = gen_starts();\\n\\nconst fn gen_starts() -> [i32; 12] {\\n    let mut arr = [0; 12];\\n    let mut sum = 0;\\n    let mut i = 0;\\n    while i < 12 {\\n        arr[i] = sum;\\n        sum += MONTH_LEN[i];\\n        i += 1;\\n    }\\n    arr\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::str::FromStr;\\n\\nimpl Solution {\\n    pub fn count_days_together(arrive_alice: String, leave_alice: String, arrive_bob: String, leave_bob: String) -> i32 {\\n        let starta = str_to_date(&arrive_alice);\\n        let enda = str_to_date(&leave_alice);\\n        let startb = str_to_date(&arrive_bob);\\n        let endb = str_to_date(&leave_bob);\\n        (enda.min(endb) - starta.max(startb) + 1).max(0)\\n    }\\n}\\n\\nfn str_to_date(date: &str) -> i32 {\\n    let (left, right) = date.split_once(\\'-\\').unwrap();\\n    let month = usize::from_str(left).unwrap() - 1;\\n    let day = i32::from_str(right).unwrap() - 1;\\n    day + MONTH_START[month]\\n}\\n\\nconst MONTH_LEN: [i32; 12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n\\nconst MONTH_START: [i32; 12] = gen_starts();\\n\\nconst fn gen_starts() -> [i32; 12] {\\n    let mut arr = [0; 12];\\n    let mut sum = 0;\\n    let mut i = 0;\\n    while i < 12 {\\n        arr[i] = sum;\\n        sum += MONTH_LEN[i];\\n        i += 1;\\n    }\\n    arr\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037709,
                "title": "python-beats-89-45",
                "content": "# Code\\n![\\u672A\\u547D\\u540D.png](https://assets.leetcode.com/users/images/e8058428-4f4a-4b63-b3e9-ae1c706437c3_1694566803.1178703.png)\\n```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        Output = 0\\n        d = {1: 31, 2: 28, 3: 31, 4: 30, 5: 31, 6: 30, 7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31}\\n        arriveAlice = arriveAlice[0] + arriveAlice[1] + arriveAlice[3] + arriveAlice[4]\\n        leaveAlice = leaveAlice[0] + leaveAlice[1] + leaveAlice[3] + leaveAlice[4]\\n        arriveBob = arriveBob[0] + arriveBob[1] + arriveBob[3] + arriveBob[4]\\n        leaveBob = leaveBob[0] + leaveBob[1] + leaveBob[3] + leaveBob[4]\\n\\n        def PASS(time1: str,time2: str) -> int:\\n            nonlocal Output\\n            curr = int(time1[0] + time1[1])\\n            end = int(time2[0] + time2[1])\\n\\n            if curr != end:\\n                Output = Output + d[curr] - int(time1[2] + time1[3]) + 1\\n                curr = curr + 1\\n                while curr != end:\\n                    Output = Output + d[curr]\\n                    curr = curr + 1\\n                Output = Output + int(time2[2] + time2[3])\\n            elif curr == end:\\n                Output = Output + int(time2[2] + time2[3]) - int(time1[2] + time1[3]) + 1\\n            \\n            return Output\\n        \\n        if int(arriveBob) > int(leaveAlice) or int(arriveAlice) > int(leaveBob):\\n            return 0\\n        else:\\n            if int(arriveBob) > int(arriveAlice):\\n                if int(leaveBob) > int(leaveAlice):\\n                    return PASS(arriveBob, leaveAlice)\\n                elif int(leaveBob) <= int(leaveAlice):\\n                    return PASS(arriveBob, leaveBob)\\n            elif int(arriveBob) < int(arriveAlice):\\n                if int(leaveBob) >= int(leaveAlice):\\n                    return PASS(arriveAlice, leaveAlice)\\n                elif int(leaveBob) < int(leaveAlice):\\n                    return PASS(arriveAlice, leaveBob)\\n            elif int(arriveBob) == int(arriveAlice):\\n                if int(leaveBob) >= int(leaveAlice):\\n                    return PASS(arriveAlice, leaveAlice)\\n                elif int(leaveBob) < int(leaveAlice):\\n                    return PASS(arriveBob, leaveBob)\\n\\n        # 20230913\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        Output = 0\\n        d = {1: 31, 2: 28, 3: 31, 4: 30, 5: 31, 6: 30, 7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31}\\n        arriveAlice = arriveAlice[0] + arriveAlice[1] + arriveAlice[3] + arriveAlice[4]\\n        leaveAlice = leaveAlice[0] + leaveAlice[1] + leaveAlice[3] + leaveAlice[4]\\n        arriveBob = arriveBob[0] + arriveBob[1] + arriveBob[3] + arriveBob[4]\\n        leaveBob = leaveBob[0] + leaveBob[1] + leaveBob[3] + leaveBob[4]\\n\\n        def PASS(time1: str,time2: str) -> int:\\n            nonlocal Output\\n            curr = int(time1[0] + time1[1])\\n            end = int(time2[0] + time2[1])\\n\\n            if curr != end:\\n                Output = Output + d[curr] - int(time1[2] + time1[3]) + 1\\n                curr = curr + 1\\n                while curr != end:\\n                    Output = Output + d[curr]\\n                    curr = curr + 1\\n                Output = Output + int(time2[2] + time2[3])\\n            elif curr == end:\\n                Output = Output + int(time2[2] + time2[3]) - int(time1[2] + time1[3]) + 1\\n            \\n            return Output\\n        \\n        if int(arriveBob) > int(leaveAlice) or int(arriveAlice) > int(leaveBob):\\n            return 0\\n        else:\\n            if int(arriveBob) > int(arriveAlice):\\n                if int(leaveBob) > int(leaveAlice):\\n                    return PASS(arriveBob, leaveAlice)\\n                elif int(leaveBob) <= int(leaveAlice):\\n                    return PASS(arriveBob, leaveBob)\\n            elif int(arriveBob) < int(arriveAlice):\\n                if int(leaveBob) >= int(leaveAlice):\\n                    return PASS(arriveAlice, leaveAlice)\\n                elif int(leaveBob) < int(leaveAlice):\\n                    return PASS(arriveAlice, leaveBob)\\n            elif int(arriveBob) == int(arriveAlice):\\n                if int(leaveBob) >= int(leaveAlice):\\n                    return PASS(arriveAlice, leaveAlice)\\n                elif int(leaveBob) < int(leaveAlice):\\n                    return PASS(arriveBob, leaveBob)\\n\\n        # 20230913\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019880,
                "title": "clear-and-easy-to-understand-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int[] daysOfMonth = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int aA = dayOfYear(daysOfMonth, mmdd(arriveAlice));\\n        int lA = dayOfYear(daysOfMonth, mmdd(leaveAlice));\\n        int aB = dayOfYear(daysOfMonth, mmdd(arriveBob));\\n        int lB = dayOfYear(daysOfMonth, mmdd(leaveBob));\\n        if(aA > lB || aB > lA) return 0;\\n        return Math.min(lA, lB) - Math.max(aA, aB) + 1;\\n        \\n    }\\n\\n    private int[] mmdd(String str){\\n        String[] arr = str.split(\"-\");\\n        return new int[]{Integer.parseInt(arr[0]), Integer.parseInt(arr[1])};\\n    }\\n\\n    private int dayOfYear(int[] daysOfMonths, int[] mmdd){\\n        int count = 0;\\n        for(int i = 0; i < mmdd[0] - 1; i++)\\n            count += daysOfMonths[i];\\n        count += mmdd[1];\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int[] daysOfMonth = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int aA = dayOfYear(daysOfMonth, mmdd(arriveAlice));\\n        int lA = dayOfYear(daysOfMonth, mmdd(leaveAlice));\\n        int aB = dayOfYear(daysOfMonth, mmdd(arriveBob));\\n        int lB = dayOfYear(daysOfMonth, mmdd(leaveBob));\\n        if(aA > lB || aB > lA) return 0;\\n        return Math.min(lA, lB) - Math.max(aA, aB) + 1;\\n        \\n    }\\n\\n    private int[] mmdd(String str){\\n        String[] arr = str.split(\"-\");\\n        return new int[]{Integer.parseInt(arr[0]), Integer.parseInt(arr[1])};\\n    }\\n\\n    private int dayOfYear(int[] daysOfMonths, int[] mmdd){\\n        int count = 0;\\n        for(int i = 0; i < mmdd[0] - 1; i++)\\n            count += daysOfMonths[i];\\n        count += mmdd[1];\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965711,
                "title": "python-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nchoosing second to come and first to leave dates.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConverting the string to [month, date] list.\\nAdding dates in a month between these two choosing and the rest of days.\\nMultiplying the month with some high number to compare the dates.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        arriveAlice, arriveBob = [int(i) for i in arriveAlice.split(\\'-\\')], [int(j) for j in arriveBob.split(\\'-\\')]\\n        leaveAlice, leaveBob = [int(i) for i in leaveAlice.split(\\'-\\')], [int(j) for j in leaveBob.split(\\'-\\')]\\n        second_come = arriveAlice if arriveAlice[0] * 1000 + arriveAlice[1] > arriveBob[0] * 1000 + arriveBob[1] else arriveBob\\n        first_leave = leaveAlice if leaveAlice[0] * 1000 + leaveAlice[1] < leaveBob[0] * 1000 + leaveBob[1] else leaveBob\\n        if second_come[0] * 1000 + second_come[1] > first_leave[0] * 1000 + first_leave[1]: return 0\\n        return sum(self.months[i - 1] for i in range(second_come[0], first_leave[0])) - second_come[1] + first_leave[1] + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        arriveAlice, arriveBob = [int(i) for i in arriveAlice.split(\\'-\\')], [int(j) for j in arriveBob.split(\\'-\\')]\\n        leaveAlice, leaveBob = [int(i) for i in leaveAlice.split(\\'-\\')], [int(j) for j in leaveBob.split(\\'-\\')]\\n        second_come = arriveAlice if arriveAlice[0] * 1000 + arriveAlice[1] > arriveBob[0] * 1000 + arriveBob[1] else arriveBob\\n        first_leave = leaveAlice if leaveAlice[0] * 1000 + leaveAlice[1] < leaveBob[0] * 1000 + leaveBob[1] else leaveBob\\n        if second_come[0] * 1000 + second_come[1] > first_leave[0] * 1000 + first_leave[1]: return 0\\n        return sum(self.months[i - 1] for i in range(second_come[0], first_leave[0])) - second_come[1] + first_leave[1] + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948758,
                "title": "unique-solution-using-the-logic-of-number-of-days-between-two-dates",
                "content": "# Code\\n```\\nimport java.time.LocalDate;\\nimport java.time.temporal.ChronoUnit;\\n\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n\\n        LocalDate aAlice = LocalDate.of(2019,Integer.valueOf(arriveAlice.substring(0,2)),Integer.valueOf( arriveAlice.substring(3,5) ) );\\n\\n        LocalDate aBob = LocalDate.of(2019,Integer.valueOf(arriveBob.substring(0,2)),Integer.valueOf( arriveBob.substring(3,5) ) );\\n\\n        LocalDate lAlice = LocalDate.of(2019,Integer.valueOf(leaveAlice.substring(0,2)),Integer.valueOf( leaveAlice.substring(3,5) ) );\\n\\n        LocalDate lBob = LocalDate.of(2019,Integer.valueOf(leaveBob.substring(0,2)),Integer.valueOf( leaveBob.substring(3,5) ) );\\n\\n        LocalDate arrival = aAlice.isAfter(aBob)?aAlice:aBob;\\n        LocalDate depart = lAlice.isBefore(lBob)?lAlice:lBob;\\n        long daysBetween =  ChronoUnit.DAYS.between(arrival,depart);\\n        int g = (int) daysBetween+1;\\n        if(g<0){\\n            return 0;\\n        }\\n        return g;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.time.LocalDate;\\nimport java.time.temporal.ChronoUnit;\\n\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n\\n        LocalDate aAlice = LocalDate.of(2019,Integer.valueOf(arriveAlice.substring(0,2)),Integer.valueOf( arriveAlice.substring(3,5) ) );\\n\\n        LocalDate aBob = LocalDate.of(2019,Integer.valueOf(arriveBob.substring(0,2)),Integer.valueOf( arriveBob.substring(3,5) ) );\\n\\n        LocalDate lAlice = LocalDate.of(2019,Integer.valueOf(leaveAlice.substring(0,2)),Integer.valueOf( leaveAlice.substring(3,5) ) );\\n\\n        LocalDate lBob = LocalDate.of(2019,Integer.valueOf(leaveBob.substring(0,2)),Integer.valueOf( leaveBob.substring(3,5) ) );\\n\\n        LocalDate arrival = aAlice.isAfter(aBob)?aAlice:aBob;\\n        LocalDate depart = lAlice.isBefore(lBob)?lAlice:lBob;\\n        long daysBetween =  ChronoUnit.DAYS.between(arrival,depart);\\n        int g = (int) daysBetween+1;\\n        if(g<0){\\n            return 0;\\n        }\\n        return g;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945679,
                "title": "easy-to-understand-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    String greatDate(String s1,String s2){\\n        int m1=Integer.parseInt(s1.substring(0,2));\\n        int m2=Integer.parseInt(s2.substring(0,2));\\n        if(m1>m2) return s1;\\n        else if(m2>m1) return s2;\\n\\n        m1=Integer.parseInt(s1.substring(3));\\n        m2=Integer.parseInt(s2.substring(3));\\n\\n        if(m1>m2) return s1;\\n\\n        return s2;\\n    }\\n\\n     String smallDate(String s1,String s2){\\n        int m1=Integer.parseInt(s1.substring(0,2));\\n        int m2=Integer.parseInt(s2.substring(0,2));\\n        if(m1<m2) return s1;\\n        else if(m2<m1) return s2;\\n\\n        m1=Integer.parseInt(s1.substring(3));\\n        m2=Integer.parseInt(s2.substring(3));\\n\\n        if(m1<m2) return s1;\\n\\n        return s2;\\n    }\\n\\n    int countDay(String s1, String s2){\\n        int m1=Integer.parseInt(s1.substring(0,2));\\n        int m2=Integer.parseInt(s2.substring(0,2));\\n        int d1=Integer.parseInt(s1.substring(3));\\n        int d2=Integer.parseInt(s2.substring(3));\\n\\n        if(m1>m2) return 0;\\n        else if(m1==m2 && d1>d2) return 0;\\n        \\n\\n        int c=0;\\n        int [] arr={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\n        if(m1!=m2){\\n       for(int i=m1; i<m2-1; i++)\\n         c+=arr[i];\\n        }else if(m1==m2) return d2-d1+1;\\n\\n\\n        return c+d2+arr[m1-1]-d1+1;\\n    }\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n         \\n         String startDateTogether = greatDate(arriveAlice,arriveBob);\\n\\n         String endDateTogether = smallDate(leaveBob,leaveAlice);\\n\\n         return countDay(startDateTogether,endDateTogether);\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    String greatDate(String s1,String s2){\\n        int m1=Integer.parseInt(s1.substring(0,2));\\n        int m2=Integer.parseInt(s2.substring(0,2));\\n        if(m1>m2) return s1;\\n        else if(m2>m1) return s2;\\n\\n        m1=Integer.parseInt(s1.substring(3));\\n        m2=Integer.parseInt(s2.substring(3));\\n\\n        if(m1>m2) return s1;\\n\\n        return s2;\\n    }\\n\\n     String smallDate(String s1,String s2){\\n        int m1=Integer.parseInt(s1.substring(0,2));\\n        int m2=Integer.parseInt(s2.substring(0,2));\\n        if(m1<m2) return s1;\\n        else if(m2<m1) return s2;\\n\\n        m1=Integer.parseInt(s1.substring(3));\\n        m2=Integer.parseInt(s2.substring(3));\\n\\n        if(m1<m2) return s1;\\n\\n        return s2;\\n    }\\n\\n    int countDay(String s1, String s2){\\n        int m1=Integer.parseInt(s1.substring(0,2));\\n        int m2=Integer.parseInt(s2.substring(0,2));\\n        int d1=Integer.parseInt(s1.substring(3));\\n        int d2=Integer.parseInt(s2.substring(3));\\n\\n        if(m1>m2) return 0;\\n        else if(m1==m2 && d1>d2) return 0;\\n        \\n\\n        int c=0;\\n        int [] arr={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\n        if(m1!=m2){\\n       for(int i=m1; i<m2-1; i++)\\n         c+=arr[i];\\n        }else if(m1==m2) return d2-d1+1;\\n\\n\\n        return c+d2+arr[m1-1]-d1+1;\\n    }\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n         \\n         String startDateTogether = greatDate(arriveAlice,arriveBob);\\n\\n         String endDateTogether = smallDate(leaveBob,leaveAlice);\\n\\n         return countDay(startDateTogether,endDateTogether);\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943026,
                "title": "simple-typescript-solution-100-speed",
                "content": "![image.png](https://assets.leetcode.com/users/images/772c5f9d-36de-45ee-90e1-35634b35f341_1692661114.9814005.png)\\n\\n# Code (100% speed)\\n```ts\\nconst NOT_LEAP_YEAR = \"2023-\"\\nconst DAY = 1000 * 60 * 60 * 24\\n\\nfunction countDaysTogether(arriveAlice: string, leaveAlice: string, arriveBob: string, leaveBob: string): number {\\n    const getDateVal = (a: string): number => {\\n        return new Date(NOT_LEAP_YEAR + a).valueOf()\\n    }\\n\\n    return Math.max(\\n        0,\\n        (\\n            Math.min(getDateVal(leaveAlice), getDateVal(leaveBob))\\n            - Math.max(getDateVal(arriveAlice), getDateVal(arriveBob))\\n        )/ DAY + 1\\n    )\\n};\\n```\\n\\n# Thank you\\nUpvote if you like \\u2B06\\uFE0F\\nIf you have any questions, please let me know in the comment section.",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nconst NOT_LEAP_YEAR = \"2023-\"\\nconst DAY = 1000 * 60 * 60 * 24\\n\\nfunction countDaysTogether(arriveAlice: string, leaveAlice: string, arriveBob: string, leaveBob: string): number {\\n    const getDateVal = (a: string): number => {\\n        return new Date(NOT_LEAP_YEAR + a).valueOf()\\n    }\\n\\n    return Math.max(\\n        0,\\n        (\\n            Math.min(getDateVal(leaveAlice), getDateVal(leaveBob))\\n            - Math.max(getDateVal(arriveAlice), getDateVal(arriveBob))\\n        )/ DAY + 1\\n    )\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938889,
                "title": "easy-readable-solution-3-lines",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfrom datetime import datetime\\n\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        def get_date(d):\\n            return datetime.strptime(d, \\'%m-%d\\')\\n        return max(0, (min(get_date(leaveAlice), get_date(leaveBob)) - max(get_date(arriveAlice), get_date(arriveBob))).days + 1)\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom datetime import datetime\\n\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        def get_date(d):\\n            return datetime.strptime(d, \\'%m-%d\\')\\n        return max(0, (min(get_date(leaveAlice), get_date(leaveBob)) - max(get_date(arriveAlice), get_date(arriveBob))).days + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919540,
                "title": "java-easiest-to-understand-clean-code-beats-100",
                "content": "# Intuition\\n* Get a reference for easy dealing with the intervals (start of year)\\n* Get days since start of year for each point in time\\n* Discard in case of no overalp\\n* Calculate difference between latest interval start and earlier interval end (+1 since limits are all inclusive)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nNo libraries or magic tricks, just parse dates and easily calculate.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public final static int[] daysInMonth = new int[] {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int arriveAliveEpoch = getDaysSinceYearStart(arriveAlice);\\n        int leaveAliceEpoch = getDaysSinceYearStart(leaveAlice);\\n        int arriveBobEpoch = getDaysSinceYearStart(arriveBob);\\n        int leaveBobEpoch = getDaysSinceYearStart(leaveBob);\\n\\n        return getOverlappingDays(arriveAliveEpoch, leaveAliceEpoch, arriveBobEpoch, leaveBobEpoch);\\n    }\\n\\n    private int getDaysSinceYearStart(String date) {\\n        int month = Integer.valueOf(date.substring(0, 2));\\n        int day = Integer.valueOf(date.substring(3, 5));\\n\\n        int numDays = 0;\\n\\n        for (int i = 0; i < month - 1; i++) {\\n            numDays += daysInMonth[i];\\n        }\\n\\n        numDays += day;\\n\\n        return numDays;\\n    }\\n\\n    private int getOverlappingDays(int firstIntervalStart, int firstIntervalEnd, int secondIntervalStart, int secondIntervalEnd) {\\n        if ( firstIntervalStart > secondIntervalEnd || secondIntervalStart > firstIntervalEnd) {\\n            return 0;\\n        } else {\\n            int latestStart = Math.max(firstIntervalStart, secondIntervalStart);\\n            int earliestEnd = Math.min(firstIntervalEnd, secondIntervalEnd);\\n\\n            return earliestEnd - latestStart + 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public final static int[] daysInMonth = new int[] {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int arriveAliveEpoch = getDaysSinceYearStart(arriveAlice);\\n        int leaveAliceEpoch = getDaysSinceYearStart(leaveAlice);\\n        int arriveBobEpoch = getDaysSinceYearStart(arriveBob);\\n        int leaveBobEpoch = getDaysSinceYearStart(leaveBob);\\n\\n        return getOverlappingDays(arriveAliveEpoch, leaveAliceEpoch, arriveBobEpoch, leaveBobEpoch);\\n    }\\n\\n    private int getDaysSinceYearStart(String date) {\\n        int month = Integer.valueOf(date.substring(0, 2));\\n        int day = Integer.valueOf(date.substring(3, 5));\\n\\n        int numDays = 0;\\n\\n        for (int i = 0; i < month - 1; i++) {\\n            numDays += daysInMonth[i];\\n        }\\n\\n        numDays += day;\\n\\n        return numDays;\\n    }\\n\\n    private int getOverlappingDays(int firstIntervalStart, int firstIntervalEnd, int secondIntervalStart, int secondIntervalEnd) {\\n        if ( firstIntervalStart > secondIntervalEnd || secondIntervalStart > firstIntervalEnd) {\\n            return 0;\\n        } else {\\n            int latestStart = Math.max(firstIntervalStart, secondIntervalStart);\\n            int earliestEnd = Math.min(firstIntervalEnd, secondIntervalEnd);\\n\\n            return earliestEnd - latestStart + 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879453,
                "title": "java-10ms-beats-5-49",
                "content": "# Intuition & Approach\\n- Use Java\\'s built-in Date functions because they\\'re efficient and error-free\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.time.LocalDate;\\nimport java.time.ZoneId;\\nimport java.time.temporal.ChronoUnit;\\nimport java.util.Date;\\n\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n\\n        // strategy: find difference between later arrive and earlier leave.\\n        // negative values mean no overlap.\\n\\n        // find difference between later arrive and and earlier leave\\n        int arriveComparison = arriveAlice.compareTo(arriveBob);\\n        Date laterArrive = null;\\n        if (arriveComparison < 0) {\\n            laterArrive = convertMonthDayToDate(arriveBob);\\n        } else {\\n            laterArrive = convertMonthDayToDate(arriveAlice);\\n        }\\n\\n        int leaveComparison = leaveAlice.compareTo(leaveBob);\\n        Date earlierLeave = null;\\n        if (leaveComparison < 0) {\\n            earlierLeave = convertMonthDayToDate(leaveAlice);\\n        } else {\\n            earlierLeave = convertMonthDayToDate(leaveBob);\\n        }\\n\\n        int overlap = daysOverlap(laterArrive, earlierLeave);\\n        return overlap < 0 ? 0 : overlap;\\n    }\\n\\n    private Date convertMonthDayToDate(String s) {\\n        int year = 2023;  // we need a year without a leap day\\n        int month = (s.charAt(0) - \\'0\\') * 10 + s.charAt(1) - \\'0\\';\\n        int day = (s.charAt(3) - \\'0\\') * 10 + s.charAt(4) - \\'0\\';\\n        LocalDate localDate = LocalDate.of(year, month, day);\\n        return Date.from(localDate.atStartOfDay(ZoneId.systemDefault()).toInstant());\\n    }\\n\\n    private int daysOverlap(Date date1, Date date2) {\\n        LocalDate localDate1 = date1.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();\\n        LocalDate localDate2 = date2.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();\\n        return (int)ChronoUnit.DAYS.between(localDate1, localDate2) + 1;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.time.LocalDate;\\nimport java.time.ZoneId;\\nimport java.time.temporal.ChronoUnit;\\nimport java.util.Date;\\n\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n\\n        // strategy: find difference between later arrive and earlier leave.\\n        // negative values mean no overlap.\\n\\n        // find difference between later arrive and and earlier leave\\n        int arriveComparison = arriveAlice.compareTo(arriveBob);\\n        Date laterArrive = null;\\n        if (arriveComparison < 0) {\\n            laterArrive = convertMonthDayToDate(arriveBob);\\n        } else {\\n            laterArrive = convertMonthDayToDate(arriveAlice);\\n        }\\n\\n        int leaveComparison = leaveAlice.compareTo(leaveBob);\\n        Date earlierLeave = null;\\n        if (leaveComparison < 0) {\\n            earlierLeave = convertMonthDayToDate(leaveAlice);\\n        } else {\\n            earlierLeave = convertMonthDayToDate(leaveBob);\\n        }\\n\\n        int overlap = daysOverlap(laterArrive, earlierLeave);\\n        return overlap < 0 ? 0 : overlap;\\n    }\\n\\n    private Date convertMonthDayToDate(String s) {\\n        int year = 2023;  // we need a year without a leap day\\n        int month = (s.charAt(0) - \\'0\\') * 10 + s.charAt(1) - \\'0\\';\\n        int day = (s.charAt(3) - \\'0\\') * 10 + s.charAt(4) - \\'0\\';\\n        LocalDate localDate = LocalDate.of(year, month, day);\\n        return Date.from(localDate.atStartOfDay(ZoneId.systemDefault()).toInstant());\\n    }\\n\\n    private int daysOverlap(Date date1, Date date2) {\\n        LocalDate localDate1 = date1.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();\\n        LocalDate localDate2 = date2.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();\\n        return (int)ChronoUnit.DAYS.between(localDate1, localDate2) + 1;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867827,
                "title": "js-six-possibilities",
                "content": "# Intuition\\nBuild and array with days in, days out and compare possibilities\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} arriveAlice\\n * @param {string} leaveAlice\\n * @param {string} arriveBob\\n * @param {string} leaveBob\\n * @return {number}\\n */\\nvar countDaysTogether = function(arriveAlice, leaveAlice, arriveBob, leaveBob) {\\nlet yrdd = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\nvar days = []\\ndays.push(dds(arriveAlice))\\ndays.push(dds(leaveAlice))\\ndays.push(dds(arriveBob))\\ndays.push(dds(leaveBob))\\n\\n// 1. Alices arrives when Bob has left\\n    if(days[3]<days[0]){\\n        return 0\\n    }\\n\\n// 2. Bob arrives when Alice has left\\n    if(days[1]<days[2]){\\n        return 0\\n    }\\n\\n// 3. Alice arrives after Bob and leaves after Bob\\n    if(days[2]<=days[0] && days[3]<=days[1]){\\n        return days[3]-days[0]+1\\n    }\\n\\n// 4. Alice arrives after Bob and leaves before Bob\\n    if(days[2]<=days[0] && days[1]<=days[3]){\\n        return days[1]-days[0]+1\\n    }\\n\\n// 5. Alice arrives before Bob and leaves after Bob\\n    if(days[0]<=days[2] && days[3]<=days[1]){\\n        return days[3]-days[2]+1\\n    }\\n\\n// 6. Alice arrives before bob and leaves before Bob\\n    if(days[0]<=days[2] && days[1]<=days[3]){\\n        return days[1]-days[2]+1\\n    }\\n\\nfunction dds(str){\\n    var arr = str.split(\\'-\\')\\n    var m = Number(arr[0])\\n    var d = Number(arr[1])\\n    var dd = d\\n    for(var i = 0; i<m-1; i++){\\n        dd += yrdd[i]\\n    }\\n    return dd;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} arriveAlice\\n * @param {string} leaveAlice\\n * @param {string} arriveBob\\n * @param {string} leaveBob\\n * @return {number}\\n */\\nvar countDaysTogether = function(arriveAlice, leaveAlice, arriveBob, leaveBob) {\\nlet yrdd = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\nvar days = []\\ndays.push(dds(arriveAlice))\\ndays.push(dds(leaveAlice))\\ndays.push(dds(arriveBob))\\ndays.push(dds(leaveBob))\\n\\n// 1. Alices arrives when Bob has left\\n    if(days[3]<days[0]){\\n        return 0\\n    }\\n\\n// 2. Bob arrives when Alice has left\\n    if(days[1]<days[2]){\\n        return 0\\n    }\\n\\n// 3. Alice arrives after Bob and leaves after Bob\\n    if(days[2]<=days[0] && days[3]<=days[1]){\\n        return days[3]-days[0]+1\\n    }\\n\\n// 4. Alice arrives after Bob and leaves before Bob\\n    if(days[2]<=days[0] && days[1]<=days[3]){\\n        return days[1]-days[0]+1\\n    }\\n\\n// 5. Alice arrives before Bob and leaves after Bob\\n    if(days[0]<=days[2] && days[3]<=days[1]){\\n        return days[3]-days[2]+1\\n    }\\n\\n// 6. Alice arrives before bob and leaves before Bob\\n    if(days[0]<=days[2] && days[1]<=days[3]){\\n        return days[1]-days[2]+1\\n    }\\n\\nfunction dds(str){\\n    var arr = str.split(\\'-\\')\\n    var m = Number(arr[0])\\n    var d = Number(arr[1])\\n    var dd = d\\n    for(var i = 0; i<m-1; i++){\\n        dd += yrdd[i]\\n    }\\n    return dd;\\n}\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3856758,
                "title": "python-simple-solution-string-math",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def countDaysTogether(self, arAl: str, lAl: str, arBo: str, lBo: str) -> int:\\n    months = [-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n    start = max(arAl, arBo)\\n    end = min(lAl, lBo)\\n\\n    startDay = int(start[3:])\\n    startMonth = int(start[:2])\\n    endDay = int(end[3:])\\n    endMonth = int(end[:2])\\n\\n    if start > end:\\n      return 0\\n    if startMonth == endMonth:\\n      return endDay - startDay + 1\\n    elif startMonth < endMonth:\\n      return months[startMonth] - startDay + endDay + 1 + sum(months[m] for m in range(startMonth + 1, endMonth))\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n  def countDaysTogether(self, arAl: str, lAl: str, arBo: str, lBo: str) -> int:\\n    months = [-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n    start = max(arAl, arBo)\\n    end = min(lAl, lBo)\\n\\n    startDay = int(start[3:])\\n    startMonth = int(start[:2])\\n    endDay = int(end[3:])\\n    endMonth = int(end[:2])\\n\\n    if start > end:\\n      return 0\\n    if startMonth == endMonth:\\n      return endDay - startDay + 1\\n    elif startMonth < endMonth:\\n      return months[startMonth] - startDay + endDay + 1 + sum(months[m] for m in range(startMonth + 1, endMonth))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844736,
                "title": "beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    private static final int[] daysInMonth = new int[] {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    private static final int[] daysBefore = new int[12];\\n\\n\\n    static {\\n        int totalDaysBefore = 0;\\n        int i = 0;\\n        for (int days: daysInMonth) {\\n            daysBefore[i++] = totalDaysBefore; \\n            totalDaysBefore += days;\\n        }\\n    }\\n\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int days = Math.min(toDayNumber(leaveAlice), toDayNumber(leaveBob)) - Math.max(toDayNumber(arriveAlice), toDayNumber(arriveBob));\\n        return days >= 0 ? days + 1 : 0;\\n    }\\n\\n    private int toDayNumber(String mmdd) {\\n        int month = toInt(mmdd.charAt(0)) * 10 + toInt(mmdd.charAt(1));\\n        int day = toInt(mmdd.charAt(3)) * 10 + toInt(mmdd.charAt(4));\\n        return daysBefore[month - 1] + day;\\n    }\\n\\n\\n    private int toInt(char c) {\\n        return c - \\'0\\';\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    private static final int[] daysInMonth = new int[] {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    private static final int[] daysBefore = new int[12];\\n\\n\\n    static {\\n        int totalDaysBefore = 0;\\n        int i = 0;\\n        for (int days: daysInMonth) {\\n            daysBefore[i++] = totalDaysBefore; \\n            totalDaysBefore += days;\\n        }\\n    }\\n\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int days = Math.min(toDayNumber(leaveAlice), toDayNumber(leaveBob)) - Math.max(toDayNumber(arriveAlice), toDayNumber(arriveBob));\\n        return days >= 0 ? days + 1 : 0;\\n    }\\n\\n    private int toDayNumber(String mmdd) {\\n        int month = toInt(mmdd.charAt(0)) * 10 + toInt(mmdd.charAt(1));\\n        int day = toInt(mmdd.charAt(3)) * 10 + toInt(mmdd.charAt(4));\\n        return daysBefore[month - 1] + day;\\n    }\\n\\n\\n    private int toInt(char c) {\\n        return c - \\'0\\';\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844734,
                "title": "beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    private static final int[] daysInMonth = new int[] {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    private static final int[] daysBefore = new int[12];\\n\\n\\n    static {\\n        int totalDaysBefore = 0;\\n        int i = 0;\\n        for (int days: daysInMonth) {\\n            daysBefore[i++] = totalDaysBefore; \\n            totalDaysBefore += days;\\n        }\\n    }\\n\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int days = Math.min(toDayNumber(leaveAlice), toDayNumber(leaveBob)) - Math.max(toDayNumber(arriveAlice), toDayNumber(arriveBob));\\n        return days >= 0 ? days + 1 : 0;\\n    }\\n\\n    private int toDayNumber(String mmdd) {\\n        int month = toInt(mmdd.charAt(0)) * 10 + toInt(mmdd.charAt(1));\\n        int day = toInt(mmdd.charAt(3)) * 10 + toInt(mmdd.charAt(4));\\n        return daysBefore[month - 1] + day;\\n    }\\n\\n\\n    private int toInt(char c) {\\n        return c - \\'0\\';\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    private static final int[] daysInMonth = new int[] {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    private static final int[] daysBefore = new int[12];\\n\\n\\n    static {\\n        int totalDaysBefore = 0;\\n        int i = 0;\\n        for (int days: daysInMonth) {\\n            daysBefore[i++] = totalDaysBefore; \\n            totalDaysBefore += days;\\n        }\\n    }\\n\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int days = Math.min(toDayNumber(leaveAlice), toDayNumber(leaveBob)) - Math.max(toDayNumber(arriveAlice), toDayNumber(arriveBob));\\n        return days >= 0 ? days + 1 : 0;\\n    }\\n\\n    private int toDayNumber(String mmdd) {\\n        int month = toInt(mmdd.charAt(0)) * 10 + toInt(mmdd.charAt(1));\\n        int day = toInt(mmdd.charAt(3)) * 10 + toInt(mmdd.charAt(4));\\n        return daysBefore[month - 1] + day;\\n    }\\n\\n\\n    private int toInt(char c) {\\n        return c - \\'0\\';\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825853,
                "title": "average-solution-day-of-year",
                "content": "# Intuition\\n\\nParse date to date of year and then do check interception of two intervals. \\n\\n# Approach\\n\\nDefine an array with day of year at the begining of month. When parse - search by month, add day. \\n\\n\\n# Code\\n```\\nimport java.time.LocalDate;\\n\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n  \\n        final var months = new int[]{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n\\n        final var aliceStart = parse(arriveAlice, months);\\n        final var aliceEnd = parse(leaveAlice, months);\\n\\n        final var bobStart = parse(arriveBob, months);\\n        final var bobEnd = parse(leaveBob, months);\\n\\n        if(aliceEnd < bobStart || bobEnd < aliceStart){\\n            return 0;\\n        }\\n\\n        if(aliceStart < bobStart){ // allice arived before bob\\n            if(aliceEnd < bobEnd){ // alice left before bob\\n                return aliceEnd - bobStart + 1;\\n            }else { // bob left before alice\\n                return bobEnd - bobStart  + 1;\\n            }\\n        }else{ // bob arived before alice\\n            if(bobEnd < aliceEnd){ // bob left before left\\n                return bobEnd - aliceStart  + 1; \\n            }else { // alice left before bob\\n                return aliceEnd - aliceStart  + 1;\\n            }\\n        }\\n    }\\n\\n    private int parse(final String date, final int[] monthsDay){\\n        final var s = date.split(\"-\");\\n        final int month = Integer.parseInt(s[0]) - 1;\\n        final int day = Integer.parseInt(s[1]);\\n\\n        return monthsDay[month] + day;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.time.LocalDate;\\n\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n  \\n        final var months = new int[]{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n\\n        final var aliceStart = parse(arriveAlice, months);\\n        final var aliceEnd = parse(leaveAlice, months);\\n\\n        final var bobStart = parse(arriveBob, months);\\n        final var bobEnd = parse(leaveBob, months);\\n\\n        if(aliceEnd < bobStart || bobEnd < aliceStart){\\n            return 0;\\n        }\\n\\n        if(aliceStart < bobStart){ // allice arived before bob\\n            if(aliceEnd < bobEnd){ // alice left before bob\\n                return aliceEnd - bobStart + 1;\\n            }else { // bob left before alice\\n                return bobEnd - bobStart  + 1;\\n            }\\n        }else{ // bob arived before alice\\n            if(bobEnd < aliceEnd){ // bob left before left\\n                return bobEnd - aliceStart  + 1; \\n            }else { // alice left before bob\\n                return aliceEnd - aliceStart  + 1;\\n            }\\n        }\\n    }\\n\\n    private int parse(final String date, final int[] monthsDay){\\n        final var s = date.split(\"-\");\\n        final int month = Integer.parseInt(s[0]) - 1;\\n        final int day = Integer.parseInt(s[1]);\\n\\n        return monthsDay[month] + day;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821118,
                "title": "58ms-optimized",
                "content": "\\n# Code\\n```\\ntype DateInput = {\\n    month: number;\\n    day: number;\\n}\\n\\nfunction countDaysTogether(arriveAlice: string, leaveAlice: string, arriveBob: string, leaveBob: string): number {\\n    let aliceData = {\\n        arriveDate: inputDate(arriveAlice), // {month, day}\\n        leaveDate: inputDate(leaveAlice),\\n        arriveAbsoluteDay: 0,\\n        leaveAbsoluteDay: 0,\\n    }\\n\\n    let bobData = {\\n        arriveDate: inputDate(arriveBob),\\n        leaveDate: inputDate(leaveBob),\\n        arriveAbsoluteDay: 0,\\n        leaveAbsoluteDay: 0\\n    }\\n\\n    aliceData.arriveAbsoluteDay = absoluteDay({...aliceData.arriveDate})\\n    aliceData.leaveAbsoluteDay = absoluteDay({...aliceData.leaveDate})\\n\\n    bobData.arriveAbsoluteDay = absoluteDay({...bobData.arriveDate})\\n    bobData.leaveAbsoluteDay = absoluteDay({...bobData.leaveDate})\\n\\n   return Math.max(0, Math.min(aliceData.leaveAbsoluteDay, bobData.leaveAbsoluteDay) - Math.max(aliceData.arriveAbsoluteDay, bobData.arriveAbsoluteDay) + 1);\\n};\\n\\n\\n// helpers\\n\\nconst inputDate = (date: string): DateInput => {\\n        // format: MM-DD\\n        const chunks = date.split(\\'-\\');\\n        let month: number = Number(chunks[0])\\n        let day: number = Number(chunks[1]);\\n        return {month, day}\\n    }\\n\\nconst absoluteDay = ({month, day}): number => {\\n    const daysInEachMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n    let result = 0;\\n    for (let m = 1; m < month; m++) {\\n        result += daysInEachMonth[m - 1];\\n    }\\n    result += day;\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype DateInput = {\\n    month: number;\\n    day: number;\\n}\\n\\nfunction countDaysTogether(arriveAlice: string, leaveAlice: string, arriveBob: string, leaveBob: string): number {\\n    let aliceData = {\\n        arriveDate: inputDate(arriveAlice), // {month, day}\\n        leaveDate: inputDate(leaveAlice),\\n        arriveAbsoluteDay: 0,\\n        leaveAbsoluteDay: 0,\\n    }\\n\\n    let bobData = {\\n        arriveDate: inputDate(arriveBob),\\n        leaveDate: inputDate(leaveBob),\\n        arriveAbsoluteDay: 0,\\n        leaveAbsoluteDay: 0\\n    }\\n\\n    aliceData.arriveAbsoluteDay = absoluteDay({...aliceData.arriveDate})\\n    aliceData.leaveAbsoluteDay = absoluteDay({...aliceData.leaveDate})\\n\\n    bobData.arriveAbsoluteDay = absoluteDay({...bobData.arriveDate})\\n    bobData.leaveAbsoluteDay = absoluteDay({...bobData.leaveDate})\\n\\n   return Math.max(0, Math.min(aliceData.leaveAbsoluteDay, bobData.leaveAbsoluteDay) - Math.max(aliceData.arriveAbsoluteDay, bobData.arriveAbsoluteDay) + 1);\\n};\\n\\n\\n// helpers\\n\\nconst inputDate = (date: string): DateInput => {\\n        // format: MM-DD\\n        const chunks = date.split(\\'-\\');\\n        let month: number = Number(chunks[0])\\n        let day: number = Number(chunks[1]);\\n        return {month, day}\\n    }\\n\\nconst absoluteDay = ({month, day}): number => {\\n    const daysInEachMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n    let result = 0;\\n    for (let m = 1; m < month; m++) {\\n        result += daysInEachMonth[m - 1];\\n    }\\n    result += day;\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3817916,
                "title": "problem-days-spent-together",
                "content": "# Intuition\\nJust compute the days without using any date functions.\\n\\n# Approach\\nGet the start and end date where they are together then compute the distance.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype DateInput = {\\n    month: number;\\n    date: number;\\n}\\n\\nconst daysMap = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n\\nfunction createDateInput(value: string): DateInput {\\n    const chunks = value.split(\\'-\\');\\n    return {\\n        month: parseInt(chunks[0]),\\n        date: parseInt(chunks[1]),\\n    };\\n}\\n\\nfunction compare(input1: DateInput, input2: DateInput): number {\\n    if (input1.month === input2.month) {\\n        if (input1.date > input2.date) {\\n            return 1;\\n        } else if (input1.date < input2.date) {\\n            return -1;\\n        } else {\\n            return 0;\\n        }\\n    } else {\\n        if (input1.month > input2.month) {\\n            return 1;\\n        } else if (input1.month < input2.month) {\\n            return -1;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n\\nfunction computeDiff(input1: DateInput, input2: DateInput): number {\\n    if (input1.month === input2.month) {\\n        // Same month, just diff the date and pad 1 day\\n        return input2.date - input1.date;\\n    } else {\\n        // Different month, compute distance\\n        let runningMonth = input1.month;\\n        let daysInMonth = daysMap[runningMonth - 1];\\n        let days = daysInMonth - input1.date;\\n\\n        while (runningMonth < input2.month) {\\n            runningMonth++;\\n            daysInMonth = daysMap[runningMonth - 1];\\n            if (runningMonth === input2.month) {\\n                days += input2.date;\\n            } else {\\n                days += daysInMonth;\\n            }\\n        }\\n        \\n        return days;\\n    }\\n}\\n\\nfunction countDaysTogether(arriveAlice: string, leaveAlice: string, arriveBob: string, leaveBob: string): number {\\n    const arriveAliceInput = createDateInput(arriveAlice);\\n    const leaveAliceInput = createDateInput(leaveAlice);\\n    const arriveBobInput = createDateInput(arriveBob);\\n    const leaveBobInput = createDateInput(leaveBob);\\n\\n    let together = 0;\\n    let start: DateInput;\\n    let end: DateInput;\\n\\n    // Find earliest arrival and earliest leave\\n    const earliestDiff = compare(arriveAliceInput, arriveBobInput);\\n    const earliestLeaveDiff = compare(leaveAliceInput, leaveBobInput);\\n\\n    if (earliestDiff === 0 || earliestDiff === -1) {\\n        // Alice was earlier or they arrived at the same date\\n        // Let\\'s find out if they met by finding out if bob arrived earlier than alice left\\n        const intersect = compare(leaveAliceInput, arriveBobInput);\\n        if (intersect === 1 || intersect === 0) {\\n            // They met somehow, so let\\'s start by the date where bob arrived\\n            start = arriveBobInput;\\n\\n            // When does it ends? Depends on who left earlier\\n            if (earliestLeaveDiff === 0 || earliestLeaveDiff === -1) {\\n                // Alice left early or they left at the same time\\n                // Let\\'s assumethe end date be when alice left\\n                end = leaveAliceInput;\\n            } else {\\n                // Bob left early so the end date must be when bob left\\n                end = leaveBobInput;\\n            }\\n        }\\n    } else {\\n        // Bob was earlier\\n        // Let\\'s find out if they met by finding out if alice arrived earlier than bob left\\n        const intersect = compare(leaveBobInput, arriveAliceInput);\\n        if (intersect === 1 || intersect === 0) {\\n            // The met somehow, so let\\'s start the date where alice arrived\\n            start = arriveAliceInput;\\n\\n            // When does it ends? Depends on who left earlier\\n            if (earliestLeaveDiff === 0 || earliestLeaveDiff === -1) {\\n                // Alice left early or they left at the same time\\n                // Let\\'s assume the end date be when alice left\\n                end = leaveAliceInput;\\n            } else {\\n                // Bob left early so the end date must be when bob left\\n                end = leaveBobInput;\\n            }\\n        }\\n    }\\n    \\n    if (start && end) {\\n        const diff = compare(start, end);\\n        if (diff === -1) {\\n            // Let\\'s compute the days they are together...\\n            together = computeDiff(start, end) + 1;\\n        } else if (diff === 0) {\\n            // They met on that same day\\n            together = 1;\\n        }\\n    }\\n\\n    return together;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype DateInput = {\\n    month: number;\\n    date: number;\\n}\\n\\nconst daysMap = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n\\nfunction createDateInput(value: string): DateInput {\\n    const chunks = value.split(\\'-\\');\\n    return {\\n        month: parseInt(chunks[0]),\\n        date: parseInt(chunks[1]),\\n    };\\n}\\n\\nfunction compare(input1: DateInput, input2: DateInput): number {\\n    if (input1.month === input2.month) {\\n        if (input1.date > input2.date) {\\n            return 1;\\n        } else if (input1.date < input2.date) {\\n            return -1;\\n        } else {\\n            return 0;\\n        }\\n    } else {\\n        if (input1.month > input2.month) {\\n            return 1;\\n        } else if (input1.month < input2.month) {\\n            return -1;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n\\nfunction computeDiff(input1: DateInput, input2: DateInput): number {\\n    if (input1.month === input2.month) {\\n        // Same month, just diff the date and pad 1 day\\n        return input2.date - input1.date;\\n    } else {\\n        // Different month, compute distance\\n        let runningMonth = input1.month;\\n        let daysInMonth = daysMap[runningMonth - 1];\\n        let days = daysInMonth - input1.date;\\n\\n        while (runningMonth < input2.month) {\\n            runningMonth++;\\n            daysInMonth = daysMap[runningMonth - 1];\\n            if (runningMonth === input2.month) {\\n                days += input2.date;\\n            } else {\\n                days += daysInMonth;\\n            }\\n        }\\n        \\n        return days;\\n    }\\n}\\n\\nfunction countDaysTogether(arriveAlice: string, leaveAlice: string, arriveBob: string, leaveBob: string): number {\\n    const arriveAliceInput = createDateInput(arriveAlice);\\n    const leaveAliceInput = createDateInput(leaveAlice);\\n    const arriveBobInput = createDateInput(arriveBob);\\n    const leaveBobInput = createDateInput(leaveBob);\\n\\n    let together = 0;\\n    let start: DateInput;\\n    let end: DateInput;\\n\\n    // Find earliest arrival and earliest leave\\n    const earliestDiff = compare(arriveAliceInput, arriveBobInput);\\n    const earliestLeaveDiff = compare(leaveAliceInput, leaveBobInput);\\n\\n    if (earliestDiff === 0 || earliestDiff === -1) {\\n        // Alice was earlier or they arrived at the same date\\n        // Let\\'s find out if they met by finding out if bob arrived earlier than alice left\\n        const intersect = compare(leaveAliceInput, arriveBobInput);\\n        if (intersect === 1 || intersect === 0) {\\n            // They met somehow, so let\\'s start by the date where bob arrived\\n            start = arriveBobInput;\\n\\n            // When does it ends? Depends on who left earlier\\n            if (earliestLeaveDiff === 0 || earliestLeaveDiff === -1) {\\n                // Alice left early or they left at the same time\\n                // Let\\'s assumethe end date be when alice left\\n                end = leaveAliceInput;\\n            } else {\\n                // Bob left early so the end date must be when bob left\\n                end = leaveBobInput;\\n            }\\n        }\\n    } else {\\n        // Bob was earlier\\n        // Let\\'s find out if they met by finding out if alice arrived earlier than bob left\\n        const intersect = compare(leaveBobInput, arriveAliceInput);\\n        if (intersect === 1 || intersect === 0) {\\n            // The met somehow, so let\\'s start the date where alice arrived\\n            start = arriveAliceInput;\\n\\n            // When does it ends? Depends on who left earlier\\n            if (earliestLeaveDiff === 0 || earliestLeaveDiff === -1) {\\n                // Alice left early or they left at the same time\\n                // Let\\'s assume the end date be when alice left\\n                end = leaveAliceInput;\\n            } else {\\n                // Bob left early so the end date must be when bob left\\n                end = leaveBobInput;\\n            }\\n        }\\n    }\\n    \\n    if (start && end) {\\n        const diff = compare(start, end);\\n        if (diff === -1) {\\n            // Let\\'s compute the days they are together...\\n            together = computeDiff(start, end) + 1;\\n        } else if (diff === 0) {\\n            // They met on that same day\\n            together = 1;\\n        }\\n    }\\n\\n    return together;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3804342,
                "title": "100-beat-best-code-shortest",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int dn(string s){\\n        vector<int>v{0,31,59,90,120,151,181,212,243,273,304,334,365};\\n        int m = stoi(s.substr(0,2)) , d = stoi(s.substr(3,2)) , ans=0;\\n        return ans+v[m-1]+d;\\n    }\\n\\n    int countDaysTogether(string aa , string la , string ab , string lb){\\n        int a = dn(aa) , b = dn(la) , c = dn(ab) , d = dn(lb);\\n        vector<int>v(366,0);\\n        for(int i=a; i<=b; i++){\\n            v[i]++;\\n        }\\n        for(int i=c; i<=d; i++){\\n            v[i]++;\\n        }\\n        int co=0;\\n        for(auto i:v){\\n            if(i==2){\\n                co++;\\n            }\\n        }\\n        return co;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dn(string s){\\n        vector<int>v{0,31,59,90,120,151,181,212,243,273,304,334,365};\\n        int m = stoi(s.substr(0,2)) , d = stoi(s.substr(3,2)) , ans=0;\\n        return ans+v[m-1]+d;\\n    }\\n\\n    int countDaysTogether(string aa , string la , string ab , string lb){\\n        int a = dn(aa) , b = dn(la) , c = dn(ab) , d = dn(lb);\\n        vector<int>v(366,0);\\n        for(int i=a; i<=b; i++){\\n            v[i]++;\\n        }\\n        for(int i=c; i<=d; i++){\\n            v[i]++;\\n        }\\n        int co=0;\\n        for(auto i:v){\\n            if(i==2){\\n                co++;\\n            }\\n        }\\n        return co;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791124,
                "title": "simple-solution-using-java",
                "content": "# Intuition\\nCheck if there is any overlapping between late arrival and early leave.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    int months[]=new int[]{0,31,59,90,120,151,181,212,243,273,304,334};\\n    private int getDays(String s){\\n        int month = s.charAt(1)-\\'0\\';\\n        if(s.charAt(0) == \\'1\\'){\\n            month += 10;\\n        }\\n        int days = (s.charAt(3)-\\'0\\') * 10 + s.charAt(4)-\\'0\\';\\n        return months[month-1] + days;\\n    }\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n      int arrive1 = getDays(arriveAlice);\\n      int leave1 = getDays(leaveAlice);\\n      int arrive2 = getDays(arriveBob);\\n      int leave2 = getDays(leaveBob);\\n\\n      int lateArrive = Math.max(arrive1,arrive2);\\n      int earlyLeave = Math.min(leave1,leave2);\\n      if(lateArrive > earlyLeave){\\n          return 0;\\n      }\\n      return earlyLeave - lateArrive + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int months[]=new int[]{0,31,59,90,120,151,181,212,243,273,304,334};\\n    private int getDays(String s){\\n        int month = s.charAt(1)-\\'0\\';\\n        if(s.charAt(0) == \\'1\\'){\\n            month += 10;\\n        }\\n        int days = (s.charAt(3)-\\'0\\') * 10 + s.charAt(4)-\\'0\\';\\n        return months[month-1] + days;\\n    }\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n      int arrive1 = getDays(arriveAlice);\\n      int leave1 = getDays(leaveAlice);\\n      int arrive2 = getDays(arriveBob);\\n      int leave2 = getDays(leaveBob);\\n\\n      int lateArrive = Math.max(arrive1,arrive2);\\n      int earlyLeave = Math.min(leave1,leave2);\\n      if(lateArrive > earlyLeave){\\n          return 0;\\n      }\\n      return earlyLeave - lateArrive + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753544,
                "title": "java-simple-interval-overlap",
                "content": "**Idea:** Find the 4 day indices and find overlap between the 2 pairs\\n>**T/S:** O(1)/O(1)\\n```\\nprivate static final int[] MONTH_DAYS = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\npublic int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n\\treturn Math.max(0, 1 + Math.min(dayIndex(leaveAlice), dayIndex(leaveBob)) - \\n\\t\\t\\t\\t\\t\\t   Math.max(dayIndex(arriveAlice), dayIndex(arriveBob)));\\n}\\n\\nprivate int dayIndex(String date) {\\n\\tvar index = Integer.parseInt(date.substring(3, 5));\\n\\tfor (var i = Integer.parseInt(date.substring(0, 2)) - 1; i > 0; i--)\\n\\t\\tindex += MONTH_DAYS[i];\\n\\treturn index;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprivate static final int[] MONTH_DAYS = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\npublic int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n\\treturn Math.max(0, 1 + Math.min(dayIndex(leaveAlice), dayIndex(leaveBob)) - \\n\\t\\t\\t\\t\\t\\t   Math.max(dayIndex(arriveAlice), dayIndex(arriveBob)));\\n}\\n\\nprivate int dayIndex(String date) {\\n\\tvar index = Integer.parseInt(date.substring(3, 5));\\n\\tfor (var i = Integer.parseInt(date.substring(0, 2)) - 1; i > 0; i--)\\n\\t\\tindex += MONTH_DAYS[i];\\n\\treturn index;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3748537,
                "title": "beats-100-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int countDays(string s){\\n        int month[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int m = stoi(s.substr(0,2)), ans = 0, d = stoi(s.substr(3,2));\\n        for(int i = 1; i < m; i++){\\n            ans += month[i-1];\\n        }\\n        return ans + d;\\n    }\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int aA = countDays(arriveAlice), lA = countDays(leaveAlice), aB = countDays(arriveBob), lB = countDays(leaveBob);\\n        int ans = min(lA, lB) - max(aA, aB) + 1;\\n        return ans > 0 ? ans : 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int countDays(string s){\\n        int month[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int m = stoi(s.substr(0,2)), ans = 0, d = stoi(s.substr(3,2));\\n        for(int i = 1; i < m; i++){\\n            ans += month[i-1];\\n        }\\n        return ans + d;\\n    }\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int aA = countDays(arriveAlice), lA = countDays(leaveAlice), aB = countDays(arriveBob), lB = countDays(leaveBob);\\n        int ans = min(lA, lB) - max(aA, aB) + 1;\\n        return ans > 0 ? ans : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719597,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} arriveAlice\\n * @param {string} leaveAlice\\n * @param {string} arriveBob\\n * @param {string} leaveBob\\n * @return {number}\\n */\\nvar countDaysTogether = function(arriveAlice, leaveAlice, arriveBob, leaveBob) {\\n    const arrivalDate = Math.max(Date.parse(arriveAlice), Date.parse(arriveBob));\\n    const leaveDate = Math.min(Date.parse(leaveAlice), Date.parse(leaveBob));\\n    const dayInMS = 1000*60*60*24;\\n    return arrivalDate > leaveDate ? 0 : ((leaveDate - arrivalDate)/dayInMS) + 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} arriveAlice\\n * @param {string} leaveAlice\\n * @param {string} arriveBob\\n * @param {string} leaveBob\\n * @return {number}\\n */\\nvar countDaysTogether = function(arriveAlice, leaveAlice, arriveBob, leaveBob) {\\n    const arrivalDate = Math.max(Date.parse(arriveAlice), Date.parse(arriveBob));\\n    const leaveDate = Math.min(Date.parse(leaveAlice), Date.parse(leaveBob));\\n    const dayInMS = 1000*60*60*24;\\n    return arrivalDate > leaveDate ? 0 : ((leaveDate - arrivalDate)/dayInMS) + 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3694255,
                "title": "easy-solution-with-for-loop",
                "content": "# Intuition\\nYou can find counter of days that belong to each segment: Alice-segment and Bob-segment\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction countDaysTogether(arriveAlice: string, leaveAlice: string, arriveBob: string, leaveBob: string): number {\\n    let alice1 = (new Date(\"2022-\" + arriveAlice)).getTime();\\n    let alice2 = (new Date(\"2022-\" + leaveAlice)).getTime();\\n    let bob1 = (new Date(\"2022-\" + arriveBob)).getTime();\\n    let bob2 = (new Date(\"2022-\" + leaveBob)).getTime();\\n    let min = Math.min(alice1, alice2, bob1, bob2);\\n    let max = Math.max(alice1, alice2, bob1, bob2);\\n    let counter: number = 0;\\n    for(let i = min; i <= max; i = i + 86400000){\\n        if(i >= alice1 && i <= alice2 && i >= bob1 && i <= bob2)    counter++;\\n    };\\n    return counter;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction countDaysTogether(arriveAlice: string, leaveAlice: string, arriveBob: string, leaveBob: string): number {\\n    let alice1 = (new Date(\"2022-\" + arriveAlice)).getTime();\\n    let alice2 = (new Date(\"2022-\" + leaveAlice)).getTime();\\n    let bob1 = (new Date(\"2022-\" + arriveBob)).getTime();\\n    let bob2 = (new Date(\"2022-\" + leaveBob)).getTime();\\n    let min = Math.min(alice1, alice2, bob1, bob2);\\n    let max = Math.max(alice1, alice2, bob1, bob2);\\n    let counter: number = 0;\\n    for(let i = min; i <= max; i = i + 86400000){\\n        if(i >= alice1 && i <= alice2 && i >= bob1 && i <= bob2)    counter++;\\n    };\\n    return counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3694194,
                "title": "simple-c-code-using-string-basics",
                "content": "# Intuition\\nConvert all your dates to days of the year as all dates are of the same year.Use stoi for string to integer conversion.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nComapre the arrival time fo both and departure times of both to conclude what all days they spent together or if they didn\\'t then return 0.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int a1=stoi(arriveAlice.substr(0,2));\\n        int a2=stoi(arriveAlice.substr(3,5));\\n        int b1=stoi(arriveBob.substr(0,2));\\n        int b2=stoi(arriveBob.substr(3,5));\\n        int a3=stoi(leaveAlice.substr(0,2));\\n        int a4=stoi(leaveAlice.substr(3,5));\\n        int b3=stoi(leaveBob.substr(0,2));\\n        int b4=stoi(leaveBob.substr(3,5));\\n        int t1=countdays(a1,a2);\\n        int t2=countdays(b1,b2);\\n        int t3=countdays(a3,a4);\\n        int t4=countdays(b3,b4);\\n        if(t2>=t1 && t2<=t3)\\n        {\\n            cout<<t1<<endl<<t2<<endl<<t3<<endl<<t4;\\n            if(t4<t3)\\n            return t4-t2+1;\\n            return t3-t2+1;\\n        }\\n        else if(t1>=t2 && t1<=t4)\\n        {\\n            cout<<t1<<endl<<t2<<endl<<t3<<endl<<t4;\\n            if(t3<t4)\\n            return t3-t1+1;\\n            return t4-t1+1;\\n        }\\n        return 0;\\n    }\\n    int countdays(int x1,int x2)\\n    {\\n        int days[]={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int s=0;\\n        for(int i=0;i<x1-1;i++)\\n        {\\n            s=s+days[i];\\n        }\\n        return x2+s;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int a1=stoi(arriveAlice.substr(0,2));\\n        int a2=stoi(arriveAlice.substr(3,5));\\n        int b1=stoi(arriveBob.substr(0,2));\\n        int b2=stoi(arriveBob.substr(3,5));\\n        int a3=stoi(leaveAlice.substr(0,2));\\n        int a4=stoi(leaveAlice.substr(3,5));\\n        int b3=stoi(leaveBob.substr(0,2));\\n        int b4=stoi(leaveBob.substr(3,5));\\n        int t1=countdays(a1,a2);\\n        int t2=countdays(b1,b2);\\n        int t3=countdays(a3,a4);\\n        int t4=countdays(b3,b4);\\n        if(t2>=t1 && t2<=t3)\\n        {\\n            cout<<t1<<endl<<t2<<endl<<t3<<endl<<t4;\\n            if(t4<t3)\\n            return t4-t2+1;\\n            return t3-t2+1;\\n        }\\n        else if(t1>=t2 && t1<=t4)\\n        {\\n            cout<<t1<<endl<<t2<<endl<<t3<<endl<<t4;\\n            if(t3<t4)\\n            return t3-t1+1;\\n            return t4-t1+1;\\n        }\\n        return 0;\\n    }\\n    int countdays(int x1,int x2)\\n    {\\n        int days[]={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int s=0;\\n        for(int i=0;i<x1-1;i++)\\n        {\\n            s=s+days[i];\\n        }\\n        return x2+s;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3662521,
                "title": "easiet-solution-by-nnn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDaysTogether(String aA, String lA, String aB, String lB) {\\n        int dayOfMonth[] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};\\n        int Ax = dayOfMonth[Integer.parseInt(aA.substring(0, 2)) - 1] + Integer.parseInt(aA.substring(3, 5));\\n        int Ay = dayOfMonth[Integer.parseInt(lA.substring(0, 2)) - 1] + Integer.parseInt(lA.substring(3, 5));\\n        int Bx = dayOfMonth[Integer.parseInt(aB.substring(0, 2)) - 1] + Integer.parseInt(aB.substring(3, 5));\\n        int By = dayOfMonth[Integer.parseInt(lB.substring(0, 2)) - 1] + Integer.parseInt(lB.substring(3, 5));\\n        if (Ax > By || Bx > Ay)\\n            return 0;\\n        if (Ax > Bx && Ay < By)\\n            return Ay - Ax+1;\\n        if (Bx > Ax && By < Ay)\\n            return By - Bx+1;\\n        if (Bx < Ay && By > Ay)\\n            return Ay - Bx+1;\\n        if (Ax < By && Ay > By)\\n            return By - Ax+1;\\n        if(Ax==Bx&&Ay==By)return Ay-Ax+1;\\n        if(Ay==Bx||Ax==By)return 1;\\n        return 0;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDaysTogether(String aA, String lA, String aB, String lB) {\\n        int dayOfMonth[] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};\\n        int Ax = dayOfMonth[Integer.parseInt(aA.substring(0, 2)) - 1] + Integer.parseInt(aA.substring(3, 5));\\n        int Ay = dayOfMonth[Integer.parseInt(lA.substring(0, 2)) - 1] + Integer.parseInt(lA.substring(3, 5));\\n        int Bx = dayOfMonth[Integer.parseInt(aB.substring(0, 2)) - 1] + Integer.parseInt(aB.substring(3, 5));\\n        int By = dayOfMonth[Integer.parseInt(lB.substring(0, 2)) - 1] + Integer.parseInt(lB.substring(3, 5));\\n        if (Ax > By || Bx > Ay)\\n            return 0;\\n        if (Ax > Bx && Ay < By)\\n            return Ay - Ax+1;\\n        if (Bx > Ax && By < Ay)\\n            return By - Bx+1;\\n        if (Bx < Ay && By > Ay)\\n            return Ay - Bx+1;\\n        if (Ax < By && Ay > By)\\n            return By - Ax+1;\\n        if(Ax==Bx&&Ay==By)return Ay-Ax+1;\\n        if(Ay==Bx||Ax==By)return 1;\\n        return 0;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654580,
                "title": "python-find-the-max-of-arrivals-and-min-of-departures",
                "content": "# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n    \\n        def days_count(string):\\n            days = [31,28,31,30,31,30,31,31,30,31,30,31]\\n            month, day = string.split(\"-\")\\n            return sum(days[:int(month)-1]) + int(day)\\n\\n        end_date = days_count(min(leaveAlice, leaveBob))\\n        start_date = days_count(max(arriveAlice, arriveBob))\\n\\n        return int(start_date <= end_date)*( end_date - start_date + 1)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n    \\n        def days_count(string):\\n            days = [31,28,31,30,31,30,31,31,30,31,30,31]\\n            month, day = string.split(\"-\")\\n            return sum(days[:int(month)-1]) + int(day)\\n\\n        end_date = days_count(min(leaveAlice, leaveBob))\\n        start_date = days_count(max(arriveAlice, arriveBob))\\n\\n        return int(start_date <= end_date)*( end_date - start_date + 1)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648050,
                "title": "c-solution-beats-100-59ms-w-explanation-kth-day-of-the-month",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy idea was simply to figure out the difference between the date of whoever arrived second and whoever left first. Of course, I knew there would be a few edge cases, which are commented in the code.\\n\\nPS: Reading into other solutions, mine was needlessly complicated in nature. Instead of using each date as a \"day of the year\", I converted each date into a \"day of the month\". This created a lot of challenges as conversions were now necessary.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI decided to first parse the arrival and leave dates into integer arrays. My knowledge doesn\\'t cover whether a tuplet would be faster, but it was pretty negligible.\\n\\nAfterwards, I first came up with a way to check if they even had days in common before proceeding with that assumption.\\n\\nThen, it was implementing my idea: Find the difference between the dates of whoever arrived second (arrS) and whoever left first (leaveF). The only edge case here was whether arrS and leaveF had the shared the same month, as that would behave incorrectly with how I calculated all other cases.\\n\\nThis was my first leetcode problem after a couple months away from programming, so it took me an embarrasingly long time.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(1)$$ -->\\n\\n- Space complexity: I have no clue. I would guess that it\\'s also $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    int[] months = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int CountDaysTogether(string arriveAlice, string leaveAli_ce, string arriveBob, string leaveBob) {\\n        int[] arriveAli_ = new int[]{Int32.Parse(arriveAlice.Substring(0,2)), Int32.Parse(arriveAlice.Substring(3,2))};\\n        int[] leaveAli_ = new int[]{Int32.Parse(leaveAli_ce.Substring(0,2)), Int32.Parse(leaveAli_ce.Substring(3,2))};\\n\\n        int[] arriveBob_ = new int[]{Int32.Parse(arriveBob.Substring(0,2)), Int32.Parse(arriveBob.Substring(3,2))};\\n        int[] leaveBob_ = new int[]{Int32.Parse(leaveBob.Substring(0,2)), Int32.Parse(leaveBob.Substring(3,2))};\\n\\n        // Do they even have common days?\\n\\n        //If Ali\\'s trip concludes before Bob\\'s starts\\n        if((leaveAli_[0] < arriveBob_[0]) || (leaveAli_[0] == arriveBob_[0] && leaveAli_[1] < arriveBob_[1])) return 0;\\n        //If Bob\\'s trip concludes before Ali\\'s starts\\n        if((leaveBob_[0] < arriveAli_[0]) || (leaveBob_[0] == arriveAli_[0] && leaveBob_[1] < arriveAli_[1])) return 0;\\n\\n        int days = 1;\\n        int[] arrS;\\n        int[] leaveF;\\n\\n        //Check who arrived first\\n        // Ali arrives first\\n        if(arriveAli_[0] < arriveBob_[0] || (arriveAli_[0] == arriveBob_[0] && arriveAli_[1] < arriveBob_[1])) {\\n            arrS = arriveBob_;\\n        }\\n        // Bob arrives first\\n        else {\\n            arrS = arriveAli_;\\n        }\\n\\n        // Who leaves first\\n\\n        // Ali leaves first\\n        if(leaveAli_[0] < leaveBob_[0] || (leaveAli_[0] == leaveBob_[0] && leaveAli_[1] < leaveBob_[1])) {\\n            leaveF = leaveAli_;\\n        }\\n        // Bob leaves first\\n        else {\\n            leaveF = leaveBob_;\\n        }\\n\\n        // If first leaves the same month second arrives\\n        if(leaveF[0] == arrS[0]) {\\n            return leaveF[1] - arrS[1] + 1;\\n        }\\n\\n        // Add the days of the month of the second arrival and the days of the month of the first leave\\n        days = months[arrS[0]-1] - arrS[1] + 1 + leaveF[1];\\n\\n        // The months in between\\n        for(int i = 0; i < leaveF[0] - arrS[0] - 1; i++) {\\n            days += months[i + arrS[0]];\\n        }\\n\\n        return days;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    int[] months = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int CountDaysTogether(string arriveAlice, string leaveAli_ce, string arriveBob, string leaveBob) {\\n        int[] arriveAli_ = new int[]{Int32.Parse(arriveAlice.Substring(0,2)), Int32.Parse(arriveAlice.Substring(3,2))};\\n        int[] leaveAli_ = new int[]{Int32.Parse(leaveAli_ce.Substring(0,2)), Int32.Parse(leaveAli_ce.Substring(3,2))};\\n\\n        int[] arriveBob_ = new int[]{Int32.Parse(arriveBob.Substring(0,2)), Int32.Parse(arriveBob.Substring(3,2))};\\n        int[] leaveBob_ = new int[]{Int32.Parse(leaveBob.Substring(0,2)), Int32.Parse(leaveBob.Substring(3,2))};\\n\\n        // Do they even have common days?\\n\\n        //If Ali\\'s trip concludes before Bob\\'s starts\\n        if((leaveAli_[0] < arriveBob_[0]) || (leaveAli_[0] == arriveBob_[0] && leaveAli_[1] < arriveBob_[1])) return 0;\\n        //If Bob\\'s trip concludes before Ali\\'s starts\\n        if((leaveBob_[0] < arriveAli_[0]) || (leaveBob_[0] == arriveAli_[0] && leaveBob_[1] < arriveAli_[1])) return 0;\\n\\n        int days = 1;\\n        int[] arrS;\\n        int[] leaveF;\\n\\n        //Check who arrived first\\n        // Ali arrives first\\n        if(arriveAli_[0] < arriveBob_[0] || (arriveAli_[0] == arriveBob_[0] && arriveAli_[1] < arriveBob_[1])) {\\n            arrS = arriveBob_;\\n        }\\n        // Bob arrives first\\n        else {\\n            arrS = arriveAli_;\\n        }\\n\\n        // Who leaves first\\n\\n        // Ali leaves first\\n        if(leaveAli_[0] < leaveBob_[0] || (leaveAli_[0] == leaveBob_[0] && leaveAli_[1] < leaveBob_[1])) {\\n            leaveF = leaveAli_;\\n        }\\n        // Bob leaves first\\n        else {\\n            leaveF = leaveBob_;\\n        }\\n\\n        // If first leaves the same month second arrives\\n        if(leaveF[0] == arrS[0]) {\\n            return leaveF[1] - arrS[1] + 1;\\n        }\\n\\n        // Add the days of the month of the second arrival and the days of the month of the first leave\\n        days = months[arrS[0]-1] - arrS[1] + 1 + leaveF[1];\\n\\n        // The months in between\\n        for(int i = 0; i < leaveF[0] - arrS[0] - 1; i++) {\\n            days += months[i + arrS[0]];\\n        }\\n\\n        return days;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647455,
                "title": "c-solution-beats-100",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Get exact day of the year from the given data and then it becomes a normal intersecting regions problem.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector <int> daysOfMonths = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int getExactDayOfYear(string k){\\n        int m1 = k[0] - \\'0\\', m2 = k[1] - \\'0\\';\\n        int d1 = k[3] - \\'0\\', d2 = k[4] - \\'0\\';\\n        int month = m1*10 + m2;\\n        int day = d1 * 10 + d2;\\n        int totalDays = 0;\\n        for(int i = 1; i < month; i++) totalDays += daysOfMonths[i];\\n        totalDays += day;\\n        return totalDays;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        \\n        int aA = getExactDayOfYear(arriveAlice);\\n        int lA = getExactDayOfYear(leaveAlice);\\n        int aB = getExactDayOfYear(arriveBob);\\n        int lB = getExactDayOfYear(leaveBob);\\n\\n        vector<int> v;\\n        v.push_back(aA);\\n        v.push_back(lA);\\n        v.push_back(aB);\\n        v.push_back(lB);\\n        sort(v.begin(), v.end());\\n\\n        int ans = 0;\\n\\n        for(int i = v[0]; i <= v[3]; i++){\\n            if(i >= aA and i <= lA){\\n                if(i >= aB and i <= lB) ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector <int> daysOfMonths = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int getExactDayOfYear(string k){\\n        int m1 = k[0] - \\'0\\', m2 = k[1] - \\'0\\';\\n        int d1 = k[3] - \\'0\\', d2 = k[4] - \\'0\\';\\n        int month = m1*10 + m2;\\n        int day = d1 * 10 + d2;\\n        int totalDays = 0;\\n        for(int i = 1; i < month; i++) totalDays += daysOfMonths[i];\\n        totalDays += day;\\n        return totalDays;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        \\n        int aA = getExactDayOfYear(arriveAlice);\\n        int lA = getExactDayOfYear(leaveAlice);\\n        int aB = getExactDayOfYear(arriveBob);\\n        int lB = getExactDayOfYear(leaveBob);\\n\\n        vector<int> v;\\n        v.push_back(aA);\\n        v.push_back(lA);\\n        v.push_back(aB);\\n        v.push_back(lB);\\n        sort(v.begin(), v.end());\\n\\n        int ans = 0;\\n\\n        for(int i = v[0]; i <= v[3]; i++){\\n            if(i >= aA and i <= lA){\\n                if(i >= aB and i <= lB) ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636051,
                "title": "standard-java-solution",
                "content": "### Theory\\nConvert the dates to a day. Loop through all the days in the year and check if alice and bob are present on that day.\\n\\n### Solution\\n```\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int aliceStartDay = getDays(arriveAlice), aliceEndDay = getDays(leaveAlice);\\n        int bobStartDay = getDays(arriveBob), bobEndDay = getDays(leaveBob);\\n\\n        int count = 0;\\n        for (int i = 1; i <= 365; i++) {\\n            if (presentOnDay(i, aliceStartDay, aliceEndDay) && presentOnDay(i, bobStartDay, bobEndDay))\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private boolean presentOnDay(int day, int start, int end) {\\n        return day >= start && day <= end;\\n    }\\n    \\n    private int getDays(String date) {\\n        int dayCount = 0;\\n        String[] parts = date.split(\"-\");\\n        Integer month = Integer.parseInt(parts[0]), dayOfMonth = Integer.parseInt(parts[1]);\\n        for (int i = 0; i < month - 1; i++) {\\n            dayCount += days[i];\\n        }\\n        \\n        dayCount += dayOfMonth;\\n        return dayCount;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int aliceStartDay = getDays(arriveAlice), aliceEndDay = getDays(leaveAlice);\\n        int bobStartDay = getDays(arriveBob), bobEndDay = getDays(leaveBob);\\n\\n        int count = 0;\\n        for (int i = 1; i <= 365; i++) {\\n            if (presentOnDay(i, aliceStartDay, aliceEndDay) && presentOnDay(i, bobStartDay, bobEndDay))\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private boolean presentOnDay(int day, int start, int end) {\\n        return day >= start && day <= end;\\n    }\\n    \\n    private int getDays(String date) {\\n        int dayCount = 0;\\n        String[] parts = date.split(\"-\");\\n        Integer month = Integer.parseInt(parts[0]), dayOfMonth = Integer.parseInt(parts[1]);\\n        for (int i = 0; i < month - 1; i++) {\\n            dayCount += days[i];\\n        }\\n        \\n        dayCount += dayOfMonth;\\n        return dayCount;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3627360,
                "title": "java-solution-using-sets-to-calculate-days-spent-together-by-this-weird-couple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\nimport java.util.Date; \\nimport java.time.*;\\nimport java.time.LocalDateTime;\\nimport java.time.format.DateTimeFormatter;\\nimport java.text.SimpleDateFormat;\\n\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n\\n        String result = arriveAlice + \"-\" +leaveAlice + \"-\" + arriveBob +\"-\" + leaveBob;\\n        String[] arr = result.split(\"-\");\\n        int[] days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int start1 = Integer.parseInt(arr[0]);\\n        int end1 = Integer.parseInt(arr[2]);\\n        int start2 = Integer.parseInt(arr[4]);\\n        int end2 = Integer.parseInt(arr[6]);\\n\\n  \\n        int start1Day = getDayOfYear(start1, Integer.parseInt(arr[1]), days);\\n        int end1Day = getDayOfYear(end1, Integer.parseInt(arr[3]), days);\\n        int start2Day = getDayOfYear(start2, Integer.parseInt(arr[5]), days);\\n        int end2Day =getDayOfYear(end2, Integer.parseInt(arr[7]), days); \\n\\n        int startDateMonth = Math.max(start1, start2);\\n        int startDateDay = Math.max(start1Day, start2Day);\\n        int endDateMonth = Math.min(end1, end2);\\n        int endDateDay = Math.min(end1Day, end2Day);\\n\\n        if (endDateMonth < startDateMonth || (endDateMonth == startDateMonth && endDateDay < startDateDay)) {\\n            return 0;\\n        }\\n\\n        Set<Integer> set1 = new HashSet<>();\\n        Set<Integer> set2 = new HashSet<>();\\n        while (start1Day <= end1Day ){\\n            set1.add(start1Day);\\n            start1Day++;\\n         }\\n         while (start2Day <= end2Day ){\\n            set2.add(start2Day);\\n            start2Day++;\\n         }\\n  \\n\\n    return countIntersection(set1, set2);\\n    }\\n        public static int countIntersection(Set<Integer> set1, Set<Integer> set2) {\\n        Set<Integer> intersection = new HashSet<>(set1);\\n        intersection.retainAll(set2);\\n\\n        return intersection.size();\\n    }\\n    public int getDayOfYear(int month, int day, int[] days) {\\n        int dayOfYear = day;\\n        for (int i = 0; i < month - 1; i++) {\\n            dayOfYear += days[i];\\n        }\\n        return dayOfYear;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Date; \\nimport java.time.*;\\nimport java.time.LocalDateTime;\\nimport java.time.format.DateTimeFormatter;\\nimport java.text.SimpleDateFormat;\\n\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n\\n        String result = arriveAlice + \"-\" +leaveAlice + \"-\" + arriveBob +\"-\" + leaveBob;\\n        String[] arr = result.split(\"-\");\\n        int[] days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int start1 = Integer.parseInt(arr[0]);\\n        int end1 = Integer.parseInt(arr[2]);\\n        int start2 = Integer.parseInt(arr[4]);\\n        int end2 = Integer.parseInt(arr[6]);\\n\\n  \\n        int start1Day = getDayOfYear(start1, Integer.parseInt(arr[1]), days);\\n        int end1Day = getDayOfYear(end1, Integer.parseInt(arr[3]), days);\\n        int start2Day = getDayOfYear(start2, Integer.parseInt(arr[5]), days);\\n        int end2Day =getDayOfYear(end2, Integer.parseInt(arr[7]), days); \\n\\n        int startDateMonth = Math.max(start1, start2);\\n        int startDateDay = Math.max(start1Day, start2Day);\\n        int endDateMonth = Math.min(end1, end2);\\n        int endDateDay = Math.min(end1Day, end2Day);\\n\\n        if (endDateMonth < startDateMonth || (endDateMonth == startDateMonth && endDateDay < startDateDay)) {\\n            return 0;\\n        }\\n\\n        Set<Integer> set1 = new HashSet<>();\\n        Set<Integer> set2 = new HashSet<>();\\n        while (start1Day <= end1Day ){\\n            set1.add(start1Day);\\n            start1Day++;\\n         }\\n         while (start2Day <= end2Day ){\\n            set2.add(start2Day);\\n            start2Day++;\\n         }\\n  \\n\\n    return countIntersection(set1, set2);\\n    }\\n        public static int countIntersection(Set<Integer> set1, Set<Integer> set2) {\\n        Set<Integer> intersection = new HashSet<>(set1);\\n        intersection.retainAll(set2);\\n\\n        return intersection.size();\\n    }\\n    public int getDayOfYear(int month, int day, int[] days) {\\n        int dayOfYear = day;\\n        for (int i = 0; i < month - 1; i++) {\\n            dayOfYear += days[i];\\n        }\\n        return dayOfYear;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617616,
                "title": "python3-convert-then-get-the-intersection",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nWe need to convert then in same unit base on the fixed days in month \\n[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\nExample: \\n02-01 = arr[0] + 01\\n05-19 = arr[0] + arr[1] + arr[2] + arr[3] + 19\\n\\nThen we have 2 line in same axis X.\\n[120, 130], [125,135]\\nWe can think they are 2 line and we need to find the intersection between them. \\n\\nBy using max at x1, x2 -> \\n--------x1----------------------------y1----------------------\\n------------x2-----------------------------y2-----------------\\n-------max(x1,x2)-------------------min(y1,y2)----------------\\nresult = min(y1,y2) - max(x1,x2)\\n\\nIn case: they didn\\'t intersect\\n--------x1-----y1---------------------------------------------\\n-----------------------------------x2---------------y2--------\\n--------------min(y1,y2)--------max(x1,x2)-------------------- \\nmin(y1,y2) - max(x1,x2) < 0\\n\\n\\nThen the final formula is:\\nreturn 0 if result < 0 else result\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def convertToTimespan(self, date: str) -> int:\\n        daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        [months, days] = date.split(\"-\")\\n        result = 0\\n        for i in range(int(months) - 1):\\n            result += daysInMonth[i]\\n        return result + int(days)\\n\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        arriveAliceTimeSpan = self.convertToTimespan(arriveAlice)\\n        leaveAliceTimeSpan = self.convertToTimespan(leaveAlice)\\n        arriveBobTimeSpan = self.convertToTimespan(arriveBob)\\n        leaveBobTimeSpan = self.convertToTimespan(leaveBob)\\n        result = min(leaveAliceTimeSpan,leaveBobTimeSpan) - max(arriveAliceTimeSpan,arriveBobTimeSpan) + 1\\n        return 0 if result < 0 else result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTimespan(self, date: str) -> int:\\n        daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        [months, days] = date.split(\"-\")\\n        result = 0\\n        for i in range(int(months) - 1):\\n            result += daysInMonth[i]\\n        return result + int(days)\\n\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        arriveAliceTimeSpan = self.convertToTimespan(arriveAlice)\\n        leaveAliceTimeSpan = self.convertToTimespan(leaveAlice)\\n        arriveBobTimeSpan = self.convertToTimespan(arriveBob)\\n        leaveBobTimeSpan = self.convertToTimespan(leaveBob)\\n        result = min(leaveAliceTimeSpan,leaveBobTimeSpan) - max(arriveAliceTimeSpan,arriveBobTimeSpan) + 1\\n        return 0 if result < 0 else result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573864,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        auto daysYearToDate = [](const string& date) {\\n            int daysYearToMonth[] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n            return daysYearToMonth[10 * (date[0] - \\'0\\') + date[1] - \\'0\\' - 1] + 10 * (date[3] - \\'0\\') + date[4] - \\'0\\';\\n        };\\n        const auto beginAlice = daysYearToDate(arriveAlice), endAlice = daysYearToDate(leaveAlice),\\n                   beginBob = daysYearToDate(arriveBob), endBob = daysYearToDate(leaveBob);\\n        return max(0, min(endAlice, endBob) - max(beginAlice, beginBob) + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        auto daysYearToDate = [](const string& date) {\\n            int daysYearToMonth[] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n            return daysYearToMonth[10 * (date[0] - \\'0\\') + date[1] - \\'0\\' - 1] + 10 * (date[3] - \\'0\\') + date[4] - \\'0\\';\\n        };\\n        const auto beginAlice = daysYearToDate(arriveAlice), endAlice = daysYearToDate(leaveAlice),\\n                   beginBob = daysYearToDate(arriveBob), endBob = daysYearToDate(leaveBob);\\n        return max(0, min(endAlice, endBob) - max(beginAlice, beginBob) + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562871,
                "title": "simple-solution-by-finding-day-of-the-year",
                "content": "# Approach\\nThe question states that there is no leep year.\\n\\nfind all days in day of the year and find the difference between second came and first left\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    static int [] arr = new int [13] ;\\n\\n    static{\\n        int days = 0;\\n        for(int i = 1;i<=12;i++){\\n            if(i == 2){\\n                days+=28;\\n                arr[i] = days;\\n                continue;\\n            }   \\n            if(i<=7){\\n                days += i%2 == 0 ? 30 : 31;\\n            }else{\\n                days += i%2 == 0 ? 31 : 30;\\n            }\\n            arr[i] = days;\\n        }\\n    }\\n\\n    public int countDaysTogether(String aa, String la, String ab, String lb) {\\n        int alicecame = dayOfTheYear(aa.split(\"-\"));\\n        int aliceleave = dayOfTheYear(la.split(\"-\"));\\n        int bobcame = dayOfTheYear(ab.split(\"-\"));\\n        int bobleave = dayOfTheYear(lb.split(\"-\"));\\n        if(aliceleave < bobcame || bobleave < alicecame)\\n            return 0;\\n        int secondcame = alicecame > bobcame ? alicecame : bobcame;\\n        int firstleave = aliceleave < bobleave ? aliceleave : bobleave;\\n\\n        return firstleave - secondcame+1;\\n    }\\n\\n    public int dayOfTheYear(String [] date){\\n        int res = 0;\\n        int month = Integer.parseInt(date[0])-1;\\n        res+= arr[month];\\n        res += Integer.parseInt(date[1]);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int [] arr = new int [13] ;\\n\\n    static{\\n        int days = 0;\\n        for(int i = 1;i<=12;i++){\\n            if(i == 2){\\n                days+=28;\\n                arr[i] = days;\\n                continue;\\n            }   \\n            if(i<=7){\\n                days += i%2 == 0 ? 30 : 31;\\n            }else{\\n                days += i%2 == 0 ? 31 : 30;\\n            }\\n            arr[i] = days;\\n        }\\n    }\\n\\n    public int countDaysTogether(String aa, String la, String ab, String lb) {\\n        int alicecame = dayOfTheYear(aa.split(\"-\"));\\n        int aliceleave = dayOfTheYear(la.split(\"-\"));\\n        int bobcame = dayOfTheYear(ab.split(\"-\"));\\n        int bobleave = dayOfTheYear(lb.split(\"-\"));\\n        if(aliceleave < bobcame || bobleave < alicecame)\\n            return 0;\\n        int secondcame = alicecame > bobcame ? alicecame : bobcame;\\n        int firstleave = aliceleave < bobleave ? aliceleave : bobleave;\\n\\n        return firstleave - secondcame+1;\\n    }\\n\\n    public int dayOfTheYear(String [] date){\\n        int res = 0;\\n        int month = Integer.parseInt(date[0])-1;\\n        res+= arr[month];\\n        res += Integer.parseInt(date[1]);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547734,
                "title": "simple-kotlin-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    fun countDaysTogether(arriveAlice: String, leaveAlice: String, arriveBob: String, leaveBob: String): Int {\\n        val months = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\\n        val days = IntArray(13)\\n        for ((i, total) in months.withIndex()) days[i+1] = days[i] + total\\n        val aliceStartMonth = arriveAlice.take(2).toInt()\\n        val aliceStartDay = arriveAlice.takeLast(2).toInt()\\n        val aliceEndMonth = leaveAlice.take(2).toInt()\\n        val aliceEndDay = leaveAlice.takeLast(2).toInt()\\n        val aliceStart = days[aliceStartMonth-1] + aliceStartDay\\n        val aliceEnd = days[aliceEndMonth-1] + aliceEndDay\\n\\n        val bobStartMonth = arriveBob.take(2).toInt()\\n        val bobStartDay = arriveBob.takeLast(2).toInt()\\n        val bobEndMonth = leaveBob.take(2).toInt()\\n        val bobEndDay = leaveBob.takeLast(2).toInt()\\n        val bobStart = days[bobStartMonth-1] + bobStartDay\\n        val bobEnd = days[bobEndMonth-1] + bobEndDay\\n\\n        val min = maxOf(aliceStart, bobStart)\\n        val max = minOf(aliceEnd, bobEnd)\\n        return maxOf(0, max-min+1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun countDaysTogether(arriveAlice: String, leaveAlice: String, arriveBob: String, leaveBob: String): Int {\\n        val months = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\\n        val days = IntArray(13)\\n        for ((i, total) in months.withIndex()) days[i+1] = days[i] + total\\n        val aliceStartMonth = arriveAlice.take(2).toInt()\\n        val aliceStartDay = arriveAlice.takeLast(2).toInt()\\n        val aliceEndMonth = leaveAlice.take(2).toInt()\\n        val aliceEndDay = leaveAlice.takeLast(2).toInt()\\n        val aliceStart = days[aliceStartMonth-1] + aliceStartDay\\n        val aliceEnd = days[aliceEndMonth-1] + aliceEndDay\\n\\n        val bobStartMonth = arriveBob.take(2).toInt()\\n        val bobStartDay = arriveBob.takeLast(2).toInt()\\n        val bobEndMonth = leaveBob.take(2).toInt()\\n        val bobEndDay = leaveBob.takeLast(2).toInt()\\n        val bobStart = days[bobStartMonth-1] + bobStartDay\\n        val bobEnd = days[bobEndMonth-1] + bobEndDay\\n\\n        val min = maxOf(aliceStart, bobStart)\\n        val max = minOf(aliceEnd, bobEnd)\\n        return maxOf(0, max-min+1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505017,
                "title": "convert-to-days-in-year",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        aA, lA = self.getDaysOfYear(arriveAlice), self.getDaysOfYear(leaveAlice)\\n        aB, lB = self.getDaysOfYear(arriveBob), self.getDaysOfYear(leaveBob)\\n        s, e = max(aA, aB), min(lA, lB)\\n        if s > e:\\n            return 0\\n        return e - s + 1\\n        \\n    def getDaysOfYear(self, dateStr):\\n        months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        month, day = int(dateStr.split(\\'-\\')[0]), int(dateStr.split(\\'-\\')[1])\\n        return sum(months[:month - 1]) + day\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        aA, lA = self.getDaysOfYear(arriveAlice), self.getDaysOfYear(leaveAlice)\\n        aB, lB = self.getDaysOfYear(arriveBob), self.getDaysOfYear(leaveBob)\\n        s, e = max(aA, aB), min(lA, lB)\\n        if s > e:\\n            return 0\\n        return e - s + 1\\n        \\n    def getDaysOfYear(self, dateStr):\\n        months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        month, day = int(dateStr.split(\\'-\\')[0]), int(dateStr.split(\\'-\\')[1])\\n        return sum(months[:month - 1]) + day\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500628,
                "title": "java-additional-method-solution-with-explaining",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use different strategies to resolve the problem: parsing input strings to Date, counting days after parsing input Strings to Integer values, brute force etc..\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe create method getDays(String date). This method returns the day of the year from string value. Knowing all days of the year we easily find the matching using two Set containers.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int [] year  = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n\\n        Set<Integer> aliceDays = new HashSet<>();\\n        Set<Integer> bobDays = new HashSet<>();\\n\\n        for(int i=getDays(arriveAlice);i<=getDays(leaveAlice);i++)\\n            aliceDays.add(i);\\n        for(int i=getDays(arriveBob);i<=getDays(leaveBob);i++)\\n            bobDays.add(i);\\n\\n        aliceDays.retainAll(bobDays);\\n\\n        return aliceDays.size();\\n\\n    }\\n\\n    private int getDays(String date){\\n        int result=0;\\n        int index=0;\\n        while (Integer.valueOf(date.split(\"-\")[0])-1!=index)\\n        {\\n            result+=year[index++];\\n        }\\n        result+=Integer.valueOf(date.split(\"-\")[1]);\\n\\n        return result;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int [] year  = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n\\n        Set<Integer> aliceDays = new HashSet<>();\\n        Set<Integer> bobDays = new HashSet<>();\\n\\n        for(int i=getDays(arriveAlice);i<=getDays(leaveAlice);i++)\\n            aliceDays.add(i);\\n        for(int i=getDays(arriveBob);i<=getDays(leaveBob);i++)\\n            bobDays.add(i);\\n\\n        aliceDays.retainAll(bobDays);\\n\\n        return aliceDays.size();\\n\\n    }\\n\\n    private int getDays(String date){\\n        int result=0;\\n        int index=0;\\n        while (Integer.valueOf(date.split(\"-\")[0])-1!=index)\\n        {\\n            result+=year[index++];\\n        }\\n        result+=Integer.valueOf(date.split(\"-\")[1]);\\n\\n        return result;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453039,
                "title": "c-solution-beats-100-fast-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        if (leaveAlice < arriveBob || leaveBob < arriveAlice)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            int ans = 0;\\n            int days[] = {0,31,28,31,30,31,30,31,31,30,31,30,31};\\n            string end = min(leaveAlice, leaveBob);\\n            string start = max(arriveAlice, arriveBob);\\n            int start_month = stoi(start.substr(0,2));\\n            int end_month = stoi(end.substr(0,2));\\n            int start_date = stoi(start.substr(3,2));\\n            int end_date = stoi(end.substr(3,2));\\n\\n            if (start_month != end_month)\\n                for (int month = start_month; month < end_month; month++)\\n                    ans += days[month];\\n\\n            ans = ans + end_date - start_date + 1;\\n   \\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        if (leaveAlice < arriveBob || leaveBob < arriveAlice)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            int ans = 0;\\n            int days[] = {0,31,28,31,30,31,30,31,31,30,31,30,31};\\n            string end = min(leaveAlice, leaveBob);\\n            string start = max(arriveAlice, arriveBob);\\n            int start_month = stoi(start.substr(0,2));\\n            int end_month = stoi(end.substr(0,2));\\n            int start_date = stoi(start.substr(3,2));\\n            int end_date = stoi(end.substr(3,2));\\n\\n            if (start_month != end_month)\\n                for (int month = start_month; month < end_month; month++)\\n                    ans += days[month];\\n\\n            ans = ans + end_date - start_date + 1;\\n   \\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440738,
                "title": "c-easy-and-short-min-max",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> D = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\\n\\n    int parse(string & s)\\n    {\\n        return D[(s[0] - \\'0\\') * 10 + (s[1] - \\'0\\') - 1] + (s[3] - \\'0\\') * 10 + (s[4] - \\'0\\');\\n    }\\n\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n    {\\n        for (int i = 1; i < D.size(); i++)\\n            D[i] += D[i - 1];\\n\\n        int a = parse(arriveAlice);\\n        int b = parse(leaveAlice);\\n        int c = parse(arriveBob);\\n        int d = parse(leaveBob);\\n\\n        return max(0, min(b, d) - max(a, c) + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> D = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\\n\\n    int parse(string & s)\\n    {\\n        return D[(s[0] - \\'0\\') * 10 + (s[1] - \\'0\\') - 1] + (s[3] - \\'0\\') * 10 + (s[4] - \\'0\\');\\n    }\\n\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n    {\\n        for (int i = 1; i < D.size(); i++)\\n            D[i] += D[i - 1];\\n\\n        int a = parse(arriveAlice);\\n        int b = parse(leaveAlice);\\n        int c = parse(arriveBob);\\n        int d = parse(leaveBob);\\n\\n        return max(0, min(b, d) - max(a, c) + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427135,
                "title": "lc-2409-e-python3-prefix-sum",
                "content": "Calculate the corresponding days for each month using the prefix sum and then write the process as requested.\\n\\n```Python3 []\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        month_days = list(accumulate([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], initial=0))\\n        alice_arrive_day = month_days[int(arriveAlice[:2])-1] + int(arriveAlice[3:])\\n        alice_leave_day = month_days[int(leaveAlice[:2])-1] + int(leaveAlice[3:])\\n        bob_arrive_day = month_days[int(arriveBob[:2])-1] + int(arriveBob[3:])\\n        bob_leave_day = month_days[int(leaveBob[:2])-1] + int(leaveBob[3:])\\n\\n        return max(0, min(alice_leave_day, bob_leave_day) - max(alice_arrive_day, bob_arrive_day) + 1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python3 []\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        month_days = list(accumulate([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], initial=0))\\n        alice_arrive_day = month_days[int(arriveAlice[:2])-1] + int(arriveAlice[3:])\\n        alice_leave_day = month_days[int(leaveAlice[:2])-1] + int(leaveAlice[3:])\\n        bob_arrive_day = month_days[int(arriveBob[:2])-1] + int(arriveBob[3:])\\n        bob_leave_day = month_days[int(leaveBob[:2])-1] + int(leaveBob[3:])\\n\\n        return max(0, min(alice_leave_day, bob_leave_day) - max(alice_arrive_day, bob_arrive_day) + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424114,
                "title": "simple-solution-by-finding-the-day-in-years-of-each-date",
                "content": "\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int[] preDays = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 };\\n\\n        int ParseDay(string date)\\n        {\\n            //return preDays[date[0] * 10 + date[1] - 529] + date[3] * 10 + date[4] - 528;\\n            var arr = date.Split(\\'-\\').Select(int.Parse).ToArray();\\n            return preDays[arr[0] - 1] + arr[1];\\n        }\\n\\n        int aa = ParseDay(arriveAlice), la = ParseDay(leaveAlice);\\n        int ab = ParseDay(arriveBob), lb = ParseDay(leaveBob);\\n\\n        return aa > lb || ab > la\\n            ? 0\\n            : (la > lb ? lb : la) - (aa > ab ? aa : ab) + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int[] preDays = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 };\\n\\n        int ParseDay(string date)\\n        {\\n            //return preDays[date[0] * 10 + date[1] - 529] + date[3] * 10 + date[4] - 528;\\n            var arr = date.Split(\\'-\\').Select(int.Parse).ToArray();\\n            return preDays[arr[0] - 1] + arr[1];\\n        }\\n\\n        int aa = ParseDay(arriveAlice), la = ParseDay(leaveAlice);\\n        int ab = ParseDay(arriveBob), lb = ParseDay(leaveBob);\\n\\n        return aa > lb || ab > la\\n            ? 0\\n            : (la > lb ? lb : la) - (aa > ab ? aa : ab) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422342,
                "title": "python-explained-runtime-8-ms-beats-97-30",
                "content": "![Screenshot 2023-04-16 11.17.37 AM.png](https://assets.leetcode.com/users/images/d1ec51b2-002a-4d9d-a803-6b2518fb861a_1681624411.4825795.png)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countDaysTogether(self, arriveAlice, leaveAlice, arriveBob, leaveBob):\\n        \"\"\"\\n        :type arriveAlice: str\\n        :type leaveAlice: str\\n        :type arriveBob: str\\n        :type leaveBob: str\\n        :rtype: int\\n        \"\"\"\\n\\n        # My Code.\\n\\n        # Importing date from datetime module.\\n        from datetime import date\\n\\n        # Getting max date between Alice & Bob\\'s arrival.\\n        # That\\'s the date from when they both will be together.\\n        a = max(arriveAlice, arriveBob)\\n\\n        # Getting min date between Alice & Bob\\'s departure.\\n        # That\\'s the date till both of them were together.\\n        b = min(leaveAlice, leaveBob)\\n\\n        # Defining a function, that converts str MM-DD to int MM-DD in tuple.\\n        def intdate(s):\\n            return tuple(map(int, s.split(\\'-\\')))\\n\\n        # Getting int of start date.\\n        c = intdate(a)\\n\\n        # Getting int of end date.\\n        d = intdate(b)\\n\\n        # If end date is smaller than start date.\\n        if d < c:\\n            return 0\\n\\n        # Subtracting 1 date from another. Doesn\\'t matter which from which.\\n        # Using abs() to get positive int.\\n        # Adding 1 to the end result & returning the final value.\\n        return abs(date(2019, c[0], c[1]) - date(2019, d[0], d[1])).days + 1\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "![Screenshot 2023-04-16 11.17.37 AM.png](https://assets.leetcode.com/users/images/d1ec51b2-002a-4d9d-a803-6b2518fb861a_1681624411.4825795.png)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countDaysTogether(self, arriveAlice, leaveAlice, arriveBob, leaveBob):\\n        \"\"\"\\n        :type arriveAlice: str\\n        :type leaveAlice: str\\n        :type arriveBob: str\\n        :type leaveBob: str\\n        :rtype: int\\n        \"\"\"\\n\\n        # My Code.\\n\\n        # Importing date from datetime module.\\n        from datetime import date\\n\\n        # Getting max date between Alice & Bob\\'s arrival.\\n        # That\\'s the date from when they both will be together.\\n        a = max(arriveAlice, arriveBob)\\n\\n        # Getting min date between Alice & Bob\\'s departure.\\n        # That\\'s the date till both of them were together.\\n        b = min(leaveAlice, leaveBob)\\n\\n        # Defining a function, that converts str MM-DD to int MM-DD in tuple.\\n        def intdate(s):\\n            return tuple(map(int, s.split(\\'-\\')))\\n\\n        # Getting int of start date.\\n        c = intdate(a)\\n\\n        # Getting int of end date.\\n        d = intdate(b)\\n\\n        # If end date is smaller than start date.\\n        if d < c:\\n            return 0\\n\\n        # Subtracting 1 date from another. Doesn\\'t matter which from which.\\n        # Using abs() to get positive int.\\n        # Adding 1 to the end result & returning the final value.\\n        return abs(date(2019, c[0], c[1]) - date(2019, d[0], d[1])).days + 1\\n",
                "codeTag": "Java"
            },
            {
                "id": 3416971,
                "title": "python-code-is-clear-af-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(n log n) - hope so\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n log n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n\\n        month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n\\n        count = 0\\n\\n        if arriveAlice > arriveBob:\\n            arriveDay = int(arriveAlice[3:]) \\n            arriveMon = int(arriveAlice[:2])\\n        else:\\n            arriveDay = int(arriveBob[3:]) \\n            arriveMon = int(arriveBob[:2])\\n            \\n        if leaveAlice > leaveBob:\\n            leaveDay  = int(leaveBob[3:]) \\n            leaveMon = int(leaveBob[:2])\\n        else:\\n            leaveDay  = int(leaveAlice[3:])\\n            leaveMon = int(leaveAlice[:2])\\n        \\n\\n        for mon in range(arriveMon, leaveMon + 1):\\n\\n            if mon == arriveMon:\\n                start = arriveDay\\n            else:\\n                start = 1\\n\\n            if mon == leaveMon:\\n                end = leaveDay\\n            else:\\n                end = month[mon - 1]\\n\\n            for day in range(start, end + 1):\\n                count += 1\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n\\n        month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n\\n        count = 0\\n\\n        if arriveAlice > arriveBob:\\n            arriveDay = int(arriveAlice[3:]) \\n            arriveMon = int(arriveAlice[:2])\\n        else:\\n            arriveDay = int(arriveBob[3:]) \\n            arriveMon = int(arriveBob[:2])\\n            \\n        if leaveAlice > leaveBob:\\n            leaveDay  = int(leaveBob[3:]) \\n            leaveMon = int(leaveBob[:2])\\n        else:\\n            leaveDay  = int(leaveAlice[3:])\\n            leaveMon = int(leaveAlice[:2])\\n        \\n\\n        for mon in range(arriveMon, leaveMon + 1):\\n\\n            if mon == arriveMon:\\n                start = arriveDay\\n            else:\\n                start = 1\\n\\n            if mon == leaveMon:\\n                end = leaveDay\\n            else:\\n                end = month[mon - 1]\\n\\n            for day in range(start, end + 1):\\n                count += 1\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404289,
                "title": "python-simple-solution-with-date",
                "content": "# Code\\n```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        latest_start = max(arriveAlice, arriveBob)\\n        earliest_end = min(leaveAlice, leaveBob)\\n        if latest_start <= earliest_end:\\n            return (date(2001, *map(int, earliest_end.split(\\'-\\'))) - \\n                    date(2001, *map(int, latest_start.split(\\'-\\')))).days + 1\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        latest_start = max(arriveAlice, arriveBob)\\n        earliest_end = min(leaveAlice, leaveBob)\\n        if latest_start <= earliest_end:\\n            return (date(2001, *map(int, earliest_end.split(\\'-\\'))) - \\n                    date(2001, *map(int, latest_start.split(\\'-\\')))).days + 1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399045,
                "title": "c-convert-to-days-from-boy",
                "content": "```\\nclass Solution {\\n    constexpr static int daysInmonth[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    int str2n(string str) {\\n        return (str.front() - \\'0\\') * 10 + (str.back() - \\'1\\');\\n    }\\n    int md2d(int m, int d) { // month and date to total days\\n        return accumulate(daysInmonth, daysInmonth + m, 0) + d;\\n    }\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        array<int,2> duration1 = {\\n            md2d( str2n(arriveAlice.substr(0,2)), str2n(arriveAlice.substr(3,2)) ),\\n            md2d( str2n(leaveAlice.substr(0,2)), str2n(leaveAlice.substr(3,2)) )\\n        };\\n        \\n        array<int,2> duration2 = {\\n            md2d( str2n(arriveBob.substr(0,2)), str2n(arriveBob.substr(3,2)) ),\\n            md2d( str2n(leaveBob.substr(0,2)), str2n(leaveBob.substr(3,2)) )\\n        };\\n        \\n        if(duration1[0] > duration2[0])\\n            swap(duration1, duration2);\\n        \\n        return max(0,  min(duration1[1], duration2[1]) - max(duration1[0], duration2[0]) + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    constexpr static int daysInmonth[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    int str2n(string str) {\\n        return (str.front() - \\'0\\') * 10 + (str.back() - \\'1\\');\\n    }\\n    int md2d(int m, int d) { // month and date to total days\\n        return accumulate(daysInmonth, daysInmonth + m, 0) + d;\\n    }\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        array<int,2> duration1 = {\\n            md2d( str2n(arriveAlice.substr(0,2)), str2n(arriveAlice.substr(3,2)) ),\\n            md2d( str2n(leaveAlice.substr(0,2)), str2n(leaveAlice.substr(3,2)) )\\n        };\\n        \\n        array<int,2> duration2 = {\\n            md2d( str2n(arriveBob.substr(0,2)), str2n(arriveBob.substr(3,2)) ),\\n            md2d( str2n(leaveBob.substr(0,2)), str2n(leaveBob.substr(3,2)) )\\n        };\\n        \\n        if(duration1[0] > duration2[0])\\n            swap(duration1, duration2);\\n        \\n        return max(0,  min(duration1[1], duration2[1]) - max(duration1[0], duration2[0]) + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395654,
                "title": "beats-100-so-many-conditions",
                "content": "brute checking\\nwhen bob comes firts or alice comes first\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n\\n        map<int,int> mp;\\n        mp[0] = 0;\\n        mp[1] = 31;\\n        mp[2] = 28;\\n        mp[3] = 31;\\n        mp[4] = 30;\\n        mp[5] = 31;\\n        mp[6] = 30;\\n        mp[7] = 31;\\n        mp[8] = 31;\\n        mp[9] = 30;\\n        mp[10] = 31;\\n        mp[11] = 30;\\n        mp[12] = 31;\\n\\n        for(int i=2;i<=12;i++){\\n            mp[i] = mp[i]+mp[i-1];\\n        }\\n\\n        // for(auto i:mp){\\n        //     cout<<i.first<<\" \"<<i.second<<endl;\\n        // }\\n\\n        int ans = 0;\\n\\n        int aaM = stoi(arriveAlice.substr(0,2));\\n        int aaD =stoi(arriveAlice.substr(3,2));\\n\\n        int alM = stoi(leaveAlice.substr(0,2));\\n        int alD = stoi(leaveAlice.substr(3,2));\\n\\n\\n        int baM = stoi(arriveBob.substr(0,2));\\n        int baD =stoi(arriveBob.substr(3,2));\\n\\n        int blM = stoi(leaveBob.substr(0,2));\\n        int blD = stoi(leaveBob.substr(3,2));\\n\\n        cout<<aaM<<\" \"<<aaD<<\" \"<<alM<<\" \"<<alD<<endl;\\n        cout<<baM<<\" \"<<baD<<\" \"<<blM<<\" \"<<blD<<endl;\\n\\n        \\n\\n        int aliceDaysArr = mp[aaM-1] + aaD;\\n        int aliceDaysLeave = mp[alM-1] + alD;\\n\\n        int bobDaysArr = mp[baM-1] + baD;\\n        int bobDaysLeave = mp[blM-1] + blD;\\n\\n        \\n        cout<<aliceDaysArr<<\" \"<<aliceDaysLeave<<\" \"<<endl;\\n        cout<<bobDaysArr<<\" \"<<bobDaysLeave<<\" \"<<endl;\\n\\n        // bob arriving first\\n        if(bobDaysArr<=aliceDaysArr){\\n            cout<<\"here \"<<endl;\\n            if(aliceDaysLeave<=bobDaysLeave){\\n                ans =  (aliceDaysLeave - aliceDaysArr) + 1;\\n            }\\n            if(aliceDaysLeave>bobDaysLeave){\\n                ans =  bobDaysLeave - aliceDaysArr +1;\\n            }\\n\\n        }\\n        // alice arrives first\\n        if(aliceDaysArr<=bobDaysArr){\\n            cout<<\"here\"<<endl;\\n            if(bobDaysLeave<=aliceDaysLeave){\\n                ans =  (bobDaysLeave - bobDaysArr) + 1;\\n            }\\n            if(bobDaysLeave>aliceDaysLeave){\\n                ans =  aliceDaysLeave - bobDaysArr +1;\\n            }\\n\\n        }\\n        if(ans>0){\\n            return ans;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n\\n        map<int,int> mp;\\n        mp[0] = 0;\\n        mp[1] = 31;\\n        mp[2] = 28;\\n        mp[3] = 31;\\n        mp[4] = 30;\\n        mp[5] = 31;\\n        mp[6] = 30;\\n        mp[7] = 31;\\n        mp[8] = 31;\\n        mp[9] = 30;\\n        mp[10] = 31;\\n        mp[11] = 30;\\n        mp[12] = 31;\\n\\n        for(int i=2;i<=12;i++){\\n            mp[i] = mp[i]+mp[i-1];\\n        }\\n\\n        // for(auto i:mp){\\n        //     cout<<i.first<<\" \"<<i.second<<endl;\\n        // }\\n\\n        int ans = 0;\\n\\n        int aaM = stoi(arriveAlice.substr(0,2));\\n        int aaD =stoi(arriveAlice.substr(3,2));\\n\\n        int alM = stoi(leaveAlice.substr(0,2));\\n        int alD = stoi(leaveAlice.substr(3,2));\\n\\n\\n        int baM = stoi(arriveBob.substr(0,2));\\n        int baD =stoi(arriveBob.substr(3,2));\\n\\n        int blM = stoi(leaveBob.substr(0,2));\\n        int blD = stoi(leaveBob.substr(3,2));\\n\\n        cout<<aaM<<\" \"<<aaD<<\" \"<<alM<<\" \"<<alD<<endl;\\n        cout<<baM<<\" \"<<baD<<\" \"<<blM<<\" \"<<blD<<endl;\\n\\n        \\n\\n        int aliceDaysArr = mp[aaM-1] + aaD;\\n        int aliceDaysLeave = mp[alM-1] + alD;\\n\\n        int bobDaysArr = mp[baM-1] + baD;\\n        int bobDaysLeave = mp[blM-1] + blD;\\n\\n        \\n        cout<<aliceDaysArr<<\" \"<<aliceDaysLeave<<\" \"<<endl;\\n        cout<<bobDaysArr<<\" \"<<bobDaysLeave<<\" \"<<endl;\\n\\n        // bob arriving first\\n        if(bobDaysArr<=aliceDaysArr){\\n            cout<<\"here \"<<endl;\\n            if(aliceDaysLeave<=bobDaysLeave){\\n                ans =  (aliceDaysLeave - aliceDaysArr) + 1;\\n            }\\n            if(aliceDaysLeave>bobDaysLeave){\\n                ans =  bobDaysLeave - aliceDaysArr +1;\\n            }\\n\\n        }\\n        // alice arrives first\\n        if(aliceDaysArr<=bobDaysArr){\\n            cout<<\"here\"<<endl;\\n            if(bobDaysLeave<=aliceDaysLeave){\\n                ans =  (bobDaysLeave - bobDaysArr) + 1;\\n            }\\n            if(bobDaysLeave>aliceDaysLeave){\\n                ans =  aliceDaysLeave - bobDaysArr +1;\\n            }\\n\\n        }\\n        if(ans>0){\\n            return ans;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1881413,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "**Weird couple :)**"
                    },
                    {
                        "username": "coderrsc",
                        "content": "thats what she said"
                    },
                    {
                        "username": "Suffolk",
                        "content": "convert to seconds, problem is converted to find overlap of 2 int arrays (if they have).\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Brute force."
                    }
                ]
            },
            {
                "id": 1918158,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "**Weird couple :)**"
                    },
                    {
                        "username": "coderrsc",
                        "content": "thats what she said"
                    },
                    {
                        "username": "Suffolk",
                        "content": "convert to seconds, problem is converted to find overlap of 2 int arrays (if they have).\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Brute force."
                    }
                ]
            },
            {
                "id": 1846544,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "**Weird couple :)**"
                    },
                    {
                        "username": "coderrsc",
                        "content": "thats what she said"
                    },
                    {
                        "username": "Suffolk",
                        "content": "convert to seconds, problem is converted to find overlap of 2 int arrays (if they have).\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Brute force."
                    }
                ]
            },
            {
                "id": 1736884,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "**Weird couple :)**"
                    },
                    {
                        "username": "coderrsc",
                        "content": "thats what she said"
                    },
                    {
                        "username": "Suffolk",
                        "content": "convert to seconds, problem is converted to find overlap of 2 int arrays (if they have).\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Brute force."
                    }
                ]
            }
        ]
    }
]