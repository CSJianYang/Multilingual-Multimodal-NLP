[
    {
        "title": "Ambiguous Coordinates",
        "question_content": "We had some 2-dimensional coordinates, like \"(1, 3)\" or \"(2, 0.5)\". Then, we removed all commas, decimal points, and spaces and ended up with the string s.\n\n\tFor example, \"(1, 3)\" becomes s = \"(13)\" and \"(2, 0.5)\" becomes s = \"(205)\".\n\nReturn a list of strings representing all possibilities for what our original coordinates could have been.\nOur original representation never had extraneous zeroes, so we never started with numbers like \"00\", \"0.0\", \"0.00\", \"1.0\", \"001\", \"00.01\", or any other number that can be represented with fewer digits. Also, a decimal point within a number never occurs without at least one digit occurring before it, so we never started with numbers like \".1\".\nThe final answer list can be returned in any order. All coordinates in the final answer have exactly one space between them (occurring after the comma.)\n&nbsp;\nExample 1:\n\nInput: s = \"(123)\"\nOutput: [\"(1, 2.3)\",\"(1, 23)\",\"(1.2, 3)\",\"(12, 3)\"]\n\nExample 2:\n\nInput: s = \"(0123)\"\nOutput: [\"(0, 1.23)\",\"(0, 12.3)\",\"(0, 123)\",\"(0.1, 2.3)\",\"(0.1, 23)\",\"(0.12, 3)\"]\nExplanation: 0.0, 00, 0001 or 00.01 are not allowed.\n\nExample 3:\n\nInput: s = \"(00011)\"\nOutput: [\"(0, 0.011)\",\"(0.001, 1)\"]\n\n&nbsp;\nConstraints:\n\n\t4 <= s.length <= 12\n\ts[0] == '(' and s[s.length - 1] == ')'.\n\tThe rest of s are digits.",
        "solutions": [
            {
                "id": 123851,
                "title": "c-java-python-solution-with-explanation",
                "content": "We can split S to two parts for two coordinates.\\nThen we use sub function ```f``` to find all possible strings for each coordinate.\\n\\n**In sub functon f(S)**\\nif S == \"\": return []\\nif S == \"0\": return [S]\\nif S == \"0XXX0\": return []\\nif S == \"0XXX\": return [\"0.XXX\"]\\nif S == \"XXX0\": return [S]\\nreturn [S, \"X.XXX\", \"XX.XX\", \"XXX.X\"...]\\n\\nThen we add the product of two lists to result.\\n\\n**Time complexity**\\nO(N^3) with N <= 10\\n\\nProvement:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/lee215/image_1523920967.png)\\n\\n\\nC++:\\n```\\n    vector<string> ambiguousCoordinates(string S) {\\n        int n = S.size();\\n        vector<string> res;\\n        for (int i = 1; i < n - 2; ++i) {\\n            vector<string> A = f(S.substr(1, i)), B = f(S.substr(i + 1, n - 2 - i));\\n            for (auto & a : A) for (auto & b : B) res.push_back(\"(\" + a + \", \" + b + \")\");\\n        }\\n        return res;\\n    }\\n    vector<string> f(string S) {\\n        int n = S.size();\\n        if (n == 0 || (n > 1 && S[0] == \\'0\\' && S[n - 1] == \\'0\\')) return {};\\n        if (n > 1 && S[0] == \\'0\\') return {\"0.\" + S.substr(1)};\\n        if (n == 1 || S[n - 1] == \\'0\\') return {S};\\n        vector<string> res = {S};\\n        for (int i = 1; i < n; ++i) res.push_back(S.substr(0, i) + \\'.\\' + S.substr(i));\\n        return res;\\n    }\\n```\\n**Java:**\\n```\\n    public List<String> ambiguousCoordinates(String S) {\\n        int n = S.length();\\n        List<String> res = new ArrayList();\\n        for (int i = 1; i < n - 2; ++i) {\\n            List<String> A = f(S.substring(1, i + 1)), B = f(S.substring(i + 1, n - 1));\\n            for (String a : A) for (String b : B) res.add(\"(\" + a + \", \" + b + \")\");\\n        }\\n        return res;\\n    }\\n    public List<String> f(String S) {\\n        int n = S.length();\\n        List<String> res = new ArrayList();\\n        if (n == 0 || (n > 1 && S.charAt(0) == \\'0\\' && S.charAt(n - 1) == \\'0\\')) return res;\\n        if (n > 1 && S.charAt(0) == \\'0\\') {\\n            res.add(\"0.\" + S.substring(1));\\n            return res;\\n        }\\n        res.add(S);\\n        if (n == 1 || S.charAt(n - 1) == \\'0\\') return res;\\n        for (int i = 1; i < n; ++i) res.add(S.substring(0, i) + \\'.\\' + S.substring(i));\\n        return res;\\n    }\\n```\\n**Python:**\\n```\\n    def ambiguousCoordinates(self, S):\\n        S = S[1:-1]\\n        def f(S):\\n            if not S or len(S) > 1 and S[0] == S[-1] == \\'0\\': return []\\n            if S[-1] == \\'0\\': return [S]\\n            if S[0] == \\'0\\': return [S[0] + \\'.\\' + S[1:]]\\n            return [S] + [S[:i] + \\'.\\' + S[i:] for i in range(1, len(S))]\\n        return [\\'(%s, %s)\\' % (a, b) for i in range(len(S)) for a, b in itertools.product(f(S[:i]), f(S[i:]))]\\n```",
                "solutionTags": [],
                "code": "```f```\n```\\n    vector<string> ambiguousCoordinates(string S) {\\n        int n = S.size();\\n        vector<string> res;\\n        for (int i = 1; i < n - 2; ++i) {\\n            vector<string> A = f(S.substr(1, i)), B = f(S.substr(i + 1, n - 2 - i));\\n            for (auto & a : A) for (auto & b : B) res.push_back(\"(\" + a + \", \" + b + \")\");\\n        }\\n        return res;\\n    }\\n    vector<string> f(string S) {\\n        int n = S.size();\\n        if (n == 0 || (n > 1 && S[0] == \\'0\\' && S[n - 1] == \\'0\\')) return {};\\n        if (n > 1 && S[0] == \\'0\\') return {\"0.\" + S.substr(1)};\\n        if (n == 1 || S[n - 1] == \\'0\\') return {S};\\n        vector<string> res = {S};\\n        for (int i = 1; i < n; ++i) res.push_back(S.substr(0, i) + \\'.\\' + S.substr(i));\\n        return res;\\n    }\\n```\n```\\n    public List<String> ambiguousCoordinates(String S) {\\n        int n = S.length();\\n        List<String> res = new ArrayList();\\n        for (int i = 1; i < n - 2; ++i) {\\n            List<String> A = f(S.substring(1, i + 1)), B = f(S.substring(i + 1, n - 1));\\n            for (String a : A) for (String b : B) res.add(\"(\" + a + \", \" + b + \")\");\\n        }\\n        return res;\\n    }\\n    public List<String> f(String S) {\\n        int n = S.length();\\n        List<String> res = new ArrayList();\\n        if (n == 0 || (n > 1 && S.charAt(0) == \\'0\\' && S.charAt(n - 1) == \\'0\\')) return res;\\n        if (n > 1 && S.charAt(0) == \\'0\\') {\\n            res.add(\"0.\" + S.substring(1));\\n            return res;\\n        }\\n        res.add(S);\\n        if (n == 1 || S.charAt(n - 1) == \\'0\\') return res;\\n        for (int i = 1; i < n; ++i) res.add(S.substring(0, i) + \\'.\\' + S.substring(i));\\n        return res;\\n    }\\n```\n```\\n    def ambiguousCoordinates(self, S):\\n        S = S[1:-1]\\n        def f(S):\\n            if not S or len(S) > 1 and S[0] == S[-1] == \\'0\\': return []\\n            if S[-1] == \\'0\\': return [S]\\n            if S[0] == \\'0\\': return [S[0] + \\'.\\' + S[1:]]\\n            return [S] + [S[:i] + \\'.\\' + S[i:] for i in range(1, len(S))]\\n        return [\\'(%s, %s)\\' % (a, b) for i in range(len(S)) for a, b in itertools.product(f(S[:i]), f(S[i:]))]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 123875,
                "title": "really-clear-java-code",
                "content": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String S) {\\n        S = S.substring(1, S.length() - 1);\\n        List<String> result = new LinkedList<>();\\n        for (int i = 1; i < S.length(); i++) {\\n            List<String> left = allowed(S.substring(0, i));\\n            List<String> right = allowed(S.substring(i));\\n            for (String ls : left) {\\n                for (String rs : right) {\\n                    result.add(\"(\" + ls + \", \" + rs + \")\");\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    private List<String> allowed(String s) {\\n        int l = s.length();\\n        char[] cs = s.toCharArray();\\n        List<String> result = new LinkedList<>();\\n        if (cs[0] == \\'0\\' && cs[l - 1] == \\'0\\') { // \"0xxxx0\" Invalid unless a single \"0\"\\n            if (l == 1) {\\n                result.add(\"0\");\\n            }\\n            return result;\\n        }\\n        if (cs[0] == \\'0\\') { // \"0xxxxx\" The only valid result is \"0.xxxxx\"\\n            result.add(\"0.\" + s.substring(1));\\n            return result;\\n        }\\n        if (cs[l - 1] == \\'0\\') { // \"xxxxx0\" The only valid result is itself\\n            result.add(s);\\n            return result;\\n        }\\n        result.add(s); // Add itself\\n        for (int i = 1; i < l; i++) { // \"xxxx\" -> \"x.xxx\", \"xx.xx\", \"xxx.x\"\\n            result.add(s.substring(0, i) + \\'.\\' + s.substring(i));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String S) {\\n        S = S.substring(1, S.length() - 1);\\n        List<String> result = new LinkedList<>();\\n        for (int i = 1; i < S.length(); i++) {\\n            List<String> left = allowed(S.substring(0, i));\\n            List<String> right = allowed(S.substring(i));\\n            for (String ls : left) {\\n                for (String rs : right) {\\n                    result.add(\"(\" + ls + \", \" + rs + \")\");\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    private List<String> allowed(String s) {\\n        int l = s.length();\\n        char[] cs = s.toCharArray();\\n        List<String> result = new LinkedList<>();\\n        if (cs[0] == \\'0\\' && cs[l - 1] == \\'0\\') { // \"0xxxx0\" Invalid unless a single \"0\"\\n            if (l == 1) {\\n                result.add(\"0\");\\n            }\\n            return result;\\n        }\\n        if (cs[0] == \\'0\\') { // \"0xxxxx\" The only valid result is \"0.xxxxx\"\\n            result.add(\"0.\" + s.substring(1));\\n            return result;\\n        }\\n        if (cs[l - 1] == \\'0\\') { // \"xxxxx0\" The only valid result is itself\\n            result.add(s);\\n            return result;\\n        }\\n        result.add(s); // Add itself\\n        for (int i = 1; i < l; i++) { // \"xxxx\" -> \"x.xxx\", \"xx.xx\", \"xxx.x\"\\n            result.add(s.substring(0, i) + \\'.\\' + s.substring(i));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205855,
                "title": "c-clean-and-simple-solution-faster-than-96",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string> res;\\n        string s2 = s.substr(1, s.size()-2);\\n        int n = s2.size();\\n        \\n        for (int i = 1; i < n; i++) {\\n            vector<string> first = getNumbers(s2.substr(0, i));\\n            vector<string> second = getNumbers(s2.substr(i));\\n            \\n            for (int j = 0; j < first.size(); j++) {\\n                for (int k = 0; k < second.size(); k++) {\\n                    res.push_back(\"(\" + first[j] + \", \" + second[k] + \")\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\nprivate:\\n    vector<string> getNumbers(string num) {\\n        vector<string> res;\\n        int n = num.size();\\n        \\n        if (n == 1) \\n            return {num};\\n        \\n        if (num[0] != \\'0\\') \\n            res.push_back(num);\\n        \\n        if (num[0] == \\'0\\') {\\n            if (num.back() == \\'0\\') return {};\\n            return {\"0.\" + num.substr(1)};\\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (num.substr(i).back() == \\'0\\') continue;\\n            res.push_back(num.substr(0, i) + \".\" + num.substr(i));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string> res;\\n        string s2 = s.substr(1, s.size()-2);\\n        int n = s2.size();\\n        \\n        for (int i = 1; i < n; i++) {\\n            vector<string> first = getNumbers(s2.substr(0, i));\\n            vector<string> second = getNumbers(s2.substr(i));\\n            \\n            for (int j = 0; j < first.size(); j++) {\\n                for (int k = 0; k < second.size(); k++) {\\n                    res.push_back(\"(\" + first[j] + \", \" + second[k] + \")\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\nprivate:\\n    vector<string> getNumbers(string num) {\\n        vector<string> res;\\n        int n = num.size();\\n        \\n        if (n == 1) \\n            return {num};\\n        \\n        if (num[0] != \\'0\\') \\n            res.push_back(num);\\n        \\n        if (num[0] == \\'0\\') {\\n            if (num.back() == \\'0\\') return {};\\n            return {\"0.\" + num.substr(1)};\\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (num.substr(i).back() == \\'0\\') continue;\\n            res.push_back(num.substr(0, i) + \".\" + num.substr(i));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123881,
                "title": "concise-c-solution-with-comments",
                "content": "```\\nvector<string> cases(string &&s) {\\n    if (s.size() == 1) // single digit\\n        return {s};\\n    if (s.front() == \\'0\\') { // 0xxx\\n        if (s.back() == \\'0\\') // 0xxx0\\n            return {};\\n        return {\"0.\" + s.substr(1)}; // 0xxx9\\n    }\\n    if (s.back() == \\'0\\') // 9xxx0\\n        return {s};\\n    vector<string> res{s}; // 9xxx9\\n    for (int i = 1; i < s.size(); i++)\\n        res.emplace_back(s.substr(0, i) + \".\" + s.substr(i));\\n    return res;\\n}\\n\\nvector<string> ambiguousCoordinates(string S) {\\n    vector<string> res;\\n    for (int i = 2; i < S.size() - 1; i++) // position of comma\\n    for (auto &x : cases(S.substr(1, i - 1)))\\n    for (auto &y : cases(S.substr(i, S.size() - i - 1)))\\n        res.emplace_back(\"(\" + x + \", \" + y + \")\");\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> cases(string &&s) {\\n    if (s.size() == 1) // single digit\\n        return {s};\\n    if (s.front() == \\'0\\') { // 0xxx\\n        if (s.back() == \\'0\\') // 0xxx0\\n            return {};\\n        return {\"0.\" + s.substr(1)}; // 0xxx9\\n    }\\n    if (s.back() == \\'0\\') // 9xxx0\\n        return {s};\\n    vector<string> res{s}; // 9xxx9\\n    for (int i = 1; i < s.size(); i++)\\n        res.emplace_back(s.substr(0, i) + \".\" + s.substr(i));\\n    return res;\\n}\\n\\nvector<string> ambiguousCoordinates(string S) {\\n    vector<string> res;\\n    for (int i = 2; i < S.size() - 1; i++) // position of comma\\n    for (auto &x : cases(S.substr(1, i - 1)))\\n    for (auto &y : cases(S.substr(i, S.size() - i - 1)))\\n        res.emplace_back(\"(\" + x + \", \" + y + \")\");\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1205982,
                "title": "python-product-solution-with-correct-complexity-explained",
                "content": "Let us create function `generate(s)`, which generate all possible candidates for string `s`: we need to check number without dot and also all possible ways to put dot inside. We need to check the condition `our original representation never had extraneous zeroes`, so we check that if some number starts with `0`, it should be equal to `0`.\\n\\nThen we split `S` into all possible  ways, for each part generate all numbers and then choose all pairs of numbers. \\n\\n#### Complexity\\nThere is `O(n)` ways to split string `S` into two parts. Overall time and space complexity will be `O(n^4)`, for example for string `\"(\" + \"1\"*n + \")\"`, number of ways will be approximately `n^3/6`, each of them have length `O(n)`.\\n\\n```python\\nclass Solution:\\n    def ambiguousCoordinates(self, S):\\n        def generate(s):\\n            ans = []\\n            if s == \"0\" or s[0] != \"0\": ans.append(s)\\n            for i in range(1, len(s)):\\n                if (s[:i] == \"0\" or s[0] != \"0\") and s[-1] != \"0\":\\n                    ans.append(s[:i] + \".\" + s[i:])\\n            return ans\\n        \\n        n, ans = len(S), []\\n        for i in range(2, n-1):\\n            cand_l, cand_r = generate(S[1:i]), generate(S[i:-1])     \\n            for l, r in product(cand_l, cand_r):\\n                ans.append(\"(\" + l + \", \" + r + \")\")\\n                \\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def ambiguousCoordinates(self, S):\\n        def generate(s):\\n            ans = []\\n            if s == \"0\" or s[0] != \"0\": ans.append(s)\\n            for i in range(1, len(s)):\\n                if (s[:i] == \"0\" or s[0] != \"0\") and s[-1] != \"0\":\\n                    ans.append(s[:i] + \".\" + s[i:])\\n            return ans\\n        \\n        n, ans = len(S), []\\n        for i in range(2, n-1):\\n            cand_l, cand_r = generate(S[1:i]), generate(S[i:-1])     \\n            for l, r in product(cand_l, cand_r):\\n                ans.append(\"(\" + l + \", \" + r + \")\")\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206218,
                "title": "js-python-java-c-easy-iterative-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nFor this problem, we have two basic challenges. The first challenge is preventing invalid coordinates. For that, we can define a helper function (**parse**) which will take a string (**str**) and only pass on valid options for another helper (**process**) to handle.\\n\\nWe can break down the options into three categories:\\n - _No decimal_: Any option except one with more than **1** digit and a leading **\"0\"**.\\n - _Decimal after first digit_: Any option with more than **1** digit and no trailing **\"0\"**.\\n - _Decimals throughout_: Any option that doesn\\'t start and end with a **\"0\"**\\n\\nAfter defining our first helper function, the next thing we should do is iterate through possible comma locations in our input string (**S**) and separate the coordinate pair strings (**xStr, yStr**).\\n\\nThen we\\'ll run into the second challenge, which is to avoid repeating the same processing. If we were to employ a simple nested loop or recursive function to solve this problem, it would end up redoing the same processes many times, since both coordinates can have a decimal.\\n\\nWhat we actually want is the product of two loops. The basic solution would be to create two arrays and iterate through their combinations, but there\\'s really no need to actually build the second array, since we can just as easily process the combinations while we iterate through the second coordinate naturally.\\n\\nSo we should first build and validate all decimal options for the **xStr** of a given comma position and store the valid possibilities in an array (**xPoss**). Once this is complete we should find each valid decimal option for **yStr**, combine it with each value in **xPoss**, and add the results to our answer array (**ans**) before moving onto the next comma position.\\n\\nTo aid in this, we can define **process**, which will either store the valid decimal options from **xStr** into **xPoss** or combine valid decimal options from **yStr** with the contents of **xPoss** and store the results in **ans**, depending on which coordinate string we\\'re currently on (**xy**).\\n\\nOnce we finish iterating through all comma positions, we can **return ans**.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **76ms / 42.3MB** (beats 100% / 100%).\\n```javascript\\nvar ambiguousCoordinates = function(S) {\\n    let ans = [], xPoss\\n    const process = (str, xy) => {\\n        if (xy)\\n            for (let x of xPoss)\\n                ans.push(`(${x}, ${str})`)\\n        else xPoss.push(str)\\n    }\\n    const parse = (str, xy) => {\\n        if (str.length === 1 || str[0] !== \"0\")\\n            process(str, xy)\\n        if (str.length > 1 && str[str.length-1] !== \"0\")\\n            process(str.slice(0,1) + \".\" + str.slice(1), xy)\\n        if (str.length > 2 && str[0] !== \"0\" && str[str.length-1] !== \"0\")\\n            for (let i = 2; i < str.length; i++)\\n                process(str.slice(0,i) + \".\" + str.slice(i), xy)\\n    }\\n    for (let i = 2; i < S.length - 1; i++) {\\n        let strs = [S.slice(1,i), S.slice(i, S.length - 1)]\\n        xPoss = []\\n        for (let j = 0; j < 2; j++)\\n            if (xPoss.length || !j) parse(strs[j], j)\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **32ms / 14.1MB** (beats 99% / 92%).\\n```python\\nclass Solution:\\n    def ambiguousCoordinates(self, S: str) -> List[str]:\\n        ans, xPoss = [], []\\n        def process(st: str, xy: int):\\n            if xy:\\n                for x in xPoss:\\n                    ans.append(\"(\" + x + \", \" + st + \")\")\\n            else: xPoss.append(st)\\n        def parse(st: str, xy: int):\\n            if len(st) == 1 or st[0] != \"0\":\\n                process(st, xy)\\n            if len(st) > 1 and st[-1] != \"0\":\\n                process(st[:1] + \".\" + st[1:], xy)\\n            if len(st) > 2 and st[0] != \"0\" and st[-1] != \"0\":\\n                for i in range(2, len(st)):\\n                    process(st[:i] + \".\" + st[i:], xy)  \\n        for i in range(2, len(S)-1):\\n            strs, xPoss = [S[1:i], S[i:-1]], []\\n            for j in range(2):\\n                if xPoss or not j: parse(strs[j], j)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **7ms / 39.5MB** (beats 100% / 91%).\\n```java\\nclass Solution {\\n    private List<String> xPoss, ans;\\n    public List<String> ambiguousCoordinates(String S) {\\n        ans = new ArrayList<>();\\n        for (int i = 2; i < S.length() - 1; i++) {\\n            String[] strs = {S.substring(1,i), S.substring(i, S.length() - 1)};\\n            xPoss = new ArrayList<>();\\n            for (int j = 0; j < 2; j++)\\n                if (xPoss.size() > 0 || j == 0) parse(strs[j], j);\\n        }\\n        return ans;\\n    }\\n    private void parse(String str, int xy) {\\n        if (str.length() == 1 || str.charAt(0) != \\'0\\')\\n            process(str, xy);\\n        if (str.length() > 1 && str.charAt(str.length()-1) != \\'0\\')\\n            process(str.substring(0,1) + \".\" + str.substring(1), xy);\\n        if (str.length() > 2 && str.charAt(0) != \\'0\\' && str.charAt(str.length()-1) != \\'0\\')\\n            for (int i = 2; i < str.length(); i++)\\n                process(str.substring(0,i) + \".\" + str.substring(i), xy);\\n    }\\n    private void process(String str, int xy) {\\n        if (xy > 0)\\n            for (String x : xPoss)\\n                ans.add(\"(\" + x + \", \" + str + \")\");\\n        else xPoss.add(str);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 9.1MB** (beats 100% / 95%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string S) {\\n        for (int i = 2; i < S.size() - 1; i++) {\\n            string strs[2] = {S.substr(1,i-1), S.substr(i,S.size()-i-1)};\\n            xPoss.clear();\\n            for (int j = 0; j < 2; j++)\\n                if (xPoss.size() || !j) parse(strs[j], j);\\n        }\\n        return ans;\\n    }\\nprivate:\\n    vector<string> ans, xPoss;\\n    void parse(string str, int xy) {\\n        if (str.size() == 1 || str.front() != \\'0\\')\\n            process(str, xy);\\n        if (str.size() > 1 && str.back() != \\'0\\')\\n            process(str.substr(0,1) + \".\" + str.substr(1), xy);\\n        if (str.size() > 2 && str.front() != \\'0\\' && str.back() != \\'0\\')\\n            for (int i = 2; i < str.size(); i++)\\n                process(str.substr(0,i) + \".\" + str.substr(i), xy);\\n    }\\n    void process(string str, int xy) {\\n        if (xy)\\n            for (auto x : xPoss)\\n                ans.push_back(\"(\" + x + \", \" + str + \")\");\\n        else xPoss.push_back(str);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar ambiguousCoordinates = function(S) {\\n    let ans = [], xPoss\\n    const process = (str, xy) => {\\n        if (xy)\\n            for (let x of xPoss)\\n                ans.push(`(${x}, ${str})`)\\n        else xPoss.push(str)\\n    }\\n    const parse = (str, xy) => {\\n        if (str.length === 1 || str[0] !== \"0\")\\n            process(str, xy)\\n        if (str.length > 1 && str[str.length-1] !== \"0\")\\n            process(str.slice(0,1) + \".\" + str.slice(1), xy)\\n        if (str.length > 2 && str[0] !== \"0\" && str[str.length-1] !== \"0\")\\n            for (let i = 2; i < str.length; i++)\\n                process(str.slice(0,i) + \".\" + str.slice(i), xy)\\n    }\\n    for (let i = 2; i < S.length - 1; i++) {\\n        let strs = [S.slice(1,i), S.slice(i, S.length - 1)]\\n        xPoss = []\\n        for (let j = 0; j < 2; j++)\\n            if (xPoss.length || !j) parse(strs[j], j)\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def ambiguousCoordinates(self, S: str) -> List[str]:\\n        ans, xPoss = [], []\\n        def process(st: str, xy: int):\\n            if xy:\\n                for x in xPoss:\\n                    ans.append(\"(\" + x + \", \" + st + \")\")\\n            else: xPoss.append(st)\\n        def parse(st: str, xy: int):\\n            if len(st) == 1 or st[0] != \"0\":\\n                process(st, xy)\\n            if len(st) > 1 and st[-1] != \"0\":\\n                process(st[:1] + \".\" + st[1:], xy)\\n            if len(st) > 2 and st[0] != \"0\" and st[-1] != \"0\":\\n                for i in range(2, len(st)):\\n                    process(st[:i] + \".\" + st[i:], xy)  \\n        for i in range(2, len(S)-1):\\n            strs, xPoss = [S[1:i], S[i:-1]], []\\n            for j in range(2):\\n                if xPoss or not j: parse(strs[j], j)\\n        return ans\\n```\n```java\\nclass Solution {\\n    private List<String> xPoss, ans;\\n    public List<String> ambiguousCoordinates(String S) {\\n        ans = new ArrayList<>();\\n        for (int i = 2; i < S.length() - 1; i++) {\\n            String[] strs = {S.substring(1,i), S.substring(i, S.length() - 1)};\\n            xPoss = new ArrayList<>();\\n            for (int j = 0; j < 2; j++)\\n                if (xPoss.size() > 0 || j == 0) parse(strs[j], j);\\n        }\\n        return ans;\\n    }\\n    private void parse(String str, int xy) {\\n        if (str.length() == 1 || str.charAt(0) != \\'0\\')\\n            process(str, xy);\\n        if (str.length() > 1 && str.charAt(str.length()-1) != \\'0\\')\\n            process(str.substring(0,1) + \".\" + str.substring(1), xy);\\n        if (str.length() > 2 && str.charAt(0) != \\'0\\' && str.charAt(str.length()-1) != \\'0\\')\\n            for (int i = 2; i < str.length(); i++)\\n                process(str.substring(0,i) + \".\" + str.substring(i), xy);\\n    }\\n    private void process(String str, int xy) {\\n        if (xy > 0)\\n            for (String x : xPoss)\\n                ans.add(\"(\" + x + \", \" + str + \")\");\\n        else xPoss.add(str);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string S) {\\n        for (int i = 2; i < S.size() - 1; i++) {\\n            string strs[2] = {S.substr(1,i-1), S.substr(i,S.size()-i-1)};\\n            xPoss.clear();\\n            for (int j = 0; j < 2; j++)\\n                if (xPoss.size() || !j) parse(strs[j], j);\\n        }\\n        return ans;\\n    }\\nprivate:\\n    vector<string> ans, xPoss;\\n    void parse(string str, int xy) {\\n        if (str.size() == 1 || str.front() != \\'0\\')\\n            process(str, xy);\\n        if (str.size() > 1 && str.back() != \\'0\\')\\n            process(str.substr(0,1) + \".\" + str.substr(1), xy);\\n        if (str.size() > 2 && str.front() != \\'0\\' && str.back() != \\'0\\')\\n            for (int i = 2; i < str.size(); i++)\\n                process(str.substr(0,i) + \".\" + str.substr(i), xy);\\n    }\\n    void process(string str, int xy) {\\n        if (xy)\\n            for (auto x : xPoss)\\n                ans.push_back(\"(\" + x + \", \" + str + \")\");\\n        else xPoss.push_back(str);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206219,
                "title": "ambiguous-coordinates-js-python-java-c-easy-iterative-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nFor this problem, we have two basic challenges. The first challenge is preventing invalid coordinates. For that, we can define a helper function (**parse**) which will take a string (**str**) and only pass on valid options for another helper (**process**) to handle.\\n\\nWe can break down the options into three categories:\\n - _No decimal_: Any option except one with more than **1** digit and a leading **\"0\"**.\\n - _Decimal after first digit_: Any option with more than **1** digit and no trailing **\"0\"**.\\n - _Decimals throughout_: Any option that doesn\\'t start and end with a **\"0\"**\\n\\nAfter defining our first helper function, the next thing we should do is iterate through possible comma locations in our input string (**S**) and separate the coordinate pair strings (**xStr, yStr**).\\n\\nThen we\\'ll run into the second challenge, which is to avoid repeating the same processing. If we were to employ a simple nested loop or recursive function to solve this problem, it would end up redoing the same processes many times, since both coordinates can have a decimal.\\n\\nWhat we actually want is the product of two loops. The basic solution would be to create two arrays and iterate through their combinations, but there\\'s really no need to actually build the second array, since we can just as easily process the combinations while we iterate through the second coordinate naturally.\\n\\nSo we should first build and validate all decimal options for the **xStr** of a given comma position and store the valid possibilities in an array (**xPoss**). Once this is complete we should find each valid decimal option for **yStr**, combine it with each value in **xPoss**, and add the results to our answer array (**ans**) before moving onto the next comma position.\\n\\nTo aid in this, we can define **process**, which will either store the valid decimal options from **xStr** into **xPoss** or combine valid decimal options from **yStr** with the contents of **xPoss** and store the results in **ans**, depending on which coordinate string we\\'re currently on (**xy**).\\n\\nOnce we finish iterating through all comma positions, we can **return ans**.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **76ms / 42.3MB** (beats 100% / 100%).\\n```javascript\\nvar ambiguousCoordinates = function(S) {\\n    let ans = [], xPoss\\n    const process = (str, xy) => {\\n        if (xy)\\n            for (let x of xPoss)\\n                ans.push(`(${x}, ${str})`)\\n        else xPoss.push(str)\\n    }\\n    const parse = (str, xy) => {\\n        if (str.length === 1 || str[0] !== \"0\")\\n            process(str, xy)\\n        if (str.length > 1 && str[str.length-1] !== \"0\")\\n            process(str.slice(0,1) + \".\" + str.slice(1), xy)\\n        if (str.length > 2 && str[0] !== \"0\" && str[str.length-1] !== \"0\")\\n            for (let i = 2; i < str.length; i++)\\n                process(str.slice(0,i) + \".\" + str.slice(i), xy)\\n    }\\n    for (let i = 2; i < S.length - 1; i++) {\\n        let strs = [S.slice(1,i), S.slice(i, S.length - 1)]\\n        xPoss = []\\n        for (let j = 0; j < 2; j++)\\n            if (xPoss.length || !j) parse(strs[j], j)\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **32ms / 14.1MB** (beats 99% / 92%).\\n```python\\nclass Solution:\\n    def ambiguousCoordinates(self, S: str) -> List[str]:\\n        ans, xPoss = [], []\\n        def process(st: str, xy: int):\\n            if xy:\\n                for x in xPoss:\\n                    ans.append(\"(\" + x + \", \" + st + \")\")\\n            else: xPoss.append(st)\\n        def parse(st: str, xy: int):\\n            if len(st) == 1 or st[0] != \"0\":\\n                process(st, xy)\\n            if len(st) > 1 and st[-1] != \"0\":\\n                process(st[:1] + \".\" + st[1:], xy)\\n            if len(st) > 2 and st[0] != \"0\" and st[-1] != \"0\":\\n                for i in range(2, len(st)):\\n                    process(st[:i] + \".\" + st[i:], xy)  \\n        for i in range(2, len(S)-1):\\n            strs, xPoss = [S[1:i], S[i:-1]], []\\n            for j in range(2):\\n                if xPoss or not j: parse(strs[j], j)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **7ms / 39.5MB** (beats 100% / 91%).\\n```java\\nclass Solution {\\n    private List<String> xPoss, ans;\\n    public List<String> ambiguousCoordinates(String S) {\\n        ans = new ArrayList<>();\\n        for (int i = 2; i < S.length() - 1; i++) {\\n            String[] strs = {S.substring(1,i), S.substring(i, S.length() - 1)};\\n            xPoss = new ArrayList<>();\\n            for (int j = 0; j < 2; j++)\\n                if (xPoss.size() > 0 || j == 0) parse(strs[j], j);\\n        }\\n        return ans;\\n    }\\n    private void parse(String str, int xy) {\\n        if (str.length() == 1 || str.charAt(0) != \\'0\\')\\n            process(str, xy);\\n        if (str.length() > 1 && str.charAt(str.length()-1) != \\'0\\')\\n            process(str.substring(0,1) + \".\" + str.substring(1), xy);\\n        if (str.length() > 2 && str.charAt(0) != \\'0\\' && str.charAt(str.length()-1) != \\'0\\')\\n            for (int i = 2; i < str.length(); i++)\\n                process(str.substring(0,i) + \".\" + str.substring(i), xy);\\n    }\\n    private void process(String str, int xy) {\\n        if (xy > 0)\\n            for (String x : xPoss)\\n                ans.add(\"(\" + x + \", \" + str + \")\");\\n        else xPoss.add(str);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 9.1MB** (beats 100% / 95%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string S) {\\n        for (int i = 2; i < S.size() - 1; i++) {\\n            string strs[2] = {S.substr(1,i-1), S.substr(i,S.size()-i-1)};\\n            xPoss.clear();\\n            for (int j = 0; j < 2; j++)\\n                if (xPoss.size() || !j) parse(strs[j], j);\\n        }\\n        return ans;\\n    }\\nprivate:\\n    vector<string> ans, xPoss;\\n    void parse(string str, int xy) {\\n        if (str.size() == 1 || str.front() != \\'0\\')\\n            process(str, xy);\\n        if (str.size() > 1 && str.back() != \\'0\\')\\n            process(str.substr(0,1) + \".\" + str.substr(1), xy);\\n        if (str.size() > 2 && str.front() != \\'0\\' && str.back() != \\'0\\')\\n            for (int i = 2; i < str.size(); i++)\\n                process(str.substr(0,i) + \".\" + str.substr(i), xy);\\n    }\\n    void process(string str, int xy) {\\n        if (xy)\\n            for (auto x : xPoss)\\n                ans.push_back(\"(\" + x + \", \" + str + \")\");\\n        else xPoss.push_back(str);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar ambiguousCoordinates = function(S) {\\n    let ans = [], xPoss\\n    const process = (str, xy) => {\\n        if (xy)\\n            for (let x of xPoss)\\n                ans.push(`(${x}, ${str})`)\\n        else xPoss.push(str)\\n    }\\n    const parse = (str, xy) => {\\n        if (str.length === 1 || str[0] !== \"0\")\\n            process(str, xy)\\n        if (str.length > 1 && str[str.length-1] !== \"0\")\\n            process(str.slice(0,1) + \".\" + str.slice(1), xy)\\n        if (str.length > 2 && str[0] !== \"0\" && str[str.length-1] !== \"0\")\\n            for (let i = 2; i < str.length; i++)\\n                process(str.slice(0,i) + \".\" + str.slice(i), xy)\\n    }\\n    for (let i = 2; i < S.length - 1; i++) {\\n        let strs = [S.slice(1,i), S.slice(i, S.length - 1)]\\n        xPoss = []\\n        for (let j = 0; j < 2; j++)\\n            if (xPoss.length || !j) parse(strs[j], j)\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def ambiguousCoordinates(self, S: str) -> List[str]:\\n        ans, xPoss = [], []\\n        def process(st: str, xy: int):\\n            if xy:\\n                for x in xPoss:\\n                    ans.append(\"(\" + x + \", \" + st + \")\")\\n            else: xPoss.append(st)\\n        def parse(st: str, xy: int):\\n            if len(st) == 1 or st[0] != \"0\":\\n                process(st, xy)\\n            if len(st) > 1 and st[-1] != \"0\":\\n                process(st[:1] + \".\" + st[1:], xy)\\n            if len(st) > 2 and st[0] != \"0\" and st[-1] != \"0\":\\n                for i in range(2, len(st)):\\n                    process(st[:i] + \".\" + st[i:], xy)  \\n        for i in range(2, len(S)-1):\\n            strs, xPoss = [S[1:i], S[i:-1]], []\\n            for j in range(2):\\n                if xPoss or not j: parse(strs[j], j)\\n        return ans\\n```\n```java\\nclass Solution {\\n    private List<String> xPoss, ans;\\n    public List<String> ambiguousCoordinates(String S) {\\n        ans = new ArrayList<>();\\n        for (int i = 2; i < S.length() - 1; i++) {\\n            String[] strs = {S.substring(1,i), S.substring(i, S.length() - 1)};\\n            xPoss = new ArrayList<>();\\n            for (int j = 0; j < 2; j++)\\n                if (xPoss.size() > 0 || j == 0) parse(strs[j], j);\\n        }\\n        return ans;\\n    }\\n    private void parse(String str, int xy) {\\n        if (str.length() == 1 || str.charAt(0) != \\'0\\')\\n            process(str, xy);\\n        if (str.length() > 1 && str.charAt(str.length()-1) != \\'0\\')\\n            process(str.substring(0,1) + \".\" + str.substring(1), xy);\\n        if (str.length() > 2 && str.charAt(0) != \\'0\\' && str.charAt(str.length()-1) != \\'0\\')\\n            for (int i = 2; i < str.length(); i++)\\n                process(str.substring(0,i) + \".\" + str.substring(i), xy);\\n    }\\n    private void process(String str, int xy) {\\n        if (xy > 0)\\n            for (String x : xPoss)\\n                ans.add(\"(\" + x + \", \" + str + \")\");\\n        else xPoss.add(str);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string S) {\\n        for (int i = 2; i < S.size() - 1; i++) {\\n            string strs[2] = {S.substr(1,i-1), S.substr(i,S.size()-i-1)};\\n            xPoss.clear();\\n            for (int j = 0; j < 2; j++)\\n                if (xPoss.size() || !j) parse(strs[j], j);\\n        }\\n        return ans;\\n    }\\nprivate:\\n    vector<string> ans, xPoss;\\n    void parse(string str, int xy) {\\n        if (str.size() == 1 || str.front() != \\'0\\')\\n            process(str, xy);\\n        if (str.size() > 1 && str.back() != \\'0\\')\\n            process(str.substr(0,1) + \".\" + str.substr(1), xy);\\n        if (str.size() > 2 && str.front() != \\'0\\' && str.back() != \\'0\\')\\n            for (int i = 2; i < str.size(); i++)\\n                process(str.substr(0,i) + \".\" + str.substr(i), xy);\\n    }\\n    void process(string str, int xy) {\\n        if (xy)\\n            for (auto x : xPoss)\\n                ans.push_back(\"(\" + x + \", \" + str + \")\");\\n        else xPoss.push_back(str);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599950,
                "title": "c-modular-code-with-explanation",
                "content": "The logic is quite simple for this problem. You have to break the strings, at all possible points. Then you have to again break all the formed substrings, by placing dots in between the substrings, and following the `0` rules.\\n\\nExample - `(1234)`\\n\\nAfter removing the brackets, we get `s = 1234`. If you break the string at all points, the substrings you get are-\\n\\n`1  234`    ->   `1  234`,  `1  2.34`,  `1  23.4`\\n`12  34`    ->   `12  34`,  `12  3.4`,  `1.2  34`,  `1.2  3.4`\\n`123  4`    ->   `123  4`,  `1.23  4`,  `12.3  4`\\n\\nAs you can see I broke the substrings again to insert decimals. Of course you can\\'t have something like `1.` or `0001` or `1.00`. For that I use a `check function`.\\n\\nAs you can see after breaking the string at a particular point, I get two substrings `s1` and `s2`. Then I break both of them into `first` and `second`. `first` represents the part before the decimal and `second` is the part after that.\\n\\nFor `first`, if it\\'s length is greater than `1`, then first digit can\\'t be `0`. For example `0.xx` or `0` is valid, but something like `01.xx` or `000` is not acceptable. \\nSimilarly, for `second`, the last digit cant be `0`. For example `xx.0` or `xx.30` is not valid.\\n\\nThe reset is simple. I take 2 vectors `res1` (for storing the first coordinates) and `res2` (for storing the second coordinates), and combine them into the final vector.\\n\\n```\\nclass Solution {\\npublic:\\n\\t// issecword denotes if it is the second word (the part after the decimal)\\n    bool check(string s, bool issecword)\\n    {\\n        int n=s.length();\\n\\t\\t// Logic explained above\\n        if(issecword){\\n            if(n>0 && s[n-1]==\\'0\\') return false;\\n        }\\n        else{\\n            if(n>1 && s[0]==\\'0\\') return false;\\n        }\\n        return true;\\n    }\\n\\n    vector<string> ambiguousCoordinates(string S) {\\n        vector<string> res;\\n        S=S.substr(1,S.length()-2);  // Remove the brackets\\n        int n=S.length();\\n\\n        for(int i=1;i<n;i++){\\n            string s1=S.substr(0,i);\\n            string s2=S.substr(i);\\n            vector<string> res1, res2;\\n\\t\\t\\t\\n\\t\\t\\t// The full string without any decimal point can also be a coordinate.\\n\\t\\t\\t// But \\'01\\' or \\'001\\' is not possible.\\n            if(check(s1, false)) res1.push_back(s1);\\n            if(check(s2, false)) res2.push_back(s2);\\n\\t\\t\\t\\n\\t\\t\\t// First co-ordinate\\n            for(int j=1;j<s1.length();j++){\\n                string first=s1.substr(0,j);\\n                string second=s1.substr(j);\\n                if(check(first, false) && check(second, true)) res1.push_back(first+\".\"+second);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Second co-ordinate\\n            for(int j=1;j<s2.length();j++){\\n                string first=s2.substr(0,j);\\n                string second=s2.substr(j);\\n                if(check(first, false) && check(second, true)) res2.push_back(first+\".\"+second);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Combine all the results\\n            for(auto left:res1){\\n                for(auto right:res2){\\n                    res.push_back(\"(\" + left + \", \"+ right + \")\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n*Time Complexity* - `O(n^4)`  (Because `substr` function is `O(n)` worst case)\\n*Space Compexity* - `O(n)`",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// issecword denotes if it is the second word (the part after the decimal)\\n    bool check(string s, bool issecword)\\n    {\\n        int n=s.length();\\n\\t\\t// Logic explained above\\n        if(issecword){\\n            if(n>0 && s[n-1]==\\'0\\') return false;\\n        }\\n        else{\\n            if(n>1 && s[0]==\\'0\\') return false;\\n        }\\n        return true;\\n    }\\n\\n    vector<string> ambiguousCoordinates(string S) {\\n        vector<string> res;\\n        S=S.substr(1,S.length()-2);  // Remove the brackets\\n        int n=S.length();\\n\\n        for(int i=1;i<n;i++){\\n            string s1=S.substr(0,i);\\n            string s2=S.substr(i);\\n            vector<string> res1, res2;\\n\\t\\t\\t\\n\\t\\t\\t// The full string without any decimal point can also be a coordinate.\\n\\t\\t\\t// But \\'01\\' or \\'001\\' is not possible.\\n            if(check(s1, false)) res1.push_back(s1);\\n            if(check(s2, false)) res2.push_back(s2);\\n\\t\\t\\t\\n\\t\\t\\t// First co-ordinate\\n            for(int j=1;j<s1.length();j++){\\n                string first=s1.substr(0,j);\\n                string second=s1.substr(j);\\n                if(check(first, false) && check(second, true)) res1.push_back(first+\".\"+second);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Second co-ordinate\\n            for(int j=1;j<s2.length();j++){\\n                string first=s2.substr(0,j);\\n                string second=s2.substr(j);\\n                if(check(first, false) && check(second, true)) res2.push_back(first+\".\"+second);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Combine all the results\\n            for(auto left:res1){\\n                for(auto right:res2){\\n                    res.push_back(\"(\" + left + \", \"+ right + \")\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934654,
                "title": "python3-valid-numbers",
                "content": "Algo\\nThe key is to deal with extraneous zeros. Below rule gives the what\\'s required\\n1) if a string has length 1, return it;\\n2) if a string with length larger than 1 and starts and ends with 0, it cannot contain valid number;\\n3) if a string starts with 0, return `0.xxx`;\\n4) if a string ends with 0, return `xxx0`;\\n5) otherwise, put decimal point in the `n-1` places. \\n\\nImplementation \\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s.strip(\"(\").strip(\")\")\\n        \\n        def fn(s): \\n            \"\"\"Return valid numbers from s.\"\"\"\\n            if len(s) == 1: return [s]\\n            if s.startswith(\"0\") and s.endswith(\"0\"): return []\\n            if s.startswith(\"0\"): return [s[:1] + \".\" + s[1:]]\\n            if s.endswith(\"0\"): return [s]\\n            return [s[:i] + \".\" + s[i:] for i in range(1, len(s))] + [s]\\n        \\n        ans = []\\n        for i in range(1, len(s)): \\n            for x in fn(s[:i]):\\n                for y in fn(s[i:]): \\n                    ans.append(f\"({x}, {y})\")\\n        return ans  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s.strip(\"(\").strip(\")\")\\n        \\n        def fn(s): \\n            \"\"\"Return valid numbers from s.\"\"\"\\n            if len(s) == 1: return [s]\\n            if s.startswith(\"0\") and s.endswith(\"0\"): return []\\n            if s.startswith(\"0\"): return [s[:1] + \".\" + s[1:]]\\n            if s.endswith(\"0\"): return [s]\\n            return [s[:i] + \".\" + s[i:] for i in range(1, len(s))] + [s]\\n        \\n        ans = []\\n        for i in range(1, len(s)): \\n            for x in fn(s[:i]):\\n                for y in fn(s[i:]): \\n                    ans.append(f\"({x}, {y})\")\\n        return ans  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205957,
                "title": "rust-0-4ms-100-runtime-iterative-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn ambiguous_coordinates(s: String) -> Vec<String> {\\n        let s = &s.as_bytes()[1..s.len() - 1]; // ignore the parenthesis around the coords\\n        (1..s.len()).fold(vec![], |mut acc, commai| {\\n            let (x, y) = s.split_at(commai);\\n            (0..x.len())\\n                .filter_map(|doti| Self::make_coord(x, doti))\\n                .for_each(|x| {\\n                    (0..y.len())\\n                        .filter_map(|doti| Self::make_coord(y, doti))\\n                        .for_each(|y| acc.push(format!(\"({}, {})\", x, y)))\\n                });\\n            acc\\n        })\\n    }\\n\\n    fn make_coord(s: &[u8], doti: usize) -> Option<String> {\\n        if (s.len() == 1 || doti == 1 || s[0] != b\\'0\\') && (doti == 0 || s[s.len() - 1] != b\\'0\\') {\\n            let (l, r) = s.split_at(doti);\\n            let l = unsafe { String::from_utf8_unchecked(l.into()) }; // these are safe, as s is\\n            let r = unsafe { String::from_utf8_unchecked(r.into()) }; // always valid ASCII\\n            Some(format!(\"{}{}{}\", l, if l.is_empty() { \"\" } else { \".\" }, r))\\n        } else {\\n            None\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Iterator"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn ambiguous_coordinates(s: String) -> Vec<String> {\\n        let s = &s.as_bytes()[1..s.len() - 1]; // ignore the parenthesis around the coords\\n        (1..s.len()).fold(vec![], |mut acc, commai| {\\n            let (x, y) = s.split_at(commai);\\n            (0..x.len())\\n                .filter_map(|doti| Self::make_coord(x, doti))\\n                .for_each(|x| {\\n                    (0..y.len())\\n                        .filter_map(|doti| Self::make_coord(y, doti))\\n                        .for_each(|y| acc.push(format!(\"({}, {})\", x, y)))\\n                });\\n            acc\\n        })\\n    }\\n\\n    fn make_coord(s: &[u8], doti: usize) -> Option<String> {\\n        if (s.len() == 1 || doti == 1 || s[0] != b\\'0\\') && (doti == 0 || s[s.len() - 1] != b\\'0\\') {\\n            let (l, r) = s.split_at(doti);\\n            let l = unsafe { String::from_utf8_unchecked(l.into()) }; // these are safe, as s is\\n            let r = unsafe { String::from_utf8_unchecked(r.into()) }; // always valid ASCII\\n            Some(format!(\"{}{}{}\", l, if l.is_empty() { \"\" } else { \".\" }, r))\\n        } else {\\n            None\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1207300,
                "title": "java-simple-and-easy-to-understand-solution-8-ms-faster-than-79-79-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        \\n        String digits = s.substring(1, s.length() - 1);\\n        \\n        List<String> result = new ArrayList();\\n        if(digits.length() < 2) return result;\\n        \\n        \\n        for(int i = 1; i < digits.length(); i++){\\n            //split the digits in 2 parts\\n            String left = digits.substring(0, i);\\n            String right = digits.substring(i);\\n            \\n            //check any of part contains only zeroes \\n            if((left.length() > 1 && Long.valueOf(left) == 0) || (right.length() > 1 && Long.valueOf(right) == 0)) continue;\\n            \\n            \\n            List<String> leftCoordinates = getValidCoordinates(left);\\n            if(leftCoordinates.size() == 0) continue;\\n            \\n            List<String> rightCoordinates = getValidCoordinates(right);\\n            if(rightCoordinates.size() == 0) continue;\\n            \\n            \\n            for(String leftCor : leftCoordinates){\\n                for(String rightCor : rightCoordinates){\\n                    //concatenate right and left coordinate\\n                    StringBuilder sb = new StringBuilder();\\n                        sb\\n                        .append(\\'(\\')\\n                        .append(leftCor)\\n                        .append(\", \")\\n                        .append(rightCor)\\n                        .append(\\')\\');\\n                    //String coordinate = \"(\" + leftCor + \", \" + rightCor + \")\";\\n                    //result.add(coordinate);\\n                    \\n                    result.add(sb.toString());\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        \\n        return result;\\n    }\\n    \\n    private List<String> getValidCoordinates(String str){\\n        \\n        List<String> result = new ArrayList();\\n        \\n        int n = str.length();\\n        \\n        if(n == 1) {\\n            result.add(str);\\n            return result;\\n        }\\n        \\n        if(str.charAt(0) == \\'0\\'){\\n            if(str.charAt(n - 1) == \\'0\\'){\\n                return result;\\n            }\\n            \\n            String coordinate = \"0.\" + str.substring(1); \\n            result.add(coordinate);\\n            return result;\\n        }\\n        \\n        if(str.charAt(n - 1) == \\'0\\'){\\n            result.add(str);\\n            return result;\\n        }\\n        \\n        \\n        for(int i = 1; i < n; i++){\\n            String coordinate = str.substring(0, i) + \".\" + str.substring(i); \\n            result.add(coordinate);\\n        }\\n        result.add(str);\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        \\n        String digits = s.substring(1, s.length() - 1);\\n        \\n        List<String> result = new ArrayList();\\n        if(digits.length() < 2) return result;\\n        \\n        \\n        for(int i = 1; i < digits.length(); i++){\\n            //split the digits in 2 parts\\n            String left = digits.substring(0, i);\\n            String right = digits.substring(i);\\n            \\n            //check any of part contains only zeroes \\n            if((left.length() > 1 && Long.valueOf(left) == 0) || (right.length() > 1 && Long.valueOf(right) == 0)) continue;\\n            \\n            \\n            List<String> leftCoordinates = getValidCoordinates(left);\\n            if(leftCoordinates.size() == 0) continue;\\n            \\n            List<String> rightCoordinates = getValidCoordinates(right);\\n            if(rightCoordinates.size() == 0) continue;\\n            \\n            \\n            for(String leftCor : leftCoordinates){\\n                for(String rightCor : rightCoordinates){\\n                    //concatenate right and left coordinate\\n                    StringBuilder sb = new StringBuilder();\\n                        sb\\n                        .append(\\'(\\')\\n                        .append(leftCor)\\n                        .append(\", \")\\n                        .append(rightCor)\\n                        .append(\\')\\');\\n                    //String coordinate = \"(\" + leftCor + \", \" + rightCor + \")\";\\n                    //result.add(coordinate);\\n                    \\n                    result.add(sb.toString());\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        \\n        return result;\\n    }\\n    \\n    private List<String> getValidCoordinates(String str){\\n        \\n        List<String> result = new ArrayList();\\n        \\n        int n = str.length();\\n        \\n        if(n == 1) {\\n            result.add(str);\\n            return result;\\n        }\\n        \\n        if(str.charAt(0) == \\'0\\'){\\n            if(str.charAt(n - 1) == \\'0\\'){\\n                return result;\\n            }\\n            \\n            String coordinate = \"0.\" + str.substring(1); \\n            result.add(coordinate);\\n            return result;\\n        }\\n        \\n        if(str.charAt(n - 1) == \\'0\\'){\\n            result.add(str);\\n            return result;\\n        }\\n        \\n        \\n        for(int i = 1; i < n; i++){\\n            String coordinate = str.substring(0, i) + \".\" + str.substring(i); \\n            result.add(coordinate);\\n        }\\n        result.add(str);\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1512858,
                "title": "python-generate-beats-94-runtime-and-91-memory",
                "content": "For a string slice, we generate a list of numbers with following rules:\\n1. If the slice is `\\'0\\'`, then return `[\\'0\\']`\\n2. If the slice starts and ends with `\\'0\\'`, we generate nothing. Because we cannot have `0.****0`\\n3. If the slice starts with `\\'0\\'`, then the only number we generate is `0.****`\\n4. If the slice does not start with `\\'0\\'`, but ends with `\\'0\\'`, which means we can only generate `*****0` without decimal point. Otherwise, we\\'d end up with `***.***0`\\n5. If the slice does not start with or end with `\\'0\\'`, then we can generate lots of numbers by inserting the decimal points at any position. For example, using `ABCD` as a base, then we can generate `A.BCD`, `AB.CD`, `ABC.D`.\\n```python\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1] # remove parenthesis\\n        def generateNumbers(start, end):\\n            if s[start] == \\'0\\': \\n                if end == start: return [\\'0\\'] # rule 1\\n                elif s[end] == \\'0\\': return [] # rule 2\\n                else: return [f\\'{s[start]}.{s[start+1:end+1]}\\'] # rule 3\\n            base = s[start:end+1]\\n            res = [base]\\n            if s[end] != \\'0\\': # rule 4\\n                for i in range(1, len(base)): # rule 5\\n                    res.append(f\\'{base[:i]}.{base[i:]}\\')\\n            return res\\n        size = len(s)\\n        res = []\\n        for split in range(1, size):\\n            for first in generateNumbers(0, split - 1):\\n                for second in generateNumbers(split, size - 1):\\n                    res.append(f\\'({first}, {second})\\')\\n        return res\\n            \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1] # remove parenthesis\\n        def generateNumbers(start, end):\\n            if s[start] == \\'0\\': \\n                if end == start: return [\\'0\\'] # rule 1\\n                elif s[end] == \\'0\\': return [] # rule 2\\n                else: return [f\\'{s[start]}.{s[start+1:end+1]}\\'] # rule 3\\n            base = s[start:end+1]\\n            res = [base]\\n            if s[end] != \\'0\\': # rule 4\\n                for i in range(1, len(base)): # rule 5\\n                    res.append(f\\'{base[:i]}.{base[i:]}\\')\\n            return res\\n        size = len(s)\\n        res = []\\n        for split in range(1, size):\\n            for first in generateNumbers(0, split - 1):\\n                for second in generateNumbers(split, size - 1):\\n                    res.append(f\\'({first}, {second})\\')\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206637,
                "title": "java-simple-split-and-apply-dots-approach-beats-80-with-explaination",
                "content": "Key Intuition: \\n1. Split the string up in 2 parts in all possible ways. \\n2. Now add dots at various possible places in each split part. Remember to skip instances where pre dot part has leading zeros and post dot part has trailing zeros. Also do not forget to include the complete string itself without the dot in case it has no leading zeros. \\n3. Find the cross product of list of strings obtained by putting the dot at various places in the left (xcord) and right (ycord) coordinates.\\n4. Return this list of cross products of possible string combinations.\\n```\\n/*\\nKey Intuition: \\n1. Split the string up in 2 parts in all possible ways. \\n2. Now add dots at various possible places in each split part. Remember to skip instances where pre dot part has leading zeros and post dot part has trailing zeros. Also do not forget to include the complete string itself without the dow in case it has no leading zeros. \\n3. Find the cross product of list of strings obtained by putting the dot at various places in the left (xcord) and right (ycord) coordinates.\\n4. Return this list of cross products of possible string combinations.\\n\\n*/\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> result = new ArrayList<>();\\n        \\n        //Split the string up in 2 parts in all possible ways. \\n        List<String[]> list = split(s.substring(1, s.length() - 1));\\n\\n        for(String[] split : list) {\\n            \\n            //Now add dots at various possible places in each split part. Remember to skip instances where pre dot part has leading zeros and post dot part has trailing zeros. Also do not forget to include the complete string itself without the dot in case it has no leading zeros.\\n            List<String> xcords = dot(split[0]);\\n            List<String> ycords = dot(split[1]);\\n\\t\\t\\t\\n\\t\\t\\t//Find the cross product of list of strings obtained by putting the dot at various places in the left (xcord) and right (ycord) coordinates.\\n            for(String xcord : xcords) {\\n                for(String ycord : ycords) {\\n                    result.add(\"(\" + xcord + \", \" + ycord + \")\");\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    //Split the string up in 2 parts in all possible ways. \\n    private List<String[]> split(String s) {\\n        List<String[]> list = new ArrayList<>();\\n        for(int i = 1; i < s.length(); i++) {\\n            String[] splits = new String[2];\\n            splits[0] = s.substring(0, i);\\n            splits[1] = s.substring(i);\\n            list.add(splits);\\n        }\\n        return list;\\n    }\\n    \\n    private List<String> dot(String s) {\\n        \\n        List<String> list = new ArrayList<>();\\n        \\n        // do not forget to include the complete string itself without the dow in case it has no leading zeros.\\n        if(!s.startsWith(\"0\") || s.length() == 1) {\\n            list.add(s);\\n        }\\n        \\n        if(s.length() == 1) {\\n            return list;\\n        }\\n        \\n        //Now add dots at various possible places in each split part.\\n        for(int i = 1; i < s.length(); i++) {\\n            \\n            //Remember to skip instances where pre dot part has leading zeros and post dot part has trailing zeros\\n            String preDot = s.substring(0, i);\\n            if(preDot.startsWith(\"0\") && preDot.length() > 1) {\\n                continue;\\n            }\\n            String postDot = s.substring(i);\\n            if(postDot.endsWith(\"0\")) {\\n                continue;\\n            }\\n            list.add(preDot + \".\" + postDot);\\n        }\\n        return list;\\n    }\\n}\\n```\\n\\n**Please upvote if this helped**",
                "solutionTags": [],
                "code": "```\\n/*\\nKey Intuition: \\n1. Split the string up in 2 parts in all possible ways. \\n2. Now add dots at various possible places in each split part. Remember to skip instances where pre dot part has leading zeros and post dot part has trailing zeros. Also do not forget to include the complete string itself without the dow in case it has no leading zeros. \\n3. Find the cross product of list of strings obtained by putting the dot at various places in the left (xcord) and right (ycord) coordinates.\\n4. Return this list of cross products of possible string combinations.\\n\\n*/\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> result = new ArrayList<>();\\n        \\n        //Split the string up in 2 parts in all possible ways. \\n        List<String[]> list = split(s.substring(1, s.length() - 1));\\n\\n        for(String[] split : list) {\\n            \\n            //Now add dots at various possible places in each split part. Remember to skip instances where pre dot part has leading zeros and post dot part has trailing zeros. Also do not forget to include the complete string itself without the dot in case it has no leading zeros.\\n            List<String> xcords = dot(split[0]);\\n            List<String> ycords = dot(split[1]);\\n\\t\\t\\t\\n\\t\\t\\t//Find the cross product of list of strings obtained by putting the dot at various places in the left (xcord) and right (ycord) coordinates.\\n            for(String xcord : xcords) {\\n                for(String ycord : ycords) {\\n                    result.add(\"(\" + xcord + \", \" + ycord + \")\");\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    //Split the string up in 2 parts in all possible ways. \\n    private List<String[]> split(String s) {\\n        List<String[]> list = new ArrayList<>();\\n        for(int i = 1; i < s.length(); i++) {\\n            String[] splits = new String[2];\\n            splits[0] = s.substring(0, i);\\n            splits[1] = s.substring(i);\\n            list.add(splits);\\n        }\\n        return list;\\n    }\\n    \\n    private List<String> dot(String s) {\\n        \\n        List<String> list = new ArrayList<>();\\n        \\n        // do not forget to include the complete string itself without the dow in case it has no leading zeros.\\n        if(!s.startsWith(\"0\") || s.length() == 1) {\\n            list.add(s);\\n        }\\n        \\n        if(s.length() == 1) {\\n            return list;\\n        }\\n        \\n        //Now add dots at various possible places in each split part.\\n        for(int i = 1; i < s.length(); i++) {\\n            \\n            //Remember to skip instances where pre dot part has leading zeros and post dot part has trailing zeros\\n            String preDot = s.substring(0, i);\\n            if(preDot.startsWith(\"0\") && preDot.length() > 1) {\\n                continue;\\n            }\\n            String postDot = s.substring(i);\\n            if(postDot.endsWith(\"0\")) {\\n                continue;\\n            }\\n            list.add(preDot + \".\" + postDot);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206060,
                "title": "python-well-explained-97-33-faster-easy-understanding",
                "content": "## **Idea :**\\nSplit the string into left and right , then create the possible string seperately , then merge .\\n\\n* When there is only one letter in the string , directly return itself.\\n* when the first and last letter is \\'0\\', then it\\'s impossible to create a valid string, return []\\n* when the first letter is \\'0\\', then we only have one choice : \\'0.xxxx\\'\\n* when the last letter is \\'0\\', then we only have one choice , the string itself.\\n* all other , we can put \\'.\\' between any two letters.\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\n        def create(num):\\n            l=len(num)\\n            if l==1:\\n                return [num]\\n            if num[0]==\"0\" and num[-1]==\"0\":\\n                return []\\n            if num[0]==\"0\":\\n                return [\"0.\"+num[1:]]\\n            if num[-1]==\"0\":\\n                return [num]\\n            local=[num]\\n            for i in range(1,len(num)):\\n                local.append(num[:i]+\".\"+num[i:])\\n            return local\\n        \\n        s=s[1:-1]\\n        n=len(s)\\n        res=[]\\n        for i in range(1,n):\\n            left = create(s[:i])\\n            right= create(s[i:])\\n            if not left or not right:\\n                continue\\n            for l in left:\\n                for r in right:\\n                    res.append(f\\'({l}, {r})\\')\\n        return res\\n\\nThank You!!\\nIf you dont get it , feel free to ask.",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "class Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\n        def create(num):\\n            l=len(num)\\n            if l==1:\\n                return [num]\\n            if num[0]==\"0\" and num[-1]==\"0\":\\n                return []\\n            if num[0]==\"0\":\\n                return [\"0.\"+num[1:]]\\n            if num[-1]==\"0\":\\n                return [num]\\n            local=[num]\\n            for i in range(1,len(num)):\\n                local.append(num[:i]+\".\"+num[i:])\\n            return local\\n        \\n        s=s[1:-1]\\n        n=len(s)\\n        res=[]\\n        for i in range(1,n):\\n            left = create(s[:i])\\n            right= create(s[i:])\\n            if not left or not right:\\n                continue\\n            for l in left:\\n                for r in right:\\n                    res.append(f\\'({l}",
                "codeTag": "Java"
            },
            {
                "id": 1205884,
                "title": "modular-programming-easy-to-read-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1, s.length() - 2);\\n        vector<string> result;\\n        for (int i = 1; i < s.length(); i++)\\n        {\\n            string str1 = s.substr(0, i), str2 = s.substr(i);\\n            vector<string> res1 = genValid(str1), res2 = genValid(str2);\\n\\n            for (auto& s1 : res1)\\n                for (auto& s2 : res2)\\n                    genResult(s1, s2, result);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    vector<string> genValid(string& str)\\n    {\\n        vector<string> res;\\n        if (valid(str))\\n            res.push_back(str);\\n        \\n        for (int i = 1; i < str.length(); i++)\\n        {\\n            string cur = str.substr(0, i) + \".\" + str.substr(i);\\n            if (valid(cur))\\n                res.emplace_back(cur);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    bool valid(string& str)\\n    {\\n        if (str.length() > 1 && str[0] == \\'0\\' && str[1] != \\'.\\')\\n            return false;\\n\\n        if (str.back() == \\'0\\')\\n        {\\n            for (int i = str.length() - 1; i >= 0; i--)\\n                if (str[i] == \\'.\\')\\n                    return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    void genResult(string& str1, string& str2, vector<string>& result)\\n    {\\n        result.emplace_back(\"(\" + str1 + \", \" + str2 + \")\");\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1, s.length() - 2);\\n        vector<string> result;\\n        for (int i = 1; i < s.length(); i++)\\n        {\\n            string str1 = s.substr(0, i), str2 = s.substr(i);\\n            vector<string> res1 = genValid(str1), res2 = genValid(str2);\\n\\n            for (auto& s1 : res1)\\n                for (auto& s2 : res2)\\n                    genResult(s1, s2, result);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    vector<string> genValid(string& str)\\n    {\\n        vector<string> res;\\n        if (valid(str))\\n            res.push_back(str);\\n        \\n        for (int i = 1; i < str.length(); i++)\\n        {\\n            string cur = str.substr(0, i) + \".\" + str.substr(i);\\n            if (valid(cur))\\n                res.emplace_back(cur);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    bool valid(string& str)\\n    {\\n        if (str.length() > 1 && str[0] == \\'0\\' && str[1] != \\'.\\')\\n            return false;\\n\\n        if (str.back() == \\'0\\')\\n        {\\n            for (int i = str.length() - 1; i >= 0; i--)\\n                if (str[i] == \\'.\\')\\n                    return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    void genResult(string& str1, string& str2, vector<string>& result)\\n    {\\n        result.emplace_back(\"(\" + str1 + \", \" + str2 + \")\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1115781,
                "title": "c-solution-with-some-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string S) {\\n        // First get rid of paranthesis at the both end\\n        S.erase(0, 1);\\n        S.pop_back();\\n        vector<string> result;\\n        vector<pair<string, string>> valids;\\n        int size = S.size();\\n        // Without dots\\n        for (int i = 0; i < size - 1; i++) {\\n            string A = S.substr(0, i + 1);\\n            string B = S.substr(i + 1, size - i + 1);\\n            valids.push_back({A, B});\\n        }\\n        // With Dots\\n        for (int i = 0; i < valids.size(); i++) {\\n            vector<string> left = { valids[i].first }, right = { valids[i].second };\\n            if (valids[i].first.size() > 1) {\\n                for (int j = 1; j < valids[i].first.size(); j++) {\\n                    string withDotL = valids[i].first;\\n                    withDotL.insert(j, 1, \\'.\\');\\n                    left.push_back(withDotL);\\n                }\\n            }\\n            if (valids[i].second.size() > 1) {\\n                for (int j = 1; j < valids[i].second.size(); j++) {\\n                    string withDotR = valids[i].second;\\n                    withDotR.insert(j, 1, \\'.\\');\\n                    right.push_back(withDotR);\\n                }\\n            }\\n            // Start checking validity\\n            for (int i = 0; i < left.size(); i++) {\\n                for (int j = 0; j < right.size(); j++) {\\n                    if (isValid(left[i]) && isValid(right[j])) {\\n                        result.push_back(\"(\" + left[i] + \", \" + right[j] + \")\");\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    // Valid 0, 0.X\\n    // Invalid: \"5.0\", \"00\", \"0.0\", \"0.00\", \"1.0\", \"001\", \"00.01\"\\n    bool isValid(string &s) {\\n        // Single char\\n        if (s.size() == 1) {\\n            return true;\\n        }\\n        // Invalid case: 0xxx0\\n        if (s[0] == \\'0\\') {\\n            // Only valid 0.xxx\\n            if (s[1] != \\'.\\') {\\n                return false;\\n            }\\n            // 00, 0xx0\\n            if (s.back() == \\'0\\' || s[1] == \\'0\\') {\\n                return false;\\n            }\\n            return true;\\n        }\\n        // Invalid case: xxx.0\\n        if (s.back() == \\'0\\') {\\n            // Only valid case xxx0\\n            if (s.find(\\'.\\') == std::string::npos) {\\n                return true;\\n            }\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string S) {\\n        // First get rid of paranthesis at the both end\\n        S.erase(0, 1);\\n        S.pop_back();\\n        vector<string> result;\\n        vector<pair<string, string>> valids;\\n        int size = S.size();\\n        // Without dots\\n        for (int i = 0; i < size - 1; i++) {\\n            string A = S.substr(0, i + 1);\\n            string B = S.substr(i + 1, size - i + 1);\\n            valids.push_back({A, B});\\n        }\\n        // With Dots\\n        for (int i = 0; i < valids.size(); i++) {\\n            vector<string> left = { valids[i].first }, right = { valids[i].second };\\n            if (valids[i].first.size() > 1) {\\n                for (int j = 1; j < valids[i].first.size(); j++) {\\n                    string withDotL = valids[i].first;\\n                    withDotL.insert(j, 1, \\'.\\');\\n                    left.push_back(withDotL);\\n                }\\n            }\\n            if (valids[i].second.size() > 1) {\\n                for (int j = 1; j < valids[i].second.size(); j++) {\\n                    string withDotR = valids[i].second;\\n                    withDotR.insert(j, 1, \\'.\\');\\n                    right.push_back(withDotR);\\n                }\\n            }\\n            // Start checking validity\\n            for (int i = 0; i < left.size(); i++) {\\n                for (int j = 0; j < right.size(); j++) {\\n                    if (isValid(left[i]) && isValid(right[j])) {\\n                        result.push_back(\"(\" + left[i] + \", \" + right[j] + \")\");\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    // Valid 0, 0.X\\n    // Invalid: \"5.0\", \"00\", \"0.0\", \"0.00\", \"1.0\", \"001\", \"00.01\"\\n    bool isValid(string &s) {\\n        // Single char\\n        if (s.size() == 1) {\\n            return true;\\n        }\\n        // Invalid case: 0xxx0\\n        if (s[0] == \\'0\\') {\\n            // Only valid 0.xxx\\n            if (s[1] != \\'.\\') {\\n                return false;\\n            }\\n            // 00, 0xx0\\n            if (s.back() == \\'0\\' || s[1] == \\'0\\') {\\n                return false;\\n            }\\n            return true;\\n        }\\n        // Invalid case: xxx.0\\n        if (s.back() == \\'0\\') {\\n            // Only valid case xxx0\\n            if (s.find(\\'.\\') == std::string::npos) {\\n                return true;\\n            }\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861233,
                "title": "javascript-100-with-comments",
                "content": "```\\nfunction solution(S) {\\n    S = S.slice(1, S.length - 1);\\n    let arr = [];\\n\\n    // Separate in 2 parts. All possible ways (just put comma in all possible places).\\n    for (let i = 1; i < S.length; i++) {\\n        // get all possible (distinct) numbers that a string can be converted to. Do this for string1 and string2\\n        let p1 = combos(S.slice(0, i));\\n        let p2 = combos(S.slice(i));\\n\\n\\n        if (p1.length && p2.length) {\\n            for (let x1 of p1) {\\n                for (let x2 of p2) {\\n                    arr.push([x1, x2]);\\n                }\\n            }\\n        }\\n    }\\n    return arr.map(e => `(${e[0]}, ${e[1]})`);\\n}\\n\\n// get all possible (distinct) numbers that a string can be converted to.\\nfunction combos(s) {\\n    let set = new Set(); // Use set so that it keeps distinct values\\n    if (String(Number(s)).length === s.length) set.add(Number(s));\\n    if (s.length === 1) return [...set];\\n\\n    // Just put a dot in all possible places.\\n    for (let i = 1; i < s.length; i++) {\\n        let x = Number(s.slice(0, i) + \\'.\\' + s.slice(i));\\n\\n        // Don\\'t add if some digits were lost during convert (e.g. 0012 --> 12)\\n        if (String(x).length === (s.length + 1)) set.add(x);\\n    }\\n    return [...set];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunction solution(S) {\\n    S = S.slice(1, S.length - 1);\\n    let arr = [];\\n\\n    // Separate in 2 parts. All possible ways (just put comma in all possible places).\\n    for (let i = 1; i < S.length; i++) {\\n        // get all possible (distinct) numbers that a string can be converted to. Do this for string1 and string2\\n        let p1 = combos(S.slice(0, i));\\n        let p2 = combos(S.slice(i));\\n\\n\\n        if (p1.length && p2.length) {\\n            for (let x1 of p1) {\\n                for (let x2 of p2) {\\n                    arr.push([x1, x2]);\\n                }\\n            }\\n        }\\n    }\\n    return arr.map(e => `(${e[0]}, ${e[1]})`);\\n}\\n\\n// get all possible (distinct) numbers that a string can be converted to.\\nfunction combos(s) {\\n    let set = new Set(); // Use set so that it keeps distinct values\\n    if (String(Number(s)).length === s.length) set.add(Number(s));\\n    if (s.length === 1) return [...set];\\n\\n    // Just put a dot in all possible places.\\n    for (let i = 1; i < s.length; i++) {\\n        let x = Number(s.slice(0, i) + \\'.\\' + s.slice(i));\\n\\n        // Don\\'t add if some digits were lost during convert (e.g. 0012 --> 12)\\n        if (String(x).length === (s.length + 1)) set.add(x);\\n    }\\n    return [...set];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 641809,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string s, bool issecword){\\n        int n=s.length();\\n\\t\\t// Logic explained above\\n        if(issecword){\\n            if(n>0 && s[n-1]==\\'0\\') return false;\\n        }\\n        else{\\n            if(n>1 && s[0]==\\'0\\') return false;\\n        }\\n        return true;\\n    }\\n\\n    vector<string> ambiguousCoordinates(string S) {\\n        vector<string> res;\\n        S=S.substr(1,S.length()-2);\\n        int n=S.length();\\n\\n        for(int i=1;i<n;i++){\\n            string s1=S.substr(0,i);\\n            string s2=S.substr(i);\\n            vector<string> res1, res2;\\n\\t\\t\\t\\n            if(check(s1, false)) res1.push_back(s1);\\n            if(check(s2, false)) res2.push_back(s2);\\n\\t\\t\\t\\n            for(int j=1;j<s1.length();j++){\\n                string first=s1.substr(0,j);\\n                string second=s1.substr(j);\\n                if(check(first, false) && check(second, true)) res1.push_back(first+\".\"+second);\\n            }\\n            \\n            for(int j=1;j<s2.length();j++){\\n                string first=s2.substr(0,j);\\n                string second=s2.substr(j);\\n                if(check(first, false) && check(second, true)) res2.push_back(first+\".\"+second);\\n            }\\n\\t\\t\\t\\n            for(auto left:res1){\\n                for(auto right:res2){\\n                    res.push_back(\"(\" + left + \", \"+ right + \")\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string s, bool issecword){\\n        int n=s.length();\\n\\t\\t// Logic explained above\\n        if(issecword){\\n            if(n>0 && s[n-1]==\\'0\\') return false;\\n        }\\n        else{\\n            if(n>1 && s[0]==\\'0\\') return false;\\n        }\\n        return true;\\n    }\\n\\n    vector<string> ambiguousCoordinates(string S) {\\n        vector<string> res;\\n        S=S.substr(1,S.length()-2);\\n        int n=S.length();\\n\\n        for(int i=1;i<n;i++){\\n            string s1=S.substr(0,i);\\n            string s2=S.substr(i);\\n            vector<string> res1, res2;\\n\\t\\t\\t\\n            if(check(s1, false)) res1.push_back(s1);\\n            if(check(s2, false)) res2.push_back(s2);\\n\\t\\t\\t\\n            for(int j=1;j<s1.length();j++){\\n                string first=s1.substr(0,j);\\n                string second=s1.substr(j);\\n                if(check(first, false) && check(second, true)) res1.push_back(first+\".\"+second);\\n            }\\n            \\n            for(int j=1;j<s2.length();j++){\\n                string first=s2.substr(0,j);\\n                string second=s2.substr(j);\\n                if(check(first, false) && check(second, true)) res2.push_back(first+\".\"+second);\\n            }\\n\\t\\t\\t\\n            for(auto left:res1){\\n                for(auto right:res2){\\n                    res.push_back(\"(\" + left + \", \"+ right + \")\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507569,
                "title": "accepted-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        public IList<string> AmbiguousCoordinates(string s)\\n        {\\n            s = s.Substring(1, s.Length - 2);\\n            IList<string> res = new List<string>();\\n            for (int i = 1; i < s.Length; i++)\\n            {\\n                var left = s.Substring(0, i);\\n                var right = s.Substring(i, s.Length - i);\\n\\n\\n                IList<string> lefts = new List<string>();\\n                IList<string> rights = new List<string>();\\n\\n                if (!(left.Length >= 2 && left[0] == \\'0\\'))\\n                {\\n                    lefts.Add(left);\\n                }\\n\\n\\n                if (!(right.Length >= 2 && right[0] == \\'0\\'))\\n                {\\n                    rights.Add(right);\\n                }\\n\\n                for (int j = 1; j < left.Length; j++)\\n                {\\n                    var leftLeft = left.Substring(0, j);\\n                    if (j > 1 && leftLeft[0] == \\'0\\')\\n                    {\\n                        continue;\\n                    }\\n                    var leftRight = left.Substring(j, left.Length - j);\\n\\n                    if (leftRight.Length > 1 && leftRight[leftRight.Length - 1] == \\'0\\')\\n                    {\\n                        continue;\\n                    }\\n\\n\\n                    var cand = $\"{leftLeft}.{leftRight}\";\\n                    if (int.Parse(leftRight) == 0)\\n                    {\\n                        continue;\\n                    }\\n                    lefts.Add(cand);\\n                }\\n\\n\\n                for (int j = 1; j < right.Length; j++)\\n                {\\n                    var rightLeft = right.Substring(0, j);\\n                    if (j > 1 && rightLeft[0] == \\'0\\')\\n                    {\\n                        continue;\\n                    }\\n                    var rightRight = right.Substring(j, right.Length - j);\\n\\n                    if (rightRight.Length > 1 && rightRight[rightRight.Length - 1] == \\'0\\')\\n                    {\\n                        continue;\\n                    }\\n\\n                    var cand = $\"{rightLeft}.{rightRight}\";\\n                    if (int.Parse(rightRight) == 0)\\n                    {\\n                        continue;\\n                    }\\n                    rights.Add(cand);\\n                }\\n\\n                foreach (var l in lefts)\\n                {\\n                    foreach (var r in rights)\\n                    {\\n                        res.Add($\"({l}, {r})\");\\n                    }\\n                }\\n\\n            }\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        public IList<string> AmbiguousCoordinates(string s)\\n        {\\n            s = s.Substring(1, s.Length - 2);\\n            IList<string> res = new List<string>();\\n            for (int i = 1; i < s.Length; i++)\\n            {\\n                var left = s.Substring(0, i);\\n                var right = s.Substring(i, s.Length - i);\\n\\n\\n                IList<string> lefts = new List<string>();\\n                IList<string> rights = new List<string>();\\n\\n                if (!(left.Length >= 2 && left[0] == \\'0\\'))\\n                {\\n                    lefts.Add(left);\\n                }\\n\\n\\n                if (!(right.Length >= 2 && right[0] == \\'0\\'))\\n                {\\n                    rights.Add(right);\\n                }\\n\\n                for (int j = 1; j < left.Length; j++)\\n                {\\n                    var leftLeft = left.Substring(0, j);\\n                    if (j > 1 && leftLeft[0] == \\'0\\')\\n                    {\\n                        continue;\\n                    }\\n                    var leftRight = left.Substring(j, left.Length - j);\\n\\n                    if (leftRight.Length > 1 && leftRight[leftRight.Length - 1] == \\'0\\')\\n                    {\\n                        continue;\\n                    }\\n\\n\\n                    var cand = $\"{leftLeft}.{leftRight}\";\\n                    if (int.Parse(leftRight) == 0)\\n                    {\\n                        continue;\\n                    }\\n                    lefts.Add(cand);\\n                }\\n\\n\\n                for (int j = 1; j < right.Length; j++)\\n                {\\n                    var rightLeft = right.Substring(0, j);\\n                    if (j > 1 && rightLeft[0] == \\'0\\')\\n                    {\\n                        continue;\\n                    }\\n                    var rightRight = right.Substring(j, right.Length - j);\\n\\n                    if (rightRight.Length > 1 && rightRight[rightRight.Length - 1] == \\'0\\')\\n                    {\\n                        continue;\\n                    }\\n\\n                    var cand = $\"{rightLeft}.{rightRight}\";\\n                    if (int.Parse(rightRight) == 0)\\n                    {\\n                        continue;\\n                    }\\n                    rights.Add(cand);\\n                }\\n\\n                foreach (var l in lefts)\\n                {\\n                    foreach (var r in rights)\\n                    {\\n                        res.Add($\"({l}, {r})\");\\n                    }\\n                }\\n\\n            }\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327572,
                "title": "java-super-clear-solution",
                "content": "```\\nclass Solution {\\n    private List<String> sub(String s) {\\n        if (s.length() == 1) return Collections.singletonList(s);\\n\\n        List<String> ans = new ArrayList<>();\\n        if (s.charAt(0) != \\'0\\') {\\n            ans.add(s);\\n            for (int i = 1; i < s.length() && !s.endsWith(\"0\"); i++) {\\n                ans.add(s.substring(0, i) + \".\" + s.substring(i));\\n            }\\n        } else if (!s.endsWith(\"0\")) {\\n            ans.add(s.substring(0, 1) + \".\" + s.substring(1));\\n        }\\n\\n        return ans;\\n    }\\n\\n    public List<String> ambiguousCoordinates(String S) {\\n        List<String> ans = new ArrayList<>();\\n        List<String> left;\\n        List<String> right;\\n\\n        for (int i = 2; i < S.length() - 1; i++) {\\n            left = sub(S.substring(1, i));\\n            right = sub(S.substring(i, S.length() - 1));\\n\\n            if (!left.isEmpty() && !right.isEmpty()) {\\n                for (String l : left) {\\n                    for (String r : right) {\\n                        ans.add(\"(\" + l + \", \" + r + \")\");\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private List<String> sub(String s) {\\n        if (s.length() == 1) return Collections.singletonList(s);\\n\\n        List<String> ans = new ArrayList<>();\\n        if (s.charAt(0) != \\'0\\') {\\n            ans.add(s);\\n            for (int i = 1; i < s.length() && !s.endsWith(\"0\"); i++) {\\n                ans.add(s.substring(0, i) + \".\" + s.substring(i));\\n            }\\n        } else if (!s.endsWith(\"0\")) {\\n            ans.add(s.substring(0, 1) + \".\" + s.substring(1));\\n        }\\n\\n        return ans;\\n    }\\n\\n    public List<String> ambiguousCoordinates(String S) {\\n        List<String> ans = new ArrayList<>();\\n        List<String> left;\\n        List<String> right;\\n\\n        for (int i = 2; i < S.length() - 1; i++) {\\n            left = sub(S.substring(1, i));\\n            right = sub(S.substring(i, S.length() - 1));\\n\\n            if (!left.isEmpty() && !right.isEmpty()) {\\n                for (String l : left) {\\n                    for (String r : right) {\\n                        ans.add(\"(\" + l + \", \" + r + \")\");\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477750,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        string cur1 = \"\";\\n        string cur2 = \"\";\\n        vector<string> res;\\n        bool confirmedFirstPart = false;\\n        bool usedDot = false;\\n        backtrack(s, cur1, cur2, res, 0, confirmedFirstPart, usedDot);\\n        return res;\\n    }\\n    void backtrack(string& s, string& cur1, string& cur2, vector<string>& res, int index, bool& confirmedFirstPart, bool& usedDot)\\n    {\\n        if (index == s.length())\\n        {\\n            if (confirmedFirstPart == true)\\n            {\\n                if (cur2.size() != 2 && (cur2[cur2.size() - 2] == \\'0\\') && (cur2[0] == \\'0\\')) return;\\n                res.push_back(cur1 + cur2);\\n            }\\n            return;\\n        }\\n        if (s[index] != \\'(\\' && s[index] != \\')\\')\\n        {\\n            if (usedDot == false && index != s.length() - 2)\\n            {\\n                if (!confirmedFirstPart)\\n                {\\n                    cur1.push_back(s[index]);\\n                    cur1.push_back(\\'.\\');\\n                    usedDot = true;\\n                    backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                    cur1.pop_back();\\n                    cur1.pop_back();\\n                    usedDot = false;\\n                }\\n                else\\n                {\\n                    cur2.push_back(s[index]);\\n                    cur2.push_back(\\'.\\');\\n                    usedDot = true;\\n                    backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                    cur2.pop_back();\\n                    cur2.pop_back();\\n                    usedDot = false;\\n                }\\n            }\\n            if (confirmedFirstPart == false && index != s.length() - 2)\\n            {\\n                if (!(usedDot == true && s[index] == \\'0\\'))\\n                {\\n                    cur1.push_back(s[index]);\\n                    cur1.push_back(\\',\\');\\n                    cur1.push_back(\\' \\');\\n                    confirmedFirstPart = true;\\n                    bool usedDotCopy = usedDot;\\n                    usedDot = false;\\n                    backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                    cur1.pop_back();\\n                    cur1.pop_back();\\n                    cur1.pop_back();\\n                    confirmedFirstPart = false;\\n                    usedDot = usedDotCopy;\\n                }\\n            }\\n            if (!confirmedFirstPart) \\n            {\\n                if (!(cur1.size() == 1 && s[index] == \\'0\\'))\\n                {\\n                    cur1.push_back(s[index]);\\n                    backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                    cur1.pop_back();\\n                }\\n            }\\n            else\\n            {\\n                if (!(cur2.empty() && index != s.length() - 2 && s[index] == \\'0\\') && \\n                    !(usedDot && index == s.length() - 2 && s[index] == \\'0\\'))\\n                {\\n                    cur2.push_back(s[index]);\\n                    backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                    cur2.pop_back();\\n                }\\n            }\\n        }\\n        else\\n        {\\n            if (s[index] == \\'(\\')\\n            {\\n                cur1.push_back(\\'(\\');\\n                backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                cur1.pop_back();\\n            }\\n            else\\n            {\\n                cur2.push_back(\\')\\');\\n                backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                cur2.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def gen_nums(self, s):\\n        ans = []\\n        if s == \"0\" or s[0] != \"0\":\\n            ans.append(s)\\n        \\n        if s[-1] == \\'0\\':\\n            return ans\\n        \\n        if s[0] == \\'0\\':\\n            return ans + [\\'0.\\' + s[1:]]\\n\\n        for i in range(1, len(s)):\\n            ans.append(s[:i] + \\'.\\' + s[i:])\\n        return ans\\n\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        res = []\\n        for left_len in range(1, len(s)):\\n            l = self.gen_nums(s[:left_len])\\n            r = self.gen_nums(s[left_len:])\\n            for n1 in l:\\n                for n2 in r:\\n                    res.append(f\\'({n1}, {n2})\\')\\n                    \\n        return res\\n```\\n\\n```Java []\\nclass Solution {\\n    public List<String> helper (String s) {\\n        List<String> answer = new ArrayList<> ();\\n        if (s.length () == 1) {\\n            answer.add (s);\\n            return answer;\\n        }\\n        else if (s.charAt (0) == \\'0\\' && s.charAt (s.length () - 1) == \\'0\\') {\\n            return answer;\\n        }\\n        else if (s.charAt (0) == \\'0\\') {\\n            StringBuilder sb = new StringBuilder ();\\n            sb.append (s.charAt (0)).append (\".\").append (s.substring (1));\\n            answer.add (sb.toString ());\\n            return answer;\\n        }\\n        else if (s.charAt (s.length () - 1) == \\'0\\') {\\n            answer.add (s);\\n            return answer;\\n        }\\n        answer.add (s);\\n        for (int i = 1; i < s.length (); i++) {\\n            StringBuilder sb = new StringBuilder ();\\n            sb.append (s.substring (0, i)).append (\".\").append (s.substring (i));\\n            answer.add (sb.toString ());\\n        }\\n        return answer;\\n    }\\n    public List<String> ambiguousCoordinates(String s) {   \\n        List<String> answer = new ArrayList<> ();\\n        for (int i = 2; i < s.length () - 1; i++) {\\n            List<String> leftLists = helper (s.substring (1, i));\\n            List<String> rightLists = helper (s.substring (i, s.length () - 1));\\n            \\n            for (String leftString : leftLists) {\\n                for (String rightString : rightLists) {\\n                    StringBuilder sb = new StringBuilder ();\\n                    sb.append (\"(\").append (leftString).append (\", \").append (rightString).append (\")\");\\n                    answer.add (sb.toString ());\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        string cur1 = \"\";\\n        string cur2 = \"\";\\n        vector<string> res;\\n        bool confirmedFirstPart = false;\\n        bool usedDot = false;\\n        backtrack(s, cur1, cur2, res, 0, confirmedFirstPart, usedDot);\\n        return res;\\n    }\\n    void backtrack(string& s, string& cur1, string& cur2, vector<string>& res, int index, bool& confirmedFirstPart, bool& usedDot)\\n    {\\n        if (index == s.length())\\n        {\\n            if (confirmedFirstPart == true)\\n            {\\n                if (cur2.size() != 2 && (cur2[cur2.size() - 2] == \\'0\\') && (cur2[0] == \\'0\\')) return;\\n                res.push_back(cur1 + cur2);\\n            }\\n            return;\\n        }\\n        if (s[index] != \\'(\\' && s[index] != \\')\\')\\n        {\\n            if (usedDot == false && index != s.length() - 2)\\n            {\\n                if (!confirmedFirstPart)\\n                {\\n                    cur1.push_back(s[index]);\\n                    cur1.push_back(\\'.\\');\\n                    usedDot = true;\\n                    backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                    cur1.pop_back();\\n                    cur1.pop_back();\\n                    usedDot = false;\\n                }\\n                else\\n                {\\n                    cur2.push_back(s[index]);\\n                    cur2.push_back(\\'.\\');\\n                    usedDot = true;\\n                    backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                    cur2.pop_back();\\n                    cur2.pop_back();\\n                    usedDot = false;\\n                }\\n            }\\n            if (confirmedFirstPart == false && index != s.length() - 2)\\n            {\\n                if (!(usedDot == true && s[index] == \\'0\\'))\\n                {\\n                    cur1.push_back(s[index]);\\n                    cur1.push_back(\\',\\');\\n                    cur1.push_back(\\' \\');\\n                    confirmedFirstPart = true;\\n                    bool usedDotCopy = usedDot;\\n                    usedDot = false;\\n                    backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                    cur1.pop_back();\\n                    cur1.pop_back();\\n                    cur1.pop_back();\\n                    confirmedFirstPart = false;\\n                    usedDot = usedDotCopy;\\n                }\\n            }\\n            if (!confirmedFirstPart) \\n            {\\n                if (!(cur1.size() == 1 && s[index] == \\'0\\'))\\n                {\\n                    cur1.push_back(s[index]);\\n                    backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                    cur1.pop_back();\\n                }\\n            }\\n            else\\n            {\\n                if (!(cur2.empty() && index != s.length() - 2 && s[index] == \\'0\\') && \\n                    !(usedDot && index == s.length() - 2 && s[index] == \\'0\\'))\\n                {\\n                    cur2.push_back(s[index]);\\n                    backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                    cur2.pop_back();\\n                }\\n            }\\n        }\\n        else\\n        {\\n            if (s[index] == \\'(\\')\\n            {\\n                cur1.push_back(\\'(\\');\\n                backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                cur1.pop_back();\\n            }\\n            else\\n            {\\n                cur2.push_back(\\')\\');\\n                backtrack(s, cur1, cur2, res, index + 1, confirmedFirstPart, usedDot);\\n                cur2.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def gen_nums(self, s):\\n        ans = []\\n        if s == \"0\" or s[0] != \"0\":\\n            ans.append(s)\\n        \\n        if s[-1] == \\'0\\':\\n            return ans\\n        \\n        if s[0] == \\'0\\':\\n            return ans + [\\'0.\\' + s[1:]]\\n\\n        for i in range(1, len(s)):\\n            ans.append(s[:i] + \\'.\\' + s[i:])\\n        return ans\\n\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        res = []\\n        for left_len in range(1, len(s)):\\n            l = self.gen_nums(s[:left_len])\\n            r = self.gen_nums(s[left_len:])\\n            for n1 in l:\\n                for n2 in r:\\n                    res.append(f\\'({n1}, {n2})\\')\\n                    \\n        return res\\n```\n```Java []\\nclass Solution {\\n    public List<String> helper (String s) {\\n        List<String> answer = new ArrayList<> ();\\n        if (s.length () == 1) {\\n            answer.add (s);\\n            return answer;\\n        }\\n        else if (s.charAt (0) == \\'0\\' && s.charAt (s.length () - 1) == \\'0\\') {\\n            return answer;\\n        }\\n        else if (s.charAt (0) == \\'0\\') {\\n            StringBuilder sb = new StringBuilder ();\\n            sb.append (s.charAt (0)).append (\".\").append (s.substring (1));\\n            answer.add (sb.toString ());\\n            return answer;\\n        }\\n        else if (s.charAt (s.length () - 1) == \\'0\\') {\\n            answer.add (s);\\n            return answer;\\n        }\\n        answer.add (s);\\n        for (int i = 1; i < s.length (); i++) {\\n            StringBuilder sb = new StringBuilder ();\\n            sb.append (s.substring (0, i)).append (\".\").append (s.substring (i));\\n            answer.add (sb.toString ());\\n        }\\n        return answer;\\n    }\\n    public List<String> ambiguousCoordinates(String s) {   \\n        List<String> answer = new ArrayList<> ();\\n        for (int i = 2; i < s.length () - 1; i++) {\\n            List<String> leftLists = helper (s.substring (1, i));\\n            List<String> rightLists = helper (s.substring (i, s.length () - 1));\\n            \\n            for (String leftString : leftLists) {\\n                for (String rightString : rightLists) {\\n                    StringBuilder sb = new StringBuilder ();\\n                    sb.append (\"(\").append (leftString).append (\", \").append (rightString).append (\")\");\\n                    answer.add (sb.toString ());\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637129,
                "title": "c-easy-solution",
                "content": "\\tpublic class Solution\\n\\t{\\n\\t\\tList<string> ans;\\n\\t\\tpublic IList<string> AmbiguousCoordinates(string s)\\n\\t\\t{\\n\\t\\t\\tans = new List<string>();\\n\\t\\t\\tSolve(s, new List<string>(), 1);\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tprivate void Solve(string s, List<string> str, int idx)\\n\\t\\t{\\n\\t\\t\\tif(str.Count >= 2)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (IsValid(str, s.Length - 2))\\n\\t\\t\\t\\t\\tans.Add(\\'(\\' + str[0] + \", \" + str[1] + \\')\\');\\n\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i = idx; i < s.Length - 1; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstr.Add(s.Substring(idx, i - idx + 1));\\n\\t\\t\\t\\tSolve(s, str, i + 1);\\n\\t\\t\\t\\tstr.RemoveAt(str.Count - 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i = idx; i < s.Length - 1; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring temp = s.Substring(idx, i - idx + 1) + \\'.\\';\\n\\t\\t\\t\\tfor(int j = i + 1; j < s.Length - 1; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstr.Add(temp + s.Substring(i + 1, j - i));\\n\\t\\t\\t\\t\\tSolve(s, str, j + 1);\\n\\t\\t\\t\\t\\tstr.RemoveAt(str.Count - 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate bool IsValid(List<string> str, int stringLength)\\n\\t\\t{\\n\\t\\t\\treturn !string.IsNullOrWhiteSpace(str[0]) &&\\n\\t\\t\\t\\t!string.IsNullOrWhiteSpace(str[1]) &&\\n\\t\\t\\t\\t(str[0][0] != \\'0\\' || str[0].Length == 1 || str[0][1] == \\'.\\') &&\\n\\t\\t\\t\\t(str[1][0] != \\'0\\' || str[1].Length == 1 || str[1][1] == \\'.\\') &&\\n\\t\\t\\t\\t(!str[0].Contains(\\'.\\') || str[0][^1] != \\'0\\') &&\\n\\t\\t\\t\\t(!str[1].Contains(\\'.\\') || str[1][^1] != \\'0\\') &&\\n\\t\\t\\t\\t(str[0].Replace(\".\", string.Empty).Length + str[1].Replace(\".\", string.Empty).Length >= stringLength);\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution\\n\\t{\\n\\t\\tList<string> ans;\\n\\t\\tpublic IList<string> AmbiguousCoordinates(string s)\\n\\t\\t{\\n\\t\\t\\tans = new List<string>();\\n\\t\\t\\tSolve(s, new List<string>(), 1);\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1427481,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int len;\\n    vector<string>ans;\\n    string helper(string s,int k){\\n        if(s.size() == 1) return s;\\n        if(k>=2){\\n            if(s[0] == \\'0\\') return \"-1\";\\n        }\\n        if(s[s.size()-1] == \\'0\\'){\\n            if(k != s.size()) return \"-1\";\\n        }\\n        if(k == s.size()) return s;\\n        string res = s.substr(0,k)+\".\"+s.substr(k);\\n        return res;\\n    }\\n    void backtrack(string s,int pos,string prev){\\n        if(prev.size()>0){\\n            for(int i = 1;i<=len-pos;i++){\\n                string t = helper(s.substr(pos),i);\\n                if(t == \"-1\") continue;\\n                else ans.push_back(\"(\"+prev+\", \"+t+\")\");\\n            }\\n            return;\\n        }\\n        else{\\n            for(int i = 1;i<len;i++){\\n                string temp = s.substr(0,i);\\n                for(int j = 1;j<=i;j++){\\n                    string t = helper(temp,j);\\n                    if(t == \"-1\") continue;\\n                    backtrack(s,i,t);\\n                }\\n            }\\n        }\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1,s.size()-2);\\n        len = s.size();\\n        backtrack(s,0,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int len;\\n    vector<string>ans;\\n    string helper(string s,int k){\\n        if(s.size() == 1) return s;\\n        if(k>=2){\\n            if(s[0] == \\'0\\') return \"-1\";\\n        }\\n        if(s[s.size()-1] == \\'0\\'){\\n            if(k != s.size()) return \"-1\";\\n        }\\n        if(k == s.size()) return s;\\n        string res = s.substr(0,k)+\".\"+s.substr(k);\\n        return res;\\n    }\\n    void backtrack(string s,int pos,string prev){\\n        if(prev.size()>0){\\n            for(int i = 1;i<=len-pos;i++){\\n                string t = helper(s.substr(pos),i);\\n                if(t == \"-1\") continue;\\n                else ans.push_back(\"(\"+prev+\", \"+t+\")\");\\n            }\\n            return;\\n        }\\n        else{\\n            for(int i = 1;i<len;i++){\\n                string temp = s.substr(0,i);\\n                for(int j = 1;j<=i;j++){\\n                    string t = helper(temp,j);\\n                    if(t == \"-1\") continue;\\n                    backtrack(s,i,t);\\n                }\\n            }\\n        }\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1,s.size()-2);\\n        len = s.size();\\n        backtrack(s,0,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250312,
                "title": "c-solution-with-explanation",
                "content": "```\\n    /*\\n     * input: \"(123)\"\\n     * First we will assign commas\\n     *               123\\n     *                |\\n     *            ----------\\n     *           |          |\\n     *         1, 23       12, 3\\n     *\\n     * Now we have 2 pairs after putting comma. Now try tp put the \\n     * decimal point\\n     *\\n     *         1, 2.3       1.2, 3\\n     * So there are total 4 combinations (1, 23), (1, 2.3), (12, 3), (1.2, 3)\\n     * While applying decimal point, we need to exclude the nos that are \"00\"\\n     * \"0.0\", \"0.00\", \"1.0\", \"001\", \"00.01\", \".1\"\\n    */\\n\\n    //Function that will generate all nos (including decimal)\\n    void generateNumbers(string s, vector<string>& out) {\\n        // If the string has only one character then there won\\'t be any\\n        // decimal point, so pushing the num and returning\\n        if (s.length() == 1) {\\n            out.push_back(s);\\n            return;\\n        }\\n        \\n        // Check if the first char is zero or not\\n        if (s[0] != \\'0\\') {\\n            // The first char is not zero, so we have a valid number and one\\n            // combination, push it to res\\n            // Eg: s = 12 for input 123, then 12 is one combination of input.\\n            out.push_back(s);\\n        }\\n        else {\\n            // First char is zero, check if the last char is zero, if so the\\n            // number had extraneous zeros which is not valid. If last char is\\n            // not zero then we add a decimal point after the first char and\\n            // return from the function\\n            // Eg: s = \"01230\" return empty vecctor\\n            //     s = \"01234\" return 0.1234\\n            if (s.back() != \\'0\\') {\\n                out.push_back(\"0.\" + s.substr(1));\\n            }\\n            \\n            return;\\n        }\\n\\n        // Check if the last char is 0, if so return\\n        // Eg: s = \"10\" skip as 1.0 not allowed\\n        if (s.back() == \\'0\\') {\\n            return;\\n        }\\n        \\n        // Now that we have valid numbers, loop all characters and find the\\n        // decimal combinations.\\n        for (int i = 1; i < s.length(); i++) {\\n            out.push_back(s.substr(0, i) + \".\" + s.substr(i));\\n        }\\n        \\n        return;\\n    }\\n    \\n    vector<string> ambiguousCoordinates(string s) {\\n        // Generate a string by excluding open and close\\n        // brackets\\n        string s2 = s.substr(1, s.length() - 2);\\n        \\n        // Variable to store the length of input\\n        int n = s2.length();\\n        \\n        // Vector to store result\\n        vector<string> res;\\n        // Left and right vectors are for storing the number combinations for\\n        // left and right values\\n        vector<string> left;\\n        vector<string> right;\\n        \\n        // Traverse each char in string starting from 1 as we need\\n        // at least one char\\n        for (int i = 1; i < n; i++) {\\n            // Generate the left half and right half ie.., if input is 123\\n            // below logic will generate it as 1 and 23\\n            // Send it to generate numbers function to get the decimal nos\\n            // out of it\\n            generateNumbers(s2.substr(0, i), left);            \\n            generateNumbers(s2.substr(i), right);\\n            \\n            // Now that we have all combinations for this number, put it in\\n            // result by adding space between nos and open and close brackets\\n            for (string& lnum : left) {\\n                for (string& rnum : right) {\\n                    res.push_back(\"(\" + lnum + \", \" + rnum + \")\");\\n                }\\n            }\\n            // Clear the vectors for the next set of generated nums\\n            left.clear();\\n            right.clear();\\n        }\\n        \\n        // return the result\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    /*\\n     * input: \"(123)\"\\n     * First we will assign commas\\n     *               123\\n     *                |\\n     *            ----------\\n     *           |          |\\n     *         1, 23       12, 3\\n     *\\n     * Now we have 2 pairs after putting comma. Now try tp put the \\n     * decimal point\\n     *\\n     *         1, 2.3       1.2, 3\\n     * So there are total 4 combinations (1, 23), (1, 2.3), (12, 3), (1.2, 3)\\n     * While applying decimal point, we need to exclude the nos that are \"00\"\\n     * \"0.0\", \"0.00\", \"1.0\", \"001\", \"00.01\", \".1\"\\n    */\\n\\n    //Function that will generate all nos (including decimal)\\n    void generateNumbers(string s, vector<string>& out) {\\n        // If the string has only one character then there won\\'t be any\\n        // decimal point, so pushing the num and returning\\n        if (s.length() == 1) {\\n            out.push_back(s);\\n            return;\\n        }\\n        \\n        // Check if the first char is zero or not\\n        if (s[0] != \\'0\\') {\\n            // The first char is not zero, so we have a valid number and one\\n            // combination, push it to res\\n            // Eg: s = 12 for input 123, then 12 is one combination of input.\\n            out.push_back(s);\\n        }\\n        else {\\n            // First char is zero, check if the last char is zero, if so the\\n            // number had extraneous zeros which is not valid. If last char is\\n            // not zero then we add a decimal point after the first char and\\n            // return from the function\\n            // Eg: s = \"01230\" return empty vecctor\\n            //     s = \"01234\" return 0.1234\\n            if (s.back() != \\'0\\') {\\n                out.push_back(\"0.\" + s.substr(1));\\n            }\\n            \\n            return;\\n        }\\n\\n        // Check if the last char is 0, if so return\\n        // Eg: s = \"10\" skip as 1.0 not allowed\\n        if (s.back() == \\'0\\') {\\n            return;\\n        }\\n        \\n        // Now that we have valid numbers, loop all characters and find the\\n        // decimal combinations.\\n        for (int i = 1; i < s.length(); i++) {\\n            out.push_back(s.substr(0, i) + \".\" + s.substr(i));\\n        }\\n        \\n        return;\\n    }\\n    \\n    vector<string> ambiguousCoordinates(string s) {\\n        // Generate a string by excluding open and close\\n        // brackets\\n        string s2 = s.substr(1, s.length() - 2);\\n        \\n        // Variable to store the length of input\\n        int n = s2.length();\\n        \\n        // Vector to store result\\n        vector<string> res;\\n        // Left and right vectors are for storing the number combinations for\\n        // left and right values\\n        vector<string> left;\\n        vector<string> right;\\n        \\n        // Traverse each char in string starting from 1 as we need\\n        // at least one char\\n        for (int i = 1; i < n; i++) {\\n            // Generate the left half and right half ie.., if input is 123\\n            // below logic will generate it as 1 and 23\\n            // Send it to generate numbers function to get the decimal nos\\n            // out of it\\n            generateNumbers(s2.substr(0, i), left);            \\n            generateNumbers(s2.substr(i), right);\\n            \\n            // Now that we have all combinations for this number, put it in\\n            // result by adding space between nos and open and close brackets\\n            for (string& lnum : left) {\\n                for (string& rnum : right) {\\n                    res.push_back(\"(\" + lnum + \", \" + rnum + \")\");\\n                }\\n            }\\n            // Clear the vectors for the next set of generated nums\\n            left.clear();\\n            right.clear();\\n        }\\n        \\n        // return the result\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1249467,
                "title": "bhayank-code-h-bhai-c",
                "content": "```c++\\nclass Solution {\\npublic:\\n    bool valpre(string &s){\\n        if(s.size()==1) return true;\\n        if(s[0]==\\'0\\') return false;\\n        return true;\\n    }\\n    bool valsuff(string &s){\\n        if(s[s.size()-1]==\\'0\\') return false;\\n        return true;\\n    }\\n    bool isvalid(string &s){\\n        if(s.size()==1) return true;\\n        int i = 0;\\n        string pre = \"\";\\n        string suff = \"\";\\n        while(i<s.size()&&s[i]!=\\'.\\'){\\n            pre+=s[i];\\n            i++;\\n        }\\n        if(i==s.size()){\\n            if(s[0]==\\'0\\') return false;\\n            return true;\\n        }\\n        suff = s.substr(i,s.size());\\n        return valpre(pre)&&valsuff(suff);\\n        \\n    }\\n    vector<string>make_coordinate(string &s){\\n        vector<string>res;\\n        res.push_back(s);\\n        if(s.size()==1) return res;\\n        string prefix = \"\";\\n        string suffix = \"\";\\n        for(int i = 0;i<s.size()-1;i++){\\n            prefix+=s[i];\\n            suffix = s.substr(i+1,s.size());\\n            if(suffix.size()==0){\\n                res.push_back(prefix);\\n                continue;\\n            }\\n            string curr = \"\";\\n            curr+=prefix;\\n            curr+=\\'.\\';\\n            curr+=suffix;\\n            res.push_back(curr);\\n        }\\n        return res;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        s.erase(s.begin());\\n        s.erase(--s.end());\\n        string prefix = \"\";\\n        string suffix;\\n        vector<string>ans;\\n        string temp = \"01\";\\n        for(int i = 0;i<s.size()-1;i++){\\n            prefix+=s[i];\\n            suffix = s.substr(i+1,s.size());\\n            vector<string>leftcord = make_coordinate(prefix);\\n            vector<string>rightcord = make_coordinate(suffix);\\n            for(auto &s1 : leftcord){\\n                for(auto &s2 : rightcord){\\n                    if(isvalid(s1)==false||isvalid(s2)==false) continue;\\n                    string curr = \"(\";\\n                    curr+=s1;\\n                    curr+=\", \";\\n                    curr+=s2;\\n                    curr+=\\')\\';\\n                    ans.push_back(curr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool valpre(string &s){\\n        if(s.size()==1) return true;\\n        if(s[0]==\\'0\\') return false;\\n        return true;\\n    }\\n    bool valsuff(string &s){\\n        if(s[s.size()-1]==\\'0\\') return false;\\n        return true;\\n    }\\n    bool isvalid(string &s){\\n        if(s.size()==1) return true;\\n        int i = 0;\\n        string pre = \"\";\\n        string suff = \"\";\\n        while(i<s.size()&&s[i]!=\\'.\\'){\\n            pre+=s[i];\\n            i++;\\n        }\\n        if(i==s.size()){\\n            if(s[0]==\\'0\\') return false;\\n            return true;\\n        }\\n        suff = s.substr(i,s.size());\\n        return valpre(pre)&&valsuff(suff);\\n        \\n    }\\n    vector<string>make_coordinate(string &s){\\n        vector<string>res;\\n        res.push_back(s);\\n        if(s.size()==1) return res;\\n        string prefix = \"\";\\n        string suffix = \"\";\\n        for(int i = 0;i<s.size()-1;i++){\\n            prefix+=s[i];\\n            suffix = s.substr(i+1,s.size());\\n            if(suffix.size()==0){\\n                res.push_back(prefix);\\n                continue;\\n            }\\n            string curr = \"\";\\n            curr+=prefix;\\n            curr+=\\'.\\';\\n            curr+=suffix;\\n            res.push_back(curr);\\n        }\\n        return res;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        s.erase(s.begin());\\n        s.erase(--s.end());\\n        string prefix = \"\";\\n        string suffix;\\n        vector<string>ans;\\n        string temp = \"01\";\\n        for(int i = 0;i<s.size()-1;i++){\\n            prefix+=s[i];\\n            suffix = s.substr(i+1,s.size());\\n            vector<string>leftcord = make_coordinate(prefix);\\n            vector<string>rightcord = make_coordinate(suffix);\\n            for(auto &s1 : leftcord){\\n                for(auto &s2 : rightcord){\\n                    if(isvalid(s1)==false||isvalid(s2)==false) continue;\\n                    string curr = \"(\";\\n                    curr+=s1;\\n                    curr+=\", \";\\n                    curr+=s2;\\n                    curr+=\\')\\';\\n                    ans.push_back(curr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208709,
                "title": "c-cartesian-product-faster-than-100",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool Prefix(string s)\\n    {\\n        int n=(int)s.length();\\n        if(n==1) return true;\\n        if(s[0]==\\'0\\') return false;\\n        return true;\\n    }\\n    bool Suffix(string s)\\n    {\\n        int n=(int)s.length();\\n        if(s[n-1]==\\'0\\') return false;\\n        return true;\\n    }\\n    vector<string> generate(string s)\\n    {\\n        vector<string> g;\\n        int n=(int)s.length();\\n        if(Prefix(s)) g.push_back(s);\\n        for(int i=1;i<n;i++)\\n        {\\n            string left=s.substr(0,i);\\n            string right=s.substr(i);\\n            if(Prefix(left)==true and Suffix(right)==true){\\n                g.push_back(left+\".\"+right);\\n            }\\n        }\\n        return g;\\n    }\\npublic:\\n    vector<string> ambiguousCoordinates(string str) {\\n        vector<string> sol;\\n        string s=str.substr(1,str.length()-2);\\n        int n=(int)s.length();\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            vector<string> left=generate(s.substr(0,i));\\n            vector<string> right=generate(s.substr(i));\\n            for(auto l:left)\\n            {\\n                for(auto r:right) sol.push_back(\"(\"+l+\", \"+r+\")\");\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool Prefix(string s)\\n    {\\n        int n=(int)s.length();\\n        if(n==1) return true;\\n        if(s[0]==\\'0\\') return false;\\n        return true;\\n    }\\n    bool Suffix(string s)\\n    {\\n        int n=(int)s.length();\\n        if(s[n-1]==\\'0\\') return false;\\n        return true;\\n    }\\n    vector<string> generate(string s)\\n    {\\n        vector<string> g;\\n        int n=(int)s.length();\\n        if(Prefix(s)) g.push_back(s);\\n        for(int i=1;i<n;i++)\\n        {\\n            string left=s.substr(0,i);\\n            string right=s.substr(i);\\n            if(Prefix(left)==true and Suffix(right)==true){\\n                g.push_back(left+\".\"+right);\\n            }\\n        }\\n        return g;\\n    }\\npublic:\\n    vector<string> ambiguousCoordinates(string str) {\\n        vector<string> sol;\\n        string s=str.substr(1,str.length()-2);\\n        int n=(int)s.length();\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            vector<string> left=generate(s.substr(0,i));\\n            vector<string> right=generate(s.substr(i));\\n            for(auto l:left)\\n            {\\n                for(auto r:right) sol.push_back(\"(\"+l+\", \"+r+\")\");\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207736,
                "title": "swift-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    func ambiguousCoordinates(_ s: String) -> [String] {\\n        var str = Array(s)\\n        str.removeFirst()\\n        str.removeLast()\\n        var ans: [String] = []\\n        var lefts: [String] = []\\n        var rights: [String] = []\\n        for i in 0..<str.count-1 {\\n            lefts = makeStrings(str, 0, i)\\n            rights = makeStrings(str, i+1, str.count-1)\\n            for left in lefts {\\n                for right in rights {\\n                    let temp = \"(\" + left + \", \" + right + \")\"\\n                    ans.append(temp)\\n                }\\n            }\\n        }\\n        return ans\\n    }\\n\\n    func makeStrings(_ s: [Character], _ i: Int, _ j: Int) -> [String] {\\n        var str = s[i...j]\\n        var result: [String] = []\\n        for idx in i...j { // Array.Slice is only a view of an original arran, so we use original index rather than 0..<str.count, which will cause index out of bounds error\\n            var left: [Character] = []\\n            var right: [Character] = []\\n            \\n            if idx == j { // reach the last index, do not need to split\\n                left.append(contentsOf: Array(str[i...j]))\\n                right = []\\n            } else {\\n                left = Array(str[i...idx])\\n                right = Array(str[idx+1...j])\\n            }\\n            if !(left.count > 1 && left.first! == \"0\") { // case like left =  \"01\" right = \"23\" we do not add dot\\n                if right.isEmpty {\\n                    result.append(String(left))\\n                } else {\\n                    var temp = left\\n                    temp.append(\".\")\\n                    temp.append(contentsOf: right)\\n                    if temp.last! != \"0\" { // case like \"1.0\" is not eligible\\n                        result.append(String(temp))\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func ambiguousCoordinates(_ s: String) -> [String] {\\n        var str = Array(s)\\n        str.removeFirst()\\n        str.removeLast()\\n        var ans: [String] = []\\n        var lefts: [String] = []\\n        var rights: [String] = []\\n        for i in 0..<str.count-1 {\\n            lefts = makeStrings(str, 0, i)\\n            rights = makeStrings(str, i+1, str.count-1)\\n            for left in lefts {\\n                for right in rights {\\n                    let temp = \"(\" + left + \", \" + right + \")\"\\n                    ans.append(temp)\\n                }\\n            }\\n        }\\n        return ans\\n    }\\n\\n    func makeStrings(_ s: [Character], _ i: Int, _ j: Int) -> [String] {\\n        var str = s[i...j]\\n        var result: [String] = []\\n        for idx in i...j { // Array.Slice is only a view of an original arran, so we use original index rather than 0..<str.count, which will cause index out of bounds error\\n            var left: [Character] = []\\n            var right: [Character] = []\\n            \\n            if idx == j { // reach the last index, do not need to split\\n                left.append(contentsOf: Array(str[i...j]))\\n                right = []\\n            } else {\\n                left = Array(str[i...idx])\\n                right = Array(str[idx+1...j])\\n            }\\n            if !(left.count > 1 && left.first! == \"0\") { // case like left =  \"01\" right = \"23\" we do not add dot\\n                if right.isEmpty {\\n                    result.append(String(left))\\n                } else {\\n                    var temp = left\\n                    temp.append(\".\")\\n                    temp.append(contentsOf: right)\\n                    if temp.last! != \"0\" { // case like \"1.0\" is not eligible\\n                        result.append(String(temp))\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207148,
                "title": "java-100-2ms-fast-simple-explanation",
                "content": "This code runs in 2ms or sometimes 3ms.\\n\\nThe execution speed comes from converting the original `String` to a `char[]` array, then do all the testing and building of any valid coordinate strings directly from the `char[]` array, without any slow substring creation.  The code works with comma and any decimal point positions that are indexes into the `char[]` array, without actually putting any comma character or decimal point character into the `char[]` array.  The index for the comma or any decimal point are the index of the character in the `char[]` array that they would appear before, but they are **never** inserted into the `char[]`.  The loops that provide the comma or decimal point indexes, *always* give valid positions.\\n\\nThe basic code structure it to try all possible comma positions.  For a comma position, check if the first number is a valid integer, and try all possible decimal point positions for the first number and check if the first number is a valid decimal point\\'ed number for that decimal point position.  For all valid first numbers, check if the second number would be a valid integer, or try all decimal point positions in the second number.  If two valid numbers are found, then call a method to build the valid coordinate string and add it to the result list.\\n\\nIf useful, please up-vote.\\n```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        char[] sc = s.toCharArray();\\n        List<String> result = new ArrayList();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        // Loop through all possible index positions for the comma.\\n        for (int commaPos = 2; commaPos < sc.length - 1; commaPos++) {\\n            \\n            // If first number if a valid integer without any decimal point.\\n            if (isValidNum(sc, 1, commaPos - 1)) {\\n                if (isValidNum(sc, commaPos, sc.length - 2))\\n                    buildNums(result, sb, sc, 1, commaPos-1, 0, commaPos, sc.length-2, 0);\\n                for (int dp2Idx = commaPos + 1; dp2Idx < sc.length - 1; dp2Idx++)\\n                    if (isValidDPNum(sc, commaPos, sc.length - 2, dp2Idx))\\n                        buildNums(result, sb, sc, 1, commaPos-1, 0, commaPos, sc.length-2, dp2Idx);\\n            }\\n            \\n            // Check all possible decimal point positions for the first number.\\n            for (int dp1Idx = 2; dp1Idx < commaPos; dp1Idx++) {\\n                if (isValidDPNum(sc, 1, commaPos - 1, dp1Idx)) {\\n                    if (isValidNum(sc, commaPos, sc.length - 2))\\n                        buildNums(result, sb, sc, 1, commaPos-1, dp1Idx, commaPos, sc.length-2, 0);\\n                    for (int dp2Idx = commaPos + 1; dp2Idx < sc.length - 1; dp2Idx++)\\n                        if (isValidDPNum(sc, commaPos, sc.length - 2, dp2Idx))\\n                            buildNums(result, sb, sc, 1, commaPos-1, dp1Idx, commaPos, sc.length-2, dp2Idx);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    \\n    // Check if a number in the char[] array is a valid integer without any decimal point.\\n    private boolean isValidNum(char[] sc, int startIdx, int lastIdx) {\\n        if (sc[startIdx] == \\'0\\' && lastIdx - startIdx != 0)  return false;\\n        return true;\\n    }\\n    \\n    \\n    // Check if a number in the char[] array is valid number with virtual decimal point at the specified index.\\n    private boolean isValidDPNum(char[] sc, int startIdx, int lastIdx, int dpIdx) {\\n        if ((sc[startIdx] == \\'0\\' && dpIdx - startIdx != 1) || sc[lastIdx] == \\'0\\')  return false;\\n        return true;\\n    }\\n    \\n    \\n    // Build the result two number coordinate string and add to the List of results.\\n    private void buildNums(List<String> result, StringBuilder sb, char[] sc, \\n                            int start1Idx, int last1Idx, int dp1Idx, \\n                            int start2Idx, int last2Idx, int dp2Idx) {\\n        sb.setLength(0);\\n        sb.append(\\'(\\');\\n        if (dp1Idx == 0)\\n            sb.append(sc, start1Idx, last1Idx - start1Idx + 1);\\n        else\\n            sb.append(sc, start1Idx, dp1Idx - start1Idx).append(\\'.\\').append(sc, dp1Idx, last1Idx - dp1Idx + 1);\\n        sb.append(\\',\\').append(\\' \\');\\n        if (dp2Idx == 0)\\n            sb.append(sc, start2Idx, last2Idx - start2Idx + 1);\\n        else\\n            sb.append(sc, start2Idx, dp2Idx - start2Idx).append(\\'.\\').append(sc, dp2Idx, last2Idx - dp2Idx + 1);\\n        sb.append(\\')\\');\\n        result.add(sb.toString());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        char[] sc = s.toCharArray();\\n        List<String> result = new ArrayList();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        // Loop through all possible index positions for the comma.\\n        for (int commaPos = 2; commaPos < sc.length - 1; commaPos++) {\\n            \\n            // If first number if a valid integer without any decimal point.\\n            if (isValidNum(sc, 1, commaPos - 1)) {\\n                if (isValidNum(sc, commaPos, sc.length - 2))\\n                    buildNums(result, sb, sc, 1, commaPos-1, 0, commaPos, sc.length-2, 0);\\n                for (int dp2Idx = commaPos + 1; dp2Idx < sc.length - 1; dp2Idx++)\\n                    if (isValidDPNum(sc, commaPos, sc.length - 2, dp2Idx))\\n                        buildNums(result, sb, sc, 1, commaPos-1, 0, commaPos, sc.length-2, dp2Idx);\\n            }\\n            \\n            // Check all possible decimal point positions for the first number.\\n            for (int dp1Idx = 2; dp1Idx < commaPos; dp1Idx++) {\\n                if (isValidDPNum(sc, 1, commaPos - 1, dp1Idx)) {\\n                    if (isValidNum(sc, commaPos, sc.length - 2))\\n                        buildNums(result, sb, sc, 1, commaPos-1, dp1Idx, commaPos, sc.length-2, 0);\\n                    for (int dp2Idx = commaPos + 1; dp2Idx < sc.length - 1; dp2Idx++)\\n                        if (isValidDPNum(sc, commaPos, sc.length - 2, dp2Idx))\\n                            buildNums(result, sb, sc, 1, commaPos-1, dp1Idx, commaPos, sc.length-2, dp2Idx);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    \\n    // Check if a number in the char[] array is a valid integer without any decimal point.\\n    private boolean isValidNum(char[] sc, int startIdx, int lastIdx) {\\n        if (sc[startIdx] == \\'0\\' && lastIdx - startIdx != 0)  return false;\\n        return true;\\n    }\\n    \\n    \\n    // Check if a number in the char[] array is valid number with virtual decimal point at the specified index.\\n    private boolean isValidDPNum(char[] sc, int startIdx, int lastIdx, int dpIdx) {\\n        if ((sc[startIdx] == \\'0\\' && dpIdx - startIdx != 1) || sc[lastIdx] == \\'0\\')  return false;\\n        return true;\\n    }\\n    \\n    \\n    // Build the result two number coordinate string and add to the List of results.\\n    private void buildNums(List<String> result, StringBuilder sb, char[] sc, \\n                            int start1Idx, int last1Idx, int dp1Idx, \\n                            int start2Idx, int last2Idx, int dp2Idx) {\\n        sb.setLength(0);\\n        sb.append(\\'(\\');\\n        if (dp1Idx == 0)\\n            sb.append(sc, start1Idx, last1Idx - start1Idx + 1);\\n        else\\n            sb.append(sc, start1Idx, dp1Idx - start1Idx).append(\\'.\\').append(sc, dp1Idx, last1Idx - dp1Idx + 1);\\n        sb.append(\\',\\').append(\\' \\');\\n        if (dp2Idx == 0)\\n            sb.append(sc, start2Idx, last2Idx - start2Idx + 1);\\n        else\\n            sb.append(sc, start2Idx, dp2Idx - start2Idx).append(\\'.\\').append(sc, dp2Idx, last2Idx - dp2Idx + 1);\\n        sb.append(\\')\\');\\n        result.add(sb.toString());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206931,
                "title": "easy-clean-go-solution-beats-100",
                "content": "```\\nfunc ambiguousCoordinates(s string) []string {\\n\\tvar result []string\\n\\n\\tfor i := 2; i <= len(s)-2; i++ {\\n\\t\\tleft, right := s[1:i], s[i:len(s)-1]\\n\\n\\t\\tif isLegalPart(left) && isLegalPart(right) {\\n\\t\\t\\tleftPartitions, rightPartitions := getAllPartitions(left), getAllPartitions(right)\\n\\n\\t\\t\\tfor _, leftPartition := range leftPartitions {\\n\\t\\t\\t\\tfor _, rightPartition := range rightPartitions {\\n\\t\\t\\t\\t\\tresult = append(result, fmt.Sprintf(\"(%s, %s)\", leftPartition, rightPartition))\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc isLegalPart(s string) bool {\\n\\treturn len(s) == 1 || s[0] != \\'0\\' || s[len(s)-1] != \\'0\\'\\n}\\n\\nfunc getAllPartitions(s string) []string {\\n\\tswitch {\\n\\tcase len(s) == 1 || s[len(s)-1] == \\'0\\':\\n\\t\\treturn []string{s}\\n\\tcase s[0] == \\'0\\':\\n\\t\\treturn []string{fmt.Sprintf(\"0.%s\", s[1:])}\\n\\tdefault:\\n\\t\\tresult := make([]string, 1, len(s))\\n\\t\\tresult[0] = s\\n\\t\\tfor i := 1; i < len(s); i++ {\\n\\t\\t\\tresult = append(result, fmt.Sprintf(\"%s.%s\", s[:i], s[i:]))\\n\\t\\t}\\n\\t\\treturn result\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc ambiguousCoordinates(s string) []string {\\n\\tvar result []string\\n\\n\\tfor i := 2; i <= len(s)-2; i++ {\\n\\t\\tleft, right := s[1:i], s[i:len(s)-1]\\n\\n\\t\\tif isLegalPart(left) && isLegalPart(right) {\\n\\t\\t\\tleftPartitions, rightPartitions := getAllPartitions(left), getAllPartitions(right)\\n\\n\\t\\t\\tfor _, leftPartition := range leftPartitions {\\n\\t\\t\\t\\tfor _, rightPartition := range rightPartitions {\\n\\t\\t\\t\\t\\tresult = append(result, fmt.Sprintf(\"(%s, %s)\", leftPartition, rightPartition))\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc isLegalPart(s string) bool {\\n\\treturn len(s) == 1 || s[0] != \\'0\\' || s[len(s)-1] != \\'0\\'\\n}\\n\\nfunc getAllPartitions(s string) []string {\\n\\tswitch {\\n\\tcase len(s) == 1 || s[len(s)-1] == \\'0\\':\\n\\t\\treturn []string{s}\\n\\tcase s[0] == \\'0\\':\\n\\t\\treturn []string{fmt.Sprintf(\"0.%s\", s[1:])}\\n\\tdefault:\\n\\t\\tresult := make([]string, 1, len(s))\\n\\t\\tresult[0] = s\\n\\t\\tfor i := 1; i < len(s); i++ {\\n\\t\\t\\tresult = append(result, fmt.Sprintf(\"%s.%s\", s[:i], s[i:]))\\n\\t\\t}\\n\\t\\treturn result\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1206759,
                "title": "70-python",
                "content": "```\\nclass Solution:\\n    def putDecimal(self, num):\\n        ans = []\\n        if not int(num):\\n            if len(num) == 1:\\n                return [\\'0\\']\\n            else:\\n                return []\\n            \\n        if num.startswith(\\'0\\'):\\n            return [\\'0.\\' + num[1:]] if not num.endswith(\\'0\\') else []\\n        \\n        if num.endswith(\\'0\\'):\\n            return [num]\\n        \\n        for i in range(len(num) - 1):\\n            # [0, i + 1), [i + 1, ..)\\n            left, right = num[:i + 1], num[i + 1: ]\\n            if not int(right):\\n                break\\n            if not right.endswith(\\'0\\'):\\n                ans.append(left + \\'.\\' + right)\\n            \\n        return ans + [num] if not num.startswith(\\'0\\') else ans\\n    \\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1: -1]\\n        ans = set()\\n        for i in range(len(s) - 1):\\n            left, right = s[:i + 1], s[i + 1: ]\\n            leftDecimals = self.putDecimal(left)\\n            rightDecimals = self.putDecimal(right)\\n            \\n            if leftDecimals and rightDecimals:\\n                for leftDecimal in leftDecimals:\\n                    for rightDecimal in rightDecimals:\\n                        ans.add(\"(\" + leftDecimal + \", \" + rightDecimal + \")\")\\n        return ans\\n    # \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def putDecimal(self, num):\\n        ans = []\\n        if not int(num):\\n            if len(num) == 1:\\n                return [\\'0\\']\\n            else:\\n                return []\\n            \\n        if num.startswith(\\'0\\'):\\n            return [\\'0.\\' + num[1:]] if not num.endswith(\\'0\\') else []\\n        \\n        if num.endswith(\\'0\\'):\\n            return [num]\\n        \\n        for i in range(len(num) - 1):\\n            # [0, i + 1), [i + 1, ..)\\n            left, right = num[:i + 1], num[i + 1: ]\\n            if not int(right):\\n                break\\n            if not right.endswith(\\'0\\'):\\n                ans.append(left + \\'.\\' + right)\\n            \\n        return ans + [num] if not num.startswith(\\'0\\') else ans\\n    \\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1: -1]\\n        ans = set()\\n        for i in range(len(s) - 1):\\n            left, right = s[:i + 1], s[i + 1: ]\\n            leftDecimals = self.putDecimal(left)\\n            rightDecimals = self.putDecimal(right)\\n            \\n            if leftDecimals and rightDecimals:\\n                for leftDecimal in leftDecimals:\\n                    for rightDecimal in rightDecimals:\\n                        ans.add(\"(\" + leftDecimal + \", \" + rightDecimal + \")\")\\n        return ans\\n    # \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206598,
                "title": "c-solution-95-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.size();\\n        vector<string>ans;\\n        for(int i = 1; i < n-2; i++){\\n            vector<string>A = helper(s.substr(1, i));\\n            vector<string>B = helper(s.substr(i+1, n-2-i));\\n            for(auto &a : A)\\n                for(auto &b : B)\\n                    ans.push_back(\"(\" + a + \", \" + b + \")\");\\n        }\\n        return ans;\\n    }\\n    vector<string>helper(string s){\\n        int n = s.size();\\n        if(n == 0 || (n > 1 && s[0] == \\'0\\' && s[n-1] == \\'0\\')) return {};  //Null string or 0xxx0         \\n        if(n > 1 && s[0] == \\'0\\') return {\"0.\" + s.substr(1)};   //0xxx9\\n        if(n == 1 || s[n-1] == \\'0\\') return {s};   //single digit or 9xxx0\\n        \\n        //9xxx9\\n        vector<string>ans = {s};\\n        for(int i = 1; i < n; i++)\\n            ans.push_back(s.substr(0,i) + \\'.\\' + s.substr(i));\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.size();\\n        vector<string>ans;\\n        for(int i = 1; i < n-2; i++){\\n            vector<string>A = helper(s.substr(1, i));\\n            vector<string>B = helper(s.substr(i+1, n-2-i));\\n            for(auto &a : A)\\n                for(auto &b : B)\\n                    ans.push_back(\"(\" + a + \", \" + b + \")\");\\n        }\\n        return ans;\\n    }\\n    vector<string>helper(string s){\\n        int n = s.size();\\n        if(n == 0 || (n > 1 && s[0] == \\'0\\' && s[n-1] == \\'0\\')) return {};  //Null string or 0xxx0         \\n        if(n > 1 && s[0] == \\'0\\') return {\"0.\" + s.substr(1)};   //0xxx9\\n        if(n == 1 || s[n-1] == \\'0\\') return {s};   //single digit or 9xxx0\\n        \\n        //9xxx9\\n        vector<string>ans = {s};\\n        for(int i = 1; i < n; i++)\\n            ans.push_back(s.substr(0,i) + \\'.\\' + s.substr(i));\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206404,
                "title": "java-clean-and-fast-beats-100",
                "content": "The solution is self explanatory.\\n\\n```\\nclass Solution {\\n\\n    public List<String> ambiguousCoordinates(String digits) {\\n        List<String> answer = new ArrayList<>();\\n        char[] digitsArr = digits.toCharArray();\\n        int n = digitsArr.length;\\n\\n        for (int comaIdx = 2; comaIdx < n - 1; comaIdx++) {\\n            String left = new String(Arrays.copyOfRange(digitsArr, 1, comaIdx));\\n            String right = new String(Arrays.copyOfRange(digitsArr, comaIdx, n - 1));\\n\\n            List<String> leftWithPoint = addPoints(left);\\n            List<String> rightWithPoint = addPoints(right);\\n\\n            for (String leftFloat : leftWithPoint) {\\n                for (String rightFloat : rightWithPoint) {\\n                    answer.add(build(leftFloat, rightFloat, true));\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    private List<String> addPoints(String digits) {\\n\\n        List<String> answer = new ArrayList<>();\\n\\n        if (isValid(digits)) {\\n            answer.add(digits);\\n        }\\n\\n        char[] digitsArr = digits.toCharArray();\\n        int n = digitsArr.length;\\n\\n        for (int pointIdx = 1; pointIdx < n; pointIdx++) {\\n            String left = new String(Arrays.copyOfRange(digitsArr, 0, pointIdx));\\n            String right = new String(Arrays.copyOfRange(digitsArr, pointIdx, n));\\n            String floatNum = build(left, right, false);\\n\\n            if (isValid(floatNum)) {\\n                answer.add(floatNum);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    private String build(String left, String right, boolean comaSep) {\\n        StringBuilder builder = new StringBuilder();\\n\\n        if (comaSep) {\\n            builder.append(\"(\");\\n        }\\n\\n        builder.append(left);\\n\\n        if (comaSep) {\\n            builder.append(\", \");\\n        } else {\\n            builder.append(\".\");\\n        }\\n\\n        builder.append(right);\\n\\n        if (comaSep) {\\n            builder.append(\")\");\\n        }\\n\\n        return builder.toString();\\n    }\\n\\n    private boolean isValid(String value) {\\n        if (value.length() > 1 && value.charAt(1) != \\'.\\' && value.startsWith(\"0\")) {\\n            return false;\\n        }\\n\\n        if (value.contains(\".\") && value.endsWith(\"0\")) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public List<String> ambiguousCoordinates(String digits) {\\n        List<String> answer = new ArrayList<>();\\n        char[] digitsArr = digits.toCharArray();\\n        int n = digitsArr.length;\\n\\n        for (int comaIdx = 2; comaIdx < n - 1; comaIdx++) {\\n            String left = new String(Arrays.copyOfRange(digitsArr, 1, comaIdx));\\n            String right = new String(Arrays.copyOfRange(digitsArr, comaIdx, n - 1));\\n\\n            List<String> leftWithPoint = addPoints(left);\\n            List<String> rightWithPoint = addPoints(right);\\n\\n            for (String leftFloat : leftWithPoint) {\\n                for (String rightFloat : rightWithPoint) {\\n                    answer.add(build(leftFloat, rightFloat, true));\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    private List<String> addPoints(String digits) {\\n\\n        List<String> answer = new ArrayList<>();\\n\\n        if (isValid(digits)) {\\n            answer.add(digits);\\n        }\\n\\n        char[] digitsArr = digits.toCharArray();\\n        int n = digitsArr.length;\\n\\n        for (int pointIdx = 1; pointIdx < n; pointIdx++) {\\n            String left = new String(Arrays.copyOfRange(digitsArr, 0, pointIdx));\\n            String right = new String(Arrays.copyOfRange(digitsArr, pointIdx, n));\\n            String floatNum = build(left, right, false);\\n\\n            if (isValid(floatNum)) {\\n                answer.add(floatNum);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    private String build(String left, String right, boolean comaSep) {\\n        StringBuilder builder = new StringBuilder();\\n\\n        if (comaSep) {\\n            builder.append(\"(\");\\n        }\\n\\n        builder.append(left);\\n\\n        if (comaSep) {\\n            builder.append(\", \");\\n        } else {\\n            builder.append(\".\");\\n        }\\n\\n        builder.append(right);\\n\\n        if (comaSep) {\\n            builder.append(\")\");\\n        }\\n\\n        return builder.toString();\\n    }\\n\\n    private boolean isValid(String value) {\\n        if (value.length() > 1 && value.charAt(1) != \\'.\\' && value.startsWith(\"0\")) {\\n            return false;\\n        }\\n\\n        if (value.contains(\".\") && value.endsWith(\"0\")) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206236,
                "title": "816-the-long-answer",
                "content": "Not a simple one :)\\n\\nLong answer ahead :), with a lot of code duplication. Hopefully others can understand.\\n\\n    var ambiguousCoordinates = function (s) {\\n        let n = s.length;\\n\\n        // answer array\\n        let A = [];\\n\\n        // remove ( and ),   reduce length by 2\\n        s = s.slice(1, n - 1);\\n        n -= 2;\\n\\n        for (let i = 1; i < n; i++) {\\n            let left = s.slice(0, i);\\n            let right = s.slice(i);\\n\\n            // ---------- no decimals\\n\\n            if (\\n                (left.length >= 2 && left.startsWith(\"0\")) ||\\n                (right.length >= 2 && right.startsWith(\"0\"))\\n            ) {\\n            } else {\\n                A.push(\"(\" + left + \", \" + right + \")\");\\n            }\\n\\n            // ---------- left decimal\\n\\n            for (let j = 1; j < left.length; j++) {\\n                left1 = left.slice(0, j);\\n                left2 = left.slice(j);\\n                if (\\n                    (left1.length >= 2 && left1.startsWith(\"0\")) || //\\n                    (left2.length >= 2 && left2.endsWith(\"0\")) || //\\n                    +left2 === 0 || //\\n                    (right.length >= 2 && right.startsWith(\"0\"))\\n                ) {\\n                } else {\\n                    A.push(\"(\" + left1 + \".\" + left2 + \", \" + right + \")\");\\n                }\\n            }\\n\\n            // ---------- right decimal\\n\\n            for (let j = 1; j < right.length; j++) {\\n                right1 = right.slice(0, j);\\n                right2 = right.slice(j);\\n                if (\\n                    (right1.length >= 2 && right1.startsWith(\"0\")) || //\\n                    (right2.length >= 2 && right2.endsWith(\"0\")) || //\\n                    +right2 === 0 || //\\n                    (left.length >= 2 && left.startsWith(\"0\"))\\n                ) {\\n                } else {\\n                    A.push(\"(\" + left + \", \" + right1 + \".\" + right2 + \")\");\\n                }\\n            }\\n\\n            // ---------- left & right decimal\\n\\n            for (let j = 1; j < left.length; j++) {\\n                left1 = left.slice(0, j);\\n                left2 = left.slice(j);\\n                if (\\n                    (left1.length >= 2 && left1.startsWith(\"0\")) || //\\n                    (left2.length >= 2 && left2.endsWith(\"0\")) || //\\n                    +left2 === 0\\n                ) {\\n                } else {\\n                    for (let j = 1; j < right.length; j++) {\\n                        right1 = right.slice(0, j);\\n                        right2 = right.slice(j);\\n\\n                        if (\\n                            (right1.length >= 2 && right1.startsWith(\"0\")) || //\\n                            (right2.length >= 2 && right2.endsWith(\"0\")) || //\\n                            +right2 === 0\\n                        ) {\\n                        } else {\\n                            A.push(\"(\" + left1 + \".\" + left2 + \", \" + right1 + \".\" + right2 + \")\");\\n                        }\\n                    }\\n                }\\n            }\\n\\n            // ---------- right & left decimal\\n\\n            for (let j = 1; j < right.length; j++) {\\n                right1 = right.slice(0, j);\\n                right2 = right.slice(j);\\n                if (\\n                    (right1.length >= 2 && right1.startsWith(\"0\")) || //\\n                    (right2.length >= 2 && right2.endsWith(\"0\")) || //\\n                    +right2 === 0\\n                ) {\\n                } else {\\n                    for (let j = 1; j < left.length; j++) {\\n                        left1 = left.slice(0, j);\\n                        left2 = left.slice(j);\\n                        if (\\n                            (left1.length >= 2 && left1.startsWith(\"0\")) || //\\n                            (left2.length >= 2 && left2.endsWith(\"0\")) || //\\n                            +left2 === 0\\n                        ) {\\n                        } else {\\n                            A.push(\"(\" + left1 + \".\" + left2 + \", \" + right1 + \".\" + right2 + \")\");\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return [...new Set(A)];\\n    };\\n\\n----\\n\\nAfter merging loops into another ( `left` into `left & right`,  and   `right` into `right & left`)\\n\\n    var ambiguousCoordinates = function (s) {\\n        let n = s.length;\\n\\n        // answer array\\n        let A = [];\\n\\n        // remove ( and ),   reduce length by 2\\n        s = s.slice(1, n - 1);\\n        n -= 2;\\n\\n        for (let i = 1; i < n; i++) {\\n            let left = s.slice(0, i);\\n            let right = s.slice(i);\\n\\n            // ---------- no decimals\\n            if (\\n                (left.length >= 2 && left.startsWith(\"0\")) ||\\n                (right.length >= 2 && right.startsWith(\"0\"))\\n            ) {\\n            } else {\\n                A.push(\"(\" + left + \", \" + right + \")\");\\n            }\\n\\n            // left decimal, then  left & right decimal\\n            for (let j = 1; j < left.length; j++) {\\n                left1 = left.slice(0, j);\\n                left2 = left.slice(j);\\n                if (\\n                    (left1.length >= 2 && left1.startsWith(\"0\")) || //\\n                    (left2.length >= 2 && left2.endsWith(\"0\")) || //\\n                    +left2 === 0\\n                ) {\\n                    continue;\\n                }\\n\\n                // ---------- left decimal\\n                if (right.length >= 2 && right.startsWith(\"0\")) {\\n                } else {\\n                    A.push(\"(\" + left1 + \".\" + left2 + \", \" + right + \")\");\\n                }\\n\\n                // ---------- left & right decimal\\n                for (let j = 1; j < right.length; j++) {\\n                    right1 = right.slice(0, j);\\n                    right2 = right.slice(j);\\n                    if (\\n                        (right1.length >= 2 && right1.startsWith(\"0\")) || //\\n                        (right2.length >= 2 && right2.endsWith(\"0\")) || //\\n                        +right2 === 0\\n                    ) {\\n                        continue;\\n                    }\\n\\n                    A.push(\"(\" + left1 + \".\" + left2 + \", \" + right1 + \".\" + right2 + \")\"); //prettier-ignore\\n                }\\n            }\\n\\n            // right decimal, then  right & left decimal\\n            for (let j = 1; j < right.length; j++) {\\n                right1 = right.slice(0, j);\\n                right2 = right.slice(j);\\n                if (\\n                    (right1.length >= 2 && right1.startsWith(\"0\")) || //\\n                    (right2.length >= 2 && right2.endsWith(\"0\")) || //\\n                    +right2 === 0\\n                ) {\\n                    continue;\\n                }\\n\\n                // ---------- right decimal\\n                if (left.length >= 2 && left.startsWith(\"0\")) {\\n                } else {\\n                    A.push(\"(\" + left + \", \" + right1 + \".\" + right2 + \")\");\\n                }\\n\\n                // ---------- right & left decimal\\n                for (let j = 1; j < left.length; j++) {\\n                    left1 = left.slice(0, j);\\n                    left2 = left.slice(j);\\n                    if (\\n                        (left1.length >= 2 && left1.startsWith(\"0\")) || //\\n                        (left2.length >= 2 && left2.endsWith(\"0\")) || //\\n                        +left2 === 0\\n                    ) {\\n                        continue;\\n                    }\\n\\n                    A.push(\"(\" + left1 + \".\" + left2 + \", \" + right1 + \".\" + right2 + \")\"); //prettier-ignore\\n                }\\n            }\\n        }\\n\\n        return [...new Set(A)];\\n    };\\n\\n----\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Not a simple one :)\\n\\nLong answer ahead :), with a lot of code duplication. Hopefully others can understand.\\n\\n    var ambiguousCoordinates = function (s) {\\n        let n = s.length;\\n\\n        // answer array\\n        let A = [];\\n\\n        // remove ( and ),   reduce length by 2\\n        s = s.slice(1, n - 1);\\n        n -= 2;\\n\\n        for (let i = 1; i < n; i++) {\\n            let left = s.slice(0, i);\\n            let right = s.slice(i);\\n\\n            // ---------- no decimals\\n\\n            if (\\n                (left.length >= 2 && left.startsWith(\"0\")) ||\\n                (right.length >= 2 && right.startsWith(\"0\"))\\n            ) {\\n            } else {\\n                A.push(\"(\" + left + \", \" + right + \")\");\\n            }\\n\\n            // ---------- left decimal\\n\\n            for (let j = 1; j < left.length; j++) {\\n                left1 = left.slice(0, j);\\n                left2 = left.slice(j);\\n                if (\\n                    (left1.length >= 2 && left1.startsWith(\"0\")) || //\\n                    (left2.length >= 2 && left2.endsWith(\"0\")) || //\\n                    +left2 === 0 || //\\n                    (right.length >= 2 && right.startsWith(\"0\"))\\n                ) {\\n                } else {\\n                    A.push(\"(\" + left1 + \".\" + left2 + \", \" + right + \")\");\\n                }\\n            }\\n\\n            // ---------- right decimal\\n\\n            for (let j = 1; j < right.length; j++) {\\n                right1 = right.slice(0, j);\\n                right2 = right.slice(j);\\n                if (\\n                    (right1.length >= 2 && right1.startsWith(\"0\")) || //\\n                    (right2.length >= 2 && right2.endsWith(\"0\")) || //\\n                    +right2 === 0 || //\\n                    (left.length >= 2 && left.startsWith(\"0\"))\\n                ) {\\n                } else {\\n                    A.push(\"(\" + left + \", \" + right1 + \".\" + right2 + \")\");\\n                }\\n            }\\n\\n            // ---------- left & right decimal\\n\\n            for (let j = 1; j < left.length; j++) {\\n                left1 = left.slice(0, j);\\n                left2 = left.slice(j);\\n                if (\\n                    (left1.length >= 2 && left1.startsWith(\"0\")) || //\\n                    (left2.length >= 2 && left2.endsWith(\"0\")) || //\\n                    +left2 === 0\\n                ) {\\n                } else {\\n                    for (let j = 1; j < right.length; j++) {\\n                        right1 = right.slice(0, j);\\n                        right2 = right.slice(j);\\n\\n                        if (\\n                            (right1.length >= 2 && right1.startsWith(\"0\")) || //\\n                            (right2.length >= 2 && right2.endsWith(\"0\")) || //\\n                            +right2 === 0\\n                        ) {\\n                        } else {\\n                            A.push(\"(\" + left1 + \".\" + left2 + \", \" + right1 + \".\" + right2 + \")\");\\n                        }\\n                    }\\n                }\\n            }\\n\\n            // ---------- right & left decimal\\n\\n            for (let j = 1; j < right.length; j++) {\\n                right1 = right.slice(0, j);\\n                right2 = right.slice(j);\\n                if (\\n                    (right1.length >= 2 && right1.startsWith(\"0\")) || //\\n                    (right2.length >= 2 && right2.endsWith(\"0\")) || //\\n                    +right2 === 0\\n                ) {\\n                } else {\\n                    for (let j = 1; j < left.length; j++) {\\n                        left1 = left.slice(0, j);\\n                        left2 = left.slice(j);\\n                        if (\\n                            (left1.length >= 2 && left1.startsWith(\"0\")) || //\\n                            (left2.length >= 2 && left2.endsWith(\"0\")) || //\\n                            +left2 === 0\\n                        ) {\\n                        } else {\\n                            A.push(\"(\" + left1 + \".\" + left2 + \", \" + right1 + \".\" + right2 + \")\");\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return [...new Set(A)];\\n    };\\n\\n----\\n\\nAfter merging loops into another ( `left` into `left & right`,  and   `right` into `right & left`)\\n\\n    var ambiguousCoordinates = function (s) {\\n        let n = s.length;\\n\\n        // answer array\\n        let A = [];\\n\\n        // remove ( and ),   reduce length by 2\\n        s = s.slice(1, n - 1);\\n        n -= 2;\\n\\n        for (let i = 1; i < n; i++) {\\n            let left = s.slice(0, i);\\n            let right = s.slice(i);\\n\\n            // ---------- no decimals\\n            if (\\n                (left.length >= 2 && left.startsWith(\"0\")) ||\\n                (right.length >= 2 && right.startsWith(\"0\"))\\n            ) {\\n            } else {\\n                A.push(\"(\" + left + \", \" + right + \")\");\\n            }\\n\\n            // left decimal, then  left & right decimal\\n            for (let j = 1; j < left.length; j++) {\\n                left1 = left.slice(0, j);\\n                left2 = left.slice(j);\\n                if (\\n                    (left1.length >= 2 && left1.startsWith(\"0\")) || //\\n                    (left2.length >= 2 && left2.endsWith(\"0\")) || //\\n                    +left2 === 0\\n                ) {\\n                    continue;\\n                }\\n\\n                // ---------- left decimal\\n                if (right.length >= 2 && right.startsWith(\"0\")) {\\n                } else {\\n                    A.push(\"(\" + left1 + \".\" + left2 + \", \" + right + \")\");\\n                }\\n\\n                // ---------- left & right decimal\\n                for (let j = 1; j < right.length; j++) {\\n                    right1 = right.slice(0, j);\\n                    right2 = right.slice(j);\\n                    if (\\n                        (right1.length >= 2 && right1.startsWith(\"0\")) || //\\n                        (right2.length >= 2 && right2.endsWith(\"0\")) || //\\n                        +right2 === 0\\n                    ) {\\n                        continue;\\n                    }\\n\\n                    A.push(\"(\" + left1 + \".\" + left2 + \", \" + right1 + \".\" + right2 + \")\"); //prettier-ignore\\n                }\\n            }\\n\\n            // right decimal, then  right & left decimal\\n            for (let j = 1; j < right.length; j++) {\\n                right1 = right.slice(0, j);\\n                right2 = right.slice(j);\\n                if (\\n                    (right1.length >= 2 && right1.startsWith(\"0\")) || //\\n                    (right2.length >= 2 && right2.endsWith(\"0\")) || //\\n                    +right2 === 0\\n                ) {\\n                    continue;\\n                }\\n\\n                // ---------- right decimal\\n                if (left.length >= 2 && left.startsWith(\"0\")) {\\n                } else {\\n                    A.push(\"(\" + left + \", \" + right1 + \".\" + right2 + \")\");\\n                }\\n\\n                // ---------- right & left decimal\\n                for (let j = 1; j < left.length; j++) {\\n                    left1 = left.slice(0, j);\\n                    left2 = left.slice(j);\\n                    if (\\n                        (left1.length >= 2 && left1.startsWith(\"0\")) || //\\n                        (left2.length >= 2 && left2.endsWith(\"0\")) || //\\n                        +left2 === 0\\n                    ) {\\n                        continue;\\n                    }\\n\\n                    A.push(\"(\" + left1 + \".\" + left2 + \", \" + right1 + \".\" + right2 + \")\"); //prettier-ignore\\n                }\\n            }\\n        }\\n\\n        return [...new Set(A)];\\n    };\\n\\n----\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1206129,
                "title": "c-clean-and-short-codes",
                "content": "```\\nchar buf[14];\\nclass Solution {\\npublic:\\n    inline bool check(const char *c, int n) {\\n        return 1==n||c[0]!=\\'0\\'||c[n-1]!=\\'0\\';\\n    }\\n    vector<string> helper (const char *c, int n) {\\n        vector<string> ans;\\n        if(n==1) {\\n            ans.push_back(string(c, 1));\\n            return move(ans);\\n        }\\n        if(c[0]==\\'0\\') {\\n            buf[0]=\\'0\\';\\n            buf[1]=\\'.\\';\\n            for(int i=1; i<n; ++i) {\\n                buf[i+1]=c[i];\\n            }\\n            buf[n+1]=\\'\\\\0\\';\\n            ans.push_back(buf);\\n        } else if(c[n-1]==\\'0\\'){\\n            ans.push_back(string(c,n));\\n        } else {\\n            for(int i=0; i<n; ++i) {\\n                buf[i]=c[i];\\n            }\\n            buf[n]=\\'\\\\0\\';\\n            buf[n+1]=\\'\\\\0\\';\\n            ans.push_back(buf);\\n            buf[n]=\\'.\\';\\n            for(int i=n-1; i>0; --i){\\n                swap(buf[i], buf[i+1]);\\n                ans.push_back(buf);\\n            }\\n        }\\n        return move(ans);\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int N=s.size()-2;\\n        const char * c =s.c_str()+1;\\n        string str(\"(\");\\n        vector<string> ans;\\n        for(int i=0; i<N-1; ++i) {\\n            // cout<<string(c, i+1)<<\":\"<<check(c, i+1)<<\" | \"\\n            //     <<string(c+i+1, N-i-1)<<\":\"<<check(c+i+1, N-i-1)<<\"\\\\n\";\\n            if(check(c, i+1) && check(c+i+1, N-i-1)) {\\n                auto left=helper(c, i+1);\\n                auto right=helper(c+i+1, N-i-1);\\n                for(auto &l:left) {\\n                    for(auto &r:right) {\\n                        ans.push_back(str+l+\", \"+r+\")\");\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nchar buf[14];\\nclass Solution {\\npublic:\\n    inline bool check(const char *c, int n) {\\n        return 1==n||c[0]!=\\'0\\'||c[n-1]!=\\'0\\';\\n    }\\n    vector<string> helper (const char *c, int n) {\\n        vector<string> ans;\\n        if(n==1) {\\n            ans.push_back(string(c, 1));\\n            return move(ans);\\n        }\\n        if(c[0]==\\'0\\') {\\n            buf[0]=\\'0\\';\\n            buf[1]=\\'.\\';\\n            for(int i=1; i<n; ++i) {\\n                buf[i+1]=c[i];\\n            }\\n            buf[n+1]=\\'\\\\0\\';\\n            ans.push_back(buf);\\n        } else if(c[n-1]==\\'0\\'){\\n            ans.push_back(string(c,n));\\n        } else {\\n            for(int i=0; i<n; ++i) {\\n                buf[i]=c[i];\\n            }\\n            buf[n]=\\'\\\\0\\';\\n            buf[n+1]=\\'\\\\0\\';\\n            ans.push_back(buf);\\n            buf[n]=\\'.\\';\\n            for(int i=n-1; i>0; --i){\\n                swap(buf[i], buf[i+1]);\\n                ans.push_back(buf);\\n            }\\n        }\\n        return move(ans);\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int N=s.size()-2;\\n        const char * c =s.c_str()+1;\\n        string str(\"(\");\\n        vector<string> ans;\\n        for(int i=0; i<N-1; ++i) {\\n            // cout<<string(c, i+1)<<\":\"<<check(c, i+1)<<\" | \"\\n            //     <<string(c+i+1, N-i-1)<<\":\"<<check(c+i+1, N-i-1)<<\"\\\\n\";\\n            if(check(c, i+1) && check(c+i+1, N-i-1)) {\\n                auto left=helper(c, i+1);\\n                auto right=helper(c+i+1, N-i-1);\\n                for(auto &l:left) {\\n                    for(auto &r:right) {\\n                        ans.push_back(str+l+\", \"+r+\")\");\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1206062,
                "title": "simple-commented-code-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string>fun(string str)\\n    {\\n        vector<string>ans;\\n        int n = str.length();\\n        if(n == 1)\\n        {\\n            return {str};\\n        }\\n        // cases like \"123\"\\n        if(str[0] != \\'0\\')\\n        {\\n            ans.push_back(str);\\n        }\\n        \\n        if(str[0] == \\'0\\')\\n        {\\n            // cases like \"0110\"\\n            if(str.back() == \\'0\\')\\n            {\\n                return {};\\n            }\\n            // cases like \"011\"\\n            return {\"0.\" + str.substr(1)};\\n        }\\n        \\n        // for cases like 123 -- final vector would be {123, 1.23, 12.3}, but\\n        // for cases like 120 -- final vector would be {120} and not {120, 1.20, 12.0} as 1.20 and 12.0 are invalid \\n        if(str.back() != \\'0\\')\\n        {\\n                 for(int i = 1; i < n; i++)\\n                    {\\n                        string first = str.substr(0, i);\\n                        string second = str.substr(i);\\n                        ans.push_back(first + \".\" + second);\\n                    }   \\n        }\\n        return ans;\\n    }\\n    vector<string> ambiguousCoordinates(string s) \\n    {\\n        vector<string>ans;\\n        // removing parenthesis\\n        string str = s.substr(1, s.length() - 2);\\n        int n = str.length();\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            string first = str.substr(0, i);\\n            string second = str.substr(i);\\n            \\n            vector<string>for_first = fun(first);\\n            vector<string>for_second = fun(second);\\n            \\n            for(int i  = 0; i < for_first.size(); i++)\\n            {\\n                for(int j = 0; j < for_second.size(); j++)\\n                {\\n                    ans.push_back(\"(\" + for_first[i] + \", \" + for_second[j] + \")\");\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>fun(string str)\\n    {\\n        vector<string>ans;\\n        int n = str.length();\\n        if(n == 1)\\n        {\\n            return {str};\\n        }\\n        // cases like \"123\"\\n        if(str[0] != \\'0\\')\\n        {\\n            ans.push_back(str);\\n        }\\n        \\n        if(str[0] == \\'0\\')\\n        {\\n            // cases like \"0110\"\\n            if(str.back() == \\'0\\')\\n            {\\n                return {};\\n            }\\n            // cases like \"011\"\\n            return {\"0.\" + str.substr(1)};\\n        }\\n        \\n        // for cases like 123 -- final vector would be {123, 1.23, 12.3}, but\\n        // for cases like 120 -- final vector would be {120} and not {120, 1.20, 12.0} as 1.20 and 12.0 are invalid \\n        if(str.back() != \\'0\\')\\n        {\\n                 for(int i = 1; i < n; i++)\\n                    {\\n                        string first = str.substr(0, i);\\n                        string second = str.substr(i);\\n                        ans.push_back(first + \".\" + second);\\n                    }   \\n        }\\n        return ans;\\n    }\\n    vector<string> ambiguousCoordinates(string s) \\n    {\\n        vector<string>ans;\\n        // removing parenthesis\\n        string str = s.substr(1, s.length() - 2);\\n        int n = str.length();\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            string first = str.substr(0, i);\\n            string second = str.substr(i);\\n            \\n            vector<string>for_first = fun(first);\\n            vector<string>for_second = fun(second);\\n            \\n            for(int i  = 0; i < for_first.size(); i++)\\n            {\\n                for(int j = 0; j < for_second.size(); j++)\\n                {\\n                    ans.push_back(\"(\" + for_first[i] + \", \" + for_second[j] + \")\");\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206052,
                "title": "explained-algorithm-c-clean-code",
                "content": "**Intuition:**\\n1. Need to divide string in two halves and place decimal properly in each half.\\n2. Broke the string in two halves and made valid combination list of each half. \\n3. Received two list from left half and right half - assuming size a and b respectively\\n4. Now simple make (a* b) combinations of all elements present in two lists.\\n\\nWhere to place decimal :\\n1. [0XXXX0] -> {}\\n2. [0XXXXX] -> {0.XXXX}\\n3. [XXXXX0] -> {XXXXX0}\\n4. [XXXX] -> [XXXX]+[X.XXX]+[XX.XX]+[XXX.X] \\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> insertDecimal(string s){\\n        int n = s.length();\\n        \\n        vector<string> v;\\n        \\n        if(n == 0)\\n            return {};\\n        if(n == 1)\\n            return {s};\\n            \\n        if(s[0] == \\'0\\' && s[n-1] == \\'0\\')\\n            return {};\\n        if(s[0] == \\'0\\')\\n            return {\"0.\"+s.substr(1)};\\n        if(s[n-1] == \\'0\\')\\n            return {s};\\n        v.emplace_back(s);\\n        for(int i = 1; i<n; i++){\\n            v.emplace_back(s.substr(0,i)+\".\"+s.substr(i));\\n        }\\n        return v;\\n        \\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.length();\\n        vector<string> ans;\\n        \\n        for(int i = 1; i<n-2; i++){\\n            string s1 = s.substr(1,i);\\n            string s2 = s.substr(i+1,n-i-2);\\n            \\n            //cout<<s1<<\" \"<<s2<<endl;\\n            \\n            vector<string> v1 = insertDecimal(s1);\\n            vector<string> v2 = insertDecimal(s2);\\n            \\n            for(string s1 : v1){\\n                for(string s2 :  v2){\\n                    ans.emplace_back(\"(\"+s1+\", \"+s2+\")\");\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Time complexity** - O(n^3)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> insertDecimal(string s){\\n        int n = s.length();\\n        \\n        vector<string> v;\\n        \\n        if(n == 0)\\n            return {};\\n        if(n == 1)\\n            return {s};\\n            \\n        if(s[0] == \\'0\\' && s[n-1] == \\'0\\')\\n            return {};\\n        if(s[0] == \\'0\\')\\n            return {\"0.\"+s.substr(1)};\\n        if(s[n-1] == \\'0\\')\\n            return {s};\\n        v.emplace_back(s);\\n        for(int i = 1; i<n; i++){\\n            v.emplace_back(s.substr(0,i)+\".\"+s.substr(i));\\n        }\\n        return v;\\n        \\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.length();\\n        vector<string> ans;\\n        \\n        for(int i = 1; i<n-2; i++){\\n            string s1 = s.substr(1,i);\\n            string s2 = s.substr(i+1,n-i-2);\\n            \\n            //cout<<s1<<\" \"<<s2<<endl;\\n            \\n            vector<string> v1 = insertDecimal(s1);\\n            vector<string> v2 = insertDecimal(s2);\\n            \\n            for(string s1 : v1){\\n                for(string s2 :  v2){\\n                    ans.emplace_back(\"(\"+s1+\", \"+s2+\")\");\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 887214,
                "title": "python3-straightforward-solution-ambiguous-coordinates",
                "content": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, S: str) -> List[str]:\\n        S = S[1:-1]\\n        def numbers(s):\\n            ans = []\\n            for i in range(1, len(s)+1):\\n                ns = s[:i]\\n                if s[i:]:\\n                    ns += \".\" + s[i:]\\n                if len(ns) > 1 and (\\n                    ns[0] == \\'0\\' and ns[-1] == \\'0\\' or\\n                    ns[0] == \\'0\\' and ns[1] != \\'.\\' or\\n                    ns[-1] == \\'0\\' and \\'.\\' in ns):\\n                    continue\\n                ans.append(ns)    \\n            return ans        \\n        return [\\'(\\' + p[0] + \\', \\' + p[1] + \\')\\'\\n               for i in range(1, len(S))\\n               for p in itertools.product(numbers(S[:i]), numbers(S[i:]))]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, S: str) -> List[str]:\\n        S = S[1:-1]\\n        def numbers(s):\\n            ans = []\\n            for i in range(1, len(s)+1):\\n                ns = s[:i]\\n                if s[i:]:\\n                    ns += \".\" + s[i:]\\n                if len(ns) > 1 and (\\n                    ns[0] == \\'0\\' and ns[-1] == \\'0\\' or\\n                    ns[0] == \\'0\\' and ns[1] != \\'.\\' or\\n                    ns[-1] == \\'0\\' and \\'.\\' in ns):\\n                    continue\\n                ans.append(ns)    \\n            return ans        \\n        return [\\'(\\' + p[0] + \\', \\' + p[1] + \\')\\'\\n               for i in range(1, len(S))\\n               for p in itertools.product(numbers(S[:i]), numbers(S[i:]))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763418,
                "title": "c-easy-solution-explained",
                "content": "The idea is very simple. We continuously split the substring in 2 parts. One is our x coordinate the other is y coordinate. Now the helper function finds the number of ways we can form the x coordinate and the y coordinate, we form the final string by combining all x coordinates and y coordinates. Rest of the explanation is in code. Comment for any doubt.\\n```\\nclass Solution {\\npublic:\\n    vector <string> helper(string s)\\n    {\\n        vector <string> v;\\n        if(s.size()<2)\\n            return {s};\\n        int n=s.size();\\n        if(s[0]==\\'0\\')\\n        {\\n             if(s[n-1]==\\'0\\')\\n                 return {};\\n            string t=s.substr(0,1)+ \\'.\\' + s.substr(1); // if s[0] is 0, only possible solution is 0.xxxxx where last digit!=0\\n            return {t};\\n        }\\n        if(s[n-1]==\\'0\\')\\n            return {s}; // if last digit is 0, only possible solution is the string itself\\n        for(int i=0;i<n-1;i++)\\n        {\\n            v.push_back(s.substr(0,i+1)+\\'.\\'+s.substr(i+1)); // \\'.\\' in between all substrings\\n        }\\n        v.push_back(s);\\n        return v;\\n        \\n    }\\n    vector<string> ambiguousCoordinates(string S) {\\n        int n=S.size();\\n        \\n        vector <string> ans;\\n        vector <string> v1,v2;\\n        for(int i=1;i<n-2;i++)\\n        {\\n            v1.clear();\\n            v2.clear();\\n            v1= helper(S.substr(1,i));\\n            v2= helper(S.substr(i+1,n-i-2));\\n            cout<<S.substr(1,i)<<\" \"<<S.substr(i+1,n-i-2)<<\" \";\\n            if(v1.empty() || v2.empty())\\n                continue;\\n            for(int a=0;a<v1.size();a++)\\n            {\\n                for(int b=0;b<v2.size();b++)\\n                {\\n                    ans.push_back(\\'(\\'+v1[a]+\\',\\'+\\' \\'+v2[b]+\\')\\');\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector <string> helper(string s)\\n    {\\n        vector <string> v;\\n        if(s.size()<2)\\n            return {s};\\n        int n=s.size();\\n        if(s[0]==\\'0\\')\\n        {\\n             if(s[n-1]==\\'0\\')\\n                 return {};\\n            string t=s.substr(0,1)+ \\'.\\' + s.substr(1); // if s[0] is 0, only possible solution is 0.xxxxx where last digit!=0\\n            return {t};\\n        }\\n        if(s[n-1]==\\'0\\')\\n            return {s}; // if last digit is 0, only possible solution is the string itself\\n        for(int i=0;i<n-1;i++)\\n        {\\n            v.push_back(s.substr(0,i+1)+\\'.\\'+s.substr(i+1)); // \\'.\\' in between all substrings\\n        }\\n        v.push_back(s);\\n        return v;\\n        \\n    }\\n    vector<string> ambiguousCoordinates(string S) {\\n        int n=S.size();\\n        \\n        vector <string> ans;\\n        vector <string> v1,v2;\\n        for(int i=1;i<n-2;i++)\\n        {\\n            v1.clear();\\n            v2.clear();\\n            v1= helper(S.substr(1,i));\\n            v2= helper(S.substr(i+1,n-i-2));\\n            cout<<S.substr(1,i)<<\" \"<<S.substr(i+1,n-i-2)<<\" \";\\n            if(v1.empty() || v2.empty())\\n                continue;\\n            for(int a=0;a<v1.size();a++)\\n            {\\n                for(int b=0;b<v2.size();b++)\\n                {\\n                    ans.push_back(\\'(\\'+v1[a]+\\',\\'+\\' \\'+v2[b]+\\')\\');\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 600675,
                "title": "java-solution-with-a-simple-predicate",
                "content": "```\\nclass Solution {\\n    private Predicate<String> coordinatePredicate =\\n            s -> !(s.contains(\".\") && s.endsWith(\"0\") || s.startsWith(\"0\") && s.length() > 1 && !s.startsWith(\"0.\"));\\n\\n    private String removeParentheses(String s) {\\n        return s.substring(1, s.length() - 1);\\n    }\\n\\n    public List<String> ambiguousCoordinates(String S) {\\n        List<String> result = new ArrayList<>();\\n        S = removeParentheses(S);\\n        for (int i = 1; i < S.length(); i++) {\\n            result.addAll(combine(\\n                    possibleCoordinates(S.substring(0, i)),\\n                    possibleCoordinates(S.substring(i))\\n            ));\\n        }\\n        return result;\\n    }\\n\\n    private List<String> possibleCoordinates(String s) {\\n        return IntStream.range(0, s.length())\\n                .mapToObj(i -> insertDot(s, i))\\n                .filter(coordinatePredicate)\\n                .collect(Collectors.toList());\\n    }\\n\\n    private static String insertDot(String val, int place) {\\n        if (place == 0) {\\n            return val;\\n        }\\n        return val.substring(0, place) + \".\" + val.substring(place);\\n    }\\n\\n    private static List<String> combine(List<String> l1, List<String> l2) {\\n        return l1.stream().flatMap(s1 -> l2.stream().map(s2 -> \"(\" + s1 + \", \" + s2 + \")\")).collect(Collectors.toList());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private Predicate<String> coordinatePredicate =\\n            s -> !(s.contains(\".\") && s.endsWith(\"0\") || s.startsWith(\"0\") && s.length() > 1 && !s.startsWith(\"0.\"));\\n\\n    private String removeParentheses(String s) {\\n        return s.substring(1, s.length() - 1);\\n    }\\n\\n    public List<String> ambiguousCoordinates(String S) {\\n        List<String> result = new ArrayList<>();\\n        S = removeParentheses(S);\\n        for (int i = 1; i < S.length(); i++) {\\n            result.addAll(combine(\\n                    possibleCoordinates(S.substring(0, i)),\\n                    possibleCoordinates(S.substring(i))\\n            ));\\n        }\\n        return result;\\n    }\\n\\n    private List<String> possibleCoordinates(String s) {\\n        return IntStream.range(0, s.length())\\n                .mapToObj(i -> insertDot(s, i))\\n                .filter(coordinatePredicate)\\n                .collect(Collectors.toList());\\n    }\\n\\n    private static String insertDot(String val, int place) {\\n        if (place == 0) {\\n            return val;\\n        }\\n        return val.substring(0, place) + \".\" + val.substring(place);\\n    }\\n\\n    private static List<String> combine(List<String> l1, List<String> l2) {\\n        return l1.stream().flatMap(s1 -> l2.stream().map(s2 -> \"(\" + s1 + \", \" + s2 + \")\")).collect(Collectors.toList());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 553676,
                "title": "python-intuitive-solution",
                "content": "```\\n\\'\\'\\'\\nSplit the number into left and right halves.\\nCompute possible combinations of each half\\npick one from left comb and one from right comb to build final results.\\nwhen build the combinations of a given word, the helper function doesn\\'t count invalid numbers.\\ntime complexity: O(n*n*n)\\nspace: O(n*n)\\n\\'\\'\\'\\nclass Solution:\\n    def ambiguousCoordinates(self, S: str) -> List[str]:\\n        res = []\\n        len_S = len(S)\\n        for i in range(2,len_S-1):\\n            left = S[1:i]\\n            right = S[i:len_S-1]\\n            left_comb = self.helper(left)\\n            right_comb = self.helper(right)\\n            for l in left_comb:\\n                for r in right_comb:\\n                    res.append(\\'(\\'+l+\\', \\'+r+\\')\\')\\n        return res\\n    \\n    def helper(self, word):\\n        if len(word) == 1:\\n            return [word]\\n        if word[0] == \\'0\\':\\n            if word[-1] != \\'0\\':\\n                return [\\'0.\\'+word[1:]]\\n            return []\\n        res = [word]\\n        if word[-1] != \\'0\\':\\n            for i in range(1, len(word)):\\n                res.append(word[:i]+\\'.\\'+word[i:])\\n        return res\\n            \\n```",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\nSplit the number into left and right halves.\\nCompute possible combinations of each half\\npick one from left comb and one from right comb to build final results.\\nwhen build the combinations of a given word, the helper function doesn\\'t count invalid numbers.\\ntime complexity: O(n*n*n)\\nspace: O(n*n)\\n\\'\\'\\'\\nclass Solution:\\n    def ambiguousCoordinates(self, S: str) -> List[str]:\\n        res = []\\n        len_S = len(S)\\n        for i in range(2,len_S-1):\\n            left = S[1:i]\\n            right = S[i:len_S-1]\\n            left_comb = self.helper(left)\\n            right_comb = self.helper(right)\\n            for l in left_comb:\\n                for r in right_comb:\\n                    res.append(\\'(\\'+l+\\', \\'+r+\\')\\')\\n        return res\\n    \\n    def helper(self, word):\\n        if len(word) == 1:\\n            return [word]\\n        if word[0] == \\'0\\':\\n            if word[-1] != \\'0\\':\\n                return [\\'0.\\'+word[1:]]\\n            return []\\n        res = [word]\\n        if word[-1] != \\'0\\':\\n            for i in range(1, len(word)):\\n                res.append(word[:i]+\\'.\\'+word[i:])\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 188921,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun ambiguousCoordinates(S: String): List<String> {\\n        val content = S.substring(1, S.length - 1)\\n        if (content.length <= 1) return listOf()\\n        return (0 until content.length - 1).flatMap {\\n            val left = decimals(content.substring(0, it + 1))\\n            val right = decimals(content.substring(it + 1))\\n            if (left != null && right != null) {\\n                left.flatMap { l -> right.map { r -> \"($l, $r)\"} }\\n            } else {\\n                emptyList()\\n            }\\n        }\\n    }\\n\\n    private fun decimals(S: String): List<String>? {\\n        if (S[0] == \\'0\\') {\\n            if (S.length == 1) return listOf(\"0\")\\n            if (S.all { it == \\'0\\' }) return null\\n            if (S.last() == \\'0\\') return null\\n            return listOf(\"0.${S.substring(1)}\")\\n        } else {\\n            return if (S.last() == \\'0\\') listOf(S) else (0 until S.length).map {\\n                if (it < S.length - 1) \"${S.substring(0, it + 1)}.${S.substring(it + 1)}\" else S\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun ambiguousCoordinates(S: String): List<String> {\\n        val content = S.substring(1, S.length - 1)\\n        if (content.length <= 1) return listOf()\\n        return (0 until content.length - 1).flatMap {\\n            val left = decimals(content.substring(0, it + 1))\\n            val right = decimals(content.substring(it + 1))\\n            if (left != null && right != null) {\\n                left.flatMap { l -> right.map { r -> \"($l, $r)\"} }\\n            } else {\\n                emptyList()\\n            }\\n        }\\n    }\\n\\n    private fun decimals(S: String): List<String>? {\\n        if (S[0] == \\'0\\') {\\n            if (S.length == 1) return listOf(\"0\")\\n            if (S.all { it == \\'0\\' }) return null\\n            if (S.last() == \\'0\\') return null\\n            return listOf(\"0.${S.substring(1)}\")\\n        } else {\\n            return if (S.last() == \\'0\\') listOf(S) else (0 until S.length).map {\\n                if (it < S.length - 1) \"${S.substring(0, it + 1)}.${S.substring(it + 1)}\" else S\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158464,
                "title": "c-real-clear-8ms-solution-beats-100",
                "content": "```\\n    vector<string> ambiguousCoordinates(string S) {\\n        vector<string> res;\\n        for(int i=1;i<S.size()-2;i++) {\\n            vector<string> left=makeNum(S.substr(1, i));\\n            vector<string> right=makeNum(S.substr(i+1, S.size()-2-i));\\n            for(int m=0;m<left.size();m++) {\\n                for(int n=0;n<right.size();n++) res.push_back(\"(\"+left[m]+\", \"+right[n]+\")\");\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    vector<string> makeNum(string num) {\\n        vector<string> res;\\n        if(num[0]!=\\'0\\'||num.size()==1) res.push_back(num);\\n        for(int i=0;i<num.size()-1;i++) {\\n            if((num[0]==\\'0\\'&&i!=0)||num.back()==\\'0\\') continue;\\n            res.push_back(num.substr(0, i+1)+\".\"+num.substr(i+1));\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    vector<string> ambiguousCoordinates(string S) {\\n        vector<string> res;\\n        for(int i=1;i<S.size()-2;i++) {\\n            vector<string> left=makeNum(S.substr(1, i));\\n            vector<string> right=makeNum(S.substr(i+1, S.size()-2-i));\\n            for(int m=0;m<left.size();m++) {\\n                for(int n=0;n<right.size();n++) res.push_back(\"(\"+left[m]+\", \"+right[n]+\")\");\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    vector<string> makeNum(string num) {\\n        vector<string> res;\\n        if(num[0]!=\\'0\\'||num.size()==1) res.push_back(num);\\n        for(int i=0;i<num.size()-1;i++) {\\n            if((num[0]==\\'0\\'&&i!=0)||num.back()==\\'0\\') continue;\\n            res.push_back(num.substr(0, i+1)+\".\"+num.substr(i+1));\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4090391,
                "title": "c-annoying-validation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force with validation of generated numbers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Split input into 2 parts (left & right) process each in seperation.\\n- Combine results in nested loop.\\n- Call function to validate if generated number looks reasonable.\\n\\n# Complexity\\n- Time complexity:\\nSeems like a $$O(n^3)$$ in the worst case.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSeems like a $$O(n^2)$$ in the worst case.\\n\\n# Code\\n```\\npublic class Solution {\\n\\n    bool reasonable(string s)\\n    {\\n// use a hack to simplofy\\n         if (s.IndexOf(\\'.\\') < 0)\\n         {\\n             return $\"{int.Parse(s)}\" == s;\\n         }\\n                \\n// only cases with floating point left here - can\\'t end with a 0\\n        if (s.Last() == \\'0\\')                        \\n            return false;        \\n\\n// floating point that starts with a 0, means must have a . as 2nd\\n        if (s[0] == \\'0\\')\\n        {\\n            if (s.Length < 3)\\n                return false;\\n\\n            if (s[1] != \\'.\\')\\n            {\\n                return false;\\n            }\\n        }\\n    \\n        return true;\\n    }\\n// generate possible cases out of supplied digits\\n    IList<string> generate(string s)\\n    {\\n        var a = new List<string>();\\n        a.Add(s);\\n        for (int i = 1; i < s.Length; i++)\\n        {\\n            a.Add($\"{s.Substring(0,i)}.{s.Substring(i, s.Length-i)}\");\\n        }\\n        return a;\\n    }\\n\\n    public IList<string> AmbiguousCoordinates(string s) {\\n\\n        var st = s.Substring(1, s.Length-2);\\n        var answer = new List<string>();\\n   // slide possible position of ,     \\n        for (int i = 1; i < st.Length; i++)\\n        {\\n            var ls = st.Substring(0, i);\\n            var rs = st.Substring(i, st.Length-i);\\n\\n            foreach(var lc in generate(ls))\\n            {\\n                if (!reasonable(lc))\\n                    continue;\\n\\n                foreach(var rc in generate(rs))\\n                {\\n                    if (reasonable(rc))\\n                        answer.Add($\"({lc}, {rc})\");\\n                }\\n            }\\n        }    \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n    bool reasonable(string s)\\n    {\\n// use a hack to simplofy\\n         if (s.IndexOf(\\'.\\') < 0)\\n         {\\n             return $\"{int.Parse(s)}\" == s;\\n         }\\n                \\n// only cases with floating point left here - can\\'t end with a 0\\n        if (s.Last() == \\'0\\')                        \\n            return false;        \\n\\n// floating point that starts with a 0, means must have a . as 2nd\\n        if (s[0] == \\'0\\')\\n        {\\n            if (s.Length < 3)\\n                return false;\\n\\n            if (s[1] != \\'.\\')\\n            {\\n                return false;\\n            }\\n        }\\n    \\n        return true;\\n    }\\n// generate possible cases out of supplied digits\\n    IList<string> generate(string s)\\n    {\\n        var a = new List<string>();\\n        a.Add(s);\\n        for (int i = 1; i < s.Length; i++)\\n        {\\n            a.Add($\"{s.Substring(0,i)}.{s.Substring(i, s.Length-i)}\");\\n        }\\n        return a;\\n    }\\n\\n    public IList<string> AmbiguousCoordinates(string s) {\\n\\n        var st = s.Substring(1, s.Length-2);\\n        var answer = new List<string>();\\n   // slide possible position of ,     \\n        for (int i = 1; i < st.Length; i++)\\n        {\\n            var ls = st.Substring(0, i);\\n            var rs = st.Substring(i, st.Length-i);\\n\\n            foreach(var lc in generate(ls))\\n            {\\n                if (!reasonable(lc))\\n                    continue;\\n\\n                foreach(var rc in generate(rs))\\n                {\\n                    if (reasonable(rc))\\n                        answer.Add($\"({lc}, {rc})\");\\n                }\\n            }\\n        }    \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049037,
                "title": "go-solution-with-comments",
                "content": "```\\nfunc ambiguousCoordinates(s string) []string {\\n    res := []string{}\\n    // remove parenthesis\\n    s = s[1:len(s) - 1]\\n\\n    for i := 1; i < len(s); i++ {\\n        // generate possible x coordinates based on split\\n        lefts := gen(s, 0, i)\\n        // generate possible y coordinates based on split\\n        rights := gen(s, i, len(s))\\n\\n        // for each possible pair of  coordinates\\n        for _, left := range lefts {\\n            for _, right := range rights {\\n                val := \"(\" + left + \", \" + right + \")\"\\n                res = append(res, val)\\n            }\\n        }\\n    }\\n\\n    return res\\n}\\n\\nfunc gen(s string, start, end int) []string {\\n    res := []string{}\\n\\n    // partitioning for whole number and decimal part\\n    for p := 1; p <= end - start; p++ {\\n        // whole number part\\n        w := s[start:start + p]\\n        // decimal number part\\n        d := s[start + p:end]\\n\\n        // either whole number part is a zero or it cannot start with zero\\n        // and either decimal part doesn\\'t exist or it cannot end with a zero\\n        if (w == \"0\" || w[0] != \\'0\\') && (len(d) == 0 || d[len(d) - 1] != \\'0\\') {\\n            if len(d) == 0 {\\n                // decimal part does not exist\\n                res = append(res, w)\\n            } else {\\n                // decimal exists\\n                res = append(res, w + \".\" + d)\\n            }\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc ambiguousCoordinates(s string) []string {\\n    res := []string{}\\n    // remove parenthesis\\n    s = s[1:len(s) - 1]\\n\\n    for i := 1; i < len(s); i++ {\\n        // generate possible x coordinates based on split\\n        lefts := gen(s, 0, i)\\n        // generate possible y coordinates based on split\\n        rights := gen(s, i, len(s))\\n\\n        // for each possible pair of  coordinates\\n        for _, left := range lefts {\\n            for _, right := range rights {\\n                val := \"(\" + left + \", \" + right + \")\"\\n                res = append(res, val)\\n            }\\n        }\\n    }\\n\\n    return res\\n}\\n\\nfunc gen(s string, start, end int) []string {\\n    res := []string{}\\n\\n    // partitioning for whole number and decimal part\\n    for p := 1; p <= end - start; p++ {\\n        // whole number part\\n        w := s[start:start + p]\\n        // decimal number part\\n        d := s[start + p:end]\\n\\n        // either whole number part is a zero or it cannot start with zero\\n        // and either decimal part doesn\\'t exist or it cannot end with a zero\\n        if (w == \"0\" || w[0] != \\'0\\') && (len(d) == 0 || d[len(d) - 1] != \\'0\\') {\\n            if len(d) == 0 {\\n                // decimal part does not exist\\n                res = append(res, w)\\n            } else {\\n                // decimal exists\\n                res = append(res, w + \".\" + d)\\n            }\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028585,
                "title": "python-solution-explanation",
                "content": "We can split this problem into two subproblems:\\n1. Get all the possible values for coordinates substring (`102` -> `[1.02, 10.2, 102]`, `00` -> `[]`)\\n2. Get all the possible combinations for two coordinates substrings\\n\\nFor the first subproblem, refer to `variants` function. It should be self-explanatory: we iterate through coordinate substring and split it into whole part and fractional part. Then we validate each part according to problem description. If both parts are valid, we add it to our answer.\\n\\nFor the second subproblem we iterate through input string, split it into two parts, call `variants` function and use `itertools.product` to generate all the possible combinations.\\n\\n# Code\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:len(s) - 1]\\n\\n        @functools.cache\\n        def variants(val):\\n            vals = []\\n\\n            for i in range(1, len(val) + 1):\\n                whole = val[:i]\\n                fractional = val[i:]\\n\\n                if whole[0] == \"0\" and len(whole) > 1:\\n                    continue\\n\\n                if fractional:\\n                    if fractional[-1] == \"0\":\\n                        continue\\n\\n                    vals.append(f\"{whole}.{fractional}\")\\n                else:\\n                    vals.append(whole)    \\n\\n            return vals\\n\\n        result = []\\n\\n        for i in range(1, len(s)):\\n            result.extend(\\n                f\"({a}, {b})\" \\n                for a, b in itertools.product(variants(s[:i]), variants(s[i:]))\\n            )\\n\\n        return result\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:len(s) - 1]\\n\\n        @functools.cache\\n        def variants(val):\\n            vals = []\\n\\n            for i in range(1, len(val) + 1):\\n                whole = val[:i]\\n                fractional = val[i:]\\n\\n                if whole[0] == \"0\" and len(whole) > 1:\\n                    continue\\n\\n                if fractional:\\n                    if fractional[-1] == \"0\":\\n                        continue\\n\\n                    vals.append(f\"{whole}.{fractional}\")\\n                else:\\n                    vals.append(whole)    \\n\\n            return vals\\n\\n        result = []\\n\\n        for i in range(1, len(s)):\\n            result.extend(\\n                f\"({a}, {b})\" \\n                for a, b in itertools.product(variants(s[:i]), variants(s[i:]))\\n            )\\n\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018347,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\n// the constraints are really small so we can use brute force , rest of the code is self explanatory\\n\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        String str = s.substring(1,s.length()-1); // remove brackets from the expression to make it easier to process \\n        List<String> list = new ArrayList();\\n        for(int i =0;i<str.length()-1;i++){\\n            String s1 = str.substring(0,i+1); // first coordinate \\n            String s2 = str.substring(i+1);   // second coordinate \\n            if(isValid(s1)&&isValid(s2)){ // if both are valid numbers , then we will add this to our result \\n                String ans = \"(\"+s1+\", \"+s2+\")\";\\n                list.add(ans);\\n            }\\n            // now we form two lists l1 and l2 , l1 consists of all possible decimal numbers that can be formed from s1 , l2 consists of all possible decimal numbers that can be formed from s2 \\n            List<String> l1 = new ArrayList();\\n            List<String> l2 = new ArrayList();\\n            fillList(s1,l1);\\n            fillList(s2,l2);\\n            for(String ss1 : l1){\\n                for(String ss2 : l2){\\n                     String ans = \"(\"+ss1+\", \"+ss2+\")\"; // adding all (decimal , decimal) pairs to answer\\n                     list.add(ans);\\n                }\\n            }\\n            if(isValid(s1)){ // add all (integer , decimal) pairs to answer if s1 is a valid integer\\n                for(String ss2 : l2){\\n                     String ans = \"(\"+s1+\", \"+ss2+\")\";\\n                     list.add(ans);\\n                }\\n            }\\n            if(isValid(s2)){ // add all (decimal , integer) pairs to answer if s2 is a valid integer \\n                for(String ss1 : l1){\\n                     String ans = \"(\"+ss1+\", \"+s2+\")\";\\n                     list.add(ans);\\n                }\\n            }\\n            \\n   }\\n        return list;\\n    }\\n    public boolean isValid(String s){ // this is used to check if an integer is valid and it is also used to check if part of number before decimal is valid \\n        if(s.length()==1) return true; // always valid \\n        return s.charAt(0)==\\'0\\'?false:true; // form : 0000....... invalid \\n    }\\n    public boolean isSecondValid(String s){ // this is used to check if part of number after decimal is valid \\n        boolean found = false; // found == true if >=\\'1\\' found \\n        for(int i = 0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch>=\\'1\\') found = true;\\n            else{\\n                if(found){ // if >=\\'1\\' found check if after this do we have only zeroes , because 0.5000000 is invalid \\n                    boolean allZeroes = true;\\n                    for(int j = i+1;j<s.length();j++){\\n                        if(s.charAt(j)>=\\'1\\') allZeroes = false;\\n                    }\\n                    if(allZeroes) return false;\\n                }\\n            }\\n        }\\n        return found; // found becomes true when >=\\'1\\' is found so if we have something like 0.0000000 its invalid and we return false in that case \\n    }\\n \\n    public void fillList(String s , List<String> list){ // fills list with all decimal numbers possible from given string s\\n            for(int i = 0;i<s.length()-1;i++){\\n             String s1 = s.substring(0,i+1);\\n             String s2 = s.substring(i+1);\\n             if(isValid(s1)&&isSecondValid(s2)){\\n                 String ans = s1+\".\"+s2;\\n                 list.add(ans);\\n             }\\n            }\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    \\n    bool valid(string t) { // is this coord valid? \\n        int i=1,n=t.size();\\n        if(n>=2 and t[0]==\\'0\\' and t[1]!=\\'.\\') // 01, 03... --> not valid\\n            return false;\\n        \\n        while(i<n and t[i]!=\\'.\\') // get position of the point\\n              i++;\\n        if(i!=n and t[n-1]==\\'0\\') // 234.0, 931.424320 --> not valid\\n            return false;\\n        i++;\\n        while(i<n and t[i]==\\'0\\') // if after the point are all zeros, not valid\\n            i++;\\n        if(i==n) return false;\\n        \\n        return true; // if here, coord is valid\\n   }\\n    \\n    void get_coord(string s1, string s2, vector<string>& res) {\\n        int n1=s1.size(), n2=s2.size();\\n        for(int i=0;i<n1;i++){ \\n            // get every possible partition, as before, but with point at the middle\\n            // es. s1 = 1234 -> (.1234), (1.234), (12.234), (123.4)\\n            string s11 = s1.substr(0,i);\\n            string s12 = s1.substr(i);\\n            string t1 = s11 + \".\" + s12;\\n            if(t1[0] == \\'.\\') // remove initial point if present\\n                t1=t1.substr(1);\\n            if(valid(t1)){ // if it is valid, look at the second string\\n                for(int i=0;i<n2;i++){\\n                    string s21 = s2.substr(0,i);\\n                    string s22 = s2.substr(i);  \\n                    string t2 = s21 + \".\" + s22;\\n                    if(t2[0] == \\'.\\') // remove initial point if present\\n                        t2=t2.substr(1);\\n                    if(valid(t2)){ // if the second is valid too, add to res\\n                        res.push_back(\"(\"+t1+\", \"+t2+\")\");\\n                    }\\n                }\\n            }\\n        }\\n    }   \\n    \\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1,s.size()-2); // string without ( )\\n        vector<string> res;\\n        int n=s.size();\\n        for(int i=0;i<n;i++) {\\n            // get every double partition of string\\n            // es. s = 1234 -> (, 1234), (1, 234), (12, 234), (123, 4)\\n            get_coord(s.substr(0,i), s.substr(i), res); \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\n// the constraints are really small so we can use brute force , rest of the code is self explanatory\\n\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        String str = s.substring(1,s.length()-1); // remove brackets from the expression to make it easier to process \\n        List<String> list = new ArrayList();\\n        for(int i =0;i<str.length()-1;i++){\\n            String s1 = str.substring(0,i+1); // first coordinate \\n            String s2 = str.substring(i+1);   // second coordinate \\n            if(isValid(s1)&&isValid(s2)){ // if both are valid numbers , then we will add this to our result \\n                String ans = \"(\"+s1+\", \"+s2+\")\";\\n                list.add(ans);\\n            }\\n            // now we form two lists l1 and l2 , l1 consists of all possible decimal numbers that can be formed from s1 , l2 consists of all possible decimal numbers that can be formed from s2 \\n            List<String> l1 = new ArrayList();\\n            List<String> l2 = new ArrayList();\\n            fillList(s1,l1);\\n            fillList(s2,l2);\\n            for(String ss1 : l1){\\n                for(String ss2 : l2){\\n                     String ans = \"(\"+ss1+\", \"+ss2+\")\"; // adding all (decimal , decimal) pairs to answer\\n                     list.add(ans);\\n                }\\n            }\\n            if(isValid(s1)){ // add all (integer , decimal) pairs to answer if s1 is a valid integer\\n                for(String ss2 : l2){\\n                     String ans = \"(\"+s1+\", \"+ss2+\")\";\\n                     list.add(ans);\\n                }\\n            }\\n            if(isValid(s2)){ // add all (decimal , integer) pairs to answer if s2 is a valid integer \\n                for(String ss1 : l1){\\n                     String ans = \"(\"+ss1+\", \"+s2+\")\";\\n                     list.add(ans);\\n                }\\n            }\\n            \\n   }\\n        return list;\\n    }\\n    public boolean isValid(String s){ // this is used to check if an integer is valid and it is also used to check if part of number before decimal is valid \\n        if(s.length()==1) return true; // always valid \\n        return s.charAt(0)==\\'0\\'?false:true; // form : 0000....... invalid \\n    }\\n    public boolean isSecondValid(String s){ // this is used to check if part of number after decimal is valid \\n        boolean found = false; // found == true if >=\\'1\\' found \\n        for(int i = 0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch>=\\'1\\') found = true;\\n            else{\\n                if(found){ // if >=\\'1\\' found check if after this do we have only zeroes , because 0.5000000 is invalid \\n                    boolean allZeroes = true;\\n                    for(int j = i+1;j<s.length();j++){\\n                        if(s.charAt(j)>=\\'1\\') allZeroes = false;\\n                    }\\n                    if(allZeroes) return false;\\n                }\\n            }\\n        }\\n        return found; // found becomes true when >=\\'1\\' is found so if we have something like 0.0000000 its invalid and we return false in that case \\n    }\\n \\n    public void fillList(String s , List<String> list){ // fills list with all decimal numbers possible from given string s\\n            for(int i = 0;i<s.length()-1;i++){\\n             String s1 = s.substring(0,i+1);\\n             String s2 = s.substring(i+1);\\n             if(isValid(s1)&&isSecondValid(s2)){\\n                 String ans = s1+\".\"+s2;\\n                 list.add(ans);\\n             }\\n            }\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    \\n    bool valid(string t) { // is this coord valid? \\n        int i=1,n=t.size();\\n        if(n>=2 and t[0]==\\'0\\' and t[1]!=\\'.\\') // 01, 03... --> not valid\\n            return false;\\n        \\n        while(i<n and t[i]!=\\'.\\') // get position of the point\\n              i++;\\n        if(i!=n and t[n-1]==\\'0\\') // 234.0, 931.424320 --> not valid\\n            return false;\\n        i++;\\n        while(i<n and t[i]==\\'0\\') // if after the point are all zeros, not valid\\n            i++;\\n        if(i==n) return false;\\n        \\n        return true; // if here, coord is valid\\n   }\\n    \\n    void get_coord(string s1, string s2, vector<string>& res) {\\n        int n1=s1.size(), n2=s2.size();\\n        for(int i=0;i<n1;i++){ \\n            // get every possible partition, as before, but with point at the middle\\n            // es. s1 = 1234 -> (.1234), (1.234), (12.234), (123.4)\\n            string s11 = s1.substr(0,i);\\n            string s12 = s1.substr(i);\\n            string t1 = s11 + \".\" + s12;\\n            if(t1[0] == \\'.\\') // remove initial point if present\\n                t1=t1.substr(1);\\n            if(valid(t1)){ // if it is valid, look at the second string\\n                for(int i=0;i<n2;i++){\\n                    string s21 = s2.substr(0,i);\\n                    string s22 = s2.substr(i);  \\n                    string t2 = s21 + \".\" + s22;\\n                    if(t2[0] == \\'.\\') // remove initial point if present\\n                        t2=t2.substr(1);\\n                    if(valid(t2)){ // if the second is valid too, add to res\\n                        res.push_back(\"(\"+t1+\", \"+t2+\")\");\\n                    }\\n                }\\n            }\\n        }\\n    }   \\n    \\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1,s.size()-2); // string without ( )\\n        vector<string> res;\\n        int n=s.size();\\n        for(int i=0;i<n;i++) {\\n            // get every double partition of string\\n            // es. s = 1234 -> (, 1234), (1, 234), (12, 234), (123, 4)\\n            get_coord(s.substr(0,i), s.substr(i), res); \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644493,
                "title": "very-simple-intuition-solution-c",
                "content": "# Complexity\\n- Time complexity: O(N^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(vector<string> &ans, string &a, string &b){\\n        // Here we have to validate and then add that to answer\\n        vector<string> tem;\\n        string t = \"(\";\\n        // putting dot on\\n        for(int i=0;i<a.length();i++){\\n            t = \"(\";\\n            if(i == 0) t += a;\\n            else{\\n                t += a.substr(0,i);\\n                t += \\'.\\';\\n                t += a.substr(i,a.length()-i);\\n            }\\n            // Now we got t\\n            // check for 00. or 000. 01.\\n            if(t[1] == \\'0\\'){\\n                // if first char is zero we must see if we got any other char after that or not if we got that we break\\n                if(t.length() > 2 && t[2] != \\'.\\') continue;\\n            }\\n            // check for .000 or .00\\n            if(i != 0 && t[t.length()-1] == \\'0\\') continue;\\n            tem.push_back(t);\\n        }\\n        t = \"\";\\n        for(int i=0;i<b.length();i++){\\n            if(i == 0) t = b;\\n            else{\\n                t = b.substr(0,i);\\n                t += \\'.\\';\\n                t += b.substr(i,b.length()-i);\\n            }\\n            // Now we got t\\n            // check for 00. or 000. 01.\\n            if(t[0] == \\'0\\'){\\n                // if first char is zero we must see if we got any other char after that or not if we got that we break\\n                if(t.length() > 1 && t[1] != \\'.\\') continue;\\n            }\\n            // check for .000 or .00\\n            if(i != 0 && t[t.length()-1] == \\'0\\') continue;\\n            for(auto s: tem){\\n                string n = s;\\n                n += \", \";\\n                n += t;\\n                n += \\')\\';\\n                ans.push_back(n);\\n            }\\n        }\\n    }\\n    \\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string> ans;\\n        string fi = \"\", se = \"\";\\n        // we are making first coordinate and second then try to add point in all and validate \\n        for(int j = 1;j<s.length()-2;j++){\\n            fi += s[j];\\n            se = s.substr(j+1,s.length()-1-(j+1));\\n            // Now we have to pass this\\n            solve(ans,fi,se);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(vector<string> &ans, string &a, string &b){\\n        // Here we have to validate and then add that to answer\\n        vector<string> tem;\\n        string t = \"(\";\\n        // putting dot on\\n        for(int i=0;i<a.length();i++){\\n            t = \"(\";\\n            if(i == 0) t += a;\\n            else{\\n                t += a.substr(0,i);\\n                t += \\'.\\';\\n                t += a.substr(i,a.length()-i);\\n            }\\n            // Now we got t\\n            // check for 00. or 000. 01.\\n            if(t[1] == \\'0\\'){\\n                // if first char is zero we must see if we got any other char after that or not if we got that we break\\n                if(t.length() > 2 && t[2] != \\'.\\') continue;\\n            }\\n            // check for .000 or .00\\n            if(i != 0 && t[t.length()-1] == \\'0\\') continue;\\n            tem.push_back(t);\\n        }\\n        t = \"\";\\n        for(int i=0;i<b.length();i++){\\n            if(i == 0) t = b;\\n            else{\\n                t = b.substr(0,i);\\n                t += \\'.\\';\\n                t += b.substr(i,b.length()-i);\\n            }\\n            // Now we got t\\n            // check for 00. or 000. 01.\\n            if(t[0] == \\'0\\'){\\n                // if first char is zero we must see if we got any other char after that or not if we got that we break\\n                if(t.length() > 1 && t[1] != \\'.\\') continue;\\n            }\\n            // check for .000 or .00\\n            if(i != 0 && t[t.length()-1] == \\'0\\') continue;\\n            for(auto s: tem){\\n                string n = s;\\n                n += \", \";\\n                n += t;\\n                n += \\')\\';\\n                ans.push_back(n);\\n            }\\n        }\\n    }\\n    \\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string> ans;\\n        string fi = \"\", se = \"\";\\n        // we are making first coordinate and second then try to add point in all and validate \\n        for(int j = 1;j<s.length()-2;j++){\\n            fi += s[j];\\n            se = s.substr(j+1,s.length()-1-(j+1));\\n            // Now we have to pass this\\n            solve(ans,fi,se);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592211,
                "title": "easy-division",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsuppose s=pre+suf, the corresponding coordinates include the join of all possible divisions of pre/suf. Note that, for any pre/suf, it is not valid for division if the length of it is larger than 1 and both the front and end of it are \\'0\\'s.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^3)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    unordered_map<string,vector<string>> mp;\\n    vector<string> helper(string&s){\\n        if(mp.count(s)) return mp[s];\\n        if(s.size()>1 and s[0]==\\'0\\' and s.back()==\\'0\\') return {};\\n        if(s.back()==\\'0\\'){\\n            mp[s]={s};\\n            return mp[s];\\n        }\\n        if(s[0]==\\'0\\'){\\n            string tmp=s.substr(0,1)+\\'.\\'+s.substr(1);\\n            mp[s]={tmp};\\n            return mp[s];\\n        }\\n        for(int i=1;i<s.size();i++){\\n            string tmp=s.substr(0,i)+\\'.\\'+s.substr(i);\\n            mp[s].emplace_back(tmp);\\n        }\\n        mp[s].emplace_back(s);\\n        return mp[s];\\n    }\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string> result;\\n        for(int i=1;i+2<s.size();i++){\\n            string pre=s.substr(1,i),suf=s.substr(i+1,s.size()-i-2);\\n            auto ss1=helper(pre);\\n            auto ss2=helper(suf);\\n            if(ss1.empty() or ss2.empty())  continue;\\n            for(auto&x:ss1) for(auto&y:ss2){\\n                    string tmp=\"(\"+x+\", \"+y+\")\";\\n                    result.emplace_back(tmp);\\n                }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<string,vector<string>> mp;\\n    vector<string> helper(string&s){\\n        if(mp.count(s)) return mp[s];\\n        if(s.size()>1 and s[0]==\\'0\\' and s.back()==\\'0\\') return {};\\n        if(s.back()==\\'0\\'){\\n            mp[s]={s};\\n            return mp[s];\\n        }\\n        if(s[0]==\\'0\\'){\\n            string tmp=s.substr(0,1)+\\'.\\'+s.substr(1);\\n            mp[s]={tmp};\\n            return mp[s];\\n        }\\n        for(int i=1;i<s.size();i++){\\n            string tmp=s.substr(0,i)+\\'.\\'+s.substr(i);\\n            mp[s].emplace_back(tmp);\\n        }\\n        mp[s].emplace_back(s);\\n        return mp[s];\\n    }\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string> result;\\n        for(int i=1;i+2<s.size();i++){\\n            string pre=s.substr(1,i),suf=s.substr(i+1,s.size()-i-2);\\n            auto ss1=helper(pre);\\n            auto ss2=helper(suf);\\n            if(ss1.empty() or ss2.empty())  continue;\\n            for(auto&x:ss1) for(auto&y:ss2){\\n                    string tmp=\"(\"+x+\", \"+y+\")\";\\n                    result.emplace_back(tmp);\\n                }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574885,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cases(string &&s)\\n     {\\n    if (s.size() == 1) \\n        return {s};\\n    if (s.front() == \\'0\\') \\n    { \\n        if (s.back() == \\'0\\') \\n            return\\n             {\\n\\n             };\\n        return {\"0.\" + s.substr(1)}; \\n    }\\n    if (s.back() == \\'0\\') \\n        return \\n        {\\n            s\\n            };\\n    vector<string> res\\n    {\\n        s\\n        }; \\n    for (int i = 1; i < s.size(); i++)\\n        res.emplace_back(s.substr(0, i) + \".\" + s.substr(i));\\n    return res;\\n}\\nvector<string> ambiguousCoordinates(string S)\\n {\\n    vector<string> res;\\n    for (int i = 2; i < S.size() - 1; i++) \\n    for (auto &x : cases(S.substr(1, i - 1)))\\n    for (auto &y : cases(S.substr(i, S.size() - i - 1)))\\n        res.emplace_back(\"(\" + x + \", \" + y + \")\");\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cases(string &&s)\\n     {\\n    if (s.size() == 1) \\n        return {s};\\n    if (s.front() == \\'0\\') \\n    { \\n        if (s.back() == \\'0\\') \\n            return\\n             {\\n\\n             };\\n        return {\"0.\" + s.substr(1)}; \\n    }\\n    if (s.back() == \\'0\\') \\n        return \\n        {\\n            s\\n            };\\n    vector<string> res\\n    {\\n        s\\n        }; \\n    for (int i = 1; i < s.size(); i++)\\n        res.emplace_back(s.substr(0, i) + \".\" + s.substr(i));\\n    return res;\\n}\\nvector<string> ambiguousCoordinates(string S)\\n {\\n    vector<string> res;\\n    for (int i = 2; i < S.size() - 1; i++) \\n    for (auto &x : cases(S.substr(1, i - 1)))\\n    for (auto &y : cases(S.substr(i, S.size() - i - 1)))\\n        res.emplace_back(\"(\" + x + \", \" + y + \")\");\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573862,
                "title": "python3-ye-olde-one-liner",
                "content": "# Intuition\\nCuz why not?\\n\\n# Code\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        return [f\"({x}, {y})\" for d in [lambda n:  [x for x in [f\"{n[:i]}.{n[i:]}\".strip(\\'.\\') for i in range(1, len(n)+1)] if (\\'.\\' not in x or x[-1] != \\'0\\') and x[:2] != \\'00\\' and (x[0] != \\'0\\' or x[:2]==\\'0.\\' or len(x) == 1)]] for i in range(2, len(s)-1) for x in d(s[1:i]) for y in d(s[i:-1])]\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        return [f\"({x}, {y})\" for d in [lambda n:  [x for x in [f\"{n[:i]}.{n[i:]}\".strip(\\'.\\') for i in range(1, len(n)+1)] if (\\'.\\' not in x or x[-1] != \\'0\\') and x[:2] != \\'00\\' and (x[0] != \\'0\\' or x[:2]==\\'0.\\' or len(x) == 1)]] for i in range(2, len(s)-1) for x in d(s[1:i]) for y in d(s[i:-1])]\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393069,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func ambiguousCoordinates(_ s: String) -> [String] {\\n\\n        func lr(_ s: String) -> [(String, String)] {\\n            (1..<s.count).map { (String(s.prefix($0)), String(s.dropFirst($0))) }\\n        }\\n\\n        func opts(_ s: String) -> [String] {\\n            guard !s.hasPrefix(\"00\") || s.contains(where: { $0 != \"0\" }) else { return [] }\\n            guard !s.hasPrefix(\"0\") || !s.hasSuffix(\"0\") || s == \"0\" else { return [] }\\n            guard s.count > 1, !s.hasSuffix(\"0\") else { return [s] }\\n            guard !s.hasPrefix(\"0\") else { return [\"\\\\(0).\\\\(s.dropFirst())\"] }\\n            return [s] + lr(s).map { \"\\\\($0).\\\\($1)\" }\\n        }\\n        \\n        return lr(String(s.dropFirst().dropLast()))\\n            .map { (opts($0), opts($1)) }\\n            .filter { !$0.isEmpty && !$1.isEmpty }\\n            .flatMap { ls, rs in ls.flatMap { l in rs.map { r in \"(\\\\(l), \\\\(r))\" } } }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func ambiguousCoordinates(_ s: String) -> [String] {\\n\\n        func lr(_ s: String) -> [(String, String)] {\\n            (1..<s.count).map { (String(s.prefix($0)), String(s.dropFirst($0))) }\\n        }\\n\\n        func opts(_ s: String) -> [String] {\\n            guard !s.hasPrefix(\"00\") || s.contains(where: { $0 != \"0\" }) else { return [] }\\n            guard !s.hasPrefix(\"0\") || !s.hasSuffix(\"0\") || s == \"0\" else { return [] }\\n            guard s.count > 1, !s.hasSuffix(\"0\") else { return [s] }\\n            guard !s.hasPrefix(\"0\") else { return [\"\\\\(0).\\\\(s.dropFirst())\"] }\\n            return [s] + lr(s).map { \"\\\\($0).\\\\($1)\" }\\n        }\\n        \\n        return lr(String(s.dropFirst().dropLast()))\\n            .map { (opts($0), opts($1)) }\\n            .filter { !$0.isEmpty && !$1.isEmpty }\\n            .flatMap { ls, rs in ls.flatMap { l in rs.map { r in \"(\\\\(l), \\\\(r))\" } } }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355645,
                "title": "i-ruby",
                "content": "```ruby\\ndef ambiguous_coordinates s\\n    f = -> s do\\n        r, z = [s], s.size\\n        return r if z == 1\\n        return (s[/^0/] ? [] : r) if s[/0$/]\\n        return [\\'0.\\' + s[1..]] if s[/^0/]\\n        (1...z).reduce(r) { _1 << s.clone.insert(_2, ?.) }\\n    end\\n    (1...(s = s[1..-2]).size).flat_map do | i |\\n        f.(s[...i]).product(f.(s[i..])).map do\\n            \"(#{_1.first}, #{_1.last})\"\\n        end\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef ambiguous_coordinates s\\n    f = -> s do\\n        r, z = [s], s.size\\n        return r if z == 1\\n        return (s[/^0/] ? [] : r) if s[/0$/]\\n        return [\\'0.\\' + s[1..]] if s[/^0/]\\n        (1...z).reduce(r) { _1 << s.clone.insert(_2, ?.) }\\n    end\\n    (1...(s = s[1..-2]).size).flat_map do | i |\\n        f.(s[...i]).product(f.(s[i..])).map do\\n            \"(#{_1.first}, #{_1.last})\"\\n        end\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3351264,
                "title": "c",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<string>splits(string s){\\n        if(s.size() == 0)\\n            return {} ;\\n        if(s.size() > 1 && s[0] == \\'0\\' && s.back() == \\'0\\')\\n            return {} ;\\n        if(s.back() == \\'0\\')\\n            return {s} ;\\n        if(s.front() == \\'0\\')\\n            return {\"0.\" + s.substr(1)} ;\\n        \\n        vector<string>ret ;\\n        ret.push_back(s) ;\\n        for(int i = 1; i < s.size(); i++){\\n            ret.push_back(s.substr(0, i) + \".\" + s.substr(i)) ;\\n        }\\n        return ret ;\\n    }\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string>ret ;\\n        s = s.substr(1, s.size()-2) ;\\n        for(int i = 1; i < s.size(); i++){\\n            for(auto& x : splits(s.substr(0, i))){\\n                for(auto& y : splits(s.substr(i))){\\n                    ret.push_back(\"(\" + x + \", \" + y +\")\" ) ;\\n                }\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<string>splits(string s){\\n        if(s.size() == 0)\\n            return {} ;\\n        if(s.size() > 1 && s[0] == \\'0\\' && s.back() == \\'0\\')\\n            return {} ;\\n        if(s.back() == \\'0\\')\\n            return {s} ;\\n        if(s.front() == \\'0\\')\\n            return {\"0.\" + s.substr(1)} ;\\n        \\n        vector<string>ret ;\\n        ret.push_back(s) ;\\n        for(int i = 1; i < s.size(); i++){\\n            ret.push_back(s.substr(0, i) + \".\" + s.substr(i)) ;\\n        }\\n        return ret ;\\n    }\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string>ret ;\\n        s = s.substr(1, s.size()-2) ;\\n        for(int i = 1; i < s.size(); i++){\\n            for(auto& x : splits(s.substr(0, i))){\\n                for(auto& y : splits(s.substr(i))){\\n                    ret.push_back(\"(\" + x + \", \" + y +\")\" ) ;\\n                }\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306935,
                "title": "python-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\n2D coordinate has two values\\n1. enumerate all of the ways to split the string in two substring\\n2. enumerate all of the values which the substring can be turned into\\n3. do the `prodcut` of two value sets\\n\\'\\'\\'\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        def getNums(sub):\\n            ans = []\\n            leng = len(sub)\\n            for i in range(1, leng+1):\\n                l = sub[:i]\\n                r = sub[i:]\\n                if (l[0] != \\'0\\' or l == \\'0\\') and (len(r) == 0 or r[-1] != \\'0\\'):\\n                    ans.append(l + (\\'.\\' if len(r) > 0 else \\'\\') + r)\\n            return ans\\n        ans = []\\n        for i in range(1, len(s)):\\n            for sub1 in getNums(s[:i]):\\n                for sub2 in getNums(s[i:]):\\n                    ans.append(\\'({}, {})\\'.format(sub1, sub2))\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n\\'\\'\\'\\n2D coordinate has two values\\n1. enumerate all of the ways to split the string in two substring\\n2. enumerate all of the values which the substring can be turned into\\n3. do the `prodcut` of two value sets\\n\\'\\'\\'\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        def getNums(sub):\\n            ans = []\\n            leng = len(sub)\\n            for i in range(1, leng+1):\\n                l = sub[:i]\\n                r = sub[i:]\\n                if (l[0] != \\'0\\' or l == \\'0\\') and (len(r) == 0 or r[-1] != \\'0\\'):\\n                    ans.append(l + (\\'.\\' if len(r) > 0 else \\'\\') + r)\\n            return ans\\n        ans = []\\n        for i in range(1, len(s)):\\n            for sub1 in getNums(s[:i]):\\n                for sub2 in getNums(s[i:]):\\n                    ans.append(\\'({}, {})\\'.format(sub1, sub2))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971696,
                "title": "swift-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBacktracking\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ne.g. `(123)`\\n1. Remove brackets first\\n2. Collect LHS e.g. `1, 1, 1.2, 12`\\n3. Collect RHS e.g. `2.3, 23, 3, 3`\\n3. Combine them \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n . 2^(p-1))\\nn partition options and each partition can have 2^p-1 option to place \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) + O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func ambiguousCoordinates(_ s: String) -> [String] {\\n        var string = s\\n        string.removeFirst()\\n        string.removeLast()\\n\\n        var lefts = [String]()\\n        var rights = [String]()\\n        var result = [String]()\\n\\n        for i in 0..<string.count - 1 {\\n            lefts = f(string, 0, i) // Extract lefts only e.g. 1, 1.2, 12\\n            rights = f(string, i + 1, string.count - 1) // Extract right only e.g. 2.3, 23, 3\\n\\n            for left in lefts {\\n                for right in rights {\\n                    let temp = \"(\\\\(left), \\\\(right))\"\\n                    result.append(temp)\\n                }\\n            }\\n        }\\n        return result\\n    }\\n\\n    private func f(_ s: String, _ i: Int, _ j: Int) -> [String] {\\n        var result = [String]()\\n        \\n        for x in i...j {\\n            var left = String()\\n            var right = String()\\n            \\n            if x == j {\\n                left = s.getSubstring(i, j)\\n                right = String()\\n            } else {\\n                left = s.getSubstring(i, x)\\n                right = s.getSubstring(x + 1, j)\\n            }\\n\\n            if !(left.count > 1 && left.first! == \"0\") { // Edge case Left = 01 Right = 23 \\n                if right.isEmpty {\\n                    result.append(left)\\n                } else {\\n                    var temp = left\\n                    temp.append(\".\")\\n                    temp.append(right)\\n\\n                    if temp.last! != \"0\" { // Edge case temp = 1.0\\n                        result.append(temp)\\n                    } \\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n\\nextension String {\\n    subscript (_ at: Int) -> Self {\\n        return String( self[index(startIndex, offsetBy: at)] )\\n    }\\n\\n    func getSubstring(_ from: Int, _ to: Int) -> Self {\\n        let start = index(startIndex, offsetBy: from)\\n        let end = index(startIndex, offsetBy: to)\\n        let stringSubsequence = self[start...end]\\n        return String(stringSubsequence)\\n    }\\n}\\n```\\n\\n# Reference\\n* https://leetcode.com/problems/ambiguous-coordinates/solutions/1207736/swift-solution-with-explanation/?orderBy=most_votes&languageTags=swift",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func ambiguousCoordinates(_ s: String) -> [String] {\\n        var string = s\\n        string.removeFirst()\\n        string.removeLast()\\n\\n        var lefts = [String]()\\n        var rights = [String]()\\n        var result = [String]()\\n\\n        for i in 0..<string.count - 1 {\\n            lefts = f(string, 0, i) // Extract lefts only e.g. 1, 1.2, 12\\n            rights = f(string, i + 1, string.count - 1) // Extract right only e.g. 2.3, 23, 3\\n\\n            for left in lefts {\\n                for right in rights {\\n                    let temp = \"(\\\\(left), \\\\(right))\"\\n                    result.append(temp)\\n                }\\n            }\\n        }\\n        return result\\n    }\\n\\n    private func f(_ s: String, _ i: Int, _ j: Int) -> [String] {\\n        var result = [String]()\\n        \\n        for x in i...j {\\n            var left = String()\\n            var right = String()\\n            \\n            if x == j {\\n                left = s.getSubstring(i, j)\\n                right = String()\\n            } else {\\n                left = s.getSubstring(i, x)\\n                right = s.getSubstring(x + 1, j)\\n            }\\n\\n            if !(left.count > 1 && left.first! == \"0\") { // Edge case Left = 01 Right = 23 \\n                if right.isEmpty {\\n                    result.append(left)\\n                } else {\\n                    var temp = left\\n                    temp.append(\".\")\\n                    temp.append(right)\\n\\n                    if temp.last! != \"0\" { // Edge case temp = 1.0\\n                        result.append(temp)\\n                    } \\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n\\nextension String {\\n    subscript (_ at: Int) -> Self {\\n        return String( self[index(startIndex, offsetBy: at)] )\\n    }\\n\\n    func getSubstring(_ from: Int, _ to: Int) -> Self {\\n        let start = index(startIndex, offsetBy: from)\\n        let end = index(startIndex, offsetBy: to)\\n        let stringSubsequence = self[start...end]\\n        return String(stringSubsequence)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949735,
                "title": "kotlin-implementation",
                "content": "# Approach\\n- Ignore leading & tailing braces by limiting the index range\\n- Split remaining string into 2 chunks of at least 1 character\\n- Get all possible number configurations for each chunk\\n    - Split number string at each possible decimal-point location\\n    - If both chunks are valid, add to possible configurations\\n    - First chunk\\n        - Invalid, if more than 1 leading \\'0\\'s\\n        - Invalid, if 1 leading \\'0\\' and length more than 1\\n    - Second chunk (may be of length 0)\\n        - Invalid if more than 0 tailing \\'0\\'s\\n- Zip those for both chunks (all permutations)\\n\\n# Code\\n```\\nclass Solution {\\n    private fun leadingZeros(v: String): Int {\\n        var leadingZeros = 0\\n        while(leadingZeros < v.length && v[leadingZeros] == \\'0\\') leadingZeros++\\n        return leadingZeros\\n    }\\n    private fun tailingZeros(v: String): Int {\\n        var tailingZeros = 0\\n        while(tailingZeros < v.length && v[v.lastIndex - tailingZeros] == \\'0\\') tailingZeros++\\n        return tailingZeros\\n    }\\n    private fun allValuesOf(n: String): List<String> {\\n        val values = mutableListOf<String>()\\n        for(decimalPointIndex in 1 .. n.length) {\\n            val first = n.substring(0, decimalPointIndex)\\n            val fl0 = leadingZeros(first)\\n            if(fl0 >= 2 || fl0 != 0 && first.length != 1) continue\\n            values += if(decimalPointIndex != n.length) {\\n                val second = n.substring(decimalPointIndex)\\n                if(tailingZeros(second) != 0) continue\\n                \"$first.$second\"\\n            } else first\\n        }\\n        return values\\n    }\\n    fun ambiguousCoordinates(s: String): List<String> {\\n        val result = mutableListOf<String>()\\n        for(breakpoint in 2 .. s.lastIndex - 1) {\\n            val firstValues = allValuesOf(s.substring(1, breakpoint))\\n            val secondValues = allValuesOf(s.substring(breakpoint, s.lastIndex))\\n\\n            for(first in firstValues)\\n                for(second in secondValues)\\n                    result += \"($first, $second)\"\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    private fun leadingZeros(v: String): Int {\\n        var leadingZeros = 0\\n        while(leadingZeros < v.length && v[leadingZeros] == \\'0\\') leadingZeros++\\n        return leadingZeros\\n    }\\n    private fun tailingZeros(v: String): Int {\\n        var tailingZeros = 0\\n        while(tailingZeros < v.length && v[v.lastIndex - tailingZeros] == \\'0\\') tailingZeros++\\n        return tailingZeros\\n    }\\n    private fun allValuesOf(n: String): List<String> {\\n        val values = mutableListOf<String>()\\n        for(decimalPointIndex in 1 .. n.length) {\\n            val first = n.substring(0, decimalPointIndex)\\n            val fl0 = leadingZeros(first)\\n            if(fl0 >= 2 || fl0 != 0 && first.length != 1) continue\\n            values += if(decimalPointIndex != n.length) {\\n                val second = n.substring(decimalPointIndex)\\n                if(tailingZeros(second) != 0) continue\\n                \"$first.$second\"\\n            } else first\\n        }\\n        return values\\n    }\\n    fun ambiguousCoordinates(s: String): List<String> {\\n        val result = mutableListOf<String>()\\n        for(breakpoint in 2 .. s.lastIndex - 1) {\\n            val firstValues = allValuesOf(s.substring(1, breakpoint))\\n            val secondValues = allValuesOf(s.substring(breakpoint, s.lastIndex))\\n\\n            for(first in firstValues)\\n                for(second in secondValues)\\n                    result += \"($first, $second)\"\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939247,
                "title": "python3-concise-solution-beats-99",
                "content": "# Algo\\nThe key is to deal with extraneous zeros. Below rule gives the what\\'s required\\n\\n1. if a string has length 1, return it;\\n2. if a string with length larger than 1 and starts and ends with 0, it cannot contain valid number;\\n3. if a string starts with 0, return 0.xxx;\\n4. if a string ends with 0, return xxx0;\\n5. otherwise, put decimal point in the n-1 places.\\n\\n# Code\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s.strip(\"(\").strip(\")\")\\n        \\n        def fn(s): \\n            \"\"\"Return valid numbers from s.\"\"\"\\n            if len(s) == 1: return [s]\\n            if s.startswith(\"0\") and s.endswith(\"0\"): return []\\n            if s.startswith(\"0\"): return [s[:1] + \".\" + s[1:]]\\n            if s.endswith(\"0\"): return [s]\\n            return [s[:i] + \".\" + s[i:] for i in range(1, len(s))] + [s]\\n        \\n        ans = []\\n        for i in range(1, len(s)): \\n            for x in fn(s[:i]):\\n                for y in fn(s[i:]): \\n                    ans.append(f\"({x}, {y})\")\\n        return ans  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s.strip(\"(\").strip(\")\")\\n        \\n        def fn(s): \\n            \"\"\"Return valid numbers from s.\"\"\"\\n            if len(s) == 1: return [s]\\n            if s.startswith(\"0\") and s.endswith(\"0\"): return []\\n            if s.startswith(\"0\"): return [s[:1] + \".\" + s[1:]]\\n            if s.endswith(\"0\"): return [s]\\n            return [s[:i] + \".\" + s[i:] for i in range(1, len(s))] + [s]\\n        \\n        ans = []\\n        for i in range(1, len(s)): \\n            for x in fn(s[:i]):\\n                for y in fn(s[i:]): \\n                    ans.append(f\"({x}, {y})\")\\n        return ans  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2922878,
                "title": "python3-iterative-with-regex",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First, split the input into two numbers with a comma at every valid index. \\n    - e.g. `1234 -> (1, 234), (12, 34), (1,234)`\\n- For each of those pairs of numbers, further split each number with a period at every valid index.\\n    - e.g. `(12,34) -> (12, 34), (1.2, 34), (1.2, 3.4), (12,3.4)`\\n- Check if both numbers are valid (have no zeroes where there shouldn\\'t be)\\n    - e.g. `100 -> (10, 0) -> (1.0, 0)X, (10, 0)OK -> [(10, 0)]` \\n\\nFiguring out the regexes was nasty here. On an interview I definitely would have run out of time. \\n\\n# Code\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\n        # remove the parentheses \\n        num = s[1:-1] \\n        # split the number at every index into tuples\\n        # e.g \\'123\\' -> (1, 23) , (12, 3)\\n        comma_split = [(num[:i] , num[i:]) for i in range(1, len(num))]\\n\\n        def num_ok(*args):\\n            # checks number(s) are valid\\n            for n in args:\\n                # reject nums with zeroes after \\'.\\' and 0 or more digits, OR leading zeroes before one \\'0\\' or one or more nonzero digits\\n                if re.search(\"\\\\.[0-9]*0+$\", n) or re.search(\"^0+(0|[1-9]+)\\\\.?\", n):\\n                    return False\\n            return True\\n\\n        ans = []\\n        # algo: \\n        # split the first number with a period at every valid index: 123 -> 123, 1.23, 12.3 (not .123 or 123.)\\n        # do the same for the second number\\n        # check if the numbers produced are valid \\n        # if so, add every combination to answer\\n        for n1, n2 in comma_split:\\n            for i in range(len(n1)):\\n                # split the first number with a period at all indices\\n                n1s = n1[:i]+\\'.\\'+n1[i:] if i > 0 else n1\\n                for j in range(len(n2)):\\n                    # split the second number with a period at all indices\\n                    n2s = n2[:j]+\\'.\\'+n2[j:] if j > 0 else n2\\n                    if num_ok(n1s, n2s):\\n                        # check validity\\n                        ans.append((n1s, n2s))\\n                    \\n        for i, (n1, n2) in enumerate(ans):\\n            # formatting nonsense\\n            ans[i] = \\'(\\' + n1 + \\', \\' + n2 +\\')\\'\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\n        # remove the parentheses \\n        num = s[1:-1] \\n        # split the number at every index into tuples\\n        # e.g \\'123\\' -> (1, 23) , (12, 3)\\n        comma_split = [(num[:i] , num[i:]) for i in range(1, len(num))]\\n\\n        def num_ok(*args):\\n            # checks number(s) are valid\\n            for n in args:\\n                # reject nums with zeroes after \\'.\\' and 0 or more digits, OR leading zeroes before one \\'0\\' or one or more nonzero digits\\n                if re.search(\"\\\\.[0-9]*0+$\", n) or re.search(\"^0+(0|[1-9]+)\\\\.?\", n):\\n                    return False\\n            return True\\n\\n        ans = []\\n        # algo: \\n        # split the first number with a period at every valid index: 123 -> 123, 1.23, 12.3 (not .123 or 123.)\\n        # do the same for the second number\\n        # check if the numbers produced are valid \\n        # if so, add every combination to answer\\n        for n1, n2 in comma_split:\\n            for i in range(len(n1)):\\n                # split the first number with a period at all indices\\n                n1s = n1[:i]+\\'.\\'+n1[i:] if i > 0 else n1\\n                for j in range(len(n2)):\\n                    # split the second number with a period at all indices\\n                    n2s = n2[:j]+\\'.\\'+n2[j:] if j > 0 else n2\\n                    if num_ok(n1s, n2s):\\n                        # check validity\\n                        ans.append((n1s, n2s))\\n                    \\n        for i, (n1, n2) in enumerate(ans):\\n            # formatting nonsense\\n            ans[i] = \\'(\\' + n1 + \\', \\' + n2 +\\')\\'\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2889745,
                "title": "c-iterative-solution-14ms",
                "content": "# Intuition\\n- actually we divided string into two part left and right and add  `.` into each position of left and right string. and making combinations of that strings. \\n```  \\n if(s1[0] != \\'0\\' || s1 == \"0\") a.push_back(s1);\\n``` \\n- above condition used for checking any leading zero present or not in string\\n```\\n if(flag || sub2[sub2.size() - 1] == \\'0\\') continue;\\n```\\n- above condition used for checking string contains all zero\\'s or also check last char is zero or not if condition true then this string is invalid for making combinations with left string. e.g `\\nsuppose left str = 34 and right str = 000 or 450 so whole string is 34.000 or 34.450 and that strings are invalid`\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n     -- $$O(n*n)$$. n = length of string\\n\\n- Space complexity:\\n    -- $$O(n*n)$$. n = length of string\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.size();\\n        string t = s.substr(1, n-2);\\n        int m = t.size();\\n\\n        vector<string> v;\\n        for(int j = 0; j < m - 1; j++) {\\n            string s1 = t.substr(0, j+1), s2 =t.substr(j+1, m-1-j);\\n            vector<string> a, b;\\n\\n            if(s1[0] != \\'0\\' || s1 == \"0\") a.push_back(s1);\\n            if(s2[0] != \\'0\\' || s2 == \"0\") b.push_back(s2);\\n\\n\\n            for(int k = 0; k < s1.size() - 1; k++) {\\n                bool flag = true;\\n                string sub1 = s1.substr(0, k+1), sub2 = s1.substr(k+1, s1.size() - 1 - k);\\n\\n                for(int i = 0; i < sub2.size(); i++) {\\n                    if(sub2[i] != \\'0\\') flag = false;\\n                }\\n                if(flag || sub2[sub2.size() - 1] == \\'0\\') continue;\\n\\n                string str = sub1 + \".\" + sub2;\\n\\n                if(str[0] ==\\'0\\' && str[1] != \\'.\\') continue;\\n                a.push_back(str);\\n            }\\n\\n            for(int k = 0; k < s2.size() - 1; k++) {\\n                bool flag = true;\\n                string sub1 = s2.substr(0, k+1), sub2 =  s2.substr(k+1, s2.size() - 1 - k);\\n\\n                for(int i = 0; i < sub2.size(); i++) {\\n                    if(sub2[i] != \\'0\\') flag = false;\\n                }\\n                if(flag || sub2[sub2.size() - 1] == \\'0\\') continue;\\n\\n                string str = sub1 + \".\" + sub2;\\n\\n                if(str[0] ==\\'0\\' && str[1] != \\'.\\') continue;\\n                b.push_back(str);\\n            }\\n            \\n            for(int i = 0; i < a.size(); i++) {\\n                for(int k = 0; k < b.size(); k++) {\\n                    v.push_back(\"(\" + a[i] + \", \" + b[k] + \")\");\\n                }\\n            }\\n        }\\n    \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```  \\n if(s1[0] != \\'0\\' || s1 == \"0\") a.push_back(s1);\\n```\n```\\n if(flag || sub2[sub2.size() - 1] == \\'0\\') continue;\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.size();\\n        string t = s.substr(1, n-2);\\n        int m = t.size();\\n\\n        vector<string> v;\\n        for(int j = 0; j < m - 1; j++) {\\n            string s1 = t.substr(0, j+1), s2 =t.substr(j+1, m-1-j);\\n            vector<string> a, b;\\n\\n            if(s1[0] != \\'0\\' || s1 == \"0\") a.push_back(s1);\\n            if(s2[0] != \\'0\\' || s2 == \"0\") b.push_back(s2);\\n\\n\\n            for(int k = 0; k < s1.size() - 1; k++) {\\n                bool flag = true;\\n                string sub1 = s1.substr(0, k+1), sub2 = s1.substr(k+1, s1.size() - 1 - k);\\n\\n                for(int i = 0; i < sub2.size(); i++) {\\n                    if(sub2[i] != \\'0\\') flag = false;\\n                }\\n                if(flag || sub2[sub2.size() - 1] == \\'0\\') continue;\\n\\n                string str = sub1 + \".\" + sub2;\\n\\n                if(str[0] ==\\'0\\' && str[1] != \\'.\\') continue;\\n                a.push_back(str);\\n            }\\n\\n            for(int k = 0; k < s2.size() - 1; k++) {\\n                bool flag = true;\\n                string sub1 = s2.substr(0, k+1), sub2 =  s2.substr(k+1, s2.size() - 1 - k);\\n\\n                for(int i = 0; i < sub2.size(); i++) {\\n                    if(sub2[i] != \\'0\\') flag = false;\\n                }\\n                if(flag || sub2[sub2.size() - 1] == \\'0\\') continue;\\n\\n                string str = sub1 + \".\" + sub2;\\n\\n                if(str[0] ==\\'0\\' && str[1] != \\'.\\') continue;\\n                b.push_back(str);\\n            }\\n            \\n            for(int i = 0; i < a.size(); i++) {\\n                for(int k = 0; k < b.size(); k++) {\\n                    v.push_back(\"(\" + a[i] + \", \" + b[k] + \")\");\\n                }\\n            }\\n        }\\n    \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867427,
                "title": "java-self-descriptive-codes-no-need-of-any-explanation",
                "content": "```\\nclass Solution {\\n    \\n    private List<String> coordinates;\\n    \\n    public Solution() {\\n        coordinates = new ArrayList<>();\\n    }\\n    \\n    public List<String> ambiguousCoordinates(String s) {\\n        s = s.substring(1, s.length() - 1); // remove left & right parenthesis\\n        // This part can be done recursively as well.\\n        for(int i = 1; i < s.length(); i += 1) {\\n            // Try every possible (x, y) type xs & ys\\n            String x = s.substring(0, i), y = s.substring(i);\\n            addValidCoordinates(x, y);\\n        }\\n        return coordinates;\\n    }\\n    \\n    \\n    private void addValidCoordinates(String x, String y) {\\n        List<String> dottedXs = addADot(x);\\n        List<String> dottedYs = addADot(y);\\n        for(String x_ : dottedXs) {\\n            if(isValidNumber(x_)) { \\n                for(String y_ : dottedYs) {\\n                    if(isValidNumber(y_)) {\\n                        coordinates.add(\"(\" + x_ + \", \" + y_ + \")\");\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    private List<String> addADot(String num) {\\n        List<String> dottedNums = new ArrayList<>();\\n        dottedNums.add(num); // add whole number itself\\n        for(int i = 1; i < num.length(); i += 1) {\\n            dottedNums.add(num.substring(0, i) + \".\" + num.substring(i));\\n        }\\n        return dottedNums;\\n    }\\n    \\n    /*\\n        If a coordinate\\'s x/y is valid: \\n        \\n        Type:1 dddd\\n        ----------\\n            + If doesn\\'t have dot, it should either be \"0\" OR\\n                cannot have leading zeros.\\n                \\n        Type:2 dd.dd\\n        ------------\\n            + If it has a dot, the first half(before dot) should either be \"0\" \\n                OR cannot have any leading zero(s).\\n                \\n       Type:3 dd.ddd (Actually can be added into the Type#2)\\n       -----------------------------------------------------\\n            + If it has a dot, first part doesn\\'t have any leading zero(s)\\n                then second half(after dot) cannot have trailing zero(s) as well.\\n    */\\n    private boolean isValidNumber(String num) {\\n        int dotIdx = num.indexOf(\".\");\\n        boolean isValid = false;\\n        // Type#1\\n        if(dotIdx == -1) {\\n            if(num.equals(\"0\") || num.charAt(0) != \\'0\\') isValid = true;\\n        } else {\\n            // Type#2, #3 \\n            String beforeDot = num.substring(0, dotIdx); \\n            String afterDot = num.substring(dotIdx + 1);\\n            if(beforeDot.equals(\"0\") || beforeDot.charAt(0) != \\'0\\') {\\n                if(afterDot.charAt(afterDot.length() - 1) != \\'0\\') {\\n                    // Both before & after dot is valid then only given number \\'num\\'\\n                    // is valid. Invalid, otherwise.\\n                    isValid = true;\\n                }\\n            }\\n        }\\n        return isValid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private List<String> coordinates;\\n    \\n    public Solution() {\\n        coordinates = new ArrayList<>();\\n    }\\n    \\n    public List<String> ambiguousCoordinates(String s) {\\n        s = s.substring(1, s.length() - 1); // remove left & right parenthesis\\n        // This part can be done recursively as well.\\n        for(int i = 1; i < s.length(); i += 1) {\\n            // Try every possible (x, y) type xs & ys\\n            String x = s.substring(0, i), y = s.substring(i);\\n            addValidCoordinates(x, y);\\n        }\\n        return coordinates;\\n    }\\n    \\n    \\n    private void addValidCoordinates(String x, String y) {\\n        List<String> dottedXs = addADot(x);\\n        List<String> dottedYs = addADot(y);\\n        for(String x_ : dottedXs) {\\n            if(isValidNumber(x_)) { \\n                for(String y_ : dottedYs) {\\n                    if(isValidNumber(y_)) {\\n                        coordinates.add(\"(\" + x_ + \", \" + y_ + \")\");\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    private List<String> addADot(String num) {\\n        List<String> dottedNums = new ArrayList<>();\\n        dottedNums.add(num); // add whole number itself\\n        for(int i = 1; i < num.length(); i += 1) {\\n            dottedNums.add(num.substring(0, i) + \".\" + num.substring(i));\\n        }\\n        return dottedNums;\\n    }\\n    \\n    /*\\n        If a coordinate\\'s x/y is valid: \\n        \\n        Type:1 dddd\\n        ----------\\n            + If doesn\\'t have dot, it should either be \"0\" OR\\n                cannot have leading zeros.\\n                \\n        Type:2 dd.dd\\n        ------------\\n            + If it has a dot, the first half(before dot) should either be \"0\" \\n                OR cannot have any leading zero(s).\\n                \\n       Type:3 dd.ddd (Actually can be added into the Type#2)\\n       -----------------------------------------------------\\n            + If it has a dot, first part doesn\\'t have any leading zero(s)\\n                then second half(after dot) cannot have trailing zero(s) as well.\\n    */\\n    private boolean isValidNumber(String num) {\\n        int dotIdx = num.indexOf(\".\");\\n        boolean isValid = false;\\n        // Type#1\\n        if(dotIdx == -1) {\\n            if(num.equals(\"0\") || num.charAt(0) != \\'0\\') isValid = true;\\n        } else {\\n            // Type#2, #3 \\n            String beforeDot = num.substring(0, dotIdx); \\n            String afterDot = num.substring(dotIdx + 1);\\n            if(beforeDot.equals(\"0\") || beforeDot.charAt(0) != \\'0\\') {\\n                if(afterDot.charAt(afterDot.length() - 1) != \\'0\\') {\\n                    // Both before & after dot is valid then only given number \\'num\\'\\n                    // is valid. Invalid, otherwise.\\n                    isValid = true;\\n                }\\n            }\\n        }\\n        return isValid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787784,
                "title": "python-solution-backtrack-faster-than-9-time-o-2-n-space-o-2-n",
                "content": "\\tclass Solution:\\n\\t\\tdef ambiguousCoordinates(self, s: str) -> List[str]:\\n\\t\\t\\ts_list = list(s[1:-1])\\n\\t\\t\\ts_list_len = len(s_list)\\n\\t\\t\\tres = list()\\n\\t\\t\\tif s_list_len < 2: \\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif s_list_len == 2: \\n\\t\\t\\t\\ts_list.insert(1, \\', \\')\\n\\t\\t\\t\\tres.append(\\'(\\' + \\'\\'.join(s_list) + \\')\\')\\n\\t\\t\\t\\treturn res\\n\\n\\t\\t\\tdef is_valid_integer(nums_list):\\n\\t\\t\\t\\tnums_list_len = len(nums_list)\\n\\t\\t\\t\\tif nums_list_len>1 and nums_list[0]==\\'0\\':\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\treturn True    \\n\\n\\t\\t\\tdef is_valid_decimal(nums_list):\\n\\t\\t\\t\\t# print(\"nums: \", nums_list)\\n\\t\\t\\t\\tif nums_list[-1]==\\'0\\':\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\tfor idx in range(1, s_list_len):\\n\\t\\t\\t\\ts_list.insert(idx, \\', \\')\\n\\t\\t\\t\\tfirst_part = s_list[:idx]\\n\\t\\t\\t\\tsecond_part = s_list[idx+1:]\\n\\t\\t\\t\\tfirst_part_len = len(first_part)\\n\\t\\t\\t\\tsecond_part_len = len(second_part)\\n\\t\\t\\t\\t# print(first_part, \\', \\', second_part)\\n\\t\\t\\t\\tif is_valid_integer(first_part) and is_valid_integer(second_part): \\n\\t\\t\\t\\t\\tres.append(\\'(\\' + \\'\\'.join(first_part) + \\', \\' + \\'\\'.join(second_part) + \\')\\')\\n\\t\\t\\t\\tfor sdx in range(1, second_part_len): \\n\\t\\t\\t\\t\\tsecond_part.insert(sdx, \\'.\\')  \\n\\t\\t\\t\\t\\tsecond_part_integer = second_part[:sdx]\\n\\t\\t\\t\\t\\tsecond_part_decimal = second_part[sdx+1:]\\n\\t\\t\\t\\t\\t# print(\"second:\", second_part_integer, second_part_decimal)\\n\\n\\t\\t\\t\\t\\tif is_valid_integer(first_part) and is_valid_integer(second_part_integer) and is_valid_decimal(second_part_decimal): \\n\\t\\t\\t\\t\\t\\tres.append(\\'(\\' + \\'\\'.join(first_part) + \\', \\' + \\'\\'.join(second_part) + \\')\\')\\n\\t\\t\\t\\t\\tsecond_part.pop(sdx)  \\n\\n\\t\\t\\t\\tfor fdx in range(1, first_part_len):\\n\\t\\t\\t\\t\\tfirst_part.insert(fdx, \\'.\\')\\n\\t\\t\\t\\t\\tfirst_part_integer = first_part[:fdx]\\n\\t\\t\\t\\t\\tfirst_part_decimal = first_part[fdx+1:]\\n\\t\\t\\t\\t\\tif is_valid_integer(first_part_integer) and is_valid_decimal(first_part_decimal) and is_valid_integer(second_part): \\n\\t\\t\\t\\t\\t\\tres.append(\\'(\\' + \\'\\'.join(first_part) + \\', \\' + \\'\\'.join(second_part) + \\')\\')\\n\\t\\t\\t\\t\\tfirst_part.pop(fdx)    \\n\\n\\t\\t\\t\\tfor fdx in range(1, first_part_len): \\n\\t\\t\\t\\t\\tfirst_part.insert(fdx, \\'.\\')\\n\\t\\t\\t\\t\\tfirst_part_integer = first_part[:fdx]\\n\\t\\t\\t\\t\\tfirst_part_decimal = first_part[fdx+1:]\\n\\t\\t\\t\\t\\tfor sdx in range(1, second_part_len): \\n\\t\\t\\t\\t\\t\\tsecond_part.insert(sdx, \\'.\\')\\n\\t\\t\\t\\t\\t\\tsecond_part_integer = second_part[:sdx]\\n\\t\\t\\t\\t\\t\\tsecond_part_decimal = second_part[sdx+1:]\\n\\t\\t\\t\\t\\t\\tif is_valid_integer(first_part_integer) and is_valid_decimal(first_part_decimal) and is_valid_integer(second_part_integer) and is_valid_decimal(second_part_decimal): \\n\\t\\t\\t\\t\\t\\t\\tres.append(\\'(\\' + \\'\\'.join(first_part) + \\', \\' + \\'\\'.join(second_part) + \\')\\')\\n\\t\\t\\t\\t\\t\\tsecond_part.pop(sdx)     \\n\\t\\t\\t\\t\\tfirst_part.pop(fdx)   \\n\\t\\t\\t\\ts_list.pop(idx)    \\n\\t\\t\\treturn res        \\n\\n\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef ambiguousCoordinates(self, s: str) -> List[str]:\\n\\t\\t\\ts_list = list(s[1:-1])\\n\\t\\t\\ts_list_len = len(s_list)\\n\\t\\t\\tres = list()\\n\\t\\t\\tif s_list_len < 2: \\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif s_list_len == 2: \\n\\t\\t\\t\\ts_list.insert(1, \\', \\')\\n\\t\\t\\t\\tres.append(\\'(\\' + \\'\\'.join(s_list) + \\')\\')\\n\\t\\t\\t\\treturn res\\n\\n\\t\\t\\tdef is_valid_integer(nums_list):\\n\\t\\t\\t\\tnums_list_len = len(nums_list)\\n\\t\\t\\t\\tif nums_list_len>1 and nums_list[0]==\\'0\\':\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\treturn True    \\n\\n\\t\\t\\tdef is_valid_decimal(nums_list):\\n\\t\\t\\t\\t# print(\"nums: \", nums_list)\\n\\t\\t\\t\\tif nums_list[-1]==\\'0\\':\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\tfor idx in range(1, s_list_len):\\n\\t\\t\\t\\ts_list.insert(idx, \\', \\')\\n\\t\\t\\t\\tfirst_part = s_list[:idx]\\n\\t\\t\\t\\tsecond_part = s_list[idx+1:]\\n\\t\\t\\t\\tfirst_part_len = len(first_part)\\n\\t\\t\\t\\tsecond_part_len = len(second_part)\\n\\t\\t\\t\\t# print(first_part, \\', \\', second_part)\\n\\t\\t\\t\\tif is_valid_integer(first_part) and is_valid_integer(second_part): \\n\\t\\t\\t\\t\\tres.append(\\'(\\' + \\'\\'.join(first_part) + \\', \\' + \\'\\'.join(second_part) + \\')\\')\\n\\t\\t\\t\\tfor sdx in range(1, second_part_len): \\n\\t\\t\\t\\t\\tsecond_part.insert(sdx, \\'.\\')  \\n\\t\\t\\t\\t\\tsecond_part_integer = second_part[:sdx]\\n\\t\\t\\t\\t\\tsecond_part_decimal = second_part[sdx+1:]\\n\\t\\t\\t\\t\\t# print(\"second:\", second_part_integer, second_part_decimal)\\n\\n\\t\\t\\t\\t\\tif is_valid_integer(first_part) and is_valid_integer(second_part_integer) and is_valid_decimal(second_part_decimal): \\n\\t\\t\\t\\t\\t\\tres.append(\\'(\\' + \\'\\'.join(first_part) + \\', \\' + \\'\\'.join(second_part) + \\')\\')\\n\\t\\t\\t\\t\\tsecond_part.pop(sdx)  \\n\\n\\t\\t\\t\\tfor fdx in range(1, first_part_len):\\n\\t\\t\\t\\t\\tfirst_part.insert(fdx, \\'.\\')\\n\\t\\t\\t\\t\\tfirst_part_integer = first_part[:fdx]\\n\\t\\t\\t\\t\\tfirst_part_decimal = first_part[fdx+1:]\\n\\t\\t\\t\\t\\tif is_valid_integer(first_part_integer) and is_valid_decimal(first_part_decimal) and is_valid_integer(second_part): \\n\\t\\t\\t\\t\\t\\tres.append(\\'(\\' + \\'\\'.join(first_part) + \\', \\' + \\'\\'.join(second_part) + \\')\\')\\n\\t\\t\\t\\t\\tfirst_part.pop(fdx)    \\n\\n\\t\\t\\t\\tfor fdx in range(1, first_part_len): \\n\\t\\t\\t\\t\\tfirst_part.insert(fdx, \\'.\\')\\n\\t\\t\\t\\t\\tfirst_part_integer = first_part[:fdx]\\n\\t\\t\\t\\t\\tfirst_part_decimal = first_part[fdx+1:]\\n\\t\\t\\t\\t\\tfor sdx in range(1, second_part_len): \\n\\t\\t\\t\\t\\t\\tsecond_part.insert(sdx, \\'.\\')\\n\\t\\t\\t\\t\\t\\tsecond_part_integer = second_part[:sdx]\\n\\t\\t\\t\\t\\t\\tsecond_part_decimal = second_part[sdx+1:]\\n\\t\\t\\t\\t\\t\\tif is_valid_integer(first_part_integer) and is_valid_decimal(first_part_decimal) and is_valid_integer(second_part_integer) and is_valid_decimal(second_part_decimal): \\n\\t\\t\\t\\t\\t\\t\\tres.append(\\'(\\' + \\'\\'.join(first_part) + \\', \\' + \\'\\'.join(second_part) + \\')\\')\\n\\t\\t\\t\\t\\t\\tsecond_part.pop(sdx)     \\n\\t\\t\\t\\t\\tfirst_part.pop(fdx)   \\n\\t\\t\\t\\ts_list.pop(idx)    \\n\\t\\t\\treturn res        \\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2786263,
                "title": "python-clear-explained-clean",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDivide it into sub problems:\\n - split left hand side and right hand side (123 | 456)\\n - split the \\'.\\' (123, 1.23, 12.3)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNested for loops\\n```\\nfor (lhs, rhs):\\n    for comb(lhs):\\n        for comb(rhs):\\n            add to output\\n# 3 loops => very likely in O(n^3)\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N<sup>3</sup>)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N<sup>3</sup>)\\n# Code\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\n        def possibleSplit(inputStr):\\n            # integer (no leading zeros or \\'0\\' itself)\\n            output = [inputStr] if inputStr[0] != \\'0\\' or inputStr == \\'0\\' else []\\n            # float\\n            for i in range(1, len(inputStr)):\\n                digit, decimal = inputStr[:i], inputStr[i:]\\n                # checking digit (left extra zeros)\\n                if len(digit) >= 2 and digit[0] == \\'0\\':\\n                    break\\n                # checking decimal (right extra zeros)\\n                if decimal[-1] == \\'0\\':\\n                    break\\n                output.append(f\\'{digit}.{decimal}\\')\\n            return output\\n        \\n        numStr = s[1:-1]\\n        output = []\\n        for i in range(1, len(numStr)):\\n            for x in possibleSplit(numStr[:i]):\\n                for y in possibleSplit(numStr[i:]):\\n                    output.append(f\\'({x}, {y})\\')\\n\\n        return output\\n\\n \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfor (lhs, rhs):\\n    for comb(lhs):\\n        for comb(rhs):\\n            add to output\\n# 3 loops => very likely in O(n^3)\\n```\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\n        def possibleSplit(inputStr):\\n            # integer (no leading zeros or \\'0\\' itself)\\n            output = [inputStr] if inputStr[0] != \\'0\\' or inputStr == \\'0\\' else []\\n            # float\\n            for i in range(1, len(inputStr)):\\n                digit, decimal = inputStr[:i], inputStr[i:]\\n                # checking digit (left extra zeros)\\n                if len(digit) >= 2 and digit[0] == \\'0\\':\\n                    break\\n                # checking decimal (right extra zeros)\\n                if decimal[-1] == \\'0\\':\\n                    break\\n                output.append(f\\'{digit}.{decimal}\\')\\n            return output\\n        \\n        numStr = s[1:-1]\\n        output = []\\n        for i in range(1, len(numStr)):\\n            for x in possibleSplit(numStr[:i]):\\n                for y in possibleSplit(numStr[i:]):\\n                    output.append(f\\'({x}, {y})\\')\\n\\n        return output\\n\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766104,
                "title": "c-annoying-question-with-annoying-code",
                "content": "Simple idea, just be careful of syntax errors... if any.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> res = {};\\n    string createResult(string l, string r) {\\n        return \"(\" + l + \", \" + r + \")\"; \\n    }\\n    string createDouble(string raw, int didx) {\\n        string res = \"\";\\n        res = raw.substr(0, didx + 1) + \".\" + raw.substr(didx + 1, raw.length() - didx - 1);\\n        return res;\\n    }\\n    void ckRightThenAppend(string ls, string rs, int rsl) {\\n        if (rsl == 1) {\\n            res.push_back(createResult(ls, rs));\\n        }\\n        else {\\n            if (rs[0] == \\'0\\') {\\n                if (rs[rsl - 1] == \\'0\\') {\\n                    \\n                }\\n                else {\\n                    res.push_back(createResult(ls, createDouble(rs, 0)));\\n                }\\n            }\\n            else {\\n                res.push_back(createResult(ls, rs));\\n                if (rs[rsl - 1] == \\'0\\') {\\n                    \\n                }\\n                else {\\n                    for (int i = 0; i < rsl - 1; i++) {\\n                         res.push_back(createResult(ls, createDouble(rs, i)));\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int len = s.length();\\n        string t = s.substr(1, (len - 2));\\n        len = t.length();\\n        for (int i = 0; i < len - 1; i++) {\\n            string ls = t.substr(0, (i + 1));\\n            string rs = t.substr((i + 1), (len - i - 1));\\n            int lsl = ls.length();\\n            int rsl = rs.length();\\n            string ltmp, rtmp;\\n            if (ls.length() == 1) {\\n                ckRightThenAppend(ls, rs, rsl);\\n            }\\n            else {\\n                if (ls[0] == \\'0\\') {\\n                    if (ls[lsl - 1] == \\'0\\') {\\n                        \\n                    }\\n                    else {\\n                        ltmp = createDouble(ls, 0);\\n                        ckRightThenAppend(ltmp, rs, rsl);\\n                    }\\n                }\\n                else {\\n                    ckRightThenAppend(ls, rs, rsl);\\n                    if (ls[lsl - 1] == \\'0\\') {\\n                        \\n                    }\\n                    else {\\n                        for (int i = 0; i < lsl - 1; i++) {\\n                            ltmp = createDouble(ls, i);\\n                            ckRightThenAppend(ltmp, rs, rsl);\\n                        }\\n                    }                    \\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> res = {};\\n    string createResult(string l, string r) {\\n        return \"(\" + l + \", \" + r + \")\"; \\n    }\\n    string createDouble(string raw, int didx) {\\n        string res = \"\";\\n        res = raw.substr(0, didx + 1) + \".\" + raw.substr(didx + 1, raw.length() - didx - 1);\\n        return res;\\n    }\\n    void ckRightThenAppend(string ls, string rs, int rsl) {\\n        if (rsl == 1) {\\n            res.push_back(createResult(ls, rs));\\n        }\\n        else {\\n            if (rs[0] == \\'0\\') {\\n                if (rs[rsl - 1] == \\'0\\') {\\n                    \\n                }\\n                else {\\n                    res.push_back(createResult(ls, createDouble(rs, 0)));\\n                }\\n            }\\n            else {\\n                res.push_back(createResult(ls, rs));\\n                if (rs[rsl - 1] == \\'0\\') {\\n                    \\n                }\\n                else {\\n                    for (int i = 0; i < rsl - 1; i++) {\\n                         res.push_back(createResult(ls, createDouble(rs, i)));\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int len = s.length();\\n        string t = s.substr(1, (len - 2));\\n        len = t.length();\\n        for (int i = 0; i < len - 1; i++) {\\n            string ls = t.substr(0, (i + 1));\\n            string rs = t.substr((i + 1), (len - i - 1));\\n            int lsl = ls.length();\\n            int rsl = rs.length();\\n            string ltmp, rtmp;\\n            if (ls.length() == 1) {\\n                ckRightThenAppend(ls, rs, rsl);\\n            }\\n            else {\\n                if (ls[0] == \\'0\\') {\\n                    if (ls[lsl - 1] == \\'0\\') {\\n                        \\n                    }\\n                    else {\\n                        ltmp = createDouble(ls, 0);\\n                        ckRightThenAppend(ltmp, rs, rsl);\\n                    }\\n                }\\n                else {\\n                    ckRightThenAppend(ls, rs, rsl);\\n                    if (ls[lsl - 1] == \\'0\\') {\\n                        \\n                    }\\n                    else {\\n                        for (int i = 0; i < lsl - 1; i++) {\\n                            ltmp = createDouble(ls, i);\\n                            ckRightThenAppend(ltmp, rs, rsl);\\n                        }\\n                    }                    \\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753546,
                "title": "divide-conquer-faster-than-70",
                "content": "\\tclass Solution:\\n\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.ans=[]\\n\\n\\n\\t\\tdef checkCorrect(self,string):\\n\\n\\t\\t\\tif \\'.\\' not in string:\\n\\t\\t\\t\\tif(str(int(string))==string):\\n\\t\\t\\t\\t\\treturn string\\n\\t\\t\\t\\treturn \"\"\\n\\t\\t\\telse:\\n\\t\\t\\t\\tindex=-1\\n\\t\\t\\t\\tfor i in range(len(string)):\\n\\t\\t\\t\\t\\tif(string[i]==\\'.\\'):\\n\\t\\t\\t\\t\\t\\tindex=i\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\ts1=string[:index]\\n\\t\\t\\t\\ts2=string[index+1:]\\n\\n\\t\\t\\t\\tc=0\\n\\t\\t\\t\\tfor i in s1:\\n\\t\\t\\t\\t\\tif(i==\\'0\\'):\\n\\t\\t\\t\\t\\t\\tc+=1\\n\\n\\t\\t\\t\\tif(((c!=len(s1) and s1[0]!=\\'0\\') or (c==1 and len(s1)==1) or( c>1 and s1[0]!=\\'0\\')))  and s2[-1]!=\\'0\\':\\n\\t\\t\\t\\t\\treturn string\\n\\n\\t\\t\\t\\treturn \"\"\\n\\n\\n\\t\\tdef makeAnswer(self,string,index,ans,c,final):\\n\\t\\t\\tif(index==len(string)-1):\\n\\t\\t\\t\\tfor i in range(index,len(string)):\\n\\t\\t\\t\\t\\tans+=string[i]\\n\\n\\t\\t\\t\\tst=\"\"\\n\\t\\t\\t\\tfor i in ans:\\n\\t\\t\\t\\t\\tst+=i\\n\\n\\t\\t\\t\\tres=self.checkCorrect(st)\\n\\t\\t\\t\\tif(res!=\"\"):\\n\\t\\t\\t\\t\\tfinal.append(res)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\telif(c==0):\\n\\t\\t\\t\\tfor i in range(index,len(string)):\\n\\t\\t\\t\\t\\tans+=string[i]\\n\\t\\t\\t\\tst=\"\"\\n\\t\\t\\t\\tfor i in ans:\\n\\t\\t\\t\\t\\tst+=i\\n\\n\\t\\t\\t\\tres=self.checkCorrect(st)\\n\\t\\t\\t\\tif(res!=\"\"):\\n\\t\\t\\t\\t\\tfinal.append(res)\\n\\t\\t\\t\\treturn\\n\\n\\n\\t\\t\\tself.makeAnswer(string,index+1,ans+string[index]+\".\",c-1,final)\\n\\t\\t\\tself.makeAnswer(string,index+1,ans+string[index],c,final)\\n\\n\\t\\t\\treturn\\n\\n\\t\\tdef divideCon(self,string):\\n\\t\\t\\tans=[]\\n\\t\\t\\tfor i in range(2,len(string)-1):\\n\\n\\t\\t\\t\\ts1=string[:i]\\n\\t\\t\\t\\ts2=string[i:]\\n\\t\\t\\t\\ts1=s1[1:]\\n\\t\\t\\t\\ts2=s2[:-1]\\n\\t\\t\\t\\tl1=[]\\n\\t\\t\\t\\tl2=[]\\n\\t\\t\\t\\tself.makeAnswer(s1,0,\"\",1,l1)\\n\\t\\t\\t\\tself.makeAnswer(s2,0,\"\",1,l2)\\n\\n\\t\\t\\t\\tif(len(l1)!=0 and len(l2)!=0):\\n\\t\\t\\t\\t\\tfor i in l1:\\n\\t\\t\\t\\t\\t\\tfor j in l2:\\n\\t\\t\\t\\t\\t\\t\\tfg=\\'(\\'+i+\", \"+j+\")\"\\n\\t\\t\\t\\t\\t\\t\\tans.append(fg)\\n\\n\\t\\t\\treturn ans\\n\\n\\n\\t\\tdef ambiguousCoordinates(self, s: str) -> List[str]:\\n\\n\\t\\t\\treturn self.divideCon(s)\\n\\t\\t\\t\\n\\t\\t\\t\\n**Please Upvote**\\n\\ntraverse the string from 2 index, becoz we will always place a \\',\\' between 2 numbers.\\nThan try all combos for \\'.\\' in the first anf second string, and at last just arrange those strings.\\nThe imp work here is to validate that the string formed is valid or not, like\\nthere must be no continuous zeros before \\'.\\', etc etc. make sure that.",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.ans=[]\\n\\n\\n\\t\\tdef checkCorrect(self,string):\\n\\n\\t\\t\\tif \\'.\\' not in string:\\n\\t\\t\\t\\tif(str(int(string))==string):\\n\\t\\t\\t\\t\\treturn string\\n\\t\\t\\t\\treturn \"\"\\n\\t\\t\\telse:\\n\\t\\t\\t\\tindex=-1\\n\\t\\t\\t\\tfor i in range(len(string)):\\n\\t\\t\\t\\t\\tif(string[i]==\\'.\\'):\\n\\t\\t\\t\\t\\t\\tindex=i\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\ts1=string[:index]\\n\\t\\t\\t\\ts2=string[index+1:]\\n\\n\\t\\t\\t\\tc=0\\n\\t\\t\\t\\tfor i in s1:\\n\\t\\t\\t\\t\\tif(i==\\'0\\'):\\n\\t\\t\\t\\t\\t\\tc+=1\\n\\n\\t\\t\\t\\tif(((c!=len(s1) and s1[0]!=\\'0\\') or (c==1 and len(s1)==1) or( c>1 and s1[0]!=\\'0\\')))  and s2[-1]!=\\'0\\':\\n\\t\\t\\t\\t\\treturn string\\n\\n\\t\\t\\t\\treturn \"\"\\n\\n\\n\\t\\tdef makeAnswer(self,string,index,ans,c,final):\\n\\t\\t\\tif(index==len(string)-1):\\n\\t\\t\\t\\tfor i in range(index,len(string)):\\n\\t\\t\\t\\t\\tans+=string[i]\\n\\n\\t\\t\\t\\tst=\"\"\\n\\t\\t\\t\\tfor i in ans:\\n\\t\\t\\t\\t\\tst+=i\\n\\n\\t\\t\\t\\tres=self.checkCorrect(st)\\n\\t\\t\\t\\tif(res!=\"\"):\\n\\t\\t\\t\\t\\tfinal.append(res)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\telif(c==0):\\n\\t\\t\\t\\tfor i in range(index,len(string)):\\n\\t\\t\\t\\t\\tans+=string[i]\\n\\t\\t\\t\\tst=\"\"\\n\\t\\t\\t\\tfor i in ans:\\n\\t\\t\\t\\t\\tst+=i\\n\\n\\t\\t\\t\\tres=self.checkCorrect(st)\\n\\t\\t\\t\\tif(res!=\"\"):\\n\\t\\t\\t\\t\\tfinal.append(res)\\n\\t\\t\\t\\treturn\\n\\n\\n\\t\\t\\tself.makeAnswer(string,index+1,ans+string[index]+\".\",c-1,final)\\n\\t\\t\\tself.makeAnswer(string,index+1,ans+string[index],c,final)\\n\\n\\t\\t\\treturn\\n\\n\\t\\tdef divideCon(self,string):\\n\\t\\t\\tans=[]\\n\\t\\t\\tfor i in range(2,len(string)-1):\\n\\n\\t\\t\\t\\ts1=string[:i]\\n\\t\\t\\t\\ts2=string[i:]\\n\\t\\t\\t\\ts1=s1[1:]\\n\\t\\t\\t\\ts2=s2[:-1]\\n\\t\\t\\t\\tl1=[]\\n\\t\\t\\t\\tl2=[]\\n\\t\\t\\t\\tself.makeAnswer(s1,0,\"\",1,l1)\\n\\t\\t\\t\\tself.makeAnswer(s2,0,\"\",1,l2)\\n\\n\\t\\t\\t\\tif(len(l1)!=0 and len(l2)!=0):\\n\\t\\t\\t\\t\\tfor i in l1:\\n\\t\\t\\t\\t\\t\\tfor j in l2:\\n\\t\\t\\t\\t\\t\\t\\tfg=\\'(\\'+i+\", \"+j+\")\"\\n\\t\\t\\t\\t\\t\\t\\tans.append(fg)\\n\\n\\t\\t\\treturn ans\\n\\n\\n\\t\\tdef ambiguousCoordinates(self, s: str) -> List[str]:\\n\\n\\t\\t\\treturn self.divideCon(s)\\n\\t\\t\\t\\n\\t\\t\\t\\n**Please Upvote**\\n\\ntraverse the string from 2 index, becoz we will always place a \\',\\' between 2 numbers.\\nThan try all combos for \\'.\\' in the first anf second string, and at last just arrange those strings.\\nThe imp work here is to validate that the string formed is valid or not, like\\nthere must be no continuous zeros before \\'.\\', etc etc. make sure that.",
                "codeTag": "Java"
            },
            {
                "id": 2752463,
                "title": "explained-c",
                "content": "```\\nCan be done in two steps.\\nSeparate x and y coordinates in one step.\\nPlace decimal point in second step.\\nThe decimal can\\'t be placed when starting is with \\'0\\' and left part size is > 1\\nAlso when the last char is \\'0\\'.\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<string> sep(string s){\\n        int n = s.size();\\n        vector<string> ans;\\n\\t\\t// if size is 1 or starting is not with \\'0\\'\\n\\t\\t// we can take whole string is valid\\n        if(n == 1 || s[0] != \\'0\\') ans.push_back(s);\\n        for(int i=1; i<n; i++){\\n            string a = s.substr(0,i);\\n            string b = s.substr(i,n-i);\\n\\t\\t\\t// if size > 1 and starting is 0, invalid\\n            if(i > 1 && s[0] == \\'0\\') break;\\n\\t\\t\\t// if last index is 0, invalid\\n            if(s[n-1] == \\'0\\') break;\\n            string x = a + \".\" + b;\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.size();\\n        vector<string> ans;\\n        for(int i=1; i<n-2; i++){\\n\\t\\t\\t// first char is (, so start with 1\\n\\t\\t\\t// separate left and right part \\n\\t\\t\\t// apply decimal of both the parts\\n            vector<string> a = sep(s.substr(1,i));\\n            vector<string> b = sep(s.substr(i+1,n-2-i));\\n            for(auto i:a){\\n                for(auto j:b){\\n                    string x = \"(\" + i + \", \" + j + \")\";\\n                    ans.push_back(x);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nCan be done in two steps.\\nSeparate x and y coordinates in one step.\\nPlace decimal point in second step.\\nThe decimal can\\'t be placed when starting is with \\'0\\' and left part size is > 1\\nAlso when the last char is \\'0\\'.\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> sep(string s){\\n        int n = s.size();\\n        vector<string> ans;\\n\\t\\t// if size is 1 or starting is not with \\'0\\'\\n\\t\\t// we can take whole string is valid\\n        if(n == 1 || s[0] != \\'0\\') ans.push_back(s);\\n        for(int i=1; i<n; i++){\\n            string a = s.substr(0,i);\\n            string b = s.substr(i,n-i);\\n\\t\\t\\t// if size > 1 and starting is 0, invalid\\n            if(i > 1 && s[0] == \\'0\\') break;\\n\\t\\t\\t// if last index is 0, invalid\\n            if(s[n-1] == \\'0\\') break;\\n            string x = a + \".\" + b;\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.size();\\n        vector<string> ans;\\n        for(int i=1; i<n-2; i++){\\n\\t\\t\\t// first char is (, so start with 1\\n\\t\\t\\t// separate left and right part \\n\\t\\t\\t// apply decimal of both the parts\\n            vector<string> a = sep(s.substr(1,i));\\n            vector<string> b = sep(s.substr(i+1,n-2-i));\\n            for(auto i:a){\\n                for(auto j:b){\\n                    string x = \"(\" + i + \", \" + j + \")\";\\n                    ans.push_back(x);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645114,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar ambiguousCoordinates = function(s) {\\n\\t\\tconst set = new Set();\\n\\t\\tconst getCoordinate = (str) => {\\n\\t\\t\\tif (str.length === 1) return [str];\\n\\t\\t\\tconst isStartZero = str.startsWith(\\'0\\');\\n\\t\\t\\tconst isEndZero = str.endsWith(\\'0\\');\\n\\t\\t\\tif (isStartZero && isEndZero) return;\\n\\t\\t\\tif (isStartZero && !isEndZero) return [`0.${str.slice(1)}`];\\n\\t\\t\\tif (isEndZero) return [str];\\n\\n\\t\\t\\tconst dot = [];\\n\\t\\t\\tfor (let index = 1; index < str.length; index++) {\\n\\t\\t\\t\\tconst reuslt = `${str.slice(0, index)}.${str.slice(index)}`;\\n\\t\\t\\t\\tdot.push(reuslt);\\n\\t\\t\\t}\\n\\t\\t\\treturn [str, ...dot];\\n\\t\\t};\\n\\n\\t\\ts = s.slice(1, -1);\\n\\n\\t\\tfor (let index = 0; index < s.length - 1; index++) {\\n\\t\\t\\tconst x = getCoordinate(s.slice(0, index + 1));\\n\\t\\t\\tconst y = getCoordinate(s.slice(index + 1));\\n\\t\\t\\tif (!x || !y) continue;\\n\\n\\t\\t\\tx.forEach(valueX => {\\n\\t\\t\\t\\ty.forEach(valueY => set.add(`(${valueX}, ${valueY})`));\\n\\t\\t\\t});\\n\\t\\t}\\n\\t\\treturn [...set];\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar ambiguousCoordinates = function(s) {\\n\\t\\tconst set = new Set();\\n\\t\\tconst getCoordinate = (str) => {\\n\\t\\t\\tif (str.length === 1) return [str];\\n\\t\\t\\tconst isStartZero = str.startsWith(\\'0\\');\\n\\t\\t\\tconst isEndZero = str.endsWith(\\'0\\');\\n\\t\\t\\tif (isStartZero && isEndZero) return;\\n\\t\\t\\tif (isStartZero && !isEndZero) return [`0.${str.slice(1)}`];\\n\\t\\t\\tif (isEndZero) return [str];\\n\\n\\t\\t\\tconst dot = [];\\n\\t\\t\\tfor (let index = 1; index < str.length; index++) {\\n\\t\\t\\t\\tconst reuslt = `${str.slice(0, index)}.${str.slice(index)}`;\\n\\t\\t\\t\\tdot.push(reuslt);\\n\\t\\t\\t}\\n\\t\\t\\treturn [str, ...dot];\\n\\t\\t};\\n\\n\\t\\ts = s.slice(1, -1);\\n\\n\\t\\tfor (let index = 0; index < s.length - 1; index++) {\\n\\t\\t\\tconst x = getCoordinate(s.slice(0, index + 1));\\n\\t\\t\\tconst y = getCoordinate(s.slice(index + 1));\\n\\t\\t\\tif (!x || !y) continue;\\n\\n\\t\\t\\tx.forEach(valueX => {\\n\\t\\t\\t\\ty.forEach(valueY => set.add(`(${valueX}, ${valueY})`));\\n\\t\\t\\t});\\n\\t\\t}\\n\\t\\treturn [...set];\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2631672,
                "title": "o-n-3-time-o-n-3-space-clear-explanation-consider-all-the-options",
                "content": "![image](https://assets.leetcode.com/users/images/8eeb3ee6-e135-43e3-87a0-a5b75059365e_1664299536.0641801.png)\\n\\n\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \"\"\" O(N^3)TS \"\"\"\\n\\n        def fn(n):\\n            if not (len(n) > 1 and n[0] == n[-1] == \\'0\\'):\\n                if n[-1] == \\'0\\':\\n                    yield n\\n                elif n[0] == \\'0\\':\\n                    yield n[0] + \\'.\\' + n[1:]\\n                else:\\n                    yield from [n] + [f\\'{n[:i]}.{n[i:]}\\' for i in range(1, len(n))]\\n\\n        arr = s.strip(\\'()\\')\\n        return [f\\'({a}, {b})\\' for i in range(1, len(arr)) for a, b in itertools.product(fn(arr[:i]), fn(arr[i:]))]\\n\\n![image](https://assets.leetcode.com/users/images/17b584c9-0b1e-45ba-b478-0791ffd5b514_1664299547.2679756.png)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/8eeb3ee6-e135-43e3-87a0-a5b75059365e_1664299536.0641801.png)\\n\\n\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \"\"\" O(N^3)TS \"\"\"\\n\\n        def fn(n):\\n            if not (len(n) > 1 and n[0] == n[-1] == \\'0\\'):\\n                if n[-1] == \\'0\\':\\n                    yield n\\n                elif n[0] == \\'0\\':\\n                    yield n[0] + \\'.\\' + n[1:]\\n                else:\\n                    yield from [n] + [f\\'{n[:i]}.{n[i:]}\\' for i in range(1, len(n))]\\n\\n        arr = s.strip(\\'()\\')\\n        return [f\\'({a}, {b})\\' for i in range(1, len(arr)) for a, b in itertools.product(fn(arr[:i]), fn(arr[i:]))]\\n\\n![image](https://assets.leetcode.com/users/images/17b584c9-0b1e-45ba-b478-0791ffd5b514_1664299547.2679756.png)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2579252,
                "title": "c-backtracking-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n\\n    void backtrack(string &s, char last = \\'(\\', int index = 1, bool dec = false, bool comma = false, bool beg = false, string out = \"(\") {\\n        if(index == s.length()-1) {\\n            if(comma and ((dec and last != \\'0\\') or !dec)) {\\n                out += s[index];\\n                ans.push_back(out);\\n            }\\n            return;\\n        }\\n\\n        string outcopy = out+\\'*\\';\\n        if(dec or last != \\'0\\' or (last == \\'0\\' and beg)) {\\n            outcopy.back() = s[index];\\n            if(last == \\'(\\' or last == \\',\\') backtrack(s,s[index],index+1,dec,comma,s[index] != \\'0\\',outcopy);\\n            else backtrack(s,s[index],index+1,dec,comma,beg,outcopy);\\n        }\\n        \\n        if(!dec and last != \\',\\' and last != \\'(\\') {\\n            outcopy.back() = \\'.\\';\\n            backtrack(s,\\'.\\',index,true,comma,beg,outcopy);\\n        }\\n        \\n        if(!comma and last != \\'.\\' and last != \\'(\\' and !(dec and last == \\'0\\')) {\\n            outcopy.back() = \\',\\';\\n            outcopy += \\' \\';\\n            backtrack(s,\\',\\',index,false,true,false,outcopy);\\n        }\\n    }\\n\\n    vector<string> ambiguousCoordinates(string s) {\\n        backtrack(s);\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> ans;\\n\\n    void backtrack(string &s, char last = \\'(\\', int index = 1, bool dec = false, bool comma = false, bool beg = false, string out = \"(\") {\\n        if(index == s.length()-1) {\\n            if(comma and ((dec and last != \\'0\\') or !dec)) {\\n                out += s[index];\\n                ans.push_back(out);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2470876,
                "title": "python3-solved-using-general-intuition-and-handling-edge-cases-with-0",
                "content": "```\\nclass Solution:\\n    #Time-Complexity: O(n^3), since outer for loop runs n times, and in worst case,\\n    #the first_value and second_value array of coordinates used to pairing up is in worst case\\n    #at most size n if the substring we passed to helper is around n characters! \\n    #Space-Complexity: O(2*n * n) -> O(n^2)\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        #First, we need to decide how to split s into two numbers! This will decide where to put\\n        #comma! \\n        \\n        #Then, we need to see if we are able to put decimal point in only one of the two splitted\\n        #numbers!\\n        \\n        #we also need to exclude the parentheses characteres!\\n        s = s[1:len(s)-1]\\n        #we need to define some helper to determine all possible valid coordinate values\\n        #we can form using substring x as input!\\n        def helper(x):\\n            #if x is single character, then itself is a valid coordinate value and only one!\\n            if(len(x) == 1):\\n                return [x]\\n            #if x has both first and last character be a 0, it can\\'t ever result in a \\n            #valid coordinate value!\\n            if(x[0] == \"0\" and x[len(x)-1] == \"0\"):\\n                return []\\n            #if only first character is 0, only valid coordinate value it can form is \\n            #in form 0.xxxxxx...!\\n            if(x[0] == \"0\"):\\n                return [\"0.\" + x[1:]]\\n            #if last digit is a 0, it can always be simplified no matter where I place\\n            #decimal point, thus only possible coordinate value candidate is x itself!\\n            if(x[-1] == \\'0\\'):\\n                return [x]\\n            #otherwise, we can simply generate all possible coordinate values by placing\\n            #decimal point between every two digits!\\n            else:\\n                #string x as itself is one of many ways!\\n                local = [x]\\n                #we will iterate from first char to 2nd to last char!\\n                cur = \"\"\\n                for i in range(0, len(x) - 1):\\n                    cur += x[i]\\n                    second_portion = x[i+1:]\\n                    overall = cur + \".\" + second_portion\\n                    local.append(overall)\\n                return local\\n                    \\n                    \\n                    \\n                    \\n            \\n        \\n        \\n        ans = []\\n        n = len(s)\\n        #For each iteration, we consider a possible split!\\n        for i in range(1, n):\\n            #consider splitting the string input s into left and right portions!\\n            #Left portion will determine all possible first coordinate values!\\n            #Right portion will determine all possible second coordinate values!\\n            l = s[:i]\\n            r = s[i:]\\n            #Once we find all possible first and second coordinate values, we simply\\n            #need to find all pairings!\\n            left_vals = helper(l)\\n            right_vals = helper(r)\\n            \\n            #before running for loop, we need to make sure that left_vals and right_vals is both\\n            #not an empty array. If even one of them is empty, it is not possible to form\\n            #a single valid 2-d coordinate pairing!\\n            if(not left_vals and not right_vals):\\n                continue\\n            for l in left_vals:\\n                for r in right_vals:\\n                    new_pairing = \"(\" + l + \", \" + r + \")\"\\n                    ans.append(new_pairing)\\n        return ans",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    #Time-Complexity: O(n^3), since outer for loop runs n times, and in worst case,\\n    #the first_value and second_value array of coordinates used to pairing up is in worst case\\n    #at most size n if the substring we passed to helper is around n characters! \\n    #Space-Complexity: O(2*n * n) -> O(n^2)\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        #First, we need to decide how to split s into two numbers! This will decide where to put\\n        #comma! \\n        \\n        #Then, we need to see if we are able to put decimal point in only one of the two splitted\\n        #numbers!\\n        \\n        #we also need to exclude the parentheses characteres!\\n        s = s[1:len(s)-1]\\n        #we need to define some helper to determine all possible valid coordinate values\\n        #we can form using substring x as input!\\n        def helper(x):\\n            #if x is single character, then itself is a valid coordinate value and only one!\\n            if(len(x) == 1):\\n                return [x]\\n            #if x has both first and last character be a 0, it can\\'t ever result in a \\n            #valid coordinate value!\\n            if(x[0] == \"0\" and x[len(x)-1] == \"0\"):\\n                return []\\n            #if only first character is 0, only valid coordinate value it can form is \\n            #in form 0.xxxxxx...!\\n            if(x[0] == \"0\"):\\n                return [\"0.\" + x[1:]]\\n            #if last digit is a 0, it can always be simplified no matter where I place\\n            #decimal point, thus only possible coordinate value candidate is x itself!\\n            if(x[-1] == \\'0\\'):\\n                return [x]\\n            #otherwise, we can simply generate all possible coordinate values by placing\\n            #decimal point between every two digits!\\n            else:\\n                #string x as itself is one of many ways!\\n                local = [x]\\n                #we will iterate from first char to 2nd to last char!\\n                cur = \"\"\\n                for i in range(0, len(x) - 1):\\n                    cur += x[i]\\n                    second_portion = x[i+1:]\\n                    overall = cur + \".\" + second_portion\\n                    local.append(overall)\\n                return local\\n                    \\n                    \\n                    \\n                    \\n            \\n        \\n        \\n        ans = []\\n        n = len(s)\\n        #For each iteration, we consider a possible split!\\n        for i in range(1, n):\\n            #consider splitting the string input s into left and right portions!\\n            #Left portion will determine all possible first coordinate values!\\n            #Right portion will determine all possible second coordinate values!\\n            l = s[:i]\\n            r = s[i:]\\n            #Once we find all possible first and second coordinate values, we simply\\n            #need to find all pairings!\\n            left_vals = helper(l)\\n            right_vals = helper(r)\\n            \\n            #before running for loop, we need to make sure that left_vals and right_vals is both\\n            #not an empty array. If even one of them is empty, it is not possible to form\\n            #a single valid 2-d coordinate pairing!\\n            if(not left_vals and not right_vals):\\n                continue\\n            for l in left_vals:\\n                for r in right_vals:\\n                    new_pairing = \"(\" + l + \", \" + r + \")\"\\n                    ans.append(new_pairing)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2401452,
                "title": "intuitive-simulation",
                "content": "```\\nclass Solution {\\n    \\n    vector<string> make(const string& str) {\\n        vector<string> res;\\n        int len = str.size();\\n        \\n        for (int sep = 1; sep <= len; ++sep) {\\n            auto left = str.substr(0, sep);\\n            auto right = str.substr(sep);\\n            if ((left[0] != \\'0\\' or left == \"0\") and right.back() != \\'0\\')\\n                res.push_back(left + (sep < len ? \".\" : \"\") + right);\\n        }\\n        \\n        return res;\\n    }\\n    \\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1, s.size() - 2);\\n        vector<string> res;\\n        for (int sep = 1; sep < s.size(); ++sep) {\\n            for (auto left : make(s.substr(0, sep))) {\\n                for (auto right : make(s.substr(sep))) {\\n                    res.push_back(\"(\" + left + \", \" + right + \")\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    vector<string> make(const string& str) {\\n        vector<string> res;\\n        int len = str.size();\\n        \\n        for (int sep = 1; sep <= len; ++sep) {\\n            auto left = str.substr(0, sep);\\n            auto right = str.substr(sep);\\n            if ((left[0] != \\'0\\' or left == \"0\") and right.back() != \\'0\\')\\n                res.push_back(left + (sep < len ? \".\" : \"\") + right);\\n        }\\n        \\n        return res;\\n    }\\n    \\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1, s.size() - 2);\\n        vector<string> res;\\n        for (int sep = 1; sep < s.size(); ++sep) {\\n            for (auto left : make(s.substr(0, sep))) {\\n                for (auto right : make(s.substr(sep))) {\\n                    res.push_back(\"(\" + left + \", \" + right + \")\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399267,
                "title": "typescript-100",
                "content": "```\\nfunction ambiguousCoordinates(s: string): string[] {\\n    s = s.substr(1, s.length-2);\\n    let pairs = [];\\n    for(let i=1; i<s.length; i++) {\\n        pairs.push([s.substr(0,i), s.substr(i)])\\n    }\\n    \\n    function getValidCombinations(s) {\\n        \\n        let possible = [];\\n        \\n        if(s.length == `${+s}`.length) {\\n           possible.push(s); \\n        }\\n        \\n        for(let i=1; i<s.length; i++) {\\n            let modified = s.substr(0,i)+\".\"+s.substr(i);\\n            if(modified.length == `${+modified}`.length) {\\n               possible.push(modified); \\n            }\\n        }\\n        return possible;\\n        \\n    }\\n    \\n    let result = [];\\n    for(let pair of pairs) {\\n        let comb1 = getValidCombinations(pair[0]);\\n        if(comb1.length) {\\n            let comb2 = getValidCombinations(pair[1]);\\n            for(let c1 of comb1) {\\n                for(let c2 of comb2) {\\n                    result.push(`(${c1}, ${c2})`);\\n                }\\n            }\\n        }\\n    }\\n    \\n    return result;\\n\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/96bed362-8e33-4156-94e7-45abe83eaa89_1659985691.1875932.png)\\n",
                "solutionTags": [],
                "code": "```\\nfunction ambiguousCoordinates(s: string): string[] {\\n    s = s.substr(1, s.length-2);\\n    let pairs = [];\\n    for(let i=1; i<s.length; i++) {\\n        pairs.push([s.substr(0,i), s.substr(i)])\\n    }\\n    \\n    function getValidCombinations(s) {\\n        \\n        let possible = [];\\n        \\n        if(s.length == `${+s}`.length) {\\n           possible.push(s); \\n        }\\n        \\n        for(let i=1; i<s.length; i++) {\\n            let modified = s.substr(0,i)+\".\"+s.substr(i);\\n            if(modified.length == `${+modified}`.length) {\\n               possible.push(modified); \\n            }\\n        }\\n        return possible;\\n        \\n    }\\n    \\n    let result = [];\\n    for(let pair of pairs) {\\n        let comb1 = getValidCombinations(pair[0]);\\n        if(comb1.length) {\\n            let comb2 = getValidCombinations(pair[1]);\\n            for(let c1 of comb1) {\\n                for(let c2 of comb2) {\\n                    result.push(`(${c1}, ${c2})`);\\n                }\\n            }\\n        }\\n    }\\n    \\n    return result;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2346369,
                "title": "python-brute-force-with-validation-solution",
                "content": "Intuition:\\n1. split s into all-possible two coordinates, some cases maybe invalid,we can filter out: 00110, possible splits: 0,0110 00,110, 001,10 but 00,110 is invalied as 00, so if one sub-split all contains all 0s length than 1 we can abort it.\\n2. for every split we enumerate all possible formed numbers(also filterout some invalied cases), eg, 011 there is 0.11 only, 110 there is:110 only, 101 there\\'re 1.01 10.1 101\\n3. using itertools.product to combine all paired of results from 1 and 2\\n*eg>s = \"(0123)\"\\n0,123 can be [0] combine with [1.23 12.3 123] so there are:(0,1,23),(0,12.3),(0,123)\\n01,23 can be [0.1] combine [2.3,23], so there are is:(0.1,2.3) and (0.1,23)\\n012,3 can be [0.12] and [3] so, (0.12,3)\\ntotal results:[\"(0, 1.23)\",\"(0, 12.3)\",\"(0, 123)\",\"(0.1, 2.3)\",\"(0.1, 23)\",\"(0.12, 3)\"]*\\n```\\nclass Solution(object):\\n    def ambiguousCoordinates(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        def _isValidSplit(s):\\n            return False if len(s)>1 and re.match(\\'/^[0]+$/\\',s) else True\\n            \\n        def _isValidNum(ipart,fpart):\\n            return False if (len(ipart)>1 and ipart[0]==\\'0\\') or (fpart and fpart[-1]==\\'0\\') else True\\n                             \\n        def _splitToNums(s):\\n            rets=[]\\n            if len(s)==1:return [s]\\n            for i in range(1,len(s)+1):\\n                a,b=s[:i],s[i:]\\n                if _isValidNum(a,b):rets.append(\"%s.%s\"%(a,b) if b else \"%s\"%(a))\\n            return rets               \\n        \\n        ans,s=[],s[1:-1]\\n        for i in range(1,len(s)):\\n            a,b=s[:i],s[i:]\\n            if not _isValidSplit(a) or not _isValidSplit(b):continue\\n            for c1,c2 in itertools.product(_splitToNums(a),_splitToNums(b)):ans.append(\"(%s, %s)\"%(c1,c2))\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def ambiguousCoordinates(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        def _isValidSplit(s):\\n            return False if len(s)>1 and re.match(\\'/^[0]+$/\\',s) else True\\n            \\n        def _isValidNum(ipart,fpart):\\n            return False if (len(ipart)>1 and ipart[0]==\\'0\\') or (fpart and fpart[-1]==\\'0\\') else True\\n                             \\n        def _splitToNums(s):\\n            rets=[]\\n            if len(s)==1:return [s]\\n            for i in range(1,len(s)+1):\\n                a,b=s[:i],s[i:]\\n                if _isValidNum(a,b):rets.append(\"%s.%s\"%(a,b) if b else \"%s\"%(a))\\n            return rets               \\n        \\n        ans,s=[],s[1:-1]\\n        for i in range(1,len(s)):\\n            a,b=s[:i],s[i:]\\n            if not _isValidSplit(a) or not _isValidSplit(b):continue\\n            for c1,c2 in itertools.product(_splitToNums(a),_splitToNums(b)):ans.append(\"(%s, %s)\"%(c1,c2))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340066,
                "title": "go-cartesian-product-fast",
                "content": "```\\nfunc ambiguousCoordinates(st string) []string {\\n\\tres := []string{}\\n\\n\\tisNotLegal := func(s string) bool {\\n\\t\\treturn !(len(s) == 1 || s[0] != \\'0\\' || s[len(s)-1] != \\'0\\')\\n\\t}\\n\\n\\tmakeCoordinates := func(s string) []string {\\n\\t\\tswitch {\\n\\t\\t\\tcase len(s) == 1 || s[len(s)-1] == \\'0\\':\\n\\t\\t\\t\\treturn []string{s}\\n\\t\\t\\tcase s[0] == \\'0\\':\\n\\t\\t\\t\\treturn []string{fmt.Sprintf(\"0.%s\", s[1:])}\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tresult := make([]string, 1, len(s))\\n\\t\\t\\t\\tresult[0] = s\\n\\t\\t\\t\\tfor i := 1; i < len(s); i++ {\\n\\t\\t\\t\\t\\tresult = append(result, fmt.Sprintf(\"%s.%s\", s[:i], s[i:]))\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result\\n\\t\\t\\t}\\n\\t}\\n\\n\\tfor i:=2; i<len(st)-1; i++ {\\n\\t\\tleft, right := st[1:i], st[i:len(st)-1]\\n\\t\\tif isNotLegal(left) || isNotLegal(right) {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tleftC, rightC := makeCoordinates(left), makeCoordinates(right)\\n\\t\\tfor _, l := range leftC {\\n\\t\\t\\tfor _, r := range rightC {\\n\\t\\t\\t\\tres = append(res, []string{fmt.Sprintf(\"(%s, %s)\", l, r)} ...)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc ambiguousCoordinates(st string) []string {\\n\\tres := []string{}\\n\\n\\tisNotLegal := func(s string) bool {\\n\\t\\treturn !(len(s) == 1 || s[0] != \\'0\\' || s[len(s)-1] != \\'0\\')\\n\\t}\\n\\n\\tmakeCoordinates := func(s string) []string {\\n\\t\\tswitch {\\n\\t\\t\\tcase len(s) == 1 || s[len(s)-1] == \\'0\\':\\n\\t\\t\\t\\treturn []string{s}\\n\\t\\t\\tcase s[0] == \\'0\\':\\n\\t\\t\\t\\treturn []string{fmt.Sprintf(\"0.%s\", s[1:])}\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tresult := make([]string, 1, len(s))\\n\\t\\t\\t\\tresult[0] = s\\n\\t\\t\\t\\tfor i := 1; i < len(s); i++ {\\n\\t\\t\\t\\t\\tresult = append(result, fmt.Sprintf(\"%s.%s\", s[:i], s[i:]))\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result\\n\\t\\t\\t}\\n\\t}\\n\\n\\tfor i:=2; i<len(st)-1; i++ {\\n\\t\\tleft, right := st[1:i], st[i:len(st)-1]\\n\\t\\tif isNotLegal(left) || isNotLegal(right) {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tleftC, rightC := makeCoordinates(left), makeCoordinates(right)\\n\\t\\tfor _, l := range leftC {\\n\\t\\t\\tfor _, r := range rightC {\\n\\t\\t\\t\\tres = append(res, []string{fmt.Sprintf(\"(%s, %s)\", l, r)} ...)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2313001,
                "title": "c-clean-code-recursive-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> getnumber(string s)\\n    {\\n        vector<string> ans;\\n        int n=s.size();\\n        if(n==1)\\n            return {s};\\n        if(s[0]!=\\'0\\')\\n        {\\n            ans.push_back(s);\\n                \\n        }\\n        if(s[0]==\\'0\\')\\n        {\\n            if(s[n-1]==\\'0\\')\\n            {\\n                return {};\\n            }\\n            else\\n                return {\"0.\"+s.substr(1)};\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s.substr(i).back()==\\'0\\')\\n                continue;\\n            ans.push_back(s.substr(0,i)+\".\"+s.substr(i));\\n        }\\n        return ans;\\n    }\\n    vector<string> ambiguousCoordinates(string ss) \\n    {\\n        vector<string> res;\\n        string s=ss.substr(1,ss.size()-2);\\n        int n=s.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            vector<string> s1=getnumber(s.substr(0,i));\\n            vector<string> s2=getnumber(s.substr(i));\\n            for(int j=0;j<s1.size();j++)\\n            {\\n    \\n                for(int k=0;k<s2.size();k++)\\n                {\\n                    \\n                    res.push_back(\"(\"+s1[j]+\", \"+s2[k]+\")\");\\n                }\\n            }\\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n// if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> getnumber(string s)\\n    {\\n        vector<string> ans;\\n        int n=s.size();\\n        if(n==1)\\n            return {s}",
                "codeTag": "Java"
            },
            {
                "id": 2270249,
                "title": "python-solution-just-follow-the-instruction",
                "content": "```\\nclass Solution:\\n    # DFS to put the comma and zeros\\n    # First put in the comma, and separate the front and back\\n    # For front and back, we try to put decimal point into each spot\\n    # For the decimal point placement to be valid, the one at front is always valid if it is of length 1. If it has length > 1, it must not start with 0\\n    # For the one at back cannot end with 0. Also, it cannot be a single 0\\n    \\n    def valid_decimals(self, front, back):\\n        if len(front) > 1 and front[0] == \"0\":\\n            return False\\n        if len(back) > 1 and back[-1] == \"0\":\\n            return False\\n        if back == \"0\":\\n            return False\\n        return True\\n    \\n    def dfs(self, front, back):\\n        valid_fronts = []\\n        valid_backs = []\\n        # not introducing any decimals\\n        if len(front) == 1:\\n            valid_fronts.append(front)\\n        elif front[0] != \\'0\\':\\n            valid_fronts.append(front)\\n            \\n        if len(back) == 1:\\n            valid_backs.append(back)\\n        elif back[0] != \\'0\\':\\n            valid_backs.append(back)\\n        # introducing the decimals\\n        if len(front) > 1:\\n            for i in range(1, len(front)):\\n                if self.valid_decimals(front[:i], front[i:]):\\n                    valid_fronts.append(front[:i] + \".\" + front[i:])\\n        if len(back) > 1:\\n            for i in range(1, len(back)):\\n                if self.valid_decimals(back[:i], back[i:]):\\n                    valid_backs.append(back[:i] + \".\" + back[i:])\\n        # Construct all the possible words\\n        valid_words = []\\n        for i in range(len(valid_fronts)):\\n            for j in range(len(valid_backs)):\\n                valid_words.append(\"(\" + valid_fronts[i] + \", \" + valid_backs[j] + \")\")\\n        return valid_words\\n            \\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        word = s[1:-1]\\n        result = []\\n        for i in range(1,len(word)):\\n            result += self.dfs(word[:i], word[i:])\\n        return result\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # DFS to put the comma and zeros\\n    # First put in the comma, and separate the front and back\\n    # For front and back, we try to put decimal point into each spot\\n    # For the decimal point placement to be valid, the one at front is always valid if it is of length 1. If it has length > 1, it must not start with 0\\n    # For the one at back cannot end with 0. Also, it cannot be a single 0\\n    \\n    def valid_decimals(self, front, back):\\n        if len(front) > 1 and front[0] == \"0\":\\n            return False\\n        if len(back) > 1 and back[-1] == \"0\":\\n            return False\\n        if back == \"0\":\\n            return False\\n        return True\\n    \\n    def dfs(self, front, back):\\n        valid_fronts = []\\n        valid_backs = []\\n        # not introducing any decimals\\n        if len(front) == 1:\\n            valid_fronts.append(front)\\n        elif front[0] != \\'0\\':\\n            valid_fronts.append(front)\\n            \\n        if len(back) == 1:\\n            valid_backs.append(back)\\n        elif back[0] != \\'0\\':\\n            valid_backs.append(back)\\n        # introducing the decimals\\n        if len(front) > 1:\\n            for i in range(1, len(front)):\\n                if self.valid_decimals(front[:i], front[i:]):\\n                    valid_fronts.append(front[:i] + \".\" + front[i:])\\n        if len(back) > 1:\\n            for i in range(1, len(back)):\\n                if self.valid_decimals(back[:i], back[i:]):\\n                    valid_backs.append(back[:i] + \".\" + back[i:])\\n        # Construct all the possible words\\n        valid_words = []\\n        for i in range(len(valid_fronts)):\\n            for j in range(len(valid_backs)):\\n                valid_words.append(\"(\" + valid_fronts[i] + \", \" + valid_backs[j] + \")\")\\n        return valid_words\\n            \\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        word = s[1:-1]\\n        result = []\\n        for i in range(1,len(word)):\\n            result += self.dfs(word[:i], word[i:])\\n        return result\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2120476,
                "title": "c-string-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> check(string s){\\n        int n = s.size();\\n        vector<string> res;\\n        if(s[0] == \\'0\\'){\\n            if(n == 1)\\n                res.push_back(s);\\n            else{\\n                if(s[n-1] == \\'0\\')\\n                    return res;\\n                \\n                s.insert(1, \".\");\\n                res.push_back(s);\\n            }\\n        }\\n        else{\\n            if(s[n-1] == \\'0\\'){\\n                res.push_back(s);\\n                return res;\\n            }\\n            \\n            for(int i=1; i<n; i++){\\n                string t = s.substr(0, i) + \".\" + s.substr(i, n-i);\\n                res.push_back(t);\\n            }\\n            res.push_back(s);\\n        }\\n        \\n        return res;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.size();\\n        vector<string> res;\\n        \\n        for(int i=2; i<n-1; i++){\\n            vector<string> left = check(s.substr(1, i-1));\\n            vector<string> right = check(s.substr(i, n-i-1));\\n            for(int j=0; j<left.size(); j++){\\n                for(int k=0; k<right.size(); k++){\\n                    string t = \"(\" + left[j] + \", \" + right[k] + \")\";\\n                    res.push_back(t);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> check(string s){\\n        int n = s.size();\\n        vector<string> res;\\n        if(s[0] == \\'0\\'){\\n            if(n == 1)\\n                res.push_back(s);\\n            else{\\n                if(s[n-1] == \\'0\\')\\n                    return res;\\n                \\n                s.insert(1, \".\");\\n                res.push_back(s);\\n            }\\n        }\\n        else{\\n            if(s[n-1] == \\'0\\'){\\n                res.push_back(s);\\n                return res;\\n            }\\n            \\n            for(int i=1; i<n; i++){\\n                string t = s.substr(0, i) + \".\" + s.substr(i, n-i);\\n                res.push_back(t);\\n            }\\n            res.push_back(s);\\n        }\\n        \\n        return res;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.size();\\n        vector<string> res;\\n        \\n        for(int i=2; i<n-1; i++){\\n            vector<string> left = check(s.substr(1, i-1));\\n            vector<string> right = check(s.substr(i, n-i-1));\\n            for(int j=0; j<left.size(); j++){\\n                for(int k=0; k<right.size(); k++){\\n                    string t = \"(\" + left[j] + \", \" + right[k] + \")\";\\n                    res.push_back(t);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093313,
                "title": "c-solution-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n\\n    void backtrack(string &s, char last = \\'(\\', int index = 1, bool dec = false, bool comma = false, bool beg = false, string out = \"(\") {\\n        if(index == s.length()-1) {\\n            if(comma and ((dec and last != \\'0\\') or !dec)) {\\n                out += s[index];\\n                ans.push_back(out);\\n            }\\n            return;\\n        }\\n\\n        string outcopy = out+\\'*\\';\\n        if(dec or last != \\'0\\' or (last == \\'0\\' and beg)) {\\n            outcopy.back() = s[index];\\n            if(last == \\'(\\' or last == \\',\\') backtrack(s,s[index],index+1,dec,comma,s[index] != \\'0\\',outcopy);\\n            else backtrack(s,s[index],index+1,dec,comma,beg,outcopy);\\n        }\\n        \\n        if(!dec and last != \\',\\' and last != \\'(\\') {\\n            outcopy.back() = \\'.\\';\\n            backtrack(s,\\'.\\',index,true,comma,beg,outcopy);\\n        }\\n        \\n        if(!comma and last != \\'.\\' and last != \\'(\\' and !(dec and last == \\'0\\')) {\\n            outcopy.back() = \\',\\';\\n            outcopy += \\' \\';\\n            backtrack(s,\\',\\',index,false,true,false,outcopy);\\n        }\\n    }\\n\\n    vector<string> ambiguousCoordinates(string s) {\\n        backtrack(s);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n\\n    void backtrack(string &s, char last = \\'(\\', int index = 1, bool dec = false, bool comma = false, bool beg = false, string out = \"(\") {\\n        if(index == s.length()-1) {\\n            if(comma and ((dec and last != \\'0\\') or !dec)) {\\n                out += s[index];\\n                ans.push_back(out);\\n            }\\n            return;\\n        }\\n\\n        string outcopy = out+\\'*\\';\\n        if(dec or last != \\'0\\' or (last == \\'0\\' and beg)) {\\n            outcopy.back() = s[index];\\n            if(last == \\'(\\' or last == \\',\\') backtrack(s,s[index],index+1,dec,comma,s[index] != \\'0\\',outcopy);\\n            else backtrack(s,s[index],index+1,dec,comma,beg,outcopy);\\n        }\\n        \\n        if(!dec and last != \\',\\' and last != \\'(\\') {\\n            outcopy.back() = \\'.\\';\\n            backtrack(s,\\'.\\',index,true,comma,beg,outcopy);\\n        }\\n        \\n        if(!comma and last != \\'.\\' and last != \\'(\\' and !(dec and last == \\'0\\')) {\\n            outcopy.back() = \\',\\';\\n            outcopy += \\' \\';\\n            backtrack(s,\\',\\',index,false,true,false,outcopy);\\n        }\\n    }\\n\\n    vector<string> ambiguousCoordinates(string s) {\\n        backtrack(s);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089318,
                "title": "java-detailed-explanation-easy-to-understand",
                "content": "Please refer to the comment, I think it is detailed enough~~\\n```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n\\t    // delete \"(\" and \")\" in the given string\\n        s = s.substring(1, s.length() - 1);\\n        List<String> res = new ArrayList<>();\\n        for (int i = 1; i < s.length(); ++i) {\\n\\t\\t    // split the given string into two parts:\\n\\t\\t\\t// - left part includes all possible x\\n\\t\\t\\t// - right part includes all possible y\\n            String xString = s.substring(0, i);\\n            String yString = s.substring(i);\\n\\t\\t\\t// what we need to do is to find all valid coordinates in each parts\\n            List<String> validX = validCoordinates(xString);\\n            List<String> validY = validCoordinates(yString);\\n\\t\\t\\t// once we get all possible x and y, we just combine them one by one\\n            for (String x : validX) {\\n                for (String y : validY) {\\n                    res.add(\"(\" + x + \", \" + y + \")\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private List<String> validCoordinates(String s) {\\n        List<String> res = new ArrayList<String>();\\n\\t    // firstly we can regard the whole string as an integer and check whether it is valid or not\\n        if (checkInteger(s)) {\\n            res.add(s);\\n        }\\n\\t\\t// then we can add \".\" in each possible position, and check the integer part and decimal part respectively\\n        for (int i = 1; i < s.length(); ++i) {\\n            if (checkInteger(s.substring(0, i)) && checkDecimal(s.substring(i))) {\\n                res.add(s.substring(0, i) + \".\" + s.substring(i));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n\\t// integer part shouldn\\'t have leading zero, except \"0\" itself\\n    private boolean checkInteger(String s) {\\n        return !s.startsWith(\"0\") || s.equals(\"0\");\\n    }\\n\\t\\n    // decimal part shouldn\\'t have tailing zero\\n    private boolean checkDecimal(String s) {\\n        return !s.endsWith(\"0\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n\\t    // delete \"(\" and \")\" in the given string\\n        s = s.substring(1, s.length() - 1);\\n        List<String> res = new ArrayList<>();\\n        for (int i = 1; i < s.length(); ++i) {\\n\\t\\t    // split the given string into two parts:\\n\\t\\t\\t// - left part includes all possible x\\n\\t\\t\\t// - right part includes all possible y\\n            String xString = s.substring(0, i);\\n            String yString = s.substring(i);\\n\\t\\t\\t// what we need to do is to find all valid coordinates in each parts\\n            List<String> validX = validCoordinates(xString);\\n            List<String> validY = validCoordinates(yString);\\n\\t\\t\\t// once we get all possible x and y, we just combine them one by one\\n            for (String x : validX) {\\n                for (String y : validY) {\\n                    res.add(\"(\" + x + \", \" + y + \")\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private List<String> validCoordinates(String s) {\\n        List<String> res = new ArrayList<String>();\\n\\t    // firstly we can regard the whole string as an integer and check whether it is valid or not\\n        if (checkInteger(s)) {\\n            res.add(s);\\n        }\\n\\t\\t// then we can add \".\" in each possible position, and check the integer part and decimal part respectively\\n        for (int i = 1; i < s.length(); ++i) {\\n            if (checkInteger(s.substring(0, i)) && checkDecimal(s.substring(i))) {\\n                res.add(s.substring(0, i) + \".\" + s.substring(i));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n\\t// integer part shouldn\\'t have leading zero, except \"0\" itself\\n    private boolean checkInteger(String s) {\\n        return !s.startsWith(\"0\") || s.equals(\"0\");\\n    }\\n\\t\\n    // decimal part shouldn\\'t have tailing zero\\n    private boolean checkDecimal(String s) {\\n        return !s.endsWith(\"0\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043904,
                "title": "python",
                "content": "\\n    def dfs(self, s):\\n        if len(s) == 1:\\n            return [s]\\n        \\n        ans = [] if s.startswith(\"0\") else [s]\\n        \\n        if s.endswith(\"0\"):\\n            return ans\\n        \\n        for i in range(1, len(s)):\\n            if s[:i].startswith(\"0\") and len(s[:i]) > 1:\\n                break\\n            \\n            ans.append(s[:i] + \".\" + s[i:])\\n            \\n        return ans\\n    \\n    def ambiguousCoordinates(self, s):\\n        s, res = s[1:-1], []\\n        \\n        for i in range(1,len(s)):\\n            for x in self.dfs(s[:i]):\\n                for y in self.dfs(s[i:]):\\n                    res.append(\"(\" + x + \", \" + y + \")\")\\n                \\n        return res",
                "solutionTags": [],
                "code": "\\n    def dfs(self, s):\\n        if len(s) == 1:\\n            return [s]\\n        \\n        ans = [] if s.startswith(\"0\") else [s]\\n        \\n        if s.endswith(\"0\"):\\n            return ans\\n        \\n        for i in range(1, len(s)):\\n            if s[:i].startswith(\"0\") and len(s[:i]) > 1:\\n                break\\n            \\n            ans.append(s[:i] + \".\" + s[i:])\\n            \\n        return ans\\n    \\n    def ambiguousCoordinates(self, s):\\n        s, res = s[1:-1], []\\n        \\n        for i in range(1,len(s)):\\n            for x in self.dfs(s[:i]):\\n                for y in self.dfs(s[i:]):\\n                    res.append(\"(\" + x + \", \" + y + \")\")\\n                \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2041470,
                "title": "python-straight-forward-solution",
                "content": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        # Extract number \\n        orig = re.findall(\"([0-9]+)\", s)[0]\\n        output = []\\n        # Iterrate trying to split the number to two by `index` (put comma) \\n        for index in range(len(orig)-1):            \\n            result = [None]*2                                                \\n            d1, d2 = orig[:index+1], orig[index+1:]            \\n            # Try to put dot in 1st digit\\n            for x in range(len(d1)):\\n                if x > 0 and d1[0] == \\'0\\':\\n                    continue\\n                if x == len(d1)-1:\\n                    result[0] = d1\\n                else:\\n                    if d1[x+1:][-1] == \"0\":\\n                        continue\\n                    result[0] = f\"{d1[:x+1]}.{d1[x+1:]}\"\\n                # Try to put dot in 2nd digit\\n                for y in range(len(d2)):\\n                    if y > 0 and d2[0] == \\'0\\':\\n                        continue\\n                    if y == len(d2)-1:\\n                        result[1] = d2\\n                    else:\\n                        if d2[y+1:][-1] == \"0\":\\n                            continue\\n                        result[1] = f\"{d2[:y+1]}.{d2[y+1:]}\"\\n\\n                    output.append(f\"({result[0]}, {result[1]})\")\\n            \\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        # Extract number \\n        orig = re.findall(\"([0-9]+)\", s)[0]\\n        output = []\\n        # Iterrate trying to split the number to two by `index` (put comma) \\n        for index in range(len(orig)-1):            \\n            result = [None]*2                                                \\n            d1, d2 = orig[:index+1], orig[index+1:]            \\n            # Try to put dot in 1st digit\\n            for x in range(len(d1)):\\n                if x > 0 and d1[0] == \\'0\\':\\n                    continue\\n                if x == len(d1)-1:\\n                    result[0] = d1\\n                else:\\n                    if d1[x+1:][-1] == \"0\":\\n                        continue\\n                    result[0] = f\"{d1[:x+1]}.{d1[x+1:]}\"\\n                # Try to put dot in 2nd digit\\n                for y in range(len(d2)):\\n                    if y > 0 and d2[0] == \\'0\\':\\n                        continue\\n                    if y == len(d2)-1:\\n                        result[1] = d2\\n                    else:\\n                        if d2[y+1:][-1] == \"0\":\\n                            continue\\n                        result[1] = f\"{d2[:y+1]}.{d2[y+1:]}\"\\n\\n                    output.append(f\"({result[0]}, {result[1]})\")\\n            \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032430,
                "title": "python-soln",
                "content": "finally, after six attempts\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        l=[]\\n        s=s[1:-1]\\n        for i in range(0,len(s)-1):\\n            \\n            l.append([s[:i+1],s[i+1:]])\\n            \\n        print(l)\\n        res=[]\\n        for x in l:\\n            \\n            a=x[0]\\n            b=x[1]\\n            \\n            l1=[]\\n            if (len(a)>=2 and a.count(\\'0\\')==len(a)) or (len(b)>=2 and b.count(\\'0\\')==len(b)):\\n                continue\\n            \\n            \\n            if a[0]==\\'0\\':\\n                if len(a)==1:\\n                    l1.append(a)\\n                else:\\n                    if a[1:][-1]!=\\'0\\':\\n                        l1.append(a[0]+\\'.\\'+a[1:])\\n            else:\\n                \\n                l1.append(a)\\n                \\n                for i in range(len(a)-1):\\n                    m=a[:i+1]\\n                    n=a[i+1:]\\n                    \\n                    if n.count(\\'0\\')==len(n):\\n                        \\n                        continue\\n                    if n[-1]==\\'0\\':\\n                        continue\\n                    \\n                    else:\\n                        l1.append(m+\\'.\\'+n)\\n                    \\n            \\n            l2=[]\\n            \\n            \\n            if b[0]==\\'0\\':\\n                if len(b)==1:\\n                    l2.append(b)\\n                else:\\n                    if b[1:][-1]!=\\'0\\':\\n                        l2.append(b[0]+\\'.\\'+b[1:])\\n                    \\n            \\n            else:\\n                \\n                l2.append(b)\\n                \\n                for i in range(len(b)-1):\\n                    m=b[:i+1]\\n                    n=b[i+1:]\\n                    #print(n)\\n                    if n.count(\\'0\\')==len(n):\\n                        continue\\n                    elif n[-1]==\\'0\\':\\n                        continue\\n                    else:\\n                        l2.append(m+\\'.\\'+n)\\n            for i in l1:\\n                for j in l2:\\n                    \\n                    x=\"(\"+i+\\', \\'+j+\")\"\\n                    res.append(x)\\n        return res\\n            \\n                \\n            \\n                \\n            \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        l=[]\\n        s=s[1:-1]\\n        for i in range(0,len(s)-1):\\n            \\n            l.append([s[:i+1],s[i+1:]])\\n            \\n        print(l)\\n        res=[]\\n        for x in l:\\n            \\n            a=x[0]\\n            b=x[1]\\n            \\n            l1=[]\\n            if (len(a)>=2 and a.count(\\'0\\')==len(a)) or (len(b)>=2 and b.count(\\'0\\')==len(b)):\\n                continue\\n            \\n            \\n            if a[0]==\\'0\\':\\n                if len(a)==1:\\n                    l1.append(a)\\n                else:\\n                    if a[1:][-1]!=\\'0\\':\\n                        l1.append(a[0]+\\'.\\'+a[1:])\\n            else:\\n                \\n                l1.append(a)\\n                \\n                for i in range(len(a)-1):\\n                    m=a[:i+1]\\n                    n=a[i+1:]\\n                    \\n                    if n.count(\\'0\\')==len(n):\\n                        \\n                        continue\\n                    if n[-1]==\\'0\\':\\n                        continue\\n                    \\n                    else:\\n                        l1.append(m+\\'.\\'+n)\\n                    \\n            \\n            l2=[]\\n            \\n            \\n            if b[0]==\\'0\\':\\n                if len(b)==1:\\n                    l2.append(b)\\n                else:\\n                    if b[1:][-1]!=\\'0\\':\\n                        l2.append(b[0]+\\'.\\'+b[1:])\\n                    \\n            \\n            else:\\n                \\n                l2.append(b)\\n                \\n                for i in range(len(b)-1):\\n                    m=b[:i+1]\\n                    n=b[i+1:]\\n                    #print(n)\\n                    if n.count(\\'0\\')==len(n):\\n                        continue\\n                    elif n[-1]==\\'0\\':\\n                        continue\\n                    else:\\n                        l2.append(m+\\'.\\'+n)\\n            for i in l1:\\n                for j in l2:\\n                    \\n                    x=\"(\"+i+\\', \\'+j+\")\"\\n                    res.append(x)\\n        return res\\n            \\n                \\n            \\n                \\n            \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918316,
                "title": "c-hints-to-self-try-solution",
                "content": "**Hints**\\n1. Generate all possible numbers by breaking the intial string in two parts.\\n2. Now since we have broken down the string, all we have to do now is place decimal points.\\n3. Generate all the pairs of unique numbers that we can build with or without placing decimal point.\\n4. Check whether both these generated no.s are valid or not. If  they are, you know what we\\'ve to do.\\n\\n**Personal Advice:** Now you must give it a try.\\n```\\nclass Solution {\\npublic:\\n    bool validOrNot(string &s, int j)\\n    {\\n        // no decimal point\\n        if(j == 0)\\n        {\\n            if(s[0] == \\'0\\' && s.size() > 1)\\n            {\\n                return false;\\n            }\\n        }\\n        // decimal at jth positon in s1\\n        else\\n        {\\n            if(s[s.size() - 1] == \\'0\\')\\n                    return false;\\n            if(s[0] == \\'0\\' && j != 1)\\n                return false;\\n            \\n        }\\n        return true;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1, s.size()-2);\\n        int n = s.size();\\n        vector<string> ans;\\n        for(int i=1; i<n; i++)\\n        {\\n            string first = s.substr(0, i);\\n            string second = s.substr(i);\\n            \\n            for(int j=0; j<first.size(); j++)\\n            {\\n                for(int k=0; k<second.size(); k++)\\n                {\\n                    bool x;\\n                    if(first.size() == 1)\\n                    {\\n                        x = true;\\n                    }\\n                    else \\n                    {\\n                        x = validOrNot(first, j);\\n                        if(!x) continue;\\n                    }\\n                    if(second.size() != 1)\\n                    {\\n                        x = x && validOrNot(second, k);\\n                    }\\n                    \\n                    if(x)\\n                    {\\n                        string s1, s2;\\n                        if(j)\\n                        {\\n                            s1 = first.substr(0, j) + \".\" + first.substr(j);\\n                        }\\n                        else\\n                        {\\n                            s1 = first;\\n                        }\\n                        if(k)\\n                        {\\n                            s2 = second.substr(0, k) + \".\" + second.substr(k);\\n                        }\\n                        else\\n                        {\\n                            s2 = second;\\n                        }\\n                        \\n                        ans.push_back(\"(\" + s1 + \", \" + s2 + \")\");\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validOrNot(string &s, int j)\\n    {\\n        // no decimal point\\n        if(j == 0)\\n        {\\n            if(s[0] == \\'0\\' && s.size() > 1)\\n            {\\n                return false;\\n            }\\n        }\\n        // decimal at jth positon in s1\\n        else\\n        {\\n            if(s[s.size() - 1] == \\'0\\')\\n                    return false;\\n            if(s[0] == \\'0\\' && j != 1)\\n                return false;\\n            \\n        }\\n        return true;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1, s.size()-2);\\n        int n = s.size();\\n        vector<string> ans;\\n        for(int i=1; i<n; i++)\\n        {\\n            string first = s.substr(0, i);\\n            string second = s.substr(i);\\n            \\n            for(int j=0; j<first.size(); j++)\\n            {\\n                for(int k=0; k<second.size(); k++)\\n                {\\n                    bool x;\\n                    if(first.size() == 1)\\n                    {\\n                        x = true;\\n                    }\\n                    else \\n                    {\\n                        x = validOrNot(first, j);\\n                        if(!x) continue;\\n                    }\\n                    if(second.size() != 1)\\n                    {\\n                        x = x && validOrNot(second, k);\\n                    }\\n                    \\n                    if(x)\\n                    {\\n                        string s1, s2;\\n                        if(j)\\n                        {\\n                            s1 = first.substr(0, j) + \".\" + first.substr(j);\\n                        }\\n                        else\\n                        {\\n                            s1 = first;\\n                        }\\n                        if(k)\\n                        {\\n                            s2 = second.substr(0, k) + \".\" + second.substr(k);\\n                        }\\n                        else\\n                        {\\n                            s2 = second;\\n                        }\\n                        \\n                        ans.push_back(\"(\" + s1 + \", \" + s2 + \")\");\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890035,
                "title": "is-this-even-backtracking",
                "content": "I don\\'t think this problem should be labelled backtracking because the solution doesn\\'t involve any sort of DFS, it\\'s just a cartesian product.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1828614,
                "title": "c-combination",
                "content": "**Idea:**\\nFirstly divide string into two parts **s1** and **s2** such that s1+s2=`s`. Generate all possible no. from s1 and s2 , and try every combination of those no.  A number is valid fromed by the string if:\\n* size of string ==1\\n* first and last character of string should not be `\\'0\\'` simultaneously.\\n* If first character == `\\'0\\'` or last character == `\\'0\\'` , then there is only one possible number\\n* else generate all possibility by putting `\\'.\\'` at every position\\n```\\nclass Solution {\\npublic:\\n    void find(string s,int in,int st,vector<string> &nums){\\n        if(st-in==0){\\n            nums.push_back(string(1,s[in])); return;\\n        }\\n        if(s[in]==\\'0\\' && s[st]==\\'0\\') return;\\n        if(s[st]==\\'0\\'){\\n            nums.push_back(s.substr(in,st-in+1)); return;\\n        }\\n        if(s[in]==\\'0\\'){\\n            string re = \"0.\"+s.substr(in+1,st-in);\\n            nums.push_back(re);\\n            return;\\n        }\\n        for(int i = in; i<st;++i){\\n            string re = s.substr(in,i-in+1)+\".\"+s.substr(i+1,st-i);\\n            nums.push_back(re);\\n        }\\n        nums.push_back(s.substr(in,st-in+1));\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string> re;\\n        s = s.substr(1,s.size()-2);\\n        for(int i = 1; i<s.size();++i){\\n            vector<string> left,right;\\n            find(s,0,i-1,left); \\n            find(s,i,s.size()-1,right);\\n            if(left.size() && right.size()){\\n                for(int j = 0; j<left.size();++j){\\n                    for(int k = 0; k<right.size();++k){\\n                        re.push_back(\"(\"+left[j]+\", \"+right[k]+\")\");\\n                    }\\n                }\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void find(string s,int in,int st,vector<string> &nums){\\n        if(st-in==0){\\n            nums.push_back(string(1,s[in])); return;\\n        }\\n        if(s[in]==\\'0\\' && s[st]==\\'0\\') return;\\n        if(s[st]==\\'0\\'){\\n            nums.push_back(s.substr(in,st-in+1)); return;\\n        }\\n        if(s[in]==\\'0\\'){\\n            string re = \"0.\"+s.substr(in+1,st-in);\\n            nums.push_back(re);\\n            return;\\n        }\\n        for(int i = in; i<st;++i){\\n            string re = s.substr(in,i-in+1)+\".\"+s.substr(i+1,st-i);\\n            nums.push_back(re);\\n        }\\n        nums.push_back(s.substr(in,st-in+1));\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string> re;\\n        s = s.substr(1,s.size()-2);\\n        for(int i = 1; i<s.size();++i){\\n            vector<string> left,right;\\n            find(s,0,i-1,left); \\n            find(s,i,s.size()-1,right);\\n            if(left.size() && right.size()){\\n                for(int j = 0; j<left.size();++j){\\n                    for(int k = 0; k<right.size();++k){\\n                        re.push_back(\"(\"+left[j]+\", \"+right[k]+\")\");\\n                    }\\n                }\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776337,
                "title": "c-solution-dfs-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1,s.length()-2);\\n        int size = s.length();\\n        vector<string> ans;\\n        for (int split=1; split<size; split++){\\n            for(auto first: generate(0, split-1, s)){\\n                for(auto second: generate(split,size-1, s)){\\n                    ans.push_back(\"(\"+first+\",\"+\" \"+second+\")\");\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<string> generate(int start, int end, string& s){\\n        if(s[start]==\\'0\\'){\\n            if(end==start) return{\"0\"};\\n            else if (s[end]==\\'0\\') return{};\\n            else{\\n                return{\"0.\"+s.substr(start+1, end-start)};\\n            }\\n        }\\n        string base = s.substr(start, 1+end-start);\\n        vector<string> res = {base};\\n        if(s[end]!=\\'0\\'){\\n            for(int i=1; i<base.length(); i++){\\n                res.push_back(base.substr(0,i)+\".\"+base.substr(i));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1,s.length()-2);\\n        int size = s.length();\\n        vector<string> ans;\\n        for (int split=1; split<size; split++){\\n            for(auto first: generate(0, split-1, s)){\\n                for(auto second: generate(split,size-1, s)){\\n                    ans.push_back(\"(\"+first+\",\"+\" \"+second+\")\");\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<string> generate(int start, int end, string& s){\\n        if(s[start]==\\'0\\'){\\n            if(end==start) return{\"0\"};\\n            else if (s[end]==\\'0\\') return{};\\n            else{\\n                return{\"0.\"+s.substr(start+1, end-start)};\\n            }\\n        }\\n        string base = s.substr(start, 1+end-start);\\n        vector<string> res = {base};\\n        if(s[end]!=\\'0\\'){\\n            for(int i=1; i<base.length(); i++){\\n                res.push_back(base.substr(0,i)+\".\"+base.substr(i));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775154,
                "title": "java-solution-with-comments-faster-then-52-25",
                "content": "Ret is a list for storing strings after putting \",\" (comma) in them after that we put decimals in correct places \".\" !\\n\\n```\\nclass Solution {\\n    public List<String> ret;\\n    public List<String> ans;\\n    public List<String> ambiguousCoordinates(String s) {\\n        ret=new ArrayList<>();\\n        ans=new ArrayList<>();\\n        String start=s.substring(0,2);\\n        util(s,1);\\n        fun();\\n        return ans;\\n    }\\n    \\n    //putting comma\\n    void util(String s,int idx) {\\n        if(idx==s.length()-2) {\\n            return;\\n        }\\n        \\n        String ns=s.substring(0,idx+1)+\", \"+s.substring(idx+1);\\n        ret.add(ns);\\n        util(s,idx+1);\\n    }\\n    \\n    //helper function for puting decimals after comma\\n    void fun() {\\n        for(String s:ret) {\\n            int cIndex=0;\\n            for(int i=0;i<s.length();i++) {\\n                if(s.charAt(i)==\\',\\') {\\n                    cIndex=i;\\n                    break;\\n                }\\n            }\\n            String a=s.substring(1,cIndex);\\n            String b=s.substring(cIndex+2,s.length()-1);\\n            List<String> n1=dot(a);\\n            List<String> n2=dot(b);\\n            if(n1==null || n2==null) { //invalid strings\\n                continue;\\n            }else { //valid strings\\n                for(String fir:n1) {\\n                    for(String sec:n2) {\\n                        ans.add(\"(\"+fir+\", \"+sec+\")\");\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    //putting decimal point\\n    List<String> dot(String n) {\\n        List<String> li=new ArrayList<>();\\n        if(n.length()==1) {\\n            li.add(n);\\n        }else {\\n            \\n            //just checking for first and last zeroes and making conditions accordingly\\n\\n            if(n.charAt(n.length()-1)==\\'0\\') {\\n                if(n.charAt(0)==\\'0\\') {\\n                    return null;\\n                }else {\\n                    li.add(n);\\n                }\\n            }else if(n.charAt(0)==\\'0\\') {\\n                li.add(\"0.\"+n.substring(1));\\n            }else {\\n                for(int i=0;i<n.length()-1;i++) {\\n                    li.add(n.substring(0,i+1)+\".\"+n.substring(i+1));\\n                }\\n                li.add(n);  //without any decimal\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> ret;\\n    public List<String> ans;\\n    public List<String> ambiguousCoordinates(String s) {\\n        ret=new ArrayList<>();\\n        ans=new ArrayList<>();\\n        String start=s.substring(0,2);\\n        util(s,1);\\n        fun();\\n        return ans;\\n    }\\n    \\n    //putting comma\\n    void util(String s,int idx) {\\n        if(idx==s.length()-2) {\\n            return;\\n        }\\n        \\n        String ns=s.substring(0,idx+1)+\", \"+s.substring(idx+1);\\n        ret.add(ns);\\n        util(s,idx+1);\\n    }\\n    \\n    //helper function for puting decimals after comma\\n    void fun() {\\n        for(String s:ret) {\\n            int cIndex=0;\\n            for(int i=0;i<s.length();i++) {\\n                if(s.charAt(i)==\\',\\') {\\n                    cIndex=i;\\n                    break;\\n                }\\n            }\\n            String a=s.substring(1,cIndex);\\n            String b=s.substring(cIndex+2,s.length()-1);\\n            List<String> n1=dot(a);\\n            List<String> n2=dot(b);\\n            if(n1==null || n2==null) { //invalid strings\\n                continue;\\n            }else { //valid strings\\n                for(String fir:n1) {\\n                    for(String sec:n2) {\\n                        ans.add(\"(\"+fir+\", \"+sec+\")\");\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    //putting decimal point\\n    List<String> dot(String n) {\\n        List<String> li=new ArrayList<>();\\n        if(n.length()==1) {\\n            li.add(n);\\n        }else {\\n            \\n            //just checking for first and last zeroes and making conditions accordingly\\n\\n            if(n.charAt(n.length()-1)==\\'0\\') {\\n                if(n.charAt(0)==\\'0\\') {\\n                    return null;\\n                }else {\\n                    li.add(n);\\n                }\\n            }else if(n.charAt(0)==\\'0\\') {\\n                li.add(\"0.\"+n.substring(1));\\n            }else {\\n                for(int i=0;i<n.length()-1;i++) {\\n                    li.add(n.substring(0,i+1)+\".\"+n.substring(i+1));\\n                }\\n                li.add(n);  //without any decimal\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745242,
                "title": "python-with-comments-97-time-98-memory",
                "content": "python. DFS with MAX_DEPTH of 2 and early stops\\n\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\'\\'\\'\\n        input: S - string\\n        output: all_possible_strings - list\\n        \\'\\'\\'\\n        # write your code here\\n        all_possible_strings = []\\n        string_two_numbers = s[1:len(s)-1]\\n        length = len(string_two_numbers)\\n        for i in range(length - 1):\\n            # split numbers, the same as add comma and space\\n            number_str1 = string_two_numbers[:i+1]\\n            number_str2 = string_two_numbers[i+1:]\\n            # add decimal point if necessary\\n            number_str1_list = self.get_valid_number(number_str1)\\n            if number_str1_list:\\n                number_str2_list = self.get_valid_number(number_str2)\\n                if number_str2_list:\\n                    for str1 in number_str1_list:\\n                        for str2 in number_str2_list:\\n                            solution = \"\".join([\"(\", str1, \", \", str2, \")\"])\\n                            all_possible_strings.append(solution)\\n        return all_possible_strings\\n\\n    def get_valid_number(self, number_str):\\n        number_str_list = []\\n        # check without decimal\\n        if number_str[0] != \\'0\\' or len(number_str) == 1:\\n            number_str_list.append(number_str)\\n        # check add one decimal\\n        # if ending with 0, remove\\n        if number_str[-1] != \\'0\\':\\n            # not ending with \\'0\\'\\n            if number_str[0] == \\'0\\':\\n                # starting with 0, decimal must be next\\n                number_str_list.append(\\'0\\'+\\'.\\' + number_str[1:])\\n            else:\\n                # starting with non-zero, ending with non-zero\\n                for insert_index in range(1, len(number_str)):\\n                    number_str_list.append(number_str[:insert_index] +\\'.\\' + number_str[insert_index:])\\n        return number_str_list\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\'\\'\\'\\n        input: S - string\\n        output: all_possible_strings - list\\n        \\'\\'\\'\\n        # write your code here\\n        all_possible_strings = []\\n        string_two_numbers = s[1:len(s)-1]\\n        length = len(string_two_numbers)\\n        for i in range(length - 1):\\n            # split numbers, the same as add comma and space\\n            number_str1 = string_two_numbers[:i+1]\\n            number_str2 = string_two_numbers[i+1:]\\n            # add decimal point if necessary\\n            number_str1_list = self.get_valid_number(number_str1)\\n            if number_str1_list:\\n                number_str2_list = self.get_valid_number(number_str2)\\n                if number_str2_list:\\n                    for str1 in number_str1_list:\\n                        for str2 in number_str2_list:\\n                            solution = \"\".join([\"(\", str1, \", \", str2, \")\"])\\n                            all_possible_strings.append(solution)\\n        return all_possible_strings\\n\\n    def get_valid_number(self, number_str):\\n        number_str_list = []\\n        # check without decimal\\n        if number_str[0] != \\'0\\' or len(number_str) == 1:\\n            number_str_list.append(number_str)\\n        # check add one decimal\\n        # if ending with 0, remove\\n        if number_str[-1] != \\'0\\':\\n            # not ending with \\'0\\'\\n            if number_str[0] == \\'0\\':\\n                # starting with 0, decimal must be next\\n                number_str_list.append(\\'0\\'+\\'.\\' + number_str[1:])\\n            else:\\n                # starting with non-zero, ending with non-zero\\n                for insert_index in range(1, len(number_str)):\\n                    number_str_list.append(number_str[:insert_index] +\\'.\\' + number_str[insert_index:])\\n        return number_str_list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726226,
                "title": "easy-peasy-backtracking-solution-c",
                "content": "class Solution {\\npublic:\\n\\n    void find(vector<string> &res, string s, string str, bool dot, bool valid, int i)\\n    {\\n        if(i==s.length())\\n        {\\n            if(dot)\\n            {\\n                if(str[str.length()-1]==\\'0\\') //this conditions helps with avoiding cases like 5.30\\n                    return;\\n            }\\n            if(valid || !dot)\\n                res.push_back(str);\\n            return;\\n        }\\n        if(str.length()) //if the string is not empty\\n        {\\n            if(dot)\\n            {\\n                str+=s[i];\\n                if(s[i]!=\\'0\\') //if there is a positive number after \\'.\\', it is valid except for 1 case which we are handling in base conditon\\n                    find(res,s,str,dot,true,i+1);\\n                else\\n                    find(res,s,str,dot,valid,i+1); \\n                str.pop_back();\\n            }\\n            else\\n            {   // Case 1-> either we add another number\\n                if(str[0]!=\\'0\\') //if have a non decimal number, and we are trying to add another number, we only do it if there are no leading zeros\\n                {\\n                    str+=s[i];\\n                    find(res,s,str,dot,valid,i+1);\\n                    str.pop_back();\\n                }\\n                str+=\".\"; //Case 2-> or we add a dot\\n                find(res,s,str,true,valid,i); //We call the function on the same index again so as to add ith digit after \\'.\\' \\n                str.pop_back();\\n            }\\n        } \\n        else //if the string is empty\\n        {\\n            str+=s[i]; //this is our first number\\n            find(res,s,str,dot,valid,i+1);\\n        }\\n    }\\n    \\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string> res;\\n        for(int i=1;i<s.length()-2;i++) //calling function on all possible lengths of both the coordinates.\\n        {                               // Lets say we have 1234. We will call function on {1,234}, {12,34} & {123,4}\\n            vector<string> arr;\\n            find(arr,s.substr(1,i),\"\",false,false,0); //after the function call, arr stores all possible numbers of first coordinate\\n            vector<string> s1=arr;\\n            arr.clear();\\n            find(arr,s.substr(i+1,s.length()-i-2),\"\",false,false,0);//after the function call, arr stores all possible numbers of second coordinate\\n            vector<string> s2=arr;\\n            arr.clear();\\n            for(auto x : s1) // once we have all possible combinations of coordinates we can just combine all sets of coordinates with each other\\n            {\\n                for(auto y : s2)\\n                {\\n                    res.push_back(\"(\"+x+\", \"+y+\")\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    void find(vector<string> &res, string s, string str, bool dot, bool valid, int i)\\n    {\\n        if(i==s.length())\\n        {\\n            if(dot)\\n            {\\n                if(str[str.length()-1]==\\'0\\') //this conditions helps with avoiding cases like 5.30\\n                    return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1507086,
                "title": "your-code-hurt-my-eyes-clean-python-code",
                "content": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s):\\n        # remove paranthesis\\n        s = s[1:-1]\\n        res = []\\n        # split into parts for (x, y)\\n        for x, y in self.partition(s):\\n            x_s = self.coordinates(x)\\n            y_s = self.coordinates(y)\\n\\n            # because x + y == s, we can use all possible values of x \\n            # and y independently, so we take the cartesian product\\n            for x in x_s:\\n                for y in y_s:\\n                    res.append(f\"({x}, {y})\") # format in the required form\\n        return res\\n\\n    def coordinates(self, s):\\n\\t  \"\"\"\\n\\t  A coordinate is either an integral number or\\n\\t  a decimal number with integral and decimal parts\\n\\t  \"\"\"\\n        # check if the whole string* can be an integral coordinate\\n\\t\\t# *because it is not contained in partitions\\n        vals = [s] if self.integral(s) else []\\n\\t\\t\\n        # add coordinates with valid integral and decimal part\\n        for i, d in self.partition(s):\\n            if self.integral(i) and self.decimal(d):\\n                vals.append(f\"{i}.{d}\")\\n        return vals\\n\\n    def integral(self, s):\\n        \"\"\"\\n        An integral part in the coordinates is not allowed \\n\\t\\tto have a leading zero, except when it is 0\\n        \"\"\"\\n        return s[0] != \"0\" or s == \"0\"\\n\\n    def decimal(self, s):\\n        \"\"\"\\n        A decimal part in the coordinates is not allowed \\n\\t\\tto end with a zero \\n        \"\"\"\\n        return s[-1] != \"0\"\\n\\n    def partition(self, s):\\n        \"\"\"\\n        return a generator that splits the string \\n\\t\\tin two-parts of lengths (1, n-1), (2, n-2),... \\n        \"\"\"\\n        return ( (s[0:i], s[i:]) for i in range(1, len(s)) )\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s):\\n        # remove paranthesis\\n        s = s[1:-1]\\n        res = []\\n        # split into parts for (x, y)\\n        for x, y in self.partition(s):\\n            x_s = self.coordinates(x)\\n            y_s = self.coordinates(y)\\n\\n            # because x + y == s, we can use all possible values of x \\n            # and y independently, so we take the cartesian product\\n            for x in x_s:\\n                for y in y_s:\\n                    res.append(f\"({x}, {y})\") # format in the required form\\n        return res\\n\\n    def coordinates(self, s):\\n\\t  \"\"\"\\n\\t  A coordinate is either an integral number or\\n\\t  a decimal number with integral and decimal parts\\n\\t  \"\"\"\\n        # check if the whole string* can be an integral coordinate\\n\\t\\t# *because it is not contained in partitions\\n        vals = [s] if self.integral(s) else []\\n\\t\\t\\n        # add coordinates with valid integral and decimal part\\n        for i, d in self.partition(s):\\n            if self.integral(i) and self.decimal(d):\\n                vals.append(f\"{i}.{d}\")\\n        return vals\\n\\n    def integral(self, s):\\n        \"\"\"\\n        An integral part in the coordinates is not allowed \\n\\t\\tto have a leading zero, except when it is 0\\n        \"\"\"\\n        return s[0] != \"0\" or s == \"0\"\\n\\n    def decimal(self, s):\\n        \"\"\"\\n        A decimal part in the coordinates is not allowed \\n\\t\\tto end with a zero \\n        \"\"\"\\n        return s[-1] != \"0\"\\n\\n    def partition(self, s):\\n        \"\"\"\\n        return a generator that splits the string \\n\\t\\tin two-parts of lengths (1, n-1), (2, n-2),... \\n        \"\"\"\\n        return ( (s[0:i], s[i:]) for i in range(1, len(s)) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480758,
                "title": "using-itertools-product-81-speed",
                "content": "Runtime: 44 ms, faster than 81.05% of Python3 online submissions for Ambiguous Coordinates.\\nMemory Usage: 14.4 MB, less than 18.95% of Python3 online submissions for Ambiguous Coordinates.\\n```\\nclass Solution:\\n\\n    def generate_nums(self, s: str) -> List[str]:\\n        if len(s) == 1:\\n            return [s]\\n        ans = [] if s.startswith(\"0\") else [s]\\n        if s.endswith(\"0\"):\\n            return ans\\n        for i in range(1, len(s)):\\n            a, b = s[:i], s[i:]\\n            if a.startswith(\"0\") and len(a) > 1:\\n                break\\n            ans.append(f\"{a}.{b}\")\\n        return ans\\n\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        ans = []\\n        for i in range(1, len(s)):\\n            a, b = s[:i], s[i:]\\n            for x, y in product(self.generate_nums(a), self.generate_nums(b)):\\n                ans.append(f\"({x}, {y})\")\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def generate_nums(self, s: str) -> List[str]:\\n        if len(s) == 1:\\n            return [s]\\n        ans = [] if s.startswith(\"0\") else [s]\\n        if s.endswith(\"0\"):\\n            return ans\\n        for i in range(1, len(s)):\\n            a, b = s[:i], s[i:]\\n            if a.startswith(\"0\") and len(a) > 1:\\n                break\\n            ans.append(f\"{a}.{b}\")\\n        return ans\\n\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        ans = []\\n        for i in range(1, len(s)):\\n            a, b = s[:i], s[i:]\\n            for x, y in product(self.generate_nums(a), self.generate_nums(b)):\\n                ans.append(f\"({x}, {y})\")\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448698,
                "title": "c-recursion",
                "content": "```\\npublic class Solution \\n{\\n    public IList<string> AmbiguousCoordinates(string s) \\n    {\\n        var output = new List<string>();\\n        \\n        for (int i = 1; i < s.Length - 2; i++)\\n        {\\n            var length = (i - 1) + 1;\\n            var x = s.Substring(1, length);\\n            var y = s.Substring(length + 1, (s.Length - 2) - length);\\n            \\n            var validXs = GetValidNumbers(x);\\n            var validYs = GetValidNumbers(y);\\n            \\n            foreach (string validX in validXs)\\n            {\\n                foreach (string validY in validYs)\\n                {\\n                    output.Add($\"({validX}, {validY})\");\\n                }                \\n            }            \\n        }\\n        \\n        return output;\\n    }\\n    \\n    private List<string> GetValidNumbers(string s)\\n    {\\n        var validNumbers = new List<string>();              \\n        \\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            var length = (i - 0) + 1;\\n            var x = s.Substring(0, length);\\n            var y = s.Substring(length, s.Length - length);\\n\\n            //only add \\'0\\' or numbers that don\\'t start and end with 0\\n            if ((!x.StartsWith(\\'0\\') || x == \"0\") && !y.EndsWith(\\'0\\'))\\n            {\\n                //only add the period up to the 2nd to last char\\n                var period = (i < s.Length - 1) ? \".\" : string.Empty;\\n                \\n                validNumbers.Add($\"{x}{period}{y}\");\\n            }\\n        }\\n        \\n        return validNumbers;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public IList<string> AmbiguousCoordinates(string s) \\n    {\\n        var output = new List<string>();\\n        \\n        for (int i = 1; i < s.Length - 2; i++)\\n        {\\n            var length = (i - 1) + 1;\\n            var x = s.Substring(1, length);\\n            var y = s.Substring(length + 1, (s.Length - 2) - length);\\n            \\n            var validXs = GetValidNumbers(x);\\n            var validYs = GetValidNumbers(y);\\n            \\n            foreach (string validX in validXs)\\n            {\\n                foreach (string validY in validYs)\\n                {\\n                    output.Add($\"({validX}, {validY})\");\\n                }                \\n            }            \\n        }\\n        \\n        return output;\\n    }\\n    \\n    private List<string> GetValidNumbers(string s)\\n    {\\n        var validNumbers = new List<string>();              \\n        \\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            var length = (i - 0) + 1;\\n            var x = s.Substring(0, length);\\n            var y = s.Substring(length, s.Length - length);\\n\\n            //only add \\'0\\' or numbers that don\\'t start and end with 0\\n            if ((!x.StartsWith(\\'0\\') || x == \"0\") && !y.EndsWith(\\'0\\'))\\n            {\\n                //only add the period up to the 2nd to last char\\n                var period = (i < s.Length - 1) ? \".\" : string.Empty;\\n                \\n                validNumbers.Add($\"{x}{period}{y}\");\\n            }\\n        }\\n        \\n        return validNumbers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1436178,
                "title": "lessons-from-this-problem-pseudocode",
                "content": "1. When I was  faced with this problem in a virtual contest, I knew I had to brute-force through it. There was no underlying optimization or algorithmic trick that would help. Also the constraints are a huge hint and the problem literally screams brute-force recursion.\\n2.  The second mental barrier were the nasty edge cases which actually made the problem difficult. I thought deeply about how you could handle all the edge cases iteratively and spent a lot of time perfecting it into code but it just got messier and messier.\\n3.  The trick was to use Interval based recursion and handle the edge cases in recursive fashion and not iteratively. This needed a smart observation that is already explained in detail in the top-voted solutions.\\n4.  I was so convinced that the iterative solution could work, that I failed to appreciate the aforementioned approach. In the recursive approach all the nasty edge cases take the form of just 5 simple base conditions.\\n------------------\\n\\n```\\nif(s.size() == 0) return {};\\nif(s.size() == 1) return s;\\nif(s == \"0XXX0\") return {};        // decimal point cant be added, all strings would be invalid.\\nif(s == \"0XXX\") return {0.XXX};    // only one string can be formed which is returned, rest would all be  invalid\\nif(s == \"XXX0\") return {XXX0}     // decimal point cannot be added, only the entire number as a whole is valid\\nreturn {X.XX, XX.X};             // If there are no leading or trailing zeros like (\"XXX\") we can simply assign \\n                                         //the decimal point at various places because all of them would be valid. \\n```",
                "solutionTags": [],
                "code": "```\\nif(s.size() == 0) return {};\\nif(s.size() == 1) return s;\\nif(s == \"0XXX0\") return {};        // decimal point cant be added, all strings would be invalid.\\nif(s == \"0XXX\") return {0.XXX};    // only one string can be formed which is returned, rest would all be  invalid\\nif(s == \"XXX0\") return {XXX0}     // decimal point cannot be added, only the entire number as a whole is valid\\nreturn {X.XX, XX.X};             // If there are no leading or trailing zeros like (\"XXX\") we can simply assign \\n                                         //the decimal point at various places because all of them would be valid. \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1435995,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> res = new ArrayList<>();\\n        for(int i = 2; i < s.length()-1; i++) {\\n            List<String> left = helper(s.substring(1, i));\\n            List<String> right = helper(s.substring(i, s.length()-1));\\n            if(left.size() == 0 || right.size() == 0) {\\n                continue;\\n            } \\n            for(String l : left) {\\n                for(String r : right) {\\n                    String curr = \"(\" + l + \", \" + r + \")\";\\n                    res.add(curr);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public List<String> helper(String s) {\\n        List<String> res = new ArrayList<>();\\n        if(s.length() == 1 || !s.startsWith(\"0\")) {\\n            res.add(s);\\n        }\\n        for(int i = 1; i < s.length(); i++) {\\n            String curr = s.substring(0, i) + \".\" + s.substring(i, s.length());\\n            if(curr.endsWith(\"0\") || (curr.startsWith(\"0\") && curr.charAt(1) != \\'.\\')) {\\n                continue;\\n            }\\n            res.add(curr);\\n        }\\n        return res;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> res = new ArrayList<>();\\n        for(int i = 2; i < s.length()-1; i++) {\\n            List<String> left = helper(s.substring(1, i));\\n            List<String> right = helper(s.substring(i, s.length()-1));\\n            if(left.size() == 0 || right.size() == 0) {\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1433622,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> result = new ArrayList<>();\\n        s = s.substring(1,s.length()-1);\\n        for(int i = 0; i < s.length()-1; i++)\\n        {\\n            String first = s.substring(0, i+1);\\n            String second = s.substring(i+1,s.length());\\n            List<String> firstCombs = getValidCombs(first);\\n            List<String> secondCombs = getValidCombs(second);\\n            for(int j = 0; j < firstCombs.size(); j++)\\n            {\\n                for(int k = 0; k < secondCombs.size(); k++)\\n                {\\n                    result.add(\"(\"+firstCombs.get(j)+\", \"+secondCombs.get(k)+\")\");\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    List<String> getValidCombs(String cordinate)\\n    {\\n        List<String> combs = new ArrayList<>();\\n        if(cordinate.length() > 1 && cordinate.startsWith(\"0\"))\\n        {\\n            if(cordinate.endsWith(\"0\")) return combs;\\n            combs.add(cordinate.substring(0,1)+\".\"+cordinate.substring(1,cordinate.length()));    \\n            return combs;\\n        }\\n        \\n        if(cordinate.length() == 1)\\n        {\\n            combs.add(cordinate);\\n            return combs;\\n        }\\n        \\n        combs.add(cordinate);\\n        for(int i = 1; i < cordinate.length(); i++)\\n        {\\n            String before = cordinate.substring(0,i);\\n            String after = cordinate.substring(i,cordinate.length());\\n            if(after.charAt(after.length()-1) == \\'0\\') continue;\\n            \\n            String total = (before.length() >= 1) ? before+\".\"+after : after;\\n            combs.add(total);\\n        }\\n        \\n        return combs;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> result = new ArrayList<>();\\n        s = s.substring(1,s.length()-1);\\n        for(int i = 0; i < s.length()-1; i++)\\n        {\\n            String first = s.substring(0, i+1);\\n            String second = s.substring(i+1,s.length());\\n            List<String> firstCombs = getValidCombs(first);\\n            List<String> secondCombs = getValidCombs(second);\\n            for(int j = 0; j < firstCombs.size(); j++)\\n            {\\n                for(int k = 0; k < secondCombs.size(); k++)\\n                {\\n                    result.add(\"(\"+firstCombs.get(j)+\", \"+secondCombs.get(k)+\")\");\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1382165,
                "title": "go-double-100",
                "content": "```\\nfunc ambiguousCoordinates(s string) []string {\\n\\tans, prefix, suffix := []string{}, []string{}, []string{}\\n\\tbuff := \"\"\\n\\tstr := s[1 : len(s)-1]\\n\\tlength := len(str)\\n\\n\\tif length == 2 {\\n\\t\\tbuff = \"(\" + string(str[0]) + \", \" + string(str[1]) + \")\"\\n\\t\\tans = append(ans, buff)\\n\\t} else {\\n\\t\\tfor i := 1; i < length; i++ {\\n\\t\\t\\tprefix = addDot(str[:i])\\n\\t\\t\\tsuffix = addDot(str[i:])\\n\\n\\t\\t\\tfor j := 0; j < len(prefix); j++ {\\n\\t\\t\\t\\tfor k := 0; k < len(suffix); k++ {\\n\\t\\t\\t\\t\\tbuff = \"(\" + prefix[j] + \", \" + suffix[k] + \")\"\\n\\t\\t\\t\\t\\tans = append(ans, buff)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n\\nfunc addDot(str string) []string {\\n\\tans := []string{}\\n\\n\\tif checkNum(str, false, false) {\\n\\t\\tans = append(ans, str)\\n\\t}\\n\\n\\tfor i := 1; i < len(str); i++ {\\n\\t\\tbuff := str[0:i] + \".\" + str[i:]\\n\\t\\tif checkNum(buff, false, false) {\\n\\t\\t\\tans = append(ans, buff)\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n\\nfunc checkNum(s string, pre, after bool) bool {\\n\\tif len(s) == 1 && strings.Contains(s, \"0\") && pre && !after {\\n\\t\\treturn true\\n\\t}\\n\\n\\tif len(s) == 1 && strings.Contains(s, \"0\") && !pre && after {\\n\\t\\treturn false\\n\\t}\\n\\n\\tif !strings.Contains(s, \".\") && pre && !after {\\n\\t\\tfor i := len(s) - 1; i >= 0; i-- {\\n\\t\\t\\tif strings.ContainsAny(s[:i], \"123456789\") {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif strings.Contains(s[:i], \"0\") {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\n\\tif !strings.Contains(s, \".\") && !pre && after {\\n\\t\\tfor i := 0; i < len(s); i++ {\\n\\t\\t\\t// fmt.Println(s[i:])\\n\\t\\t\\tif strings.ContainsAny(s[i:], \"123456789\") {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif strings.Contains(s[i:], \"0\") {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif !pre && !after {\\n\\t\\tif strings.Contains(s, \".\") {\\n\\t\\t\\ti := strings.IndexByte(s, \\'.\\')\\n\\n\\t\\t\\tif checkNum(s[:i], true, false) && checkNum(s[i+1:], false, true) {\\n\\t\\t\\t\\tgoto end\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor i := len(s) - 1; i >= 0; i-- {\\n\\t\\t\\t\\tif strings.ContainsAny(s[:i], \"123456789\") {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif strings.Contains(s[:i], \"0\") {\\n\\t\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\nend:\\n\\treturn true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc ambiguousCoordinates(s string) []string {\\n\\tans, prefix, suffix := []string{}, []string{}, []string{}\\n\\tbuff := \"\"\\n\\tstr := s[1 : len(s)-1]\\n\\tlength := len(str)\\n\\n\\tif length == 2 {\\n\\t\\tbuff = \"(\" + string(str[0]) + \", \" + string(str[1]) + \")\"\\n\\t\\tans = append(ans, buff)\\n\\t} else {\\n\\t\\tfor i := 1; i < length; i++ {\\n\\t\\t\\tprefix = addDot(str[:i])\\n\\t\\t\\tsuffix = addDot(str[i:])\\n\\n\\t\\t\\tfor j := 0; j < len(prefix); j++ {\\n\\t\\t\\t\\tfor k := 0; k < len(suffix); k++ {\\n\\t\\t\\t\\t\\tbuff = \"(\" + prefix[j] + \", \" + suffix[k] + \")\"\\n\\t\\t\\t\\t\\tans = append(ans, buff)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n\\nfunc addDot(str string) []string {\\n\\tans := []string{}\\n\\n\\tif checkNum(str, false, false) {\\n\\t\\tans = append(ans, str)\\n\\t}\\n\\n\\tfor i := 1; i < len(str); i++ {\\n\\t\\tbuff := str[0:i] + \".\" + str[i:]\\n\\t\\tif checkNum(buff, false, false) {\\n\\t\\t\\tans = append(ans, buff)\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n\\nfunc checkNum(s string, pre, after bool) bool {\\n\\tif len(s) == 1 && strings.Contains(s, \"0\") && pre && !after {\\n\\t\\treturn true\\n\\t}\\n\\n\\tif len(s) == 1 && strings.Contains(s, \"0\") && !pre && after {\\n\\t\\treturn false\\n\\t}\\n\\n\\tif !strings.Contains(s, \".\") && pre && !after {\\n\\t\\tfor i := len(s) - 1; i >= 0; i-- {\\n\\t\\t\\tif strings.ContainsAny(s[:i], \"123456789\") {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif strings.Contains(s[:i], \"0\") {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\n\\tif !strings.Contains(s, \".\") && !pre && after {\\n\\t\\tfor i := 0; i < len(s); i++ {\\n\\t\\t\\t// fmt.Println(s[i:])\\n\\t\\t\\tif strings.ContainsAny(s[i:], \"123456789\") {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif strings.Contains(s[i:], \"0\") {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif !pre && !after {\\n\\t\\tif strings.Contains(s, \".\") {\\n\\t\\t\\ti := strings.IndexByte(s, \\'.\\')\\n\\n\\t\\t\\tif checkNum(s[:i], true, false) && checkNum(s[i+1:], false, true) {\\n\\t\\t\\t\\tgoto end\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor i := len(s) - 1; i >= 0; i-- {\\n\\t\\t\\t\\tif strings.ContainsAny(s[:i], \"123456789\") {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif strings.Contains(s[:i], \"0\") {\\n\\t\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\nend:\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1215760,
                "title": "93-time-55-space",
                "content": "```\\nclass Solution:\\n    \\n    def validate(self, s: str) -> bool:\\n        \\n        left_zero_count = 0\\n        \\n        if s[0] == \\'0\\' and s[1] != \\'.\\':\\n            return False\\n        \\n        if s[-1] == \\'0\\':\\n            return False\\n        \\n        return True\\n    \\n    def get_possibles(self, s: str, prefix: str, suffix: str) -> list:\\n        \\n        poss = []\\n        if s[0] != \\'0\\' or s==\"0\":\\n            poss.append(prefix + s + suffix)\\n        \\n        for d in range(1, len(s)):\\n            k = s[:d]+\".\"+s[d:]\\n            if self.validate(k):\\n                poss.append(prefix + k + suffix)\\n        \\n        return poss\\n\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        poss = []\\n        # print(s)\\n        for i in range(1,len(s), 1):\\n            # print(s[:i], s[i:])\\n            poss_1 = self.get_possibles(s[:i], \"(\", \", \")\\n            poss_2 = self.get_possibles(s[i:], \"\", \")\")\\n            poss += list(itertools.product(poss_1, poss_2))\\n        \\n        \\n        if len(poss) == 0:\\n            return []\\n        return [a[0]+a[1] for a in poss]\\n        \\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def validate(self, s: str) -> bool:\\n        \\n        left_zero_count = 0\\n        \\n        if s[0] == \\'0\\' and s[1] != \\'.\\':\\n            return False\\n        \\n        if s[-1] == \\'0\\':\\n            return False\\n        \\n        return True\\n    \\n    def get_possibles(self, s: str, prefix: str, suffix: str) -> list:\\n        \\n        poss = []\\n        if s[0] != \\'0\\' or s==\"0\":\\n            poss.append(prefix + s + suffix)\\n        \\n        for d in range(1, len(s)):\\n            k = s[:d]+\".\"+s[d:]\\n            if self.validate(k):\\n                poss.append(prefix + k + suffix)\\n        \\n        return poss\\n\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        poss = []\\n        # print(s)\\n        for i in range(1,len(s), 1):\\n            # print(s[:i], s[i:])\\n            poss_1 = self.get_possibles(s[:i], \"(\", \", \")\\n            poss_2 = self.get_possibles(s[i:], \"\", \")\")\\n            poss += list(itertools.product(poss_1, poss_2))\\n        \\n        \\n        if len(poss) == 0:\\n            return []\\n        return [a[0]+a[1] for a in poss]\\n        \\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1211835,
                "title": "python-3-solution",
                "content": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        def gnrtnum(s):\\n            \\'\\'\\'\\n            This function is to generate valid numbers for each input string.\\n            \\'\\'\\'\\n            l=len(s)\\n            # only one digit, then return the only possible one s\\n            if l==1:\\n                return [s]\\n            # if start with 0 and end with 0, it could only be the format of \\n            # 0.110 which should have been generated in last step of 0.11\\n            # so return empty to skip this step\\n            if s[0]==\\'0\\' and s[-1]==\\'0\\':\\n                return []\\n            # if input string start with 0, then there is only one valid \\n            # number could be generated like 0.11\\n            if s[0]==\\'0\\':\\n                return [\\'0.\\'+s[1:]]\\n            # if input string end with 0, then there is only one valid number\\n            # could be generated like 110\\n            if s[-1]==\\'0\\':\\n                return [s]\\n            nums=[s]\\n            for i in range(1,len(s)):\\n                num=s[:i]+\\'.\\'+s[i:]\\n                nums.append(num)\\n            return nums\\n        nums=[]\\n        for i in range(2,len(s)-1):\\n            nums1=gnrtnum(s[1:i])\\n            nums2=gnrtnum(s[i:-1])\\n            if not nums1 or not nums2:\\n                continue\\n            for a,b in product(nums1, nums2):\\n                nums.append(f\\'({a}, {b})\\')\\n        return nums\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        def gnrtnum(s):\\n            \\'\\'\\'\\n            This function is to generate valid numbers for each input string.\\n            \\'\\'\\'\\n            l=len(s)\\n            # only one digit, then return the only possible one s\\n            if l==1:\\n                return [s]\\n            # if start with 0 and end with 0, it could only be the format of \\n            # 0.110 which should have been generated in last step of 0.11\\n            # so return empty to skip this step\\n            if s[0]==\\'0\\' and s[-1]==\\'0\\':\\n                return []\\n            # if input string start with 0, then there is only one valid \\n            # number could be generated like 0.11\\n            if s[0]==\\'0\\':\\n                return [\\'0.\\'+s[1:]]\\n            # if input string end with 0, then there is only one valid number\\n            # could be generated like 110\\n            if s[-1]==\\'0\\':\\n                return [s]\\n            nums=[s]\\n            for i in range(1,len(s)):\\n                num=s[:i]+\\'.\\'+s[i:]\\n                nums.append(num)\\n            return nums\\n        nums=[]\\n        for i in range(2,len(s)-1):\\n            nums1=gnrtnum(s[1:i])\\n            nums2=gnrtnum(s[i:-1])\\n            if not nums1 or not nums2:\\n                continue\\n            for a,b in product(nums1, nums2):\\n                nums.append(f\\'({a}, {b})\\')\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211795,
                "title": "java-simple-commented-solution",
                "content": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        \\n        int n = s.length();\\n        List<String> result = new ArrayList<>();\\n        // i represents the point at which we partition the string into 2 coordinates\\n        for(int i = 2; i<n-1; i++) {\\n             \\n\\t\\t\\t //find all possible representations for left coordinate\\n            List<String> left = find(s.substring(1,i));\\n\\t\\t\\t//if left coordinates are empty, then we can skip this partition point\\n\\t\\t\\t//no need to calculate right coordinates\\n            if(left.isEmpty()) continue;\\n            \\n            List<String> right = find(s.substring(i, n-1));\\n            \\n\\t\\t\\t//each possible left coordinate can be combined with each right coordinate\\n            for(String l  : left){\\n                for(String r : right){\\n                    result.add(\"(\" + l + \", \" + r + \")\");\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private List<String> find(String s){\\n        \\n        if(s.length()==1)\\n            return Arrays.asList(s);\\n        \\n        if(s.charAt(0) == \\'0\\' && s.charAt(s.length()-1)==\\'0\\')\\n            return new ArrayList<>();\\n        \\n        if(s.charAt(0) == \\'0\\'){\\n            return Collections.singletonList(s.charAt(0) + \".\" + s.substring(1));\\n        }\\n        \\n        if(s.charAt(s.length()-1)==\\'0\\')   return Arrays.asList(s);\\n        \\n        List<String> res = new ArrayList<>();\\n        res.add(s);\\n        for(int i = 0; i < s.length() - 1;  i++){\\n            res.add(s.substring(0, i+1) + \".\" + s.substring(i+1));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        \\n        int n = s.length();\\n        List<String> result = new ArrayList<>();\\n        // i represents the point at which we partition the string into 2 coordinates\\n        for(int i = 2; i<n-1; i++) {\\n             \\n\\t\\t\\t //find all possible representations for left coordinate\\n            List<String> left = find(s.substring(1,i));\\n\\t\\t\\t//if left coordinates are empty, then we can skip this partition point\\n\\t\\t\\t//no need to calculate right coordinates\\n            if(left.isEmpty()) continue;\\n            \\n            List<String> right = find(s.substring(i, n-1));\\n            \\n\\t\\t\\t//each possible left coordinate can be combined with each right coordinate\\n            for(String l  : left){\\n                for(String r : right){\\n                    result.add(\"(\" + l + \", \" + r + \")\");\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private List<String> find(String s){\\n        \\n        if(s.length()==1)\\n            return Arrays.asList(s);\\n        \\n        if(s.charAt(0) == \\'0\\' && s.charAt(s.length()-1)==\\'0\\')\\n            return new ArrayList<>();\\n        \\n        if(s.charAt(0) == \\'0\\'){\\n            return Collections.singletonList(s.charAt(0) + \".\" + s.substring(1));\\n        }\\n        \\n        if(s.charAt(s.length()-1)==\\'0\\')   return Arrays.asList(s);\\n        \\n        List<String> res = new ArrayList<>();\\n        res.add(s);\\n        for(int i = 0; i < s.length() - 1;  i++){\\n            res.add(s.substring(0, i+1) + \".\" + s.substring(i+1));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210519,
                "title": "python-3-solution-explained",
                "content": "```\\nfrom itertools import product\\n\\n\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str):\\n        \"\"\"\\n        Given a string of digits, this program determines all\\n        possibilities of what two coordinates could be with the\\n        addition of decimal points, a comma, and a space.\\n\\n        :param s: 2-dimensional coordinates with all commas,\\n                  decimal points, and spaces removed\\n        :type s: str\\n        :return: array of all possibilities for what our original\\n                 coordinates could have been\\n        :rtype: list[str]\\n        \"\"\"\\n\\n        def is_valid(coord: str) -> bool:\\n            \"\"\"\\n            This method determines whether a given coordinate\\n            (coord) is valid or can be made valid with the addition\\n            of a decimal point.\\n\\n            :param coord: coordinate string containing only digits\\n            :type coord: str\\n            :return: True if coord is a valid coordinate or can\\n                     be converted to a valid coordinate with the\\n                     addition of a decimal point, else False\\n            :rtype: bool\\n            \"\"\"\\n\\n            \"\"\"\\n            A coordinate is valid if one of the following is true:\\n            - It contains a single digit.\\n            - The first digit or last digit is not \\'0\\'.\\n            \"\"\"\\n            if len(coord) == 1:\\n                return True\\n            if coord[0] == \\'0\\' and coord[-1] == \\'0\\':\\n                return False\\n            return True\\n\\n        def possibilities(coord: str):\\n            \"\"\"\\n            Given a string of digits (coord) that has passed\\n            a validity test that determined that at least one\\n            valid coordinate is possible, this program determines\\n            the list of all possible coordinates that can be\\n            derived from coord.\\n\\n            :param coord: validated string of digits\\n            :type coord: str\\n            :return: array of all possible coordinates that\\n                     can be derived from coord\\n            :rtype: list[str]\\n            \"\"\"\\n\\n            \"\"\"\\n            The following valid coordinates have exactly one\\n            possibility:\\n            - The coordinate has one digit.\\n            - The coordinate begins with \\'0\\'.\\n            - The coordinate ends with \\'0\\'.\\n            Otherwise, the possibilities consist of the unmodified\\n            coordinate plus the possibilities that can be generated\\n            by placing a decimal point between any two digits.\\n            \"\"\"\\n            len_coord = len(coord)\\n            if len_coord == 1:\\n                return [coord]\\n            if coord[0] == \\'0\\':\\n                return [\\'\\'.join([\\'0.\\', coord[1:]])]\\n            if coord[-1] == \\'0\\':\\n                return [coord]\\n            result = [coord]\\n            for decimal in range(1, len_coord):\\n                result.append(\\'\\'.join([coord[:decimal], \\'.\\', coord[decimal:]]))\\n            return result\\n\\n        \"\"\"\\n        - Extract the contents of s by removing the outer parentheses\\n          and store them in content.\\n        - Store the length of content in len_content.\\n        - result will contain the output from this program.\\n        \"\"\"\\n        len_s = len(s)\\n        content = s[1:len_s - 1]\\n        len_content = len(content)\\n        result = []\\n        \\n        \"\"\"\\n        Main Loop:\\n        - Partition content into two coordinates (coord_1, coord_2).\\n        - If both coordinates pass a validity test using the\\n          is_valid method:\\n          - Use the possibilities method to generate a list of\\n            possibilities for each coordinate. Store the results\\n            for coord_1 and coord_2 in list_1 and list_2, respectively.\\n          - Generate coordinate pairs (pairs) from the list product\\n            of list_1 and list_2.\\n          - Add each pair to result in the correct format.\\n        \"\"\"\\n        for k in range(1, len_content):\\n            coord_1 = content[:k]\\n            coord_2 = content[k:]\\n            if is_valid(coord_1) and is_valid(coord_2):\\n                list_1 = possibilities(coord_1)\\n                list_2 = possibilities(coord_2)\\n                pairs = list(product(list_1, list_2))\\n                for p1, p2 in pairs:\\n                    result.append(\\'\\'.join([\\'(\\', p1, \\', \\', p2, \\')\\']))\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import product\\n\\n\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str):\\n        \"\"\"\\n        Given a string of digits, this program determines all\\n        possibilities of what two coordinates could be with the\\n        addition of decimal points, a comma, and a space.\\n\\n        :param s: 2-dimensional coordinates with all commas,\\n                  decimal points, and spaces removed\\n        :type s: str\\n        :return: array of all possibilities for what our original\\n                 coordinates could have been\\n        :rtype: list[str]\\n        \"\"\"\\n\\n        def is_valid(coord: str) -> bool:\\n            \"\"\"\\n            This method determines whether a given coordinate\\n            (coord) is valid or can be made valid with the addition\\n            of a decimal point.\\n\\n            :param coord: coordinate string containing only digits\\n            :type coord: str\\n            :return: True if coord is a valid coordinate or can\\n                     be converted to a valid coordinate with the\\n                     addition of a decimal point, else False\\n            :rtype: bool\\n            \"\"\"\\n\\n            \"\"\"\\n            A coordinate is valid if one of the following is true:\\n            - It contains a single digit.\\n            - The first digit or last digit is not \\'0\\'.\\n            \"\"\"\\n            if len(coord) == 1:\\n                return True\\n            if coord[0] == \\'0\\' and coord[-1] == \\'0\\':\\n                return False\\n            return True\\n\\n        def possibilities(coord: str):\\n            \"\"\"\\n            Given a string of digits (coord) that has passed\\n            a validity test that determined that at least one\\n            valid coordinate is possible, this program determines\\n            the list of all possible coordinates that can be\\n            derived from coord.\\n\\n            :param coord: validated string of digits\\n            :type coord: str\\n            :return: array of all possible coordinates that\\n                     can be derived from coord\\n            :rtype: list[str]\\n            \"\"\"\\n\\n            \"\"\"\\n            The following valid coordinates have exactly one\\n            possibility:\\n            - The coordinate has one digit.\\n            - The coordinate begins with \\'0\\'.\\n            - The coordinate ends with \\'0\\'.\\n            Otherwise, the possibilities consist of the unmodified\\n            coordinate plus the possibilities that can be generated\\n            by placing a decimal point between any two digits.\\n            \"\"\"\\n            len_coord = len(coord)\\n            if len_coord == 1:\\n                return [coord]\\n            if coord[0] == \\'0\\':\\n                return [\\'\\'.join([\\'0.\\', coord[1:]])]\\n            if coord[-1] == \\'0\\':\\n                return [coord]\\n            result = [coord]\\n            for decimal in range(1, len_coord):\\n                result.append(\\'\\'.join([coord[:decimal], \\'.\\', coord[decimal:]]))\\n            return result\\n\\n        \"\"\"\\n        - Extract the contents of s by removing the outer parentheses\\n          and store them in content.\\n        - Store the length of content in len_content.\\n        - result will contain the output from this program.\\n        \"\"\"\\n        len_s = len(s)\\n        content = s[1:len_s - 1]\\n        len_content = len(content)\\n        result = []\\n        \\n        \"\"\"\\n        Main Loop:\\n        - Partition content into two coordinates (coord_1, coord_2).\\n        - If both coordinates pass a validity test using the\\n          is_valid method:\\n          - Use the possibilities method to generate a list of\\n            possibilities for each coordinate. Store the results\\n            for coord_1 and coord_2 in list_1 and list_2, respectively.\\n          - Generate coordinate pairs (pairs) from the list product\\n            of list_1 and list_2.\\n          - Add each pair to result in the correct format.\\n        \"\"\"\\n        for k in range(1, len_content):\\n            coord_1 = content[:k]\\n            coord_2 = content[k:]\\n            if is_valid(coord_1) and is_valid(coord_2):\\n                list_1 = possibilities(coord_1)\\n                list_2 = possibilities(coord_2)\\n                pairs = list(product(list_1, list_2))\\n                for p1, p2 in pairs:\\n                    result.append(\\'\\'.join([\\'(\\', p1, \\', \\', p2, \\')\\']))\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207893,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    bool good(string s) {\\n        int n = s.size();\\n        int dot = 0;\\n        if(n > 1 && s[0] == \\'0\\' && s[1] != \\'.\\') {\\n            return false;\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'.\\') {\\n                dot++;\\n                if(s.substr(i + 1) == string(n - i - 1, \\'0\\'))\\n                    return false;\\n            }\\n        }\\n        if(dot == 1 && s.back() == \\'0\\')\\n            return false;\\n        if(dot <= 1)\\n            return true;\\n        return false;\\n    }\\n    void dfs(string s, vector<string>& a, int pos, string b) {\\n        if(pos == (int) s.size()) {\\n            a.push_back(b);\\n            return;\\n        }\\n        b.push_back(s[pos]);\\n        b.push_back(\\'.\\');\\n        dfs(s, a, pos + 1, b);\\n        if(b.back() == \\'.\\')\\n            b.pop_back();\\n        dfs(s, a, pos + 1, b);\\n    }\\n    vector<string> getStrings(string s) {\\n        vector<string> a;\\n        dfs(s, a, 0, \"\");\\n        return a;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        s.erase(s.begin());\\n        s.pop_back();\\n        int n = s.size();\\n        for(int split = 0; split < n - 1; split++) {\\n            vector<string> a =  getStrings(s.substr(0, split + 1));\\n            vector<string> b = getStrings(s.substr(split + 1));\\n            for(string c : a) {\\n                for(string d : b) {\\n                    if(good(c) && good(d)) {\\n                        string sol = \"(\" + c + \", \" + d + \")\";\\n                        ans.push_back(sol);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    bool good(string s) {\\n        int n = s.size();\\n        int dot = 0;\\n        if(n > 1 && s[0] == \\'0\\' && s[1] != \\'.\\') {\\n            return false;\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'.\\') {\\n                dot++;\\n                if(s.substr(i + 1) == string(n - i - 1, \\'0\\'))\\n                    return false;\\n            }\\n        }\\n        if(dot == 1 && s.back() == \\'0\\')\\n            return false;\\n        if(dot <= 1)\\n            return true;\\n        return false;\\n    }\\n    void dfs(string s, vector<string>& a, int pos, string b) {\\n        if(pos == (int) s.size()) {\\n            a.push_back(b);\\n            return;\\n        }\\n        b.push_back(s[pos]);\\n        b.push_back(\\'.\\');\\n        dfs(s, a, pos + 1, b);\\n        if(b.back() == \\'.\\')\\n            b.pop_back();\\n        dfs(s, a, pos + 1, b);\\n    }\\n    vector<string> getStrings(string s) {\\n        vector<string> a;\\n        dfs(s, a, 0, \"\");\\n        return a;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        s.erase(s.begin());\\n        s.pop_back();\\n        int n = s.size();\\n        for(int split = 0; split < n - 1; split++) {\\n            vector<string> a =  getStrings(s.substr(0, split + 1));\\n            vector<string> b = getStrings(s.substr(split + 1));\\n            for(string c : a) {\\n                for(string d : b) {\\n                    if(good(c) && good(d)) {\\n                        string sol = \"(\" + c + \", \" + d + \")\";\\n                        ans.push_back(sol);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207680,
                "title": "js-split-by-comma-then-put-decimal",
                "content": "```\\nvar ambiguousCoordinates = function(s) {\\n    let list = putComma(s.match(/\\\\d+/)[0]);\\n    let ans = [];\\n    for(let l of list)\\n        putDecimal(l, ans);\\n    return ans;      \\n};\\n\\nvar putComma = function(s) {\\n    let l = [];\\n    let i = 1;\\n    while(i < s.length) {\\n        l.push([s.slice(0,i), s.slice(i)])\\n        i++;\\n    } \\n    return l;\\n}\\nvar putDecimal = function([first, second], ans) {\\n    let firstSet = putDecimalPerString(first);\\n    let secondSet = putDecimalPerString(second);\\n    for(let f of firstSet)\\n        for(let s of secondSet)\\n            ans.push(`(${f}, ${s})`);\\n}\\nvar putDecimalPerString = function(s) {\\n    if(s.length === 1)\\n        return [s];\\n    else {\\n        let ans = s === \"\"+Number(s) ? [s] : [];\\n        let i = 1;\\n        while(i < s.length) {\\n            let s_n = s.slice(0,i) + \\'.\\' + s.slice(i);\\n            if(s_n === \"\" + Number(s_n))\\n                ans.push(s_n);\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar ambiguousCoordinates = function(s) {\\n    let list = putComma(s.match(/\\\\d+/)[0]);\\n    let ans = [];\\n    for(let l of list)\\n        putDecimal(l, ans);\\n    return ans;      \\n};\\n\\nvar putComma = function(s) {\\n    let l = [];\\n    let i = 1;\\n    while(i < s.length) {\\n        l.push([s.slice(0,i), s.slice(i)])\\n        i++;\\n    } \\n    return l;\\n}\\nvar putDecimal = function([first, second], ans) {\\n    let firstSet = putDecimalPerString(first);\\n    let secondSet = putDecimalPerString(second);\\n    for(let f of firstSet)\\n        for(let s of secondSet)\\n            ans.push(`(${f}, ${s})`);\\n}\\nvar putDecimalPerString = function(s) {\\n    if(s.length === 1)\\n        return [s];\\n    else {\\n        let ans = s === \"\"+Number(s) ? [s] : [];\\n        let i = 1;\\n        while(i < s.length) {\\n            let s_n = s.slice(0,i) + \\'.\\' + s.slice(i);\\n            if(s_n === \"\" + Number(s_n))\\n                ans.push(s_n);\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1207623,
                "title": "java-solution-100-beat",
                "content": "```\\nclass Solution {\\n    public List<String> xPoss, ans;\\n    public List<String> ambiguousCoordinates(String s) {\\n        ans = new ArrayList<>();   \\n        for(int i = 2; i < s.length() - 1; i++){\\n            String[] str = {s.substring(1, i), s.substring(i, s.length() - 1)};\\n            xPoss = new ArrayList<>();\\n            for(int j = 0; j < 2; j++){\\n                if(xPoss.size() > 0 || j == 0) placDec(str[j], j);\\n            }\\n        }\\n        return ans;\\n    }\\n    public void placDec(String str, int lr){\\n        if(str.length() == 1 || str.charAt(0) != \\'0\\')\\n            process(str, lr);\\n        if(str.length() > 1 && str.charAt(str.length() - 1) != \\'0\\') \\n            process(str.substring(0, 1) + \".\" + str.substring(1), lr);\\n        if(str.length() > 2 && str.charAt(0) != \\'0\\' && str.charAt(str.length() - 1) != \\'0\\')\\n            for(int j = 2; j < str.length(); j++)\\n                process(str.substring(0, j) + \".\" + str.substring(j), lr);\\n    } \\n    public void process(String str, int lr){\\n        if(lr > 0){\\n          for (String x : xPoss)\\n                ans.add(\"(\" + x + \", \" + str + \")\");\\n        }\\n        else xPoss.add(str);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> xPoss, ans;\\n    public List<String> ambiguousCoordinates(String s) {\\n        ans = new ArrayList<>();   \\n        for(int i = 2; i < s.length() - 1; i++){\\n            String[] str = {s.substring(1, i), s.substring(i, s.length() - 1)};\\n            xPoss = new ArrayList<>();\\n            for(int j = 0; j < 2; j++){\\n                if(xPoss.size() > 0 || j == 0) placDec(str[j], j);\\n            }\\n        }\\n        return ans;\\n    }\\n    public void placDec(String str, int lr){\\n        if(str.length() == 1 || str.charAt(0) != \\'0\\')\\n            process(str, lr);\\n        if(str.length() > 1 && str.charAt(str.length() - 1) != \\'0\\') \\n            process(str.substring(0, 1) + \".\" + str.substring(1), lr);\\n        if(str.length() > 2 && str.charAt(0) != \\'0\\' && str.charAt(str.length() - 1) != \\'0\\')\\n            for(int j = 2; j < str.length(); j++)\\n                process(str.substring(0, j) + \".\" + str.substring(j), lr);\\n    } \\n    public void process(String str, int lr){\\n        if(lr > 0){\\n          for (String x : xPoss)\\n                ans.add(\"(\" + x + \", \" + str + \")\");\\n        }\\n        else xPoss.add(str);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207599,
                "title": "faster-than-100-python-submissions",
                "content": "If we are given string s, then the idea to first try to break the string based on `,` into say `s[:i]` and `s[i:]` and then brute force into all possible numbers formed by `s[:i]` and `s[i:]`\\n\\nFor a number to be well formed, it shouldn\\'t  start with `0`\\'s and after decimal it shouldn\\'t end with `0`\\n```python\\nfrom itertools import product\\n\\nclass Solution(object):\\n    def get(self, s):\\n        # Returns the different numbers formed with string s\\n        ret = []\\n        for i in range(1, len(s)+1):\\n            s1, s2 = s[:i], s[i:]\\n            if (s1[0]==\\'0\\' and len(s1)>1) or (len(s2)>0 and s2[-1]==\\'0\\'):\\n                continue\\n            ret += [str(s1)] if len(s2)==0 else [str(s1 + \\'.\\' + s2)]\\n        return ret\\n                   \\n    def ambiguousCoordinates(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        s = s[1:-1]\\n        ret = []\\n        for i in range(1,len(s)):\\n            # Split s by comma -> s[:i] and s[i:]\\n            for (x, y) in product(self.get(s[:i]), self.get(s[i:])):\\n                ret += [\"(\" + x + \", \" + y + \")\" ]\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom itertools import product\\n\\nclass Solution(object):\\n    def get(self, s):\\n        # Returns the different numbers formed with string s\\n        ret = []\\n        for i in range(1, len(s)+1):\\n            s1, s2 = s[:i], s[i:]\\n            if (s1[0]==\\'0\\' and len(s1)>1) or (len(s2)>0 and s2[-1]==\\'0\\'):\\n                continue\\n            ret += [str(s1)] if len(s2)==0 else [str(s1 + \\'.\\' + s2)]\\n        return ret\\n                   \\n    def ambiguousCoordinates(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        s = s[1:-1]\\n        ret = []\\n        for i in range(1,len(s)):\\n            # Split s by comma -> s[:i] and s[i:]\\n            for (x, y) in product(self.get(s[:i]), self.get(s[i:])):\\n                ret += [\"(\" + x + \", \" + y + \")\" ]\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207532,
                "title": "python-easy-problem-breakdown-steps",
                "content": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        cache = {}\\n        decimal_cache = {}\\n\\t\\t\"\"\"\\n\\t\\tUsing caches to save operations on similar segments if done earlier\\n\\t\\tAs 11111 will break into\\n\\t\\t1 1111\\n\\t\\t11 111\\n\\t\\t111 11\\n\\t\\t1111 1\\n\\t\\tLeft and right segments will repeat\\n\\t\\t\"\"\"\\n        s = s[1:len(s) - 1]\\n\\n        def is_valid(subs: str) -> (bool, List[str]):\\n            if subs == \\'0\\':\\n                return True, [subs]\\n\\n            if len(subs) > 0 and subs[0] == \\'0\\' and subs[-1] == \\'0\\':\\n\\t\\t\\t    \"\"\"\\n\\t\\t\\t\\tBegining and ending with 0 not allowed\\n\\t\\t\\t\\tsegment 01230 or 0010 not allowed to be 0.010 or 0.1230\\n\\t\\t\\t\\t\"\"\"\\n                return False, []\\n\\n            if subs[-1] == \\'0\\':\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tEnding with 0 are allowed to be whole numbers only\\n\\t\\t\\t\\teg: the segment 1230 can be 1230 only\\n\\t\\t\\t\\tor 10 can be 10 only and not 1.0\\n\\t\\t\\t\\t\"\"\"\\n                return True, [subs]\\n\\n            # place decimal\\n            if subs[0] == \\'0\\':\\n                \"\"\"\\n                decimal can only be placed in position 1\\n\\t\\t\\t\\teg: 0123 can be 0.123\\n\\t\\t\\t\\t\"\"\"\\n                return True, [f\\'{subs[0]}.{subs[1:]}\\']\\n            else:\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tFor regular non 0 begining/ ending numbers can have decimals\\n\\t\\t\\t\\tin between every two digits\\n\\t\\t\\t\\t\"\"\"\\n                if subs in decimal_cache:\\n                    return decimal_cache[subs]\\n                res = [subs]\\n                if res[-1] == 0:\\n                    return True, res\\n\\n                for i in range(1, len(subs)):\\n                    l, r = subs[:i], subs[i:]\\n                    res.append(f\\'{l}.{r}\\')\\n                decimal_cache[subs] = True, res\\n                return decimal_cache[subs]\\n\\n\\t\\tres = set()\\n        for i in range(1, len(s)):\\n            left_subs, right_subs = s[:i], s[i:]\\n\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tFor each segment check cache first and if not valid move to next\\n\\t\\t\\tOnly if both valid add to final result set\\n\\t\\t\\t\"\"\"\\n\\n            if left_subs not in cache:\\n                cache[left_subs] = is_valid(left_subs)\\n\\n            left_is_valid, left_res = cache[left_subs]\\n            if not left_is_valid:\\n                continue\\n\\n            if right_subs not in cache:\\n                cache[right_subs] = is_valid(right_subs)\\n\\n            right_is_valid, right_res = cache[right_subs]\\n            if not right_is_valid:\\n                continue\\n\\n            for _, lv in enumerate(left_res):\\n                for _, rv in enumerate(right_res):\\n                    res.add(f\\'({lv}, {rv})\\')\\n\\n        return list(res)\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        cache = {}\\n        decimal_cache = {}\\n\\t\\t\"\"\"\\n\\t\\tUsing caches to save operations on similar segments if done earlier\\n\\t\\tAs 11111 will break into\\n\\t\\t1 1111\\n\\t\\t11 111\\n\\t\\t111 11\\n\\t\\t1111 1\\n\\t\\tLeft and right segments will repeat\\n\\t\\t\"\"\"\\n        s = s[1:len(s) - 1]\\n\\n        def is_valid(subs: str) -> (bool, List[str]):\\n            if subs == \\'0\\':\\n                return True, [subs]\\n\\n            if len(subs) > 0 and subs[0] == \\'0\\' and subs[-1] == \\'0\\':\\n\\t\\t\\t    \"\"\"\\n\\t\\t\\t\\tBegining and ending with 0 not allowed\\n\\t\\t\\t\\tsegment 01230 or 0010 not allowed to be 0.010 or 0.1230\\n\\t\\t\\t\\t\"\"\"\\n                return False, []\\n\\n            if subs[-1] == \\'0\\':\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tEnding with 0 are allowed to be whole numbers only\\n\\t\\t\\t\\teg: the segment 1230 can be 1230 only\\n\\t\\t\\t\\tor 10 can be 10 only and not 1.0\\n\\t\\t\\t\\t\"\"\"\\n                return True, [subs]\\n\\n            # place decimal\\n            if subs[0] == \\'0\\':\\n                \"\"\"\\n                decimal can only be placed in position 1\\n\\t\\t\\t\\teg: 0123 can be 0.123\\n\\t\\t\\t\\t\"\"\"\\n                return True, [f\\'{subs[0]}.{subs[1:]}\\']\\n            else:\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tFor regular non 0 begining/ ending numbers can have decimals\\n\\t\\t\\t\\tin between every two digits\\n\\t\\t\\t\\t\"\"\"\\n                if subs in decimal_cache:\\n                    return decimal_cache[subs]\\n                res = [subs]\\n                if res[-1] == 0:\\n                    return True, res\\n\\n                for i in range(1, len(subs)):\\n                    l, r = subs[:i], subs[i:]\\n                    res.append(f\\'{l}.{r}\\')\\n                decimal_cache[subs] = True, res\\n                return decimal_cache[subs]\\n\\n\\t\\tres = set()\\n        for i in range(1, len(s)):\\n            left_subs, right_subs = s[:i], s[i:]\\n\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tFor each segment check cache first and if not valid move to next\\n\\t\\t\\tOnly if both valid add to final result set\\n\\t\\t\\t\"\"\"\\n\\n            if left_subs not in cache:\\n                cache[left_subs] = is_valid(left_subs)\\n\\n            left_is_valid, left_res = cache[left_subs]\\n            if not left_is_valid:\\n                continue\\n\\n            if right_subs not in cache:\\n                cache[right_subs] = is_valid(right_subs)\\n\\n            right_is_valid, right_res = cache[right_subs]\\n            if not right_is_valid:\\n                continue\\n\\n            for _, lv in enumerate(left_res):\\n                for _, rv in enumerate(right_res):\\n                    res.add(f\\'({lv}, {rv})\\')\\n\\n        return list(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207500,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\nclass Solution {\\n    func ambiguousCoordinates(_ s: String) -> [String] {\\n        let s = Array(s)[1...(s.count - 2)].map({ Int($0.asciiValue ?? 48) - 48 }), c = s.count\\n        var result = [String](), d1 = 0\\n        for1: for i1 in 0..<(c - 1) {\\n            var d2 = 0, tz2 = 0\\n            if s[0] == 0 && i1 > 0 { break for1 } // leading zero\\n            d1 = d1 * 10 + s[i1]\\n            for2: for i2 in i1..<(c - 1) {\\n                var d3 = 0\\n                if i2 > i1 { d2 = d2 * 10 + s[i2] }\\n                if i2 > i1 && d2 == 0 { tz2 += 1 } // counting leading zeros for d2\\n                if i2 > i1 && s[i2] == 0 { continue for2 } // trailing zero\\n                for3: for i3 in (i2 + 1)..<c {\\n                    var d4 = 0, tz4 = 0\\n                    if s[i2 + 1] == 0 && i3 > i2 + 1 { break for3 } // leading zero\\n                    d3 = d3 * 10 + s[i3]\\n                    for4: for i4 in i3..<c {\\n                        if i4 > i3 { d4 = d4 * 10 + s[i4] }\\n                        if i4 > i3 && d4 == 0 { tz4 += 1 } // counting leading zeros for d4\\n                        if i4 > i3 && s[i4] == 0 { continue for4 } // trailing zero\\n                        if i4 == c - 1 {\\n                            result.append(\"(\\\\(d1)\\\\(i2 > i1 ? \".\\\\(String(repeating: \"0\", count: tz2))\\\\(d2)\" : \"\"), \\\\(d3)\\\\(i4 > i3 ? \".\\\\(String(repeating: \"0\", count: tz4))\\\\(d4)\" : \"\"))\")\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func ambiguousCoordinates(_ s: String) -> [String] {\\n        let s = Array(s)[1...(s.count - 2)].map({ Int($0.asciiValue ?? 48) - 48 }), c = s.count\\n        var result = [String](), d1 = 0\\n        for1: for i1 in 0..<(c - 1) {\\n            var d2 = 0, tz2 = 0\\n            if s[0] == 0 && i1 > 0 { break for1 } // leading zero\\n            d1 = d1 * 10 + s[i1]\\n            for2: for i2 in i1..<(c - 1) {\\n                var d3 = 0\\n                if i2 > i1 { d2 = d2 * 10 + s[i2] }\\n                if i2 > i1 && d2 == 0 { tz2 += 1 } // counting leading zeros for d2\\n                if i2 > i1 && s[i2] == 0 { continue for2 } // trailing zero\\n                for3: for i3 in (i2 + 1)..<c {\\n                    var d4 = 0, tz4 = 0\\n                    if s[i2 + 1] == 0 && i3 > i2 + 1 { break for3 } // leading zero\\n                    d3 = d3 * 10 + s[i3]\\n                    for4: for i4 in i3..<c {\\n                        if i4 > i3 { d4 = d4 * 10 + s[i4] }\\n                        if i4 > i3 && d4 == 0 { tz4 += 1 } // counting leading zeros for d4\\n                        if i4 > i3 && s[i4] == 0 { continue for4 } // trailing zero\\n                        if i4 == c - 1 {\\n                            result.append(\"(\\\\(d1)\\\\(i2 > i1 ? \".\\\\(String(repeating: \"0\", count: tz2))\\\\(d2)\" : \"\"), \\\\(d3)\\\\(i4 > i3 ? \".\\\\(String(repeating: \"0\", count: tz4))\\\\(d4)\" : \"\"))\")\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207357,
                "title": "c-clean-solution-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string> res;\\n        string a = s.substr(1,1), b = s.substr(2);\\n        b.pop_back();\\n        while(!b.empty()) {\\n            vector<string> left = getStrDots(a);\\n            vector<string> right = getStrDots(b);\\n            for(string lstr : left) {\\n                for(string rstr: right) res.push_back(\"(\"+lstr+\", \"+rstr+\")\");\\n            }\\n            a.push_back(b.front());\\n            b.erase(0,1);\\n        }\\n        return res;\\n    }\\n    \\n     //generating all valid cordinates of givens str\\n    vector<string> getStrDots(string &str) {\\n        vector<string> res;\\n        if(isValidStr(str)) res.emplace_back(str);\\n        for(int i = 1; i < str.size(); i++) {\\n            string temp = str.substr(0, i) + \".\" + str.substr(i);\\n            if(isValidStr(temp)) res.emplace_back(temp);\\n        }\\n        return res;\\n    }\\n    \\n    \\n    bool isValidStr(string &str) {\\n        // handle case of .12, 123., .0\\n        if(str.size() > 0 && (str[0] == \\'.\\' || str.back() == \\'.\\')) return false;\\n        //handle case of 12.0, 123.00, 0.0\\n        if(str.size() > 1 && str.find(\".\") != string::npos && str.back() == \\'0\\') return false;\\n        // handle case of 01, 001, 0123\\n        if(str.size() > 1 && str[0] == \\'0\\' && str[1] != \\'.\\') return false;\\n        return true;\\n    }\\n    \\n};\\n\\n// for I/O operation Faster\\n#pragma GCC optimize(\"Ofast\")\\nstatic const auto io_sync_off = []()\\n{\\n    std::ios::sync_with_stdio(false);\\n    std::cin.tie(nullptr);\\n    std::cout.tie(nullptr);\\n    return nullptr;\\n}();\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n        vector<string> res;\\n        string a = s.substr(1,1), b = s.substr(2);\\n        b.pop_back();\\n        while(!b.empty()) {\\n            vector<string> left = getStrDots(a);\\n            vector<string> right = getStrDots(b);\\n            for(string lstr : left) {\\n                for(string rstr: right) res.push_back(\"(\"+lstr+\", \"+rstr+\")\");\\n            }\\n            a.push_back(b.front());\\n            b.erase(0,1);\\n        }\\n        return res;\\n    }\\n    \\n     //generating all valid cordinates of givens str\\n    vector<string> getStrDots(string &str) {\\n        vector<string> res;\\n        if(isValidStr(str)) res.emplace_back(str);\\n        for(int i = 1; i < str.size(); i++) {\\n            string temp = str.substr(0, i) + \".\" + str.substr(i);\\n            if(isValidStr(temp)) res.emplace_back(temp);\\n        }\\n        return res;\\n    }\\n    \\n    \\n    bool isValidStr(string &str) {\\n        // handle case of .12, 123., .0\\n        if(str.size() > 0 && (str[0] == \\'.\\' || str.back() == \\'.\\')) return false;\\n        //handle case of 12.0, 123.00, 0.0\\n        if(str.size() > 1 && str.find(\".\") != string::npos && str.back() == \\'0\\') return false;\\n        // handle case of 01, 001, 0123\\n        if(str.size() > 1 && str[0] == \\'0\\' && str[1] != \\'.\\') return false;\\n        return true;\\n    }\\n    \\n};\\n\\n// for I/O operation Faster\\n#pragma GCC optimize(\"Ofast\")\\nstatic const auto io_sync_off = []()\\n{\\n    std::ios::sync_with_stdio(false);\\n    std::cin.tie(nullptr);\\n    std::cout.tie(nullptr);\\n    return nullptr;\\n}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1207356,
                "title": "c-explanation-easy-to-understand-with-comments",
                "content": "First, we process the input string to remove the `(` and `)` characters at the beginning and end respectively. Now, we can place commas at `n-1` positions, where `n` is the length of the processed string. For each of these cases, we divide the string into left and right subparts. For each subpart, we place a decimal point after each character, except in the following edge cases:\\n1. If the last character of the subpart is `0`, we return, since there is no point in putting a decimal point with a zero at the end.\\n2. If the subpart has a leading `0`, then we can place a decimal point only after the first character i.e. only after the first `0`\\n\\nHere is the code:\\n```\\nclass Solution {\\npublic:\\n    vector <string> putDecimal(string &s, int startIdx, int endIdx){\\n        //if subpart\\'s len == endIdx-startIdx+1 == 1, return itself\\n        if(endIdx - startIdx + 1 == 1)\\n            return {s.substr(startIdx, 1)};\\n        vector <string> ret;\\n        // if subpart does not contain a leading zero, we can add the whole subpart to the result without placing a decimal point  \\n        if(s[startIdx] != \\'0\\')\\n            ret.push_back(s.substr(startIdx, endIdx - startIdx + 1));\\n        //edge case 1 mentioned above\\n        if(s[endIdx] == \\'0\\')\\n            return ret;\\n        for(int i = startIdx ; i < endIdx ; i++){\\n            //edge case 2 mentioned above\\n            if(s[startIdx] == \\'0\\' && i > startIdx)\\n                break;\\n            string tmp = s.substr(startIdx, i - startIdx + 1) + \\'.\\' + s.substr(i + 1, endIdx - i);\\n            ret.push_back(tmp);\\n        }\\n        return ret;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.size();\\n        //preprocess the input string\\n        s = s.substr(1, n-2);\\n        vector <string> ans;\\n        n = s.size();\\n        // trying to put commas at all the valid positions\\n        for(int i = 0 ; i < n-1 ; i++){\\n            // divide into left and right subparts\\n            vector <string> part1 = putDecimal(s, 0, i), part2 = putDecimal(s, i+1, n-1);\\n            //combine the results of the left and right subparts\\n            for(string s1:part1){\\n                for(string s2:part2)\\n                    ans.push_back(\\'(\\' + s1 + \", \" + s2 + \\')\\');\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector <string> putDecimal(string &s, int startIdx, int endIdx){\\n        //if subpart\\'s len == endIdx-startIdx+1 == 1, return itself\\n        if(endIdx - startIdx + 1 == 1)\\n            return {s.substr(startIdx, 1)};\\n        vector <string> ret;\\n        // if subpart does not contain a leading zero, we can add the whole subpart to the result without placing a decimal point  \\n        if(s[startIdx] != \\'0\\')\\n            ret.push_back(s.substr(startIdx, endIdx - startIdx + 1));\\n        //edge case 1 mentioned above\\n        if(s[endIdx] == \\'0\\')\\n            return ret;\\n        for(int i = startIdx ; i < endIdx ; i++){\\n            //edge case 2 mentioned above\\n            if(s[startIdx] == \\'0\\' && i > startIdx)\\n                break;\\n            string tmp = s.substr(startIdx, i - startIdx + 1) + \\'.\\' + s.substr(i + 1, endIdx - i);\\n            ret.push_back(tmp);\\n        }\\n        return ret;\\n    }\\n    vector<string> ambiguousCoordinates(string s) {\\n        int n = s.size();\\n        //preprocess the input string\\n        s = s.substr(1, n-2);\\n        vector <string> ans;\\n        n = s.size();\\n        // trying to put commas at all the valid positions\\n        for(int i = 0 ; i < n-1 ; i++){\\n            // divide into left and right subparts\\n            vector <string> part1 = putDecimal(s, 0, i), part2 = putDecimal(s, i+1, n-1);\\n            //combine the results of the left and right subparts\\n            for(string s1:part1){\\n                for(string s2:part2)\\n                    ans.push_back(\\'(\\' + s1 + \", \" + s2 + \\')\\');\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207355,
                "title": "ambiguous-coordinates-help-with-calculating-complexity",
                "content": "Can anyone help me calculate the time and space complexity of this solution?\\nI am confused by the `substring()` methods and inner loops.\\nThis is my assumption:\\nwith `n` as length of string,\\n* Outer loop: `n`\\n  * subString for xVal and yVal will endup being `n` times total\\n  * we loop for length of xVal (say `x`) and length of yVal (say `y`), again total of `n` times\\n\\t  * But each iteration also does another substring totalling upto `x` and `y` length in their respective loops and also do `isValid()` check which loops through same length again. So I guess: `2x` + `2y` here which is basically `2n`\\n  * Then there is last nested loop of `x * y` times\\n\\nSo total: `n * (n + (n* 2n) + (x * y)`, \\nwhich can be simplified to: `n * (2n ^ 2 + n + xy)` => `2n^3 + n^2 + n.x.y` => O(n^3).\\n**Is this correct?**\\nI am not even sure where to start with space complexity :(\\n\\n```java\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        \\n        List<String> result = new ArrayList<>();\\n        \\n        // Find possible values for each comma position\\n        int n = s.length();\\n        for (int i = 2; i < n - 1; i++) {\\n            List<String> validXValues = new ArrayList();\\n            List<String> validYValues = new ArrayList();\\n            \\n            String xVal = s.substring(1, i);\\n            // no decimal, starting with any value other than 0 is valid\\n            if (xVal.charAt(0) != \\'0\\' || xVal.length() == 1) {\\n                validXValues.add(xVal);\\n            }\\n            \\n            String yVal = s.substring(i, n - 1);\\n            if (yVal.charAt(0) != \\'0\\' || yVal.length() == 1) {\\n                validYValues.add(yVal);\\n            }\\n                        \\n            // all possible valid values with decimals in each position for first value\\n            for (int j = 1; j < xVal.length(); j++) {\\n                String xDec = xVal.substring(0, j) + \".\" + xVal.substring(j, xVal.length());\\n                if (isValid(xDec)) {\\n                    validXValues.add(xDec);\\n                }\\n            }\\n            \\n            // and try with decimals in each position for second value\\n            for (int j = 1; j < yVal.length(); j++) {\\n                String yDec = yVal.substring(0, j) + \".\" + yVal.substring(j, yVal.length());\\n                if (isValid(yDec)) {\\n                    validYValues.add(yDec);\\n                }\\n            }\\n            \\n            // now add all combinations\\n            for (String x : validXValues) {\\n                for (String y : validYValues) {\\n                    result.add(\"(\" + x + \", \" + y + \")\");\\n                }\\n            }\\n            \\n        }\\n        return result;\\n    }\\n    \\n    public boolean isValid(String s) {\\n        if (s.length() < 1) {\\n            return false;\\n        } else if (s.length() == 1){\\n            return true;\\n        }\\n        if (s.charAt(0) == \\'0\\') {\\n            // starts with zero, so needs to have a dot right after it\\n            if (s.charAt(1) != \\'.\\') {\\n                return false;\\n            }\\n        }\\n        // if decimal, it cannot end with a 0\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (s.charAt(i) == \\'.\\') {                \\n                if (s.charAt(s.length() - 1) == \\'0\\') {\\n                    return false;\\n                }\\n                break;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        \\n        List<String> result = new ArrayList<>();\\n        \\n        // Find possible values for each comma position\\n        int n = s.length();\\n        for (int i = 2; i < n - 1; i++) {\\n            List<String> validXValues = new ArrayList();\\n            List<String> validYValues = new ArrayList();\\n            \\n            String xVal = s.substring(1, i);\\n            // no decimal, starting with any value other than 0 is valid\\n            if (xVal.charAt(0) != \\'0\\' || xVal.length() == 1) {\\n                validXValues.add(xVal);\\n            }\\n            \\n            String yVal = s.substring(i, n - 1);\\n            if (yVal.charAt(0) != \\'0\\' || yVal.length() == 1) {\\n                validYValues.add(yVal);\\n            }\\n                        \\n            // all possible valid values with decimals in each position for first value\\n            for (int j = 1; j < xVal.length(); j++) {\\n                String xDec = xVal.substring(0, j) + \".\" + xVal.substring(j, xVal.length());\\n                if (isValid(xDec)) {\\n                    validXValues.add(xDec);\\n                }\\n            }\\n            \\n            // and try with decimals in each position for second value\\n            for (int j = 1; j < yVal.length(); j++) {\\n                String yDec = yVal.substring(0, j) + \".\" + yVal.substring(j, yVal.length());\\n                if (isValid(yDec)) {\\n                    validYValues.add(yDec);\\n                }\\n            }\\n            \\n            // now add all combinations\\n            for (String x : validXValues) {\\n                for (String y : validYValues) {\\n                    result.add(\"(\" + x + \", \" + y + \")\");\\n                }\\n            }\\n            \\n        }\\n        return result;\\n    }\\n    \\n    public boolean isValid(String s) {\\n        if (s.length() < 1) {\\n            return false;\\n        } else if (s.length() == 1){\\n            return true;\\n        }\\n        if (s.charAt(0) == \\'0\\') {\\n            // starts with zero, so needs to have a dot right after it\\n            if (s.charAt(1) != \\'.\\') {\\n                return false;\\n            }\\n        }\\n        // if decimal, it cannot end with a 0\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (s.charAt(i) == \\'.\\') {                \\n                if (s.charAt(s.length() - 1) == \\'0\\') {\\n                    return false;\\n                }\\n                break;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207325,
                "title": "go-beats-100-runtime-and-memory",
                "content": "```go\\nfunc ambiguousCoordinates(s string) []string {\\n    result := []string{}\\n    var helper func(first string, second string)\\n    \\n    helper = func (first string, second string) {\\n        for i := 0; i < len(first); i++ {\\n            newF := first\\n            if i > 0 {\\n                newF = first[0:i] + \".\" + first[i:]\\n            }\\n            if (!isValid(newF)) {\\n                continue\\n            }\\n            for j := 0; j < len(second); j++  {\\n                newS := second\\n                if j > 0 {\\n                    newS = second[0:j] + \".\" + second[j:]\\n                }\\n                \\n                if !isValid(newS) {\\n                    continue\\n                }\\n                \\n                result = append(result, \"(\" + newF + \", \" + newS + \")\")\\n            }\\n        }\\n    }\\n    \\n    for i := 2; i < len(s) -1; i++ {\\n        helper(s[1:i], s[i:len(s) -1])\\n    }\\n    \\n    return result\\n}\\n\\n//  validate if a string is a valid cordinate.\\nfunc isValid(s string) bool {\\n    if len(s) < 2 {\\n        return true\\n    }\\n    \\n    decimalCount := 0;\\n    numberCount := 0;\\n    for i := 0; i < len(s); i++ {\\n        if s[i] >= \\'1\\' && s[i] <= \\'9\\' {\\n            numberCount++\\n        }\\n        \\n        if s[i] == \\'.\\'{\\n            numberCount = 0\\n            decimalCount++\\n        }\\n        \\n\\t\\t// fail early if he first character is 0 and the secod character is not \\'.\\'\\n        if i == 1 && decimalCount == 0 && s[0] == \\'0\\' {\\n            return false;\\n        }\\n    }\\n    \\n    return (numberCount > 0 && decimalCount == 0) || (decimalCount > 0 && s[len(s) -1] != \\'0\\');\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc ambiguousCoordinates(s string) []string {\\n    result := []string{}\\n    var helper func(first string, second string)\\n    \\n    helper = func (first string, second string) {\\n        for i := 0; i < len(first); i++ {\\n            newF := first\\n            if i > 0 {\\n                newF = first[0:i] + \".\" + first[i:]\\n            }\\n            if (!isValid(newF)) {\\n                continue\\n            }\\n            for j := 0; j < len(second); j++  {\\n                newS := second\\n                if j > 0 {\\n                    newS = second[0:j] + \".\" + second[j:]\\n                }\\n                \\n                if !isValid(newS) {\\n                    continue\\n                }\\n                \\n                result = append(result, \"(\" + newF + \", \" + newS + \")\")\\n            }\\n        }\\n    }\\n    \\n    for i := 2; i < len(s) -1; i++ {\\n        helper(s[1:i], s[i:len(s) -1])\\n    }\\n    \\n    return result\\n}\\n\\n//  validate if a string is a valid cordinate.\\nfunc isValid(s string) bool {\\n    if len(s) < 2 {\\n        return true\\n    }\\n    \\n    decimalCount := 0;\\n    numberCount := 0;\\n    for i := 0; i < len(s); i++ {\\n        if s[i] >= \\'1\\' && s[i] <= \\'9\\' {\\n            numberCount++\\n        }\\n        \\n        if s[i] == \\'.\\'{\\n            numberCount = 0\\n            decimalCount++\\n        }\\n        \\n\\t\\t// fail early if he first character is 0 and the secod character is not \\'.\\'\\n        if i == 1 && decimalCount == 0 && s[0] == \\'0\\' {\\n            return false;\\n        }\\n    }\\n    \\n    return (numberCount > 0 && decimalCount == 0) || (decimalCount > 0 && s[len(s) -1] != \\'0\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1207314,
                "title": "concise-java-solution-with-explanation-beats-100-in-runtime",
                "content": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> coordinates=new ArrayList<String>();\\n        //take out the \\'(\\' and \\')\\'\\n        String digits=s.substring(1,s.length()-1);\\n        \\n        //breaking the string up in two parts in all possible ways\\n        for(int i=1;i<digits.length();++i) {\\n            \\n            //check if the first part can form any valid numbers\\n            List<String> vn1=validNumbers(digits.substring(0, i));\\n            //skip the rest is 1st part is not valid\\n            if(vn1.size()==0) {\\n                continue;\\n            }\\n            //check if 2nd part can form any valid numners\\n            List<String> vn2=validNumbers(digits.substring(i));\\n            \\n            //form all combinations of valid numbers from 1st and 2nd part\\n            for(String d1:vn1) {\\n                for(String d2:vn2) {\\n                    coordinates.add(\"(\"+d1+\", \"+d2+\")\");\\n                }\\n            }\\n        }\\n        return coordinates;    \\n    }\\n    \\n    //method to check is a string can form any valid numbers\\n    public List<String> validNumbers(String str)\\n    {  \\n        List<String> validNumbers=new ArrayList<String>();\\n        //note: we won\\'t pass in any empty strings\\n        if(str.length()==1) { //any string with only 1 digit is a valid number, like 0, 1, or 8\\n            validNumbers.add(str);\\n        }\\n        else if(str.charAt(0)==\\'0\\') { //str has more then 1 digit when we reach this case \\n            //if the 1st digit is 0, it has to be a dismal number, so it\\'s only valid if it does not end with 0\\n            //for example, 0.0 or 0.10 are not valid\\n            if(str.charAt(str.length()-1)!=\\'0\\') {\\n                validNumbers.add(\"0.\"+str.substring(1));\\n            }\\n        }\\n        else {           \\n            //we have at least one valid number at this point like 123, or 100\\n            validNumbers.add(str);\\n            //we can insert a decimal point between digits to get a new valid number \\n            //as long as the number doe snot end with a 0.\\n            //for example, 123 can be 1.23, 12.3 but 1230 can not be a decimal number\\n            if(str.charAt(str.length()-1)!=\\'0\\') {\\n                for(int i=1;i<str.length();++i)  {\\n                    validNumbers.add(str.substring(0, i)+\".\"+str.substring(i));\\n                }\\n            }\\n        }\\n        return validNumbers;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> coordinates=new ArrayList<String>();\\n        //take out the \\'(\\' and \\')\\'\\n        String digits=s.substring(1,s.length()-1);\\n        \\n        //breaking the string up in two parts in all possible ways\\n        for(int i=1;i<digits.length();++i) {\\n            \\n            //check if the first part can form any valid numbers\\n            List<String> vn1=validNumbers(digits.substring(0, i));\\n            //skip the rest is 1st part is not valid\\n            if(vn1.size()==0) {\\n                continue;\\n            }\\n            //check if 2nd part can form any valid numners\\n            List<String> vn2=validNumbers(digits.substring(i));\\n            \\n            //form all combinations of valid numbers from 1st and 2nd part\\n            for(String d1:vn1) {\\n                for(String d2:vn2) {\\n                    coordinates.add(\"(\"+d1+\", \"+d2+\")\");\\n                }\\n            }\\n        }\\n        return coordinates;    \\n    }\\n    \\n    //method to check is a string can form any valid numbers\\n    public List<String> validNumbers(String str)\\n    {  \\n        List<String> validNumbers=new ArrayList<String>();\\n        //note: we won\\'t pass in any empty strings\\n        if(str.length()==1) { //any string with only 1 digit is a valid number, like 0, 1, or 8\\n            validNumbers.add(str);\\n        }\\n        else if(str.charAt(0)==\\'0\\') { //str has more then 1 digit when we reach this case \\n            //if the 1st digit is 0, it has to be a dismal number, so it\\'s only valid if it does not end with 0\\n            //for example, 0.0 or 0.10 are not valid\\n            if(str.charAt(str.length()-1)!=\\'0\\') {\\n                validNumbers.add(\"0.\"+str.substring(1));\\n            }\\n        }\\n        else {           \\n            //we have at least one valid number at this point like 123, or 100\\n            validNumbers.add(str);\\n            //we can insert a decimal point between digits to get a new valid number \\n            //as long as the number doe snot end with a 0.\\n            //for example, 123 can be 1.23, 12.3 but 1230 can not be a decimal number\\n            if(str.charAt(str.length()-1)!=\\'0\\') {\\n                for(int i=1;i<str.length();++i)  {\\n                    validNumbers.add(str.substring(0, i)+\".\"+str.substring(i));\\n                }\\n            }\\n        }\\n        return validNumbers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207291,
                "title": "c-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public IList<string> AmbiguousCoordinates(string s) {\\n        \\n        s = s.TrimStart(\\'(\\').TrimEnd(\\')\\');\\n        \\n        IList<string> res = new List<string>();\\n        \\n        for(int i = 0; i<s.Length - 1; i++) {\\n            string str = s.Substring(0, i+1) + \",\" + s.Substring(i+1);\\n            \\n            if(ContainsAllZeros(str, out string[] arr)) continue;\\n            \\n            var lft = BuildDecimalNumber(arr[0]);\\n            var rght = BuildDecimalNumber(arr[1]);\\n            \\n            for(int j = 0; j < lft.Count(); j++) {\\n                for(int k = 0; k < rght.Count(); k++) {\\n                    res.Add(\"(\" + lft[j] + \", \" + rght[k] + \")\");\\n                }\\n            }\\n            \\n        }\\n        return res.Distinct().ToList();\\n    }\\n    \\n    public bool ContainsAllZeros(string str, out string[] arr) {\\n        arr = str.Split(\",\");\\n        bool  a = false, b = false;\\n        \\n        if(arr[0].Length > 1)\\n            a = arr[0].All(x => x == \\'0\\');\\n        if(arr[1].Length > 1)\\n            b = arr[1].All(x => x == \\'0\\');\\n            \\n        return a || b ; \\n    }\\n    \\n    public List<string> BuildDecimalNumber(string s) {\\n        \\n        List<string> lst = new List<string>();\\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        if(s[0] != \\'0\\') lst.Add(s);\\n        \\n        if(s.Length == 1) {\\n            lst.Add(s);\\n            return lst;\\n        }\\n        \\n        for(int i = 1; i<s.Length; i++) {\\n            sb.Insert(i, \\'.\\');\\n            if(!IsLeadingZeros(sb.ToString())) lst.Add(sb.ToString());\\n            sb.Remove(i, 1);\\n        }\\n        \\n        return lst;\\n    }\\n    \\n    public bool IsLeadingZeros(string s) {\\n        var arr = s.Split(\\'.\\');\\n        if((arr[0].Length > 1 && s[0] == \\'0\\') ||  arr[1].All(x => x == \\'0\\') \\n           || arr[1].Last() == \\'0\\') \\n            return true;\\n        return false;\\n    }\\n}\\n```****",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> AmbiguousCoordinates(string s) {\\n        \\n        s = s.TrimStart(\\'(\\').TrimEnd(\\')\\');\\n        \\n        IList<string> res = new List<string>();\\n        \\n        for(int i = 0; i<s.Length - 1; i++) {\\n            string str = s.Substring(0, i+1) + \",\" + s.Substring(i+1);\\n            \\n            if(ContainsAllZeros(str, out string[] arr)) continue;\\n            \\n            var lft = BuildDecimalNumber(arr[0]);\\n            var rght = BuildDecimalNumber(arr[1]);\\n            \\n            for(int j = 0; j < lft.Count(); j++) {\\n                for(int k = 0; k < rght.Count(); k++) {\\n                    res.Add(\"(\" + lft[j] + \", \" + rght[k] + \")\");\\n                }\\n            }\\n            \\n        }\\n        return res.Distinct().ToList();\\n    }\\n    \\n    public bool ContainsAllZeros(string str, out string[] arr) {\\n        arr = str.Split(\",\");\\n        bool  a = false, b = false;\\n        \\n        if(arr[0].Length > 1)\\n            a = arr[0].All(x => x == \\'0\\');\\n        if(arr[1].Length > 1)\\n            b = arr[1].All(x => x == \\'0\\');\\n            \\n        return a || b ; \\n    }\\n    \\n    public List<string> BuildDecimalNumber(string s) {\\n        \\n        List<string> lst = new List<string>();\\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        if(s[0] != \\'0\\') lst.Add(s);\\n        \\n        if(s.Length == 1) {\\n            lst.Add(s);\\n            return lst;\\n        }\\n        \\n        for(int i = 1; i<s.Length; i++) {\\n            sb.Insert(i, \\'.\\');\\n            if(!IsLeadingZeros(sb.ToString())) lst.Add(sb.ToString());\\n            sb.Remove(i, 1);\\n        }\\n        \\n        return lst;\\n    }\\n    \\n    public bool IsLeadingZeros(string s) {\\n        var arr = s.Split(\\'.\\');\\n        if((arr[0].Length > 1 && s[0] == \\'0\\') ||  arr[1].All(x => x == \\'0\\') \\n           || arr[1].Last() == \\'0\\') \\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207284,
                "title": "python-addressing-edge-cases",
                "content": "class Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\n        def gen(a):\\n            \\n            if len(a) == 1:\\n                return [a]\\n            \\n            if a[0] == \\'0\\' and a[-1] == \\'0\\':\\n                return []\\n            \\n            if a[0] == \\'0\\' and a[-1] != \\'0\\':\\n                return [\\'0.\\' + a[1:]]\\n            \\n            if a[0] != \\'0\\' and a[-1] == \\'0\\':\\n                return [a]\\n            \\n            # if a[0] != \\'0\\' and a[-1] !=\\'0\\' append itself and dot separated ones\\n            comb = [a]\\n            for i in range(1,len(a)):\\n                comb.append(a[:i] + \\'.\\' + a[i:])\\n            \\n            return comb \\n            \\n        \\n        res = []\\n        for i in range(2, len(s)-1):\\n            left, right = gen(s[1:i]), gen(s[i:-1])\\n            for l in left:\\n                for r in right:\\n                    res.append(\\'(\\'+ l + \\', \\' + r + \\')\\')\\n        return res \\n    \\n    \\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\n        def gen(a):\\n            \\n            if len(a) == 1:\\n                return [a]\\n            \\n            if a[0] == \\'0\\' and a[-1] == \\'0\\':\\n                return []\\n            \\n            if a[0] == \\'0\\' and a[-1] != \\'0\\':\\n                return [\\'0.\\' + a[1:]]\\n            \\n            if a[0] != \\'0\\' and a[-1] == \\'0\\':\\n                return [a]\\n            \\n            # if a[0] != \\'0\\' and a[-1] !=\\'0\\' append itself and dot separated ones\\n            comb = [a]\\n            for i in range(1,len(a)):\\n                comb.append(a[:i] + \\'.\\' + a[i:])\\n            \\n            return comb \\n            \\n        \\n        res = []\\n        for i in range(2, len(s)-1):\\n            left, right = gen(s[1:i]), gen(s[i:-1])\\n            for l in left:\\n                for r in right:\\n                    res.append(\\'(\\'+ l + \\', \\' + r + \\')\\')\\n        return res \\n    \\n    \\n",
                "codeTag": "Java"
            },
            {
                "id": 1207280,
                "title": "java-backtracking",
                "content": "A bit convoluted, but it works.\\n\\n```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> result = new ArrayList<>();\\n        ambiguousCoordinates(\\n            s.substring(1, s.length() - 1), 0, \"\", result, -1, -1);   \\n        return result;\\n    }\\n    \\n    private void ambiguousCoordinates(\\n            String s, int index, String candidate, List<String> result,\\n            int periodAdded, int commaAdded) {\\n        if (index >= s.length()) {\\n            char last = candidate.charAt(candidate.length() - 1);\\n            if (commaAdded >= 0\\n                    && Character.isDigit(last)\\n                    && (periodAdded < 0 || last != \\'0\\')) {\\n                result.add(\\'(\\' + candidate + \\')\\');\\n            }\\n            return;\\n        }\\n        \\n        char c = s.charAt(index); \\n        candidate += c;\\n        if (periodAdded < 0) {\\n            ambiguousCoordinates(\\n                s, index + 1, candidate + \\'.\\', result, candidate.length(), commaAdded);\\n        }\\n        if (commaAdded < 0 && (periodAdded < 0 || c != \\'0\\')) {\\n            // note that this resets index for periodAdded back to -1\\n            // so that period can be added again after comma\\n            ambiguousCoordinates(\\n                s, index + 1, candidate + \", \", result, -1, candidate.length());\\n        }\\n        if (c != \\'0\\' || index == s.length() - 1 \\n            || (index > 0 && \\n                (commaAdded < 0 || candidate.charAt(candidate.length() - 3) != \\',\\')))\\n        {\\n            ambiguousCoordinates(s, index + 1, candidate, result, periodAdded, commaAdded);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> result = new ArrayList<>();\\n        ambiguousCoordinates(\\n            s.substring(1, s.length() - 1), 0, \"\", result, -1, -1);   \\n        return result;\\n    }\\n    \\n    private void ambiguousCoordinates(\\n            String s, int index, String candidate, List<String> result,\\n            int periodAdded, int commaAdded) {\\n        if (index >= s.length()) {\\n            char last = candidate.charAt(candidate.length() - 1);\\n            if (commaAdded >= 0\\n                    && Character.isDigit(last)\\n                    && (periodAdded < 0 || last != \\'0\\')) {\\n                result.add(\\'(\\' + candidate + \\')\\');\\n            }\\n            return;\\n        }\\n        \\n        char c = s.charAt(index); \\n        candidate += c;\\n        if (periodAdded < 0) {\\n            ambiguousCoordinates(\\n                s, index + 1, candidate + \\'.\\', result, candidate.length(), commaAdded);\\n        }\\n        if (commaAdded < 0 && (periodAdded < 0 || c != \\'0\\')) {\\n            // note that this resets index for periodAdded back to -1\\n            // so that period can be added again after comma\\n            ambiguousCoordinates(\\n                s, index + 1, candidate + \", \", result, -1, candidate.length());\\n        }\\n        if (c != \\'0\\' || index == s.length() - 1 \\n            || (index > 0 && \\n                (commaAdded < 0 || candidate.charAt(candidate.length() - 3) != \\',\\')))\\n        {\\n            ambiguousCoordinates(s, index + 1, candidate, result, periodAdded, commaAdded);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207261,
                "title": "ambigous-coordinates-java-modular-approach",
                "content": "class Solution {\\n    \\n    List<String> ans = new ArrayList<>();\\n    \\n    public List<String> ambiguousCoordinates(String s) { // main function\\n        \\n        s = s.substring(1,s.length()-1);\\n        \\n        for(int i=1;i<s.length();i++)\\n            solve(s.substring(0,i),s.substring(i));\\n                \\n        return ans;\\n    }\\n    \\n    public void solve(String left,String right) { // this functions tries to form all pairs of x,y coordinates\\n        \\n        List<String> left_dots = convert(left);\\n        List<String> right_dots = convert(right);\\n        \\n        for(String left_part_dot : left_dots) {\\n            if(isValid(left_part_dot)) {\\n                \\n                for(String right_part_dot : right_dots ) {\\n                    \\n                    if(isValid(right_part_dot)) {\\n                        \\n                        ans.add(\"(\" + left_part_dot + \", \" + right_part_dot + \")\");\\n                        \\n                    }\\n                }   \\n            }\\n        } \\n    }\\n    \\n    public List<String> convert(String s) { // this method just keeps dots at n-1 places\\n        \\n        List<String> tmp = new ArrayList<>();\\n        tmp.add(s);\\n        \\n        for(int i=1;i<s.length();i++) {\\n            tmp.add(s.substring(0,i) + \".\" + s.substring(i));\\n        }\\n\\n        return tmp;\\n    }\\n    \\n    public boolean isValid(String s) { // this method checks if the formed dot is valid or not.\\n        \\n        if(s.contains(\".\")) {\\n            \\n            String []part = s.split(\"\\\\\\\\.\");\\n            \\n            if(!part[0].equals(\"0\") && part[0].startsWith(\"0\")) return false;\\n            \\n            else return !part[1].endsWith(\"0\"); \\n            \\n        }\\n        else {\\n            \\n            if(s.equals(\"0\")) return true;\\n            \\n            else return !s.startsWith(\"0\");\\n            \\n        }   \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    List<String> ans = new ArrayList<>();\\n    \\n    public List<String> ambiguousCoordinates(String s) { // main function\\n        \\n        s = s.substring(1,s.length()-1);\\n        \\n        for(int i=1;i<s.length();i++)\\n            solve(s.substring(0,i),s.substring(i));\\n                \\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1207188,
                "title": "python-itertools-product-clean-code",
                "content": "```\\nfrom itertools import product\\n\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\n        def get_result_by_split(left: str, right: str) -> List[str]:\\n            sub = []\\n            left_perm = get_decimal_perm(left)\\n            right_perm = get_decimal_perm(right)\\n            if left_perm and right_perm:\\n                perm = product(left_perm, right_perm)\\n                sub.extend([f\\'({t[0]}, {t[1]})\\' for t in perm])\\n            return sub\\n        \\n        def get_decimal_perm(num: str) -> List[str]:\\n            if len(num) == 1:\\n                return [num]\\n            if num[0] == \\'0\\' and num[-1] == \\'0\\':\\n                return []\\n            if num[0] == \\'0\\':\\n                return [f\\'{num[0]}.{num[1:]}\\']\\n            if num[-1] == \\'0\\':\\n                return [num]\\n            return [f\\'{num[:n]}.{num[n:]}\\' for n in range(1, len(num))] + [num]\\n        \\n        res = []\\n        for i in range(2, len(s)-1):\\n            left, right = s[1:i], s[i:len(s)-1]\\n            res.extend(get_result_by_split(left, right))\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import product\\n\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        \\n        def get_result_by_split(left: str, right: str) -> List[str]:\\n            sub = []\\n            left_perm = get_decimal_perm(left)\\n            right_perm = get_decimal_perm(right)\\n            if left_perm and right_perm:\\n                perm = product(left_perm, right_perm)\\n                sub.extend([f\\'({t[0]}, {t[1]})\\' for t in perm])\\n            return sub\\n        \\n        def get_decimal_perm(num: str) -> List[str]:\\n            if len(num) == 1:\\n                return [num]\\n            if num[0] == \\'0\\' and num[-1] == \\'0\\':\\n                return []\\n            if num[0] == \\'0\\':\\n                return [f\\'{num[0]}.{num[1:]}\\']\\n            if num[-1] == \\'0\\':\\n                return [num]\\n            return [f\\'{num[:n]}.{num[n:]}\\' for n in range(1, len(num))] + [num]\\n        \\n        res = []\\n        for i in range(2, len(s)-1):\\n            left, right = s[1:i], s[i:len(s)-1]\\n            res.extend(get_result_by_split(left, right))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207183,
                "title": "python-elongated-every-case-checking-and-generating-string-on-basis-of-every-case",
                "content": "Okay it took me 4 H to work on this lol.\\nbut hope you can see everycase in this.\\n\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        #three choices add a ./_/nothing\\n        # we cannot add after a gap after last element is zero after a decimal\\n        #check decimal occured\\n        #if we are adding a gap we can make the decimal occured false\\n        #cannot add another 0 if decimal is not occured and last element is 0\\n        #cannot add more than one gap\\n        #check gap added\\n        \\n        #decimal occured\\n        #gap occured\\n        #if decimal occured we cannot add another decimal\\n        q=deque()\\n            \\n        q.append((s[1],False,False,0))\\n        a=set()\\n        s = s[1:-1]\\n        while q:\\n            st,gapocc,decimalocc,li = q.popleft()\\n            st2=st\\n            st = st.split(\\' \\')[-1]\\n            if li==len(s)-1:\\n                ss = st2.split(\\' \\')\\n                if len(ss)==2:\\n                    a.add(\\'(\\'+ss[0]+\\', \\'+ss[1]+\\')\\')\\n                continue\\n            ch = s[li+1]\\n            lch = st[-1]\\n            \\n            \\n            if li==len(s)-2:\\n                if decimalocc==False and gapocc:\\n                    if ch!=\\'0\\':\\n                        q.append((st2+\\'.\\'+ch,gapocc,True,li+1))\\n                        \\n                    if float(st)!=0:\\n                        q.append((st2+ch,gapocc,decimalocc,li+1))\\n                    continue\\n                if decimalocc and gapocc:\\n                    if ch==\\'0\\':\\n                        continue\\n                    else:\\n                        q.append((st2+ch,gapocc,decimalocc,li+1))\\n                    continue\\n                if gapocc==False and decimalocc:\\n                    #if gap not made len of st>1\\n                    if lch!=\\'0\\':                            \\n                        q.append((st2+\\' \\'+ch,True,decimalocc,li+1))\\n                        continue\\n                if not decimalocc and not gapocc:\\n                    q.append((st2+\\' \\'+ch,True,decimalocc,li+1))\\n                    continue\\n                    \\n            if decimalocc==False and gapocc:\\n                q.append((st2+\\'.\\'+ch,gapocc,True,li+1))\\n                if float(st)!=0:\\n                    q.append((st2+ch,gapocc,decimalocc,li+1))\\n            if decimalocc and gapocc==False:\\n                if lch!=\\'0\\':\\n                    q.append((st2+\\' \\'+ch,True,False,li+1))\\n                q.append((st2+ch,gapocc,decimalocc,li+1))\\n            if decimalocc and gapocc:\\n                q.append((st2+ch,gapocc,decimalocc,li+1))\\n            if not decimalocc and not gapocc:\\n                if float(st)!=0:\\n                    q.append((st2+ch,gapocc,decimalocc,li+1))\\n                q.append((st2+\\' \\'+ch,True,False,li+1))\\n                q.append((st2+\\'.\\'+ch,gapocc,True,li+1))\\n                \\n        return a\\n        pass\\n                \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "Okay it took me 4 H to work on this lol.\\nbut hope you can see everycase in this.\\n\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        #three choices add a ./_/nothing\\n        # we cannot add after a gap after last element is zero after a decimal\\n        #check decimal occured\\n        #if we are adding a gap we can make the decimal occured false\\n        #cannot add another 0 if decimal is not occured and last element is 0\\n        #cannot add more than one gap\\n        #check gap added\\n        \\n        #decimal occured\\n        #gap occured\\n        #if decimal occured we cannot add another decimal\\n        q=deque()\\n            \\n        q.append((s[1],False,False,0))\\n        a=set()\\n        s = s[1:-1]\\n        while q:\\n            st,gapocc,decimalocc,li = q.popleft()\\n            st2=st\\n            st = st.split(\\' \\')[-1]\\n            if li==len(s)-1:\\n                ss = st2.split(\\' \\')\\n                if len(ss)==2:\\n                    a.add(\\'(\\'+ss[0]+\\', \\'+ss[1]+\\')\\')\\n                continue\\n            ch = s[li+1]\\n            lch = st[-1]\\n            \\n            \\n            if li==len(s)-2:\\n                if decimalocc==False and gapocc:\\n                    if ch!=\\'0\\':\\n                        q.append((st2+\\'.\\'+ch,gapocc,True,li+1))\\n                        \\n                    if float(st)!=0:\\n                        q.append((st2+ch,gapocc,decimalocc,li+1))\\n                    continue\\n                if decimalocc and gapocc:\\n                    if ch==\\'0\\':\\n                        continue\\n                    else:\\n                        q.append((st2+ch,gapocc,decimalocc,li+1))\\n                    continue\\n                if gapocc==False and decimalocc:\\n                    #if gap not made len of st>1\\n                    if lch!=\\'0\\':                            \\n                        q.append((st2+\\' \\'+ch,True,decimalocc,li+1))\\n                        continue\\n                if not decimalocc and not gapocc:\\n                    q.append((st2+\\' \\'+ch,True,decimalocc,li+1))\\n                    continue\\n                    \\n            if decimalocc==False and gapocc:\\n                q.append((st2+\\'.\\'+ch,gapocc,True,li+1))\\n                if float(st)!=0:\\n                    q.append((st2+ch,gapocc,decimalocc,li+1))\\n            if decimalocc and gapocc==False:\\n                if lch!=\\'0\\':\\n                    q.append((st2+\\' \\'+ch,True,False,li+1))\\n                q.append((st2+ch,gapocc,decimalocc,li+1))\\n            if decimalocc and gapocc:\\n                q.append((st2+ch,gapocc,decimalocc,li+1))\\n            if not decimalocc and not gapocc:\\n                if float(st)!=0:\\n                    q.append((st2+ch,gapocc,decimalocc,li+1))\\n                q.append((st2+\\' \\'+ch,True,False,li+1))\\n                q.append((st2+\\'.\\'+ch,gapocc,True,li+1))\\n                \\n        return a\\n        pass\\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 1207108,
                "title": "easy-to-understand-java-solution-slow",
                "content": "```\\n/**\\nPseudo code:\\nGiven string: abcdef\\nabcd | ef\\n\\nfor i is position which divides the string into two substrings\\n    first string\\n    second string\\n    for every possible first string with . (or without) f1\\n        for every possible second string with . (or without) s1\\n            add (f1, s1)\\n\\n\\n*/\\n```\\n\\n\\n```\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    \\n    public List<String> ambiguousCoordinates(String s) {\\n        \\n        String sub = s.substring(1, s.length() - 1);\\n        for(int i= 0; i<sub.length(); i++) {\\n            String first = sub.substring(0, i);\\n            String second = sub.substring(i);\\n            \\n            for(String f1: valids(first)) {\\n                for(String s1:   valids(second)) {\\n                    ans.add(String.format(\"(%s, %s)\", f1, s1));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    // return list of strings without or without .\\n    List<String> valids(String str) {\\n        if(str.isEmpty()) return Arrays.asList();\\n        \\n        if(str.length() == 1) {\\n            return Arrays.asList(str);\\n        }\\n        \\n        List<String> lst = new ArrayList<>();\\n        if(str.charAt(0) == \\'0\\'){\\n            if(Integer.valueOf(str) == 0) return Arrays.asList();\\n            if(str.charAt(str.length()-1) == \\'0\\') return Arrays.asList();\\n            lst.add(String.format(\"%s.%s\", 0, str.substring(1)));\\n        } else {\\n            for(int i=0; i<str.length(); i++){\\n                String fst = str.substring(0, i);\\n                String second = str.substring(i);\\n                \\n                if(fst.isEmpty() || second.isEmpty()) continue;\\n                // x.0 is not permitted\\n                if(Integer.valueOf(second) == 0) {\\n                    continue;\\n                }\\n                // x.y0 is not permitted\\n                if(second.length() > 1 && second.charAt(second.length() -1 ) == \\'0\\') continue;\\n                lst.add(String.format(\"%s.%s\", fst, second));\\n            }\\n            lst.add(str);\\n        }\\n        return lst;\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\nPseudo code:\\nGiven string: abcdef\\nabcd | ef\\n\\nfor i is position which divides the string into two substrings\\n    first string\\n    second string\\n    for every possible first string with . (or without) f1\\n        for every possible second string with . (or without) s1\\n            add (f1, s1)\\n\\n\\n*/\\n```\n```\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    \\n    public List<String> ambiguousCoordinates(String s) {\\n        \\n        String sub = s.substring(1, s.length() - 1);\\n        for(int i= 0; i<sub.length(); i++) {\\n            String first = sub.substring(0, i);\\n            String second = sub.substring(i);\\n            \\n            for(String f1: valids(first)) {\\n                for(String s1:   valids(second)) {\\n                    ans.add(String.format(\"(%s, %s)\", f1, s1));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    // return list of strings without or without .\\n    List<String> valids(String str) {\\n        if(str.isEmpty()) return Arrays.asList();\\n        \\n        if(str.length() == 1) {\\n            return Arrays.asList(str);\\n        }\\n        \\n        List<String> lst = new ArrayList<>();\\n        if(str.charAt(0) == \\'0\\'){\\n            if(Integer.valueOf(str) == 0) return Arrays.asList();\\n            if(str.charAt(str.length()-1) == \\'0\\') return Arrays.asList();\\n            lst.add(String.format(\"%s.%s\", 0, str.substring(1)));\\n        } else {\\n            for(int i=0; i<str.length(); i++){\\n                String fst = str.substring(0, i);\\n                String second = str.substring(i);\\n                \\n                if(fst.isEmpty() || second.isEmpty()) continue;\\n                // x.0 is not permitted\\n                if(Integer.valueOf(second) == 0) {\\n                    continue;\\n                }\\n                // x.y0 is not permitted\\n                if(second.length() > 1 && second.charAt(second.length() -1 ) == \\'0\\') continue;\\n                lst.add(String.format(\"%s.%s\", fst, second));\\n            }\\n            lst.add(str);\\n        }\\n        return lst;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207014,
                "title": "php-3-step-approach",
                "content": "12 ms 15.7 MB\\n\\nNot a particularly sophisticated problem, just tedious.\\n\\nWe start with a bunch of digits, and start with the fact that we need to split them into 2 groups of 1 or more digits each.\\n\\n#### Phase 1 - Find the next valid pair of groups of digits\\n- Split the digits into 2 groups, starting with 1 digit on the left and everything else on the right, then shifting digits left until only 1 digit is on the right.\\n- For each group, the following patterns are valid:\\n\\t- 1 digit is valid\\n\\t- Any grouping with 1-9 on either the left or right or both is valid.\\n- If both groups are valid, move onto phase 2.\\n#### Phase 2 - Get all the valid decimal locations for each group.\\n- A group of 1 digit has a single non-decimal pattern.\\n- A group ending in 0 also has a single non-decimal pattern (otherwise you have trailing 0 fractions).\\n- A group starting in 0 has a single pattern starting with `0.`.\\n- Everything else has a non-decimal pattern plus everything from `x.xx ... x` to `x ... xx.x`\\n#### Phase 3 - Combine\\n- Concatenate each pattern from the first group with each pattern from the second group as `(p1, p2)` and add it. to the result.\\n\\n```\\nclass Solution \\n{\\n\\n    private function validateGroup(array &$s, int $start, int $end): bool\\n    {\\n        /* Allow multiple consecutive 0\\'s only if the first or last digit is not a 0. */\\n        if($start == $end)\\n            return true;\\n        return($s[$start] != \\'0\\'  ||  $s[$end] != \\'0\\');\\n    }\\n\\n    private function getDecimalStrings(array &$arr, int $start, int $end): array\\n    {\\n        /*\\n            - Single digit: no decimal\\n            - Trailing 0: no decimal.\\n            - Leading 0: decimal after first digit only.\\n            - Otherwise, no decimal, followed by decimals until before last digit. \\n        */\\n        $digitStr = substr(implode(\\'\\',$arr), $start, 1+$end-$start);\\n        $group = [$digitStr];\\n        if($start == $end)\\n            return $group;\\n        if($digitStr[$end-$start] == \\'0\\')\\n            return $group;\\n        if($digitStr[0] == \\'0\\')\\n            return [\\'0.\\'.substr($digitStr, 1)];\\n\\n        $decStr = \\'.\\'.$digitStr;\\n        for($dec=1; $dec<=$end-$start; $dec++)\\n        {\\n            $tmp = $decStr[$dec-1];\\n            $decStr[$dec-1] = $decStr[$dec];\\n            $decStr[$dec] = $tmp;\\n            $group[] = $decStr;\\n        }\\n        \\n        return $group;\\n    }\\n    \\n    /**\\n     * @param String $s\\n     * @return String[]\\n     */\\n    function ambiguousCoordinates($s) \\n    {\\n        $digits = [];\\n        $last = strlen($s)-2;\\n        for($i=1; $i<=$last; $i++)\\n            $digits[] = $s[$i];\\n        \\n        /* Try each valid group. */\\n        $groups = [];\\n        for($i=1; $i<$last; $i++)\\n        {\\n            /* 0\\'s are allowed on both ends only for 0 itself. */\\n            if(!$this->validateGroup($digits,0,$i-1))\\n                continue;\\n            if(!$this->validateGroup($digits,$i,$last-1))\\n                continue;\\n            \\n            /* Get each valid decimal position within each group. */\\n            $g1 = $this->getDecimalStrings($digits, 0, $i-1);\\n            $g2 = $this->getDecimalStrings($digits, $i, $last-1);\\n            for($j=0; $j<count($g1); $j++)\\n            {\\n                for($k=0; $k<count($g2); $k++)\\n                {\\n                    $groups[] = \"(\".$g1[$j].\", \".$g2[$k].\")\";\\n                }\\n            }\\n            \\n        }\\n\\n        return $groups;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n\\n    private function validateGroup(array &$s, int $start, int $end): bool\\n    {\\n        /* Allow multiple consecutive 0\\'s only if the first or last digit is not a 0. */\\n        if($start == $end)\\n            return true;\\n        return($s[$start] != \\'0\\'  ||  $s[$end] != \\'0\\');\\n    }\\n\\n    private function getDecimalStrings(array &$arr, int $start, int $end): array\\n    {\\n        /*\\n            - Single digit: no decimal\\n            - Trailing 0: no decimal.\\n            - Leading 0: decimal after first digit only.\\n            - Otherwise, no decimal, followed by decimals until before last digit. \\n        */\\n        $digitStr = substr(implode(\\'\\',$arr), $start, 1+$end-$start);\\n        $group = [$digitStr];\\n        if($start == $end)\\n            return $group;\\n        if($digitStr[$end-$start] == \\'0\\')\\n            return $group;\\n        if($digitStr[0] == \\'0\\')\\n            return [\\'0.\\'.substr($digitStr, 1)];\\n\\n        $decStr = \\'.\\'.$digitStr;\\n        for($dec=1; $dec<=$end-$start; $dec++)\\n        {\\n            $tmp = $decStr[$dec-1];\\n            $decStr[$dec-1] = $decStr[$dec];\\n            $decStr[$dec] = $tmp;\\n            $group[] = $decStr;\\n        }\\n        \\n        return $group;\\n    }\\n    \\n    /**\\n     * @param String $s\\n     * @return String[]\\n     */\\n    function ambiguousCoordinates($s) \\n    {\\n        $digits = [];\\n        $last = strlen($s)-2;\\n        for($i=1; $i<=$last; $i++)\\n            $digits[] = $s[$i];\\n        \\n        /* Try each valid group. */\\n        $groups = [];\\n        for($i=1; $i<$last; $i++)\\n        {\\n            /* 0\\'s are allowed on both ends only for 0 itself. */\\n            if(!$this->validateGroup($digits,0,$i-1))\\n                continue;\\n            if(!$this->validateGroup($digits,$i,$last-1))\\n                continue;\\n            \\n            /* Get each valid decimal position within each group. */\\n            $g1 = $this->getDecimalStrings($digits, 0, $i-1);\\n            $g2 = $this->getDecimalStrings($digits, $i, $last-1);\\n            for($j=0; $j<count($g1); $j++)\\n            {\\n                for($k=0; $k<count($g2); $k++)\\n                {\\n                    $groups[] = \"(\".$g1[$j].\", \".$g2[$k].\")\";\\n                }\\n            }\\n            \\n        }\\n\\n        return $groups;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207004,
                "title": "ruby-o-n-4",
                "content": "```\\n# @param {String} s\\n# @return {String[]}\\ndef ambiguous_coordinates(s)\\n  n = s.length\\n  result = []\\n  \\n  (2...n-1).each do |i|\\n    cand_left = generate(s[1...i])\\n    cand_right = generate(s[i...-1])     \\n    cand_left.product(cand_right).each do |left, right|\\n      result << \"(\" + left + \", \" + right + \")\"\\n    end\\n  end\\n\\n  result\\nend\\n          \\ndef generate(s)\\n  result = []\\n  result << s if s == \"0\" || s[0] != \"0\"\\n\\n  (1...s.length).each do |i|\\n    if (s[0...i] == \"0\" || s[0] != \"0\") && s[-1] != \"0\"\\n      result << s[0...i] + \".\" + s[i..-1]\\n    end\\n  end\\n\\n  result\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} s\\n# @return {String[]}\\ndef ambiguous_coordinates(s)\\n  n = s.length\\n  result = []\\n  \\n  (2...n-1).each do |i|\\n    cand_left = generate(s[1...i])\\n    cand_right = generate(s[i...-1])     \\n    cand_left.product(cand_right).each do |left, right|\\n      result << \"(\" + left + \", \" + right + \")\"\\n    end\\n  end\\n\\n  result\\nend\\n          \\ndef generate(s)\\n  result = []\\n  result << s if s == \"0\" || s[0] != \"0\"\\n\\n  (1...s.length).each do |i|\\n    if (s[0...i] == \"0\" || s[0] != \"0\") && s[-1] != \"0\"\\n      result << s[0...i] + \".\" + s[i..-1]\\n    end\\n  end\\n\\n  result\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1206982,
                "title": "scala-functional-programming-solution",
                "content": "```scala\\nobject Solution {\\n    def ambiguousCoordinates(s: String): List[String] = {\\n        parser.runP(s.toList).map(p => p._1)\\n    }\\n\\n    case class Parser[+A](runP: List[Char] => List[(A, List[Char])]) { self =>\\n        def map[B](f: A => B): Parser[B] = Parser(l => self.runP(l).map {case (a, remaining) => (f(a), remaining)})\\n        def flatMap[B](f: A => Parser[B]): Parser[B] = Parser(l => {\\n            self.runP(l).flatMap {case (a, remaining) => f(a).runP(remaining)}\\n        })\\n    }\\n    \\n    val fail: Parser[Nothing] = Parser(l => Nil)\\n    def pure[A](a: A): Parser[A] = Parser(l => List((a, l)))\\n    val item: Parser[Char] = Parser(l => l match {\\n        case Nil => Nil\\n        case x :: xs => List((x, xs))\\n    })\\n    \\n    def sat(p: Char => Boolean): Parser[Char] = for {\\n        ch <- item\\n        x <- if(p(ch)) pure(ch) else fail\\n    } yield x\\n    \\n    val leftP: Parser[Char] = sat(ch => ch == \\'(\\')\\n    val rightP: Parser[Char] = sat(ch => ch == \\')\\')\\n    \\n    val digit: Parser[Char] = sat(ch => \\'0\\' <= ch && ch <= \\'9\\')\\n    val zero: Parser[Char] = sat(ch => ch == \\'0\\')\\n    val nonzero: Parser[Char] = sat(ch => \\'1\\' <= ch && ch <= \\'9\\')\\n\\n    \\n    def many1(p: Parser[Char]): Parser[List[Char]] = for {\\n        c <- p\\n        cs <- many(p)\\n    } yield c :: cs\\n    \\n    def or[A](p1: Parser[A], p2: Parser[A]): Parser[A] = Parser(l => p1.runP(l) ++ p2.runP(l))\\n    def many(p: Parser[Char]): Parser[List[Char]] = or(many1(p), pure(Nil))\\n    val integer: Parser[String] = or(\\n        zero.map(_.toString),\\n        for {\\n            n <- nonzero\\n            ns <- many(digit)\\n        } yield ((n :: ns).mkString)\\n    )\\n    \\n    val fraction: Parser[String] = for {\\n        ns <- many(digit)\\n        n <- nonzero\\n    } yield (ns ++ List(n)).mkString\\n    \\n    val number: Parser[String] = or(\\n        for {\\n            int <- integer\\n            frac <- fraction\\n        } yield s\"$int.$frac\",\\n        integer\\n    )\\n    \\n    val parser: Parser[String] = for {\\n        _ <- leftP\\n        n1 <- number\\n        n2 <- number\\n        _ <- rightP\\n    } yield s\"($n1, $n2)\"\\n    \\n    \\n\\n}\\n```",
                "solutionTags": [],
                "code": "```scala\\nobject Solution {\\n    def ambiguousCoordinates(s: String): List[String] = {\\n        parser.runP(s.toList).map(p => p._1)\\n    }\\n\\n    case class Parser[+A](runP: List[Char] => List[(A, List[Char])]) { self =>\\n        def map[B](f: A => B): Parser[B] = Parser(l => self.runP(l).map {case (a, remaining) => (f(a), remaining)})\\n        def flatMap[B](f: A => Parser[B]): Parser[B] = Parser(l => {\\n            self.runP(l).flatMap {case (a, remaining) => f(a).runP(remaining)}\\n        })\\n    }\\n    \\n    val fail: Parser[Nothing] = Parser(l => Nil)\\n    def pure[A](a: A): Parser[A] = Parser(l => List((a, l)))\\n    val item: Parser[Char] = Parser(l => l match {\\n        case Nil => Nil\\n        case x :: xs => List((x, xs))\\n    })\\n    \\n    def sat(p: Char => Boolean): Parser[Char] = for {\\n        ch <- item\\n        x <- if(p(ch)) pure(ch) else fail\\n    } yield x\\n    \\n    val leftP: Parser[Char] = sat(ch => ch == \\'(\\')\\n    val rightP: Parser[Char] = sat(ch => ch == \\')\\')\\n    \\n    val digit: Parser[Char] = sat(ch => \\'0\\' <= ch && ch <= \\'9\\')\\n    val zero: Parser[Char] = sat(ch => ch == \\'0\\')\\n    val nonzero: Parser[Char] = sat(ch => \\'1\\' <= ch && ch <= \\'9\\')\\n\\n    \\n    def many1(p: Parser[Char]): Parser[List[Char]] = for {\\n        c <- p\\n        cs <- many(p)\\n    } yield c :: cs\\n    \\n    def or[A](p1: Parser[A], p2: Parser[A]): Parser[A] = Parser(l => p1.runP(l) ++ p2.runP(l))\\n    def many(p: Parser[Char]): Parser[List[Char]] = or(many1(p), pure(Nil))\\n    val integer: Parser[String] = or(\\n        zero.map(_.toString),\\n        for {\\n            n <- nonzero\\n            ns <- many(digit)\\n        } yield ((n :: ns).mkString)\\n    )\\n    \\n    val fraction: Parser[String] = for {\\n        ns <- many(digit)\\n        n <- nonzero\\n    } yield (ns ++ List(n)).mkString\\n    \\n    val number: Parser[String] = or(\\n        for {\\n            int <- integer\\n            frac <- fraction\\n        } yield s\"$int.$frac\",\\n        integer\\n    )\\n    \\n    val parser: Parser[String] = for {\\n        _ <- leftP\\n        n1 <- number\\n        n2 <- number\\n        _ <- rightP\\n    } yield s\"($n1, $n2)\"\\n    \\n    \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206905,
                "title": "easy-to-understand-java-solution-with-comments",
                "content": "The thought process is to first split the string into two numbers, and then for each number again split the number to get all valid decimal numbers.\\nComments have been added in the code for understanding.\\nPlease upvote if you like the solution. \\n\\n```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        // remove the brackets and get the number\\n        String num = s.substring(1,s.length()-1);\\n        \\n        \\n        List<String> res = new ArrayList<>();\\n        \\n        // split the number into left and right, and\\n        // for each left & right get the decimal & non-decimal permutations.\\n        // Total complexity = O(n^3)\\n        for(int i=1;i<num.length();i++) {\\n            String left = num.substring(0,i);\\n            String right = num.substring(i,num.length());\\n            getDecimalPair(res,left,right);\\n        }\\n        //System.out.println(res);\\n        \\n        return res;\\n    }\\n    \\n\\n    public void getDecimalPair(List<String> res, String left, String right){\\n        \\n        List<String> leftList = getDecimalPermute(left); // O(n)\\n        List<String> rightList = getDecimalPermute(right); // O(n)\\n        \\n        // get all permutation of left and right.\\n        for(String l:leftList) {\\n            for(String r:rightList) {\\n                res.add(addStr(l,r));\\n            }\\n        }\\n    }\\n    \\n  \\n    public List<String> getDecimalPermute(String str){\\n        List<String> res = new ArrayList<>();\\n        if(str.length()==1) {\\n            res.add(str);\\n            return res;\\n        }\\n        \\n        // Split the number to left and right so that decimal point \\n        // can be added in between. The decimal number can only\\n        // be added to the list if it satisfies the condition in the \\n        // problem statement, the condition is specified in the first if() statement.\\n\\t\\t\\n        for(int i=1;i<=str.length();i++) {\\n            String left = str.substring(0,i);\\n            String right = str.substring(i,str.length());\\n            if((!left.startsWith(\"0\") || left.equals(\"0\")) && !right.endsWith(\"0\")) {\\n                if(i<str.length())\\n                    res.add(left+\".\"+right);\\n                else //if s==str.length() then add the whole number(i.e., left+right).\\n                    res.add(left+right); \\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public String addStr(String left, String right) {\\n        return \"(\"+left+\", \"+right+\")\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        // remove the brackets and get the number\\n        String num = s.substring(1,s.length()-1);\\n        \\n        \\n        List<String> res = new ArrayList<>();\\n        \\n        // split the number into left and right, and\\n        // for each left & right get the decimal & non-decimal permutations.\\n        // Total complexity = O(n^3)\\n        for(int i=1;i<num.length();i++) {\\n            String left = num.substring(0,i);\\n            String right = num.substring(i,num.length());\\n            getDecimalPair(res,left,right);\\n        }\\n        //System.out.println(res);\\n        \\n        return res;\\n    }\\n    \\n\\n    public void getDecimalPair(List<String> res, String left, String right){\\n        \\n        List<String> leftList = getDecimalPermute(left); // O(n)\\n        List<String> rightList = getDecimalPermute(right); // O(n)\\n        \\n        // get all permutation of left and right.\\n        for(String l:leftList) {\\n            for(String r:rightList) {\\n                res.add(addStr(l,r));\\n            }\\n        }\\n    }\\n    \\n  \\n    public List<String> getDecimalPermute(String str){\\n        List<String> res = new ArrayList<>();\\n        if(str.length()==1) {\\n            res.add(str);\\n            return res;\\n        }\\n        \\n        // Split the number to left and right so that decimal point \\n        // can be added in between. The decimal number can only\\n        // be added to the list if it satisfies the condition in the \\n        // problem statement, the condition is specified in the first if() statement.\\n\\t\\t\\n        for(int i=1;i<=str.length();i++) {\\n            String left = str.substring(0,i);\\n            String right = str.substring(i,str.length());\\n            if((!left.startsWith(\"0\") || left.equals(\"0\")) && !right.endsWith(\"0\")) {\\n                if(i<str.length())\\n                    res.add(left+\".\"+right);\\n                else //if s==str.length() then add the whole number(i.e., left+right).\\n                    res.add(left+right); \\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public String addStr(String left, String right) {\\n        return \"(\"+left+\", \"+right+\")\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206887,
                "title": "python3-no-regex-and-no-str-int-conversion-48ms-beats-60-o-n-3-time",
                "content": "\\tclass Solution:\\n\\t\\tdef ambiguousCoordinates(self, s: str) -> List[str]:\\n\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t- split s into two parts: left and right\\n\\t\\t\\t- apply getPossible() function to left and right\\n\\t\\t\\t- mix the results from left and right\\n\\t\\t\\t- return list\\n\\n\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t@functools.lru_cache(None)\\n\\t\\t\\tdef getPossible(i, j):\\n\\t\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t\\t- for substring starts from i, ending at j, inclusive\\n\\t\\t\\t\\t- case1: one element, can make only s[i:j+1]\\n\\t\\t\\t\\t- case2: at least two elements\\n\\t\\t\\t\\t\\t- case21: both trailing and leading zeros, return []\\n\\t\\t\\t\\t\\t- case22: only leading zero, return 0.xxxx\\n\\t\\t\\t\\t\\t- case23: only trailing zero, return s[i:j+1]\\n\\t\\t\\t\\t\\t- case24: no trailing/leading zeros, return all xxx.xxx plus xxxxxx itself\\n\\n\\t\\t\\t\\t\\'\\'\\'\\n\\n\\t\\t\\t\\tif i == j: return [s[i]]\\n\\t\\t\\t\\tif s[i] == s[j] == \\'0\\': return []\\n\\t\\t\\t\\tif s[i] == \\'0\\': return [s[i]+\\'.\\'+s[i+1:j+1]]\\n\\t\\t\\t\\tif s[j] == \\'0\\': return [s[i:j+1]]\\n\\t\\t\\t\\tres = [s[i:j+1]]\\n\\t\\t\\t\\tfor k in range(i, j): res.append(s[i:k+1]+\\'.\\'+s[k+1:j+1])\\n\\t\\t\\t\\treturn res\\n\\n\\t\\t\\t# calculate\\n\\t\\t\\tres = []\\n\\t\\t\\tfor k in range(1, len(s)-2): # here needs O(N**3) time\\n\\t\\t\\t\\tfor left in getPossible(1, k):\\n\\t\\t\\t\\t\\tfor right in getPossible(k+1, len(s)-2):\\n\\t\\t\\t\\t\\t\\tres.append(\\'(\\' + left + \\', \\' + right + \\')\\')\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef ambiguousCoordinates(self, s: str) -> List[str]:\\n\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t- split s into two parts: left and right\\n\\t\\t\\t- apply getPossible() function to left and right\\n\\t\\t\\t- mix the results from left and right\\n\\t\\t\\t- return list\\n\\n\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t@functools.lru_cache(None)\\n\\t\\t\\tdef getPossible(i, j):\\n\\t\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t\\t- for substring starts from i, ending at j, inclusive\\n\\t\\t\\t\\t- case1: one element, can make only s[i:j+1]\\n\\t\\t\\t\\t- case2: at least two elements\\n\\t\\t\\t\\t\\t- case21: both trailing and leading zeros, return []\\n\\t\\t\\t\\t\\t- case22: only leading zero, return 0.xxxx\\n\\t\\t\\t\\t\\t- case23: only trailing zero, return s[i:j+1]\\n\\t\\t\\t\\t\\t- case24: no trailing/leading zeros, return all xxx.xxx plus xxxxxx itself\\n\\n\\t\\t\\t\\t\\'\\'\\'\\n\\n\\t\\t\\t\\tif i == j: return [s[i]]\\n\\t\\t\\t\\tif s[i] == s[j] == \\'0\\': return []\\n\\t\\t\\t\\tif s[i] == \\'0\\': return [s[i]+\\'.\\'+s[i+1:j+1]]\\n\\t\\t\\t\\tif s[j] == \\'0\\': return [s[i:j+1]]\\n\\t\\t\\t\\tres = [s[i:j+1]]\\n\\t\\t\\t\\tfor k in range(i, j): res.append(s[i:k+1]+\\'.\\'+s[k+1:j+1])\\n\\t\\t\\t\\treturn res\\n\\n\\t\\t\\t# calculate\\n\\t\\t\\tres = []\\n\\t\\t\\tfor k in range(1, len(s)-2): # here needs O(N**3) time\\n\\t\\t\\t\\tfor left in getPossible(1, k):\\n\\t\\t\\t\\t\\tfor right in getPossible(k+1, len(s)-2):\\n\\t\\t\\t\\t\\t\\tres.append(\\'(\\' + left + \\', \\' + right + \\')\\')\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 1206873,
                "title": "python3-brute-force-93",
                "content": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        #strategy: Brute Force\\n        answer = []\\n        def helper(x: str):\\n            temp = []\\n            #no decimal point\\n            if x[0] != \\'0\\' or len(x) == 1:\\n                temp.append(x)\\n            #decimal point\\n            for i in range(1, len(x)):\\n                #we can\\'t have the ending to ever be 0\\n                #the only time we can use the start as 0 if it is the only digit in front of the decimal point\\n                if ((x[0] == \\'0\\' and i == 1) or (x[0] != \\'0\\')) and (x[-1] != \\'0\\'):\\n                    temp.append(x[0:i] + \".\" + x[i:])\\n            return temp\\n        #don\\'t include parenthesis\\n        for i in range(2, len(s) - 1):\\n            #find the two points\\n            a, b = s[1:i], s[i:len(s) - 1:]\\n            #helper will add decimal points if applicable\\n            for first in helper(a):\\n                for second in helper(b):\\n                    answer.append(\"({}, {})\".format(first, second))\\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        #strategy: Brute Force\\n        answer = []\\n        def helper(x: str):\\n            temp = []\\n            #no decimal point\\n            if x[0] != \\'0\\' or len(x) == 1:\\n                temp.append(x)\\n            #decimal point\\n            for i in range(1, len(x)):\\n                #we can\\'t have the ending to ever be 0\\n                #the only time we can use the start as 0 if it is the only digit in front of the decimal point\\n                if ((x[0] == \\'0\\' and i == 1) or (x[0] != \\'0\\')) and (x[-1] != \\'0\\'):\\n                    temp.append(x[0:i] + \".\" + x[i:])\\n            return temp\\n        #don\\'t include parenthesis\\n        for i in range(2, len(s) - 1):\\n            #find the two points\\n            a, b = s[1:i], s[i:len(s) - 1:]\\n            #helper will add decimal points if applicable\\n            for first in helper(a):\\n                for second in helper(b):\\n                    answer.append(\"({}, {})\".format(first, second))\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206868,
                "title": "java-modular-code",
                "content": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> res = new ArrayList<>();\\n        if (s == null || s.length() == 0) return res;\\n        for (int i = 1; i < s.length()-2; i++) {\\n            List<String> left = getAllNums(s.substring(1, i+1));\\n            List<String> right = getAllNums(s.substring(i+1, s.length()-1));\\n            for (String l : left) {\\n                for (String r : right) {\\n                    res.add(\"(\" + l + \", \" + r + \")\");\\n                }\\n            }\\n        }\\n        return res;        \\n    }\\n\\n    private List<String> getAllNums(String str) {\\n        StringBuilder sb = new StringBuilder(str);\\n        List<String> res = new ArrayList<>();\\n        if (isValid(str)) {\\n            res.add(str);\\n        }\\n        for (int i = 1; i < str.length(); i++) {\\n            sb.insert(i, \\'.\\');\\n            if (isValid(sb.toString())) {\\n                res.add(sb.toString());\\n            }\\n            sb.deleteCharAt(i);\\n        }\\n        return res;\\n    }\\n    \\n    private boolean isValid(String str) {\\n        // System.out.println(\"checking: \" + str);\\n        if (str.charAt(0) == \\'.\\' ||\\n            str.charAt(str.length()-1) == \\'.\\' ||\\n            str.equals(\"0.0\")) {\\n            return false;\\n        }\\n        String[] parts = str.split(\"[\\\\\\\\.]\");\\n        if (parts.length == 1) {\\n            return str.length() == 1 || !isLeadingZero(str);\\n        }\\n        else {\\n            return (!isTrailingZero(parts[1]) &&\\n                    (parts[0].length() == 1 || !isLeadingZero(parts[0]))); \\n        }\\n    }\\n    \\n    private boolean isLeadingZero(String str) {\\n        return (str.length() > 0 && str.charAt(0) == \\'0\\');\\n    }\\n    \\n    private boolean isTrailingZero(String str) {\\n        return (str.length() > 0 && str.charAt(str.length()-1) == \\'0\\');\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> res = new ArrayList<>();\\n        if (s == null || s.length() == 0) return res;\\n        for (int i = 1; i < s.length()-2; i++) {\\n            List<String> left = getAllNums(s.substring(1, i+1));\\n            List<String> right = getAllNums(s.substring(i+1, s.length()-1));\\n            for (String l : left) {\\n                for (String r : right) {\\n                    res.add(\"(\" + l + \", \" + r + \")\");\\n                }\\n            }\\n        }\\n        return res;        \\n    }\\n\\n    private List<String> getAllNums(String str) {\\n        StringBuilder sb = new StringBuilder(str);\\n        List<String> res = new ArrayList<>();\\n        if (isValid(str)) {\\n            res.add(str);\\n        }\\n        for (int i = 1; i < str.length(); i++) {\\n            sb.insert(i, \\'.\\');\\n            if (isValid(sb.toString())) {\\n                res.add(sb.toString());\\n            }\\n            sb.deleteCharAt(i);\\n        }\\n        return res;\\n    }\\n    \\n    private boolean isValid(String str) {\\n        // System.out.println(\"checking: \" + str);\\n        if (str.charAt(0) == \\'.\\' ||\\n            str.charAt(str.length()-1) == \\'.\\' ||\\n            str.equals(\"0.0\")) {\\n            return false;\\n        }\\n        String[] parts = str.split(\"[\\\\\\\\.]\");\\n        if (parts.length == 1) {\\n            return str.length() == 1 || !isLeadingZero(str);\\n        }\\n        else {\\n            return (!isTrailingZero(parts[1]) &&\\n                    (parts[0].length() == 1 || !isLeadingZero(parts[0]))); \\n        }\\n    }\\n    \\n    private boolean isLeadingZero(String str) {\\n        return (str.length() > 0 && str.charAt(0) == \\'0\\');\\n    }\\n    \\n    private boolean isTrailingZero(String str) {\\n        return (str.length() > 0 && str.charAt(str.length()-1) == \\'0\\');\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206867,
                "title": "beat-100-simple-javascript-regex-with-explanation",
                "content": "```\\nconst ambiguousCoordinates = function (s) {\\n\\n  const ans = [];\\n\\n  // outer for loop to create all combinations of numbers on left and right side\\n  for (let i = 2; i < s.length - 1; i++) {\\n    let lft = s.slice(1, i);\\n    let rght = s.slice(i, s.length - 1);\\n\\n    //  add combinations with no decimals\\n    const ls = [lft];\\n    const rs = [rght];\\n\\n    // inner for loop to find all combinations of left side with a decimal\\n    for (let i = 1; i < lft.length; i++) {\\n      temp1 = lft.slice(0, i);\\n      temp2 = lft.slice(i);\\n      ls.push(`${temp1}.${temp2}`);\\n    }\\n\\n    // inner for loop to find all combinations of right side with a decimal\\n    for (let i = 1; i < rght.length; i++) {\\n      temp1 = rght.slice(0, i);\\n      temp2 = rght.slice(i, rght.length);\\n      rs.push(`${temp1}.${temp2}`);\\n    }\\n\\n    // push in all valid answers that pass the regex\\n    for (let l of ls) {\\n      if (!/^([1-9]\\\\d*|0\\\\.\\\\d*[1-9]|[1-9]\\\\d*\\\\.\\\\d*[1-9]|0)$/i.test(l)) continue;\\n      for (let r of rs) {\\n        if (!/^([1-9]\\\\d*|0\\\\.\\\\d*[1-9]|[1-9]\\\\d*\\\\.\\\\d*[1-9]|0)$/i.test(r)) continue;\\n        ans.push(`(${l}, ${r})`);\\n      }\\n    }\\n  }\\n  return ans;\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/ba9a047a-783a-484c-b85f-af508df2be68_1620935777.2615383.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst ambiguousCoordinates = function (s) {\\n\\n  const ans = [];\\n\\n  // outer for loop to create all combinations of numbers on left and right side\\n  for (let i = 2; i < s.length - 1; i++) {\\n    let lft = s.slice(1, i);\\n    let rght = s.slice(i, s.length - 1);\\n\\n    //  add combinations with no decimals\\n    const ls = [lft];\\n    const rs = [rght];\\n\\n    // inner for loop to find all combinations of left side with a decimal\\n    for (let i = 1; i < lft.length; i++) {\\n      temp1 = lft.slice(0, i);\\n      temp2 = lft.slice(i);\\n      ls.push(`${temp1}.${temp2}`);\\n    }\\n\\n    // inner for loop to find all combinations of right side with a decimal\\n    for (let i = 1; i < rght.length; i++) {\\n      temp1 = rght.slice(0, i);\\n      temp2 = rght.slice(i, rght.length);\\n      rs.push(`${temp1}.${temp2}`);\\n    }\\n\\n    // push in all valid answers that pass the regex\\n    for (let l of ls) {\\n      if (!/^([1-9]\\\\d*|0\\\\.\\\\d*[1-9]|[1-9]\\\\d*\\\\.\\\\d*[1-9]|0)$/i.test(l)) continue;\\n      for (let r of rs) {\\n        if (!/^([1-9]\\\\d*|0\\\\.\\\\d*[1-9]|[1-9]\\\\d*\\\\.\\\\d*[1-9]|0)$/i.test(r)) continue;\\n        ans.push(`(${l}, ${r})`);\\n      }\\n    }\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1206823,
                "title": "python-break-it-down",
                "content": "```\\ndef ambiguousCoordinates(self, s: str) -> List[str]:\\n\\tresults = set()\\n\\tisvalid = lambda x: len(str(int(x))) == len(x)\\n\\n\\tdef getvalidnums(s):\\n\\t\\tnums = []\\n\\t\\tif isvalid(s): nums.append(s)\\n\\t\\tfor i in range(1, len(s)):\\n\\t\\t\\tif isvalid(s[:i]) and isvalid(s[i:][::-1]) and s[i:] != \\'0\\':\\n\\t\\t\\t\\tnums.append(f\\'{s[:i]}.{s[i:]}\\')\\n\\t\\treturn nums\\n\\n\\tfor i in range(2, len(s)-1):\\n\\t\\tlnums = getvalidnums(s[1:i])\\n\\t\\trnums = getvalidnums(s[i:-1])\\n\\t\\tfor x, y in product(lnums, rnums):\\n\\t\\t\\tresults.add(f\\'({x}, {y})\\')\\n\\n\\treturn results\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef ambiguousCoordinates(self, s: str) -> List[str]:\\n\\tresults = set()\\n\\tisvalid = lambda x: len(str(int(x))) == len(x)\\n\\n\\tdef getvalidnums(s):\\n\\t\\tnums = []\\n\\t\\tif isvalid(s): nums.append(s)\\n\\t\\tfor i in range(1, len(s)):\\n\\t\\t\\tif isvalid(s[:i]) and isvalid(s[i:][::-1]) and s[i:] != \\'0\\':\\n\\t\\t\\t\\tnums.append(f\\'{s[:i]}.{s[i:]}\\')\\n\\t\\treturn nums\\n\\n\\tfor i in range(2, len(s)-1):\\n\\t\\tlnums = getvalidnums(s[1:i])\\n\\t\\trnums = getvalidnums(s[i:-1])\\n\\t\\tfor x, y in product(lnums, rnums):\\n\\t\\t\\tresults.add(f\\'({x}, {y})\\')\\n\\n\\treturn results\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1206820,
                "title": "ruby-map-by-comma-position-then-by-floating-point-position",
                "content": "```ruby\\ndef ambiguous_coordinates(s)\\n  digits = s[1..-2]\\n  n = digits.size\\n  (1...n).flat_map do |comma_pos|\\n    x, y = digits[0...comma_pos], digits[comma_pos...n]\\n\\n    next([]) if x.size > 1 && x.start_with?(\\'0\\') && x.end_with?(\\'0\\') ||\\n                y.size > 1 && y.start_with?(\\'0\\') && y.end_with?(\\'0\\')\\n\\n    x_coords = if x.size == 1 || x.end_with?(\\'0\\')\\n                 [x]\\n               elsif x.start_with?(\\'0\\')\\n                 [\"0.#{x[1..-1]}\"]\\n               else\\n                 (0...x.size).map { |p| p.zero? ? x : \"#{x[0...p]}.#{x[p..-1]}\" }\\n               end\\n    y_coords = if y.size == 1 || y.end_with?(\\'0\\')\\n                 [y]\\n               elsif y.start_with?(\\'0\\')\\n                 [\"0.#{y[1..-1]}\"]\\n               else\\n                 (0...y.size).map { |p| p.zero? ? y : \"#{y[0...p]}.#{y[p..-1]}\" }\\n               end\\n    x_coords.product(y_coords).map do |xc, yc|\\n      \"(#{xc}, #{yc})\"\\n    end\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef ambiguous_coordinates(s)\\n  digits = s[1..-2]\\n  n = digits.size\\n  (1...n).flat_map do |comma_pos|\\n    x, y = digits[0...comma_pos], digits[comma_pos...n]\\n\\n    next([]) if x.size > 1 && x.start_with?(\\'0\\') && x.end_with?(\\'0\\') ||\\n                y.size > 1 && y.start_with?(\\'0\\') && y.end_with?(\\'0\\')\\n\\n    x_coords = if x.size == 1 || x.end_with?(\\'0\\')\\n                 [x]\\n               elsif x.start_with?(\\'0\\')\\n                 [\"0.#{x[1..-1]}\"]\\n               else\\n                 (0...x.size).map { |p| p.zero? ? x : \"#{x[0...p]}.#{x[p..-1]}\" }\\n               end\\n    y_coords = if y.size == 1 || y.end_with?(\\'0\\')\\n                 [y]\\n               elsif y.start_with?(\\'0\\')\\n                 [\"0.#{y[1..-1]}\"]\\n               else\\n                 (0...y.size).map { |p| p.zero? ? y : \"#{y[0...p]}.#{y[p..-1]}\" }\\n               end\\n    x_coords.product(y_coords).map do |xc, yc|\\n      \"(#{xc}, #{yc})\"\\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1206753,
                "title": "simple-regex",
                "content": "The solution consist of two parts. 1) Split the original string into two non-empty substrings, 2) for each substring, exhaust position of decimal point.\\nUsing a regex to check if the substring (after adding decimal point) is valid.\\n```\\nimport (\\n  \"fmt\"\\n  \"regexp\"\\n)\\n\\nfunc ambiguousCoordinates(s string) []string {\\n  var res []string\\n  s = s[1:len(s)-1]\\n  for i := 0; i < len(s)-1; i++ {\\n    left := dec(s[:i+1])\\n    right := dec(s[i+1:])\\n    for _, l := range left {\\n      for _, r := range right {\\n        res = append(res, fmt.Sprintf(\"(%s, %s)\", l, r))\\n      }\\n    }\\n  }\\n  return res\\n}\\n\\nvar validNumber = regexp.MustCompile(\"^([1-9]\\\\\\\\d*|0)(\\\\\\\\.\\\\\\\\d*[1-9])?$\")\\n\\nfunc dec(s string) []string {\\n  var res []string\\n  for i := 0; i < len(s); i++ {\\n    t := s\\n    if i != 0 {\\n      t = fmt.Sprintf(\"%s.%s\", s[:i], s[i:])\\n    }\\n    if validNumber.MatchString(t) {\\n      res = append(res, t)\\n    }\\n  }\\n  return res\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimport (\\n  \"fmt\"\\n  \"regexp\"\\n)\\n\\nfunc ambiguousCoordinates(s string) []string {\\n  var res []string\\n  s = s[1:len(s)-1]\\n  for i := 0; i < len(s)-1; i++ {\\n    left := dec(s[:i+1])\\n    right := dec(s[i+1:])\\n    for _, l := range left {\\n      for _, r := range right {\\n        res = append(res, fmt.Sprintf(\"(%s, %s)\", l, r))\\n      }\\n    }\\n  }\\n  return res\\n}\\n\\nvar validNumber = regexp.MustCompile(\"^([1-9]\\\\\\\\d*|0)(\\\\\\\\.\\\\\\\\d*[1-9])?$\")\\n\\nfunc dec(s string) []string {\\n  var res []string\\n  for i := 0; i < len(s); i++ {\\n    t := s\\n    if i != 0 {\\n      t = fmt.Sprintf(\"%s.%s\", s[:i], s[i:])\\n    }\\n    if validNumber.MatchString(t) {\\n      res = append(res, t)\\n    }\\n  }\\n  return res\\n}\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1206720,
                "title": "python3-solution-for-reference-based-on-string-arrangement",
                "content": "The following template and refernce code below can help !\\n- Split the string into various substrings first ( 1234 -> 1 234, 12 34, 123 4 ) so that *left, right* are atleast 1 char long. \\n- If left or right starts with a \\'0\\' then the rest of the string can just only be a decimal as per the conditions. ( 0 0001 -> 0.0001; 0 123 -> 0.123)\\n- left and right choices cannot have decimal parts that end with \\'0\\' This one was revealed in tests. \\n- Among left and right strings insert \\'.\\' to make decimals. \\n- Collect all left items first and append each right item to all left ele to fill up output. \\n- Format strings comes in handy for the output formatting\\n\\nThere is scope for improvement for logic below by clubbng together, conditions.\\n\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        sp = [(s[:x], s[x:]) for x in range(1,len(s))]\\n        o = []\\n        for left, right in sp:\\n            la = []\\n            if left[0] == \\'0\\' and len(left) > 1 and set(left) != set([\"0\"]):\\n                if left[1:][-1] != \\'0\\':                \\n                    la.append((left[:1] + \\'.\\' + left[1:]))\\n            else:\\n                if (len(left) > 1 and set(left) != set([\"0\"])) or len(left) == 1:\\n                    la.append(left)\\n                    for y in range(1, len(left)):\\n                        if int(left[y:]) != 0 and left[y:][-1] != \\'0\\':\\n                            la.append((left[:y] + \\'.\\' + left[y:]))\\n                            \\n            ra = []\\n            if right[0] == \\'0\\' and len(right) > 1 and set(right) != set([\"0\"]):\\n                if right[1:][-1] != \\'0\\':\\n                    o += [\"(%s, %s)\"%(i, (right[:1] + \\'.\\' + right[1:])) for i in la]\\n            else:\\n                if (len(right) > 1 and set(right) != set([\"0\"])) or len(right) == 1:                 \\n                    o += [\"(%s, %s)\"%(i, right) for i in la]\\n                    for y in range(1, len(right)):\\n                        if int(right[y:]) != 0 and right[y:][-1] != \\'0\\':\\n                            rightside = right[:y] + \\'.\\' + right[y:]\\n                            o += [\"(%s, %s)\"%(i, rightside) for i in la]\\n                    \\n        return o",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "The following template and refernce code below can help !\\n- Split the string into various substrings first ( 1234 -> 1 234, 12 34, 123 4 ) so that *left, right* are atleast 1 char long. \\n- If left or right starts with a \\'0\\' then the rest of the string can just only be a decimal as per the conditions. ( 0 0001 -> 0.0001; 0 123 -> 0.123)\\n- left and right choices cannot have decimal parts that end with \\'0\\' This one was revealed in tests. \\n- Among left and right strings insert \\'.\\' to make decimals. \\n- Collect all left items first and append each right item to all left ele to fill up output. \\n- Format strings comes in handy for the output formatting\\n\\nThere is scope for improvement for logic below by clubbng together, conditions.\\n\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        sp = [(s[:x], s[x:]) for x in range(1,len(s))]\\n        o = []\\n        for left, right in sp:\\n            la = []\\n            if left[0] == \\'0\\' and len(left) > 1 and set(left) != set([\"0\"]):\\n                if left[1:][-1] != \\'0\\':                \\n                    la.append((left[:1] + \\'.\\' + left[1:]))\\n            else:\\n                if (len(left) > 1 and set(left) != set([\"0\"])) or len(left) == 1:\\n                    la.append(left)\\n                    for y in range(1, len(left)):\\n                        if int(left[y:]) != 0 and left[y:][-1] != \\'0\\':\\n                            la.append((left[:y] + \\'.\\' + left[y:]))\\n                            \\n            ra = []\\n            if right[0] == \\'0\\' and len(right) > 1 and set(right) != set([\"0\"]):\\n                if right[1:][-1] != \\'0\\':\\n                    o += [\"(%s, %s)\"%(i, (right[:1] + \\'.\\' + right[1:])) for i in la]\\n            else:\\n                if (len(right) > 1 and set(right) != set([\"0\"])) or len(right) == 1:                 \\n                    o += [\"(%s, %s)\"%(i, right) for i in la]\\n                    for y in range(1, len(right)):\\n                        if int(right[y:]) != 0 and right[y:][-1] != \\'0\\':\\n                            rightside = right[:y] + \\'.\\' + right[y:]\\n                            o += [\"(%s, %s)\"%(i, rightside) for i in la]\\n                    \\n        return o",
                "codeTag": "Java"
            },
            {
                "id": 1206681,
                "title": "easy-to-understand-java-solution-with-comments-explanation",
                "content": "```\\n public List<String> ambiguousCoordinates(String s) {\\n        s=s.substring(1,s.length()-1);\\n        List<String> list=new ArrayList<String>();\\n        \\n        for(int i=1; i<s.length(); i++){\\n    \\n        String leftSubstring=s.substring(0,i);\\n        String rightSubstring=s.substring(i,s.length());\\n            \\n        Set<String> leftPart=generate(leftSubstring);\\n        Set<String> rightPart=generate(rightSubstring);\\n        \\n        for(String left: leftPart){\\n            for(String right: rightPart){\\n                list.add(\"(\" + left + \", \"+ right + \")\");\\n            }\\n        }    \\n            \\n        }\\n        return list;\\n    }\\n    \\n    public Set<String> generate(String s){\\n        Set<String> hset=new HashSet<String>();\\n        int l=s.length();\\n        char c[]=s.toCharArray();\\n    \\n        //0XXXXX0 is Invalid unless a single zero.\\n        if(c[0]==\\'0\\' && c[l-1]==\\'0\\'){\\n            if(l==1){\\n                hset.add(\"0\");\\n            }\\n            return hset;\\n        }\\n        \\n        //0XXXX can be split like this 0.XXXX\\n        if(c[0]==\\'0\\'){\\n            hset.add(\"0.\"+s.substring(1));\\n            return hset;\\n        }\\n        \\n        //XXXX0 cannot be split\\n        if(c[l-1]==\\'0\\'){\\n            hset.add(s);\\n            return hset;\\n        }\\n        \\n        //Generating Substring for every case. XXXX => X.XXX, XX.XX, XXX.X \\n        for(int i=1; i<l; i++){\\n            hset.add(s.substring(0,i)+\".\"+s.substring(i));\\n        }\\n        hset.add(s);\\n        return hset;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n public List<String> ambiguousCoordinates(String s) {\\n        s=s.substring(1,s.length()-1);\\n        List<String> list=new ArrayList<String>();\\n        \\n        for(int i=1; i<s.length(); i++){\\n    \\n        String leftSubstring=s.substring(0,i);\\n        String rightSubstring=s.substring(i,s.length());\\n            \\n        Set<String> leftPart=generate(leftSubstring);\\n        Set<String> rightPart=generate(rightSubstring);\\n        \\n        for(String left: leftPart){\\n            for(String right: rightPart){\\n                list.add(\"(\" + left + \", \"+ right + \")\");\\n            }\\n        }    \\n            \\n        }\\n        return list;\\n    }\\n    \\n    public Set<String> generate(String s){\\n        Set<String> hset=new HashSet<String>();\\n        int l=s.length();\\n        char c[]=s.toCharArray();\\n    \\n        //0XXXXX0 is Invalid unless a single zero.\\n        if(c[0]==\\'0\\' && c[l-1]==\\'0\\'){\\n            if(l==1){\\n                hset.add(\"0\");\\n            }\\n            return hset;\\n        }\\n        \\n        //0XXXX can be split like this 0.XXXX\\n        if(c[0]==\\'0\\'){\\n            hset.add(\"0.\"+s.substring(1));\\n            return hset;\\n        }\\n        \\n        //XXXX0 cannot be split\\n        if(c[l-1]==\\'0\\'){\\n            hset.add(s);\\n            return hset;\\n        }\\n        \\n        //Generating Substring for every case. XXXX => X.XXX, XX.XX, XXX.X \\n        for(int i=1; i<l; i++){\\n            hset.add(s.substring(0,i)+\".\"+s.substring(i));\\n        }\\n        hset.add(s);\\n        return hset;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1206631,
                "title": "c-simple-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<string> ambiguousCoordinates(string s) {\\n\\t\\t\\t//delete the \"()\"\\n\\t\\t\\tstring ori=s.substr(1,s.length()-2);\\n\\n\\t\\t\\t//the result variable vector\\n\\t\\t\\tvector<string>result;\\n\\n\\t\\t\\tfunction <void(vector<string>&, const string&)> helper=[&](vector<string>& ans, const string &s){\\n\\t\\t\\t\\t//if the string only has one char then push it into the vector (special case)\\n\\t\\t\\t\\tif(s.length()==1){\\n\\t\\t\\t\\t\\tans.push_back(s);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t//Find the the apparence of the 0 at the begining and end of the string:\\n\\t\\t\\t\\t//Considering the following cases:\\n\\t\\t\\t\\t//1) the begining and the end of the string does not contain any \"0\": meaning that you can put any \".\" inside the string; (ex: 23140432)\\n\\t\\t\\t\\t//2) the begining and the end of the string both have \"0\" meaing it cannot be used;(ex. 027600)\\n\\t\\t\\t\\t//3) the begining of the string has the \"0\": only 0.28510009659 one situation (ex. 000278)\\n\\t\\t\\t\\t//4) the end of the string has \"0\": only the entire string can be used (ex. 234000)\\n\\t\\t\\t\\tint startZero=s.find_first_not_of(\\'0\\');\\n\\t\\t\\t\\tint endZero=s.find_last_not_of(\\'0\\');\\n\\n\\t\\t\\t\\tif(startZero==0 && endZero==s.length()-1){            \\n\\t\\t\\t\\t\\tfor(int i=1;i<s.length();++i){\\n\\t\\t\\t\\t\\t\\tans.push_back(s.substr(0,i)+\".\"+s.substr(i));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tans.push_back(s);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(startZero==0 && endZero!=s.length()-1){\\n\\t\\t\\t\\t\\tans.push_back(s);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(startZero!=0 && endZero==s.length()-1){\\n\\t\\t\\t\\t\\tans.push_back(s.substr(0,1)+\".\"+s.substr(1));\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn;               \\n\\t\\t\\t};\\n\\n\\n\\n\\t\\t\\t//Go through every point (put \",\") of the string\\n\\t\\t\\tfor(int i=1;i<ori.length();++i){\\n\\t\\t\\t\\tstring firstHalf=ori.substr(0,i);\\n\\t\\t\\t\\tstring secondHalf=ori.substr(i);\\n\\n\\t\\t\\t\\tvector<string>first;\\n\\t\\t\\t\\tvector<string>second;\\n\\n\\t\\t\\t\\thelper(first,firstHalf);\\n\\t\\t\\t\\thelper(second,secondHalf);\\n\\n\\t\\t\\t\\tfor(int ii=0;ii<first.size();++ii){\\n\\t\\t\\t\\t\\tfor(int j=0;j<second.size();++j){\\n\\t\\t\\t\\t\\t\\tresult.emplace_back(\"(\"+first[ii]+\", \"+second[j]+\")\");\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\t\\t}  \\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<string> ambiguousCoordinates(string s) {\\n\\t\\t\\t//delete the \"()\"\\n\\t\\t\\tstring ori=s.substr(1,s.length()-2);\\n\\n\\t\\t\\t//the result variable vector\\n\\t\\t\\tvector<string>result;\\n\\n\\t\\t\\tfunction <void(vector<string>&, const string&)> helper=[&](vector<string>& ans, const string &s){\\n\\t\\t\\t\\t//if the string only has one char then push it into the vector (special case)\\n\\t\\t\\t\\tif(s.length()==1){\\n\\t\\t\\t\\t\\tans.push_back(s);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1206625,
                "title": "java-100-beat-solution",
                "content": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> out = new ArrayList<>();\\n        String numstring = s.substring(1, s.length() - 1);\\n        for (int div = 1; div < numstring.length(); div++) {\\n            String l = numstring.substring(0, div);\\n            String r = numstring.substring(div);\\n            List<String> leftNums = generate(l), rightNums = generate(r);\\n            combine(out, leftNums, rightNums);\\n        }\\n        return out;\\n    }\\n    \\n    private void combine(List<String> out, List<String> left, List<String> right) {\\n        for (String l: left) {\\n            for (String r: right) {\\n                StringBuilder sb = new StringBuilder();\\n                sb.append(\\'(\\').append(l).append(\", \").append(r).append(\\')\\');\\n                out.add(sb.toString());\\n            }\\n        }\\n    }\\n    \\n    private List<String> generate(String s) {\\n        List<String> out = new ArrayList<>();\\n        if (isValidInteger(s)) out.add(s);\\n        for (int i = 1; i < s.length(); i++) {\\n            if (isValidFloat(s, i)) {\\n                StringBuilder sb = new StringBuilder();\\n                sb.append(s.substring(0, i)).append(\\'.\\').append(s.substring(i));\\n                out.add(sb.toString());\\n            }\\n        }\\n        return out;\\n    }\\n    \\n    private boolean isValidInteger(String s) {\\n        return s.length() == 1 || s.charAt(0) != \\'0\\';\\n    }\\n    \\n    private boolean isValidFloat(String s, int floatPos) {\\n        boolean digitPortionValid = true;\\n        if (floatPos >= 2 && s.charAt(0) == \\'0\\') digitPortionValid = false;\\n        \\n        return digitPortionValid && s.charAt(s.length() - 1) != \\'0\\';\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> out = new ArrayList<>();\\n        String numstring = s.substring(1, s.length() - 1);\\n        for (int div = 1; div < numstring.length(); div++) {\\n            String l = numstring.substring(0, div);\\n            String r = numstring.substring(div);\\n            List<String> leftNums = generate(l), rightNums = generate(r);\\n            combine(out, leftNums, rightNums);\\n        }\\n        return out;\\n    }\\n    \\n    private void combine(List<String> out, List<String> left, List<String> right) {\\n        for (String l: left) {\\n            for (String r: right) {\\n                StringBuilder sb = new StringBuilder();\\n                sb.append(\\'(\\').append(l).append(\", \").append(r).append(\\')\\');\\n                out.add(sb.toString());\\n            }\\n        }\\n    }\\n    \\n    private List<String> generate(String s) {\\n        List<String> out = new ArrayList<>();\\n        if (isValidInteger(s)) out.add(s);\\n        for (int i = 1; i < s.length(); i++) {\\n            if (isValidFloat(s, i)) {\\n                StringBuilder sb = new StringBuilder();\\n                sb.append(s.substring(0, i)).append(\\'.\\').append(s.substring(i));\\n                out.add(sb.toString());\\n            }\\n        }\\n        return out;\\n    }\\n    \\n    private boolean isValidInteger(String s) {\\n        return s.length() == 1 || s.charAt(0) != \\'0\\';\\n    }\\n    \\n    private boolean isValidFloat(String s, int floatPos) {\\n        boolean digitPortionValid = true;\\n        if (floatPos >= 2 && s.charAt(0) == \\'0\\') digitPortionValid = false;\\n        \\n        return digitPortionValid && s.charAt(s.length() - 1) != \\'0\\';\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206621,
                "title": "c-816-ambiguous-coordinates",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n                \\n        auto fn = [](string&& s) {\\n            vector<string> ans; \\n            if (s.size() == 1) \\n                ans.push_back(s); \\n            else if (s.front() == \\'0\\' and s.back() == \\'0\\') ; \\n            else if (s.front() == \\'0\\') \\n                ans.push_back(\"0.\" + s.substr(1)); \\n            else if (s.back() == \\'0\\') \\n                ans.push_back(s); \\n            else {\\n                for (int i = 1; i < s.size(); ++i)\\n                    ans.push_back(s.substr(0, i) + \".\" + s.substr(i)); \\n                ans.push_back(s); \\n            }\\n            return ans;\\n        };\\n        \\n        vector<string> ans; \\n        for (int i = 2; i < s.size()-1; ++i) \\n            for (auto& x : fn(s.substr(1, i-1))) \\n                for (auto& y : fn(s.substr(i, s.size()-1-i))) \\n                    ans.push_back(\"(\" + x + \", \" + y + \")\"); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string s) {\\n                \\n        auto fn = [](string&& s) {\\n            vector<string> ans; \\n            if (s.size() == 1) \\n                ans.push_back(s); \\n            else if (s.front() == \\'0\\' and s.back() == \\'0\\') ; \\n            else if (s.front() == \\'0\\') \\n                ans.push_back(\"0.\" + s.substr(1)); \\n            else if (s.back() == \\'0\\') \\n                ans.push_back(s); \\n            else {\\n                for (int i = 1; i < s.size(); ++i)\\n                    ans.push_back(s.substr(0, i) + \".\" + s.substr(i)); \\n                ans.push_back(s); \\n            }\\n            return ans;\\n        };\\n        \\n        vector<string> ans; \\n        for (int i = 2; i < s.size()-1; ++i) \\n            for (auto& x : fn(s.substr(1, i-1))) \\n                for (auto& y : fn(s.substr(i, s.size()-1-i))) \\n                    ans.push_back(\"(\" + x + \", \" + y + \")\"); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206570,
                "title": "c-solution-and-explanation-in-detail-simple-and-clean",
                "content": "https://ccodingclub.blogspot.com/2021/05/ambiguous-coordinates.html\\n\\nsolution explained in detail in c++\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "https://ccodingclub.blogspot.com/2021/05/ambiguous-coordinates.html\\n\\nsolution explained in detail in c++\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)",
                "codeTag": "Unknown"
            },
            {
                "id": 1206567,
                "title": "traversal-the-string-with-explanation",
                "content": "Check the explanation embeded, just a straight forward solution :\\n\\n```\\nclass Solution {\\n    // if 0 is at the beginning, cannot have more than 1 zero\\n    // if 0 is at the end, should not contains dot\\n    \\n    private static String STR_COMMA_AND_SPACE = \", \";\\n    private static String STR_DOT = \".\";\\n    private static String STR_ZERO = \"0\";\\n    private static String STR_LEFT_BRACKET = \"(\";\\n    private static String STR_RIGHT_BRACKET = \")\";\\n    private static char CHAR_ZERO = \\'0\\';\\n    \\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> ret = new ArrayList<>();\\n        int len = s.length();\\n        \\n        //we need to skip the \\'(\\' and \\')\\'\\n        for (int i = 2; i < len - 1; i++) {\\n            checkSubString(s.substring(1, i), s.substring(i, len - 1), ret);\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    private void checkSubString(String s1, String s2, List<String> ret) {\\n        int len1 = s1.length();\\n        int len2 = s2.length();\\n        \\n        // base case check\\n        if (len1 == 0 || len2 == 0) {\\n            return;\\n        }\\n        \\n        //if string start with 0 and end with 0, just skip it (except the \"0\" itself)\\n        if ((s1.startsWith(STR_ZERO)  && s1.endsWith(STR_ZERO) && !s1.equals(STR_ZERO)) \\n            || (s2.startsWith(STR_ZERO) && s2.endsWith(STR_ZERO) && !s2.equals(STR_ZERO))) {\\n            return;\\n        } \\n        \\n        List<String> list1 = getValidSubString(s1);\\n        List<String> list2 = getValidSubString(s2);\\n\\n        //compose the new string list\\n        for (String l1 : list1) {\\n            for (String l2 : list2) {\\n                ret.add(STR_LEFT_BRACKET + l1 + STR_COMMA_AND_SPACE + l2 + STR_RIGHT_BRACKET);\\n            }\\n        }\\n    }\\n    \\n    private List<String> getValidSubString(String s) {\\n        List<String> ret = new ArrayList<>();\\n        int len = s.length();\\n        \\n        // check if the string s is a valid one or not\\n        if (s.equals(STR_ZERO) || !s.startsWith(STR_ZERO)) {\\n            ret.add(s);\\n        }\\n        \\n        for (int i = 1; i < len; i++) {\\n            String s1 = s.substring(0, i);\\n            String s2 = s.substring(i);\\n            \\n            // fraction part and not end with 0\\n            // integer part cannot start with zero unless it\\'s zero\\n            if ((s1.equals(STR_ZERO) || !s1.startsWith(STR_ZERO)) && !s2.endsWith(STR_ZERO)) {\\n                ret.add(s1 + STR_DOT + s2);\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // if 0 is at the beginning, cannot have more than 1 zero\\n    // if 0 is at the end, should not contains dot\\n    \\n    private static String STR_COMMA_AND_SPACE = \", \";\\n    private static String STR_DOT = \".\";\\n    private static String STR_ZERO = \"0\";\\n    private static String STR_LEFT_BRACKET = \"(\";\\n    private static String STR_RIGHT_BRACKET = \")\";\\n    private static char CHAR_ZERO = \\'0\\';\\n    \\n    public List<String> ambiguousCoordinates(String s) {\\n        List<String> ret = new ArrayList<>();\\n        int len = s.length();\\n        \\n        //we need to skip the \\'(\\' and \\')\\'\\n        for (int i = 2; i < len - 1; i++) {\\n            checkSubString(s.substring(1, i), s.substring(i, len - 1), ret);\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    private void checkSubString(String s1, String s2, List<String> ret) {\\n        int len1 = s1.length();\\n        int len2 = s2.length();\\n        \\n        // base case check\\n        if (len1 == 0 || len2 == 0) {\\n            return;\\n        }\\n        \\n        //if string start with 0 and end with 0, just skip it (except the \"0\" itself)\\n        if ((s1.startsWith(STR_ZERO)  && s1.endsWith(STR_ZERO) && !s1.equals(STR_ZERO)) \\n            || (s2.startsWith(STR_ZERO) && s2.endsWith(STR_ZERO) && !s2.equals(STR_ZERO))) {\\n            return;\\n        } \\n        \\n        List<String> list1 = getValidSubString(s1);\\n        List<String> list2 = getValidSubString(s2);\\n\\n        //compose the new string list\\n        for (String l1 : list1) {\\n            for (String l2 : list2) {\\n                ret.add(STR_LEFT_BRACKET + l1 + STR_COMMA_AND_SPACE + l2 + STR_RIGHT_BRACKET);\\n            }\\n        }\\n    }\\n    \\n    private List<String> getValidSubString(String s) {\\n        List<String> ret = new ArrayList<>();\\n        int len = s.length();\\n        \\n        // check if the string s is a valid one or not\\n        if (s.equals(STR_ZERO) || !s.startsWith(STR_ZERO)) {\\n            ret.add(s);\\n        }\\n        \\n        for (int i = 1; i < len; i++) {\\n            String s1 = s.substring(0, i);\\n            String s2 = s.substring(i);\\n            \\n            // fraction part and not end with 0\\n            // integer part cannot start with zero unless it\\'s zero\\n            if ((s1.equals(STR_ZERO) || !s1.startsWith(STR_ZERO)) && !s2.endsWith(STR_ZERO)) {\\n                ret.add(s1 + STR_DOT + s2);\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206539,
                "title": "c-enumeration-with-all-possible-combination",
                "content": "Approach 1: enumeration with all possible combination [1]\\nWe can split S to two parts for two coordinates.\\nThen we use sub function f to find all possible strings for each coordinate.\\n\\nIn sub functon f(S)\\nif S == \"\": return []\\nif S == \"0\": return [S]\\nif S == \"0XXX0\": return []\\nif S == \"0XXX\": return [\"0.XXX\"]\\nif S == \"XXX0\": return [S]\\nreturn [S, \"X.XXX\", \"XX.XX\", \"XXX.X\"...]\\n\\nThen we add the product of two lists to result.\\n\\nTime complexity\\nO(N^3) with N <= 10\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string S) {\\n        int n = S.size();\\n        vector<string> res;\\n        for (int i = 1; i < n - 2; ++i) {\\n            vector<string> A = f(S.substr(1, i)), B = f(S.substr(i + 1, n - 2 - i));\\n            for (auto & a : A) for (auto & b : B) res.push_back(\"(\" + a + \", \" + b + \")\");\\n        }\\n        return res;\\n    }\\n    vector<string> f(string S) {\\n        int n = S.size();\\n\\t\\t//case 2: other/corner cases\\n        if (n == 0 || (n > 1 && S[0] == \\'0\\' && S[n - 1] == \\'0\\')) return {}; // this is a trick\\n        if (n > 1 && S[0] == \\'0\\') return {\"0.\" + S.substr(1)};\\n        if (n == 1 || S[n - 1] == \\'0\\') return {S};\\n        vector<string> res = {S};\\n        for (int i = 1; i < n; ++i) res.push_back(S.substr(0, i) + \\'.\\' + S.substr(i)); // case 1: normal case\\n        return res;\\n    }\\n};\\n```\\nReference:\\n[1] https://leetcode.com/problems/ambiguous-coordinates/discuss/123851/C%2B%2BJavaPython-Solution-with-Explanation",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ambiguousCoordinates(string S) {\\n        int n = S.size();\\n        vector<string> res;\\n        for (int i = 1; i < n - 2; ++i) {\\n            vector<string> A = f(S.substr(1, i)), B = f(S.substr(i + 1, n - 2 - i));\\n            for (auto & a : A) for (auto & b : B) res.push_back(\"(\" + a + \", \" + b + \")\");\\n        }\\n        return res;\\n    }\\n    vector<string> f(string S) {\\n        int n = S.size();\\n\\t\\t//case 2: other/corner cases\\n        if (n == 0 || (n > 1 && S[0] == \\'0\\' && S[n - 1] == \\'0\\')) return {}; // this is a trick\\n        if (n > 1 && S[0] == \\'0\\') return {\"0.\" + S.substr(1)};\\n        if (n == 1 || S[n - 1] == \\'0\\') return {S};\\n        vector<string> res = {S};\\n        for (int i = 1; i < n; ++i) res.push_back(S.substr(0, i) + \\'.\\' + S.substr(i)); // case 1: normal case\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206499,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn ambiguous_coordinates(s: String) -> Vec<String> {\\n        let s = s.chars().skip(1).take(s.len() - 2).collect::<Vec<_>>();\\n        let candidates = |v: &[char]| -> Vec<String> {\\n            (0..v.len())\\n                .filter_map(|i| {\\n                    let s: String = if i == 0 {\\n                        v.iter().collect()\\n                    } else {\\n                        v[..i]\\n                            .iter()\\n                            .chain(std::iter::once(&\\'.\\'))\\n                            .chain(v[i..].iter())\\n                            .collect()\\n                    };\\n                    if (s != \"0\" && s.starts_with(\\'0\\') && !s.starts_with(\"0.\"))\\n                        || (s.contains(\\'.\\') && s.ends_with(\\'0\\'))\\n                    {\\n                        None\\n                    } else {\\n                        Some(s)\\n                    }\\n                })\\n                .collect()\\n        };\\n        let mut answer = Vec::new();\\n        for i in 1..s.len() {\\n            for x in &candidates(&s[..i]) {\\n                for y in &candidates(&s[i..]) {\\n                    answer.push(format!(\"({}, {})\", x, y));\\n                }\\n            }\\n        }\\n        answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn ambiguous_coordinates(s: String) -> Vec<String> {\\n        let s = s.chars().skip(1).take(s.len() - 2).collect::<Vec<_>>();\\n        let candidates = |v: &[char]| -> Vec<String> {\\n            (0..v.len())\\n                .filter_map(|i| {\\n                    let s: String = if i == 0 {\\n                        v.iter().collect()\\n                    } else {\\n                        v[..i]\\n                            .iter()\\n                            .chain(std::iter::once(&\\'.\\'))\\n                            .chain(v[i..].iter())\\n                            .collect()\\n                    };\\n                    if (s != \"0\" && s.starts_with(\\'0\\') && !s.starts_with(\"0.\"))\\n                        || (s.contains(\\'.\\') && s.ends_with(\\'0\\'))\\n                    {\\n                        None\\n                    } else {\\n                        Some(s)\\n                    }\\n                })\\n                .collect()\\n        };\\n        let mut answer = Vec::new();\\n        for i in 1..s.len() {\\n            for x in &candidates(&s[..i]) {\\n                for y in &candidates(&s[i..]) {\\n                    answer.push(format!(\"({}, {})\", x, y));\\n                }\\n            }\\n        }\\n        answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1206489,
                "title": "scala-solution",
                "content": "```\\nimport scala.collection.mutable.ListBuffer\\nobject Solution {\\n    def ambiguousCoordinates(s: String): List[String] = {\\n        var n = s.length();\\n        var res = new ListBuffer[String]();\\n        (2 until n-1).foreach(i=> \\n            for(left <- genNumber(s.substring(1,i))){\\n                for(right <- genNumber(s.substring(i,n-1))){\\n                    res+=\"(\" + left + \", \" + right + \")\"\\n                }\\n            }                               \\n        )\\n        res.toList\\n    }\\n    \\n    def genNumber(s:String):List[String] = {\\n        var res = new ListBuffer[String]();\\n        var n = s.length();\\n        if(n==1||s(0)!=\\'0\\') res+=s;\\n        if(n>1&&s(n-1)!=\\'0\\'){\\n            if(s(0)==\\'0\\'){\\n                res+= s(0)+\".\"+s.substring(1,n);\\n            }else{\\n                (1 until n).foreach{i=>\\n                    res+=s.substring(0,i)+\".\"+s.substring(i,n);\\n                }\\n            }\\n        }\\n        res.toList\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport scala.collection.mutable.ListBuffer\\nobject Solution {\\n    def ambiguousCoordinates(s: String): List[String] = {\\n        var n = s.length();\\n        var res = new ListBuffer[String]();\\n        (2 until n-1).foreach(i=> \\n            for(left <- genNumber(s.substring(1,i))){\\n                for(right <- genNumber(s.substring(i,n-1))){\\n                    res+=\"(\" + left + \", \" + right + \")\"\\n                }\\n            }                               \\n        )\\n        res.toList\\n    }\\n    \\n    def genNumber(s:String):List[String] = {\\n        var res = new ListBuffer[String]();\\n        var n = s.length();\\n        if(n==1||s(0)!=\\'0\\') res+=s;\\n        if(n>1&&s(n-1)!=\\'0\\'){\\n            if(s(0)==\\'0\\'){\\n                res+= s(0)+\".\"+s.substring(1,n);\\n            }else{\\n                (1 until n).foreach{i=>\\n                    res+=s.substring(0,i)+\".\"+s.substring(i,n);\\n                }\\n            }\\n        }\\n        res.toList\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1206470,
                "title": "c-o-n-3-soln",
                "content": "```\\npublic class Solution {\\n    // Time = Space = O(n^3)\\n    public IList<string> AmbiguousCoordinates(string s) {\\n        List<string> validPair = new List<string>();\\n        for (int i = 2; i < s.Length - 1; i++)\\n            foreach (var first in Make(1, i))\\n                foreach (var second in Make(i, s.Length - 1))\\n                    validPair.Add(\"(\" + first + \", \" + second + \")\");\\n        return validPair;\\n        // local helper func\\n        IList<string> Make(int l, int r)\\n        {\\n            List<string> coordinates = new List<string>();\\n            string left, right;\\n            // Make valid coordinate from s.Substring(l, r)\\n            for (int d = 1; d <= r - l; d++)\\n            {\\n                left = s.Substring(l, d);\\n                right = s.Substring(l + d, r - (l + d));\\n                // left part doesnt start with \\'0\\' or if it than that the only digit && right doesnt ends with \\'0\\'\\n                if ((left[0] != \\'0\\' || left.Length == 1) && !right.EndsWith(\"0\"))\\n\\t\\t\\t\\t\\t// add dot operator if distance is less than total no of chars we have to play with\\n                    coordinates.Add(left + (d < r - l ? \".\" : \"\") + right);\\n            }\\n            return coordinates;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    // Time = Space = O(n^3)\\n    public IList<string> AmbiguousCoordinates(string s) {\\n        List<string> validPair = new List<string>();\\n        for (int i = 2; i < s.Length - 1; i++)\\n            foreach (var first in Make(1, i))\\n                foreach (var second in Make(i, s.Length - 1))\\n                    validPair.Add(\"(\" + first + \", \" + second + \")\");\\n        return validPair;\\n        // local helper func\\n        IList<string> Make(int l, int r)\\n        {\\n            List<string> coordinates = new List<string>();\\n            string left, right;\\n            // Make valid coordinate from s.Substring(l, r)\\n            for (int d = 1; d <= r - l; d++)\\n            {\\n                left = s.Substring(l, d);\\n                right = s.Substring(l + d, r - (l + d));\\n                // left part doesnt start with \\'0\\' or if it than that the only digit && right doesnt ends with \\'0\\'\\n                if ((left[0] != \\'0\\' || left.Length == 1) && !right.EndsWith(\"0\"))\\n\\t\\t\\t\\t\\t// add dot operator if distance is less than total no of chars we have to play with\\n                    coordinates.Add(left + (d < r - l ? \".\" : \"\") + right);\\n            }\\n            return coordinates;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206468,
                "title": "ambiguous-coordinates",
                "content": "class Solution { \\n    public List<String> ambiguousCoordinates(String S) {\\n        List<String> ans = new ArrayList();\\n        for (int i = 2; i < S.length()-1; ++i)\\n            for (String left: make(S, 1, i))\\n                for (String right: make(S, i, S.length()-1))\\n                    ans.add(\"(\" + left + \", \" + right + \")\");\\n        return ans;\\n    }\\n\\n    public List<String> make(String S, int i, int j) {\\n        // Make on S.substring(i, j)\\n        List<String> ans = new ArrayList();\\n        for (int d = 1; d <= j-i; ++d) {\\n            String left = S.substring(i, i+d);\\n            String right = S.substring(i+d, j);\\n            if ((!left.startsWith(\"0\") || left.equals(\"0\"))\\n                    && !right.endsWith(\"0\"))\\n                ans.add(left + (d < j-i ? \".\" : \"\") + right);\\n        }\\n        return ans;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution { \\n    public List<String> ambiguousCoordinates(String S) {\\n        List<String> ans = new ArrayList();\\n        for (int i = 2; i < S.length()-1; ++i)\\n            for (String left: make(S, 1, i))\\n                for (String right: make(S, i, S.length()-1))\\n                    ans.add(\"(\" + left + \", \" + right + \")\");\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1206378,
                "title": "c-simple-tc-o-n-3",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string st){\\n        if(st.length() > 1 && st[0] == \\'0\\'){\\n            return false;\\n        }\\n        return st.length() > 0;\\n    }\\n    \\n    bool isValidDecimal(string st){\\n        if(st.length() > 0 && st[st.length()-1] == \\'0\\'){\\n            return false;\\n        }\\n        return st.length() > 0;\\n    }\\n\\n    vector<string> comma(string s){\\n        vector<string> commaS;\\n        int size = s.length();\\n        string st = \"\";\\n        for(int i = 0;i < size; ++i){\\n            string a = s.substr(0, i+1);\\n            string b = s.substr(i+1);\\n            if(isValid(a) && isValid(b)){\\n                commaS.push_back(a + \", \" + b);\\n            }\\n        }\\n        return commaS;\\n    }\\n    vector<string> decimal(string s){\\n        vector<string> decimalSep;\\n        int size = s.length();\\n        string st = \"\";\\n        for(int i = 0; i < size; ++i){\\n            string a = s.substr(0, i+1);\\n            string b = s.substr(i+1);\\n            for(int j = 0, m = a.size();j < m; ++j){\\n                string c = a.substr(0, j+1);\\n                string d = a.substr(j+1);\\n                if(isValid(c) && isValidDecimal(d)  && isValid(b)){\\n                    decimalSep.push_back(c + \".\" + d + \", \" + b);\\n                }\\n            }\\n            for(int j = 0, m = b.size();j < m; ++j){\\n                string c = b.substr(0, j+1);\\n                string d = b.substr(j+1);\\n                if(isValid(c) && isValidDecimal(d) && isValid(a)){\\n                    decimalSep.push_back(a +  \", \" + c + \".\" + d);\\n                }\\n            }\\n            for(int j = 0, m = a.size();j < m; ++j){\\n                string c = a.substr(0, j+1);\\n                string d = a.substr(j+1);\\n                if(isValid(c) && isValidDecimal(d)){\\n                    for(int k = 0, n = b.size(); k < n; ++k){\\n                        string e = b.substr(0, k+1);\\n                        string f = b.substr(k+1);\\n                        if(isValid(e) && isValidDecimal(f)){\\n                            decimalSep.push_back(c + \".\" + d + \", \" + e + \".\" + f);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return decimalSep;\\n    }\\n    \\n    \\n    vector<string> ambiguousCoordinates(string s) {\\n        string new_s = \"\";\\n        for(char a : s){\\n            if(a!=\\')\\' && a!=\\'(\\'){\\n                new_s += a;\\n            }\\n        }\\n        \\n        int n = new_s.length();\\n        \\n        vector<string> commaSeparated = comma(new_s);\\n        vector<string> decimalSeparated = decimal(new_s);\\n        vector<string> sol;\\n        for(string a : commaSeparated){\\n            sol.push_back(\"(\" + a + \")\");\\n        }\\n        for(string b: decimalSeparated){\\n            sol.push_back(\"(\" + b + \")\");\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string st){\\n        if(st.length() > 1 && st[0] == \\'0\\'){\\n            return false;\\n        }\\n        return st.length() > 0;\\n    }\\n    \\n    bool isValidDecimal(string st){\\n        if(st.length() > 0 && st[st.length()-1] == \\'0\\'){\\n            return false;\\n        }\\n        return st.length() > 0;\\n    }\\n\\n    vector<string> comma(string s){\\n        vector<string> commaS;\\n        int size = s.length();\\n        string st = \"\";\\n        for(int i = 0;i < size; ++i){\\n            string a = s.substr(0, i+1);\\n            string b = s.substr(i+1);\\n            if(isValid(a) && isValid(b)){\\n                commaS.push_back(a + \", \" + b);\\n            }\\n        }\\n        return commaS;\\n    }\\n    vector<string> decimal(string s){\\n        vector<string> decimalSep;\\n        int size = s.length();\\n        string st = \"\";\\n        for(int i = 0; i < size; ++i){\\n            string a = s.substr(0, i+1);\\n            string b = s.substr(i+1);\\n            for(int j = 0, m = a.size();j < m; ++j){\\n                string c = a.substr(0, j+1);\\n                string d = a.substr(j+1);\\n                if(isValid(c) && isValidDecimal(d)  && isValid(b)){\\n                    decimalSep.push_back(c + \".\" + d + \", \" + b);\\n                }\\n            }\\n            for(int j = 0, m = b.size();j < m; ++j){\\n                string c = b.substr(0, j+1);\\n                string d = b.substr(j+1);\\n                if(isValid(c) && isValidDecimal(d) && isValid(a)){\\n                    decimalSep.push_back(a +  \", \" + c + \".\" + d);\\n                }\\n            }\\n            for(int j = 0, m = a.size();j < m; ++j){\\n                string c = a.substr(0, j+1);\\n                string d = a.substr(j+1);\\n                if(isValid(c) && isValidDecimal(d)){\\n                    for(int k = 0, n = b.size(); k < n; ++k){\\n                        string e = b.substr(0, k+1);\\n                        string f = b.substr(k+1);\\n                        if(isValid(e) && isValidDecimal(f)){\\n                            decimalSep.push_back(c + \".\" + d + \", \" + e + \".\" + f);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return decimalSep;\\n    }\\n    \\n    \\n    vector<string> ambiguousCoordinates(string s) {\\n        string new_s = \"\";\\n        for(char a : s){\\n            if(a!=\\')\\' && a!=\\'(\\'){\\n                new_s += a;\\n            }\\n        }\\n        \\n        int n = new_s.length();\\n        \\n        vector<string> commaSeparated = comma(new_s);\\n        vector<string> decimalSeparated = decimal(new_s);\\n        vector<string> sol;\\n        for(string a : commaSeparated){\\n            sol.push_back(\"(\" + a + \")\");\\n        }\\n        for(string b: decimalSeparated){\\n            sol.push_back(\"(\" + b + \")\");\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206352,
                "title": "python-generate-all-and-validate",
                "content": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        def invalid(s):\\n            if \\'.\\' in s:\\n                if s[-1] == \\'0\\':\\n                    return True\\n                # verify the integer part\\n                return invalid(s.split(\\'.\\')[0])\\n            else:\\n                return len(s) > 1 and s[0] == \\'0\\'\\n\\n        def get_combination(s, is_root):\\n            res = []\\n            if is_root:\\n                # add comma\\n                for i in range(1, len(s)):\\n                    first_half_com = get_combination(s[:i], False)\\n                    second_half_com = get_combination(s[i:], False)\\n                    \\n                    for first_half in first_half_com:\\n                        for second_half in second_half_com:\\n                            if invalid(first_half) or invalid(second_half): continue\\n                            res.append(f\"({first_half}, {second_half})\")\\n            else:\\n                # no dot\\n                res.append(s)\\n                # with dot\\n                for i in range(1, len(s)):\\n                    res.append(f\"{s[:i]}.{s[i:]}\")\\n            return res\\n        \\n        s = s[1:-1]\\n        return get_combination(s, True)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        def invalid(s):\\n            if \\'.\\' in s:\\n                if s[-1] == \\'0\\':\\n                    return True\\n                # verify the integer part\\n                return invalid(s.split(\\'.\\')[0])\\n            else:\\n                return len(s) > 1 and s[0] == \\'0\\'\\n\\n        def get_combination(s, is_root):\\n            res = []\\n            if is_root:\\n                # add comma\\n                for i in range(1, len(s)):\\n                    first_half_com = get_combination(s[:i], False)\\n                    second_half_com = get_combination(s[i:], False)\\n                    \\n                    for first_half in first_half_com:\\n                        for second_half in second_half_com:\\n                            if invalid(first_half) or invalid(second_half): continue\\n                            res.append(f\"({first_half}, {second_half})\")\\n            else:\\n                # no dot\\n                res.append(s)\\n                # with dot\\n                for i in range(1, len(s)):\\n                    res.append(f\"{s[:i]}.{s[i:]}\")\\n            return res\\n        \\n        s = s[1:-1]\\n        return get_combination(s, True)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206333,
                "title": "go-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n\\nInspired by [this](https://leetcode.com/problems/ambiguous-coordinates/discuss/123875/Really-clear-Java-code) solution\\n```\\nfunc ambiguousCoordinates(s string) []string {\\n\\tvar res []string\\n\\ts = s[1:len(s)-1]\\n\\tfor i := 1; i < len(s); i++ {\\n\\t\\tleft, right := valid(s[0:i]), valid(s[i:])\\n\\t\\tfor _, l:= range left {\\n\\t\\t\\tfor _, r := range right {\\n\\t\\t\\t\\tres = append(res, \"(\" + l + \", \" + r + \")\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn res\\n}\\n\\nfunc valid(s string) []string {\\n\\tn := len(s)\\n\\tvar res []string\\n\\tif s[0] == \\'0\\' && s[n-1] == \\'0\\' {\\n\\t\\tif n == 1 {\\n\\t\\t\\tres = append(res, \"0\")\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\t\\n\\tif s[0] == \\'0\\' {\\n\\t\\tres = append(res, \"0.\"+s[1:])\\n\\t\\treturn res\\n\\t}\\n\\tif s[n-1] == \\'0\\' {\\n\\t\\tres = append(res, s)\\n\\t\\treturn res\\n\\t}\\n\\tres = append(res, s)\\n\\tfor i:= 1; i < n; i++ {\\n\\t\\tres = append(res, s[0:i] + \".\" + s[i:])\\n\\t}\\n\\t\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc ambiguousCoordinates(s string) []string {\\n\\tvar res []string\\n\\ts = s[1:len(s)-1]\\n\\tfor i := 1; i < len(s); i++ {\\n\\t\\tleft, right := valid(s[0:i]), valid(s[i:])\\n\\t\\tfor _, l:= range left {\\n\\t\\t\\tfor _, r := range right {\\n\\t\\t\\t\\tres = append(res, \"(\" + l + \", \" + r + \")\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn res\\n}\\n\\nfunc valid(s string) []string {\\n\\tn := len(s)\\n\\tvar res []string\\n\\tif s[0] == \\'0\\' && s[n-1] == \\'0\\' {\\n\\t\\tif n == 1 {\\n\\t\\t\\tres = append(res, \"0\")\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\t\\n\\tif s[0] == \\'0\\' {\\n\\t\\tres = append(res, \"0.\"+s[1:])\\n\\t\\treturn res\\n\\t}\\n\\tif s[n-1] == \\'0\\' {\\n\\t\\tres = append(res, s)\\n\\t\\treturn res\\n\\t}\\n\\tres = append(res, s)\\n\\tfor i:= 1; i < n; i++ {\\n\\t\\tres = append(res, s[0:i] + \".\" + s[i:])\\n\\t}\\n\\t\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1206325,
                "title": "java-clean-concise-optimal-code-3ms-time-100-beats-java-solution",
                "content": "```\\nclass Solution {\\n    \\n    public List<String> helper (String s) {\\n        \\n        List<String> answer = new ArrayList<> ();\\n        \\n        if (s.length () == 1) {\\n            answer.add (s);\\n            return answer;\\n        }\\n        else if (s.charAt (0) == \\'0\\' && s.charAt (s.length () - 1) == \\'0\\') {\\n            return answer;\\n        }\\n        else if (s.charAt (0) == \\'0\\') {\\n            StringBuilder sb = new StringBuilder ();\\n            sb.append (s.charAt (0)).append (\".\").append (s.substring (1));\\n            answer.add (sb.toString ());\\n            return answer;\\n        }\\n        else if (s.charAt (s.length () - 1) == \\'0\\') {\\n            answer.add (s);\\n            return answer;\\n        }\\n        \\n        answer.add (s);\\n        \\n        for (int i = 1; i < s.length (); i++) {\\n            StringBuilder sb = new StringBuilder ();\\n            sb.append (s.substring (0, i)).append (\".\").append (s.substring (i));\\n            answer.add (sb.toString ());\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    public List<String> ambiguousCoordinates(String s) {\\n        \\n        List<String> answer = new ArrayList<> ();\\n        \\n        for (int i = 2; i < s.length () - 1; i++) {\\n            List<String> leftLists = helper (s.substring (1, i));\\n            List<String> rightLists = helper (s.substring (i, s.length () - 1));\\n            \\n            for (String leftString : leftLists) {\\n                for (String rightString : rightLists) {\\n                    StringBuilder sb = new StringBuilder ();\\n                    sb.append (\"(\").append (leftString).append (\", \").append (rightString).append (\")\");\\n                    answer.add (sb.toString ());\\n                }\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public List<String> helper (String s) {\\n        \\n        List<String> answer = new ArrayList<> ();\\n        \\n        if (s.length () == 1) {\\n            answer.add (s);\\n            return answer;\\n        }\\n        else if (s.charAt (0) == \\'0\\' && s.charAt (s.length () - 1) == \\'0\\') {\\n            return answer;\\n        }\\n        else if (s.charAt (0) == \\'0\\') {\\n            StringBuilder sb = new StringBuilder ();\\n            sb.append (s.charAt (0)).append (\".\").append (s.substring (1));\\n            answer.add (sb.toString ());\\n            return answer;\\n        }\\n        else if (s.charAt (s.length () - 1) == \\'0\\') {\\n            answer.add (s);\\n            return answer;\\n        }\\n        \\n        answer.add (s);\\n        \\n        for (int i = 1; i < s.length (); i++) {\\n            StringBuilder sb = new StringBuilder ();\\n            sb.append (s.substring (0, i)).append (\".\").append (s.substring (i));\\n            answer.add (sb.toString ());\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    public List<String> ambiguousCoordinates(String s) {\\n        \\n        List<String> answer = new ArrayList<> ();\\n        \\n        for (int i = 2; i < s.length () - 1; i++) {\\n            List<String> leftLists = helper (s.substring (1, i));\\n            List<String> rightLists = helper (s.substring (i, s.length () - 1));\\n            \\n            for (String leftString : leftLists) {\\n                for (String rightString : rightLists) {\\n                    StringBuilder sb = new StringBuilder ();\\n                    sb.append (\"(\").append (leftString).append (\", \").append (rightString).append (\")\");\\n                    answer.add (sb.toString ());\\n                }\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206323,
                "title": "swift-solution",
                "content": "```swift\\nclass Solution {\\n    func ambiguousCoordinates(_ s: String) -> [String] {\\n        var sArr = Array(s)\\n        sArr.removeLast()\\n        sArr.removeFirst()\\n        \\n        func gen(_ s: String) -> [String] {\\n\\n            let sArr = Array(s)\\n            if sArr.endIndex == 1 {return [s]}\\n            var res = [String]()\\n            next: for i in 1...sArr.endIndex {\\n                var left = String(sArr[0..<i])\\n                var right = String(sArr[i...])\\n                if right == \"\" {\\n                    let leftNum = Int(left)!\\n                    if Array(left)[0] == \"0\" {continue next}\\n                    res.append(String(left))\\n                } else {\\n                    let leftNum = Int(left)!, rightNum = Int(right)!\\n                    if leftNum == 0 && left.count > 1 {continue next}\\n                    if rightNum == 0 {continue next}\\n                    if Array(right)[right.count-1] == \"0\" {continue next}\\n                    if Array(left)[0] == \"0\" && leftNum > 0 {continue next}\\n                    \\n                    res.append(left+\".\"+right) \\n                }\\n\\n            }\\n            return res\\n        }\\n        var res = [String]()\\n        for i in 1..<sArr.endIndex {\\n            let w1 = String(sArr[0..<i])\\n            let w2 = String(sArr[i...])\\n            let w1list = gen(w1), w2list = gen(w2)\\n            for left in w1list {\\n                for right in w2list {\\n                    \\n                    res.append(\"(\\\\(left), \\\\(right))\")\\n                }\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func ambiguousCoordinates(_ s: String) -> [String] {\\n        var sArr = Array(s)\\n        sArr.removeLast()\\n        sArr.removeFirst()\\n        \\n        func gen(_ s: String) -> [String] {\\n\\n            let sArr = Array(s)\\n            if sArr.endIndex == 1 {return [s]}\\n            var res = [String]()\\n            next: for i in 1...sArr.endIndex {\\n                var left = String(sArr[0..<i])\\n                var right = String(sArr[i...])\\n                if right == \"\" {\\n                    let leftNum = Int(left)!\\n                    if Array(left)[0] == \"0\" {continue next}\\n                    res.append(String(left))\\n                } else {\\n                    let leftNum = Int(left)!, rightNum = Int(right)!\\n                    if leftNum == 0 && left.count > 1 {continue next}\\n                    if rightNum == 0 {continue next}\\n                    if Array(right)[right.count-1] == \"0\" {continue next}\\n                    if Array(left)[0] == \"0\" && leftNum > 0 {continue next}\\n                    \\n                    res.append(left+\".\"+right) \\n                }\\n\\n            }\\n            return res\\n        }\\n        var res = [String]()\\n        for i in 1..<sArr.endIndex {\\n            let w1 = String(sArr[0..<i])\\n            let w2 = String(sArr[i...])\\n            let w1list = gen(w1), w2list = gen(w2)\\n            for left in w1list {\\n                for right in w2list {\\n                    \\n                    res.append(\"(\\\\(left), \\\\(right))\")\\n                }\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206320,
                "title": "c-clean-and-commented-with-examples-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPair(const string& a, const string& b) {\\n        return \"(\" + a + \", \" + b + \")\";\\n    }\\n    \\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1, s.length()-2);\\n        int n = s.length();\\n        \\n        vector<string> result;\\n        \\n        for(int i = 1; i<n; i++) {\\n            string a = s.substr(0, i);\\n            string b = s.substr(i);\\n            \\n            vector<string> left  = helper(a);\\n            vector<string> right = helper(b);\\n            \\n            for(const string& s1 : left) {\\n                for(const string& s2 : right) {\\n                    result.push_back(getPair(s1, s2));\\n                }\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n    \\n    vector<string> helper(string& s) {\\n        int n = s.length();\\n        vector<string> result;\\n\\t\\t//starts with \\'0\\' and ends with \\'0\\'\\n        if(s[0] == \\'0\\' && s[n-1] == \\'0\\') {\\n\\t\\t /*\\n\\t\\t\\t we can\\'t process strings like \"0120\" because we will\\n\\t\\t\\t have 0 in beginngin and end as well. Also, we can\\n\\t\\t\\t only allow \"0\" in this scenario\\n\\t\\t*/\\n            if(n == 1)\\n                result.push_back(\"0\");\\n            return result;\\n        }\\n        \\n\\t\\t//starts with \\'0\\'\\n        if(s[0] == \\'0\\') {\\n            //example : 012 or 0012\\n            //we can only do 0.12 or 0.012 and no other way\\n            result.push_back(\"0.\" + s.substr(1));\\n            return result;\\n        }\\n        \\n\\t\\t//ends with \\'0\\'\\n        if(s[n-1] == \\'0\\') {\\n            //example : 120: we have no option because 1.20 no allowed, 12.0 not allowed\\n            result.push_back(s);\\n            return result;\\n        }\\n        \\n\\t\\t//no \\'0\\' in start or end\\n\\t\\t//example : 123 -> {1.23, 12.3}\\n        result.push_back(s);\\n        for(int i = 1; i<n; i++) {\\n            string temp = s.substr(0, i) + \".\" + s.substr(i);\\n            result.push_back(temp);\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPair(const string& a, const string& b) {\\n        return \"(\" + a + \", \" + b + \")\";\\n    }\\n    \\n    vector<string> ambiguousCoordinates(string s) {\\n        s = s.substr(1, s.length()-2);\\n        int n = s.length();\\n        \\n        vector<string> result;\\n        \\n        for(int i = 1; i<n; i++) {\\n            string a = s.substr(0, i);\\n            string b = s.substr(i);\\n            \\n            vector<string> left  = helper(a);\\n            vector<string> right = helper(b);\\n            \\n            for(const string& s1 : left) {\\n                for(const string& s2 : right) {\\n                    result.push_back(getPair(s1, s2));\\n                }\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n    \\n    vector<string> helper(string& s) {\\n        int n = s.length();\\n        vector<string> result;\\n\\t\\t//starts with \\'0\\' and ends with \\'0\\'\\n        if(s[0] == \\'0\\' && s[n-1] == \\'0\\') {\\n\\t\\t /*\\n\\t\\t\\t we can\\'t process strings like \"0120\" because we will\\n\\t\\t\\t have 0 in beginngin and end as well. Also, we can\\n\\t\\t\\t only allow \"0\" in this scenario\\n\\t\\t*/\\n            if(n == 1)\\n                result.push_back(\"0\");\\n            return result;\\n        }\\n        \\n\\t\\t//starts with \\'0\\'\\n        if(s[0] == \\'0\\') {\\n            //example : 012 or 0012\\n            //we can only do 0.12 or 0.012 and no other way\\n            result.push_back(\"0.\" + s.substr(1));\\n            return result;\\n        }\\n        \\n\\t\\t//ends with \\'0\\'\\n        if(s[n-1] == \\'0\\') {\\n            //example : 120: we have no option because 1.20 no allowed, 12.0 not allowed\\n            result.push_back(s);\\n            return result;\\n        }\\n        \\n\\t\\t//no \\'0\\' in start or end\\n\\t\\t//example : 123 -> {1.23, 12.3}\\n        result.push_back(s);\\n        for(int i = 1; i<n; i++) {\\n            string temp = s.substr(0, i) + \".\" + s.substr(i);\\n            result.push_back(temp);\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206181,
                "title": "ambiguous-coordinates-python-simple-solution",
                "content": "\\n\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n\\t\\t\\n        def poss_combs(t: str):\\n            if len(t) == 1:\\n                return [t]\\n            elif t[0]==\"0\":\\n                return [] if t[-1] == \"0\" else [\"0.\"+t[1:]]\\n            elif t[-1]==\"0\":\\n                return [t]\\n            else:\\n                return [t[:idx_] + \".\" + t[idx_:] for idx_ in range(1, len(t))] + [t]\\n\\n        list_ = []\\n        for idx_ in range(1, len(s)):\\n            # first we split the string into two halves\\n            s1 = s[:idx_]\\n            s2 = s[idx_:]\\n        \\n            # compute the possible permutations for the given substrings\\n            c1 = poss_combs(s1)\\n            if len(c1) > 0:\\n                c2 = poss_combs(s2)\\n                if len(c2) > 0:\\n\\t\\t\\t\\t\\t# create a list of all possible combinations\\n                    list_ += [f\"({a1}, {a2})\" for a1 in c1 for a2 in c2]\\n                \\n        return list_\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n\\t\\t\\n        def poss_combs(t: str):\\n            if len(t) == 1:\\n                return [t]\\n            elif t[0]==\"0\":\\n                return [] if t[-1] == \"0\" else [\"0.\"+t[1:]]\\n            elif t[-1]==\"0\":\\n                return [t]\\n            else:\\n                return [t[:idx_] + \".\" + t[idx_:] for idx_ in range(1, len(t))] + [t]\\n\\n        list_ = []\\n        for idx_ in range(1, len(s)):\\n            # first we split the string into two halves\\n            s1 = s[:idx_]\\n            s2 = s[idx_:]\\n        \\n            # compute the possible permutations for the given substrings\\n            c1 = poss_combs(s1)\\n            if len(c1) > 0:\\n                c2 = poss_combs(s2)\\n                if len(c2) > 0:\\n\\t\\t\\t\\t\\t# create a list of all possible combinations\\n                    list_ += [f\"({a1}, {a2})\" for a1 in c1 for a2 in c2]\\n                \\n        return list_\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206178,
                "title": "java-3ms-bruceforce",
                "content": "divide 2 part and \\ncreate all possible string from each part\\n\\n```\\nclass Solution {\\n    List<String> res = new ArrayList();\\n    \\n    public List<String> ambiguousCoordinates(String s) {\\n        int n=s.length();\\n        for (int i = 2;i<n-1;i++){\\n            List<String> l = help(s.substring(1,i));\\n            List<String> r = help(s.substring(i,n-1));\\n            if (l.size()!=0&&r.size()!=0) result(l,r);\\n        }\\n        return res;\\n    }\\n    \\n    private void result(List<String> l,List<String> r){\\n        for (String str1:l){\\n            for (String str2:r){\\n                StringBuilder sb = new StringBuilder();\\n                sb.append(\\'(\\');\\n                sb.append(str1);\\n                sb.append(\", \");\\n                sb.append(str2);\\n                sb.append(\\')\\');\\n                res.add(sb.toString());\\n            }\\n        }\\n    }\\n    \\n    private List<String> help(String str){\\n        List<String> list = new ArrayList();\\n        int n = str.length();\\n        if (n==1){\\n            list.add(str);\\n            return list;\\n        }\\n        if (str.charAt(n-1)==\\'0\\'){\\n            if (str.charAt(0)==\\'0\\') return list;\\n            else{\\n                list.add(str);\\n                return list;\\n            }\\n        }else if (str.charAt(0)!=\\'0\\') list.add(str);\\n        for (int i=1;i<n;i++){\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(str.substring(0,i));\\n            sb.append(\\'.\\');\\n        sb.append(str.substring(i,n));\\n                list.add(sb.toString());\\n            if (str.charAt(0)==\\'0\\') break;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<String> res = new ArrayList();\\n    \\n    public List<String> ambiguousCoordinates(String s) {\\n        int n=s.length();\\n        for (int i = 2;i<n-1;i++){\\n            List<String> l = help(s.substring(1,i));\\n            List<String> r = help(s.substring(i,n-1));\\n            if (l.size()!=0&&r.size()!=0) result(l,r);\\n        }\\n        return res;\\n    }\\n    \\n    private void result(List<String> l,List<String> r){\\n        for (String str1:l){\\n            for (String str2:r){\\n                StringBuilder sb = new StringBuilder();\\n                sb.append(\\'(\\');\\n                sb.append(str1);\\n                sb.append(\", \");\\n                sb.append(str2);\\n                sb.append(\\')\\');\\n                res.add(sb.toString());\\n            }\\n        }\\n    }\\n    \\n    private List<String> help(String str){\\n        List<String> list = new ArrayList();\\n        int n = str.length();\\n        if (n==1){\\n            list.add(str);\\n            return list;\\n        }\\n        if (str.charAt(n-1)==\\'0\\'){\\n            if (str.charAt(0)==\\'0\\') return list;\\n            else{\\n                list.add(str);\\n                return list;\\n            }\\n        }else if (str.charAt(0)!=\\'0\\') list.add(str);\\n        for (int i=1;i<n;i++){\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(str.substring(0,i));\\n            sb.append(\\'.\\');\\n        sb.append(str.substring(i,n));\\n                list.add(sb.toString());\\n            if (str.charAt(0)==\\'0\\') break;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206143,
                "title": "java-solution-with-explanation-4ms-beats-100",
                "content": "I\\'m dividing the given string into two parts and for each part I\\'m generating the possible numbers for that part. If any pair formed by doing so has the first and second number valid, I\\'m adding it to answer.\\n\\n```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s)\\n    {\\n        int divide = 1;\\n        List<String> ans = new ArrayList<String>();\\n        s = s.substring(1,s.length()-1);\\n        while(divide < s.length())\\n        {\\n            List<String> first = gen(s.substring(0,divide));\\n            List<String> second = gen(s.substring(divide));\\n            for(String f : first)\\n            {\\n                for(String se : second)\\n                {\\n                    //System.out.println(f+\" \"+se);\\n                    if(valid(f) && valid(se))\\n                    {\\n                        StringBuilder sb = new StringBuilder();\\n                        sb.append(\"(\");\\n                        sb.append(f);\\n                        sb.append(\", \");\\n                        sb.append(se);\\n                        sb.append(\")\");\\n                        ans.add(sb.toString());\\n                    }\\n                }\\n            }\\n            divide++;\\n        }\\n        return ans;\\n    }\\n    public static List<String> gen(String s)\\n    {\\n        int divide = 1;\\n        List<String> toret = new ArrayList<String>();\\n        if(s.length() == 1)\\n        {\\n            toret.add(s);\\n            return toret;\\n        }\\n        toret.add(s);\\n        while(divide < s.length())\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(s.substring(0,divide));\\n            sb.append(\".\");\\n            sb.append(s.substring(divide));\\n            toret.add(sb.toString());\\n            divide++;\\n        }\\n        return toret;\\n    }\\n    public static Boolean valid(String s)\\n    {\\n        if(s.length() == 1)\\n            return true;\\n        if(s.charAt(0)==\\'0\\' && s.charAt(1)!=\\'.\\')\\n            return false;\\n        if(s.contains(\".\") && s.charAt(s.length()-1)==\\'0\\')\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> ambiguousCoordinates(String s)\\n    {\\n        int divide = 1;\\n        List<String> ans = new ArrayList<String>();\\n        s = s.substring(1,s.length()-1);\\n        while(divide < s.length())\\n        {\\n            List<String> first = gen(s.substring(0,divide));\\n            List<String> second = gen(s.substring(divide));\\n            for(String f : first)\\n            {\\n                for(String se : second)\\n                {\\n                    //System.out.println(f+\" \"+se);\\n                    if(valid(f) && valid(se))\\n                    {\\n                        StringBuilder sb = new StringBuilder();\\n                        sb.append(\"(\");\\n                        sb.append(f);\\n                        sb.append(\", \");\\n                        sb.append(se);\\n                        sb.append(\")\");\\n                        ans.add(sb.toString());\\n                    }\\n                }\\n            }\\n            divide++;\\n        }\\n        return ans;\\n    }\\n    public static List<String> gen(String s)\\n    {\\n        int divide = 1;\\n        List<String> toret = new ArrayList<String>();\\n        if(s.length() == 1)\\n        {\\n            toret.add(s);\\n            return toret;\\n        }\\n        toret.add(s);\\n        while(divide < s.length())\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(s.substring(0,divide));\\n            sb.append(\".\");\\n            sb.append(s.substring(divide));\\n            toret.add(sb.toString());\\n            divide++;\\n        }\\n        return toret;\\n    }\\n    public static Boolean valid(String s)\\n    {\\n        if(s.length() == 1)\\n            return true;\\n        if(s.charAt(0)==\\'0\\' && s.charAt(1)!=\\'.\\')\\n            return false;\\n        if(s.contains(\".\") && s.charAt(s.length()-1)==\\'0\\')\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206133,
                "title": "python-2-simple-solutions",
                "content": "Solution 1: simply generate all possible number strings.\\nAt each number string, check valid by converting to number, then to string again. For example: \"004\" is not a valid number string, since len(\"004\") != len(str(int(\"004\"))\\nFor floats, use decimal.Decimal for accuracy.\\n```\\nfrom decimal import Decimal\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        \\n        def get_valid_nums(base):\\n            result = [fpnum for i in range(1, len(base)) if int(base[i:]) != 0 and len(str(Decimal(fpnum := f\\'{base[:i]}.{base[i:]}\\').normalize())) == len(fpnum)]\\n            if len(str(int(base))) == len(base): result += [base]\\n            return result\\n            \\n        result = []\\n        for i in range(1, len(s)):\\n            result.extend([f\\'({x}, {y})\\' for x, y in product(get_valid_nums(s[:i]), get_valid_nums(s[i:]))])\\n            \\n        return result\\n```\\n---\\nSolution 2:\\nIf base string starts with 0 and ends with 0, string is not a valid number\\nIf base string ends with 0, return base string\\nIf base string starts with 0, return 0.rest\\nIf base string starts and ends with not 0, return any possible float from base string\\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        \\n        def get_valid_nums(base):\\n            if len(base) > 1 and base[0] == base[-1] == \\'0\\': return []\\n            elif base[-1] == \\'0\\': return [base]\\n            elif base[0] == \\'0\\': return [base[0] + \\'.\\' + base[1:]]\\n            else: return [f\\'{base[:i]}.{base[i:]}\\' for i in range(1, len(base))] + [base]\\n        \\n        result = []\\n        for i in range(1, len(s)):\\n            result.extend([f\\'({x}, {y})\\' for x, y in product(get_valid_nums(s[:i]), get_valid_nums(s[i:]))])\\n            \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nfrom decimal import Decimal\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        \\n        def get_valid_nums(base):\\n            result = [fpnum for i in range(1, len(base)) if int(base[i:]) != 0 and len(str(Decimal(fpnum := f\\'{base[:i]}.{base[i:]}\\').normalize())) == len(fpnum)]\\n            if len(str(int(base))) == len(base): result += [base]\\n            return result\\n            \\n        result = []\\n        for i in range(1, len(s)):\\n            result.extend([f\\'({x}, {y})\\' for x, y in product(get_valid_nums(s[:i]), get_valid_nums(s[i:]))])\\n            \\n        return result\\n```\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s[1:-1]\\n        \\n        def get_valid_nums(base):\\n            if len(base) > 1 and base[0] == base[-1] == \\'0\\': return []\\n            elif base[-1] == \\'0\\': return [base]\\n            elif base[0] == \\'0\\': return [base[0] + \\'.\\' + base[1:]]\\n            else: return [f\\'{base[:i]}.{base[i:]}\\' for i in range(1, len(base))] + [base]\\n        \\n        result = []\\n        for i in range(1, len(s)):\\n            result.extend([f\\'({x}, {y})\\' for x, y in product(get_valid_nums(s[:i]), get_valid_nums(s[i:]))])\\n            \\n        return result\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1670388,
                "content": [
                    {
                        "username": "zhengweix",
                        "content": "why new look????"
                    },
                    {
                        "username": "vivek_-_kr",
                        "content": "Yes "
                    }
                ]
            }
        ]
    },
    {
        "title": "Last Substring in Lexicographical Order",
        "question_content": "<p>Given a string <code>s</code>, return <em>the last substring of</em> <code>s</code> <em>in lexicographical order</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abab&quot;\n<strong>Output:</strong> &quot;bab&quot;\n<strong>Explanation:</strong> The substrings are [&quot;a&quot;, &quot;ab&quot;, &quot;aba&quot;, &quot;abab&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bab&quot;]. The lexicographically maximum substring is &quot;bab&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;leetcode&quot;\n<strong>Output:</strong> &quot;tcode&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 4 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> contains only lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 363662,
                "title": "short-python-code-o-n-time-and-o-1-space-with-proof-and-visualization",
                "content": "The solution must be in one of those n suffix candidates, and **the main idea here is to eliminate those candidates we are certain not the solution, at last, the only one left is our solution**.\\n\\nGiven `i < j`, assuming that for any `p < j` and `p != i`, `s[p:]` is smaller than the maximum substring (not the solution). \\n\\nFor `j = i+d`, where `d >= 1`, and  `k >= 0`, considering for any `0 <= x < k, s[i+x] == s[j+x]`, we have several cases to discuss.\\n1. `s[i+k] == s[j+k]`, we simply `k++`;\\n2. `s[i+k] > s[j+k]`, for any `0 <= p0 <= k`, we have substring `s[j+p0:] < s[i+p0:] = s[j-d+p0:] = s[j+p1:] < s[i+p1:] = ...` and so on, where we have `p0 = p1+d > p1 > p2... `until `j+pn < j`, in other words `s[j+p0:] < s[p:]` for some `p` where `i <= p < j`, therefore `s[j+p0:]` will not be the solution, we can safely update `j` to` j+k+1` **while still holding our assumption for any `p < j\\nand\\np != i`, `s[p:]` is not the solution;**\\n<img src=\"https://assets.leetcode.com/users/nate17/image_1566444266.png\" alt=\"\" style=\"width: 400px;\"/>\\n\\n\\n3. `s[i+k] < s[j+k]`, for any `0 <= p0 <= k`, we have substring `s[i+p0:] < s[j+p0:] = s[i+d+p0:] = s[i+p1:] < s[j+p1:] = ...` and so on, where we have `p0 = p1-d < p1 < p2...` until `i+pn > i+k`, in other words `s[i+p0:] < s[p:]` for some p where `p > i+k`, therefore `s[i+p0:]` will not be our solution, we can safely update `i` to `max(i+k+1, j)` and then update `j` to `i+1`  **while holding our assumption;**\\n<img src=\"https://assets.leetcode.com/users/nate17/image_1566445075.png\" alt=\"\" style=\"width: 450px;\"/>\\n\\nIn addition, we take into account the base case where `i+1 == j`, and `i == 0`, our assumption holds by itself. \\n\\nIn the end, we can regard `s[j+k] == \"\"` as a empty character when `j+k == n`, which falls into case two `s[i+k] > s[j+k]` in our discussion above, therefore eliminating all candidates from `j` to `j+k`, leaving the only one `s[i:]`, hence our solution.\\n\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        i, j, k = 0, 1, 0\\n        n = len(s)\\n        while j + k < n:\\n            if s[i+k] == s[j+k]:\\n                k += 1\\n                continue\\n            elif s[i+k] > s[j+k]:\\n                j = j + k + 1\\n            else:\\n                i = max(i + k + 1, j)\\n                j = i + 1\\n            k = 0\\n        return s[i:]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        i, j, k = 0, 1, 0\\n        n = len(s)\\n        while j + k < n:\\n            if s[i+k] == s[j+k]:\\n                k += 1\\n                continue\\n            elif s[i+k] > s[j+k]:\\n                j = j + k + 1\\n            else:\\n                i = max(i + k + 1, j)\\n                j = i + 1\\n            k = 0\\n        return s[i:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 582703,
                "title": "c-simple-easy-solution-with-explanation-cheers",
                "content": "```\\nclass Solution {\\npublic:\\n// We use \"j\" to find a better starting index. If any is found, we use it to update \"i\"\\n\\n// 1.\"i\" is the starting index of the first substring\\n// 2.\"j\" is the staring index of the second substring\\n// 3.\"k\" is related to substring.length() (eg. \"k\" is substring.length()-1)\\n\\n// Case 1 (s[i+k]==s[j+k]):\\n// -> If s.substr(i,k+1)==s.substr(j,k+1), we keep increasing k.\\n// Case 2 (s[i+k]<s[j+k]):\\n// -> If the second substring is larger, we update i with max(i+k+1,j). \\n//Since we can skip already matched things (The final answer is s.substr(i))\\n// Case 3 (s[i+k]>s[j+k]):\\n// -> If the second substring is smaller, we just change the starting index of the second string to j+k+1. \\n//Because s[j]~s[j+k] must be less than s[i], otherwise \"i\" will be updated by \"j\". So the next possible candidate is \"j+k+1\".\\n\\n    string lastSubstring(string s) {\\n        int n=s.length(),i=0,j=1,k=0;\\n        while(j+k<n)\\n        {\\n            if(s[i+k]==s[j+k]) k++; \\n            else if(s[i+k]<s[j+k]) i=max(i+k+1,j),j=i+1,k=0;\\n            else j+=k+1,k=0;\\n        }\\n        return s.substr(i);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n// We use \"j\" to find a better starting index. If any is found, we use it to update \"i\"\\n\\n// 1.\"i\" is the starting index of the first substring\\n// 2.\"j\" is the staring index of the second substring\\n// 3.\"k\" is related to substring.length() (eg. \"k\" is substring.length()-1)\\n\\n// Case 1 (s[i+k]==s[j+k]):\\n// -> If s.substr(i,k+1)==s.substr(j,k+1), we keep increasing k.\\n// Case 2 (s[i+k]<s[j+k]):\\n// -> If the second substring is larger, we update i with max(i+k+1,j). \\n//Since we can skip already matched things (The final answer is s.substr(i))\\n// Case 3 (s[i+k]>s[j+k]):\\n// -> If the second substring is smaller, we just change the starting index of the second string to j+k+1. \\n//Because s[j]~s[j+k] must be less than s[i], otherwise \"i\" will be updated by \"j\". So the next possible candidate is \"j+k+1\".\\n\\n    string lastSubstring(string s) {\\n        int n=s.length(),i=0,j=1,k=0;\\n        while(j+k<n)\\n        {\\n            if(s[i+k]==s[j+k]) k++; \\n            else if(s[i+k]<s[j+k]) i=max(i+k+1,j),j=i+1,k=0;\\n            else j+=k+1,k=0;\\n        }\\n        return s.substr(i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361121,
                "title": "python-o-n-with-explanation",
                "content": "First, the answer must be starting with the largest letter, ending at the end of string S. So we save all the \"candidates\" by their starting point, and assign a pointer to each of them (pointing at the start).\\nThen we increment the pointer for each candidate, using following rules:\\n1. We filter the candidates by the letter their pointers are at. Only the ones with the largest letter will go into next round.\\n2. If a pointer meets a starting point, it \"swallows\" the next candidate like a snake.\\nIn the following image, pointer of A meets the starting point of B. Suppose we want to keep candidate B. The only possibility is the future letters are lexicographically larger than candidate B, so appending it to B makes B larger than A. Apprently it can not be, otherwise B (and A) will not be selected initially as candidates.\\n\\n![image](https://assets.leetcode.com/users/mapleisle/image_1566102896.png)\\n\\nFinally we will have only one candidate.\\nThis gives O(n) time complexity. Not very strictly, assume we start with k candidates, then eliminating all except one candidate takes n/k steps. In each step, we only increment the pointer of each candidate by one.\\nCorrect me if I made a mistake. :)\\n\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        count=collections.defaultdict(list)\\n        for i in range(len(s)):\\n            count[s[i]].append(i)\\n        largeC=max(count.keys())\\n        starts={}\\n        for pos in count[largeC]:\\n            starts[pos]=pos+1\\n\\t\\t# Initialize all candidates and their pointers\\n\\t\\t\\n        while len(starts)>1:\\n\\t\\t# Eliminate till we have only one\\n            toDel=set()\\n            nextC=collections.defaultdict(list)\\n            for start,end in starts.items():\\n                if end==len(s):\\n\\t\\t\\t\\t# Remove if reaching the end\\n                    toDel.add(start)\\n                    continue\\n\\t\\t\\t\\t\\t\\n                nextC[s[end]].append(start)\\n\\t\\t\\t\\t# Filter by current letter\\n\\t\\t\\t\\t\\n                if end in starts:\\n                    toDel.add(end)\\n\\t\\t\\t\\t# \"Swallow\" the latter candidate\\n\\t\\t\\t\\n            nextStarts={}\\n            largeC=max(nextC.keys())\\n            for start in nextC[largeC]:\\n                if start not in toDel:\\n                    nextStarts[start]=starts[start]+1\\n\\t\\t\\t\\t\\t# Select what we keep for the next step\\n            starts=nextStarts.copy()\\n        for start,end in starts.items():\\n            return s[start:]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        count=collections.defaultdict(list)\\n        for i in range(len(s)):\\n            count[s[i]].append(i)\\n        largeC=max(count.keys())\\n        starts={}\\n        for pos in count[largeC]:\\n            starts[pos]=pos+1\\n\\t\\t# Initialize all candidates and their pointers\\n\\t\\t\\n        while len(starts)>1:\\n\\t\\t# Eliminate till we have only one\\n            toDel=set()\\n            nextC=collections.defaultdict(list)\\n            for start,end in starts.items():\\n                if end==len(s):\\n\\t\\t\\t\\t# Remove if reaching the end\\n                    toDel.add(start)\\n                    continue\\n\\t\\t\\t\\t\\t\\n                nextC[s[end]].append(start)\\n\\t\\t\\t\\t# Filter by current letter\\n\\t\\t\\t\\t\\n                if end in starts:\\n                    toDel.add(end)\\n\\t\\t\\t\\t# \"Swallow\" the latter candidate\\n\\t\\t\\t\\n            nextStarts={}\\n            largeC=max(nextC.keys())\\n            for start in nextC[largeC]:\\n                if start not in toDel:\\n                    nextStarts[start]=starts[start]+1\\n\\t\\t\\t\\t\\t# Select what we keep for the next step\\n            starts=nextStarts.copy()\\n        for start,end in starts.items():\\n            return s[start:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362387,
                "title": "java-python-3-two-short-o-n-codes-language-2-pointers-and-encoding",
                "content": "**Update:**\\n\\nQ & A:\\nQ:\\nIn method 1, Why is \"if (c < d) { i += offset + 1; } // chars in [i, ..., i + offset] <= charAt(i) == charAt(j)\"?\\nCan you explain more?\\nA:\\n1. `offset` is reset to `0` whenever `c != d`, and the code will keep searching for larger char by forward pointer `i` or `j`, depends on at which index the char is smaller; \\n2. Obviously, only when `charAt(i) == charAt(j)` and their following chars are also equal, `offset ` could be > 0;\\n3. The chars in (i, ..., i + offset] and (j, ..., j + offset] are equal to each other, respectively; **The key point is: they all have already been compared to *charAt(i)* or *charAt(j)* directly, or indirectly, and none greater than *charAt(i)* (or *charAt(j)*); That is why we can forward i/j by offset + 1, and attempt to search for next char that is at least equal to *charAt(i)* (or *charAt(j)*)**.\\n\\ne.g., the following case is impossible for the code in method 1 againts input `s = \"aacaac\"`:\\n\\ni = 0, j = 3, offset = 2\\n\\nbefore j reach 3 (`a`), [j, ..., j + offset] must have already covered index 2 (`c`), and `c` has been compared directly with `a = charAt(i + offset) == charAt(j)  (i = 0, j = 1, offset = 1)`, hence indirectly compared with `charAt(i)` since `charAt(i) == charAt(j)`.\\n\\nIn fact, when `i = 0, j = 1, offset = 1, c = charAt(i + offset) < d = charAt(j + offset). i` will forward `offset + 1 = 2` to index `2`, according to the code.\\n\\n----\\n\\n**Method 1: 2 pointers** -- credit to **@TianjuZhou** for his improvement.\\n\\n**Java**\\n\\n```\\n    public String lastSubstring(String s) {\\n        int i = 0, j = 1, offset = 0, len = s.length();\\n        while (i + offset < len && j + offset < len) {\\n            char c = s.charAt(i + offset), d = s.charAt(j + offset);\\n            if (c == d) {\\n                ++offset;\\n            }else {\\n                if (c < d)  { i += offset + 1; } // chars in [i, ..., i + offset] <= charAt(i) == charAt(j)\\n                else { j += offset + 1; } // c > d, chars in [j, ..., j + offset] <= charAt(i) == charAt(j)\\n                if (i == j) { ++j; } // avoid duplicate start indices. \\n                offset = 0; // reset offset to 0.\\n            }\\n        }\\n        return s.substring(i);\\n    }\\n```\\n\\n----\\n\\n**Python 3**\\n\\n```\\n    def lastSubstring(self, s: str) -> str:\\n        i, j, offset = 0, 1, 0\\n        while i + offset < len(s) and j + offset < len(s):\\n            if s[i + offset] == s[j + offset]:\\n                offset += 1\\n            else:\\n                if s[i + offset] < s[j + offset]:\\n                    i += offset + 1\\n                else:\\n                    j += offset + 1\\n                if i == j:\\n                    j += 1\\n                offset = 0\\n        return s[i :]\\n```\\n**Analysis:**\\n\\nWhenever comparing `offset` times, either `i` or `j` forward `offset` steps, so faster pointer at most visit each character twice.\\n\\nTime: O(n), space: O(1), n = s.length().\\n\\n----\\n\\n**Method 2: encoding**\\nWe can assign values `0 ~ 25` to chars `a ~ z`, respectively. The radix is `26`, since there are `26` distinct characters.\\n\\nSince **during string comparision, the most significant character (MSC) is the left most char and the least significant char (LSC) is the right most char, we should assign MSC heaviest weight and LSC the lightest weight.** Therefore, we can map the lexicographical order of a string to a `double` type numerical value as the following expression: \\n\\n[1st char value *  radix ** (n - 1)] + [2nd char value * radix ** (n - 2)] + [3rd char value * (radix ** (n - 3))] + ... + [nth char value * radix ** 0]\\n\\nInitially I used 26 as radix but got either TLE or Wrong Answer due to the double underflow (credit to **@JasperTso**\\'s correction), so I changed a smaller radix: number of distinct characters. \\ne.g., for \"bba\", radix is `2`, and we have suffices \"a\", \"ba\", \"bba\" and their encoding are as follows:\\n0 * 2  * 2 = 0, 0 * 2 + 1 * 2 * 2 = 4, 0 + 1 * 2 + 1 * 2 * 2 = 6\\n\\n1. Traverse the input string reversely, encode all suffices and compare them and update max and the corresponding index. \\n\\n2. We can use `TreeSet.headSet(key).size()` to get indices of corresponding characters.\\n\\n**Java**\\n\\n```\\n    public String lastSubstring(String s) {\\n        TreeSet<Character> ts = new TreeSet<>();\\n        for (int i = 0; i < s.length(); ++i)\\n            ts.add(s.charAt(i));\\n        int radix = ts.size(), lo = 0;\\n        double max = 0d, cur = 0d;\\n        for (int i = s.length() - 1; i >= 0; --i) {\\n            cur = ts.headSet(s.charAt(i)).size() + cur / radix;\\n            if (max <= cur) {\\n                max = cur;\\n                lo = i;\\n            }\\n        }\\n        return s.substring(lo);\\n    }\\n```\\n**Analysis:**\\n\\nTime: O(n), space: O(1), n = s.length().\\n\\n---\\n\\n**Python 3**\\n\\n```\\n    def lastSubstring(self, s: str) -> str:\\n        index = {c: i for i, c in enumerate(sorted(set(s)))}\\n        radix, val, cur, lo = len(index), 0, 0, 0\\n        for i in range(len(s) - 1, -1, -1):\\n            cur = index[s[i]] + cur / radix\\n            if cur >= val:\\n                lo, val = i, cur\\n        return s[lo:]\\n```\\n**Analysis:**\\n\\nTime &  space: O(n), n = s.length().\\n",
                "solutionTags": [],
                "code": "```\\n    public String lastSubstring(String s) {\\n        int i = 0, j = 1, offset = 0, len = s.length();\\n        while (i + offset < len && j + offset < len) {\\n            char c = s.charAt(i + offset), d = s.charAt(j + offset);\\n            if (c == d) {\\n                ++offset;\\n            }else {\\n                if (c < d)  { i += offset + 1; } // chars in [i, ..., i + offset] <= charAt(i) == charAt(j)\\n                else { j += offset + 1; } // c > d, chars in [j, ..., j + offset] <= charAt(i) == charAt(j)\\n                if (i == j) { ++j; } // avoid duplicate start indices. \\n                offset = 0; // reset offset to 0.\\n            }\\n        }\\n        return s.substring(i);\\n    }\\n```\n```\\n    def lastSubstring(self, s: str) -> str:\\n        i, j, offset = 0, 1, 0\\n        while i + offset < len(s) and j + offset < len(s):\\n            if s[i + offset] == s[j + offset]:\\n                offset += 1\\n            else:\\n                if s[i + offset] < s[j + offset]:\\n                    i += offset + 1\\n                else:\\n                    j += offset + 1\\n                if i == j:\\n                    j += 1\\n                offset = 0\\n        return s[i :]\\n```\n```\\n    public String lastSubstring(String s) {\\n        TreeSet<Character> ts = new TreeSet<>();\\n        for (int i = 0; i < s.length(); ++i)\\n            ts.add(s.charAt(i));\\n        int radix = ts.size(), lo = 0;\\n        double max = 0d, cur = 0d;\\n        for (int i = s.length() - 1; i >= 0; --i) {\\n            cur = ts.headSet(s.charAt(i)).size() + cur / radix;\\n            if (max <= cur) {\\n                max = cur;\\n                lo = i;\\n            }\\n        }\\n        return s.substring(lo);\\n    }\\n```\n```\\n    def lastSubstring(self, s: str) -> str:\\n        index = {c: i for i, c in enumerate(sorted(set(s)))}\\n        radix, val, cur, lo = len(index), 0, 0, 0\\n        for i in range(len(s) - 1, -1, -1):\\n            cur = index[s[i]] + cur / radix\\n            if cur >= val:\\n                lo, val = i, cur\\n        return s[lo:]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 360994,
                "title": "why-brute-force-is-passing-successfully",
                "content": "Why it is a Hard Problem, if Brute Force is passing successfully?\\n\\n```\\ndef lastSubstring(self, s):\\n        result=\"\"\\n        for i in range(len(s)):\\n            result=max(result,s[i:])\\n        return result\\n```\\n\\nEdit : The testcases are now fixed.\\n",
                "solutionTags": [],
                "code": "```\\ndef lastSubstring(self, s):\\n        result=\"\"\\n        for i in range(len(s)):\\n            result=max(result,s[i:])\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 361810,
                "title": "share-a-java-o-n-solution-with-comment",
                "content": "I think this is o(n) solution\\n\\nEdit : why it is O(n) and why we can move for i = i + k + 1\\n\\nbbb\\u2026bbbbbba for this case, if we just update i to i + 1,time complexity will downgrade to o(n^2).\\nLet me try to prove why it safely move from i to i + k + 1. For example, for \"cabcabx\" the matching pattern is \\'cab\\', at \\'x\\' two candidates are mismatching. since \\'x\\' > \\'c\\', wen need move i, that\\'s true we can just move to i + 1. However, as long as \\'cab\\' is matching pattern. both \\'a\\' and \\'b\\' have been visited by j. so we can safely move to i + k + 1. In other words, now j becomes i, i becomes to j. why do you want to go back a visited index? the idea is a little similar with KMP. \\n\\n```\\n    public String lastSubstring(String s) {\\n        int n = s.length();\\n        //k is the len when we have two candidates\\n        //i is the first candidate start position, j is the second one (can not be candidate)\\n        int i = 0, j= 1, k = 0;\\n        while (i < n && j < n && k < n) {\\n            if (i + k >= n || j + k >= n) {\\n                break;\\n            }\\n            // they have same start point, then increase the length\\n            if (s.charAt(i + k) == s.charAt(j + k)) {\\n                k++;\\n            } else {\\n                // now two candidates are different, then which one is larger\\n                if (s.charAt(i + k) < s.charAt(j + k)) {\\n                    i = i + k + 1; // j becomes the candidate, i need move forward\\n                } else {\\n                     j = j + k + 1; // i becomes the candidate\\n                }\\n                if (i == j) { \\n                    j++; // potational i, j stay at the same position, j move forward(i also can move)\\n                }\\n                k = 0; //reset the len\\n            }\\n        }\\n        int l = Math.min(i, j);\\n        return s.substring(l);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String lastSubstring(String s) {\\n        int n = s.length();\\n        //k is the len when we have two candidates\\n        //i is the first candidate start position, j is the second one (can not be candidate)\\n        int i = 0, j= 1, k = 0;\\n        while (i < n && j < n && k < n) {\\n            if (i + k >= n || j + k >= n) {\\n                break;\\n            }\\n            // they have same start point, then increase the length\\n            if (s.charAt(i + k) == s.charAt(j + k)) {\\n                k++;\\n            } else {\\n                // now two candidates are different, then which one is larger\\n                if (s.charAt(i + k) < s.charAt(j + k)) {\\n                    i = i + k + 1; // j becomes the candidate, i need move forward\\n                } else {\\n                     j = j + k + 1; // i becomes the candidate\\n                }\\n                if (i == j) { \\n                    j++; // potational i, j stay at the same position, j move forward(i also can move)\\n                }\\n                k = 0; //reset the len\\n            }\\n        }\\n        int l = Math.min(i, j);\\n        return s.substring(l);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 360957,
                "title": "c-brute-force",
                "content": "# Intuition\\nThe longer substring will be lexographically larger, all things equal. So, we just need to analyze n suffixes.\\n\\nThe ultimate solution for this problem is to build a sufix array and the answer would be the last element of that array. That way, we can reach O(n log n) (or even O(n)) complexity.\\n\\nI gambled - for the contest a suffix array would be too hard to implement, unless they want us to copy/paste some implementation from the internet.\\n\\nSo, I decided to go with O(n * n) solution and make it efficient - no copying strings, plus a special equality check when we have a repeated pattern. \\n```\\nstring lastSubstring(string s, int i = 0, int sz = 0) {\\n  for (auto j = 1; j < s.size(); ++j) {\\n    for (sz = 0; j + sz < s.size(); ++sz) {\\n      if (s[i + sz] == s[j + sz]) continue;\\n      i = s[j + sz] > s[i + sz] ? j : i;\\n      break;\\n    }\\n    if (j + sz == s.size()) break;\\n  }\\n  return s.substr(i);\\n}\\n```\\n# Complexity Analysis\\nRuntime: O(n * n)\\nMemory: O(1), if we do not consider memory required for the result.",
                "solutionTags": [],
                "code": "```\\nstring lastSubstring(string s, int i = 0, int sz = 0) {\\n  for (auto j = 1; j < s.size(); ++j) {\\n    for (sz = 0; j + sz < s.size(); ++sz) {\\n      if (s[i + sz] == s[j + sz]) continue;\\n      i = s[j + sz] > s[i + sz] ? j : i;\\n      break;\\n    }\\n    if (j + sz == s.size()) break;\\n  }\\n  return s.substr(i);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 362097,
                "title": "simple-c-code-o-n-time-and-o-1-space",
                "content": "I scanned other posts and I fount most of them either brute-force or complicated. So I post my solution here for your reference. Correct me if I made a mistake.\\n\\nIn my solution, I use an index `max_idx` to record the lexicographically maximal substring  `max_str`. I iterate the string with index `i`. The substring start from `i` is denoted as `cur_str`. Obviously, if `s[i] > s[max_idx]`, then `cur_str` would be larger than `max_str`, so we update the `max_str`. The tricky part is that when `s[i] == s[max_idx]`, we need to iterate the `max_str` and `cur_str` to compare them. We backup `i` as `ori_i` and use `i` and `j` to iterate `cur_str` and `max_str`. When `i == n` or `s[i] != s[j]` or `j` reach the start point of `cur_str` (in this case `max_str` should be larger than `cur_str`), the tie is broken. We then update `max_str` accordingly. When we need to update `max_str`, the candidates for maximal string should be among follows:\\n1. The substring start from `ori_i`. This is a typical case.\\n2. The substring start from `i`, which is actually the index that breaks the tie. Maybe `s[i]` is larger than `s[ori_i]`.\\n3. The substring start from `look_back_i`, where `s[look_back_i] == s[max_idx]`, and `look_back_i` is the largest index that satisfies the condition. \\n\\nEvery index other than these three indexes can be safely skipped as the substring started from them cannot be larger than these three cases.\\nFor comparing cases between 1, 2, and 3, we just set `max_idx` as `ori_i`, and set `i` back to `look_back_i` to compare them in the following iterations.\\n\\nAs the `i` visit each index at most twice, the time complexity is obviously O(n).\\n\\n```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int max_idx = 0;  // start index of the max_str\\n        int i = 1, n = s.size();\\n        while (i < n) {\\n            // If current character is larger than the first character of\\n            // max_str, then we update the max_str\\n            if (s[i] > s[max_idx]) {\\n                max_idx = i;\\n            }\\n            // If tied, we need to cur_str and max_str\\n            else if (s[i] == s[max_idx]) {\\n                // We compare them by two pointers i and j\\n                // i points to one character of cur_str, and j points to max_str\\n                int j = max_idx, ori_i = i;\\n                // If s[i] != s[j] or j == ori_i, then tie is broken\\n                // Otherwise we keep compare the next character\\n                int look_back_i = i;\\n\\t\\t\\t\\twhile (i < n && s[i] == s[j] && j < ori_i) {\\n\\t\\t\\t\\t    if (s[i] == s[max_idx]) look_back_i = i;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// If the max_str is larger than cur_str, then we don\\'t update max_str\\n\\t\\t\\t\\tif ((j == ori_i) || (i == n) || (s[j] > s[i])) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// update max_str\\n\\t\\t\\t\\tmax_idx = ori_i;\\n\\t\\t\\t\\tif (look_back_i != ori_i)\\n\\t\\t\\t\\t\\ti = look_back_i;\\n\\t\\t\\t\\tcontinue;\\n            }\\n            // These is no tie. So we just step i\\n            i++;\\n        } \\n        return s.substr(max_idx);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int max_idx = 0;  // start index of the max_str\\n        int i = 1, n = s.size();\\n        while (i < n) {\\n            // If current character is larger than the first character of\\n            // max_str, then we update the max_str\\n            if (s[i] > s[max_idx]) {\\n                max_idx = i;\\n            }\\n            // If tied, we need to cur_str and max_str\\n            else if (s[i] == s[max_idx]) {\\n                // We compare them by two pointers i and j\\n                // i points to one character of cur_str, and j points to max_str\\n                int j = max_idx, ori_i = i;\\n                // If s[i] != s[j] or j == ori_i, then tie is broken\\n                // Otherwise we keep compare the next character\\n                int look_back_i = i;\\n\\t\\t\\t\\twhile (i < n && s[i] == s[j] && j < ori_i) {\\n\\t\\t\\t\\t    if (s[i] == s[max_idx]) look_back_i = i;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// If the max_str is larger than cur_str, then we don\\'t update max_str\\n\\t\\t\\t\\tif ((j == ori_i) || (i == n) || (s[j] > s[i])) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// update max_str\\n\\t\\t\\t\\tmax_idx = ori_i;\\n\\t\\t\\t\\tif (look_back_i != ori_i)\\n\\t\\t\\t\\t\\ti = look_back_i;\\n\\t\\t\\t\\tcontinue;\\n            }\\n            // These is no tie. So we just step i\\n            i++;\\n        } \\n        return s.substr(max_idx);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 369191,
                "title": "javascript-with-explanation-no-substring-comparison-fast-o-n-time-o-1-space-credit-to-nate17",
                "content": "Credit goes to this wonderful Python solution [post](https://leetcode.com/problems/last-substring-in-lexicographical-order/discuss/363662/Short-python-code-O(n)-time-and-O(1)-space-with-proof-and-visualization) written by [nate17](https://leetcode.com/nate17).\\n\\n## Code\\n\\n```javascript\\nconst lastSubstring = (s) => {\\n  let i = 0 // index of final substring.\\n  let j = 1 // index of lookahead possible substring.\\n  let k = 0 // moving offset to compare i & j.\\n\\n  while (j + k < s.length) {\\n    if (s[i + k] < s[j + k]) {\\n      i = Math.max(i + k + 1, j)\\n      j = i + 1\\n      k = 0\\n    }\\n\\n    if (s[i + k] === s[j + k]) {\\n      k += 1\\n    }\\n\\n    if (s[i + k] > s[j + k]) {\\n      j = j + k + 1\\n      k = 0\\n    }\\n  }\\n\\n  return s.substring(i)\\n}\\n\\nmodule.exports = lastSubstring\\n```\\n\\n## Explanation\\n\\nConsider the following cases:\\n\\n```text\\nInput: zyxbzyxa\\nExpected output: zyxbzyxa\\n\\nInput: zyxbzyxc\\nExpected output: zyxc\\n```\\n\\nWe have two index pointers, `i` and `j`. `i` will always be set to the index of the final substring result. `j` is a moving lookahead index pointer that is used to loop through and compare the character at `j` with the character at `i`.\\n\\nWhen `s[i]` and `s[j]` are the same (the first z and the second z in the above example), we need to compare the characters next to them (the first y and the second y). Since they are the same, we need to compare the characters next to them (the first x and the second x), and so on. To achieve this, we use an offset `k` to compare the `k` character next to `i` and `j`. Note that `k` starts at 0, and this is essentially comparing characters `s[i+k]` and `s[j+k]`.\\n\\nWhen `s[i+k]` is bigger than `s[j+k]`, we just need to let `i` remain as is, continue move `j` forward to the next character at `j+k+1`, and reset `k` back to 0.\\n\\nWhen `s[i+k]` is smaller than `s[j+k]`, this means that the substring starting at `j` is a better result than the substring at `i`. At this point, there are two situations to consider: \\n\\n1. When `j` is more than `i+k`: Consider an input `hhhccchhhddd`, when `i` is 0, `j` is 6, and `k` is 3, both `i` and `j` are pointing to `h`, and you are comparing the first `c` and the first `d`. You would want to set `i = j`. \\n2. When `j` is less than `i+k`: Consider an input `nnnp`, when `i` is 0, `j` is 1, and `k` is 2, you are comparing the last `n` and `p`. You would want to change `i` to point to `p`, so you need to set `i = i+k+1`. Note that in this case, even though `j` is equal to `i+1`, `j` is *not always* equal to `i+1` (see situation 1 above), and hence you should not use `i = j+k`.\\n\\nSo with the above considerations, when `s[i+k]` is smaller than `s[j+k]`, we can simply set `i = Math.max(i + k + 1, j)`. \\n\\nIn the end, the result would be the substring starting at `i`.\\n\\n## Tests\\n\\nBelow are some tests using jest:\\n\\n```javascript\\ntest(\\'nnnhnnninnndnnnj should return nnnj\\', () => {\\n  const s = \\'nnnhnnninnndnnnj\\'\\n\\n  const result = lastSubstring(s)\\n\\n  expect(result).toBe(\\'nnnj\\')\\n})\\n\\ntest(\\'nnnhnnnjnnndnnni should return nnnjnnndnnni\\', () => {\\n  const s = \\'nnnhnnnjnnndnnni\\'\\n\\n  const result = lastSubstring(s)\\n\\n  expect(result).toBe(\\'nnnjnnndnnni\\')\\n})\\n```\\n\\n## Complexity Analysis\\n\\nAssume `n` is the number of characters in string `s`.\\n\\nTime complexity: O(n) since we visit each character exactly once.\\n\\nSpace complexity: O(1). Extra space used is always constant regardless of `n`.\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst lastSubstring = (s) => {\\n  let i = 0 // index of final substring.\\n  let j = 1 // index of lookahead possible substring.\\n  let k = 0 // moving offset to compare i & j.\\n\\n  while (j + k < s.length) {\\n    if (s[i + k] < s[j + k]) {\\n      i = Math.max(i + k + 1, j)\\n      j = i + 1\\n      k = 0\\n    }\\n\\n    if (s[i + k] === s[j + k]) {\\n      k += 1\\n    }\\n\\n    if (s[i + k] > s[j + k]) {\\n      j = j + k + 1\\n      k = 0\\n    }\\n  }\\n\\n  return s.substring(i)\\n}\\n\\nmodule.exports = lastSubstring\\n```\n```text\\nInput: zyxbzyxa\\nExpected output: zyxbzyxa\\n\\nInput: zyxbzyxc\\nExpected output: zyxc\\n```\n```javascript\\ntest(\\'nnnhnnninnndnnnj should return nnnj\\', () => {\\n  const s = \\'nnnhnnninnndnnnj\\'\\n\\n  const result = lastSubstring(s)\\n\\n  expect(result).toBe(\\'nnnj\\')\\n})\\n\\ntest(\\'nnnhnnnjnnndnnni should return nnnjnnndnnni\\', () => {\\n  const s = \\'nnnhnnnjnnndnnni\\'\\n\\n  const result = lastSubstring(s)\\n\\n  expect(result).toBe(\\'nnnjnnndnnni\\')\\n})\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1274574,
                "title": "easy-and-short-c-faster-than-99-o-n-one-pass",
                "content": "---- Doesn\\'t work now with updated test case --------\\n\\nThe problem is only when you have two same max characters.\\nIf the max characters match,  just loop through until the trailing characters aren\\'t same.\\nif on doing so, you encounter the starting index of current (or simply \\'i\\'), you exit the inner loop and the maxIndex doesn\\'t change.\\nIf higher trailing character is found, just update the starting index to i.\\nThe trick to O(n) is to never decrease the i and update the i to the unexplored next character.\\nSort of maintaining two pointers.\\n\\n```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        char max = s[0];\\n        int length = s.size(), maxIndex = 0;\\n        for(int i = 1 ; i < length; ++i){\\n            if ( s[i] > max ){\\n                maxIndex = i;\\n                max = s[i];\\n            }\\n            else if (s[i] == max){\\n                int j = 1;\\n                while (s[i + j] == s[maxIndex + j] && maxIndex + j < i ) j++;\\n                if (s[i + j] > s[maxIndex + j]) maxIndex = i;\\n                i = i + j-1;\\n            }\\n        }\\n        return s.substr(maxIndex,length - maxIndex + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        char max = s[0];\\n        int length = s.size(), maxIndex = 0;\\n        for(int i = 1 ; i < length; ++i){\\n            if ( s[i] > max ){\\n                maxIndex = i;\\n                max = s[i];\\n            }\\n            else if (s[i] == max){\\n                int j = 1;\\n                while (s[i + j] == s[maxIndex + j] && maxIndex + j < i ) j++;\\n                if (s[i + j] > s[maxIndex + j]) maxIndex = i;\\n                i = i + j-1;\\n            }\\n        }\\n        return s.substr(maxIndex,length - maxIndex + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961583,
                "title": "two-pointer-offset-explanation-visual-python",
                "content": "The goal is to find the last substring if all substrings were sorted in lexographical order.\\n\\n**Lexographical Order**\\n1.  ```a < b``` because ```a``` comes before ```b```  in alphabet \\n2.  if two substrings```s1``` and ```s2```  have the same character in the same position, the next characters in the substrings used for comparison \\n3.  if ```s1``` is shorter than ```s2``` and all the characters in ```s1``` are in ```s2``` , then ```s2``` comes first  ```s1 = aab, s2 = aaba```  then lexo order is ```s1, s2 ```\\n\\n\\n***Key Observations***\\n1. The last substring in lexographical order will be a ***suffix*** of the original string. This is because of the rules of lexographical ordering. \\n2.  The last occurence of the largest character (```z``` being largest possible character),is the starting point of the desired substring (last substring in lexographical order) . \\n3. To get the resultant substring, take all characters from the starting point (inclusive) to the end of the orignal string. This is possible because the substring will always be a suffix as stated in point 1\\n\\n\\nTo find the last occurrence of the largest character (the starting point of the desired suffix) , a two pointer approach with an offset can be used \\n\\nbelow is a visual walkthrough of the approach (view along with code at bottom for better understanding)\\n\\n![image](https://assets.leetcode.com/users/images/01cf6157-7b46-4e36-8abc-c2612cfca211_1607232522.4136333.png)\\n\\n\\n\\n```python\\n def lastSubstring(self, s: str) -> str:\\n        # k is an offset\\n        i, j, k = 0, 1, 0\\n        while i + k < len(s) and j + k < len(s):\\n            # when same largest char occurs think cacacb\\n            if s[i + k] == s[j + k]:\\n                k += 1\\n            else:\\n                # ensure correct order \\n                if s[i + k] < s[j + k]: \\n                    i += k + 1\\n                else:\\n                    j += k + 1\\n                \\n                if i == j: j += 1\\n                k = 0\\n        return s[i:]\\n```\\n\\n[Code Courtesy of rock](https://leetcode.com/problems/last-substring-in-lexicographical-order/discuss/362387/JavaPython-3-Two-short-O(n)-codes-language%3A-2-pointers-and-encoding)",
                "solutionTags": [],
                "code": "```a < b```\n```a```\n```b```\n```s1```\n```s2```\n```s1```\n```s2```\n```s1```\n```s2```\n```s2```\n```s1 = aab, s2 = aaba```\n```s1, s2 ```\n```z```\n```python\\n def lastSubstring(self, s: str) -> str:\\n        # k is an offset\\n        i, j, k = 0, 1, 0\\n        while i + k < len(s) and j + k < len(s):\\n            # when same largest char occurs think cacacb\\n            if s[i + k] == s[j + k]:\\n                k += 1\\n            else:\\n                # ensure correct order \\n                if s[i + k] < s[j + k]: \\n                    i += k + 1\\n                else:\\n                    j += k + 1\\n                \\n                if i == j: j += 1\\n                k = 0\\n        return s[i:]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 694848,
                "title": "java-o-n-solution-with-comments",
                "content": "References : https://leetcode.com/problems/last-substring-in-lexicographical-order/discuss/582703/C%2B%2B-SIMPLE-EASY-SOLUTION-WITH-EXPLANATION-CHEERS!!!\\n\\n```\\n\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        \\n        int k = 0;\\n        int i = 0;\\n        int j = 1;\\n        int n = s.length();\\n        while(j+k < n)\\n        {\\n            // Continue till chars are same for two substrings\\n            if(s.charAt(i+k) == s.charAt(j+k)) k++;\\n            \\n            // substring indexed at i is smaller than substring at j , hence all substrings between i and j are smaller \\n            // we jump i to j and increment j by 1\\n            else if (s.charAt(i+k) < s.charAt(j+k))\\n            {\\n                i = j;\\n                j++;\\n                k = 0;\\n            }\\n            \\n            // substring indexed at i is greater than substring at j ,\\n            // we jump j to j+k+1 to check if any further substring is greater than substring at i\\n            else if( s.charAt(i+k) > s.charAt(j+k))\\n            {\\n                \\n                j = j+k+1;\\n                k = 0;\\n            }\\n        }\\n             \\n        // finally we return the substring from index i which points to largest character in the string S\\n        return s.substring(i);            \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        \\n        int k = 0;\\n        int i = 0;\\n        int j = 1;\\n        int n = s.length();\\n        while(j+k < n)\\n        {\\n            // Continue till chars are same for two substrings\\n            if(s.charAt(i+k) == s.charAt(j+k)) k++;\\n            \\n            // substring indexed at i is smaller than substring at j , hence all substrings between i and j are smaller \\n            // we jump i to j and increment j by 1\\n            else if (s.charAt(i+k) < s.charAt(j+k))\\n            {\\n                i = j;\\n                j++;\\n                k = 0;\\n            }\\n            \\n            // substring indexed at i is greater than substring at j ,\\n            // we jump j to j+k+1 to check if any further substring is greater than substring at i\\n            else if( s.charAt(i+k) > s.charAt(j+k))\\n            {\\n                \\n                j = j+k+1;\\n                k = 0;\\n            }\\n        }\\n             \\n        // finally we return the substring from index i which points to largest character in the string S\\n        return s.substring(i);            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361944,
                "title": "c-string-view-8-lines-with-reference-link",
                "content": "[What is string view and why use it over original string in STL](https://stackoverflow.com/questions/20803826/what-is-string-view)\\n[CSDN Chinese version ](https://blog.csdn.net/hepangda/article/details/80821567)\\n\\n```\\nFrom -> https://stackoverflow.com/questions/40127965/how-exactly-is-stdstring-view-faster-than-const-stdstring\\nThe second really big reason is that it permits working with substrings without a copy. \\nSuppose you are parsing a 2 gigabyte json string (!)\\xB2. \\nIf you parse it into std::string,\\neach such parse node where they store the name or value of a node copies the original data from the 2 gb string to a local node.\\n\\nInstead, if you parse it to std::string_views, \\nthe nodes refer to the original data. \\nThis can save millions of allocations and halve memory requirements during parsing.\\n```\\n```cpp\\nclass Solution \\n{\\npublic:\\n    string lastSubstring(string_view s) \\n    {\\n        string_view res;\\n        int sz = s.size();\\n        for(int i = 0; i < sz; i++)\\n        {\\n            if(s.substr(i) > res)\\n            {\\n                res = s.substr(i);\\n            }\\n        }\\n        return string(res);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nFrom -> https://stackoverflow.com/questions/40127965/how-exactly-is-stdstring-view-faster-than-const-stdstring\\nThe second really big reason is that it permits working with substrings without a copy. \\nSuppose you are parsing a 2 gigabyte json string (!)\\xB2. \\nIf you parse it into std::string,\\neach such parse node where they store the name or value of a node copies the original data from the 2 gb string to a local node.\\n\\nInstead, if you parse it to std::string_views, \\nthe nodes refer to the original data. \\nThis can save millions of allocations and halve memory requirements during parsing.\\n```\n```cpp\\nclass Solution \\n{\\npublic:\\n    string lastSubstring(string_view s) \\n    {\\n        string_view res;\\n        int sz = s.size();\\n        for(int i = 0; i < sz; i++)\\n        {\\n            if(s.substr(i) > res)\\n            {\\n                res = s.substr(i);\\n            }\\n        }\\n        return string(res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1964848,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public String lastSubstring(String s) {\\n    int maxIndex = s.length() - 1;\\n    \\n    for(int currIndex = s.length() - 1 ; currIndex >= 0 ; currIndex--){\\n        if(s.charAt(currIndex) > s.charAt(maxIndex))\\n            maxIndex = currIndex;\\n            \\n        else if(s.charAt(currIndex) == s.charAt(maxIndex)){\\n            int i = currIndex + 1;\\n            int j = maxIndex + 1;\\n            \\n            \\n            while(i < maxIndex && j < s.length() && s.charAt(i) == s.charAt(j)){\\n                i++;\\n                j++;\\n            }\\n            \\n            if(i == maxIndex || j == s.length() || s.charAt(i) > s.charAt(j))\\n                maxIndex = currIndex;\\n        }\\n    }\\n    \\n    return s.substring(maxIndex);\\n\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public String lastSubstring(String s) {\\n    int maxIndex = s.length() - 1;\\n    \\n    for(int currIndex = s.length() - 1 ; currIndex >= 0 ; currIndex--){\\n        if(s.charAt(currIndex) > s.charAt(maxIndex))\\n            maxIndex = currIndex;\\n            \\n        else if(s.charAt(currIndex) == s.charAt(maxIndex)){\\n            int i = currIndex + 1;\\n            int j = maxIndex + 1;\\n            \\n            \\n            while(i < maxIndex && j < s.length() && s.charAt(i) == s.charAt(j)){\\n                i++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 361022,
                "title": "java-brute-force",
                "content": "```\\n    public String lastSubstring(String str) {\\n        String mx = \"\"; \\n        char cur = \\'a\\';\\n        for (int i = 0; i < str.length(); i++) { \\n            if (str.charAt(i) >= cur && mx.compareTo(str.substring(i)) <= 0) { // the first letter of substring matters,  \\n                cur = str.charAt(i);\\n                mx = str.substring(i);  // for example, \"tabc\" is lexicographically larger than \"tab\"\\n            } \\n            while(i != str.length() -1 && str.charAt(i) == str.charAt(i+1)) i++;  // get rid of continuous repeating letters\\n        } \\n        return mx;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String lastSubstring(String str) {\\n        String mx = \"\"; \\n        char cur = \\'a\\';\\n        for (int i = 0; i < str.length(); i++) { \\n            if (str.charAt(i) >= cur && mx.compareTo(str.substring(i)) <= 0) { // the first letter of substring matters,  \\n                cur = str.charAt(i);\\n                mx = str.substring(i);  // for example, \"tabc\" is lexicographically larger than \"tab\"\\n            } \\n            while(i != str.length() -1 && str.charAt(i) == str.charAt(i+1)) i++;  // get rid of continuous repeating letters\\n        } \\n        return mx;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 361114,
                "title": "java-bfs-solution-75ms",
                "content": "First store indexes of the highest character.\\nThen find second highest character. \\nIterate through the list until list has 1 element.\\n\\nWe prune index1 at each iteration if there is another index2 = index1 + shift.  This is used to handle strings like \\'aaaaa.....aaa\\' or \\'abababababab\\'.  Its each to see that index1 will never be an answer.\\n\\n```\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        char highest = \\'@\\';\\n        Set<Integer> indexes = null;\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) > highest) {\\n                highest = s.charAt(i);\\n                indexes = new HashSet<>();\\n            }\\n            \\n            if(s.charAt(i) == highest) {\\n                indexes.add(i);\\n            }\\n        }\\n        \\n        int shift = 1;\\n        \\n        while(indexes.size() > 1) {\\n            char shiftHighest = \\'@\\';\\n            Set<Integer> nextLevel = null;\\n            Set<Integer> toDelete = new HashSet<>();\\n\\n            for(int ind : indexes) {\\n                int newIndex = ind + shift;\\n                if(newIndex < s.length()){\\n                    if(s.charAt(newIndex) > shiftHighest) {\\n                        shiftHighest = s.charAt(newIndex);\\n                        nextLevel = new HashSet<>();\\n                    }\\n                    \\n                    if(s.charAt(newIndex) == shiftHighest) {\\n                        nextLevel.add(ind);\\n                    }\\n                    \\n                    if(indexes.contains(newIndex)) {\\n                        toDelete.add(newIndex);\\n                    }\\n                }\\n            }\\n\\n            for(int del : toDelete) {\\n                nextLevel.remove(del);\\n            }\\n            \\n            indexes = nextLevel;\\n            shift++;\\n        }\\n        \\n        return s.substring(indexes.iterator().next());\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        char highest = \\'@\\';\\n        Set<Integer> indexes = null;\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) > highest) {\\n                highest = s.charAt(i);\\n                indexes = new HashSet<>();\\n            }\\n            \\n            if(s.charAt(i) == highest) {\\n                indexes.add(i);\\n            }\\n        }\\n        \\n        int shift = 1;\\n        \\n        while(indexes.size() > 1) {\\n            char shiftHighest = \\'@\\';\\n            Set<Integer> nextLevel = null;\\n            Set<Integer> toDelete = new HashSet<>();\\n\\n            for(int ind : indexes) {\\n                int newIndex = ind + shift;\\n                if(newIndex < s.length()){\\n                    if(s.charAt(newIndex) > shiftHighest) {\\n                        shiftHighest = s.charAt(newIndex);\\n                        nextLevel = new HashSet<>();\\n                    }\\n                    \\n                    if(s.charAt(newIndex) == shiftHighest) {\\n                        nextLevel.add(ind);\\n                    }\\n                    \\n                    if(indexes.contains(newIndex)) {\\n                        toDelete.add(newIndex);\\n                    }\\n                }\\n            }\\n\\n            for(int del : toDelete) {\\n                nextLevel.remove(del);\\n            }\\n            \\n            indexes = nextLevel;\\n            shift++;\\n        }\\n        \\n        return s.substring(indexes.iterator().next());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537672,
                "title": "if-you-know-lyndon-word-and-duval-algorithm",
                "content": "Actually this problem is another version of Lyndon factorization. For the definition of Lyndon word, please refer to [Lyndon word](https://en.wikipedia.org/wiki/Lyndon_word). And there is an efficient Landon factorization algorithm called [Duval algorithm](https://cp-algorithms.com/string/lyndon_factorization.html). If you know the two basic problems solved by Duval algorithm: (1) Lyndon factorization (2) Finding the smallest cyclic shift, you will realize that this problem can be solved in a similar way.\\n\\nHere is a c++ version of the solution, and you can see how much it looks like the standard [Duval algorithm](https://cp-algorithms.com/string/lyndon_factorization.html):\\n\\n```\\nstring lastSubstring(string& s)\\n{\\n    int n = (int)s.size(), ans = 0, i = 0;\\n    while(i < n)\\n    {\\n        ans = i;\\n        int k = i, j = i + 1;\\n        while(j < n && s[k] >= s[j])\\n        {\\n            if(s[k] > s[j]) k = i;\\n            else k++;\\n            j++;\\n        }\\n        if(j == n) k = i;\\n        while(i <= k) i += j - k;\\n    }\\n    return s.substr(ans);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring lastSubstring(string& s)\\n{\\n    int n = (int)s.size(), ans = 0, i = 0;\\n    while(i < n)\\n    {\\n        ans = i;\\n        int k = i, j = i + 1;\\n        while(j < n && s[k] >= s[j])\\n        {\\n            if(s[k] > s[j]) k = i;\\n            else k++;\\n            j++;\\n        }\\n        if(j == n) k = i;\\n        while(i <= k) i += j - k;\\n    }\\n    return s.substr(ans);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 516486,
                "title": "java-2-pointer",
                "content": "```\\n    public String lastSubstring(String s) {\\n        int l = s.length();\\n        int i = 0, j = 1, k = 0;\\n        while(j + k < l) {\\n            if (s.charAt(i+k) == s.charAt(j+k)){\\n                k++;\\n                continue;\\n            }\\n            if (s.charAt(i+k) > s.charAt(j+k)){\\n                j++;\\n            } else {\\n                i = j;\\n                j = i + 1;\\n            }\\n            k = 0;\\n        }\\n        \\n        return s.substring(i);\\n    }\\n```\\nThanks to @Nate17:\\nhttps://leetcode.com/problems/last-substring-in-lexicographical-order/discuss/363662/Short-python-code-O(n)-time-and-O(1)-space-with-proof-and-visualization\\n",
                "solutionTags": [],
                "code": "```\\n    public String lastSubstring(String s) {\\n        int l = s.length();\\n        int i = 0, j = 1, k = 0;\\n        while(j + k < l) {\\n            if (s.charAt(i+k) == s.charAt(j+k)){\\n                k++;\\n                continue;\\n            }\\n            if (s.charAt(i+k) > s.charAt(j+k)){\\n                j++;\\n            } else {\\n                i = j;\\n                j = i + 1;\\n            }\\n            k = 0;\\n        }\\n        \\n        return s.substring(i);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 360986,
                "title": "java-short-solution",
                "content": "```\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        int largestCharacter = s.charAt(0);\\n        boolean allCharsSame = true;\\n        for(char c : s.toCharArray()){\\n            if(c != largestCharacter)\\n                allCharsSame = false;\\n            largestCharacter = Math.max(largestCharacter, c);\\n        }\\n        if(allCharsSame)\\n            return s;\\n        String result = \"\";\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == largestCharacter && s.substring(i).compareTo(result) > 0)\\n                result = s.substring(i);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        int largestCharacter = s.charAt(0);\\n        boolean allCharsSame = true;\\n        for(char c : s.toCharArray()){\\n            if(c != largestCharacter)\\n                allCharsSame = false;\\n            largestCharacter = Math.max(largestCharacter, c);\\n        }\\n        if(allCharsSame)\\n            return s;\\n        String result = \"\";\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == largestCharacter && s.substring(i).compareTo(result) > 0)\\n                result = s.substring(i);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885746,
                "title": "java-simple-two-pointer-approach",
                "content": "```\\nclass Solution {\\n    /*\\n    `   Two pointer approach  \\n    */\\n    public String lastSubstring(String s) {\\n        \\n        int start=0, end = start+1;\\n        int len =0;\\n        \\n        while(end+len < s.length()) {\\n            \\n            if(s.charAt(start+len) == s.charAt(end+len)) {\\n                len++;\\n            }else if(s.charAt(start+len) > s.charAt(end+len)) {\\n                end+=len+1;\\n                len=0;\\n            }else {\\n                start =end;\\n                end = start+1;\\n                len =0;\\n            }\\n        }\\n        return s.substring(start);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /*\\n    `   Two pointer approach  \\n    */\\n    public String lastSubstring(String s) {\\n        \\n        int start=0, end = start+1;\\n        int len =0;\\n        \\n        while(end+len < s.length()) {\\n            \\n            if(s.charAt(start+len) == s.charAt(end+len)) {\\n                len++;\\n            }else if(s.charAt(start+len) > s.charAt(end+len)) {\\n                end+=len+1;\\n                len=0;\\n            }else {\\n                start =end;\\n                end = start+1;\\n                len =0;\\n            }\\n        }\\n        return s.substring(start);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432577,
                "title": "python3-o-n",
                "content": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        i,j,k=0,1,0\\n        n=len(s)\\n        while j+k<n:\\n            \\n            if s[i+k]==s[j+k]:\\n                k+=1\\n                continue\\n            elif s[i+k]>s[j+k]:\\n                j=j+k+1\\n            else:\\n                i=max(j,i+k+1)\\n                j=i+1\\n            k=0\\n        return s[i:]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        i,j,k=0,1,0\\n        n=len(s)\\n        while j+k<n:\\n            \\n            if s[i+k]==s[j+k]:\\n                k+=1\\n                continue\\n            elif s[i+k]>s[j+k]:\\n                j=j+k+1\\n            else:\\n                i=max(j,i+k+1)\\n                j=i+1\\n            k=0\\n        return s[i:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361991,
                "title": "o-n-solution-with-detailed-explanation",
                "content": "It\\'s obvious that the answer should be a substring starting at a position within [0, s.size() - 1] and ends at s.size() - 1,\\nthere are s.size() possible candidates, we eliminate them one by one.\\n\\nLet\\'s suppose the maximum character in the string is \\'z\\', it\\'s obvious that any substring not starting with \\'z\\' \\ncan be eliminated int the first round. let vector v be the positions of substrings starting with \\'z\\' and with a length of 1.\\nFor example, v = {1,2,3,7,8,11,12,13,35}, we find the longest consecutive subArr of v.\\nthey\\'re {1,2,3},{11,12,13}, so we can eliminated substrings not starting with positions 1 and 11,\\nwhy? in the above example, we know starting with position 1, we have 3 consecutive \\'z\\' and for any other positions,\\nwhen we compare substring starting at positions other than 1 or 11, it\\'s certain they\\'re lexicographical smaller\\nbecause they don\\'t have so many \\'z\\'s following them.\\n\\nwe do this step repeatedly,\\nin a new round, suppose we have n candidates left with starting positions = {v1,v2,v3...,vn},\\nand all of them share a prefix of length len, and they\\'re the lexicographical maximum substring of length len.\\nthen we follow a similar procedure:\\nwe combine the consecutive ranges:\\nfor example:\\n\\nv1 = v2 - len ,v2 = v3 - len ,v3 < v4 - len,\\nv9 = v10 - len ,v10 = v11 - len ,v11 = v12 - len, v12 < v13 - len\\n\\nand the longest consecutive range = [v9, v9 + len * 3 - 1]\\nthen we only need to keep the candidate starting with v9, the rest can be removed.\\nwhy:\\nwhen we compare substring starting at positions v1 and v9, v1\\'s range of [l3 ,v3 + len] should be smaller than the range [v11,v12-1]\\nbecause [v11,v12-1] is the lexicographical maximum substring of length len, whereas [l3 ,v3 + len - 1] is not.\\n\\nfor other substrings not starting at position v9, the compare leads to the same result.\\n\\nthe combine and elimination strategy greatly avoids any single position being checked multiple times.\\n\\nwhy it\\'s o(n)?\\nyou may argue we get to scan the candidates multiples to eliminate them, it\\'s time consuming.\\nbut if you analyze it carefully, you can find each character is only appended once if the initial round is not considered.\\nin each round, x characters are appended, we only need to scan x candidates,\\nso the number of times we scan is o(n), it\\'s much less time consuming than it seems.\\n\\n```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        vector<int> q[2];\\n        int step = 0;\\n        for(int i = 0;i < s.size();i++)\\n            q[0].push_back(i);\\n        while(q[0].size() != 1){\\n            step++;\\n            q[1].clear();\\n            for(int i = 0;i < q[0].size();i++){\\n                if(q[0][i] + step - 1 < s.size()) {\\n                    char max_char = q[1].size() > 0 ? s[q[1].back() + step - 1]:\\'0\\';\\n                    if(s[q[0][i] + step - 1] > max_char){\\n                        q[1] = {q[0][i]};\\n                    } else if(s[q[0][i] + step - 1] == max_char)\\n                        q[1].push_back(q[0][i]);\\n                }\\n            }\\n            int left = 0,max_size = 0,step1 = 0;\\n            q[0].clear();\\n            while(left < q[1].size()){\\n                int right = left + 1;\\n                while(right < q[1].size() && q[1][right] - step == q[1][right-1]){\\n                    right++;\\n                }\\n                if(right - left > max_size){\\n                    max_size = right - left;\\n                    step1 = step * max_size;\\n                    q[0]= {q[1][left]};\\n                } else if (right - left == max_size){\\n                    q[0].push_back(q[1][left]);\\n                }\\n                left = right;\\n            }\\n            step = step1;\\n        }\\n        return s.substr(q[0][0]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        vector<int> q[2];\\n        int step = 0;\\n        for(int i = 0;i < s.size();i++)\\n            q[0].push_back(i);\\n        while(q[0].size() != 1){\\n            step++;\\n            q[1].clear();\\n            for(int i = 0;i < q[0].size();i++){\\n                if(q[0][i] + step - 1 < s.size()) {\\n                    char max_char = q[1].size() > 0 ? s[q[1].back() + step - 1]:\\'0\\';\\n                    if(s[q[0][i] + step - 1] > max_char){\\n                        q[1] = {q[0][i]};\\n                    } else if(s[q[0][i] + step - 1] == max_char)\\n                        q[1].push_back(q[0][i]);\\n                }\\n            }\\n            int left = 0,max_size = 0,step1 = 0;\\n            q[0].clear();\\n            while(left < q[1].size()){\\n                int right = left + 1;\\n                while(right < q[1].size() && q[1][right] - step == q[1][right-1]){\\n                    right++;\\n                }\\n                if(right - left > max_size){\\n                    max_size = right - left;\\n                    step1 = step * max_size;\\n                    q[0]= {q[1][left]};\\n                } else if (right - left == max_size){\\n                    q[0].push_back(q[1][left]);\\n                }\\n                left = right;\\n            }\\n            step = step1;\\n        }\\n        return s.substr(q[0][0]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073755,
                "title": "python-solution-beatas-99-with-explanantion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to find the lexicographically largest substring of a given string. My first thought is to start by comparing characters at different positions in the string and keep track of the substring with the highest lexicographic value.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the code above is to use two pointers, i and j, to compare substrings starting at different positions in the string. A third pointer, k, is used to keep track of the current substring being compared. The code then uses a while loop to iterate through the string and compare the characters at positions i + k and j + k. If they are equal, k is incremented. If the character at i + k is greater than the character at j + k, j is moved to j + k + 1 and k is reset to 0. If the character at i + k is less than the character at j + k, i is moved to the maximum of i + k + 1 and j, and j is moved to i + 1 and k is reset to 0. The final return statement returns the substring starting at position i.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        i = 0\\n        j = 1\\n        k = 0\\n        n = len(s)\\n        while j + k < n:\\n            if s[i + k] == s[j + k]:\\n                k += 1\\n            elif s[i + k] > s[j + k]:\\n                j += k + 1\\n                k = 0\\n            elif s[i + k] < s[j + k]:\\n                i = max(i + k + 1, j)\\n                j = i + 1\\n                k = 0\\n        return s[i:]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        i = 0\\n        j = 1\\n        k = 0\\n        n = len(s)\\n        while j + k < n:\\n            if s[i + k] == s[j + k]:\\n                k += 1\\n            elif s[i + k] > s[j + k]:\\n                j += k + 1\\n                k = 0\\n            elif s[i + k] < s[j + k]:\\n                i = max(i + k + 1, j)\\n                j = i + 1\\n                k = 0\\n        return s[i:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298427,
                "title": "c-easy-two-pointers",
                "content": "````\\nclass Solution\\n{\\n    public:\\n        string lastSubstring(string s)\\n        {\\n            int maxIndex = s.length() - 1;\\n\\n            for (int currIndex = s.length() - 1; currIndex >= 0; currIndex--)\\n            {\\n                if (s[currIndex] > s[maxIndex])\\n                    maxIndex = currIndex;\\n\\n                else if (s[currIndex] == s[maxIndex])\\n                {\\n                    int i = currIndex + 1;\\n                    int j = maxIndex + 1;\\n\\n                    while (i < maxIndex && j < s.length() && s[i] == s[j])\\n                    {\\n                        i++;\\n                        j++;\\n                    }\\n\\n                    if (i == maxIndex || j == s.length() || s[i] > s[j])\\n                        maxIndex = currIndex;\\n                }\\n            }\\n\\n            return s.substr(maxIndex);\\n        }\\n};\\n````",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "String"
                ],
                "code": "````\\nclass Solution\\n{\\n    public:\\n        string lastSubstring(string s)\\n        {\\n            int maxIndex = s.length() - 1;\\n\\n            for (int currIndex = s.length() - 1; currIndex >= 0; currIndex--)\\n            {\\n                if (s[currIndex] > s[maxIndex])\\n                    maxIndex = currIndex;\\n\\n                else if (s[currIndex] == s[maxIndex])\\n                {\\n                    int i = currIndex + 1;\\n                    int j = maxIndex + 1;\\n\\n                    while (i < maxIndex && j < s.length() && s[i] == s[j])\\n                    {\\n                        i++;\\n                        j++;\\n                    }\\n\\n                    if (i == maxIndex || j == s.length() || s[i] > s[j])\\n                        maxIndex = currIndex;\\n                }\\n            }\\n\\n            return s.substr(maxIndex);\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928324,
                "title": "simple-but-slow",
                "content": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        \\n        starts = [[] for _ in range(26)]\\n        \\n        for i, c in enumerate(s):\\n            starts[ord(c) - ord(\\'a\\')].append(i)\\n        \\n        for i in range(25, -1, -1):\\n            if starts[i]:\\n                break\\n        \\n        cands = starts[i]\\n        \\n        ans = \\'\\'\\n        for cand in cands:\\n            ans = max(ans, s[cand:])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        \\n        starts = [[] for _ in range(26)]\\n        \\n        for i, c in enumerate(s):\\n            starts[ord(c) - ord(\\'a\\')].append(i)\\n        \\n        for i in range(25, -1, -1):\\n            if starts[i]:\\n                break\\n        \\n        cands = starts[i]\\n        \\n        ans = \\'\\'\\n        for cand in cands:\\n            ans = max(ans, s[cand:])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 849712,
                "title": "python3-fast-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        if not s: return None\\n        ## get max char from s\\n        maxC, N = max(s),len(s)\\n        ## get max char indexs to append into inds\\n        ## only store the first ind for consecutive max chars\\n        inds = [i for i in range(N) if s[i]==maxC and (i==0 or s[i-1]!=maxC)]\\n        maxind = inds[0] # starting index of the max substring\\n       \\n        ## using for loop to compare with each substring lead by max char\\n        for i in range(1,len(inds)):\\n            curind = inds[i] # start index of current substring\\n            step = 0 # index pointer from start index\\n            ## compare the current sub with the max sub string\\n            while curind+step<N:\\n                if s[curind+step]>s[maxind+step]: # current sub larger than maxsub\\n                    maxind = curind\\n                    break\\n                elif s[curind+step]==s[maxind+step]:\\n                    step += 1\\n                else: # s[curind+step]<s[maxind+step]: # current sub smaller than maxsub\\n                    break\\n                \\n        return s[maxind:]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        if not s: return None\\n        ## get max char from s\\n        maxC, N = max(s),len(s)\\n        ## get max char indexs to append into inds\\n        ## only store the first ind for consecutive max chars\\n        inds = [i for i in range(N) if s[i]==maxC and (i==0 or s[i-1]!=maxC)]\\n        maxind = inds[0] # starting index of the max substring\\n       \\n        ## using for loop to compare with each substring lead by max char\\n        for i in range(1,len(inds)):\\n            curind = inds[i] # start index of current substring\\n            step = 0 # index pointer from start index\\n            ## compare the current sub with the max sub string\\n            while curind+step<N:\\n                if s[curind+step]>s[maxind+step]: # current sub larger than maxsub\\n                    maxind = curind\\n                    break\\n                elif s[curind+step]==s[maxind+step]:\\n                    step += 1\\n                else: # s[curind+step]<s[maxind+step]: # current sub smaller than maxsub\\n                    break\\n                \\n        return s[maxind:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538691,
                "title": "python-140-ms-beat-100",
                "content": "**Fast solution (140 ms)**\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        n = len(s)\\n        pool, c, repeat = [], max(set(s)), False    # c is the max char, pool contains the candidates\\n        for i,x in enumerate(s):\\n            if x == c:\\n                if not repeat:                      # only add non-repeat head (if there\\'s some smaller char in between) \\'zzzazz...\\', not add \\'zzzzzz...\\'\\n                    pool.append(i)\\n                    repeat = True\\n            else:\\n                repeat = False\\n        k = 1\\n        while len(pool) > 1:                        # if there are more than one substring start with the head\\n            new_pool, c = [], \\'\\'\\n            for i in pool:\\n                sc = s[i+k] if i+k < n else \\'\\'      # continue to compare the second, third, ..., k-th char\\n                if sc > c:\\n                    new_pool = [i]\\n                    c = sc\\n                elif sc == c:\\n                    new_pool.append(i)\\n            pool = new_pool\\n            k += 1                                  # compare the next char\\n        return s[pool[0]:]\\n```\\n\\n**Straightforward solution (2348 ms)**\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        c = max(set(s))\\n        res = \\'\\'\\n        for i,x in enumerate(s):\\n            if x == c:\\n                res = max(res, s[i:])\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        n = len(s)\\n        pool, c, repeat = [], max(set(s)), False    # c is the max char, pool contains the candidates\\n        for i,x in enumerate(s):\\n            if x == c:\\n                if not repeat:                      # only add non-repeat head (if there\\'s some smaller char in between) \\'zzzazz...\\', not add \\'zzzzzz...\\'\\n                    pool.append(i)\\n                    repeat = True\\n            else:\\n                repeat = False\\n        k = 1\\n        while len(pool) > 1:                        # if there are more than one substring start with the head\\n            new_pool, c = [], \\'\\'\\n            for i in pool:\\n                sc = s[i+k] if i+k < n else \\'\\'      # continue to compare the second, third, ..., k-th char\\n                if sc > c:\\n                    new_pool = [i]\\n                    c = sc\\n                elif sc == c:\\n                    new_pool.append(i)\\n            pool = new_pool\\n            k += 1                                  # compare the next char\\n        return s[pool[0]:]\\n```\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        c = max(set(s))\\n        res = \\'\\'\\n        for i,x in enumerate(s):\\n            if x == c:\\n                res = max(res, s[i:])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 454785,
                "title": "simple-and-concise-o-n-6-lines-c-solution",
                "content": "Note that the last substring must be one of the suffix of the string (s[i:] for any i will be our candidates)\\nWe use 2 pointers: i and j to check the 2 substrings, k is their string length currently\\ncase 1: s[i+k]==s[j+k]: the substring is the same, so we increase k (the length) to compare the next character\\ncase 2: s[i+k]<s[j+k]: the first string is definitely not the candidate, since the second string is larger, and we reset k\\ncase 3: s[i+k]>s[j+k]: the second string is not the candidate, so we start from the next character of the end of the string, and we reset k (we are sure that s[i] is larger than s[j]~s[j+k], otherwise i will just be updated with the previous process. So we change j to j+k+1 to compare the next candidates, and k can be reset.)\\n```\\nclass Solution \\n{\\n    public:\\n    string lastSubstring(string s) \\n    {\\n        int n=s.length(),i=0,j=1,k=0;\\n        while(j+k<n)\\n        {\\n            if(s[i+k]==s[j+k]) k++;\\n            else if(s[i+k]<s[j+k]) i=j++,k=0;\\n            else j+=k+1,k=0;\\n        }\\n        return s.substr(i);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    string lastSubstring(string s) \\n    {\\n        int n=s.length(),i=0,j=1,k=0;\\n        while(j+k<n)\\n        {\\n            if(s[i+k]==s[j+k]) k++;\\n            else if(s[i+k]<s[j+k]) i=j++,k=0;\\n            else j+=k+1,k=0;\\n        }\\n        return s.substr(i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361321,
                "title": "solution-in-python-3-beats-100",
                "content": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n    \\tS, L, a = [ord(i) for i in s] + [0], len(s), 1\\n    \\tM = max(S)\\n    \\tI = [i for i in range(L) if S[i] == M]\\n    \\tif len(I) == L: return s\\n    \\twhile len(I) != 1:\\n    \\t\\tb = [S[i + a] for i in I]\\n    \\t\\tM, a = max(b), a + 1\\n    \\t\\tI = [I[i] for i, j in enumerate(b) if j == M]\\n    \\treturn s[I[0]:]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n    \\tS, L, a = [ord(i) for i in s] + [0], len(s), 1\\n    \\tM = max(S)\\n    \\tI = [i for i in range(L) if S[i] == M]\\n    \\tif len(I) == L: return s\\n    \\twhile len(I) != 1:\\n    \\t\\tb = [S[i + a] for i in I]\\n    \\t\\tM, a = max(b), a + 1\\n    \\t\\tI = [I[i] for i, j in enumerate(b) if j == M]\\n    \\treturn s[I[0]:]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 1261692,
                "title": "python-o-n-no-suffix-array-easy-explanation",
                "content": "#### Since we are looking for the lexographically largest substring, we can greedily look for it and essentially split our work up into 3 different cases.\\n\\n##### Cases:\\n- The next character in the input string is lexographically greater than the first character in the current best string\\n\\t- In this case, we simply update the best string to be the character in the input string\\n- The next character in the input string is lexographically lesser than the first character in the current best string\\n\\t- In this case, we simply add the next character onto the currenct best string\\n- The third and most complex case is when the two are equal\\n\\t- In this case, we must look at both strings until there is an inequivalency or there is no more string to check\\n\\t- If there is no more string to check, we just add the next string onto the current best\\n\\t- Otherwise, we must check to see which substring won out\\n\\t\\t- If the current best character is larger we add the substring of s onto the end of the current best string\\n\\t\\t- Otherwise, we the current substring is determined to be lexographically greater and we reassign the current best string to it\\n\\t\\t\\n- We then update our index and continue until we reach the end. Once  we have reached the end, the current best string is the lexographically longest substring so we return it and are done.\\n```\\ndef lastSubstring(self, s: str) -> str:\\n        cur_best = s[0]\\n        i = 1\\n        while i < len(s):\\n            if ord(s[i]) > ord(cur_best[0]):\\n                cur_best = s[i]\\n            elif ord(s[i]) < ord(cur_best[0]):\\n                cur_best += s[i]\\n            else:\\n                p1 = 0\\n                j = i\\n                while p1 < len(cur_best) and j < len(s) and ord(cur_best[p1]) == ord(s[j]):\\n                    p1 += 1\\n                    j += 1\\n                if p1 == len(cur_best) or j == len(s):\\n                    cur_best += s[i:j]\\n                else:\\n                    if ord(s[j]) > ord(cur_best[p1]):\\n                        cur_best = s[i:j]\\n                    else:\\n                        cur_best += s[i:j]\\n                i = j - 1\\n            i += 1\\n        return cur_best\\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(n) i.e. \\'aaaaaaaaaaaz\\' : cur_best will store \\'aaaaaaaaaaa\\' before it stores \\'z\\'",
                "solutionTags": [],
                "code": "```\\ndef lastSubstring(self, s: str) -> str:\\n        cur_best = s[0]\\n        i = 1\\n        while i < len(s):\\n            if ord(s[i]) > ord(cur_best[0]):\\n                cur_best = s[i]\\n            elif ord(s[i]) < ord(cur_best[0]):\\n                cur_best += s[i]\\n            else:\\n                p1 = 0\\n                j = i\\n                while p1 < len(cur_best) and j < len(s) and ord(cur_best[p1]) == ord(s[j]):\\n                    p1 += 1\\n                    j += 1\\n                if p1 == len(cur_best) or j == len(s):\\n                    cur_best += s[i:j]\\n                else:\\n                    if ord(s[j]) > ord(cur_best[p1]):\\n                        cur_best = s[i:j]\\n                    else:\\n                        cur_best += s[i:j]\\n                i = j - 1\\n            i += 1\\n        return cur_best\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1053945,
                "title": "python-easy-to-understand",
                "content": "```\\ndef lastSubstring(self, s: str) -> str:\\n        if len(s) == 1:\\n            return s\\n        \\n        prev = s\\n        for i in range(1, len(s)):\\n            if s[i:] > prev:\\n                prev = s[i:]\\n        return prev\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef lastSubstring(self, s: str) -> str:\\n        if len(s) == 1:\\n            return s\\n        \\n        prev = s\\n        for i in range(1, len(s)):\\n            if s[i:] > prev:\\n                prev = s[i:]\\n        return prev\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 829075,
                "title": "c-o-n-o-1-easy-to-understand-2-pointer-method",
                "content": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int pointer1=0,pointer2=1,currletter=0;\\n        while(pointer2+currletter<s.size()){\\n            if(s[pointer1+currletter] == s[pointer2+currletter]){\\n                currletter++;\\n            } else if(s[pointer1+currletter] < s[pointer2+currletter]){\\n                pointer1 = pointer2;\\n                pointer2++;\\n                currletter=0;\\n            } else {\\n                pointer2+=currletter+1;\\n                currletter=0;\\n            }\\n        }\\n        return s.substr(pointer1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int pointer1=0,pointer2=1,currletter=0;\\n        while(pointer2+currletter<s.size()){\\n            if(s[pointer1+currletter] == s[pointer2+currletter]){\\n                currletter++;\\n            } else if(s[pointer1+currletter] < s[pointer2+currletter]){\\n                pointer1 = pointer2;\\n                pointer2++;\\n                currletter=0;\\n            } else {\\n                pointer2+=currletter+1;\\n                currletter=0;\\n            }\\n        }\\n        return s.substr(pointer1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361514,
                "title": "python-o-n-solution-112ms-faster-than-100-00-of-submissions",
                "content": "The solution is based on the thought that the last substring in lexicographical order has to start with the largest possible character. Moreover, assuming the largest possible character is \"z\", \"zz\" + any substring starting with non-z (e.g., \"zza\") is always larger than \"z\" + largest possible substring starting with non-z (e.g., \"zyyyy\"). Then, an important implication is that if there is a substring \"zzzzz\", using one of them as the starting character, we only need to consider the first \"z\", because any substring starting with other \"z\" would be smaller lexicographically (e.g., \"zzzzza\" > \"zzzza\").\\n\\nNow we are ready to proceed to the next step, which is to browse through the whole string and find the largest possible character, as well as the longest contiguous subtrings composed of that character only. The indexes of the starting characters of them can then be saved in a HashSet. If there is only one such index, congratulation as you have already found the solution!\\n\\nHowever, we do have to consider the cases where there are multiple such indexes. What is next then? Well, we just keep comparing the next characters following them until we have only one winner left. mapleisle (https://leetcode.com/problems/last-substring-in-lexicographical-order/discuss/361121/Python-O(n)-with-explanation) proposed a very interesting early termination criteria, which did not significanlty improve the performance in this specfic test case setting, but was very inspiring. mapleisle mentioned that if the next character under comparison happened to have the index saved in the original HashSet (i.e. used as the starting character of a substring), the substring starting with this \"next character\" could not be the optimal solution. This is very intuitive and please refer to mapleisle\\'s post for explanations.\\n\\nFinally, we got the solutions! Let me summarize the key steps below:\\n\\n1. Find the largest character, and longest contiguous substrings of that character. Save starting indexes in a HashSet.\\n2. Iteratively compare the next following character until only one winner left.\\n3. (Optional) Remove indexes being the next following character of other subtrings under comparison.\\n\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        n, i, MAX, best, pool = len(s), 0, max(s), 0, set()\\n        \\n        # Find all the longest contiguous subtrings of largest charaters only\\n        # Save their starting indexes in \"pool\" and lengths using \"best\".\\n        while i < n: \\n            j = i + 1\\n            if s[i] == MAX:\\n                while j < n and s[j] == MAX:\\n                    j += 1\\n                if j - i > best:\\n                    pool, best = {i}, j - i\\n                elif j - i == best:\\n                    pool.add(i)\\n            i = j\\n        \\n        # Compare following chacaters until only one winner left.\\n        # We can start the search using \"best\" because any character before \"best\" is the same.\\n        # \"visited\" is used for early termination purposes only. Not required.\\n        step, visited = best, pool.copy()\\n        while len(pool) > 1:\\n            temp, cur = set(), max(s[p + step] if p + step < n else \"\" for p in pool)\\n            for p in pool:\\n                if p + step == n or s[p + step] != cur:\\n                    temp.add(p)\\n                elif p + step in visited:\\n                    temp.add(p + step)\\n            pool -= temp\\n            step += 1\\n        return s[list(pool)[0]:]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        n, i, MAX, best, pool = len(s), 0, max(s), 0, set()\\n        \\n        # Find all the longest contiguous subtrings of largest charaters only\\n        # Save their starting indexes in \"pool\" and lengths using \"best\".\\n        while i < n: \\n            j = i + 1\\n            if s[i] == MAX:\\n                while j < n and s[j] == MAX:\\n                    j += 1\\n                if j - i > best:\\n                    pool, best = {i}, j - i\\n                elif j - i == best:\\n                    pool.add(i)\\n            i = j\\n        \\n        # Compare following chacaters until only one winner left.\\n        # We can start the search using \"best\" because any character before \"best\" is the same.\\n        # \"visited\" is used for early termination purposes only. Not required.\\n        step, visited = best, pool.copy()\\n        while len(pool) > 1:\\n            temp, cur = set(), max(s[p + step] if p + step < n else \"\" for p in pool)\\n            for p in pool:\\n                if p + step == n or s[p + step] != cur:\\n                    temp.add(p)\\n                elif p + step in visited:\\n                    temp.add(p + step)\\n            pool -= temp\\n            step += 1\\n        return s[list(pool)[0]:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577942,
                "title": "c-unique-sol-hashing-easy-explained-hashing-template",
                "content": "Convince youself first that it will be a suffix of the string. (Easy bit)\\nLets consider we have a suffix initially consisting of only 1 character that is s[n - 1].\\nString of n size has n suffixes (Clearly).\\nWe have to consider each one of them and then **compare with running lexiographically** **maximum**, but we have to do this comparision fast. (comparing 2 strings naively takes O(len(string)).\\nHere ***Hashing*** comes into the picture.\\n# Comparison of 2 strings:\\n1. Find the first position where they have different characters. (Follow 4 point: for how to)\\n2. String having greater char at this position will be lexiographically greater then then other one.\\n3. If they dont have a different char at any position then one with larger length will be lexiographically greater.\\n4. Binary search on the first position we they have different chars.(See implementation)\\n\\n# TC: O(NlogN)\\n# SC: O(N)\\n\\n```\\nstruct Hashs {\\n\\tvector<int> hashs;\\n\\tvector<int> pows;\\n\\tint P;\\n\\tint MOD;\\n\\tHashs() {}\\n\\tHashs(string &s, int P, int MOD) : P(P), MOD(MOD) {\\n\\t\\tint n = s.size();\\n\\t\\tpows.resize(n + 1, 0);\\n\\t\\thashs.resize(n + 1, 0);\\n\\t\\tpows[0] = 1;\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\thashs[i] = (1LL * hashs[i + 1] * P + s[i] - \\'a\\' + 1) % MOD;\\n\\t\\t\\tpows[n - i] = (1LL * pows[n-i-1] * P) % MOD;\\n\\t\\t}\\n\\t\\tpows[n] = (1LL * pows[n-1] * P)%MOD;\\n\\t}\\n\\tint get_hash(int l, int r) { \\n \\t\\tint ans = hashs[l] + MOD - (1LL * hashs[r + 1] * pows[r-l+1]) % MOD;\\n\\t\\tans %= MOD;\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        Hashs hash(s, 31, 1e9 + 7);\\n        int n = s.size();\\n        int curSuffixIdx = n - 1;\\n        for (int i = n - 2; i >= 0; --i) {\\n            int len = n - curSuffixIdx;\\n            int l = 1, r = len;\\n            int matchLen = 0;\\n            while (l <= r) {\\n                int mid = (l + r) >> 1;\\n                if (hash.get_hash(i, i + mid - 1) == hash.get_hash(curSuffixIdx, curSuffixIdx + mid - 1)) {\\n                    matchLen = mid;\\n                    l = mid + 1;\\n                } else {\\n                    r = mid - 1;\\n                }\\n            }\\n            if (matchLen == len) {\\n                curSuffixIdx = i;\\n                continue;\\n            }\\n            if (s[i + matchLen] > s[curSuffixIdx + matchLen]) {\\n                curSuffixIdx = i;\\n            }\\n        }\\n        return s.substr(curSuffixIdx);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct Hashs {\\n\\tvector<int> hashs;\\n\\tvector<int> pows;\\n\\tint P;\\n\\tint MOD;\\n\\tHashs() {}\\n\\tHashs(string &s, int P, int MOD) : P(P), MOD(MOD) {\\n\\t\\tint n = s.size();\\n\\t\\tpows.resize(n + 1, 0);\\n\\t\\thashs.resize(n + 1, 0);\\n\\t\\tpows[0] = 1;\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\thashs[i] = (1LL * hashs[i + 1] * P + s[i] - \\'a\\' + 1) % MOD;\\n\\t\\t\\tpows[n - i] = (1LL * pows[n-i-1] * P) % MOD;\\n\\t\\t}\\n\\t\\tpows[n] = (1LL * pows[n-1] * P)%MOD;\\n\\t}\\n\\tint get_hash(int l, int r) { \\n \\t\\tint ans = hashs[l] + MOD - (1LL * hashs[r + 1] * pows[r-l+1]) % MOD;\\n\\t\\tans %= MOD;\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        Hashs hash(s, 31, 1e9 + 7);\\n        int n = s.size();\\n        int curSuffixIdx = n - 1;\\n        for (int i = n - 2; i >= 0; --i) {\\n            int len = n - curSuffixIdx;\\n            int l = 1, r = len;\\n            int matchLen = 0;\\n            while (l <= r) {\\n                int mid = (l + r) >> 1;\\n                if (hash.get_hash(i, i + mid - 1) == hash.get_hash(curSuffixIdx, curSuffixIdx + mid - 1)) {\\n                    matchLen = mid;\\n                    l = mid + 1;\\n                } else {\\n                    r = mid - 1;\\n                }\\n            }\\n            if (matchLen == len) {\\n                curSuffixIdx = i;\\n                continue;\\n            }\\n            if (s[i + matchLen] > s[curSuffixIdx + matchLen]) {\\n                curSuffixIdx = i;\\n            }\\n        }\\n        return s.substr(curSuffixIdx);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358456,
                "title": "c-solution-with-logic-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        /* Idea is to traverse the string from behind and search for the max char (let its ind be: max_ind)\\n        then during this traversal from back to front, three cases are possible:\\n        1. max char > curr max char is found at some ind i < max_ind then max_ind = i\\n        2. char = curr max char is found at some ind i, then, there are two possibilities:\\n        a. max_ind now becomes i OR b. max_ind stays as it is i.e = curr max_ind\\n        a. is when char at ind i + j > char at max_ind + j OR\\n        when s[i + 1 ... max_ind - 1] = s[max_ind + 1 ... 2 * max_ind - i - 1] (eg: ababa, max_ind = 3, i = 1)\\n        o.w b. (eg: abcdba)\\n        3. only 1 max char is found\\n        Final Ans is s[max_ind : ]\\n        */\\n        int n = s.length();\\n        int max_ind = n - 1, i = n - 2;\\n        while (i >= 0) {\\n            // case 1\\n            if (s[i] > s[max_ind])\\n                max_ind = i;\\n            // case 2\\n            else if (s[i] == s[max_ind]) {\\n                // if max_ind was last_ind then update it and continue\\n                if (max_ind == n - 1) {\\n                    max_ind = i;\\n                    continue;\\n                }\\n                // o.w check for case a. and b. of case 2 (max_ind + j < n is used to avoid seg fault eg: abaaba)\\n                int j = 1;\\n                while (max_ind + j < n and s[i + j] == s[max_ind + j] and i + j != max_ind) j++;\\n                // case a.\\n                if (not (max_ind + j < n and s[i + j] < s[max_ind + j]))\\n                    max_ind = i;\\n            }\\n            i--;\\n        }\\n        return s.substr(max_ind);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        /* Idea is to traverse the string from behind and search for the max char (let its ind be: max_ind)\\n        then during this traversal from back to front, three cases are possible:\\n        1. max char > curr max char is found at some ind i < max_ind then max_ind = i\\n        2. char = curr max char is found at some ind i, then, there are two possibilities:\\n        a. max_ind now becomes i OR b. max_ind stays as it is i.e = curr max_ind\\n        a. is when char at ind i + j > char at max_ind + j OR\\n        when s[i + 1 ... max_ind - 1] = s[max_ind + 1 ... 2 * max_ind - i - 1] (eg: ababa, max_ind = 3, i = 1)\\n        o.w b. (eg: abcdba)\\n        3. only 1 max char is found\\n        Final Ans is s[max_ind : ]\\n        */\\n        int n = s.length();\\n        int max_ind = n - 1, i = n - 2;\\n        while (i >= 0) {\\n            // case 1\\n            if (s[i] > s[max_ind])\\n                max_ind = i;\\n            // case 2\\n            else if (s[i] == s[max_ind]) {\\n                // if max_ind was last_ind then update it and continue\\n                if (max_ind == n - 1) {\\n                    max_ind = i;\\n                    continue;\\n                }\\n                // o.w check for case a. and b. of case 2 (max_ind + j < n is used to avoid seg fault eg: abaaba)\\n                int j = 1;\\n                while (max_ind + j < n and s[i + j] == s[max_ind + j] and i + j != max_ind) j++;\\n                // case a.\\n                if (not (max_ind + j < n and s[i + j] < s[max_ind + j]))\\n                    max_ind = i;\\n            }\\n            i--;\\n        }\\n        return s.substr(max_ind);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174887,
                "title": "java-o-n-2-loops",
                "content": "```\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        char largestChar = \\'a\\';\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) > largestChar) {\\n                largestChar = s.charAt(i);\\n            }\\n        }\\n        \\n        int largestIndex = -1; // starting point of the current largest substring\\n        int i = 0;\\n        while ( i < s.length() ) {\\n            if (s.charAt(i) == largestChar) {\\n                if (largestIndex == -1) {\\n                    largestIndex = i;\\n                    i++;\\n                }\\n                else {\\n                    int a = i;\\n                    int b = largestIndex;\\n                    int jumpIndex = -1;\\n                    // skip a good number of comparison which won\\'t be greater than indices.get(j)\\n                    while (a < s.length() && s.charAt(a) == s.charAt(b)) {\\n                        if (s.charAt(a) != largestChar) jumpIndex = a;\\n                        a++;\\n                        b++;\\n                    }\\n                    if (jumpIndex == -1) jumpIndex = a;\\n                    if (a < s.length() && s.charAt(a) > s.charAt(b)) largestIndex = i;\\n                    i = jumpIndex;\\n                }\\n            }\\n            else i++;\\n        }\\n        return s.substring(largestIndex);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        char largestChar = \\'a\\';\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) > largestChar) {\\n                largestChar = s.charAt(i);\\n            }\\n        }\\n        \\n        int largestIndex = -1; // starting point of the current largest substring\\n        int i = 0;\\n        while ( i < s.length() ) {\\n            if (s.charAt(i) == largestChar) {\\n                if (largestIndex == -1) {\\n                    largestIndex = i;\\n                    i++;\\n                }\\n                else {\\n                    int a = i;\\n                    int b = largestIndex;\\n                    int jumpIndex = -1;\\n                    // skip a good number of comparison which won\\'t be greater than indices.get(j)\\n                    while (a < s.length() && s.charAt(a) == s.charAt(b)) {\\n                        if (s.charAt(a) != largestChar) jumpIndex = a;\\n                        a++;\\n                        b++;\\n                    }\\n                    if (jumpIndex == -1) jumpIndex = a;\\n                    if (a < s.length() && s.charAt(a) > s.charAt(b)) largestIndex = i;\\n                    i = jumpIndex;\\n                }\\n            }\\n            else i++;\\n        }\\n        return s.substring(largestIndex);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1141054,
                "title": "simple-python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        \\n        i,j=0,1\\n        while j<len(s):\\n            if s[j]>s[i]:\\n                i=j\\n            elif s[j]==s[i]:\\n                p,q=i,j\\n                while p<j and q<len(s):\\n                    if s[p]>s[q]:break\\n                    elif s[q]>s[p]:\\n                        i=j\\n                        break\\n                    else:\\n                        p+=1\\n                        q+=1\\n                j=q-1\\n            j=j+1\\n        return s[i:j]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        \\n        i,j=0,1\\n        while j<len(s):\\n            if s[j]>s[i]:\\n                i=j\\n            elif s[j]==s[i]:\\n                p,q=i,j\\n                while p<j and q<len(s):\\n                    if s[p]>s[q]:break\\n                    elif s[q]>s[p]:\\n                        i=j\\n                        break\\n                    else:\\n                        p+=1\\n                        q+=1\\n                j=q-1\\n            j=j+1\\n        return s[i:j]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1086288,
                "title": "o-n-java-different-way-of-solving-easy-understanding",
                "content": "```\\nclass Solution {\\n    public String lastSubstring(String S) {\\n        \\n        if(S.length() == 1) return S;\\n        \\n        char s[] = S.toCharArray();\\n        \\n        // The biggest char : \\n        char biggestChar = s[0];\\n        int maxIndex = 0;\\n        \\n        int i = 1;  // Start at 1 index.\\n        \\n        while(i < s.length){\\n            \\n            if(biggestChar > s[i]) {\\n                i++;\\n                continue;\\n            }\\n            if(biggestChar < s[i]){\\n                biggestChar = s[i];\\n                maxIndex = i;\\n                i++;\\n                continue;\\n            } \\n            \\n            // biggest char is same at s[i] : \\n            \\n            // Compare foward in both substrings : \\n            int m = 1;\\n            int lastIndexOfBiggestChar = s.length;  // Last index of biggest char is important for cases like \"cacacacb\".\\n            while(i + m < s.length && s[i + m] == s[maxIndex + m]){\\n                if(s[maxIndex] == s[maxIndex + m]){\\n                    lastIndexOfBiggestChar = m;\\n                }\\n                m++;\\n            }\\n            \\n            // We reached the end, all chars were same.\\n            if(i + m == s.length){\\n                break;\\n            }\\n            \\n            // At \\'i + m\\' we have a different character : \\n            \\n            // If \\'i + m\\' is the biggest char : \\n            if(s[i + m] > biggestChar){\\n                biggestChar = s[i + m];\\n                maxIndex = i + m;\\n                i = i + m + 1;      // Skip \\'m\\' chars. Makes it O(n).\\n                continue;\\n            }\\n            \\n            // If \\'i + m\\' is bigger than \\'maxIndex + m\\' : \\n            if(s[i + m] > s[maxIndex + m]){\\n                biggestChar = s[i];\\n                maxIndex = i;\\n            }\\n\\n            // Skip atleast upto last index of biggest char : \\n            i = i + Math.min(lastIndexOfBiggestChar, m);        // Makes it O(n).\\n        }\\n        \\n        return S.substring(maxIndex);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String lastSubstring(String S) {\\n        \\n        if(S.length() == 1) return S;\\n        \\n        char s[] = S.toCharArray();\\n        \\n        // The biggest char : \\n        char biggestChar = s[0];\\n        int maxIndex = 0;\\n        \\n        int i = 1;  // Start at 1 index.\\n        \\n        while(i < s.length){\\n            \\n            if(biggestChar > s[i]) {\\n                i++;\\n                continue;\\n            }\\n            if(biggestChar < s[i]){\\n                biggestChar = s[i];\\n                maxIndex = i;\\n                i++;\\n                continue;\\n            } \\n            \\n            // biggest char is same at s[i] : \\n            \\n            // Compare foward in both substrings : \\n            int m = 1;\\n            int lastIndexOfBiggestChar = s.length;  // Last index of biggest char is important for cases like \"cacacacb\".\\n            while(i + m < s.length && s[i + m] == s[maxIndex + m]){\\n                if(s[maxIndex] == s[maxIndex + m]){\\n                    lastIndexOfBiggestChar = m;\\n                }\\n                m++;\\n            }\\n            \\n            // We reached the end, all chars were same.\\n            if(i + m == s.length){\\n                break;\\n            }\\n            \\n            // At \\'i + m\\' we have a different character : \\n            \\n            // If \\'i + m\\' is the biggest char : \\n            if(s[i + m] > biggestChar){\\n                biggestChar = s[i + m];\\n                maxIndex = i + m;\\n                i = i + m + 1;      // Skip \\'m\\' chars. Makes it O(n).\\n                continue;\\n            }\\n            \\n            // If \\'i + m\\' is bigger than \\'maxIndex + m\\' : \\n            if(s[i + m] > s[maxIndex + m]){\\n                biggestChar = s[i];\\n                maxIndex = i;\\n            }\\n\\n            // Skip atleast upto last index of biggest char : \\n            i = i + Math.min(lastIndexOfBiggestChar, m);        // Makes it O(n).\\n        }\\n        \\n        return S.substring(maxIndex);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980014,
                "title": "simple-solution-in-python-faster-than-98-xd",
                "content": "Simple idea: just split the string into parts that start with one or more \\'max character\\'s. For example, \\'zazbzzczzc\\' will split to [\\'za\\', \\'zb\\', \\'zzc\\', \\'zzc\\'].\\nThen find the first max part. In the example above, it\\'s the \\'zzc\\' at index 2 (index from 0). \\nFinally, return the concat of parts from that first max part to the end. In the example above, eturn \\'zzczzc\\'. \\n\\n```\\ndef lastSubstring(self, s: str) -> str:\\n        max_c = max(s)\\n        last_max_c = None\\n        parts = []\\n        \\n        for i, c in enumerate(s):\\n            if c == max_c:\\n                if i> 0 and s[i - 1] == max_c:\\n                    continue\\n                                    \\n                if last_max_c is not None:\\n                    parts.append(s[last_max_c:i])\\n                    \\n                last_max_c = i\\n                \\n        parts.append(s[last_max_c:])\\n        # print(parts)\\n        \\n        max_p, max_p_i = parts[0], 0\\n        for i, p in enumerate(parts):\\n            if p > max_p:\\n                max_p = p\\n                max_p_i = i\\n        \\n        return \\'\\'.join(parts[max_p_i:])\\n```",
                "solutionTags": [],
                "code": "```\\ndef lastSubstring(self, s: str) -> str:\\n        max_c = max(s)\\n        last_max_c = None\\n        parts = []\\n        \\n        for i, c in enumerate(s):\\n            if c == max_c:\\n                if i> 0 and s[i - 1] == max_c:\\n                    continue\\n                                    \\n                if last_max_c is not None:\\n                    parts.append(s[last_max_c:i])\\n                    \\n                last_max_c = i\\n                \\n        parts.append(s[last_max_c:])\\n        # print(parts)\\n        \\n        max_p, max_p_i = parts[0], 0\\n        for i, p in enumerate(parts):\\n            if p > max_p:\\n                max_p = p\\n                max_p_i = i\\n        \\n        return \\'\\'.join(parts[max_p_i:])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 976059,
                "title": "dynamic-programming-solution-searching-backwards",
                "content": "It\\'s pretty obvious that the largest substring has to be a suffix of the original string s  \\nSo we kind of think of this problem with dynamic programming like this:\\n\\nWe scan from the end of the string, and keep the index of the largest suffix in i\\nat first i is n-1\\nWhen we check a new character s[j], we compare it with s[i]\\nif it is smaller, then we don\\'t have a larger suffix\\nif it is larger, then we do find a larger suffix\\nif it is the same, we have to compare the two suffixes\\n\\nThe idea is that when comparing s[j:n] with s[i:n], we do not need to compare beyond s[j:i], because if we do, we will be effectively comparing s[i:n] with s[2i-j:n], with the s[i:n] being the largest suffix so far we know that the s[i:n] is larger than s[2i-j:n], which means that s[j:n] is larger than s[i:n]\\n\\n\\n```\\npublic String lastSubstring(String s) {\\n        char[] chs = s.toCharArray();\\n        int n = chs.length;\\n\\n        int i = n-1;\\n\\n        // [i, n) current largest\\n        for (int j = n - 2; j >= 0; j--) {\\n            if (chs[j] < chs[i]) continue;\\n            if (chs[j] > chs[i]) {\\n                i = j;\\n                continue;\\n            }\\n\\n            // jth = ith\\n            int l = j;\\n            int r = i;\\n            while (l < i && r < n && chs[l] == chs[r]) {\\n                l++;\\n                r++;\\n            }\\n\\n            // if r == n, then [j, i) == [i, n) => [j, n) > [i, n)\\n            // if l == i, then [j, i) == [i, 2i-j), with [i, n) > [2i-j, n) we have [j, n) > [i, n)\\n            // if l < i && r < n, then we found chs[l] != chs[r], if lth > rth, then [j,n) > [i,n)\\n            if (r == n || l == i || chs[l] > chs[r]) {\\n                i = j;\\n            }\\n        }\\n\\n        return new String(chs, i, n - i);\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic String lastSubstring(String s) {\\n        char[] chs = s.toCharArray();\\n        int n = chs.length;\\n\\n        int i = n-1;\\n\\n        // [i, n) current largest\\n        for (int j = n - 2; j >= 0; j--) {\\n            if (chs[j] < chs[i]) continue;\\n            if (chs[j] > chs[i]) {\\n                i = j;\\n                continue;\\n            }\\n\\n            // jth = ith\\n            int l = j;\\n            int r = i;\\n            while (l < i && r < n && chs[l] == chs[r]) {\\n                l++;\\n                r++;\\n            }\\n\\n            // if r == n, then [j, i) == [i, n) => [j, n) > [i, n)\\n            // if l == i, then [j, i) == [i, 2i-j), with [i, n) > [2i-j, n) we have [j, n) > [i, n)\\n            // if l < i && r < n, then we found chs[l] != chs[r], if lth > rth, then [j,n) > [i,n)\\n            if (r == n || l == i || chs[l] > chs[r]) {\\n                i = j;\\n            }\\n        }\\n\\n        return new String(chs, i, n - i);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 908350,
                "title": "two-js-solutions",
                "content": "```\\n// First Solution\\n// Inefficient\\nvar lastSubstring = function(s) {\\n    if (s.length == 0) return \"\";\\n    let indices = findMaxIndices(s);\\n    let maxSubstr = \"\";\\n    for (let index of indices) {\\n        let substr = s.slice(index);\\n        if (substr > maxSubstr) {\\n            maxSubstr = substr;\\n        }\\n    }\\n    return maxSubstr;\\n    \\n};\\n\\nvar findMaxIndices = function(s) {\\n    let maxChar = \\'\\', indices = [];\\n    for (let i = 0; i < s.length; i++) {\\n        let char = s[i];\\n        if (char >= maxChar) {\\n            maxChar = char;\\n            indices.push(i);\\n        }\\n    }\\n    return indices;\\n}\\n\\n/*\\nTest Cases:\\n\"cacacb\" => \"cb\"\\n\"\" => \"\"\\n\\nFirst, the maximum substring must start with the maximum character in the string.\\nSo, we collect indices of all maximum characters.\\nSecond, we simply need to take the longest substring from each index because if prefixes\\nare the same the longer one is considered greater. Find the greatest out of those longest substrings from each index.\\n\\nTime Complexity: O(n^2)\\nSpace Complexity: O(n)\\n*/\\n```\\n\\n```\\n// Second Solution\\n// Efficient\\n/*\\nThe substring starting with the largest character is the answer. Hence we advance j and try to find the biggest character \\nwhile we use i to keep track of the current maximum string.\\nWhat if there is more than one largest character?\\n- we will need to compare both substrings starting with the largest character.\\n- (1) the substring with bigger next character is the answer.\\n- (2) if the shorter substring is exactly the same to the longer substring up to its end, the longer substring is the answer.\\n\\ni is the starting index of the answer\\nj is the pointer iterating through given string\\nk is the offset to use when we find two substrings starting with the same character\\n*/\\nvar lastSubstring = function(s) {\\n    let i = 0, j = 1, k = 0;\\n    while (j + k < s.length) {\\n        k = 0;\\n        while (s[i+k] === s[j+k]) {\\n            k += 1;\\n            if (j + k === s.length) break;\\n            // if the shorter substring is exactly the same to the longer substring up to its end, \\n            // the longer substring is the answer.\\n            // hence, if j+k reaches the end, s.substring(i) will be the answer since we maintain i < j\\n        }\\n        if (s[i+k] > s[j+k]) {\\n            j = j + 1 + k; // because there is no chance s[i+k] <= s[j+k]\\n        } else if (s[i+k] < s[j+k]) {\\n            i = i + 1 + k; // because there is no chance s[i+k] >= s[j+k]\\n        }\\n        // to ensure that i < j\\n        if (i >= j) {\\n            j = i + 1;\\n        }\\n    }\\n    return s.substring(i);\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// First Solution\\n// Inefficient\\nvar lastSubstring = function(s) {\\n    if (s.length == 0) return \"\";\\n    let indices = findMaxIndices(s);\\n    let maxSubstr = \"\";\\n    for (let index of indices) {\\n        let substr = s.slice(index);\\n        if (substr > maxSubstr) {\\n            maxSubstr = substr;\\n        }\\n    }\\n    return maxSubstr;\\n    \\n};\\n\\nvar findMaxIndices = function(s) {\\n    let maxChar = \\'\\', indices = [];\\n    for (let i = 0; i < s.length; i++) {\\n        let char = s[i];\\n        if (char >= maxChar) {\\n            maxChar = char;\\n            indices.push(i);\\n        }\\n    }\\n    return indices;\\n}\\n\\n/*\\nTest Cases:\\n\"cacacb\" => \"cb\"\\n\"\" => \"\"\\n\\nFirst, the maximum substring must start with the maximum character in the string.\\nSo, we collect indices of all maximum characters.\\nSecond, we simply need to take the longest substring from each index because if prefixes\\nare the same the longer one is considered greater. Find the greatest out of those longest substrings from each index.\\n\\nTime Complexity: O(n^2)\\nSpace Complexity: O(n)\\n*/\\n```\n```\\n// Second Solution\\n// Efficient\\n/*\\nThe substring starting with the largest character is the answer. Hence we advance j and try to find the biggest character \\nwhile we use i to keep track of the current maximum string.\\nWhat if there is more than one largest character?\\n- we will need to compare both substrings starting with the largest character.\\n- (1) the substring with bigger next character is the answer.\\n- (2) if the shorter substring is exactly the same to the longer substring up to its end, the longer substring is the answer.\\n\\ni is the starting index of the answer\\nj is the pointer iterating through given string\\nk is the offset to use when we find two substrings starting with the same character\\n*/\\nvar lastSubstring = function(s) {\\n    let i = 0, j = 1, k = 0;\\n    while (j + k < s.length) {\\n        k = 0;\\n        while (s[i+k] === s[j+k]) {\\n            k += 1;\\n            if (j + k === s.length) break;\\n            // if the shorter substring is exactly the same to the longer substring up to its end, \\n            // the longer substring is the answer.\\n            // hence, if j+k reaches the end, s.substring(i) will be the answer since we maintain i < j\\n        }\\n        if (s[i+k] > s[j+k]) {\\n            j = j + 1 + k; // because there is no chance s[i+k] <= s[j+k]\\n        } else if (s[i+k] < s[j+k]) {\\n            i = i + 1 + k; // because there is no chance s[i+k] >= s[j+k]\\n        }\\n        // to ensure that i < j\\n        if (i >= j) {\\n            j = i + 1;\\n        }\\n    }\\n    return s.substring(i);\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 905006,
                "title": "the-easiest-way-to-solve-the-problem-based-on-java",
                "content": "This problem is not too hard.\\nIntutive thinking:\\nThe result substring\\'s first letter should be a very large letter, actually, the largest one.\\nAnd the result substring should be as longer as possible, due to we want the last one in Lexicographical Order.\\n\\nThus, we only need to tackle one position: two substrings with two same prefix letters, we use k to represent it.\\n\\ni means current result\\'s start index\\nj means the previous result\\'s start index\\n\\nif current one is better than previous one, we replace it by current one.\\nfinally, we return j.\\n```\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        int len=s.length();\\n        int i=1,j=0,k=0;\\n        \\n        while(i+k<len){\\n            //k means the same letters, the longer, the better.\\n            if(s.charAt(i+k)==s.charAt(j+k)){\\n                k++;\\n                continue;\\n            }            \\n            //if we find a larger one, replace j by current i.\\n            if(s.charAt(i+k)>=s.charAt(j+k)){\\n                j=i;\\n            }            \\n            i++;\\n            //every time, we should initiate k by 0.\\n            k=0;\\n        }\\n        return s.substring(j);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        int len=s.length();\\n        int i=1,j=0,k=0;\\n        \\n        while(i+k<len){\\n            //k means the same letters, the longer, the better.\\n            if(s.charAt(i+k)==s.charAt(j+k)){\\n                k++;\\n                continue;\\n            }            \\n            //if we find a larger one, replace j by current i.\\n            if(s.charAt(i+k)>=s.charAt(j+k)){\\n                j=i;\\n            }            \\n            i++;\\n            //every time, we should initiate k by 0.\\n            k=0;\\n        }\\n        return s.substring(j);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856359,
                "title": "python-straightforward-o-n-solution",
                "content": "**Straightforward Idea:** Find the character(s) with maximum ASCII (\\'ord\\' in python), and compare them with each other by looking the next character. Return the solution until only one left.\\n\\n**Note:** if maximum ord indexes form a continuous sequence (e.g. \"avdzzzzzsdaszzzd\") we only need to track the first occurrence (e.g. the first \\'z\\' in each \"zz..\" group )\\n\\n**Complexity:** Every element will only be compared once, therefore the complexity is O(n)\\n\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        max_ord = max([ord(c) for c in s])\\n        max_ord_idxs = [i for i in range(len(s)) if ord(s[i]) == max_ord]\\n        first_unique_idx = [i for i in range(len(max_ord_idxs)-1, -1, -1) if i == 0 or max_ord_idxs[i]-1 != max_ord_idxs[i-1] ]\\n        max_ord_idxs = [max_ord_idxs[i] for i in first_unique_idx]\\n        if len(max_ord_idxs) == 1:\\n            return s[max_ord_idxs[0]:]\\n        \\n        def findNextMaxOrd(cur_idxs, level):\\n            nextOrd2CurIdx = collections.defaultdict(list)\\n            hist_max = float(\\'-inf\\')\\n            for idx in cur_idxs:\\n                if idx < len(s) - level:\\n                    nextOrd2CurIdx[ord(s[idx+level])].append(idx)\\n                    hist_max = max(hist_max, ord(s[idx+level]))\\n            return nextOrd2CurIdx[hist_max]\\n\\n        # Filtering indexes with maximum ord by comparing k-level away\\n        level = 1\\n        while 1:\\n            max_ord_idxs = findNextMaxOrd(max_ord_idxs, level)\\n            if len(max_ord_idxs) == 1:\\n                return s[max_ord_idxs[0]:]\\n            level += 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        max_ord = max([ord(c) for c in s])\\n        max_ord_idxs = [i for i in range(len(s)) if ord(s[i]) == max_ord]\\n        first_unique_idx = [i for i in range(len(max_ord_idxs)-1, -1, -1) if i == 0 or max_ord_idxs[i]-1 != max_ord_idxs[i-1] ]\\n        max_ord_idxs = [max_ord_idxs[i] for i in first_unique_idx]\\n        if len(max_ord_idxs) == 1:\\n            return s[max_ord_idxs[0]:]\\n        \\n        def findNextMaxOrd(cur_idxs, level):\\n            nextOrd2CurIdx = collections.defaultdict(list)\\n            hist_max = float(\\'-inf\\')\\n            for idx in cur_idxs:\\n                if idx < len(s) - level:\\n                    nextOrd2CurIdx[ord(s[idx+level])].append(idx)\\n                    hist_max = max(hist_max, ord(s[idx+level]))\\n            return nextOrd2CurIdx[hist_max]\\n\\n        # Filtering indexes with maximum ord by comparing k-level away\\n        level = 1\\n        while 1:\\n            max_ord_idxs = findNextMaxOrd(max_ord_idxs, level)\\n            if len(max_ord_idxs) == 1:\\n                return s[max_ord_idxs[0]:]\\n            level += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 829885,
                "title": "java-73-time-beaten-2-pointers-solution-with-explaination",
                "content": "This algorithm starts off by comparing all the substrings that\\'s starts at begin1 (subStrs1) and all the substrings that\\'s starts at begin2 (subStrs2).\\n\\nWhen scanning through both subStrs1 and subStrs2 concurrently from left to right, the first non identical character can be used to judge weather all substrings in subStrs1 is larger than all in subStrs2, or vice versa:\\n\\n1: If s[begin1 + k] > s[begin2 + k], then all substrings in subStrs1 is greater than all in subStrs2, since all chars between begin1 and begin2 + k is either equal or smaller than s[begin1], which is a invariant, we can safely assume that any substring that starts at i, where begin1 <= i <= begin2 + k is smaller than any substrings in subStrs1. Thus we filter those substrings out and move the begin2 to begin2 + k + 1.\\n\\n2: If s[begin1 + k] > s[begin2 + k], let begin1 = begin2, and begin2 = begin2 + 1, notice how the algorithm is trying to keep the invariant to be true.\\n\\nFinally, by the termination of the loop, all the comparisons are exhausted and due to the invariant, the final answer will be s[begin1:].\\n\\nAfter a brief browsing through other answers, I think this is the shortest solution. it\\'s very cheeky, and I will be suprised if anyone come up with this solution in a real interview while having no prior exposure to the question.\\n\\n```\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        int begin1 = 0, begin2 = 1;\\n        int k = 0;\\n        while(begin2 + k < s.length())\\n        {\\n            if(s.charAt(begin1 + k) == s.charAt(begin2 + k)) {\\n                k++;\\n            } else if(s.charAt(begin1 + k) > s.charAt(begin2 + k)) {\\n                begin2 = begin2 + k + 1;\\n                k = 0;\\n            } else {\\n                begin1 = begin2;\\n                begin2++;\\n                k = 0;\\n            }\\n        }\\n        return s.substring(begin1, s.length());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        int begin1 = 0, begin2 = 1;\\n        int k = 0;\\n        while(begin2 + k < s.length())\\n        {\\n            if(s.charAt(begin1 + k) == s.charAt(begin2 + k)) {\\n                k++;\\n            } else if(s.charAt(begin1 + k) > s.charAt(begin2 + k)) {\\n                begin2 = begin2 + k + 1;\\n                k = 0;\\n            } else {\\n                begin1 = begin2;\\n                begin2++;\\n                k = 0;\\n            }\\n        }\\n        return s.substring(begin1, s.length());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 713593,
                "title": "java-suffix-array-o-nlgn",
                "content": "```\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        char sp = \\'a\\' - 1;\\n        s += sp;\\n        int len = s.length();\\n        int[] p = new int[len], c = new int[len], cnt = new int[Math.max(len, 27)];\\n        int classes = 27;\\n        for(int i = 0; i < len; i++) {\\n            cnt[s.charAt(i) - sp]++;\\n        }\\n        for(int i = 1; i < classes; i++) {\\n            cnt[i] += cnt[i - 1];\\n        }\\n        for(int i = len - 1; i >= 0; i--) {\\n            p[--cnt[s.charAt(i) - sp]] = i;\\n        }\\n        c[p[0]] = 0;\\n        classes = 1;\\n        for(int i = 1; i < len; i++) {\\n            if(s.charAt(p[i]) != s.charAt(p[i - 1])) {\\n                classes++;\\n            }\\n            c[p[i]] = classes - 1;\\n        }\\n        for(int h = 0; (1 << h) < len; h++) {\\n            int[] pn = new int[len], cn = new int[len];\\n            for(int i = 0; i < len; i++) {\\n                pn[i] = p[i] - (1 << h);\\n                if(pn[i] < 0)\\n                    pn[i] += len;\\n            }\\n            for(int i = 0; i < classes; i++) cnt[i] = 0;\\n            for(int i = 0; i < len; i++) cnt[c[pn[i]]]++;\\n            for(int i = 1; i < len; i++) cnt[i] += cnt[i - 1];\\n            for(int i = len - 1; i >= 0; i--) {\\n                p[--cnt[c[pn[i]]]] = pn[i];\\n            }\\n            cn[p[0]] = 0; classes = 1;\\n            for(int i = 1; i < len; i++) {\\n                if(c[p[i]] != c[p[i - 1]] || c[(p[i] + (1 << h)) % len] != c[(p[i - 1] + (1 << h)) % len]) {\\n                    classes++;\\n                }\\n                cn[p[i]] = classes - 1;\\n            }\\n            c = cn;\\n        }\\n        int start = p[len - 1];\\n        return s.substring(start, len - 1);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String lastSubstring(String s) {\\n        char sp = \\'a\\' - 1;\\n        s += sp;\\n        int len = s.length();\\n        int[] p = new int[len], c = new int[len], cnt = new int[Math.max(len, 27)];\\n        int classes = 27;\\n        for(int i = 0; i < len; i++) {\\n            cnt[s.charAt(i) - sp]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 711066,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        //find the first index with the lexicographically biggest value\\n        int biggest = 0;\\n\\t\\tfor (int i = 1; i < s.size(); i++)\\t{\\n\\t\\t\\tif (s[i] > s[biggest]) {\\n\\t\\t\\t\\tbiggest = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        /*\\n        from that index onwards, find indices with the same letter\\n        if found, run a comparison of the two strings, indicated by:\\n        j represents the current maximum string (from [biggest, s.size()))\\n        j = [biggest, start_i)\\n        start_i is the index we just encountered\\n        i = [start_i, s.size())\\n        i represents the string that could be lexicographically larger\\n        \\n        */\\n\\t\\tfor (int i = biggest + 1; i < s.size(); i++) {\\n\\t\\t\\tif (s[i] == s[biggest]) {\\n\\t\\t\\t\\tint j = biggest;\\n                int start_i = i;\\n                //we keep incrementing i & j till they\\'re in range and the chars at their place are equal\\n                while (i < s.size() && j < start_i && s[i] == s[j]) {\\n                    i++;\\n                    j++;\\n                }\\n                \\n                //if i == s.size() ==> both strings are equal\\n                //if not, and j < start_i, that means we encountered a point of non-equality of chars\\n                //now if at this point, we encountered a char that is bigger, we have a new max_string\\n                //otherwise j==start_i and the previous string is already the biggest one\\n                \\n                if (i < s.size() && j < start_i) {\\n                    if (s[i] > s[j]) {\\n                        biggest = start_i;\\n                    }\\n                }\\n\\t\\t\\t\\ti--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn s.substr(biggest);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        //find the first index with the lexicographically biggest value\\n        int biggest = 0;\\n\\t\\tfor (int i = 1; i < s.size(); i++)\\t{\\n\\t\\t\\tif (s[i] > s[biggest]) {\\n\\t\\t\\t\\tbiggest = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        /*\\n        from that index onwards, find indices with the same letter\\n        if found, run a comparison of the two strings, indicated by:\\n        j represents the current maximum string (from [biggest, s.size()))\\n        j = [biggest, start_i)\\n        start_i is the index we just encountered\\n        i = [start_i, s.size())\\n        i represents the string that could be lexicographically larger\\n        \\n        */\\n\\t\\tfor (int i = biggest + 1; i < s.size(); i++) {\\n\\t\\t\\tif (s[i] == s[biggest]) {\\n\\t\\t\\t\\tint j = biggest;\\n                int start_i = i;\\n                //we keep incrementing i & j till they\\'re in range and the chars at their place are equal\\n                while (i < s.size() && j < start_i && s[i] == s[j]) {\\n                    i++;\\n                    j++;\\n                }\\n                \\n                //if i == s.size() ==> both strings are equal\\n                //if not, and j < start_i, that means we encountered a point of non-equality of chars\\n                //now if at this point, we encountered a char that is bigger, we have a new max_string\\n                //otherwise j==start_i and the previous string is already the biggest one\\n                \\n                if (i < s.size() && j < start_i) {\\n                    if (s[i] > s[j]) {\\n                        biggest = start_i;\\n                    }\\n                }\\n\\t\\t\\t\\ti--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn s.substr(biggest);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632575,
                "title": "java-solution-simple-code",
                "content": "```\\n\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        int left = 0;\\n        int max = 0;\\n        String result = \"\";\\n        for (int i = 1; i < s.length(); i++) {\\n            if(s.charAt(i) - s.charAt(left) >= 0) {\\n                // get the adverse lexicographical substring and compare this substring with result we got before\\n                //if it is bigger than the result before, updated: eg. \"ca\" < \"cb\" updated \\n                String pre = s.substring(left, i);\\n                if (result.compareTo(pre) < 0) {\\n                    result = pre;\\n                    max = left;\\n                }\\n                left = i;\\n            }\\n            while(i != s.length() -1 && s.charAt(i) == s.charAt(i+1)) i++; \\n            \\n        }\\n        // last one\\n        if (result.compareTo(s.substring(left, s.length())) < 0) {\\n            max = left;\\n        }\\n        //case aaaaaaaaaaa\\n        if (max == 1 && s.charAt(max) == s.charAt(0)) max = 0;        \\n        return s.substring(max, s.length());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        int left = 0;\\n        int max = 0;\\n        String result = \"\";\\n        for (int i = 1; i < s.length(); i++) {\\n            if(s.charAt(i) - s.charAt(left) >= 0) {\\n                // get the adverse lexicographical substring and compare this substring with result we got before\\n                //if it is bigger than the result before, updated: eg. \"ca\" < \"cb\" updated \\n                String pre = s.substring(left, i);\\n                if (result.compareTo(pre) < 0) {\\n                    result = pre;\\n                    max = left;\\n                }\\n                left = i;\\n            }\\n            while(i != s.length() -1 && s.charAt(i) == s.charAt(i+1)) i++; \\n            \\n        }\\n        // last one\\n        if (result.compareTo(s.substring(left, s.length())) < 0) {\\n            max = left;\\n        }\\n        //case aaaaaaaaaaa\\n        if (max == 1 && s.charAt(max) == s.charAt(0)) max = 0;        \\n        return s.substring(max, s.length());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544995,
                "title": "java-solution-8-ms-86-46-45-4-mb-100",
                "content": "Runtime: 8 ms, faster than 86.46% of Java online submissions.\\nMemory Usage: 45.4 MB, less than 100.00% of Java online submissions.\\n\\n```\\n    /*\\n    Finds last substring of input in largest lexicographic order.\\n\\n    Algorithm: Find all non-consecutive locations of the max char in the string\\n    and put them in a list. Then compare strings beginning at those indices to\\n    find the largest one.\\n\\n    Detailed steps:\\n        1. Loop through chars in the string to find the max char and add\\n           that to a list. If a character is the same as the previous char,\\n           do *not* add it to the list. This is an important optimization\\n           for cases where the string has many has many consecutive runs of\\n           a max character, which would ultimately result in a huge number\\n           of unnecessary compares.\\n        2. Loop through the list of indexes where there is a max char in the\\n           string, starting at the second item in the list so that there will\\n           be a previous item to compare to.\\n        3. Get one max char index from the list, and a second max char index\\n           from the previous element in the list. From those locations, compare\\n           following characters until you have determined which one of them is\\n           the max. Then repeat the comparison between that max string and other\\n           substrings beginning at a max index.\\n\\n           Example: \"aaaxbcdxbce\"\\n                    Max char: x\\n                    List of max indices: [3, 7]\\n                    Compare chars at indices 4 and 8 to see which is larger.\\n                    They are both the same (b), so compare indices 5 and 9.\\n                    They are both the same (c), so compare indices 6 and 10.\\n                    Char at index 6 is d, char at index 10 is e which is greater,\\n                    so string starting at index 7 is greater.\\n     */\\n    public static String lastSubstring(String s) {\\n        if (s == null || s.length() < 2) {\\n            return s;\\n        }\\n\\n        int stringLen = s.length();\\n        List<Integer> indexes = new ArrayList<>(stringLen);\\n        char[] chars = s.toCharArray();\\n        char max = 0;\\n        char c = 0, prevChar = 0;\\n        for (int i = 0; i < stringLen; i++) {\\n            prevChar = c;\\n            c = chars[i];\\n            if (c != prevChar && c > max) {\\n                max = c;\\n                indexes.clear();\\n                indexes.add(i);\\n            } else if (c != prevChar && c == max) {\\n                indexes.add(i);\\n            }\\n        }\\n\\n        int one = 0;\\n        int two = 0;\\n        int maxIdxStart = 0;\\n        for (int i = 1; i < indexes.size(); i++) {\\n            one = indexes.get(maxIdxStart) + 1;\\n            two = indexes.get(i) + 1;\\n            max = 0;\\n            while (max == 0 && two < stringLen) {\\n                if (chars[one] > chars[two]) {\\n                    max = chars[one];\\n                } else if (chars[two] > chars[one]) {\\n                    max = chars[two];\\n                    maxIdxStart = i;\\n                }\\n                one++;\\n                two++;\\n            }\\n        }\\n        return s.substring(indexes.get(maxIdxStart));\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    /*\\n    Finds last substring of input in largest lexicographic order.\\n\\n    Algorithm: Find all non-consecutive locations of the max char in the string\\n    and put them in a list. Then compare strings beginning at those indices to\\n    find the largest one.\\n\\n    Detailed steps:\\n        1. Loop through chars in the string to find the max char and add\\n           that to a list. If a character is the same as the previous char,\\n           do *not* add it to the list. This is an important optimization\\n           for cases where the string has many has many consecutive runs of\\n           a max character, which would ultimately result in a huge number\\n           of unnecessary compares.\\n        2. Loop through the list of indexes where there is a max char in the\\n           string, starting at the second item in the list so that there will\\n           be a previous item to compare to.\\n        3. Get one max char index from the list, and a second max char index\\n           from the previous element in the list. From those locations, compare\\n           following characters until you have determined which one of them is\\n           the max. Then repeat the comparison between that max string and other\\n           substrings beginning at a max index.\\n\\n           Example: \"aaaxbcdxbce\"\\n                    Max char: x\\n                    List of max indices: [3, 7]\\n                    Compare chars at indices 4 and 8 to see which is larger.\\n                    They are both the same (b), so compare indices 5 and 9.\\n                    They are both the same (c), so compare indices 6 and 10.\\n                    Char at index 6 is d, char at index 10 is e which is greater,\\n                    so string starting at index 7 is greater.\\n     */\\n    public static String lastSubstring(String s) {\\n        if (s == null || s.length() < 2) {\\n            return s;\\n        }\\n\\n        int stringLen = s.length();\\n        List<Integer> indexes = new ArrayList<>(stringLen);\\n        char[] chars = s.toCharArray();\\n        char max = 0;\\n        char c = 0, prevChar = 0;\\n        for (int i = 0; i < stringLen; i++) {\\n            prevChar = c;\\n            c = chars[i];\\n            if (c != prevChar && c > max) {\\n                max = c;\\n                indexes.clear();\\n                indexes.add(i);\\n            } else if (c != prevChar && c == max) {\\n                indexes.add(i);\\n            }\\n        }\\n\\n        int one = 0;\\n        int two = 0;\\n        int maxIdxStart = 0;\\n        for (int i = 1; i < indexes.size(); i++) {\\n            one = indexes.get(maxIdxStart) + 1;\\n            two = indexes.get(i) + 1;\\n            max = 0;\\n            while (max == 0 && two < stringLen) {\\n                if (chars[one] > chars[two]) {\\n                    max = chars[one];\\n                } else if (chars[two] > chars[one]) {\\n                    max = chars[two];\\n                    maxIdxStart = i;\\n                }\\n                one++;\\n                two++;\\n            }\\n        }\\n        return s.substring(indexes.get(maxIdxStart));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 363132,
                "title": "java-solution",
                "content": "\\nTwo solutions\\n\\nThe catch here is to skip consecutive greatest character positions, since these will not contribute.\\n\\n1) sort suffix array\\nThis is pretty straight forward due to hint4, it explicitly says \\'suffix array\\'.\\nHowever the problem of course, is with the longest test ```\"aaa...a\"```. \\n\\nSo the tweak here is to instead sort every substring, only sort the ones starting with greatest character.\\n\\n\\n\\nSuffix array implementation taken from - https://algs4.cs.princeton.edu/63suffix/SuffixArray.java.html\\n\\n```\\nclass Solution {\\n    \\n    String str;\\n    \\n    public String lastSubstring(String s) {\\n        char ch = s.charAt(0);\\n        str = s;\\n        int n = s.length(), idx = 0;\\n        Suffix[] suffix = new Suffix[n];\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(ch < s.charAt(i)) ch = s.charAt(i);\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(s.charAt(i) == ch && ((i > 0 && s.charAt(i - 1) != ch) || i == 0))\\n                suffix[idx++] = new Suffix(i);\\n        }\\n        Arrays.sort(suffix, 0, idx);\\n        return suffix[idx - 1].str();\\n    }\\n    \\n    class Suffix implements Comparable<Suffix>\\n    {\\n        final int idx;\\n        \\n        public Suffix(int i)\\n        {\\n            idx = i;\\n        }\\n        \\n        int length()\\n        {\\n            return str.length() - idx;\\n        }\\n        \\n        char charAt(int k)\\n        {\\n            return str.charAt(k + idx);\\n        }\\n        \\n        String str()\\n        {\\n            return str.substring(idx);\\n        }\\n        \\n        @Override\\n        public int compareTo(Suffix that)\\n        {\\n            if(this == that) return 0;\\n            int n = Math.min(this.length(), that.length());\\n            for(int i = 0; i < n; i++)\\n            {\\n                if(this.charAt(i) < that.charAt(i)) return -1;\\n                if(this.charAt(i) > that.charAt(i)) return 1;\\n            }\\n            return this.length() - that.length();\\n        }\\n    }\\n}\\n```\\n\\n2) find next biggest character and compare\\nThe basic idea is to\\n- update to next biggest character\\n- if same then findout which one is larger\\n- update starting position (or not)\\n```\\nclass Solution {\\n    \\n    public String lastSubstring(String s) {\\n        char ch = s.charAt(0);\\n        int n = s.length(), idx = 0, pos = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(ch < s.charAt(i))\\n            {\\n                ch = s.charAt(i); \\n                pos = i;\\n            }\\n            else if(s.charAt(i) == ch)\\n            {\\n                if(i > 0 && s.charAt(i - 1) != ch) // skip consecutive greatest character\\n                {\\n                    for(int j = pos; j < n; j++)\\n                    {\\n\\t\\t\\t\\t\\t\\tif(j >= i) {pos = i; break;} // current substring is longer - bigger\\n                        if(i + j - pos >= n) break; // previous substring is longer - bigger\\n                        if(s.charAt(j) < s.charAt(i + j - pos)) {pos = i; break;} // current substring bigger\\n                        if(s.charAt(j) > s.charAt(i + j - pos)) break; // previous substring bigger\\n                    }\\n                }\\n            }\\n        }\\n        return s.substring(pos);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\"aaa...a\"```\n```\\nclass Solution {\\n    \\n    String str;\\n    \\n    public String lastSubstring(String s) {\\n        char ch = s.charAt(0);\\n        str = s;\\n        int n = s.length(), idx = 0;\\n        Suffix[] suffix = new Suffix[n];\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(ch < s.charAt(i)) ch = s.charAt(i);\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(s.charAt(i) == ch && ((i > 0 && s.charAt(i - 1) != ch) || i == 0))\\n                suffix[idx++] = new Suffix(i);\\n        }\\n        Arrays.sort(suffix, 0, idx);\\n        return suffix[idx - 1].str();\\n    }\\n    \\n    class Suffix implements Comparable<Suffix>\\n    {\\n        final int idx;\\n        \\n        public Suffix(int i)\\n        {\\n            idx = i;\\n        }\\n        \\n        int length()\\n        {\\n            return str.length() - idx;\\n        }\\n        \\n        char charAt(int k)\\n        {\\n            return str.charAt(k + idx);\\n        }\\n        \\n        String str()\\n        {\\n            return str.substring(idx);\\n        }\\n        \\n        @Override\\n        public int compareTo(Suffix that)\\n        {\\n            if(this == that) return 0;\\n            int n = Math.min(this.length(), that.length());\\n            for(int i = 0; i < n; i++)\\n            {\\n                if(this.charAt(i) < that.charAt(i)) return -1;\\n                if(this.charAt(i) > that.charAt(i)) return 1;\\n            }\\n            return this.length() - that.length();\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public String lastSubstring(String s) {\\n        char ch = s.charAt(0);\\n        int n = s.length(), idx = 0, pos = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(ch < s.charAt(i))\\n            {\\n                ch = s.charAt(i); \\n                pos = i;\\n            }\\n            else if(s.charAt(i) == ch)\\n            {\\n                if(i > 0 && s.charAt(i - 1) != ch) // skip consecutive greatest character\\n                {\\n                    for(int j = pos; j < n; j++)\\n                    {\\n\\t\\t\\t\\t\\t\\tif(j >= i) {pos = i; break;} // current substring is longer - bigger\\n                        if(i + j - pos >= n) break; // previous substring is longer - bigger\\n                        if(s.charAt(j) < s.charAt(i + j - pos)) {pos = i; break;} // current substring bigger\\n                        if(s.charAt(j) > s.charAt(i + j - pos)) break; // previous substring bigger\\n                    }\\n                }\\n            }\\n        }\\n        return s.substring(pos);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360971,
                "title": "python-all-suffixes-approach",
                "content": "The key idea is to realize that the solution will be a proper suffix of s.\\nSo, we go from the end, looking at all suffixes and storing the largest suffix seen so far.\\n\\n```\\ndef lastSubstring(self, s: str) -> str:\\n        if len(set(s)) == 1: return s \\n        idx = len(s) - 1\\n        for i in range(len(s)-2, -1, -1):\\n            k = 0\\n            while idx+k < len(s):\\n                cur, stored = ord(s[i+k]), ord(s[idx+k])\\n                if cur > stored:\\n                    idx = i\\n                    break\\n                elif cur < stored:\\n                    break\\n                k += 1\\n            if idx+k == len(s):\\n                idx = i\\n        return s[idx:]\\n```",
                "solutionTags": [],
                "code": "```\\ndef lastSubstring(self, s: str) -> str:\\n        if len(set(s)) == 1: return s \\n        idx = len(s) - 1\\n        for i in range(len(s)-2, -1, -1):\\n            k = 0\\n            while idx+k < len(s):\\n                cur, stored = ord(s[i+k]), ord(s[idx+k])\\n                if cur > stored:\\n                    idx = i\\n                    break\\n                elif cur < stored:\\n                    break\\n                k += 1\\n            if idx+k == len(s):\\n                idx = i\\n        return s[idx:]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2263217,
                "title": "python-explanation-with-photo-linear-time-easy-intuitive",
                "content": "\\n# EXPLANATION\\n```\\nLet us start with Brute Force :\\n1.Find all substring and store them in a list : list\\n2.Sort the string list : list \\n3.return list[-1]\\n\\nWe can optimize the above problem :\\n\\nAlways remember that \"aaaba\" > \"aaab\" so ans of this problem is always a suffix of string\\n\\n1. think carefully the last substring lexicographically will start from largest character in string\\n2. we can have multiple occurences of such characher : say maxx \\n3. find every substring starting with maxx and store them in a list and sort to find ans\\n\\n\\nWe can give even better optimization:\\n1.  zaac , zaab , zaba , zaay , z , za\\n2. here the largest item is \"zaba\" \\n3. we find this by comparing each index and choosing the largest substring\\n4. Note :zaaba > zaab\\n5.  we can use the list of indexes starting with  largest character and check for each index\\n6.   list = [zaac,zaab,zaba,zaay,z,za]\\n7.   z is same for all of them\\n8.   gap = 1 : item \"z\" has no index 1 so remove it . \\n9.   the item having largest character at index = i + 1 are : new_list = [zaac,zaab,zaba,zaay,za]\\n9.   gap = 2 : item \"za\" has no index 2 remove it. list \\n10. The item having largest character at index  = i + 2 are :  new_list = [zaba]\\n10.   Here only one substring zaba is largest at index i + 2 : hence we get our answer\\n\\n```\\n![image](https://assets.leetcode.com/users/images/e6f4122a-db7f-4d9f-a65a-5e1c08c594b7_1657450099.1811793.png)\\n\\n```\\nInstead of storing the whole substring it is preferable to store the starting index in list\\n\\nLast optimization\\n1. When list = [a,a,a,a] \\n2. we will get list =[0,1,2,3]\\n3. gap = 1 : \\n\\t\\tnew_list = [] , largest_character at index = i + 1  is a \\n\\t\\titem at  list[0] : will be added to\\n\\t\\titem at  list[1]: The character matches largest_character at gap = 1\\n\\t\\tsince list[0] + 1 == 1( which is list[1] ) means the part is repeated i.e\\n\\t\\tsay s = \"baabaab\"\\n\\t\\tso here \"baa_ _ _ _\" and \"_ _ _ baa _ \" are same so in every case\\n\\t\\t\"baabaab\" will be larger than \"baab\" \\n\\t\\tsame will happen for item at list[2],list[3]\\n\\t\\t\\n\\t\\tHence instead of going o(n*n) we do o(n) \\n\\t\\t\\n\\t\\n\\t\\t\\n```\\n![image](https://assets.leetcode.com/users/images/824eba71-fd05-4fe4-a310-55a2127cc75c_1657450113.0455303.png)\\n\\n\\n# CODE\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        n = len(s)\\n        cmax = max(s)\\n        indexes = [ i for i,c in enumerate(s) if c == cmax ]\\n        gap = 1\\n        while len(indexes) > 1:\\n            new_indexes = []\\n            cmax = max(s[i+gap] for i in indexes if i+gap < n)\\n            for i,st in enumerate(indexes):\\n                if i > 0 and indexes[i-1] + gap == st: continue\\n                if st + gap < n and s[st + gap] == cmax:new_indexes.append(st)\\n            indexes = new_indexes\\n            gap += 1\\n        return s[indexes[0]:]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nLet us start with Brute Force :\\n1.Find all substring and store them in a list : list\\n2.Sort the string list : list \\n3.return list[-1]\\n\\nWe can optimize the above problem :\\n\\nAlways remember that \"aaaba\" > \"aaab\" so ans of this problem is always a suffix of string\\n\\n1. think carefully the last substring lexicographically will start from largest character in string\\n2. we can have multiple occurences of such characher : say maxx \\n3. find every substring starting with maxx and store them in a list and sort to find ans\\n\\n\\nWe can give even better optimization:\\n1.  zaac , zaab , zaba , zaay , z , za\\n2. here the largest item is \"zaba\" \\n3. we find this by comparing each index and choosing the largest substring\\n4. Note :zaaba > zaab\\n5.  we can use the list of indexes starting with  largest character and check for each index\\n6.   list = [zaac,zaab,zaba,zaay,z,za]\\n7.   z is same for all of them\\n8.   gap = 1 : item \"z\" has no index 1 so remove it . \\n9.   the item having largest character at index = i + 1 are : new_list = [zaac,zaab,zaba,zaay,za]\\n9.   gap = 2 : item \"za\" has no index 2 remove it. list \\n10. The item having largest character at index  = i + 2 are :  new_list = [zaba]\\n10.   Here only one substring zaba is largest at index i + 2 : hence we get our answer\\n\\n```\n```\\nInstead of storing the whole substring it is preferable to store the starting index in list\\n\\nLast optimization\\n1. When list = [a,a,a,a] \\n2. we will get list =[0,1,2,3]\\n3. gap = 1 : \\n\\t\\tnew_list = [] , largest_character at index = i + 1  is a \\n\\t\\titem at  list[0] : will be added to\\n\\t\\titem at  list[1]: The character matches largest_character at gap = 1\\n\\t\\tsince list[0] + 1 == 1( which is list[1] ) means the part is repeated i.e\\n\\t\\tsay s = \"baabaab\"\\n\\t\\tso here \"baa_ _ _ _\" and \"_ _ _ baa _ \" are same so in every case\\n\\t\\t\"baabaab\" will be larger than \"baab\" \\n\\t\\tsame will happen for item at list[2],list[3]\\n\\t\\t\\n\\t\\tHence instead of going o(n*n) we do o(n) \\n\\t\\t\\n\\t\\n\\t\\t\\n```\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        n = len(s)\\n        cmax = max(s)\\n        indexes = [ i for i,c in enumerate(s) if c == cmax ]\\n        gap = 1\\n        while len(indexes) > 1:\\n            new_indexes = []\\n            cmax = max(s[i+gap] for i in indexes if i+gap < n)\\n            for i,st in enumerate(indexes):\\n                if i > 0 and indexes[i-1] + gap == st: continue\\n                if st + gap < n and s[st + gap] == cmax:new_indexes.append(st)\\n            indexes = new_indexes\\n            gap += 1\\n        return s[indexes[0]:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1872438,
                "title": "c-simple-easy-solution-with-explanation",
                "content": "**Approach**\\ntraverse from left to right\\nkeep track of the index of the max character found **max_ind**\\n3 cases:\\n1-- if we get a charcter which is greater than max character found so far\\nthen update the max_ind with i  **max_ind=i**\\n2-- if we get a character which is same as the max character found \\nthen again 2 cases for this case:\\na--if the max character found earlier was at last index,then \\nwe update the max_ind with i ,,since it will be of greater length**max_ind =i**\\nb-- else we will traverse to the right of both the indexes by comparing their respective characters (*as long as we don\\'t get a mismatch*) and *(we dont go out of bounds)* and *(we dont reach the maxind form i)*\\nwhen we get a mismatch we check,\\nif the character from s[i+j] >= s[max_ind+j] or (We went out of bounds) then we assign i as max_ind  **max_ind =i**\\ncoz if we go out of bounds,it means that both strings are equals and thus we go for i(for gretaer length)\\nand if i+jth char is greater then it is lexicographically gretaer and we still go for it\\n\\nfinally we return the substring form max_ind th character as ans\\n\\n\\n**CODE**\\n\\n```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int n =s.length();\\n        int max_ind=n-1;\\n        int i=n-2;\\n        while(i>=0)\\n        {\\n            if(s[i]>s[max_ind])\\n                max_ind=i;\\n            else if(s[i]==s[max_ind])\\n            {\\n                if(max_ind==n-1)\\n                {\\n                    max_ind=i;\\n                }\\n                else\\n                {\\n                    int j=1;\\n                    while((max_ind+j)<n && s[i+j]==s[max_ind+j] && (i+j)!=max_ind) j++;\\n                    if(s[i+j]>=s[max_ind+j] || (max_ind+j)>=n)\\n                        max_ind=i;\\n                }\\n            }\\n            i--;\\n        }\\n        return s.substr(max_ind);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int n =s.length();\\n        int max_ind=n-1;\\n        int i=n-2;\\n        while(i>=0)\\n        {\\n            if(s[i]>s[max_ind])\\n                max_ind=i;\\n            else if(s[i]==s[max_ind])\\n            {\\n                if(max_ind==n-1)\\n                {\\n                    max_ind=i;\\n                }\\n                else\\n                {\\n                    int j=1;\\n                    while((max_ind+j)<n && s[i+j]==s[max_ind+j] && (i+j)!=max_ind) j++;\\n                    if(s[i+j]>=s[max_ind+j] || (max_ind+j)>=n)\\n                        max_ind=i;\\n                }\\n            }\\n            i--;\\n        }\\n        return s.substr(max_ind);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787913,
                "title": "simple-explanation-beat-60-o-n",
                "content": "class Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        \\n        \\n        \\n        \\n        m=max(s)\\n        \\n        \\n        a=\"\"\\n        b=\"\"\\n        \\n        ans=\"\"\\n        \\n        stack=\"\"\\n        \\n        x=0\\n        while x <len(s):\\n            \\n            char=s[x]\\n            # start a new substring\\n            # or continue\\n            if char==m:\\n                if stack:\\n                    # do we continue or start new\\n                    j=x\\n                    i=0\\n                    while stack and j<len(s) and i<len(stack) and stack[i]==s[j]:\\n                        i+=1\\n                        j+=1\\n             \\n                    if j<len(s) and i <len(stack) and stack[i]<s[j]:\\n                        # start new because we found bigger letter\\n                        # abc abz,  z > c \\n                        stack=s[x:j+1]\\n                        x=j\\n                    else:\\n                        # continue because not bigger than previous substring\\n                        # dont include j because it coulbe a new starting point\\n                        stack+=s[x:j]\\n                        x=j-1\\n                else:\\n                    stack+=char\\n            \\n            else:\\n                if stack:\\n                    stack+=char\\n            x+=1\\n            \\n            \\n        return stack\\n                \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        \\n        \\n        \\n        \\n        m=max(s)\\n        \\n        \\n        a=\"\"\\n        b=\"\"\\n        \\n        ans=\"\"\\n        \\n        stack=\"\"\\n        \\n        x=0\\n        while x <len(s):\\n            \\n            char=s[x]\\n            # start a new substring\\n            # or continue\\n            if char==m:\\n                if stack:\\n                    # do we continue or start new\\n                    j=x\\n                    i=0\\n                    while stack and j<len(s) and i<len(stack) and stack[i]==s[j]:\\n                        i+=1\\n                        j+=1\\n             \\n                    if j<len(s) and i <len(stack) and stack[i]<s[j]:\\n                        # start new because we found bigger letter\\n                        # abc abz,  z > c \\n                        stack=s[x:j+1]\\n                        x=j\\n                    else:\\n                        # continue because not bigger than previous substring\\n                        # dont include j because it coulbe a new starting point\\n                        stack+=s[x:j]\\n                        x=j-1\\n                else:\\n                    stack+=char\\n            \\n            else:\\n                if stack:\\n                    stack+=char\\n            x+=1\\n            \\n            \\n        return stack\\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 1549342,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    \\n\\tpublic String lastSubstring(String s) {\\n        int maxIndex = s.length() - 1;\\n        \\n        for(int currIndex = s.length() - 1 ; currIndex >= 0 ; currIndex--){\\n            if(s.charAt(currIndex) > s.charAt(maxIndex))\\n                maxIndex = currIndex;\\n                \\n            else if(s.charAt(currIndex) == s.charAt(maxIndex)){\\n                int i = currIndex + 1;\\n                int j = maxIndex + 1;\\n                \\n                \\n                while(i < maxIndex && j < s.length() && s.charAt(i) == s.charAt(j)){\\n                    i++;\\n                    j++;\\n                }\\n                \\n                if(i == maxIndex || j == s.length() || s.charAt(i) > s.charAt(j))\\n                    maxIndex = currIndex;\\n            }\\n        }\\n        \\n        return s.substring(maxIndex);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Suffix Array"
                ],
                "code": "class Solution {\\n    \\n\\tpublic String lastSubstring(String s) {\\n        int maxIndex = s.length() - 1;\\n        \\n        for(int currIndex = s.length() - 1 ; currIndex >= 0 ; currIndex--){\\n            if(s.charAt(currIndex) > s.charAt(maxIndex))\\n                maxIndex = currIndex;\\n                \\n            else if(s.charAt(currIndex) == s.charAt(maxIndex)){\\n                int i = currIndex + 1;\\n                int j = maxIndex + 1;\\n                \\n                \\n                while(i < maxIndex && j < s.length() && s.charAt(i) == s.charAt(j)){\\n                    i++;\\n                    j++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1432562,
                "title": "c-two-pointers",
                "content": "```\\n\\n```public:\\n    string lastSubstring(string s) {\\n        string temp=s;\\n        sort(temp.begin(),temp.end());\\n        char ch=temp.back();\\n        int ans=s.find(ch);\\n        for(int i=ans+1;i<s.length();i++)\\n        {\\n            if(s[i]==ch)\\n            {\\n              int  j=1;\\n                while(ans+j<i&&s[i+j]==s[ans+j])\\n                {\\n                    j++;\\n                }\\n                if(s[i+j]>s[ans+j])\\n                {\\n                    ans=i;\\n                }\\n                    i=i+j-1;\\n            }\\n        }\\n        return s.substr(ans);\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1427550,
                "title": "python-117-ms-faster-than-100",
                "content": "This approach examines potential prefixes to the solution.\\nUpdate: This approach fails for certain test cases excluded from the grader.\\n\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        # Figure out prefix of the ans: x * repeat\\n        x = max(set(s))\\n        \\n        # Find repeat using binary search\\n        low = 1\\n        high = len(s)\\n        mid = (high + low) // 2\\n        \\n        while low < mid:\\n            if x * mid in s:\\n                low = mid\\n            else:\\n                high = mid\\n            mid = (high + low) // 2\\n\\n        if x * high in s:\\n            repeat = high\\n        else:\\n            repeat = low\\n        \\n        # Check for a greater prefix\\n        def greaterPrefix(prefix, s):\\n            x = prefix[0]\\n            s = s[s.index(prefix):]\\n\\n            if len(prefix) == len(s):\\n                return prefix\\n            elif len(prefix) > len(s):\\n                return print(\\'Error: Prefix longer than string.\\')\\n            else:\\n                y = s[len(prefix)]\\n\\n            greater = [a for a in string.ascii_lowercase if a > y and a != x][::-1]\\n            for z in greater:\\n                if prefix + z in s:\\n                    return prefix + z\\n                else:\\n                    continue\\n            if prefix * 2 in s:\\n                return prefix * 2\\n            else:\\n                return prefix\\n\\n        prefix = x * repeat\\n        while prefix != greaterPrefix(prefix, s):\\n            prefix = greaterPrefix(prefix, s)\\n\\n        return s[s.index(prefix):]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        # Figure out prefix of the ans: x * repeat\\n        x = max(set(s))\\n        \\n        # Find repeat using binary search\\n        low = 1\\n        high = len(s)\\n        mid = (high + low) // 2\\n        \\n        while low < mid:\\n            if x * mid in s:\\n                low = mid\\n            else:\\n                high = mid\\n            mid = (high + low) // 2\\n\\n        if x * high in s:\\n            repeat = high\\n        else:\\n            repeat = low\\n        \\n        # Check for a greater prefix\\n        def greaterPrefix(prefix, s):\\n            x = prefix[0]\\n            s = s[s.index(prefix):]\\n\\n            if len(prefix) == len(s):\\n                return prefix\\n            elif len(prefix) > len(s):\\n                return print(\\'Error: Prefix longer than string.\\')\\n            else:\\n                y = s[len(prefix)]\\n\\n            greater = [a for a in string.ascii_lowercase if a > y and a != x][::-1]\\n            for z in greater:\\n                if prefix + z in s:\\n                    return prefix + z\\n                else:\\n                    continue\\n            if prefix * 2 in s:\\n                return prefix * 2\\n            else:\\n                return prefix\\n\\n        prefix = x * repeat\\n        while prefix != greaterPrefix(prefix, s):\\n            prefix = greaterPrefix(prefix, s)\\n\\n        return s[s.index(prefix):]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081371,
                "title": "python3-brute-force",
                "content": "Surprisingly, brute-force solution `O(N^2)` passes all test cases for Python3. \\n\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        return max(s[i:] for i in range(len(s)))\\n```\\n\\nI learned this `O(N)` solution from @nate17 in this [post](https://leetcode.com/problems/last-substring-in-lexicographical-order/discuss/363662/Short-python-code-O(n)-time-and-O(1)-space-with-proof-and-visualization). Credit goes to original author. \\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        ii = k = 0\\n        i = 1\\n        while i + k < len(s):\\n            if s[ii+k] == s[i+k]: k += 1\\n            else: \\n                if s[ii+k] > s[i+k]: i += k+1\\n                else: \\n                    ii = max(ii+k+1, i)\\n                    i = ii+1\\n                k = 0\\n        return s[ii:]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        return max(s[i:] for i in range(len(s)))\\n```\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        ii = k = 0\\n        i = 1\\n        while i + k < len(s):\\n            if s[ii+k] == s[i+k]: k += 1\\n            else: \\n                if s[ii+k] > s[i+k]: i += k+1\\n                else: \\n                    ii = max(ii+k+1, i)\\n                    i = ii+1\\n                k = 0\\n        return s[ii:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027880,
                "title": "java-solution-with-explanation",
                "content": "\\n**Brute force**\\n\\ngenerate all substring  and compare => (O(n2) )\\n\\n**Important observations**\\n\\n\\t1) in lexicographical order the smaller string is always considered shorter\\n\\t2) This means that suppose if we have a solution substring \\n\\t\\ts.substring(i , j) \\n\\t\\t\\tas largest substring  then we can always find a better solution by increasing its length to the end\\n\\t\\t i.e s.substring(i, n) is the better solution\\n\\t\\t From this we conclued the all possible solution are just suffixes \\n\\t3) Now to generate suffix is just O(n)  and we can compare all the suffixes\\n\\t4) Optimisation 1 \\n\\t\\ta. Find the character which is highest in string - say Z\\n\\t\\tb. Only compare the suffixes that start with Z\\n\\t5) Optimisation 2\\n\\t\\ta. If prev and curr character are same , skip this because of length\\n\\t\\t\\te.g. bbxya  >  bxya \\n\\n\\n```java\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        \\n    \\n        //find biggest character    \\n         int max = s.charAt(0);           \\n         for(char c: s.toCharArray()){\\n             max = c > max ? c : max;\\n         }\\n       \\n        String res = s.substring(0);\\n        \\n        for(int i = 0 ; i< s.length(); i++){\\n        \\n            //skip if pre character is same\\n            if(i>0){\\n                if (s.charAt(i) == s.charAt(i-1)){\\n                    continue;\\n                }\\n            }\\n            \\n            //check if suffix starts with max charcter\\n            if(s.charAt(i)==max){\\n                String curr = s.substring(i);\\n                \\n                if(curr.compareTo(res)>0){\\n                    res = curr;\\n                }\\n            }     \\n        }    \\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        \\n    \\n        //find biggest character    \\n         int max = s.charAt(0);           \\n         for(char c: s.toCharArray()){\\n             max = c > max ? c : max;\\n         }\\n       \\n        String res = s.substring(0);\\n        \\n        for(int i = 0 ; i< s.length(); i++){\\n        \\n            //skip if pre character is same\\n            if(i>0){\\n                if (s.charAt(i) == s.charAt(i-1)){\\n                    continue;\\n                }\\n            }\\n            \\n            //check if suffix starts with max charcter\\n            if(s.charAt(i)==max){\\n                String curr = s.substring(i);\\n                \\n                if(curr.compareTo(res)>0){\\n                    res = curr;\\n                }\\n            }     \\n        }    \\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 905440,
                "title": "c-brute-force-44ms-two-pointers-solutions-24ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        // [1] Find maximum character\\n        char maxChar = \\'a\\';\\n        for (int i = 0; i < s.size(); i++) { \\n            maxChar = max(maxChar, s[i]);\\n        }\\n        \\n        // [2] Reverse compare because of \"aaaaaaaaaa...aaaa\" case\\n        int cidx = -1;\\n        for (int i = s.size()-1; i >= 0; i--) { \\n            if (s[i] == maxChar) {\\n                if (cidx==-1) cidx = i;\\n                else if (bigger(s, i, cidx)) cidx = i;\\n            }\\n        }\\n        return s.substr(cidx, s.size()-cidx);\\n    }\\n    \\n    // [3] Incremental compare\\n    bool bigger(string& s, int a, int b) {\\n        int c = b;\\n        while (a < c && b < s.size()) {\\n            if (s[a] == s[b]) {\\n                a++;\\n                b++;\\n            } else break;\\n        }\\n        if (a==c) return true;\\n        else if (b==s.size()) return true;\\n        return s[a] >= s[b];\\n    }\\n};\\n```\\n\\n```\\n    string lastSubstring(string s) {\\n        int res = 0, i = 0, n = s.size();\\n        while (i < n) {\\n            if (s[res] > s[i]) i++;\\n            else if (s[res] < s[i]) res = i++;\\n            else {\\n                int k = 1;\\n                while (res+k < i) {\\n                    if (s[res+k] > s[i+k]) {\\n                        break;\\n                    } else if (s[res+k] < s[i+k]) {\\n                        res = i; break;\\n                    } else k++;\\n                }\\n                i += k;\\n            }\\n        }\\n        return s.substr(res, s.size()-res);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        // [1] Find maximum character\\n        char maxChar = \\'a\\';\\n        for (int i = 0; i < s.size(); i++) { \\n            maxChar = max(maxChar, s[i]);\\n        }\\n        \\n        // [2] Reverse compare because of \"aaaaaaaaaa...aaaa\" case\\n        int cidx = -1;\\n        for (int i = s.size()-1; i >= 0; i--) { \\n            if (s[i] == maxChar) {\\n                if (cidx==-1) cidx = i;\\n                else if (bigger(s, i, cidx)) cidx = i;\\n            }\\n        }\\n        return s.substr(cidx, s.size()-cidx);\\n    }\\n    \\n    // [3] Incremental compare\\n    bool bigger(string& s, int a, int b) {\\n        int c = b;\\n        while (a < c && b < s.size()) {\\n            if (s[a] == s[b]) {\\n                a++;\\n                b++;\\n            } else break;\\n        }\\n        if (a==c) return true;\\n        else if (b==s.size()) return true;\\n        return s[a] >= s[b];\\n    }\\n};\\n```\n```\\n    string lastSubstring(string s) {\\n        int res = 0, i = 0, n = s.size();\\n        while (i < n) {\\n            if (s[res] > s[i]) i++;\\n            else if (s[res] < s[i]) res = i++;\\n            else {\\n                int k = 1;\\n                while (res+k < i) {\\n                    if (s[res+k] > s[i+k]) {\\n                        break;\\n                    } else if (s[res+k] < s[i+k]) {\\n                        res = i; break;\\n                    } else k++;\\n                }\\n                i += k;\\n            }\\n        }\\n        return s.substr(res, s.size()-res);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 904302,
                "title": "java-faster-than-86-with-explanation",
                "content": "```java\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        int i=0, j=1, l = s.length(), offset = 0;\\n\\t\\t//i & j to point substring start & stop\\n\\t\\t//l - compute length outside of loop to avoid every loop iteration computing that\\n\\t\\t//offset - to determine the distance from start of string\\n        char c, d; //to hold i & j index characters\\n        while(i+offset<l && j+offset<l){ //To avoid loop execution beyond string length\\n            c = s.charAt(i+offset); \\n            d = s.charAt(j+offset);\\n            if(c==d){\\n                offset++;\\n            }else{\\n\\t\\t\\t   //if stop(j) is greater increment start(i) \\n                if(c<d){\\n                    i+=offset+1;\\n                }else{\\n\\t\\t\\t\\t//if start (i) is greater then increment the stop (j)\\n                    j+=offset+1;\\n                }\\n\\t\\t\\t\\tIf both start & stop is same, increment stop to avoid repeated check\\n                if(i==j) j++;\\n                offset=0;\\n            }\\n        }\\n        return s.substring(i);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        int i=0, j=1, l = s.length(), offset = 0;\\n\\t\\t//i & j to point substring start & stop\\n\\t\\t//l - compute length outside of loop to avoid every loop iteration computing that\\n\\t\\t//offset - to determine the distance from start of string\\n        char c, d; //to hold i & j index characters\\n        while(i+offset<l && j+offset<l){ //To avoid loop execution beyond string length\\n            c = s.charAt(i+offset); \\n            d = s.charAt(j+offset);\\n            if(c==d){\\n                offset++;\\n            }else{\\n\\t\\t\\t   //if stop(j) is greater increment start(i) \\n                if(c<d){\\n                    i+=offset+1;\\n                }else{\\n\\t\\t\\t\\t//if start (i) is greater then increment the stop (j)\\n                    j+=offset+1;\\n                }\\n\\t\\t\\t\\tIf both start & stop is same, increment stop to avoid repeated check\\n                if(i==j) j++;\\n                offset=0;\\n            }\\n        }\\n        return s.substring(i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846540,
                "title": "java",
                "content": "```\\npublic String lastSubstring(String s) {\\n\\tint length = s.length();\\n\\tList<Integer> starts = new ArrayList<>();\\n\\tfor (int i = 0; i < length; i++) {\\n\\t\\tstarts.add(i);\\n\\t}\\n\\n\\tint offset = 0;\\n\\twhile (starts.size() > 1) {\\n\\t\\tchar maxChar = \\'a\\';\\n\\t\\tfor (int start : starts) {\\n\\t\\t\\tif (start + offset < length && s.charAt(start + offset) > maxChar) {\\n\\t\\t\\t\\tmaxChar = s.charAt(start + offset);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tList<Integer> newStarts = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < starts.size(); i++) {\\n\\t\\t\\tint start = starts.get(i);\\n\\t\\t\\tif (i > 1 && starts.get(i - 1) + offset == start) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (start + offset < length && s.charAt(start + offset) == maxChar) {\\n\\t\\t\\t\\tnewStarts.add(start);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\toffset++;\\n\\t\\tstarts = newStarts;\\n\\t}\\n\\n\\treturn s.substring(starts.get(0));\\n}\\n```\\n\\nProof at: https://leetcode.com/problems/last-substring-in-lexicographical-order/discuss/363662/Short-python-code-O(n)-time-and-O(1)-space-with-proof-and-visualization\\n```\\npublic String lastSubstring(String s) {\\n\\tint length = s.length();\\n\\tint slow = 0, fast = 1, offset = 0;\\n\\n\\twhile (fast + offset < length) {\\n\\t\\tif (s.charAt(slow + offset) == s.charAt(fast + offset)) {\\n\\t\\t\\toffset++;\\n\\t\\t\\tcontinue;\\n\\t\\t} else if (s.charAt(slow + offset) > s.charAt(fast + offset)) {\\n\\t\\t\\tfast = fast + offset + 1;\\n\\t\\t} else {\\n\\t\\t\\tslow = Math.max(slow + offset + 1, fast);\\n\\t\\t\\tfast = slow + 1;\\n\\t\\t}\\n\\t\\toffset = 0;\\n\\t}\\n\\n\\treturn s.substring(slow);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String lastSubstring(String s) {\\n\\tint length = s.length();\\n\\tList<Integer> starts = new ArrayList<>();\\n\\tfor (int i = 0; i < length; i++) {\\n\\t\\tstarts.add(i);\\n\\t}\\n\\n\\tint offset = 0;\\n\\twhile (starts.size() > 1) {\\n\\t\\tchar maxChar = \\'a\\';\\n\\t\\tfor (int start : starts) {\\n\\t\\t\\tif (start + offset < length && s.charAt(start + offset) > maxChar) {\\n\\t\\t\\t\\tmaxChar = s.charAt(start + offset);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tList<Integer> newStarts = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < starts.size(); i++) {\\n\\t\\t\\tint start = starts.get(i);\\n\\t\\t\\tif (i > 1 && starts.get(i - 1) + offset == start) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (start + offset < length && s.charAt(start + offset) == maxChar) {\\n\\t\\t\\t\\tnewStarts.add(start);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\toffset++;\\n\\t\\tstarts = newStarts;\\n\\t}\\n\\n\\treturn s.substring(starts.get(0));\\n}\\n```\n```\\npublic String lastSubstring(String s) {\\n\\tint length = s.length();\\n\\tint slow = 0, fast = 1, offset = 0;\\n\\n\\twhile (fast + offset < length) {\\n\\t\\tif (s.charAt(slow + offset) == s.charAt(fast + offset)) {\\n\\t\\t\\toffset++;\\n\\t\\t\\tcontinue;\\n\\t\\t} else if (s.charAt(slow + offset) > s.charAt(fast + offset)) {\\n\\t\\t\\tfast = fast + offset + 1;\\n\\t\\t} else {\\n\\t\\t\\tslow = Math.max(slow + offset + 1, fast);\\n\\t\\t\\tfast = slow + 1;\\n\\t\\t}\\n\\t\\toffset = 0;\\n\\t}\\n\\n\\treturn s.substring(slow);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 822722,
                "title": "easy-to-understand-java-solution",
                "content": "```\\nclass Solution {\\n    public String lastSubstring(String s) {\\n       int n=s.length();\\n        char highest=s.charAt(0);\\n        String res=\"\";\\n        String temp=\"\";\\n        int i=0;\\n        while(i<s.length()){\\n            if(s.charAt(i)>=highest){\\n               temp=s.substring(i);\\n               if(temp.compareTo(res)>0){\\n                   res=temp;\\n                   highest=res.charAt(0);\\n               }\\n            }\\n            i++;\\n            while(i<s.length() && s.charAt(i)==s.charAt(i-1)){  // while the next character is same as the current character we increment i.\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\nTC : O(n^2) because of the use of one outer loop and substring method.\\nSC: O(1)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String lastSubstring(String s) {\\n       int n=s.length();\\n        char highest=s.charAt(0);\\n        String res=\"\";\\n        String temp=\"\";\\n        int i=0;\\n        while(i<s.length()){\\n            if(s.charAt(i)>=highest){\\n               temp=s.substring(i);\\n               if(temp.compareTo(res)>0){\\n                   res=temp;\\n                   highest=res.charAt(0);\\n               }\\n            }\\n            i++;\\n            while(i<s.length() && s.charAt(i)==s.charAt(i-1)){  // while the next character is same as the current character we increment i.\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 789612,
                "title": "cpp14-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n    int n = s.length() ;\\n    int i = 0 , j = 1 , k = 0 ;\\n    vector<int> index;\\n    char largest = s[0]; \\n        for(int i = 1 ; i < n ; ++i){\\n            if(s[i] > largest){\\n                largest = s[i] ; \\n            }\\n        }\\n        for(int i = 0 ; i < n ; ++i){\\n            if(s[i] == largest){\\n                index.push_back(i) ; \\n            }\\n        }\\n        if(index.size() == 1){\\n            string res= \"\" ;\\n            for(int i = index[0] ; i < n ; ++i) res+=s[i]; \\n            return res; \\n        }\\n        i = index[0] ; \\n        j = index[1] ; \\n        \\n        \\n    while(1){\\n        if(i + k >= n or j + k >= n) break;\\n        if(s[i+k] == s[j+k]) ++k ;\\n        else if(s[i+k] < s[j+k]){\\n            i = j;\\n            ++j;\\n            k = 0;\\n        }\\n        else if(s[i+k] > s[j+k]){\\n            j = j + k + 1 ;\\n            k = 0 ;\\n        }\\n    }\\n    string res=  \"\";\\n    for(int a = i ; a < n ; ++a){\\n        res+=s[a];\\n    }\\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n    int n = s.length() ;\\n    int i = 0 , j = 1 , k = 0 ;\\n    vector<int> index;\\n    char largest = s[0]; \\n        for(int i = 1 ; i < n ; ++i){\\n            if(s[i] > largest){\\n                largest = s[i] ; \\n            }\\n        }\\n        for(int i = 0 ; i < n ; ++i){\\n            if(s[i] == largest){\\n                index.push_back(i) ; \\n            }\\n        }\\n        if(index.size() == 1){\\n            string res= \"\" ;\\n            for(int i = index[0] ; i < n ; ++i) res+=s[i]; \\n            return res; \\n        }\\n        i = index[0] ; \\n        j = index[1] ; \\n        \\n        \\n    while(1){\\n        if(i + k >= n or j + k >= n) break;\\n        if(s[i+k] == s[j+k]) ++k ;\\n        else if(s[i+k] < s[j+k]){\\n            i = j;\\n            ++j;\\n            k = 0;\\n        }\\n        else if(s[i+k] > s[j+k]){\\n            j = j + k + 1 ;\\n            k = 0 ;\\n        }\\n    }\\n    string res=  \"\";\\n    for(int a = i ; a < n ; ++a){\\n        res+=s[a];\\n    }\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774326,
                "title": "sufix-array-gives-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        s += \"$\";\\n        int n = s.length();\\n        vector<int> suf(n), c(n);\\n        {\\n            vector<pair<char, int>> a(n);\\n            for (int i = 0; i < n; ++i) {\\n                a[i] = {s[i], i};\\n            }\\n            sort(a.begin(), a.end());\\n            for (int i = 0; i < n; ++i) {\\n                suf[i] = a[i].second;\\n            }\\n            c[suf[0]] = 0;\\n            for (int i = 1; i < n; ++i) {\\n                if (a[i].first == a[i - 1].first) {\\n                    c[suf[i]] = c[suf[i - 1]];\\n                }\\n                else {\\n                    c[suf[i]] = c[suf[i - 1]] + 1;;   \\n                }\\n            }\\n        }\\n        long long k = 0;\\n        vector<pair<pair<int, int>, int>> a(n);\\n        while ((1 << k) < n) {\\n            \\n            for (int i = 0; i < n; ++i) {\\n                a[i] = {{c[i], c[(i + (1 << k)) % n]}, i};\\n                \\n            }\\n            sort(a.begin(), a.end());\\n            for (int i = 0; i < n; ++i) {\\n                suf[i] = a[i].second;\\n            }\\n            c[suf[0]] = 0;\\n            for (int i = 1; i < n; ++i) {\\n                if (a[i].first == a[i - 1].first) {\\n                    c[suf[i]] = c[suf[i - 1]];\\n                }\\n                else {\\n                    c[suf[i]] = c[suf[i - 1]] + 1;;   \\n                }\\n            }\\n            ++k;\\n        }\\n        int pos = suf.back();\\n        return s.substr(pos , n - pos - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        s += \"$\";\\n        int n = s.length();\\n        vector<int> suf(n), c(n);\\n        {\\n            vector<pair<char, int>> a(n);\\n            for (int i = 0; i < n; ++i) {\\n                a[i] = {s[i], i};\\n            }\\n            sort(a.begin(), a.end());\\n            for (int i = 0; i < n; ++i) {\\n                suf[i] = a[i].second;\\n            }\\n            c[suf[0]] = 0;\\n            for (int i = 1; i < n; ++i) {\\n                if (a[i].first == a[i - 1].first) {\\n                    c[suf[i]] = c[suf[i - 1]];\\n                }\\n                else {\\n                    c[suf[i]] = c[suf[i - 1]] + 1;;   \\n                }\\n            }\\n        }\\n        long long k = 0;\\n        vector<pair<pair<int, int>, int>> a(n);\\n        while ((1 << k) < n) {\\n            \\n            for (int i = 0; i < n; ++i) {\\n                a[i] = {{c[i], c[(i + (1 << k)) % n]}, i};\\n                \\n            }\\n            sort(a.begin(), a.end());\\n            for (int i = 0; i < n; ++i) {\\n                suf[i] = a[i].second;\\n            }\\n            c[suf[0]] = 0;\\n            for (int i = 1; i < n; ++i) {\\n                if (a[i].first == a[i - 1].first) {\\n                    c[suf[i]] = c[suf[i - 1]];\\n                }\\n                else {\\n                    c[suf[i]] = c[suf[i - 1]] + 1;;   \\n                }\\n            }\\n            ++k;\\n        }\\n        int pos = suf.back();\\n        return s.substr(pos , n - pos - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772481,
                "title": "a-different-approach-using-bfs-o-n-and-o-nlogn-solution",
                "content": "unordered_set made this accepted. Using set all test cases passed but took long time.\\nAlthough this approach is not useful in this question as we have a O(n) solution but this new approach may be helpful somewhere else :D . Time complexity in worse case as we are using unordered_set can go to O(n^2), in that case using ordered set will help with O(nlogn) complexity.\\n```\\nclass Solution {\\npublic:\\n    #define mp make_pair\\n    #define fi first\\n    #define se second\\n    #define pb push_back\\n    string lastSubstring(string s) {\\n        queue<pair<int,int> > q;\\n        int n=s.length();\\n        int maxi=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            maxi=max(maxi,(int)s[i]);\\n        }\\n        int lev_max[s.length()];\\n        memset(lev_max,0,sizeof(lev_max));\\n        unordered_set<int> par[s.length()];\\n        int vis[s.length()];\\n        memset(vis,0,sizeof(vis));\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==maxi)\\n            {\\n                q.push(mp(i,0));\\n                vis[i]=0;\\n            }\\n        }\\n        int maxx=0;\\n        while(!q.empty())\\n        {\\n            int ver = q.front().fi;\\n            int lev = q.front().se;\\n            q.pop();\\n            if(lev!=0&&par[lev-1].find(ver-1)==par[lev-1].end())\\n            {\\n                continue;\\n            }\\n            if(vis[ver-lev]>1)\\n                continue;\\n            vis[ver]++;\\n            if(lev_max[lev]<(int)s[ver])\\n            {\\n                par[lev].clear();\\n                par[lev].insert(ver);\\n                lev_max[lev]=s[ver];\\n            }\\n            else if(lev_max[lev]==(int)s[ver])\\n                par[lev].insert(ver);\\n            else if(lev_max[lev]>(int)s[ver])\\n                continue;\\n            maxx=max(maxx,lev);\\n            if(ver+1<s.size())\\n                q.push(mp(ver+1,lev+1));\\n        }\\n        \\n        string ans;\\n        int idx=(*par[maxx].begin());\\n        while(maxx>=0)\\n        {\\n            ans.pb(s[idx]);\\n            maxx--;\\n            idx--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define mp make_pair\\n    #define fi first\\n    #define se second\\n    #define pb push_back\\n    string lastSubstring(string s) {\\n        queue<pair<int,int> > q;\\n        int n=s.length();\\n        int maxi=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            maxi=max(maxi,(int)s[i]);\\n        }\\n        int lev_max[s.length()];\\n        memset(lev_max,0,sizeof(lev_max));\\n        unordered_set<int> par[s.length()];\\n        int vis[s.length()];\\n        memset(vis,0,sizeof(vis));\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==maxi)\\n            {\\n                q.push(mp(i,0));\\n                vis[i]=0;\\n            }\\n        }\\n        int maxx=0;\\n        while(!q.empty())\\n        {\\n            int ver = q.front().fi;\\n            int lev = q.front().se;\\n            q.pop();\\n            if(lev!=0&&par[lev-1].find(ver-1)==par[lev-1].end())\\n            {\\n                continue;\\n            }\\n            if(vis[ver-lev]>1)\\n                continue;\\n            vis[ver]++;\\n            if(lev_max[lev]<(int)s[ver])\\n            {\\n                par[lev].clear();\\n                par[lev].insert(ver);\\n                lev_max[lev]=s[ver];\\n            }\\n            else if(lev_max[lev]==(int)s[ver])\\n                par[lev].insert(ver);\\n            else if(lev_max[lev]>(int)s[ver])\\n                continue;\\n            maxx=max(maxx,lev);\\n            if(ver+1<s.size())\\n                q.push(mp(ver+1,lev+1));\\n        }\\n        \\n        string ans;\\n        int idx=(*par[maxx].begin());\\n        while(maxx>=0)\\n        {\\n            ans.pb(s[idx]);\\n            maxx--;\\n            idx--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763575,
                "title": "ruby-beat-100",
                "content": "1. Find the **biggest char**;\\n2. Find all **indexes** of the biggest char;\\n3. Use the **offset** to compare all indexes\\'s next offset char;\\n4. Use a stack to save all indexes whose offset char is same;\\n5. When a index\\'s offset char is bigger, clear the stack;\\n\\n```\\ndef last_substring(s)\\n  chars = s.chars.uniq.sort\\n  return s if chars.size == 1\\n  char = chars.last\\n  indexes = []\\n  i = -1\\n  indexes << i while i = s.index(char, i+1)\\n\\n  offset = 1\\n  stack = []\\n  loop do\\n    indexes.each do |i|\\n      if stack.empty?\\n        stack << i\\n      elsif s[i+offset].nil? || s[i+offset] < s[stack[-1]+offset] || stack.bsearch { |j| j+offset >= i }\\n        next\\n      else\\n        stack = [] if stack.size > 0 && s[i+offset] > s[stack[-1]+offset]\\n        stack << i\\n      end\\n    end\\n    break if stack.size == 1\\n    offset += 1\\n    indexes = stack\\n    stack = []\\n  end\\n  s[stack[-1]..-1]\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef last_substring(s)\\n  chars = s.chars.uniq.sort\\n  return s if chars.size == 1\\n  char = chars.last\\n  indexes = []\\n  i = -1\\n  indexes << i while i = s.index(char, i+1)\\n\\n  offset = 1\\n  stack = []\\n  loop do\\n    indexes.each do |i|\\n      if stack.empty?\\n        stack << i\\n      elsif s[i+offset].nil? || s[i+offset] < s[stack[-1]+offset] || stack.bsearch { |j| j+offset >= i }\\n        next\\n      else\\n        stack = [] if stack.size > 0 && s[i+offset] > s[stack[-1]+offset]\\n        stack << i\\n      end\\n    end\\n    break if stack.size == 1\\n    offset += 1\\n    indexes = stack\\n    stack = []\\n  end\\n  s[stack[-1]..-1]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 722477,
                "title": "c-using-lexicographical-compare-and-string-view-90-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio(false); \\n        cin.tie(NULL);    \\n    }\\n    string lastSubstring(string_view s) {\\n        int max = INT_MIN,j=-1 ;\\n        string_view r,ans = \"\" ;\\n        int dist = 0 ;\\n        for (int i=1;i<s.size();i++){  //checking if all char in string are same.\\n            if (s[i]!=s[i-1]){\\n                dist++ ;\\n                break ;\\n            }\\n        }\\n        if (dist==0)return (string)s ;\\n        \\n        for (int i=0;i<s.size();i++){\\n            if (max<=s[i]){         // traverse string , find largest char and compare substring with result obtained so far\\n                max = s[i] ;\\n                if (lexicographical_compare(s.begin()+i,s.end(),ans.begin(),ans.end())==false) ans = s.substr(i,s.size()) ;\\n            }\\n        }\\n        return (string)ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio(false); \\n        cin.tie(NULL);    \\n    }\\n    string lastSubstring(string_view s) {\\n        int max = INT_MIN,j=-1 ;\\n        string_view r,ans = \"\" ;\\n        int dist = 0 ;\\n        for (int i=1;i<s.size();i++){  //checking if all char in string are same.\\n            if (s[i]!=s[i-1]){\\n                dist++ ;\\n                break ;\\n            }\\n        }\\n        if (dist==0)return (string)s ;\\n        \\n        for (int i=0;i<s.size();i++){\\n            if (max<=s[i]){         // traverse string , find largest char and compare substring with result obtained so far\\n                max = s[i] ;\\n                if (lexicographical_compare(s.begin()+i,s.end(),ans.begin(),ans.end())==false) ans = s.substr(i,s.size()) ;\\n            }\\n        }\\n        return (string)ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 668960,
                "title": "simple-java-solution-beats-99",
                "content": "the main idear is simple, since the answer will be always the suffix, we could starting our check from the tail. We use a pointer idx for the final answer break point and a pointer nidx search for bigger character. if the s[nidx] > s[idx], we update idx to nidx imidiately; if s[nidx] == s[idx], we start to compare the character after it use j and i until s[i] or s[j] is bigger / i hit the length / j hit the idx, then we update the idx. Checking finished when nidx hit 0. and we return s.substring(idx , s.length).  \\ntime complexity seems to beO(n) but I\\'m not ture...\\n```\\nclass Solution {\\n    public String lastSubstring(String sa) {\\n        char[] s = sa.toCharArray();\\n        int idx = s.length - 1;\\n        int nidx = s.length - 1;\\n        while(nidx >= 0){\\n            if(s[nidx] > s[idx]){\\n                idx = nidx;\\n            }else if(s[nidx] == s[idx]){\\n                int i = idx + 1;\\n                int j = nidx + 1;\\n                while(j < idx && i < s.length && s[i] == s[j]){\\n                    i++;\\n                    j++;\\n                }\\n                if(j == idx || i == s.length || s[j] > s[i])\\n                    idx = nidx;\\n            }\\n            nidx--;\\n        }\\n        return sa.substring(idx , sa.length());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String lastSubstring(String sa) {\\n        char[] s = sa.toCharArray();\\n        int idx = s.length - 1;\\n        int nidx = s.length - 1;\\n        while(nidx >= 0){\\n            if(s[nidx] > s[idx]){\\n                idx = nidx;\\n            }else if(s[nidx] == s[idx]){\\n                int i = idx + 1;\\n                int j = nidx + 1;\\n                while(j < idx && i < s.length && s[i] == s[j]){\\n                    i++;\\n                    j++;\\n                }\\n                if(j == idx || i == s.length || s[j] > s[i])\\n                    idx = nidx;\\n            }\\n            nidx--;\\n        }\\n        return sa.substring(idx , sa.length());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659024,
                "title": "must-be-joking-i-don-t-know-why-this-got-ac",
                "content": "Just used a simple brute force loop.. it got AC. I think this is not the right way to approach this question since it\\'s way too easy and too bruteforce\\n\\n    def lastSubstring(self, s: str) -> str:\\n        chars = \"abcdefghijklmnopqrstuvwxyz\"\\n        ans = \"\"\\n        for char in chars[::-1]:\\n            for i in range(len(s)):\\n                if s[i] == char: ans = max(ans, s[i:])\\n            if ans: return ans\\n        return ans",
                "solutionTags": [],
                "code": "Just used a simple brute force loop.. it got AC. I think this is not the right way to approach this question since it\\'s way too easy and too bruteforce\\n\\n    def lastSubstring(self, s: str) -> str:\\n        chars = \"abcdefghijklmnopqrstuvwxyz\"\\n        ans = \"\"\\n        for char in chars[::-1]:\\n            for i in range(len(s)):\\n                if s[i] == char: ans = max(ans, s[i:])\\n            if ans: return ans\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 646390,
                "title": "o-n-java-solution-with-explanation-and-proof",
                "content": "The below implementation is based on someone else\\'s smart algorithm. Not my original idea. I just forget his account name, and sorry for that. Time complexity is O(N).  The proof is tricky, let\\'s consider  i + j, this value is creased by one for each comparison in the inner While loop. As we know that the sum of i and j can\\'t be larger than twice the length of s.\\n\\nIn addition, there are two important Lemmas for this problem.\\n\\nLemma 1: If for some pair(i, j), we check which one is bigger by increasing k. At some point we have str.charAt(j+k) < str.charAt(i+k), then we can conclude that\\nfor all r belongs to [j, j+k], str.substring(r) can\\'t be the biggest substring.  The proof is easy: str.substring(i+(r-j)) is bigger than str.substring(r).\\n\\nLemma 2: For any pair(i, j), we can conclude that for any r belongs to (i, j)  excluding i and j, str.substring(r) can\\'t be the solution. Lemma 2 can be proved based on Lemma 1 and induction.\\n\\n```\\nclass Solution {\\n   public String lastSubstring(String s) {\\n       int n = s.length();\\n       int i=0, j=1;\\n       while (i < n && j < n) {\\n           int k = 0;\\n           while (i+k < n && j+k <n && s.charAt(i+k) == s.charAt(j+k)) {\\n               k++;\\n           }\\n           if (i+k >= n || j+k >= n) {  \\n               break; //based on Lemma 2, we can safely return here!\\n           }\\n           if (s.charAt(i+k) < s.charAt(j+k)) {\\n               i = Math.max(i + k + 1, j+1); //Based on Lemma 1 and Lemma 2, we move forward i or j.\\n           } else {\\n               j = Math.max(j + k + 1, i+1);\\n           }\\n       }\\n       return s.substring(Math.min(i, j));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public String lastSubstring(String s) {\\n       int n = s.length();\\n       int i=0, j=1;\\n       while (i < n && j < n) {\\n           int k = 0;\\n           while (i+k < n && j+k <n && s.charAt(i+k) == s.charAt(j+k)) {\\n               k++;\\n           }\\n           if (i+k >= n || j+k >= n) {  \\n               break; //based on Lemma 2, we can safely return here!\\n           }\\n           if (s.charAt(i+k) < s.charAt(j+k)) {\\n               i = Math.max(i + k + 1, j+1); //Based on Lemma 1 and Lemma 2, we move forward i or j.\\n           } else {\\n               j = Math.max(j + k + 1, i+1);\\n           }\\n       }\\n       return s.substring(Math.min(i, j));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 643317,
                "title": "getting-tle-in-o-n",
                "content": "getting TLE in this \\n\"\\n string lastSubstring(string s) {\\n        string curr;\\n        string ans;\\n        for(int i=s.size()-1;i>=0;i--){\\n          string t; \\n            t=s[i];\\n            t.append(curr);\\n            curr=t;\\n          if(ans<curr)\\n              ans=curr;\\n        }\\n       return ans;\\n    }\\n\"",
                "solutionTags": [],
                "code": "getting TLE in this \\n\"\\n string lastSubstring(string s) {\\n        string curr;\\n        string ans;\\n        for(int i=s.size()-1;i>=0;i--){\\n          string t; \\n            t=s[i];\\n            t.append(curr);\\n            curr=t;\\n          if(ans<curr)\\n              ans=curr;\\n        }\\n       return ans;\\n    }\\n\"",
                "codeTag": "Unknown"
            },
            {
                "id": 611597,
                "title": "java-simple-sort-nlogn-without-any-fancy",
                "content": "Idea: \\n1. find the maximum character\\n 2. store all string that start with the max character, for exmaple, if we have \"zabzcdz\",\\n             we will store \"zab\",\"zcd\" and \"z\",  with their correspond start index [0,3,6] (what the Node class do)\\n3. sort them, the smallest string with the start index is where we start\\n            \\n```\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        StringBuilder str=new StringBuilder();\\n        boolean check=true;\\n        int start=0;\\n        List<Node>suffix=new ArrayList<>();\\n        int max=-1;\\n        char M=\\' \\';\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)-\\'a\\'>max){\\n                max=s.charAt(i)-\\'a\\';\\n                M=s.charAt(i);\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==M){\\n                start=i;\\n                break;\\n            }\\n        }\\n        for(int i=start;i<s.length();i++){\\n            if(s.charAt(i)==M){ //append new\\n                if(!check){\\n                    str.append(s.charAt(i)+\"\");\\n                    continue;\\n                }\\n                check=false;\\n                String ss=str.toString();\\n                if(ss.length()!=0)suffix.add(new Node(i-ss.length(),ss));\\n                str=new StringBuilder();\\n                str.append(s.charAt(i)+\"\");\\n            }else{\\n                check=true;\\n                str.append(s.charAt(i)+\"\");\\n            }\\n        }\\n        if(str.toString().length()!=0){\\n            String ss=str.toString();\\n            suffix.add(new Node(s.length()-ss.length(),ss));\\n        }\\n        Collections.sort(suffix,(n1,n2)->{\\n            return n2.ss.compareTo(n1.ss);\\n        });\\n        return s.substring(suffix.get(0).index);\\n    }\\n    \\n    class Node{\\n        int index;\\n        String ss;\\n        public Node(int index,String ss){\\n            this.index=index;\\n            this.ss=ss;\\n        }\\n        public String toString(){\\n            return this.ss;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        StringBuilder str=new StringBuilder();\\n        boolean check=true;\\n        int start=0;\\n        List<Node>suffix=new ArrayList<>();\\n        int max=-1;\\n        char M=\\' \\';\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)-\\'a\\'>max){\\n                max=s.charAt(i)-\\'a\\';\\n                M=s.charAt(i);\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==M){\\n                start=i;\\n                break;\\n            }\\n        }\\n        for(int i=start;i<s.length();i++){\\n            if(s.charAt(i)==M){ //append new\\n                if(!check){\\n                    str.append(s.charAt(i)+\"\");\\n                    continue;\\n                }\\n                check=false;\\n                String ss=str.toString();\\n                if(ss.length()!=0)suffix.add(new Node(i-ss.length(),ss));\\n                str=new StringBuilder();\\n                str.append(s.charAt(i)+\"\");\\n            }else{\\n                check=true;\\n                str.append(s.charAt(i)+\"\");\\n            }\\n        }\\n        if(str.toString().length()!=0){\\n            String ss=str.toString();\\n            suffix.add(new Node(s.length()-ss.length(),ss));\\n        }\\n        Collections.sort(suffix,(n1,n2)->{\\n            return n2.ss.compareTo(n1.ss);\\n        });\\n        return s.substring(suffix.get(0).index);\\n    }\\n    \\n    class Node{\\n        int index;\\n        String ss;\\n        public Node(int index,String ss){\\n            this.index=index;\\n            this.ss=ss;\\n        }\\n        public String toString(){\\n            return this.ss;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 579851,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String lastSubstring(String str) {\\n        String mx = \"\"; \\n        char cur = \\'a\\';\\n        for (int i = 0; i < str.length(); i++) { \\n            if (str.charAt(i) >= cur && mx.compareTo(str.substring(i)) <= 0) { \\n                cur = str.charAt(i);\\n                mx = str.substring(i);  \\n            } \\n            while(i != str.length() -1 && str.charAt(i) == str.charAt(i+1)) i++; \\n            //\\u8FD9\\u91CC\\u7684trick\\u662F\\uFF1A\\n            //\\u5982\\u679C\\u662Feea\\uFF0C\\u90A3\\u4E48eea\\u80AF\\u5B9A\\u5728ea\\u540E\\u9762\\n            //\\u5982\\u679C\\u662Feex\\uFF0C\\u90A3\\u4E48\\u7ED3\\u679C\\u80AF\\u5B9A\\u662Fx\\n        } \\n        return mx;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String lastSubstring(String str) {\\n        String mx = \"\"; \\n        char cur = \\'a\\';\\n        for (int i = 0; i < str.length(); i++) { \\n            if (str.charAt(i) >= cur && mx.compareTo(str.substring(i)) <= 0) { \\n                cur = str.charAt(i);\\n                mx = str.substring(i);  \\n            } \\n            while(i != str.length() -1 && str.charAt(i) == str.charAt(i+1)) i++; \\n            //\\u8FD9\\u91CC\\u7684trick\\u662F\\uFF1A\\n            //\\u5982\\u679C\\u662Feea\\uFF0C\\u90A3\\u4E48eea\\u80AF\\u5B9A\\u5728ea\\u540E\\u9762\\n            //\\u5982\\u679C\\u662Feex\\uFF0C\\u90A3\\u4E48\\u7ED3\\u679C\\u80AF\\u5B9A\\u662Fx\\n        } \\n        return mx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551693,
                "title": "monotonic-decreasing-sequence-python-simple-solution",
                "content": "```\\nclass Solution(object):\\n    def lastSubstring(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        ans = \\'\\'\\n        stack = []\\n        for i,c in enumerate(s):\\n            if not stack:\\n                stack.append(c)\\n                continue\\n            \\n            if c>stack[0]:\\n                stack = [c]\\n            elif c<stack[0]:\\n                stack.append(c)\\n            else:\\n                if stack[0]==stack[-1]:\\n                    stack.append(c)\\n                    continue\\n                temp = \\'\\'.join(stack)\\n                if ans<temp:\\n                    ans=temp\\n                else:\\n                    ans+=temp\\n                stack=[c]\\n        \\n        temp = \\'\\'.join(stack)\\n        if ans<temp:\\n            ans=temp\\n        else:\\n            ans+=temp\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def lastSubstring(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        ans = \\'\\'\\n        stack = []\\n        for i,c in enumerate(s):\\n            if not stack:\\n                stack.append(c)\\n                continue\\n            \\n            if c>stack[0]:\\n                stack = [c]\\n            elif c<stack[0]:\\n                stack.append(c)\\n            else:\\n                if stack[0]==stack[-1]:\\n                    stack.append(c)\\n                    continue\\n                temp = \\'\\'.join(stack)\\n                if ans<temp:\\n                    ans=temp\\n                else:\\n                    ans+=temp\\n                stack=[c]\\n        \\n        temp = \\'\\'.join(stack)\\n        if ans<temp:\\n            ans=temp\\n        else:\\n            ans+=temp\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527126,
                "title": "c-solution-7-lines-of-code-8-ms-o-1-space",
                "content": "```\\nchar * lastSubstring(char * s) {\\n    char *sl = s, *sr = s + 1;\\n\\t// compare 2 subsrings, left and right, starting from the beggining of the initial string\\n\\t// left subsring should become the greatest\\n    for (int k = 0; ; ++sr, k = 0) {    // increment pointer of right substring\\n        for (; sl[k] == sr[k]; ++k);    // increment k, until symbols match\\n        if (sr[k] == 0) break;          // end of the initial string, return\\n        if (sl[k] < sr[k]) sl = sr;     // right substing is greater, assign to the left\\n    }\\n    return sl;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * lastSubstring(char * s) {\\n    char *sl = s, *sr = s + 1;\\n\\t// compare 2 subsrings, left and right, starting from the beggining of the initial string\\n\\t// left subsring should become the greatest\\n    for (int k = 0; ; ++sr, k = 0) {    // increment pointer of right substring\\n        for (; sl[k] == sr[k]; ++k);    // increment k, until symbols match\\n        if (sr[k] == 0) break;          // end of the initial string, return\\n        if (sl[k] < sr[k]) sl = sr;     // right substing is greater, assign to the left\\n    }\\n    return sl;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 521073,
                "title": "java-solution-note",
                "content": "**Key idea:** the Last Substring in Lexicographical Order will start with the biggest char. Therefore, we need to find the largest char in s. Everytime, when we find another largest char in s, we need to compare the previous (pos) find substring with current (i + j - pos) one.\\n\\nI think in average time complexity is O(N). But in worse case it could be O(N^2).\\nWhat do you guys think?\\nSpace complexity is O(1)\\n\\n```\\npublic String lastSubstring(String s) {\\n        char ch = s.charAt(0);\\n        int n = s.length(), pos = 0;\\n        // pos: starting idx of last substring\\n\\n        for(int i = 0; i < n; i++) {\\n            if (ch < s.charAt(i)) { // if find a bigger character => update largest char\\n                ch = s.charAt(i); \\n                pos = i;\\n            } else if (s.charAt(i) == ch) { // find largest char again\\n                if(i > 0 && s.charAt(i - 1) == ch) continue; // skip char that is the same as prior char\\n                // start from last largest char and compare with current largest char\\n                // to determine which is bigger\\n                for(int j = pos; j < n; j++) { \\n                    if(i + j - pos >= n) {\\n                        break;\\n                    } \\n                    if(s.charAt(j) < s.charAt(i + j - pos)) { \\n                        pos = i; \\n                        break;\\n                    }\\n                    if(s.charAt(j) > s.charAt(i + j - pos)) {\\n                        break; \\n                    }\\n                }\\n            }\\n        }\\n        return s.substring(pos);\\n}\\n```\\n\\nMy code is modified from # 2 sol of Ref: https://leetcode.com/problems/last-substring-in-lexicographical-order/discuss/363132/JAVA-solution. I found a test case \"cbcbcb\" that will result in wrong answer. I notice the problem comes from the code ```if(j >= i) {pos = i; break;}```.",
                "solutionTags": [],
                "code": "```\\npublic String lastSubstring(String s) {\\n        char ch = s.charAt(0);\\n        int n = s.length(), pos = 0;\\n        // pos: starting idx of last substring\\n\\n        for(int i = 0; i < n; i++) {\\n            if (ch < s.charAt(i)) { // if find a bigger character => update largest char\\n                ch = s.charAt(i); \\n                pos = i;\\n            } else if (s.charAt(i) == ch) { // find largest char again\\n                if(i > 0 && s.charAt(i - 1) == ch) continue; // skip char that is the same as prior char\\n                // start from last largest char and compare with current largest char\\n                // to determine which is bigger\\n                for(int j = pos; j < n; j++) { \\n                    if(i + j - pos >= n) {\\n                        break;\\n                    } \\n                    if(s.charAt(j) < s.charAt(i + j - pos)) { \\n                        pos = i; \\n                        break;\\n                    }\\n                    if(s.charAt(j) > s.charAt(i + j - pos)) {\\n                        break; \\n                    }\\n                }\\n            }\\n        }\\n        return s.substring(pos);\\n}\\n```\n```if(j >= i) {pos = i; break;}```",
                "codeTag": "Unknown"
            },
            {
                "id": 482282,
                "title": "python3-two-methods",
                "content": "```\\nclass Solution:\\n\\tdef lastSubstring(self, s: str) -> str:\\n\\t\\ti,j,k,n = 0,1,0,len(s)\\n\\t\\twhile j+k<n:\\n\\t\\t\\tif s[i+k]==s[j+k]:\\n\\t\\t\\t\\tk+=1\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\telif s[i+k]>s[j+k]:\\n\\t\\t\\t\\tj+=k+1\\n\\t\\t\\telse:\\n\\t\\t\\t\\ti=max(j,i+k+1)\\n\\t\\t\\t\\tj=i+1\\n\\t\\t\\tk=0\\n\\t\\treturn s[i:]\\n\\n\\n\\tdef lastSubstringBF(self, s: str) -> str:\\n\\t\\tif len(s)<=1: return s\\n\\t\\ti,res=1,set()\\n\\t\\twhile i<len(s)+1:\\n\\t\\t\\tfor j in range(len(s)):\\n\\t\\t\\t\\tif len(s[j:])<i:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tres.add(s[j:j+i])\\n\\t\\t\\ti+=1\\n\\t\\tres = sorted(res)\\n\\t\\treturn res[-1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef lastSubstring(self, s: str) -> str:\\n\\t\\ti,j,k,n = 0,1,0,len(s)\\n\\t\\twhile j+k<n:\\n\\t\\t\\tif s[i+k]==s[j+k]:\\n\\t\\t\\t\\tk+=1\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\telif s[i+k]>s[j+k]:\\n\\t\\t\\t\\tj+=k+1\\n\\t\\t\\telse:\\n\\t\\t\\t\\ti=max(j,i+k+1)\\n\\t\\t\\t\\tj=i+1\\n\\t\\t\\tk=0\\n\\t\\treturn s[i:]\\n\\n\\n\\tdef lastSubstringBF(self, s: str) -> str:\\n\\t\\tif len(s)<=1: return s\\n\\t\\ti,res=1,set()\\n\\t\\twhile i<len(s)+1:\\n\\t\\t\\tfor j in range(len(s)):\\n\\t\\t\\t\\tif len(s[j:])<i:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tres.add(s[j:j+i])\\n\\t\\t\\ti+=1\\n\\t\\tres = sorted(res)\\n\\t\\treturn res[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419118,
                "title": "o-n-python-solution",
                "content": "```\\n    def lastSubstring(self, s: str) -> str:\\n        def getLargestChar(plist):        \\n            dp = [[] for _ in range(26)] # the locations for each char\\n\\n            for c, i in plist:\\n                dp[ord(c) - ord(\\'a\\')].append(i)\\n            for i in range(25, -1, -1):\\n                if len(dp[i]) >= 1:\\n                    return i, dp[i]\\n            \\n        ans = \\'\\'\\n        n = len(s)\\n        plist = [(c, i) for i, c in enumerate(s)]\\n        count = 0\\n        while len(plist) > 1 and count < n:\\n            c, largest =getLargestChar(plist)\\n            count += len(largest)\\n            plist = [(s[i+1], i+1) for i in largest if i+1 <n]\\n            ans+=(chr(c+ord(\\'a\\')))\\n        if len(plist) >= 1:\\n            ans+=s[plist[0][1]:]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def lastSubstring(self, s: str) -> str:\\n        def getLargestChar(plist):        \\n            dp = [[] for _ in range(26)] # the locations for each char\\n\\n            for c, i in plist:\\n                dp[ord(c) - ord(\\'a\\')].append(i)\\n            for i in range(25, -1, -1):\\n                if len(dp[i]) >= 1:\\n                    return i, dp[i]\\n            \\n        ans = \\'\\'\\n        n = len(s)\\n        plist = [(c, i) for i, c in enumerate(s)]\\n        count = 0\\n        while len(plist) > 1 and count < n:\\n            c, largest =getLargestChar(plist)\\n            count += len(largest)\\n            plist = [(s[i+1], i+1) for i in largest if i+1 <n]\\n            ans+=(chr(c+ord(\\'a\\')))\\n        if len(plist) >= 1:\\n            ans+=s[plist[0][1]:]\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 395366,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        \\n        c, n = max(s), len(s)\\n        if s == c*n:\\n            return s\\n        \\n        q = [i for i, e in enumerate(s) if e == c]\\n        res = s[q[0]]\\n        while q:\\n            qq = []\\n            for i in q:\\n                if i+1 < n:\\n                    qq += [i+1]\\n            if not qq:\\n                break\\n            c = max(s[i] for i in qq)\\n            res += c\\n            q = [i for i in qq if s[i] == c]\\n        \\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        \\n        c, n = max(s), len(s)\\n        if s == c*n:\\n            return s\\n        \\n        q = [i for i, e in enumerate(s) if e == c]\\n        res = s[q[0]]\\n        while q:\\n            qq = []\\n            for i in q:\\n                if i+1 < n:\\n                    qq += [i+1]\\n            if not qq:\\n                break\\n            c = max(s[i] for i in qq)\\n            res += c\\n            q = [i for i in qq if s[i] == c]\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 384405,
                "title": "most-elegant-pythonic-solution",
                "content": "Not the most efficient since it\\'s O(n^2), but the prettiest solution code for sure\\n\\nThe algorithm is simple, just run backwards and find the maximum Lexicographical string among all the substrings which ends in the last index (the solution substring must end at the final index...)\\n\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        if len(s) < 2:\\n            return s\\n        \\n        current = s[-1]\\n        for i in range(len(s) - 2, -1, -1):\\n            check = s[i:]       # \"cache\" s[i:] in check variable for reducing same slicing twice\\n            if check > current:\\n                current = check\\n        \\n        return current\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        if len(s) < 2:\\n            return s\\n        \\n        current = s[-1]\\n        for i in range(len(s) - 2, -1, -1):\\n            check = s[i:]       # \"cache\" s[i:] in check variable for reducing same slicing twice\\n            if check > current:\\n                current = check\\n        \\n        return current\\n```",
                "codeTag": "Java"
            },
            {
                "id": 366753,
                "title": "java-dc3-suffix-array-solution",
                "content": "Reference: http://www.mi.fu-berlin.de/wiki/pub/ABI/SS13Lecture3Materials/script.pdf\\n```\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        if (null == s || 1 >= s.length()) return s;\\n        int n = s.length();\\n        int i = 0;\\n        int[] encode = new int[n + 3];        \\n        for (char c : s.toCharArray()) encode[i++] = c - \\'a\\' + 1;\\n        int[] sa = suffixArray(encode, n, 27);\\n        return s.substring(sa[n - 1]);\\n    }\\n    private int[] suffixArray(int[] nums, int n, int K) {\\n        int n0 = (n + 2) / 3, n1 = (n + 1) / 3, n2 = n / 3, n02 = n0 + n2;\\n        int[] s12 = new int[n02 + 3], sa12 = new int[n02 + 3];\\n        // generate positions of mod 1 and mod  2 suffixes\\n        // the \"+(n0-n1)\" adds a dummy mod 1 suffix if n%3 == 1\\n        for (int i = 0, j = 0; i < n + (n0 - n1); ++i) if (0 != i % 3) s12[j++] = i;\\n        // lsb radix sort the mod 1 and mod 2 triples        \\n        radixPass(nums, s12, sa12, 2, n02, K);        \\n        radixPass(nums, sa12, s12, 1, n02, K);        \\n        radixPass(nums, s12, sa12, 0, n02, K);                \\n        // find lexicographic names of triples \\n        int name = 0, c0 = -1, c1 = -1, c2 = -1;\\n        for (int i = 0; i < n02; ++i) {\\n            if (c0 != nums[sa12[i]] || c1 != nums[sa12[i] + 1] || c2 != nums[sa12[i] + 2]) {\\n                name++;\\n                c0 = nums[sa12[i]];\\n                c1 = nums[sa12[i] + 1];\\n                c2 = nums[sa12[i] + 2];\\n            }\\n            if (1 == sa12[i] % 3) s12[sa12[i] / 3] = name;\\n            else s12[sa12[i] / 3 + n0] = name;\\n        }\\n        // recurse if names are not yet unique\\n        if (name < n02) {\\n            sa12 = suffixArray(s12, n02, name);\\n            // store unique names in s12 using the suffix array\\n            for(int i = 0; i < n02; i++) s12[sa12[i]] = i + 1;\\n        } else {\\n            // generate the suffix array of s12 directly\\n            for(int i = 0; i < n02; i++) sa12[s12[i] - 1] = i;\\n        }\\n        // stably sort the mod 0 suffixes from SA12 by their first character\\n        int[] s0 = new int[n0], sa0 = new int[n0];\\n        for (int i = 0, j = 0; i < n02; i++) if (sa12[i] < n0) s0[j++] = 3 * sa12[i];\\n        radixPass(nums, s0, sa0, 0, n0, K);\\n        // merge sorted SA0 suffixes and sorted SA12 suffixes\\n        int[] sa = new int[n];\\n        for (int p = 0, t = n0 - n1, k = 0; k < n; k++) {\\n            // pos of current offset 12 suffix\\n            int i = sa12[t] < n0 ? sa12[t] * 3 + 1 : (sa12[t] - n0) * 3 + 2;\\n            int j = sa0[p]; // pos of current offset 0  suffix\\n            // different compares for mod 1 and mod 2 suffixes\\n            if (sa12[t] < n0 ? leq(nums[i], s12[sa12[t] + n0], nums[j], s12[j / 3]) :                 \\n                leq(nums[i], nums[i + 1], s12[sa12[t] - n0 + 1], nums[j], nums[j + 1], s12[j / 3 + n0])) {\\n                // suffix from SA12 is smaller\\n                sa[k] = i;  \\n                t++;\\n                if (t == n02) // done --- only SA0 suffixes left\\n                for (k++; p < n0; p++, k++) sa[k] = sa0[p];\\n            } else {\\n                // suffix from SA0 is smaller\\n                sa[k] = j;  \\n                p++;\\n                if (p == n0)  // done --- only SA12 suffixes left\\n                for (k++; t < n02; t++, k++) sa[k] = sa12[t] < n0 ? sa12[t] * 3 + 1 : (sa12[t] - n0) * 3 + 2;\\n            }\\n        }\\n        return sa;\\n    }\\n    private void radixPass(int[] nums, int[] input, int[] output, int offset, int n, int k) {\\n        int[] cnt = new int[k + 1];\\n        for (int i = 0; i < n; ++i) cnt[nums[input[i] + offset]]++;\\n        for (int i = 0, sum = 0; i < cnt.length; ++i) {\\n            int t = cnt[i];\\n            cnt[i] = sum;\\n            sum += t;\\n        }\\n        for (int i = 0; i < n; ++i) output[cnt[nums[input[i] + offset]]++] = input[i];\\n    }\\n    private boolean leq(int a1, int a2, int b1, int b2) {\\n        return a1 < b1 || (a1 == b1 && a2 <= b2);\\n    }\\n    private boolean leq(int a1, int a2, int a3, int b1, int b2, int b3) {\\n        return a1 < b1 || (a1 == b1 && leq(a2,a3,b2,b3));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        if (null == s || 1 >= s.length()) return s;\\n        int n = s.length();\\n        int i = 0;\\n        int[] encode = new int[n + 3];        \\n        for (char c : s.toCharArray()) encode[i++] = c - \\'a\\' + 1;\\n        int[] sa = suffixArray(encode, n, 27);\\n        return s.substring(sa[n - 1]);\\n    }\\n    private int[] suffixArray(int[] nums, int n, int K) {\\n        int n0 = (n + 2) / 3, n1 = (n + 1) / 3, n2 = n / 3, n02 = n0 + n2;\\n        int[] s12 = new int[n02 + 3], sa12 = new int[n02 + 3];\\n        // generate positions of mod 1 and mod  2 suffixes\\n        // the \"+(n0-n1)\" adds a dummy mod 1 suffix if n%3 == 1\\n        for (int i = 0, j = 0; i < n + (n0 - n1); ++i) if (0 != i % 3) s12[j++] = i;\\n        // lsb radix sort the mod 1 and mod 2 triples        \\n        radixPass(nums, s12, sa12, 2, n02, K);        \\n        radixPass(nums, sa12, s12, 1, n02, K);        \\n        radixPass(nums, s12, sa12, 0, n02, K);                \\n        // find lexicographic names of triples \\n        int name = 0, c0 = -1, c1 = -1, c2 = -1;\\n        for (int i = 0; i < n02; ++i) {\\n            if (c0 != nums[sa12[i]] || c1 != nums[sa12[i] + 1] || c2 != nums[sa12[i] + 2]) {\\n                name++;\\n                c0 = nums[sa12[i]];\\n                c1 = nums[sa12[i] + 1];\\n                c2 = nums[sa12[i] + 2];\\n            }\\n            if (1 == sa12[i] % 3) s12[sa12[i] / 3] = name;\\n            else s12[sa12[i] / 3 + n0] = name;\\n        }\\n        // recurse if names are not yet unique\\n        if (name < n02) {\\n            sa12 = suffixArray(s12, n02, name);\\n            // store unique names in s12 using the suffix array\\n            for(int i = 0; i < n02; i++) s12[sa12[i]] = i + 1;\\n        } else {\\n            // generate the suffix array of s12 directly\\n            for(int i = 0; i < n02; i++) sa12[s12[i] - 1] = i;\\n        }\\n        // stably sort the mod 0 suffixes from SA12 by their first character\\n        int[] s0 = new int[n0], sa0 = new int[n0];\\n        for (int i = 0, j = 0; i < n02; i++) if (sa12[i] < n0) s0[j++] = 3 * sa12[i];\\n        radixPass(nums, s0, sa0, 0, n0, K);\\n        // merge sorted SA0 suffixes and sorted SA12 suffixes\\n        int[] sa = new int[n];\\n        for (int p = 0, t = n0 - n1, k = 0; k < n; k++) {\\n            // pos of current offset 12 suffix\\n            int i = sa12[t] < n0 ? sa12[t] * 3 + 1 : (sa12[t] - n0) * 3 + 2;\\n            int j = sa0[p]; // pos of current offset 0  suffix\\n            // different compares for mod 1 and mod 2 suffixes\\n            if (sa12[t] < n0 ? leq(nums[i], s12[sa12[t] + n0], nums[j], s12[j / 3]) :                 \\n                leq(nums[i], nums[i + 1], s12[sa12[t] - n0 + 1], nums[j], nums[j + 1], s12[j / 3 + n0])) {\\n                // suffix from SA12 is smaller\\n                sa[k] = i;  \\n                t++;\\n                if (t == n02) // done --- only SA0 suffixes left\\n                for (k++; p < n0; p++, k++) sa[k] = sa0[p];\\n            } else {\\n                // suffix from SA0 is smaller\\n                sa[k] = j;  \\n                p++;\\n                if (p == n0)  // done --- only SA12 suffixes left\\n                for (k++; t < n02; t++, k++) sa[k] = sa12[t] < n0 ? sa12[t] * 3 + 1 : (sa12[t] - n0) * 3 + 2;\\n            }\\n        }\\n        return sa;\\n    }\\n    private void radixPass(int[] nums, int[] input, int[] output, int offset, int n, int k) {\\n        int[] cnt = new int[k + 1];\\n        for (int i = 0; i < n; ++i) cnt[nums[input[i] + offset]]++;\\n        for (int i = 0, sum = 0; i < cnt.length; ++i) {\\n            int t = cnt[i];\\n            cnt[i] = sum;\\n            sum += t;\\n        }\\n        for (int i = 0; i < n; ++i) output[cnt[nums[input[i] + offset]]++] = input[i];\\n    }\\n    private boolean leq(int a1, int a2, int b1, int b2) {\\n        return a1 < b1 || (a1 == b1 && a2 <= b2);\\n    }\\n    private boolean leq(int a1, int a2, int a3, int b1, int b2, int b3) {\\n        return a1 < b1 || (a1 == b1 && leq(a2,a3,b2,b3));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 365755,
                "title": "c-o-n-solution-well-commented-and-with-picture-to-understand",
                "content": "Feel free to decomment the printf to see how it runs or check this.\\n![image](https://assets.leetcode.com/users/bug_exceeded/image_1566651504.png)\\n\\n```cpp\\nclass Solution \\n{\\npublic:\\n    string lastSubstring(string s) \\n    {\\n        int cand_pos = 0; // position that can be the start of candidate\\n        int max_pos = 0; // position where max character lies\\n        int n = s.size();\\n        int first_find = 0; // if this is the first kind of such substring starting at position i\\n        int offset = 1; // string offset for lexicographical comparison\\n        char max_char = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            // printf(\"i %d\", i);\\n            if(s[i] > max_char) // if this char is greater than the previous, use this\\n            {\\n                // printf(\"new max char %  c\", s[i]);\\n                max_char = s[i]; // update max character\\n                max_pos = i; // update max pos\\n                first_find = 1; // the string starting at this position is currently the first and the only one\\n                offset = 1;\\n            }\\n            else if(first_find == 0) // compare the candidates\\n            {\\n                if(max_pos + offset < n) // lies in the legal position\\n                {\\n                    if(s[i] > s[max_pos + offset]) // check if another greater char exists\\n                    {\\n                        max_pos = i - offset; // if so, update the max position\\n                        // printf(\"update max_pos:%d\", max_pos);\\n                        first_find = 1; // give up the old \\n                    }\\n                    else if(s[i] == s[max_pos + offset]) // increment\\n                    {\\n                        // printf(\"same offset++\");\\n                        offset++;\\n                    }\\n                    else\\n                    {\\n                        // printf(\"give up small\");\\n                        first_find = 1; // give up such result if encounter a smaller one and keep the old\\n                    }\\n                }\\n            }\\n            else if(s[i] == max_char) // else if this char is equal, which means find the second one (i.e. string startin start with same char) to compare\\n            {\\n                // printf(\"another candidate\");\\n                offset = 1; // reset offset\\n                first_find = 0; // mark as false for not the first one\\n            }\\n            // printf(\"\\\\n\");\\n        }\\n        return s.substr(max_pos);\\n    }    \\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution \\n{\\npublic:\\n    string lastSubstring(string s) \\n    {\\n        int cand_pos = 0; // position that can be the start of candidate\\n        int max_pos = 0; // position where max character lies\\n        int n = s.size();\\n        int first_find = 0; // if this is the first kind of such substring starting at position i\\n        int offset = 1; // string offset for lexicographical comparison\\n        char max_char = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            // printf(\"i %d\", i);\\n            if(s[i] > max_char) // if this char is greater than the previous, use this\\n            {\\n                // printf(\"new max char %  c\", s[i]);\\n                max_char = s[i]; // update max character\\n                max_pos = i; // update max pos\\n                first_find = 1; // the string starting at this position is currently the first and the only one\\n                offset = 1;\\n            }\\n            else if(first_find == 0) // compare the candidates\\n            {\\n                if(max_pos + offset < n) // lies in the legal position\\n                {\\n                    if(s[i] > s[max_pos + offset]) // check if another greater char exists\\n                    {\\n                        max_pos = i - offset; // if so, update the max position\\n                        // printf(\"update max_pos:%d\", max_pos);\\n                        first_find = 1; // give up the old \\n                    }\\n                    else if(s[i] == s[max_pos + offset]) // increment\\n                    {\\n                        // printf(\"same offset++\");\\n                        offset++;\\n                    }\\n                    else\\n                    {\\n                        // printf(\"give up small\");\\n                        first_find = 1; // give up such result if encounter a smaller one and keep the old\\n                    }\\n                }\\n            }\\n            else if(s[i] == max_char) // else if this char is equal, which means find the second one (i.e. string startin start with same char) to compare\\n            {\\n                // printf(\"another candidate\");\\n                offset = 1; // reset offset\\n                first_find = 0; // mark as false for not the first one\\n            }\\n            // printf(\"\\\\n\");\\n        }\\n        return s.substr(max_pos);\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 364725,
                "title": "find-maximum-lexicographic-rotation-of-a-string",
                "content": "Reference : https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int n = s.length(); \\n        int i = 0, j = 1, k = 0;\\n        while (k < n && i < n && j < n) {\\n            //cout << i << \", \" << j << \", \" << k << endl;\\n            int idx1 = (i+k)%n, idx2 = (j+k)%n;\\n            if (s[idx1] == s[idx2]) {\\n                k++;\\n            } else {\\n                if (s[idx1] < s[idx2]) {\\n                    i = i + k + 1;\\n                } else {\\n                    j = j + k + 1;\\n                }\\n                if (i == j) {\\n                    i++;\\n                }\\n                k = 0;\\n            } \\n        }\\n        int maxIdx = min(i, j);\\n        return s.substr(maxIdx);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int n = s.length(); \\n        int i = 0, j = 1, k = 0;\\n        while (k < n && i < n && j < n) {\\n            //cout << i << \", \" << j << \", \" << k << endl;\\n            int idx1 = (i+k)%n, idx2 = (j+k)%n;\\n            if (s[idx1] == s[idx2]) {\\n                k++;\\n            } else {\\n                if (s[idx1] < s[idx2]) {\\n                    i = i + k + 1;\\n                } else {\\n                    j = j + k + 1;\\n                }\\n                if (i == j) {\\n                    i++;\\n                }\\n                k = 0;\\n            } \\n        }\\n        int maxIdx = min(i, j);\\n        return s.substr(maxIdx);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 364253,
                "title": "why-the-hint-suggest-suffix-arrary-it-s-actually-the-worse-one",
                "content": "The suffix array + radix sort is suppose to make it in ```O(nlog(n))``` time but the radix sort is kind of suck in this input scale. My solution was acutally accepted by chance and runtime is over 1.5s. The drawback of this solution is the overhead of allocating bucket in radix sort, when there are more distinct numbers to sort, the buckets size needs to be equal to the input array size in the worst case.\\n\\nI don\\'t think my code is good enough to be post. However I still post it in case if some dalao could point me out there are something in the code interferes the performance. After all I really think an ```O(nlog(n))``` solution should pass the test case, even the last one is actually 400000... \\n\\n```C++\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int count = 0;\\n        for(int i = 1; i < s.size(); ++i) {\\n            if(s[i] != s[i - 1]) count += 1;\\n        }\\n        if(count == 0) return s;\\n        vector<suffix> ranks;\\n        for(int i = 0; i < s.size(); ++i) {\\n            ranks.emplace_back(suffix(i, s[i] - \\'a\\' + 1, s[i] - \\'a\\' + 1));\\n        }\\n        int flag = radixSort(ranks);\\n        int k = 1;\\n        while(k < s.size() && flag == -1) {\\n            for(int i = 0; i < ranks.size(); ++i) {\\n                if(ranks[i].index + k < ranks.size()) ranks[i].rank[0] = ranks[i + k].rank[1];\\n                else break;\\n            }\\n            k <<= 1;\\n            flag = radixSort(ranks);\\n        }\\n        return s.substr(flag);\\n    }\\nprivate:\\n    struct suffix {\\n        int rank[2];\\n        int index;\\n        suffix(int i, int r0, int r1) : index(i) {\\n            rank[0] = r0;\\n            rank[1] = r1;\\n        }\\n    };\\n    int radixSort(vector<suffix>& ranks) {\\n        int maxSize1 = 0, maxSize2 = 0;\\n        for(auto item : ranks) {\\n            maxSize1 = max(item.rank[0], maxSize1);\\n            maxSize2 = max(item.rank[1], maxSize2);\\n        }\\n        vector<vector<suffix>> bucket1(maxSize1 + 1), bucket2(maxSize2 + 1);\\n        for(auto item : ranks) {\\n            bucket1[item.rank[0]].emplace_back(item);\\n        }\\n        for(auto p : bucket1) {\\n            for(auto item : p) {\\n                bucket2[item.rank[1]].emplace_back(item);\\n            }\\n        }\\n        int order = 0, cand = 0;\\n        int current[2] = {0, 0};\\n        for(auto item : bucket2) {\\n            for(int i = 0; i < item.size(); ++i) {\\n                auto now = item[i];\\n                if(isEqual(current, now.rank) == false) {\\n                    memcpy(current, now.rank, sizeof(now.rank));\\n                    ranks[now.index].rank[0] = 0;\\n                    ranks[now.index].rank[1] = ++order;\\n                    cand = now.index;\\n                }\\n                else {\\n                    ranks[now.index].rank[0] = 0;\\n                    ranks[now.index].rank[1] = order;\\n                }\\n            }\\n        }\\n        if(order == ranks.size()) return cand;\\n        else return -1;\\n    }\\n    inline bool isEqual(const int x[], const int y[]) {\\n        return (x[0] == y[0] && x[1] && y[1]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```O(nlog(n))```\n```O(nlog(n))```\n```C++\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int count = 0;\\n        for(int i = 1; i < s.size(); ++i) {\\n            if(s[i] != s[i - 1]) count += 1;\\n        }\\n        if(count == 0) return s;\\n        vector<suffix> ranks;\\n        for(int i = 0; i < s.size(); ++i) {\\n            ranks.emplace_back(suffix(i, s[i] - \\'a\\' + 1, s[i] - \\'a\\' + 1));\\n        }\\n        int flag = radixSort(ranks);\\n        int k = 1;\\n        while(k < s.size() && flag == -1) {\\n            for(int i = 0; i < ranks.size(); ++i) {\\n                if(ranks[i].index + k < ranks.size()) ranks[i].rank[0] = ranks[i + k].rank[1];\\n                else break;\\n            }\\n            k <<= 1;\\n            flag = radixSort(ranks);\\n        }\\n        return s.substr(flag);\\n    }\\nprivate:\\n    struct suffix {\\n        int rank[2];\\n        int index;\\n        suffix(int i, int r0, int r1) : index(i) {\\n            rank[0] = r0;\\n            rank[1] = r1;\\n        }\\n    };\\n    int radixSort(vector<suffix>& ranks) {\\n        int maxSize1 = 0, maxSize2 = 0;\\n        for(auto item : ranks) {\\n            maxSize1 = max(item.rank[0], maxSize1);\\n            maxSize2 = max(item.rank[1], maxSize2);\\n        }\\n        vector<vector<suffix>> bucket1(maxSize1 + 1), bucket2(maxSize2 + 1);\\n        for(auto item : ranks) {\\n            bucket1[item.rank[0]].emplace_back(item);\\n        }\\n        for(auto p : bucket1) {\\n            for(auto item : p) {\\n                bucket2[item.rank[1]].emplace_back(item);\\n            }\\n        }\\n        int order = 0, cand = 0;\\n        int current[2] = {0, 0};\\n        for(auto item : bucket2) {\\n            for(int i = 0; i < item.size(); ++i) {\\n                auto now = item[i];\\n                if(isEqual(current, now.rank) == false) {\\n                    memcpy(current, now.rank, sizeof(now.rank));\\n                    ranks[now.index].rank[0] = 0;\\n                    ranks[now.index].rank[1] = ++order;\\n                    cand = now.index;\\n                }\\n                else {\\n                    ranks[now.index].rank[0] = 0;\\n                    ranks[now.index].rank[1] = order;\\n                }\\n            }\\n        }\\n        if(order == ranks.size()) return cand;\\n        else return -1;\\n    }\\n    inline bool isEqual(const int x[], const int y[]) {\\n        return (x[0] == y[0] && x[1] && y[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 363552,
                "title": "go-find-max-char-and-check-substrings",
                "content": "```\\nfunc lastSubstring(s string) string {\\n\\tvar maxChar = \\'a\\'\\n\\tfor _, c := range s {\\n\\t\\tif c > maxChar {\\n\\t\\t\\tmaxChar = c\\n\\t\\t}\\n\\t}\\n\\n\\tpositions := make([]int, 0)\\n\\tfor i, c := range s {\\n\\t\\tif c == maxChar {\\n\\t\\t\\tpositions = append(positions, i)\\n\\t\\t}\\n\\t}\\n\\n\\tstrs := make([]string, 0, len(positions))\\n\\tfor _, p := range positions {\\n\\t\\tstrs = append(strs, s[p:])\\n\\t}\\n\\tsort.Strings(strs)\\n\\treturn strs[len(strs)-1]\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc lastSubstring(s string) string {\\n\\tvar maxChar = \\'a\\'\\n\\tfor _, c := range s {\\n\\t\\tif c > maxChar {\\n\\t\\t\\tmaxChar = c\\n\\t\\t}\\n\\t}\\n\\n\\tpositions := make([]int, 0)\\n\\tfor i, c := range s {\\n\\t\\tif c == maxChar {\\n\\t\\t\\tpositions = append(positions, i)\\n\\t\\t}\\n\\t}\\n\\n\\tstrs := make([]string, 0, len(positions))\\n\\tfor _, p := range positions {\\n\\t\\tstrs = append(strs, s[p:])\\n\\t}\\n\\tsort.Strings(strs)\\n\\treturn strs[len(strs)-1]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 362803,
                "title": "java-2-pointers-straightforward-obvious-algo",
                "content": "```\\n    public String lastSubstring(String s) {\\n        int i=0;\\n        int j=1;\\n        int k;\\n\\n        while(i<s.length() && j<s.length()){\\n            char ci = s.charAt(i);\\n            char cj = s.charAt(j);\\n\\n            if(ci>cj){ //i is better\\n                j++;\\n            }else if(ci<cj){ //j is better\\n                i=j;\\n                j=i+1;\\n            }else{//ci==cj\\n                for(k=1;j+k<s.length();k++){//let\\'s compare other chars like i+1 and j+1 ... i+k,j+k\\n                    char cki = s.charAt(i+k);\\n                    char ckj = s.charAt(j+k);\\n                    if(cki>ckj){ //i is better \\n                        j=j+k+1;\\n                        break;\\n                    }else if(cki<ckj){ //j is better\\n                        i=j;\\n                        j=i+1;\\n                        break;\\n                    }else if( i+k==j){ // i has reached j, that means i is better\\n                        j=j+k+1;\\n                        break;\\n                    }\\n                }\\n                \\n                //we has finished i+k,j+k comparison since j has reached end of string, so i is still better\\n                if(j+k==s.length())  \\n                    break;\\n            }\\n        }\\n\\n        //final i is always better choice\\n        return s.substring(i);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String lastSubstring(String s) {\\n        int i=0;\\n        int j=1;\\n        int k;\\n\\n        while(i<s.length() && j<s.length()){\\n            char ci = s.charAt(i);\\n            char cj = s.charAt(j);\\n\\n            if(ci>cj){ //i is better\\n                j++;\\n            }else if(ci<cj){ //j is better\\n                i=j;\\n                j=i+1;\\n            }else{//ci==cj\\n                for(k=1;j+k<s.length();k++){//let\\'s compare other chars like i+1 and j+1 ... i+k,j+k\\n                    char cki = s.charAt(i+k);\\n                    char ckj = s.charAt(j+k);\\n                    if(cki>ckj){ //i is better \\n                        j=j+k+1;\\n                        break;\\n                    }else if(cki<ckj){ //j is better\\n                        i=j;\\n                        j=i+1;\\n                        break;\\n                    }else if( i+k==j){ // i has reached j, that means i is better\\n                        j=j+k+1;\\n                        break;\\n                    }\\n                }\\n                \\n                //we has finished i+k,j+k comparison since j has reached end of string, so i is still better\\n                if(j+k==s.length())  \\n                    break;\\n            }\\n        }\\n\\n        //final i is always better choice\\n        return s.substring(i);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 362680,
                "title": "c-make-groups-for-them-not-brute-force",
                "content": "**intuition**\\n```\\n1. get the index for all the char, like\\n    a : 0,2,6,10\\n\\tb : 1,5,7\\n\\t...\\n\\tz : 15,31\\n2. get the max lexicographical char, start from z to a, any vector size != 0 will be our goal\\n3. the targeted vector should be like a group view, take k for instance :\\n    kkkkabckkkhhdkkkkzza\\n\\tvector k : 0,7,13\\n4. start with compare each group to find max lexicographical order.\\n    start from second char in a single group, then third, fourth...etc\\n\\tOnce the rest element is only 1, it\\'s the answer.\\n```\\n```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        vector<vector<int>> mymap(128,vector<int>());\\n        int max_char = INT_MIN;\\n        int start = 0;\\n\\t\\t/* step1. build up the map */\\n        while(start < s.length()){\\n            mymap[s[start]].push_back(start);\\n            while(++start < s.length() && s[start] == s[start-1]){}\\n        }\\n\\t\\t/* step2. get the max lexicographical char */\\n        for(max_char = 122 ; max_char >= 0 ;max_char--)\\n            if(mymap[max_char].size()!=0)\\n                break;\\n        vector<int> v1(mymap[max_char].begin(),mymap[max_char].end()),v2;\\n        int len = 1;\\n\\t\\t\\n\\t\\t/* step3 compare each group, and keep the max lexicographical order substring */\\n        while(v1.size() > 1){\\n            char max_char_ = 0;\\n            for(int I : v1){\\n                int cur = I+len;\\n                if(s[cur] >= max_char_){\\n                    if(s[cur] > max_char_)\\n                        max_char_ = s[cur],v2.clear();\\n                    v2.push_back(I);\\n                }\\n            }\\n            v1 = v2;\\n\\t\\t\\t/* step4, update len that we can compare further substring */\\n            len++;\\n        }\\n        return s.substr(*v1.begin());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n1. get the index for all the char, like\\n    a : 0,2,6,10\\n\\tb : 1,5,7\\n\\t...\\n\\tz : 15,31\\n2. get the max lexicographical char, start from z to a, any vector size != 0 will be our goal\\n3. the targeted vector should be like a group view, take k for instance :\\n    kkkkabckkkhhdkkkkzza\\n\\tvector k : 0,7,13\\n4. start with compare each group to find max lexicographical order.\\n    start from second char in a single group, then third, fourth...etc\\n\\tOnce the rest element is only 1, it\\'s the answer.\\n```\n```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        vector<vector<int>> mymap(128,vector<int>());\\n        int max_char = INT_MIN;\\n        int start = 0;\\n\\t\\t/* step1. build up the map */\\n        while(start < s.length()){\\n            mymap[s[start]].push_back(start);\\n            while(++start < s.length() && s[start] == s[start-1]){}\\n        }\\n\\t\\t/* step2. get the max lexicographical char */\\n        for(max_char = 122 ; max_char >= 0 ;max_char--)\\n            if(mymap[max_char].size()!=0)\\n                break;\\n        vector<int> v1(mymap[max_char].begin(),mymap[max_char].end()),v2;\\n        int len = 1;\\n\\t\\t\\n\\t\\t/* step3 compare each group, and keep the max lexicographical order substring */\\n        while(v1.size() > 1){\\n            char max_char_ = 0;\\n            for(int I : v1){\\n                int cur = I+len;\\n                if(s[cur] >= max_char_){\\n                    if(s[cur] > max_char_)\\n                        max_char_ = s[cur],v2.clear();\\n                    v2.push_back(I);\\n                }\\n            }\\n            v1 = v2;\\n\\t\\t\\t/* step4, update len that we can compare further substring */\\n            len++;\\n        }\\n        return s.substr(*v1.begin());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362522,
                "title": "simple-java-solution",
                "content": "1. First find the max character value with min index\\n2. Find other substring which the first character is the same as the max character except it is followed by a contiguous max character sequence\\n3. Compare `2` with recent find last substring candidate\\n```\\npublic String lastSubstring(String s) {\\n        int start = 0;\\n        int len = s.length();\\n        if(len == 0) return s;\\n        char maxVal = s.charAt(0);\\n        for(int i = 1; i < len; i++){\\n           if(s.charAt(i) > maxVal){\\n               maxVal = s.charAt(i);\\n               start = i;\\n           }\\n        }\\n        boolean contiguous = true;\\n        for(int i = start + 1; i < len; i++){\\n            if(s.charAt(i) != maxVal){\\n                contiguous = false;\\n            }\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0else if(!contiguous){\\n                int j = 0;\\n                while(i + j < len && s.charAt(start + j) == s.charAt(i + j)) j++;\\n                if(i + j < len && s.charAt(start + j) < s.charAt(i+j)){\\n                    start = i;\\n                }\\n               contiguous = true;\\n                \\n            }\\n        }\\n        return s.substring(start);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String lastSubstring(String s) {\\n        int start = 0;\\n        int len = s.length();\\n        if(len == 0) return s;\\n        char maxVal = s.charAt(0);\\n        for(int i = 1; i < len; i++){\\n           if(s.charAt(i) > maxVal){\\n               maxVal = s.charAt(i);\\n               start = i;\\n           }\\n        }\\n        boolean contiguous = true;\\n        for(int i = start + 1; i < len; i++){\\n            if(s.charAt(i) != maxVal){\\n                contiguous = false;\\n            }\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0else if(!contiguous){\\n                int j = 0;\\n                while(i + j < len && s.charAt(start + j) == s.charAt(i + j)) j++;\\n                if(i + j < len && s.charAt(start + j) < s.charAt(i+j)){\\n                    start = i;\\n                }\\n               contiguous = true;\\n                \\n            }\\n        }\\n        return s.substring(start);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 361859,
                "title": "python-solution",
                "content": "```\\n\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        sDict = {}\\n        \\n        for char in s:\\n            sDict[ord(char)] = sDict.get(ord(char), 0) + 1\\n            \\n        contender = \"\"\\n        maxS = \"\"\\n            \\n        for i in range(122, 96, -1):\\n            if chr(i) in s:\\n                contender = chr(i)\\n                maxS = s[s.index(chr(i)) : i]\\n                break\\n                \\n        for i in range(len(s)):\\n            if s[i] == contender:\\n                if maxS < s[i : ]:\\n                    maxS = s[i: ]\\n        \\n        return maxS\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        sDict = {}\\n        \\n        for char in s:\\n            sDict[ord(char)] = sDict.get(ord(char), 0) + 1\\n            \\n        contender = \"\"\\n        maxS = \"\"\\n            \\n        for i in range(122, 96, -1):\\n            if chr(i) in s:\\n                contender = chr(i)\\n                maxS = s[s.index(chr(i)) : i]\\n                break\\n                \\n        for i in range(len(s)):\\n            if s[i] == contender:\\n                if maxS < s[i : ]:\\n                    maxS = s[i: ]\\n        \\n        return maxS\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 361691,
                "title": "python-o-n-2-time-o-1-space",
                "content": "Going from back to front to deal with duplicated letters like \"aaaaaaa....\"\\nDirectly update when current character is greater than candidate start character (at start_loc)\\nWhen current character == start character, check subsequent letters one by one. (worse case O(N^2)\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        n = len(s)\\n        start_loc = n\\n        for i in range(n-1, -1, -1):\\n\\t\\t\\t# 1. dealing with duplicates like \"aaaaa\"\\n            if start_loc != n and s[start_loc] == s[i] and i + 1 == start_loc:\\n                start_loc = i\\n                continue\\n            ch = s[i]\\n\\t\\t\\t# 2. directly update if ch is bigger\\n            if start_loc == n or ch > s[start_loc]:\\n                start_loc = i\\n\\t\\t\\t# 3. careful checking when equal\\n            elif ch == s[start_loc]:\\n                better = True\\n                for j in range(n - start_loc):\\n                    if s[i+j] > s[start_loc + j]:\\n                        break\\n                    elif s[i+j] < s[start_loc + j]:\\n                        better = False\\n                        break\\n                if better :\\n                    start_loc = i\\n        return s[start_loc:]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        n = len(s)\\n        start_loc = n\\n        for i in range(n-1, -1, -1):\\n\\t\\t\\t# 1. dealing with duplicates like \"aaaaa\"\\n            if start_loc != n and s[start_loc] == s[i] and i + 1 == start_loc:\\n                start_loc = i\\n                continue\\n            ch = s[i]\\n\\t\\t\\t# 2. directly update if ch is bigger\\n            if start_loc == n or ch > s[start_loc]:\\n                start_loc = i\\n\\t\\t\\t# 3. careful checking when equal\\n            elif ch == s[start_loc]:\\n                better = True\\n                for j in range(n - start_loc):\\n                    if s[i+j] > s[start_loc + j]:\\n                        break\\n                    elif s[i+j] < s[start_loc + j]:\\n                        better = False\\n                        break\\n                if better :\\n                    start_loc = i\\n        return s[start_loc:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361682,
                "title": "c-brute-force-solutions",
                "content": "See more code in my repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Brute Force\\n\\nFirst, find the greatest character, with which the answer must start.\\n\\nPush all the indexes of that character into a candidate vector, which are all the possible solutions.\\n\\nNote that considering the case `\"a............a\"`, we only push if the character before the current index is not also the greatest character. This is because in that case, the previous index must yield better result than the current index (For example, for `\"ddab\"` and `\"dab\"`, we don\\'t need to consider `\"dab\"`).\\n\\nNow we have all the possible start indexes, we continue to look at the 2nd, 3rd, ... characters after the start indexes.\\n\\n* If this start index can\\'t afford `len` characters after it but others can, it should be ignored.\\n* For each start indexes `n`, we look at the `s[n + len]`, and find the greatest character. We only keep the start indexes that has the greatest character we just found at `s[n + len]`.\\n\\nAs we extending the `len`, the size of the available start indexes gets smaller and smaller until it becomes 1. The last start index left is the start index of the answer.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/last-substring-in-lexicographical-order/\\n// Author: github.com/lzl124631x\\n// Time: O(VL) where V is the length of `v` and L is the max possible `len`.\\n//       It is strictly smaller than O(N^2)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int start = 0, N = s.size();\\n        for (int i = 0; i < N; ++i) {\\n            if (s[i] > s[start]) start = i;\\n        }\\n        vector<int> v;\\n        for (int i = start; i < N; ++i) {\\n            if (s[i] == s[start] && (i == 0 || s[i - 1] != s[start])) v.push_back(i);\\n        }\\n        for (int len = 1; len <= N && v.size() > 1; ++len) {\\n            vector<int> next;\\n            char c = \\'a\\';\\n            for (int n : v) {\\n                if (n + len >= N || s[n + len] < c) continue;\\n                if (s[n + len] > c) {\\n                    next.clear();\\n                    c = s[n + len];\\n                }\\n                next.push_back(n);\\n            }\\n            v = next;\\n        }\\n        return s.substr(v[0]);\\n    }\\n};\\n```\\n\\n## Solution 2. Brute Force\\n\\nFor a substring `A` and all its prefix substrings, `A` must be the one lexicographically largest. So we don\\'t need to consider the prefix substrings of `A`.\\n\\nSo for this question, we only need to consider the `N` suffix substrings of `s`.\\n\\nWe just brute-forcely compare all the suffix strings.\\n\\nOne optimization we do for the `\"a.....a\"` case is `if (i + j == N) break`. My reasoning is as follows.\\n\\nWhen `i + j == N`, the string `i` is of pattern `ABA`, where `j` is the start index of the second string segment `A`.\\n\\nExample\\n```\\n i           j\\n[ddac](abac)[ddac]\\n```\\n\\nNote that string `A` and `B` won\\'t have any character greater than `s[i]` because otherwise `i` will be moved to that greater character first.\\n\\nSince we\\'ve already moved to `s[j]`, it means there is no better solution between `i+1` and `j - 1`. So we only need to think about the indexes after `j`. For each `k` in `[j + 1, N)`, we can find a counterpart `t` in `[i + 1, i + N - j)`, and string `t` must be better than string `k` since they have the same prefix and string `t` is longer. And because string `t` is no better than string `i`, so we can ignore all indexes after `j`.\\n\\nNote that this optimization can\\'t pass test case `\"a....ab\"` though.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/last-substring-in-lexicographical-order/\\n// Author: github.com/lzl124631x\\n// Time: O(N^2)\\n// Space: O(1)\\n// Ref: https://leetcode.com/problems/last-substring-in-lexicographical-order/discuss/360957/C%2B%2B-Brute-Force\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int start = 0, N = s.size(), j;\\n        for (int i = 1; i < N; ++i) {\\n            for (j = 0; i + j < N; ++j) {\\n                if (s[start + j] == s[i + j]) continue;\\n                start = s[start + j] > s[i + j] ? start : i;\\n                break;\\n            }\\n            if (i + j == N) break;\\n        }\\n        return s.substr(start);\\n    }\\n};\\n```\\n\\n## Solution 3. Brute Force\\n\\nSame idea as Solution 2 but with different optimization.\\n\\nWe skip the start index `i` if both `s[i]` and `s[i - 1]` are the same as `s[start]` where `start` is the best start index currently found.\\n\\nIt\\'s because in that case string `i - 1` must be lexicographically larger than string `i`.\\n\\nThis solution can pass the test case `\"a....ab\"`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/last-substring-in-lexicographical-order/\\n// Author: github.com/lzl124631x\\n// Time: O(N^2)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int start = 0, N = s.size();\\n        for (int i = 1; i < N; ++i) {\\n            if (s[i] == s[start] && s[i - 1] == s[start]) continue;\\n            for (int j = 0; i + j < N; ++j) {\\n                if (s[start + j] == s[i + j]) continue;\\n                start = s[start + j] > s[i + j] ? start : i;\\n                break;\\n            }\\n        }\\n        return s.substr(start);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/last-substring-in-lexicographical-order/\\n// Author: github.com/lzl124631x\\n// Time: O(VL) where V is the length of `v` and L is the max possible `len`.\\n//       It is strictly smaller than O(N^2)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int start = 0, N = s.size();\\n        for (int i = 0; i < N; ++i) {\\n            if (s[i] > s[start]) start = i;\\n        }\\n        vector<int> v;\\n        for (int i = start; i < N; ++i) {\\n            if (s[i] == s[start] && (i == 0 || s[i - 1] != s[start])) v.push_back(i);\\n        }\\n        for (int len = 1; len <= N && v.size() > 1; ++len) {\\n            vector<int> next;\\n            char c = \\'a\\';\\n            for (int n : v) {\\n                if (n + len >= N || s[n + len] < c) continue;\\n                if (s[n + len] > c) {\\n                    next.clear();\\n                    c = s[n + len];\\n                }\\n                next.push_back(n);\\n            }\\n            v = next;\\n        }\\n        return s.substr(v[0]);\\n    }\\n};\\n```\n```\\n i           j\\n[ddac](abac)[ddac]\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/last-substring-in-lexicographical-order/\\n// Author: github.com/lzl124631x\\n// Time: O(N^2)\\n// Space: O(1)\\n// Ref: https://leetcode.com/problems/last-substring-in-lexicographical-order/discuss/360957/C%2B%2B-Brute-Force\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int start = 0, N = s.size(), j;\\n        for (int i = 1; i < N; ++i) {\\n            for (j = 0; i + j < N; ++j) {\\n                if (s[start + j] == s[i + j]) continue;\\n                start = s[start + j] > s[i + j] ? start : i;\\n                break;\\n            }\\n            if (i + j == N) break;\\n        }\\n        return s.substr(start);\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/last-substring-in-lexicographical-order/\\n// Author: github.com/lzl124631x\\n// Time: O(N^2)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int start = 0, N = s.size();\\n        for (int i = 1; i < N; ++i) {\\n            if (s[i] == s[start] && s[i - 1] == s[start]) continue;\\n            for (int j = 0; i + j < N; ++j) {\\n                if (s[start + j] == s[i + j]) continue;\\n                start = s[start + j] > s[i + j] ? start : i;\\n                break;\\n            }\\n        }\\n        return s.substr(start);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361319,
                "title": "c-o-n-pass-hard-case-zbazbazbb-with-detailed-explanation-easy-to-understand",
                "content": "`start` is the start position of previous best solution. And `to_match` is the next position to be matched with the previous best solution. \\n1.  If `s[i]` is larger than `s[start]`, then the current best solution will be updated.  That is, `start` should be `i`.\\n2.1  Otherwise. If `s[to_match]` equals to `s[i]`, then  `to_match` should be updated.\\n2.2 If `s[to_match]` is larger than `s[i]`, then  `to_match` should go back from `start`.\\n2.3 If `s[to_match]` is smaller than `s[i]`, then the current best solution will be updated. \\n```cpp\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int n = s.size();\\n        int start = 0;\\n        int to_match = 0;\\n        for (int i = 1; i < s.size(); ++i) {\\n            if (s[i] > s[start]) {\\n                start = i;\\n                to_match = start;\\n            } \\n            else if (s[to_match] == s[i]) {\\n                to_match ++;\\n            }\\n            else if (s[to_match] > s[i]) {\\n                to_match = start;\\n            }\\n            else if (s[to_match] < s[i]) {\\n                start = i - (to_match - start);\\n                to_match = start;\\n            }\\n        }\\n        return s.substr(start);\\n    }\\n};\\n```\\n\\nBut it does not pass case `zbazbazbb`. \\n`zbazbazbb`\\n `^--------` `start`  \\n`---^-----`  `to_match`\\n`------^--` `current pos`\\nThe problem is that `z` could become a new string instead of padding to previous string.\\nTo solve it, we can move `start` to `to_match` (But there are some problems we will solve later). \\nFor this string `zbazbb`, if `zbbxxx` is larger than `zbazbbxxx`, then everything is fine.\\nBut, if `zbazbbxxx` is larger than `zbbxxx`, then the best solution is one of `{zbazbbxxx,  zbazbazbbxxx}`. Obviously, `zbazbbxxx` is larger than `zbazbazbbxxx`.  \\nTo summary, we need not to consider `zbazbazbbxxx`. We just make current string to `zbazbb`, and set `pre[3] = 3 (\"zba\")`.\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int n = s.size();\\n        vector<int> pre(n, 0);\\n        int start = 0;\\n        int to_match = 0;\\n        int visited = -1;\\n        for (int i = 1; i < s.size(); ++i) {\\n            if (s[i] > s[start]) {\\n                start = i;\\n                to_match = start;\\n            } \\n            else if (s[to_match] == s[i]) {\\n                if (i - start <= 2 * (to_match - start)) {\\n                    pre[to_match] = to_match - start;\\n                    start = to_match;\\n                    to_match = start + 1;\\n                }\\n                else {\\n                    to_match ++;\\n                }\\n            }\\n            else if (s[to_match] > s[i]) {\\n                to_match = start;\\n            }\\n            else if (s[to_match] < s[i]) {\\n                start = i - (to_match - start);\\n                to_match = start;\\n            }\\n        }\\n        int tot = 0;\\n        int pos = start;\\n        while (pos > 0) {\\n            tot += pre[pos];\\n            pos -= pre[pos];\\n            if (pre[pos] == 0) break;\\n        }\\n        return s.substr(start - tot);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int n = s.size();\\n        int start = 0;\\n        int to_match = 0;\\n        for (int i = 1; i < s.size(); ++i) {\\n            if (s[i] > s[start]) {\\n                start = i;\\n                to_match = start;\\n            } \\n            else if (s[to_match] == s[i]) {\\n                to_match ++;\\n            }\\n            else if (s[to_match] > s[i]) {\\n                to_match = start;\\n            }\\n            else if (s[to_match] < s[i]) {\\n                start = i - (to_match - start);\\n                to_match = start;\\n            }\\n        }\\n        return s.substr(start);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int n = s.size();\\n        vector<int> pre(n, 0);\\n        int start = 0;\\n        int to_match = 0;\\n        int visited = -1;\\n        for (int i = 1; i < s.size(); ++i) {\\n            if (s[i] > s[start]) {\\n                start = i;\\n                to_match = start;\\n            } \\n            else if (s[to_match] == s[i]) {\\n                if (i - start <= 2 * (to_match - start)) {\\n                    pre[to_match] = to_match - start;\\n                    start = to_match;\\n                    to_match = start + 1;\\n                }\\n                else {\\n                    to_match ++;\\n                }\\n            }\\n            else if (s[to_match] > s[i]) {\\n                to_match = start;\\n            }\\n            else if (s[to_match] < s[i]) {\\n                start = i - (to_match - start);\\n                to_match = start;\\n            }\\n        }\\n        int tot = 0;\\n        int pos = start;\\n        while (pos > 0) {\\n            tot += pre[pos];\\n            pos -= pre[pos];\\n            if (pre[pos] == 0) break;\\n        }\\n        return s.substr(start - tot);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361241,
                "title": "java-mono-stack-over-100-not-brutal-force",
                "content": "\\n**intuition:**\\nrecord every current largest position in the deque (actually mono stack) ptrs.\\n\\nupdate the deque if the current char is larget than the tail of the deque.\\n\\ngradually compare the following characters behind current candidates.\\n\\nAfter rounds of \\'competition\\', there is only one true winner, which is the real \\'largest\\' one.\\n\\n**Optimization**\\nthere must be a lot of ways to optimize this solution, but currently i only come up with one:\\n\\nFor situations like \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\nwe only need to record the first \"a\" in first round.\\nthat is because \\n1. if   the letter  after  \"aaa....a\" is a larger one (say, \"c\"), then all above a would be poll out since it\\'s mono stack.\\n2. if the letter afterwards is the same, \"a\", then it\\'s still \"aaa.....a\"\\n3. if the letter afterwards is smaller, then record the first \"a\" holds true;\\n\\n\\n**guys, I think there are other potensials in this solution, please help with other optimization~ thx a lot~**\\n\\n```\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        Deque<Integer> ptrs = new ArrayDeque<>();\\n        char[] cs = s.toCharArray();\\n        int n = cs.length, len=0;\\n        List<Integer> cands = new ArrayList<>();\\n        for (int i=0;i<n;i++) cands.add(i);\\n        while (ptrs.size()!=1){\\n            len ++;\\n            ptrs = new ArrayDeque<>();\\n            for (int i: cands){\\n                if (ptrs.size() == 0) ptrs.offerLast(i);\\n                else{\\n                    while (ptrs.size()!=0 && (int)cs[i] > (int)cs[ptrs.peekLast()]){\\n                        ptrs.pollLast();\\n                    }\\n                    if (len==1 && ptrs.size()!=0 && i>0 && cs[i]==cs[i-1]) continue;\\n                    if (ptrs.size()==0 || (int)cs[i] == (int)cs[ptrs.peekLast()]) ptrs.offerLast(i);\\n                }\\n            }\\n            cands = new ArrayList<>();\\n            for (int ptr: ptrs) cands.add(ptr);\\n            for (int i=0;i<cands.size();i++) {\\n                cands.set(i, cands.get(i)+1);\\n                if (cands.get(i)>=n)  cands.remove(i);\\n            }\\n        }\\n        return s.substring(ptrs.peek()-len+1, s.length());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        Deque<Integer> ptrs = new ArrayDeque<>();\\n        char[] cs = s.toCharArray();\\n        int n = cs.length, len=0;\\n        List<Integer> cands = new ArrayList<>();\\n        for (int i=0;i<n;i++) cands.add(i);\\n        while (ptrs.size()!=1){\\n            len ++;\\n            ptrs = new ArrayDeque<>();\\n            for (int i: cands){\\n                if (ptrs.size() == 0) ptrs.offerLast(i);\\n                else{\\n                    while (ptrs.size()!=0 && (int)cs[i] > (int)cs[ptrs.peekLast()]){\\n                        ptrs.pollLast();\\n                    }\\n                    if (len==1 && ptrs.size()!=0 && i>0 && cs[i]==cs[i-1]) continue;\\n                    if (ptrs.size()==0 || (int)cs[i] == (int)cs[ptrs.peekLast()]) ptrs.offerLast(i);\\n                }\\n            }\\n            cands = new ArrayList<>();\\n            for (int ptr: ptrs) cands.add(ptr);\\n            for (int i=0;i<cands.size();i++) {\\n                cands.set(i, cands.get(i)+1);\\n                if (cands.get(i)>=n)  cands.remove(i);\\n            }\\n        }\\n        return s.substring(ptrs.peek()-len+1, s.length());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361202,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public string LastSubstring(string s) \\n    {\\n        int index1 = 0, len = 0;\\n        for (int index2 = 1;  index2 < s.Length; index2++) \\n        {\\n            for(len = 0; index2 + len < s.Length; len++) \\n            {\\n                if (s[index1 + len] != s[index2 + len]) \\n                {\\n                    index1 = s[index1 + len] > s[index2 + len] ? index1 : index2;\\n                    break;\\n                }\\n            }\\n            \\n            if (index2 + len == s.Length) \\n                break;    \\n        }\\n        \\n        return s.Substring(index1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public string LastSubstring(string s) \\n    {\\n        int index1 = 0, len = 0;\\n        for (int index2 = 1;  index2 < s.Length; index2++) \\n        {\\n            for(len = 0; index2 + len < s.Length; len++) \\n            {\\n                if (s[index1 + len] != s[index2 + len]) \\n                {\\n                    index1 = s[index1 + len] > s[index2 + len] ? index1 : index2;\\n                    break;\\n                }\\n            }\\n            \\n            if (index2 + len == s.Length) \\n                break;    \\n        }\\n        \\n        return s.Substring(index1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361155,
                "title": "python-substring-iterative",
                "content": "The **algorithm** is as follows:\\n* find indexes of max characters, which define starting points of substrings\\n* consider every of those indexes as a new root and start iteration, which ends when we are left with only 1 substring\\n\\t* evaluate 1 next character of every substring\\n\\t* remove substrings which haven\\'t continued in new max character\\n\\t* check if some substrings merged\\n\\nExplanation of some algorithm points:\\n* find indexes of **max characters**\\n\"zazaza\"\\nindexes will be: 0, 2, 4\\n\\n\\n\\n```\\nclass Solution(object):\\n\\n    def lastSubstring(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"   \\n        s = list(s)\\n        max_character = s[0]\\n        max_indexes = []\\n        \\n        ## find candidates for beginning of the last substring\\n        for i, c in enumerate(s):\\n            if c > max_character:\\n                max_character = c\\n                max_indexes = [i]\\n            elif c == max_character:\\n                max_indexes.append(i)\\n        \\n        return self.findLastSubstring(max_indexes, s)\\n\\t\\t\\n\\t\\t\\n    def findLastSubstring(self, max_indexes, s):\\n        \\n        visited_indexes = set(max_indexes)\\n        next_indexes = max_indexes[:]\\n        iteration = 1\\n        \\n        while True:\\n            \\n            ## if next_indexes contains only 1 element\\n            ## it means that we are left with only 1 substring\\n            ## which is then surely the last one\\n            \\n            if len(next_indexes) == 1:\\n                break\\n            \\n            next_max_indexes = []\\n            next_max_characters = []\\n            \\n            \\n            ## find next character for every single\\n            ## substring candidate\\n            \\n            for idx in next_indexes:\\n                if idx+iteration == len(s):\\n                    break\\n                next_max_characters.append(s[idx+iteration])\\n                next_max_indexes.append(idx)\\n                \\n            \\n            temp_next_indexes = []\\n            max_character = max(next_max_characters)\\n            \\n            next_set = set(next_indexes)\\n            for idx in next_max_indexes:\\n                if s[idx+iteration] == max_character:\\n                    # check for merge of substrings\\n                    # this is a case when current substring\\n                    # actually continues on one of the previous substrings\\n                    if idx-iteration in next_set:\\n                        continue\\n                    else:\\n                        temp_next_indexes.append(idx)\\n            \\n            next_indexes = temp_next_indexes[:]\\n            iteration += 1\\n        \\n        max_index = next_indexes[0]\\n        \\n        return \\'\\'.join(s[max_index:]) \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n\\n    def lastSubstring(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"   \\n        s = list(s)\\n        max_character = s[0]\\n        max_indexes = []\\n        \\n        ## find candidates for beginning of the last substring\\n        for i, c in enumerate(s):\\n            if c > max_character:\\n                max_character = c\\n                max_indexes = [i]\\n            elif c == max_character:\\n                max_indexes.append(i)\\n        \\n        return self.findLastSubstring(max_indexes, s)\\n\\t\\t\\n\\t\\t\\n    def findLastSubstring(self, max_indexes, s):\\n        \\n        visited_indexes = set(max_indexes)\\n        next_indexes = max_indexes[:]\\n        iteration = 1\\n        \\n        while True:\\n            \\n            ## if next_indexes contains only 1 element\\n            ## it means that we are left with only 1 substring\\n            ## which is then surely the last one\\n            \\n            if len(next_indexes) == 1:\\n                break\\n            \\n            next_max_indexes = []\\n            next_max_characters = []\\n            \\n            \\n            ## find next character for every single\\n            ## substring candidate\\n            \\n            for idx in next_indexes:\\n                if idx+iteration == len(s):\\n                    break\\n                next_max_characters.append(s[idx+iteration])\\n                next_max_indexes.append(idx)\\n                \\n            \\n            temp_next_indexes = []\\n            max_character = max(next_max_characters)\\n            \\n            next_set = set(next_indexes)\\n            for idx in next_max_indexes:\\n                if s[idx+iteration] == max_character:\\n                    # check for merge of substrings\\n                    # this is a case when current substring\\n                    # actually continues on one of the previous substrings\\n                    if idx-iteration in next_set:\\n                        continue\\n                    else:\\n                        temp_next_indexes.append(idx)\\n            \\n            next_indexes = temp_next_indexes[:]\\n            iteration += 1\\n        \\n        max_index = next_indexes[0]\\n        \\n        return \\'\\'.join(s[max_index:]) \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361151,
                "title": "python-concise-one-pass-o-n-time-o-1-space-very-detailed-explanation",
                "content": "\\nThanks @deleted_user who figured out the flaw in my previous answer, I have improved my algorithm to make it real O(n) time and O(1) space.\\n\\nThe basic idea is simple: finding the biggest chars in the whole string, comparing their substrings and pick up the biggest. The difficult part is doing it in O(n) time and O(1) space in one-pass.\\n\\nThe most important fact is that:\\nWhen two substrings overlapps each other during comparing, we choose the first one as winner, even though it might be smaller than the 2nd one. \\n\\nThis might be a little bit hard to understand:\\ne.g. for \"**z**abc**z**abc...\"\\nThere are two \"z\" here, we don\\'t know which \"z\" substring is bigger because of the uncertainty \"...\" part in the end. \\nIf the 1st \"z\" substring is bigger, then of course it wins. But if the 2nd \"z\" substring is bigger, that means the last \"...\" part must be something like \"zb...\", which is bigger than the 2nd \"z\" substring, so it doesn\\'t matter who wins anymore when the 2nd \"z\" is bigger, because some substring in the last \"...\" part will beat them both. In both case, we can choose the 1st \"z\" as winner and make it to the next iteration of comparison.\\nThe understanding of this very fact justifies this problem to be of \"Hard\" difficulty.\\n\\nI managed to optimize the above idea with a two-pointer way, taking only O(1) memory and finishes in one-pass.\\n\\n\"slow\" points to the beginning of biggest substring.\\n\"fast\" points to the end of current substring.\\n\"compareCnt\" is the count of chars already compared between slow and fast substrings. \\nDuring the one-pass scan, we keep updating the \"slow\" pointer to the head of new bigger substring, and clearing \"compareCnt\" to zero.\\nBecause of the nature that \"the biggest substring must always extend to the end of s\", the final answer should be \"s[slow:]\".\\n\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        slow,compareCnt,n=0,0,len(s)\\n        for fast in range(1,n):\\n            if s[fast]!=s[slow+compareCnt] or slow+compareCnt==fast-compareCnt-1:\\n                if s[fast]>s[slow+compareCnt]:\\n                    slow=fast if s[fast]>s[slow] else fast-compareCnt\\n                compareCnt=0\\n            else:\\n                compareCnt+=1\\n        return s[slow:]\\n```\\n\\n\\n\\n**Old Answer:**\\n\\nBased on the fact that the biggest substring must always reach the end of \"s\".\\ne.g., if \"s\" has length of 10, then biggest substring might be from index 0~9, 1~9, 2~9, ..., but it could never be from index 1~2, 2~3, 3~4.\\nUsing this nature, I scan \"s\" from end to beginning, each time compare current idx~end substring with previous idx+1~end substring, and update the biggest substring.\\nSince only one char is introduced each time in such comparasion, I though this makes time complexity O(n). \\nBut [Caloplaca](https://leetcode.com/caloplaca/) pointed out that it is actually O(n^2) in senario of \"ba\"\\\\*n+\"a\"+\"ba\"\\\\*n+\"b\".\\n\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        n=len(s)\\n        maxIdx=-1\\n        for i in range(n-1,-1,-1):\\n            if maxIdx>=0 and s[i]>s[maxIdx]:\\n                maxIdx=i\\n            elif s[i]==s[maxIdx]:\\n                isSmaller=False\\n                for k in range(1,min(maxIdx-i,n-maxIdx)):\\n                    if s[i+k]!=s[maxIdx+k]:\\n                        isSmaller=s[i+k]<s[maxIdx+k]\\n                        break\\n                if not isSmaller:\\n                    maxIdx=i\\n        return s[maxIdx:] if maxIdx>=0 else \\'\\'\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        slow,compareCnt,n=0,0,len(s)\\n        for fast in range(1,n):\\n            if s[fast]!=s[slow+compareCnt] or slow+compareCnt==fast-compareCnt-1:\\n                if s[fast]>s[slow+compareCnt]:\\n                    slow=fast if s[fast]>s[slow] else fast-compareCnt\\n                compareCnt=0\\n            else:\\n                compareCnt+=1\\n        return s[slow:]\\n```\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        n=len(s)\\n        maxIdx=-1\\n        for i in range(n-1,-1,-1):\\n            if maxIdx>=0 and s[i]>s[maxIdx]:\\n                maxIdx=i\\n            elif s[i]==s[maxIdx]:\\n                isSmaller=False\\n                for k in range(1,min(maxIdx-i,n-maxIdx)):\\n                    if s[i+k]!=s[maxIdx+k]:\\n                        isSmaller=s[i+k]<s[maxIdx+k]\\n                        break\\n                if not isSmaller:\\n                    maxIdx=i\\n        return s[maxIdx:] if maxIdx>=0 else \\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361112,
                "title": "python3-dp-solution-step-by-step-explanations-o-n-2-time-and-o-1-space",
                "content": "**THIS POST IS WRONG, PLEASE JUST IGNORE IT**\\n**THIS POST IS WRONG, PLEASE JUST IGNORE IT**\\n**THIS POST IS WRONG, PLEASE JUST IGNORE IT**\\n**THIS POST IS WRONG, PLEASE JUST IGNORE IT**\\n**THIS POST IS WRONG, PLEASE JUST IGNORE IT**\\n**THIS POST IS WRONG, PLEASE JUST IGNORE IT**\\n**THIS POST IS WRONG, PLEASE JUST IGNORE IT**\\n**THIS POST IS WRONG, PLEASE JUST IGNORE IT**\\n**THIS POST IS WRONG, PLEASE JUST IGNORE IT**\\n**THIS POST IS WRONG, PLEASE JUST IGNORE IT**\\n\\nThis problem seems very difficult at first, but with some effort, I finally figured it out during the contest. **Here is my solutions, step by step, from failing to accepting.**\\n\\n## **First thought: Brute force? (NO WAY!)**\\nLet\\'s analyze the time complexity of BF:\\n1.  Enumerate all possible substrings, it\\'s `O(n^2)`\\n2.  For each substring, we need to compare it with the maximal substring, it\\'s O(n).\\nTherefore, BF takes `O(n^3)` time and obviously it won\\'t work for `n = 10^5`\\n\\n## **Naive thought: DFS? (TLE!)**\\nThink about it, the last substring in lexicographical order must start with the maximal chararter in the string: for example, `abab`\\'s last substring can only begin with `b`.\\nThen it comes to my mind the DFS solution: \\n1. Given a string, find all positions of its maximal character.\\n2. If there\\'s only one occurrence of the maximal character, then the last substring must be the substring that starts with the maximal character and goes until the end.\\n3. If there\\'re multiple occurrences, okay, we just do the DFS and take the maximum among them. \\n\\n**Here is the code:** It works correctly, but gets **TLE**.\\n```python\\nimport functools\\nclass Solution:\\n    @functools.lru_cache(None)\\n    def lastSubstring(self, s: str) -> str:\\n        if len(s) <= 1:\\n            return s\\n        max_char = s[0]\\n        pos = [0,]\\n        for i, x in enumerate(s[1:]):\\n            if x == max_char:\\n                pos.append(i + 1)\\n            elif x > max_char:\\n                max_char = x\\n                pos = [i + 1,]\\n        # print(max_char, pos)\\n        if len(pos) == 1:\\n            return s[pos[0]:]\\n        else:\\n            return max(self.lastSubstring(s[p:]) if p != 0 else s for p in reversed(pos))\\n```\\n## **Almost correct: DP? (MLE)** \\nYou may have noticed, instead of processing from left to right in the DFS solution, why not do it in an opposite way? **Aha, here comes the DP!**\\n\\nThe idea behind is quite similar to the DFS solution, but we just do it form right to left with DP.\\n\\nLet\\'s analyze its complexity again:\\n1. Time complexity: `O(n^2)`  (`O(n)` for iteration and `O(n)` for function `max`)\\n2. Space complexity: `O(n)`\\n\\nSeems to work? Okay, let\\'s submit it~ Oh no, it gets **MLE (memory limit exceed)!**\\n\\nWhy? The online judge gives us the test input:\\n```\"aaaaaaa.......(omitted).....aaaaa\"```\\n**Well, maybe we need to  do some extra works. (see next section)**\\n\\n```python\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        n = len(s)\\n        dp = [\"\",] * n\\n        dp[-1] = s[-1]\\n        max_char = s[-1]\\n        pos = [n - 1,]\\n        for i in range(n - 2, -1 , -1):\\n            if s[i] < max_char:\\n                dp[i] = dp[i + 1]\\n            elif s[i] > max_char:\\n                dp[i] = s[i:]\\n                max_char = s[i]\\n                pos = [i,]\\n            else:\\n                dp[i] = max(dp[pos[-1]], s[i:])\\n                pos.append(i)\\n        return dp[0]\\n```\\n\\n## **Final hit: Optimized DP? (Accepted!)**\\n\\nOur trivial DP solution is almost correct, but is it perfect?  No, actually, we do not need to store the whole `dp` array.\\n\\nIn the previous DP solution, we have such three statements:\\n```python\\ndp[i] = dp[i + 1]\\ndp[i] = s[i:]\\ndp[i] = max(dp[pos[-1]], s[i:])\\n```\\nWithout much effort, we can find that `dp[i]` only relies on `s[i:]` and \"last dp value\".\\n\\nTherefore, the optimized DP solution is:\\n\\n```python\\n    def lastSubstring(self, s: str) -> str:\\n        n = len(s)\\n        last = s[-1]\\n        max_char = s[-1]\\n        for i in range(n - 2, -1 , -1):\\n            if s[i] < max_char:\\n                pass\\n            elif s[i] > max_char:\\n                last = s[i:]\\n                max_char = s[i]\\n            else:\\n                last = max(s[i:], last)\\n        return last\\n```\\n\\nIt takes still  `O(n^2)` time, but only `O(1)` space! And happily, it\\'s accepted!",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nimport functools\\nclass Solution:\\n    @functools.lru_cache(None)\\n    def lastSubstring(self, s: str) -> str:\\n        if len(s) <= 1:\\n            return s\\n        max_char = s[0]\\n        pos = [0,]\\n        for i, x in enumerate(s[1:]):\\n            if x == max_char:\\n                pos.append(i + 1)\\n            elif x > max_char:\\n                max_char = x\\n                pos = [i + 1,]\\n        # print(max_char, pos)\\n        if len(pos) == 1:\\n            return s[pos[0]:]\\n        else:\\n            return max(self.lastSubstring(s[p:]) if p != 0 else s for p in reversed(pos))\\n```\n```\"aaaaaaa.......(omitted).....aaaaa\"```\n```python\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        n = len(s)\\n        dp = [\"\",] * n\\n        dp[-1] = s[-1]\\n        max_char = s[-1]\\n        pos = [n - 1,]\\n        for i in range(n - 2, -1 , -1):\\n            if s[i] < max_char:\\n                dp[i] = dp[i + 1]\\n            elif s[i] > max_char:\\n                dp[i] = s[i:]\\n                max_char = s[i]\\n                pos = [i,]\\n            else:\\n                dp[i] = max(dp[pos[-1]], s[i:])\\n                pos.append(i)\\n        return dp[0]\\n```\n```python\\ndp[i] = dp[i + 1]\\ndp[i] = s[i:]\\ndp[i] = max(dp[pos[-1]], s[i:])\\n```\n```python\\n    def lastSubstring(self, s: str) -> str:\\n        n = len(s)\\n        last = s[-1]\\n        max_char = s[-1]\\n        for i in range(n - 2, -1 , -1):\\n            if s[i] < max_char:\\n                pass\\n            elif s[i] > max_char:\\n                last = s[i:]\\n                max_char = s[i]\\n            else:\\n                last = max(s[i:], last)\\n        return last\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361088,
                "title": "easy-solution-for-everyone-with-detail-explanation",
                "content": "1. The last character of the answer is always the last character of the string.\\n2. The fisrt character of the answer is always the biggest character of the string.\\n3. Search the biggest character in the string and save its position, we compare characters, NOT substrings! (TLE)\\n4. If the biggest character repeats in the string multiple times, now we compare subtrings.\\n For example, `s = \"leetcodetest\"`. `\\'t\\'` is the biggest one, but it comes in 3 times, we compare `\"tcodetest\"`, `\"test\"` and `\"t\"` using `compareTo` in Java or `localeCompare` in Javascript, ... and got `\"test\"`\\n```\\n\\nvar lastSubstring = function(s) {\\n  let maxChar = s[0], maxCharIndex = 0;  \\n  for (let i = 1 ; i<s.length; i++) {  \\n    if(s[i]>maxChar) {\\n      maxChar = s[i];\\n      maxCharIndex = i;\\n    }\\n    else if(maxChar == s[i]) {\\n      if(s.substring(maxCharIndex).localeCompare(s.substring(i))<0) {\\n        maxChar = s[i];\\n        maxCharIndex = i;\\n      }\\n    }\\n  }  \\n\\n  return s.substring(maxCharIndex);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvar lastSubstring = function(s) {\\n  let maxChar = s[0], maxCharIndex = 0;  \\n  for (let i = 1 ; i<s.length; i++) {  \\n    if(s[i]>maxChar) {\\n      maxChar = s[i];\\n      maxCharIndex = i;\\n    }\\n    else if(maxChar == s[i]) {\\n      if(s.substring(maxCharIndex).localeCompare(s.substring(i))<0) {\\n        maxChar = s[i];\\n        maxCharIndex = i;\\n      }\\n    }\\n  }  \\n\\n  return s.substring(maxCharIndex);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 360988,
                "title": "c-simple-solution-appears-to-be-easy-medium-question",
                "content": "Simply find the char that is lexicographically largest and compare all the substrings starting with that char.\\nWe only take note of \\'start\\' of the maximum substring found in this fashion and return the s[start..end] at program termination.\\n\\nAny doubts, welcome to discuss :)\\n\\n```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int mx = 0;\\n        int start = -1;\\n\\t\\t//find largest char\\n        for(int i = 0; i < s.size(); i++){\\n            mx = max(mx, s[i]-\\'a\\');\\n        }\\n        char c = \\'a\\'+mx;\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == c){\\n                if(start == -1){\\n                    start = i;\\n                }else{\\n                    //Check if we need to update start i.e if prev(start..) substring is less than new(i..)\\n                    int prev = start+1;\\n                    int nw = i+1;\\n                    while(nw < s.size()){\\n                        if(s[prev] < s[nw]){\\n                            start = i;\\n                        }else if(s[prev] > s[nw]){\\n                            break;\\n                        }\\n                        prev++;\\n                        nw++;\\n                    }\\n                }\\n                //We will find the first occurence of \\'c\\' that is followed by a different char, because that is what we would like to test next\\n                while(i < s.size() && s[i] == c) i++;\\n                i--;\\n            }\\n        }\\n        return s.substr(start);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int mx = 0;\\n        int start = -1;\\n\\t\\t//find largest char\\n        for(int i = 0; i < s.size(); i++){\\n            mx = max(mx, s[i]-\\'a\\');\\n        }\\n        char c = \\'a\\'+mx;\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == c){\\n                if(start == -1){\\n                    start = i;\\n                }else{\\n                    //Check if we need to update start i.e if prev(start..) substring is less than new(i..)\\n                    int prev = start+1;\\n                    int nw = i+1;\\n                    while(nw < s.size()){\\n                        if(s[prev] < s[nw]){\\n                            start = i;\\n                        }else if(s[prev] > s[nw]){\\n                            break;\\n                        }\\n                        prev++;\\n                        nw++;\\n                    }\\n                }\\n                //We will find the first occurence of \\'c\\' that is followed by a different char, because that is what we would like to test next\\n                while(i < s.size() && s[i] == c) i++;\\n                i--;\\n            }\\n        }\\n        return s.substr(start);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360976,
                "title": "c-o-nlogn-worst-case",
                "content": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        string ans;\\n        vector<int> candidates, next_candidates;\\n        candidates.resize(s.size());\\n        iota(candidates.begin(), candidates.end(), 0);\\n        \\n        while(candidates.size()>1){\\n            char best_next_char= \\'a\\'-1;\\n            \\n            for(auto i: candidates){\\n                if(i==s.size()) continue;\\n                best_next_char= max(best_next_char, s[i]);\\n            }\\n            \\n            for(auto i: candidates){\\n                if(i==s.size()) continue;\\n                if( best_next_char == s[i]\\n                   &&\\n                   (!next_candidates.size()\\n                    ||\\n                    next_candidates.back() != i - ans.size() // \"cbacba...\" is always more than \"cba...\" this is important for complexity\\n                   )\\n                  ) next_candidates.push_back(i+1);            \\n            }\\n            ans+= best_next_char;\\n            swap(candidates, next_candidates);\\n            next_candidates.resize(0);\\n        }\\n        for(int i= candidates[0]; i< s.size(); ++i) ans+= s[i];\\n        return ans;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        string ans;\\n        vector<int> candidates, next_candidates;\\n        candidates.resize(s.size());\\n        iota(candidates.begin(), candidates.end(), 0);\\n        \\n        while(candidates.size()>1){\\n            char best_next_char= \\'a\\'-1;\\n            \\n            for(auto i: candidates){\\n                if(i==s.size()) continue;\\n                best_next_char= max(best_next_char, s[i]);\\n            }\\n            \\n            for(auto i: candidates){\\n                if(i==s.size()) continue;\\n                if( best_next_char == s[i]\\n                   &&\\n                   (!next_candidates.size()\\n                    ||\\n                    next_candidates.back() != i - ans.size() // \"cbacba...\" is always more than \"cba...\" this is important for complexity\\n                   )\\n                  ) next_candidates.push_back(i+1);            \\n            }\\n            ans+= best_next_char;\\n            swap(candidates, next_candidates);\\n            next_candidates.resize(0);\\n        }\\n        for(int i= candidates[0]; i< s.size(); ++i) ans+= s[i];\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999157,
                "title": "easy-brute-force-in-python3-that-barely-passes",
                "content": "# Code\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        res = s\\n        N = len(s)\\n        for i in range(N):\\n            res = max(res,s[i:])\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        res = s\\n        N = len(s)\\n        for i in range(N):\\n            res = max(res,s[i:])\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788550,
                "title": "100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        int i = 0;\\n        int j = 1;\\n        int k = 0;\\n        int n = s.length();\\n        char[] ca = s.toCharArray();\\n\\n        while (j + k < n){\\n            if (ca[i + k] == ca[j + k]) {\\n                k++;\\n            } else if (ca[i + k] > ca[j + k]) {\\n                j = j + k + 1;\\n                k = 0;\\n            } else {\\n                i = Math.max(i + k + 1, j);\\n                j = i + 1;\\n                k = 0;\\n            }\\n        }\\n        return s.substring(i);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        int i = 0;\\n        int j = 1;\\n        int k = 0;\\n        int n = s.length();\\n        char[] ca = s.toCharArray();\\n\\n        while (j + k < n){\\n            if (ca[i + k] == ca[j + k]) {\\n                k++;\\n            } else if (ca[i + k] > ca[j + k]) {\\n                j = j + k + 1;\\n                k = 0;\\n            } else {\\n                i = Math.max(i + k + 1, j);\\n                j = i + 1;\\n                k = 0;\\n            }\\n        }\\n        return s.substring(i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713109,
                "title": "slow",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        n = len(s)\\n        max_substring = \"\"\\n        max_char = \"\"\\n\\n        for i in range(n - 1, -1, -1):\\n            if s[i] > max_char:\\n                max_char = s[i]\\n                max_substring = s[i:]\\n            elif s[i] == max_char:\\n                if s[i:] > max_substring:\\n                    max_substring = s[i:]\\n\\n        return max_substring\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        n = len(s)\\n        max_substring = \"\"\\n        max_char = \"\"\\n\\n        for i in range(n - 1, -1, -1):\\n            if s[i] > max_char:\\n                max_char = s[i]\\n                max_substring = s[i:]\\n            elif s[i] == max_char:\\n                if s[i:] > max_substring:\\n                    max_substring = s[i:]\\n\\n        return max_substring\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701208,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def lastSubstring(s: String): String = {\\n      s.substring((s.length - 1 to 0 by -1).foldLeft(s.length - 1){(maxIdx, currIdx)=>\\n        if (s.charAt(currIdx) > s.charAt(maxIdx)) currIdx\\n        else if (s.charAt(currIdx) == s.charAt(maxIdx)) {\\n          var i = currIdx + 1\\n          var j = maxIdx + 1\\n          while (i < maxIdx && j < s.length && s.charAt(i) == s.charAt(j)) {\\n            i += 1\\n            j += 1\\n          }\\n          if (i == maxIdx || j == s.length || s.charAt(i) > s.charAt(j)) currIdx\\n          else maxIdx\\n        } else maxIdx\\n      })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def lastSubstring(s: String): String = {\\n      s.substring((s.length - 1 to 0 by -1).foldLeft(s.length - 1){(maxIdx, currIdx)=>\\n        if (s.charAt(currIdx) > s.charAt(maxIdx)) currIdx\\n        else if (s.charAt(currIdx) == s.charAt(maxIdx)) {\\n          var i = currIdx + 1\\n          var j = maxIdx + 1\\n          while (i < maxIdx && j < s.length && s.charAt(i) == s.charAt(j)) {\\n            i += 1\\n            j += 1\\n          }\\n          if (i == maxIdx || j == s.length || s.charAt(i) > s.charAt(j)) currIdx\\n          else maxIdx\\n        } else maxIdx\\n      })\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3604896,
                "title": "hashing-and-binary-search",
                "content": "**Hashing is the most powerful Weapon, If you are in courtesy of Strings, So enjoy with Hashing...**\\n\\n# Code\\n```\\nconst int P = 37, mod = 1e9+9;\\nclass Solution {\\npublic:\\n    int powmod(int a,int b){\\n        int res = 1;\\n        while(b > 0){\\n            if(b % 2){\\n                res = (1ll* res * a)%mod;\\n                b --;\\n            }\\n            else{\\n                a = (1ll * a * a)%mod;\\n                b /= 2;\\n            }\\n        }\\n        return res;\\n    }\\n    int inv(int a){\\n        return powmod(a, mod-2);\\n    }\\n    string lastSubstring(string s) {\\n        int n = s.size();\\n        vector<int>hash(n);\\n        hash[0] = s[0] - \\'a\\';\\n        for(int i=1;i<n;i++){\\n            hash[i] = (1ll * (s[i] - \\'a\\') * powmod(P, i))%mod;\\n            hash[i] = (hash[i] + hash[i-1])%mod;\\n        }\\n\\n        vector<int>inv_P(n+1);\\n        for(int i=0;i<=n;i++){\\n            inv_P[i] = inv(powmod(P, i));\\n        }\\n\\n        int j = 0;\\n        for(int i=1;i<n;i++){\\n            if(s[i] != s[j]){\\n                if(s[i] < s[j]){\\n                    continue;\\n                }\\n                else{\\n                    j = i;\\n                    continue;\\n                }\\n            }\\n            int l = 1, r = n-i; // length of common prefix\\n            while(l < r){\\n                int mid = (l+r+1)/2;\\n                // [j, j+mid-1], [i, i+mid-1]\\n                int hsh1 = hash[j+mid-1];\\n                if(j-1 >= 0){\\n                    hsh1 = (hsh1 - hash[j-1] + mod)%mod;\\n                    hsh1 = (1ll * hsh1 * inv_P[j])%mod;\\n                }\\n                int hsh2 = hash[i+mid-1];\\n                if(i-1 >= 0){\\n                    hsh2 = (hsh2 - hash[i-1] + mod)%mod;\\n                    hsh2 = (1ll * hsh2 * inv_P[i])%mod;\\n                }\\n                if(hsh1 == hsh2){\\n                    l = mid;\\n                } \\n                else{\\n                    r = mid - 1;\\n                }\\n            }\\n            // l -> length common prefix\\n            if(i+l >= n){\\n                continue;\\n            }\\n            else{\\n                if(s[i+l] > s[j+l]){\\n                    j = i;\\n                }\\n            }\\n        }\\n\\n        string ans = \"\";\\n        for(int i=j;i<n;i++){\\n            ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Rolling Hash"
                ],
                "code": "```\\nconst int P = 37, mod = 1e9+9;\\nclass Solution {\\npublic:\\n    int powmod(int a,int b){\\n        int res = 1;\\n        while(b > 0){\\n            if(b % 2){\\n                res = (1ll* res * a)%mod;\\n                b --;\\n            }\\n            else{\\n                a = (1ll * a * a)%mod;\\n                b /= 2;\\n            }\\n        }\\n        return res;\\n    }\\n    int inv(int a){\\n        return powmod(a, mod-2);\\n    }\\n    string lastSubstring(string s) {\\n        int n = s.size();\\n        vector<int>hash(n);\\n        hash[0] = s[0] - \\'a\\';\\n        for(int i=1;i<n;i++){\\n            hash[i] = (1ll * (s[i] - \\'a\\') * powmod(P, i))%mod;\\n            hash[i] = (hash[i] + hash[i-1])%mod;\\n        }\\n\\n        vector<int>inv_P(n+1);\\n        for(int i=0;i<=n;i++){\\n            inv_P[i] = inv(powmod(P, i));\\n        }\\n\\n        int j = 0;\\n        for(int i=1;i<n;i++){\\n            if(s[i] != s[j]){\\n                if(s[i] < s[j]){\\n                    continue;\\n                }\\n                else{\\n                    j = i;\\n                    continue;\\n                }\\n            }\\n            int l = 1, r = n-i; // length of common prefix\\n            while(l < r){\\n                int mid = (l+r+1)/2;\\n                // [j, j+mid-1], [i, i+mid-1]\\n                int hsh1 = hash[j+mid-1];\\n                if(j-1 >= 0){\\n                    hsh1 = (hsh1 - hash[j-1] + mod)%mod;\\n                    hsh1 = (1ll * hsh1 * inv_P[j])%mod;\\n                }\\n                int hsh2 = hash[i+mid-1];\\n                if(i-1 >= 0){\\n                    hsh2 = (hsh2 - hash[i-1] + mod)%mod;\\n                    hsh2 = (1ll * hsh2 * inv_P[i])%mod;\\n                }\\n                if(hsh1 == hsh2){\\n                    l = mid;\\n                } \\n                else{\\n                    r = mid - 1;\\n                }\\n            }\\n            // l -> length common prefix\\n            if(i+l >= n){\\n                continue;\\n            }\\n            else{\\n                if(s[i+l] > s[j+l]){\\n                    j = i;\\n                }\\n            }\\n        }\\n\\n        string ans = \"\";\\n        for(int i=j;i<n;i++){\\n            ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602924,
                "title": "python-two-pointers-2023-06-06",
                "content": "# Intuition\\n\\nfirst, find indices of lexicographically largest character by hashmap {ch: [...indices]}\\n\\nsince answer must be within every possible suffix string `s[i:] where i in index[biggestCh] `\\n\\nlet\\'s choose first 2 smallest indices since the longer the larger and maintain `i` **always smaller than** `j`\\n\\n```\\n[XXXXXXXXX]XXXXXXX\\n i       k\\n______[XXXXXXXXX]XXXXXX\\n       j       k\\n```\\n\\nand we move these two pointers by a distance `k` and keep comparing s[i+k] with s[j+k]\\n\\n- if s[i+k] == s[j+k]:\\n  - compare next character by incrementing k\\n- if s[i+k] > s[j+k]:\\n  - it means all the s[jj:] where j < jj <= j+k are smaller than s[i:]\\n  - `j` start from `j+k+1` and move to next biggest character and keep comaparing s[i+k] and s[j+k]\\n  - reset k to 0\\n- if s[i+k] > s[j+k], same as bove:\\n  - it means all the s[ii:] where i < ii <= i+k are smaller than s[j:]\\n  - `i` start from `i+k+1` and move to next biggest character and keep comaparing s[i+k] and s[j+k]\\n  - reset k to 0\\n  - special case:\\n    - if i == j, move j to next biggest character position since we want to compare two different suffix string\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def lastSubstring(self, s):\\n        index = defaultdict(list)\\n        biggestCh = \"\"\\n        for i, c in enumerate(s):\\n            index[c].append(i)\\n            biggestCh = max(biggestCh, c)\\n\\n        if len(index[biggestCh]) == 1:\\n            return s[index[biggestCh][0]:]\\n\\n        n = len(s)\\n        i, j = index[biggestCh][0], index[biggestCh][1]\\n        k = 1\\n        while i+k < n and j+k < n:\\n            if s[i+k] == s[j+k]: # if equal, keep moving k and compare next character\\n                k += 1\\n                continue\\n            elif s[i+k] > s[j+k]:\\n                j = j+k+1\\n                while j < n and s[j] != biggestCh:\\n                    j += 1\\n                k = 0\\n            else: # s[i+k] < s[j+k]\\n                i = i+k+1\\n                while i < n and s[i] != biggestCh:\\n                    i += 1\\n                k = 0\\n\\n                if i == j:\\n                    j += 1\\n                    while j < n and s[j] != biggestCh:\\n                        j += 1\\n        return s[i:]\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\n[XXXXXXXXX]XXXXXXX\\n i       k\\n______[XXXXXXXXX]XXXXXX\\n       j       k\\n```\n```\\nclass Solution:\\n    def lastSubstring(self, s):\\n        index = defaultdict(list)\\n        biggestCh = \"\"\\n        for i, c in enumerate(s):\\n            index[c].append(i)\\n            biggestCh = max(biggestCh, c)\\n\\n        if len(index[biggestCh]) == 1:\\n            return s[index[biggestCh][0]:]\\n\\n        n = len(s)\\n        i, j = index[biggestCh][0], index[biggestCh][1]\\n        k = 1\\n        while i+k < n and j+k < n:\\n            if s[i+k] == s[j+k]: # if equal, keep moving k and compare next character\\n                k += 1\\n                continue\\n            elif s[i+k] > s[j+k]:\\n                j = j+k+1\\n                while j < n and s[j] != biggestCh:\\n                    j += 1\\n                k = 0\\n            else: # s[i+k] < s[j+k]\\n                i = i+k+1\\n                while i < n and s[i] != biggestCh:\\n                    i += 1\\n                k = 0\\n\\n                if i == j:\\n                    j += 1\\n                    while j < n and s[j] != biggestCh:\\n                        j += 1\\n        return s[i:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567394,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n  public:\\n    string lastSubstring(string s) {\\n      int i = 0, j = 1, k = 0, n = int(s.length());\\n      while ((j + k) < n) {\\n        if (s[i + k] == s[j + k]) k++;\\n        else if (s[i + k] > s[j + k]) {\\n          j += k + 1;\\n          k = 0;\\n        } else {\\n          i = std::max(i + k + 1, j);\\n          j = i + 1;\\n          k = 0;\\n        }\\n      }\\n      return s.substr(i);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        n = len(s)\\n        cmax = max(s)\\n        indexes = [ i for i,c in enumerate(s) if c == cmax ]\\n        gap = 1\\n        while len(indexes) > 1:\\n            new_indexes = []\\n            cmax = max(s[i+gap] for i in indexes if i+gap < n)\\n            for i,st in enumerate(indexes):\\n                if i > 0 and indexes[i-1] + gap == st: continue\\n                if st + gap < n and s[st + gap] == cmax:new_indexes.append(st)\\n            indexes = new_indexes\\n            gap += 1\\n        return s[indexes[0]:]\\n```\\n\\n```Java []\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        int i = 0;\\n        int j = 1;\\n        int k = 0;\\n        int n = s.length();\\n        char[] ca = s.toCharArray();\\n\\n        while (j + k < n) {\\n            if (ca[i + k] == ca[j + k]) {\\n                k++;\\n            } else if (ca[i + k] > ca[j + k]) {\\n                j = j + k + 1;\\n                k = 0;\\n            } else {\\n                i = Math.max(i + k + 1, j);\\n                j = i + 1;\\n                k = 0;\\n            }\\n        }\\n        return s.substring(i);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n  public:\\n    string lastSubstring(string s) {\\n      int i = 0, j = 1, k = 0, n = int(s.length());\\n      while ((j + k) < n) {\\n        if (s[i + k] == s[j + k]) k++;\\n        else if (s[i + k] > s[j + k]) {\\n          j += k + 1;\\n          k = 0;\\n        } else {\\n          i = std::max(i + k + 1, j);\\n          j = i + 1;\\n          k = 0;\\n        }\\n      }\\n      return s.substr(i);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        n = len(s)\\n        cmax = max(s)\\n        indexes = [ i for i,c in enumerate(s) if c == cmax ]\\n        gap = 1\\n        while len(indexes) > 1:\\n            new_indexes = []\\n            cmax = max(s[i+gap] for i in indexes if i+gap < n)\\n            for i,st in enumerate(indexes):\\n                if i > 0 and indexes[i-1] + gap == st: continue\\n                if st + gap < n and s[st + gap] == cmax:new_indexes.append(st)\\n            indexes = new_indexes\\n            gap += 1\\n        return s[indexes[0]:]\\n```\n```Java []\\nclass Solution {\\n    public String lastSubstring(String s) {\\n        int i = 0;\\n        int j = 1;\\n        int k = 0;\\n        int n = s.length();\\n        char[] ca = s.toCharArray();\\n\\n        while (j + k < n) {\\n            if (ca[i + k] == ca[j + k]) {\\n                k++;\\n            } else if (ca[i + k] > ca[j + k]) {\\n                j = j + k + 1;\\n                k = 0;\\n            } else {\\n                i = Math.max(i + k + 1, j);\\n                j = i + 1;\\n                k = 0;\\n            }\\n        }\\n        return s.substring(i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511934,
                "title": "suffix-array-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nClassic suffix array problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBuild suffix array of the string\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#pragma GCC optimize(\"O3\")\\n#pragma GCC target(\"avx2\")\\n#pragma GCC optimize(\"unroll-loops\")\\n\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        string t = s;\\n        s += \\'$\\';\\n\\n        int n = s.size();\\n        const int alphabet = 256;\\n        int p[n];\\n        vector <int> c(n), cnt(max(alphabet, n), 0);\\n        for (int i = 0; i < n; i++) cnt[s[i]]++;\\n        for (int i = 1; i < alphabet; i++) cnt[i] += cnt[i - 1];\\n        for (int i = 0; i < n; i++) p[--cnt[s[i]]] = i;\\n\\n        c[p[0]] = 0;\\n        int classes = 1;\\n        for (int i = 1; i < n; i++) {\\n            if (s[p[i]] != s[p[i - 1]]) classes++;\\n            c[p[i]] = classes - 1;\\n        }\\n\\n        int pn[n];\\n        vector<int> cn(n);\\n        for (int h = 0; (1 << h) < n; ++h) {\\n            for (int i = 0; i < n; i++) {\\n                pn[i] = p[i] - (1 << h);\\n                if (pn[i] < 0) pn[i] += n;\\n            }\\n\\n            fill(cnt.begin(), cnt.begin() + classes, 0);\\n            for (int i = 0; i < n; i++) cnt[c[pn[i]]]++;\\n            for (int i = 1; i < classes; i++) cnt[i] += cnt[i-1];\\n            for (int i = n - 1; i >= 0; i--) p[--cnt[c[pn[i]]]] = pn[i];\\n\\n            cn[p[0]] = 0;\\n            classes = 1;\\n            for (int i = 1; i < n; i++) {\\n                pair<int, int> cur = {c[p[i]], c[(p[i] + (1 << h)) % n]};\\n                pair<int, int> prev = {c[p[i - 1]], c[(p[i - 1] + (1 << h)) % n]};\\n                if (cur != prev) ++classes;\\n                cn[p[i]] = classes - 1;\\n            }\\n\\n            c.swap(cn);\\n        }\\n        \\n        return t.substr(p[n - 1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#pragma GCC optimize(\"O3\")\\n#pragma GCC target(\"avx2\")\\n#pragma GCC optimize(\"unroll-loops\")\\n\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        string t = s;\\n        s += \\'$\\';\\n\\n        int n = s.size();\\n        const int alphabet = 256;\\n        int p[n];\\n        vector <int> c(n), cnt(max(alphabet, n), 0);\\n        for (int i = 0; i < n; i++) cnt[s[i]]++;\\n        for (int i = 1; i < alphabet; i++) cnt[i] += cnt[i - 1];\\n        for (int i = 0; i < n; i++) p[--cnt[s[i]]] = i;\\n\\n        c[p[0]] = 0;\\n        int classes = 1;\\n        for (int i = 1; i < n; i++) {\\n            if (s[p[i]] != s[p[i - 1]]) classes++;\\n            c[p[i]] = classes - 1;\\n        }\\n\\n        int pn[n];\\n        vector<int> cn(n);\\n        for (int h = 0; (1 << h) < n; ++h) {\\n            for (int i = 0; i < n; i++) {\\n                pn[i] = p[i] - (1 << h);\\n                if (pn[i] < 0) pn[i] += n;\\n            }\\n\\n            fill(cnt.begin(), cnt.begin() + classes, 0);\\n            for (int i = 0; i < n; i++) cnt[c[pn[i]]]++;\\n            for (int i = 1; i < classes; i++) cnt[i] += cnt[i-1];\\n            for (int i = n - 1; i >= 0; i--) p[--cnt[c[pn[i]]]] = pn[i];\\n\\n            cn[p[0]] = 0;\\n            classes = 1;\\n            for (int i = 1; i < n; i++) {\\n                pair<int, int> cur = {c[p[i]], c[(p[i] + (1 << h)) % n]};\\n                pair<int, int> prev = {c[p[i - 1]], c[(p[i - 1] + (1 << h)) % n]};\\n                if (cur != prev) ++classes;\\n                cn[p[i]] = classes - 1;\\n            }\\n\\n            c.swap(cn);\\n        }\\n        \\n        return t.substr(p[n - 1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458563,
                "title": "python3-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        i = 0\\n        j = 1\\n        k = 0\\n        n = len(s)\\n        while j + k < n:\\n            if s[i + k] == s[j + k]:\\n                k += 1\\n            elif s[i + k] > s[j + k]:\\n                j += k + 1\\n                k = 0\\n            elif s[i + k] < s[j + k]:\\n                i = max(i + k + 1, j)\\n                j = i + 1\\n                k = 0\\n        return s[i:]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        i = 0\\n        j = 1\\n        k = 0\\n        n = len(s)\\n        while j + k < n:\\n            if s[i + k] == s[j + k]:\\n                k += 1\\n            elif s[i + k] > s[j + k]:\\n                j += k + 1\\n                k = 0\\n            elif s[i + k] < s[j + k]:\\n                i = max(i + k + 1, j)\\n                j = i + 1\\n                k = 0\\n        return s[i:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432738,
                "title": "2-line-solution-in-python-with-explanation",
                "content": "# Intuition\\nThe answer will have the largest initial letter `z`. In addition, the longer the answer is the better. In other words, only the substrings `s[i:]` with `s[i] == z` ending at the end of `s` should be considered as candidates. \\n\\nA candidate substring `s[i:]` is always better than `s[i+1:]` where `s[i+1] == z`. Based on this property, a lot of candidates can be skipped. \\n\\nAs a result, only the substrings `s[i:]` with `s[i] == z` and `s[i-1] != z` should be considered as condidates. The answer is the one with the largest order.   \\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBased on above properties, the code can be implemented in a very concise way in Python. The first line is to find the largest letter `z` from `s`, which is the initial letter of the answer. The second line picks up the largest one from the candidates `s[i:]` meet all the properties. \\n\\n# Code\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        z = max(list(s))\\n        return max(s[i:] for i, c in enumerate(s) if c == z and (i == 0 or s[i-1] != z))\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        z = max(list(s))\\n        return max(s[i:] for i, c in enumerate(s) if c == z and (i == 0 or s[i-1] != z))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420522,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    public String lastSubstring(String s) {\\n        int maxIndex = s.length() - 1;\\n\\n        for(int currIndex = s.length() - 1 ; currIndex >= 0 ; currIndex--){\\n            if(s.charAt(currIndex) > s.charAt(maxIndex))\\n                maxIndex = currIndex;\\n                \\n            else if(s.charAt(currIndex) == s.charAt(maxIndex)){\\n                int i = currIndex + 1;\\n                int j = maxIndex + 1;\\n                \\n                \\n                while(i < maxIndex && j < s.length() && s.charAt(i) == s.charAt(j)){\\n                    i++;\\n                    j++;\\n                }\\n                \\n                if(i == maxIndex || j == s.length() || s.charAt(i) > s.charAt(j))\\n                    maxIndex = currIndex;\\n            }\\n        }\\n\\n        return s.substring(maxIndex);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public String lastSubstring(String s) {\\n        int maxIndex = s.length() - 1;\\n\\n        for(int currIndex = s.length() - 1 ; currIndex >= 0 ; currIndex--){\\n            if(s.charAt(currIndex) > s.charAt(maxIndex))\\n                maxIndex = currIndex;\\n                \\n            else if(s.charAt(currIndex) == s.charAt(maxIndex)){\\n                int i = currIndex + 1;\\n                int j = maxIndex + 1;\\n                \\n                \\n                while(i < maxIndex && j < s.length() && s.charAt(i) == s.charAt(j)){\\n                    i++;\\n                    j++;\\n                }\\n                \\n                if(i == maxIndex || j == s.length() || s.charAt(i) > s.charAt(j))\\n                    maxIndex = currIndex;\\n            }\\n        }\\n\\n        return s.substring(maxIndex);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336338,
                "title": "python3-fast-very-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        max = 97\\n        for e in s:\\n            if ord(e) > max:\\n                max = ord(e)\\n        \\n        maxstr = \\'\\'\\n        for i in range(len(s)):\\n            if ord(s[i]) == max:\\n                if s[i:] > maxstr:\\n                    maxstr = s[i:]\\n        \\n        return maxstr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        max = 97\\n        for e in s:\\n            if ord(e) > max:\\n                max = ord(e)\\n        \\n        maxstr = \\'\\'\\n        for i in range(len(s)):\\n            if ord(s[i]) == max:\\n                if s[i:] > maxstr:\\n                    maxstr = s[i:]\\n        \\n        return maxstr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301247,
                "title": "javascript-1163-last-substring-in-lexicographical-order",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n1 Strings - **PASS**\\n2.1 Indexs - TRY 1 - **Time Limit Exceeded**\\n2.2 Indexs - TRY 2 - **Time Limit Exceeded**\\n2.3 Indexs - TRY 3 - **PASS**\\n2.4 Indexs - TRY 4 - **PASS**\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1 Strings - **PASS**\\n```\\nvar lastSubstring = function (s) {\\n    let n = s.length;\\n\\n    let max_i = 0; // index of lexicographically largest alphabet\\n    for (let i = 0; i < n; i++)\\n        if (s[i] > s[max_i]) {\\n            max_i = i;\\n        }\\n\\n    let strings = []; // max_i staring strings\\n    for (let i = 0; i < n; i++)\\n        if (s[i] === s[max_i]) {\\n            strings.push(s.slice(i));\\n        }\\n\\n    strings.sort();\\n    return strings[strings.length - 1];\\n};\\n```\\n\\n2.1 Indexs - TRY 1 - **Time Limit Exceeded**\\n```\\nvar lastSubstring = function (s) {\\n    let n = s.length,\\n        L = 0,\\n        R = L + 1,\\n        k = 0;\\n    while (R + k < n) {\\n        if (s[L + k] === s[R + k]) {\\n            k++;\\n        } else {\\n            if (s[L + k] < s[R + k]) {\\n                L++; // TRY 1\\n                R = L + 1;\\n            } else {\\n                R++;\\n            }\\n            k = 0;\\n        }\\n    }\\n    return s.slice(L);\\n};\\n```\\n\\n2.2 Indexs - TRY 2 - **Time Limit Exceeded**\\n```\\nvar lastSubstring = function (s) {\\n    let n = s.length,\\n        L = 0,\\n        R = L + 1,\\n        k = 0;\\n    while (R + k < n) {\\n        if (s[L + k] === s[R + k]) {\\n            k++;\\n        } else {\\n            if (s[L + k] < s[R + k]) {\\n                L += k; // TRY 2\\n                R = L + 1;\\n            } else {\\n                R += k;\\n            }\\n            k = 0;\\n        }\\n    }\\n    return s.slice(L);\\n};\\n```\\n\\n2.3 Indexs - TRY 3 - **PASS**\\n```\\nvar lastSubstring = function (s) {\\n    let n = s.length,\\n        L = 0,\\n        R = L + 1,\\n        k = 0;\\n    while (R + k < n) {\\n        if (s[L + k] === s[R + k]) {\\n            k++;\\n        } else {\\n            if (s[L + k] < s[R + k]) {\\n                L += k + 1; // TRY 3\\n                R = L + 1;\\n            } else {\\n                R += k + 1;\\n            }\\n            k = 0;\\n        }\\n    }\\n    return s.slice(L);\\n};\\n```\\n\\n2.4 Indexs - TRY 4 - **PASS**\\n```\\nvar lastSubstring = function (s) {\\n    let n = s.length,\\n        L = 0,\\n        R = L + 1,\\n        k = 0;\\n    while (R + k < n) {\\n        if (s[L + k] === s[R + k]) {\\n            k++;\\n        } else {\\n            if (s[L + k] < s[R + k]) {\\n                L += k + 1;\\n                if (R < L + 1) {\\n                    R = L + 1; // TRY 4\\n                }\\n            } else {\\n                R += k + 1;\\n            }\\n            k = 0;\\n        }\\n    }\\n    return s.slice(L);\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar lastSubstring = function (s) {\\n    let n = s.length;\\n\\n    let max_i = 0; // index of lexicographically largest alphabet\\n    for (let i = 0; i < n; i++)\\n        if (s[i] > s[max_i]) {\\n            max_i = i;\\n        }\\n\\n    let strings = []; // max_i staring strings\\n    for (let i = 0; i < n; i++)\\n        if (s[i] === s[max_i]) {\\n            strings.push(s.slice(i));\\n        }\\n\\n    strings.sort();\\n    return strings[strings.length - 1];\\n};\\n```\n```\\nvar lastSubstring = function (s) {\\n    let n = s.length,\\n        L = 0,\\n        R = L + 1,\\n        k = 0;\\n    while (R + k < n) {\\n        if (s[L + k] === s[R + k]) {\\n            k++;\\n        } else {\\n            if (s[L + k] < s[R + k]) {\\n                L++; // TRY 1\\n                R = L + 1;\\n            } else {\\n                R++;\\n            }\\n            k = 0;\\n        }\\n    }\\n    return s.slice(L);\\n};\\n```\n```\\nvar lastSubstring = function (s) {\\n    let n = s.length,\\n        L = 0,\\n        R = L + 1,\\n        k = 0;\\n    while (R + k < n) {\\n        if (s[L + k] === s[R + k]) {\\n            k++;\\n        } else {\\n            if (s[L + k] < s[R + k]) {\\n                L += k; // TRY 2\\n                R = L + 1;\\n            } else {\\n                R += k;\\n            }\\n            k = 0;\\n        }\\n    }\\n    return s.slice(L);\\n};\\n```\n```\\nvar lastSubstring = function (s) {\\n    let n = s.length,\\n        L = 0,\\n        R = L + 1,\\n        k = 0;\\n    while (R + k < n) {\\n        if (s[L + k] === s[R + k]) {\\n            k++;\\n        } else {\\n            if (s[L + k] < s[R + k]) {\\n                L += k + 1; // TRY 3\\n                R = L + 1;\\n            } else {\\n                R += k + 1;\\n            }\\n            k = 0;\\n        }\\n    }\\n    return s.slice(L);\\n};\\n```\n```\\nvar lastSubstring = function (s) {\\n    let n = s.length,\\n        L = 0,\\n        R = L + 1,\\n        k = 0;\\n    while (R + k < n) {\\n        if (s[L + k] === s[R + k]) {\\n            k++;\\n        } else {\\n            if (s[L + k] < s[R + k]) {\\n                L += k + 1;\\n                if (R < L + 1) {\\n                    R = L + 1; // TRY 4\\n                }\\n            } else {\\n                R += k + 1;\\n            }\\n            k = 0;\\n        }\\n    }\\n    return s.slice(L);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3234405,
                "title": "c-o-n-3-pointer-manipulation-offset",
                "content": "```cpp\\nclass Solution {\\npublic:\\n  string lastSubstring(string s) {\\n    int n = s.size();\\n    int p = 0, j1 = 0, j2 = 0;\\n    for (int i = 1; i < n; i++) {\\n      if (s[i] > s[j1 + i - j2]) {\\n        j1 = j2;\\n      }\\n      if (s[i] < s[j1 + i - j2]) {\\n        j2 = j1;\\n      }\\n      if (s[i] > s[p + i - j2]) {\\n        p = j2;\\n      }\\n      if (s[i] < s[p + i - j2]) {\\n        j1 = j2 = p;\\n      }\\n      if (s[i] > s[p + i - j1]) {\\n        p = j1;\\n      }\\n      if (s[i] > s[p + i - j1]) {\\n        j1 = j2 = p;\\n      }\\n      if (s[i] > s[p]) {\\n        p = j1 = j2 = i;\\n      } else if (s[i] == s[p]) {\\n        j2 = i;\\n        if (j1 == p) {\\n          j1 = i;\\n        }\\n      }\\n    }\\n    return s.substr(p);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n  string lastSubstring(string s) {\\n    int n = s.size();\\n    int p = 0, j1 = 0, j2 = 0;\\n    for (int i = 1; i < n; i++) {\\n      if (s[i] > s[j1 + i - j2]) {\\n        j1 = j2;\\n      }\\n      if (s[i] < s[j1 + i - j2]) {\\n        j2 = j1;\\n      }\\n      if (s[i] > s[p + i - j2]) {\\n        p = j2;\\n      }\\n      if (s[i] < s[p + i - j2]) {\\n        j1 = j2 = p;\\n      }\\n      if (s[i] > s[p + i - j1]) {\\n        p = j1;\\n      }\\n      if (s[i] > s[p + i - j1]) {\\n        j1 = j2 = p;\\n      }\\n      if (s[i] > s[p]) {\\n        p = j1 = j2 = i;\\n      } else if (s[i] == s[p]) {\\n        j2 = i;\\n        if (j1 == p) {\\n          j1 = i;\\n        }\\n      }\\n    }\\n    return s.substr(p);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112059,
                "title": "python-brute-force-solution",
                "content": "# Intuition\\n- The answer is always suffix of the given string\\n- what if store the indices of largest character and compare the substring starting from the indeces to the end of the string\\n\\n# Approach\\n- store the indices of largest character\\n- for each index in indices take the largest substring by comparing substrings starting from the index to the end of the string\\n\\n# Complexity\\nN = len(s)\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        left = 0\\n        right = 0\\n        index = []\\n        while right < len(s):\\n            if s[right] > s[left]:\\n                left = right\\n            if s[right] == s[left]:\\n                if index and s[left] != s[index[0]]:\\n                    index = []\\n                index.append(right)\\n            right += 1\\n        \\n        largest = s[index[-1]:]\\n        start = index[-1]\\n        for i in range(len(index) - 2, -1, -1):\\n            if s[index[i]:] >= largest:\\n                largest = s[index[i]:]\\n                start = index[i]\\n        \\n        return s[start:]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        left = 0\\n        right = 0\\n        index = []\\n        while right < len(s):\\n            if s[right] > s[left]:\\n                left = right\\n            if s[right] == s[left]:\\n                if index and s[left] != s[index[0]]:\\n                    index = []\\n                index.append(right)\\n            right += 1\\n        \\n        largest = s[index[-1]:]\\n        start = index[-1]\\n        for i in range(len(index) - 2, -1, -1):\\n            if s[index[i]:] >= largest:\\n                largest = s[index[i]:]\\n                start = index[i]\\n        \\n        return s[start:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058847,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn last_substring(s: String) -> String {\\n        let mut i = 0;\\n        let mut j = 1;\\n        let mut k = 0;\\n        let s = s.as_bytes();\\n        let n = s.len();\\n        while j + k < n {\\n            match s[i + k].cmp(&s[j + k]) {\\n                std::cmp::Ordering::Equal => k += 1,\\n                std::cmp::Ordering::Less => {\\n                    i = (i + k + 1).max(j);\\n                    j = i + 1;\\n                    k = 0;\\n                }\\n                std::cmp::Ordering::Greater => {\\n                    j += k + 1;\\n                    k = 0;\\n                }\\n            }\\n        }\\n        unsafe { String::from_utf8_unchecked(s[i..].to_vec()) }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn last_substring(s: String) -> String {\\n        let mut i = 0;\\n        let mut j = 1;\\n        let mut k = 0;\\n        let s = s.as_bytes();\\n        let n = s.len();\\n        while j + k < n {\\n            match s[i + k].cmp(&s[j + k]) {\\n                std::cmp::Ordering::Equal => k += 1,\\n                std::cmp::Ordering::Less => {\\n                    i = (i + k + 1).max(j);\\n                    j = i + 1;\\n                    k = 0;\\n                }\\n                std::cmp::Ordering::Greater => {\\n                    j += k + 1;\\n                    k = 0;\\n                }\\n            }\\n        }\\n        unsafe { String::from_utf8_unchecked(s[i..].to_vec()) }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3007000,
                "title": "no-prefix-array-very-intuitive-and-na-ve-solution-by-optimizing-step-by-step-using-3-different-ways",
                "content": "# Code\\n```\\nclass Solution {\\npublic: \\n    Approach 1 TLE Very basic solution using set and recursion \\n     set<string>res;\\n     void helper(string s,string temp,int i){\\n         if(i==s.length()) {\\n             res.insert(temp);\\n             return;\\n         }\\n         // ntake \\n         res.insert(temp);\\n         string t=\"\";\\n         t+=s[i];\\n         helper(s,t,i+1);\\n         //take\\n         helper(s,temp+s[i],i+1);\\n     }\\n     string lastSubstring(string s) {\\n         helper(s,\"\",0);\\n         for(auto it=res.begin();it!=res.end();it++) cout<<*it<<\" \";\\n         auto it=res.end();\\n         it--;\\n\\n         return *it;\\n     }\\n\\n\\n\\n     Approach 2 Memory Limit Exceeded :very basic and intuitive approach of comparing each substring(suffix) of s ending with the last character of s. \\n     string lastSubstring(string s) {\\n         string temp=\"\";\\n         for(int i=0;i<s.length();i++){\\n             temp=max(temp,s.substr(i));\\n         }\\n         return temp;\\n     }\\n    \\n\\n     Approach 3 Optimized way of searching \\n    string helper(string s){\\n        // max stores the maximium character in the string \\n        // maxIndex stores the starting index of the largest substring starting with the max character\\n\\n\\n        char max = s[0];\\n        int length = s.size(), maxIndex = 0;\\n        for(int i = 1 ; i < length; ++i){\\n            if ( s[i] > max ){\\n                maxIndex = i;\\n                max = s[i];\\n            }\\n            else if (s[i] == max){\\n                int j = 1;\\n                while (s[i + j] == s[maxIndex + j] && maxIndex + j < i ) j++;\\n                if (s[i + j] > s[maxIndex + j]) maxIndex = i;\\n                i = i + j-1;\\n            }\\n        }\\n        return s.substr(maxIndex,length - maxIndex + 1);\\n\\n    }\\n    string lastSubstring(string s) {\\n        while(true){\\n            string res=helper(s);\\n            if(helper(res)==res) return res;\\n            else s=res;\\n        }\\n        return \" \";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    Approach 1 TLE Very basic solution using set and recursion \\n     set<string>res;\\n     void helper(string s,string temp,int i){\\n         if(i==s.length()) {\\n             res.insert(temp);\\n             return;\\n         }\\n         // ntake \\n         res.insert(temp);\\n         string t=\"\";\\n         t+=s[i];\\n         helper(s,t,i+1);\\n         //take\\n         helper(s,temp+s[i],i+1);\\n     }\\n     string lastSubstring(string s) {\\n         helper(s,\"\",0);\\n         for(auto it=res.begin();it!=res.end();it++) cout<<*it<<\" \";\\n         auto it=res.end();\\n         it--;\\n\\n         return *it;\\n     }\\n\\n\\n\\n     Approach 2 Memory Limit Exceeded :very basic and intuitive approach of comparing each substring(suffix) of s ending with the last character of s. \\n     string lastSubstring(string s) {\\n         string temp=\"\";\\n         for(int i=0;i<s.length();i++){\\n             temp=max(temp,s.substr(i));\\n         }\\n         return temp;\\n     }\\n    \\n\\n     Approach 3 Optimized way of searching \\n    string helper(string s){\\n        // max stores the maximium character in the string \\n        // maxIndex stores the starting index of the largest substring starting with the max character\\n\\n\\n        char max = s[0];\\n        int length = s.size(), maxIndex = 0;\\n        for(int i = 1 ; i < length; ++i){\\n            if ( s[i] > max ){\\n                maxIndex = i;\\n                max = s[i];\\n            }\\n            else if (s[i] == max){\\n                int j = 1;\\n                while (s[i + j] == s[maxIndex + j] && maxIndex + j < i ) j++;\\n                if (s[i + j] > s[maxIndex + j]) maxIndex = i;\\n                i = i + j-1;\\n            }\\n        }\\n        return s.substr(maxIndex,length - maxIndex + 1);\\n\\n    }\\n    string lastSubstring(string s) {\\n        while(true){\\n            string res=helper(s);\\n            if(helper(res)==res) return res;\\n            else s=res;\\n        }\\n        return \" \";\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2984911,
                "title": "python-very-easy-solution-please-upvote-and-add-to-your-favourites",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        res=\"\"\\n        for i in range(len(s)):\\n            res=max(res,s[i:])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        res=\"\"\\n        for i in range(len(s)):\\n            res=max(res,s[i:])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924439,
                "title": "python-efficient-solution-easy-to-understand-beats-70",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find optimal index of maximum element. ```s[maxIndex:]``` is the answer\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo the Basis of this kindof solution is the fact that the input string may not only contain unique characters, it can contain duplicate high lexicographical chars , so at that point , we need to compare the substrings from those two chars that which one is more efficient. CRUX of the problem is:\\nWe iterate throught the string from right to left . (max idx = n-1 initially )\\n2 Cases :\\n1. If we get a higher char, we assign it to max idx.\\n2. If we get a char which is same as the prev encountered high char , ie. at max idx , then we need to compaer the strings\\n\\n2 cases :\\n1. if the prev max char is at n-1 (max idx=n-1) , we assign max idx to i ,why? ( because obv a string of greater length will be lexicographical. Higher than the same char alone)\\n2. if its not at n-1 , we compare strings (till both the strings are same ), when there is a mismatch , we check if current string has a higher element , or the prev max string is outof bound .\\n3. If so , we assign max idx to i.\\n\\nHence we return the maximum lexicographical string.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        sz = len(s)\\n        maxIndex = sz - 1\\n        for idx in range(sz - 2, -1, -1):\\n            if s[idx] > s[maxIndex]:\\n                maxIndex = idx\\n            elif s[idx] == s[maxIndex]:\\n                if maxIndex == sz-1:\\n                    maxIndex = idx\\n                else:\\n                    j = 1\\n                    while maxIndex + j < sz and s[idx + j] == s[maxIndex + j] and (idx + j) != maxIndex:\\n                        j += 1\\n                    if s[idx + j] >= s[min(maxIndex + j, sz - 1)] or (maxIndex + j) >= sz:\\n                        maxIndex = idx\\n        return s[maxIndex:]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String"
                ],
                "code": "```s[maxIndex:]```\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        sz = len(s)\\n        maxIndex = sz - 1\\n        for idx in range(sz - 2, -1, -1):\\n            if s[idx] > s[maxIndex]:\\n                maxIndex = idx\\n            elif s[idx] == s[maxIndex]:\\n                if maxIndex == sz-1:\\n                    maxIndex = idx\\n                else:\\n                    j = 1\\n                    while maxIndex + j < sz and s[idx + j] == s[maxIndex + j] and (idx + j) != maxIndex:\\n                        j += 1\\n                    if s[idx + j] >= s[min(maxIndex + j, sz - 1)] or (maxIndex + j) >= sz:\\n                        maxIndex = idx\\n        return s[maxIndex:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763793,
                "title": "longer-code-but-may-help-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        // As the hint given, the max substr will always be suffix string. \\n        // You can always add more character to make it (greater) if it is not a suffix str.\\n        //\\n\\t\\t// (Easier to program to start from the end of the string)\\n        // So the problem becomes comparing list of subffix strs (char by char to save temp memory).\\n        // There are several different situations in the comparison:\\n        // 1. You encounter a char greater than the curr max.\\n        // 2. You keep encountering the same stream of chars, and the new suffix str is longer.\\n        // 3. You encounter a char overlapped between the curr suffix str and the max suffix str e.g. fbbaa vs bbaa. (try my best to explain in wordings, draw it out may help)\\n        //    In this case, no need to iterate further. The property of the max suffix str allow you to stop further comparison. \\n        //    Because all characters behind the first character in the max suffix str must be smaller or eq. \\n        //    In the example bbbaa vs bbaa, compare \\'b\\' vs \\'b\\', same -> move to next char, now it is in the overlapped zone. \\n        //    any char going further will be smaller than or eq to this char \\'b\\' (property of max substr). Means we just find another longer max substr.\\n        //    \\n        \\n        // The substr starts from pos will be the answer.\\n        int pos=s.length()-1;\\n        for(int i=s.length()-2; i>=0; i--) {\\n            int k=0;\\n            while(pos+k < s.length()) {\\n                // case 3\\n                if(i+k>=pos) {\\n                    pos=i;\\n                    break;\\n                }\\n                \\n                // case 1\\n                if(s[i+k] > s[pos+k]) {\\n                   pos = i;\\n                   break;\\n                } else if(s[i+k] < s[pos+k]) {\\n                   break;\\n                }\\n                \\n                k++;\\n            }\\n            \\n            // case 2\\n            if(pos+k==s.length()) {\\n                pos=i;\\n            }\\n        }\\n        \\n        return s.substr(pos);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        // As the hint given, the max substr will always be suffix string. \\n        // You can always add more character to make it (greater) if it is not a suffix str.\\n        //\\n\\t\\t// (Easier to program to start from the end of the string)\\n        // So the problem becomes comparing list of subffix strs (char by char to save temp memory).\\n        // There are several different situations in the comparison:\\n        // 1. You encounter a char greater than the curr max.\\n        // 2. You keep encountering the same stream of chars, and the new suffix str is longer.\\n        // 3. You encounter a char overlapped between the curr suffix str and the max suffix str e.g. fbbaa vs bbaa. (try my best to explain in wordings, draw it out may help)\\n        //    In this case, no need to iterate further. The property of the max suffix str allow you to stop further comparison. \\n        //    Because all characters behind the first character in the max suffix str must be smaller or eq. \\n        //    In the example bbbaa vs bbaa, compare \\'b\\' vs \\'b\\', same -> move to next char, now it is in the overlapped zone. \\n        //    any char going further will be smaller than or eq to this char \\'b\\' (property of max substr). Means we just find another longer max substr.\\n        //    \\n        \\n        // The substr starts from pos will be the answer.\\n        int pos=s.length()-1;\\n        for(int i=s.length()-2; i>=0; i--) {\\n            int k=0;\\n            while(pos+k < s.length()) {\\n                // case 3\\n                if(i+k>=pos) {\\n                    pos=i;\\n                    break;\\n                }\\n                \\n                // case 1\\n                if(s[i+k] > s[pos+k]) {\\n                   pos = i;\\n                   break;\\n                } else if(s[i+k] < s[pos+k]) {\\n                   break;\\n                }\\n                \\n                k++;\\n            }\\n            \\n            // case 2\\n            if(pos+k==s.length()) {\\n                pos=i;\\n            }\\n        }\\n        \\n        return s.substr(pos);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763788,
                "title": "intutive-approach-with-detailed-explanation",
                "content": "# Intuition\\n1. Answer will must start with the biggest character in string\\n\\n\\n# Approach\\n1. Traverse string in reverse order\\n2. Keep track of biggest element till that specific index also keep track of the index of that biggest element.\\n3. if new character is greater than the previous big character then will update biggest characted and index\\n4. if new character is less than the previous big character then don\\'t need to do anything\\n5. if new character is equal to the previous biggest character then compare both substring whichever is biggest will store that.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n##Keep track of bigest character min index O(N^2)\\n##Need to slove in ()\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        mx=\"\"\\n        biggest=s[-1]\\n        index=len(s)-1\\n        for i in range(len(s)-2,-1,-1):\\n             if s[i]>biggest:\\n                 biggest=s[i]\\n                 index=i\\n             elif s[i]==biggest:\\n                 if s[i:len(s)]>s[index:len(s)]:\\n                     biggest=s[i]\\n                     index=i\\n        return s[index:len(s)]                           \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n##Keep track of bigest character min index O(N^2)\\n##Need to slove in ()\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        mx=\"\"\\n        biggest=s[-1]\\n        index=len(s)-1\\n        for i in range(len(s)-2,-1,-1):\\n             if s[i]>biggest:\\n                 biggest=s[i]\\n                 index=i\\n             elif s[i]==biggest:\\n                 if s[i:len(s)]>s[index:len(s)]:\\n                     biggest=s[i]\\n                     index=i\\n        return s[index:len(s)]                           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623968,
                "title": "c-efficient-solution-fully-explained",
                "content": "***Explanation :*** \\uD83D\\uDCCA\\nSo the ***Basis*** of this kindof solution is the fact that the , input string may not only contain unique characters, it can contain duplicate high lexic chars , so at that point , we need  to compare the substrings from those two chars that which one is more efficient. \\n***CRUXX of the problem :*** \\u2B50\\nWe iterate throught the string from right to left . (max idx = n-1 initially  )\\n***2 Cases :***\\nIf we get a higher char, we assign it to max idx.\\nIf we get a char which is same as the prev encountered  high char , ie. at max idx , then we need to compaer  the strings \\n***2 cases :***\\n-> if the prev max char is at n-1 (max idx=n-1) , we assign max idx to i ,why? ( because obv a string of greater length will be lexic . higher than the same char alone )\\n-> if its  not at n-1 , we compare strings (till  both the strings are same ), when there is a mismatch , we check if current string has a higher element , or the prev max string is outof bound .\\n->If so , we assign max idx to i. \\nHence we return the maximum lexic string. \\n**UPVOTE IF YOU LIKE** \\uD83D\\uDE0A\\u2705\\n```\\n/* Conditions for comparison of strings :\\n    maxidx+j<n               --> out of bound condition \\n    s[i+j]==s[maxidx+j]      --> till both the strings are same\\n    i+j!=maxidx              --> substring i is considered before the max idx . \\n*/ \\n```\\n```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int n=s.length();\\n        int maxidx=n-1;\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]>s[maxidx]){\\n                maxidx=i;\\n            }\\n            else if(s[i]==s[maxidx]){\\n                if(maxidx==n-1){\\n                    maxidx=i;\\n                }\\n                else{\\n                    int j=1;\\n                    while((maxidx+j<n) && s[i+j]==s[maxidx+j] && (i+j)!=maxidx ){\\n                        j++;\\n                    }\\n                    if(s[i+j]>=s[maxidx+j] || (maxidx+j)>=n){\\n                        maxidx=i;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substr(maxidx);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n/* Conditions for comparison of strings :\\n    maxidx+j<n               --> out of bound condition \\n    s[i+j]==s[maxidx+j]      --> till both the strings are same\\n    i+j!=maxidx              --> substring i is considered before the max idx . \\n*/ \\n```\n```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int n=s.length();\\n        int maxidx=n-1;\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]>s[maxidx]){\\n                maxidx=i;\\n            }\\n            else if(s[i]==s[maxidx]){\\n                if(maxidx==n-1){\\n                    maxidx=i;\\n                }\\n                else{\\n                    int j=1;\\n                    while((maxidx+j<n) && s[i+j]==s[maxidx+j] && (i+j)!=maxidx ){\\n                        j++;\\n                    }\\n                    if(s[i+j]>=s[maxidx+j] || (maxidx+j)>=n){\\n                        maxidx=i;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substr(maxidx);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243628,
                "title": "python-o-n-explanation",
                "content": "Explanation\\n- First get all the locations of max character.\\n- Starting off with an offset of 1, get all the charaters from each of the start points and find the max character amongst them.\\n- Then check which amongst the start points has the max character with that particular offset and add it to the candidates list.\\n- Using the first index we will be able to extract the last lexicographical sorted string.\\n\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        n = len(s)\\n        cmax = max(s)\\n        \\n        candidates = [i for i, c in enumerate(s) if c == cmax]\\n        offset = 1\\n        \\n        while len(candidates) > 1:\\n            new_candidates = []\\n            cmax = max(s[i + offset] for i in candidates if i + offset < n)\\n            \\n            for i, st in enumerate(candidates):\\n                if i > 0 and candidates[i - 1] + offset == st:\\n                    continue\\n                \\n                if st + offset < n and s[st + offset] == cmax:\\n                    new_candidates.append(st)\\n                \\n            candidates = new_candidates\\n            offset += 1\\n        return s[candidates[0]:]\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Explanation\\n- First get all the locations of max character.\\n- Starting off with an offset of 1, get all the charaters from each of the start points and find the max character amongst them.\\n- Then check which amongst the start points has the max character with that particular offset and add it to the candidates list.\\n- Using the first index we will be able to extract the last lexicographical sorted string.\\n\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        n = len(s)\\n        cmax = max(s)\\n        \\n        candidates = [i for i, c in enumerate(s) if c == cmax]\\n        offset = 1\\n        \\n        while len(candidates) > 1:\\n            new_candidates = []\\n            cmax = max(s[i + offset] for i in candidates if i + offset < n)\\n            \\n            for i, st in enumerate(candidates):\\n                if i > 0 and candidates[i - 1] + offset == st:\\n                    continue\\n                \\n                if st + offset < n and s[st + offset] == cmax:\\n                    new_candidates.append(st)\\n                \\n            candidates = new_candidates\\n            offset += 1\\n        return s[candidates[0]:]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2076679,
                "title": "100-faster-java-beats-all",
                "content": "Hii , this is my solution I found I wrote a year back. I dont remember if it is my original solution or someone else. But it looks like mine because there are many unsuccessful attempts. However this solution beats all and is 100% fast\\n\\n```\\npublic String lastSubstring(String S) {\\n           \\n        if(S.length() == 1) return S;\\n        \\n        char s[] = S.toCharArray();\\n        \\n        // The biggest char : \\n        char biggestChar = s[0];\\n        int maxIndex = 0;\\n        \\n        int i = 1;  // Start at 1 index.\\n        \\n        while(i < s.length){\\n            \\n            if(biggestChar > s[i]) {\\n                i++;\\n                continue;\\n            }\\n            if(biggestChar < s[i]){\\n                biggestChar = s[i];\\n                maxIndex = i;\\n                i++;\\n                continue;\\n            } \\n            \\n            // biggest char is same at s[i] : \\n            \\n            // Compare foward in both substrings : \\n            int m = 1;\\n            int lastIndexOfBiggestChar = s.length;  // Last index of biggest char is important for cases like \"cacacacb\".\\n            while(i + m < s.length && s[i + m] == s[maxIndex + m]){\\n                if(s[maxIndex] == s[maxIndex + m]){\\n                    lastIndexOfBiggestChar = m;\\n                }\\n                m++;\\n            }\\n            \\n            // We reached the end, all chars were same.\\n            if(i + m == s.length){\\n                break;\\n            }\\n            \\n            // At \\'i + m\\' we have a different character : \\n            \\n            // If \\'i + m\\' is the biggest char : \\n            if(s[i + m] > biggestChar){\\n                biggestChar = s[i + m];\\n                maxIndex = i + m;\\n                i = i + m + 1;      // Skip \\'m\\' chars. Makes it O(n).\\n                continue;\\n            }\\n            \\n            // If \\'i + m\\' is bigger than \\'maxIndex + m\\' : \\n            if(s[i + m] > s[maxIndex + m]){\\n                biggestChar = s[i];\\n                maxIndex = i;\\n            }\\n\\n            // Skip atleast upto last index of biggest char : \\n            i = i + Math.min(lastIndexOfBiggestChar, m);        // Makes it O(n).\\n        }\\n        \\n        return S.substring(maxIndex);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String lastSubstring(String S) {\\n           \\n        if(S.length() == 1) return S;\\n        \\n        char s[] = S.toCharArray();\\n        \\n        // The biggest char : \\n        char biggestChar = s[0];\\n        int maxIndex = 0;\\n        \\n        int i = 1;  // Start at 1 index.\\n        \\n        while(i < s.length){\\n            \\n            if(biggestChar > s[i]) {\\n                i++;\\n                continue;\\n            }\\n            if(biggestChar < s[i]){\\n                biggestChar = s[i];\\n                maxIndex = i;\\n                i++;\\n                continue;\\n            } \\n            \\n            // biggest char is same at s[i] : \\n            \\n            // Compare foward in both substrings : \\n            int m = 1;\\n            int lastIndexOfBiggestChar = s.length;  // Last index of biggest char is important for cases like \"cacacacb\".\\n            while(i + m < s.length && s[i + m] == s[maxIndex + m]){\\n                if(s[maxIndex] == s[maxIndex + m]){\\n                    lastIndexOfBiggestChar = m;\\n                }\\n                m++;\\n            }\\n            \\n            // We reached the end, all chars were same.\\n            if(i + m == s.length){\\n                break;\\n            }\\n            \\n            // At \\'i + m\\' we have a different character : \\n            \\n            // If \\'i + m\\' is the biggest char : \\n            if(s[i + m] > biggestChar){\\n                biggestChar = s[i + m];\\n                maxIndex = i + m;\\n                i = i + m + 1;      // Skip \\'m\\' chars. Makes it O(n).\\n                continue;\\n            }\\n            \\n            // If \\'i + m\\' is bigger than \\'maxIndex + m\\' : \\n            if(s[i + m] > s[maxIndex + m]){\\n                biggestChar = s[i];\\n                maxIndex = i;\\n            }\\n\\n            // Skip atleast upto last index of biggest char : \\n            i = i + Math.min(lastIndexOfBiggestChar, m);        // Makes it O(n).\\n        }\\n        \\n        return S.substring(maxIndex);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2075617,
                "title": "easy-understandable-standard-two-pointer-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int n =s.length();\\n        int max_ind=n-1;\\n        int i=n-2;\\n        while(i>=0)\\n        {\\n            if(s[i]>s[max_ind])\\n                max_ind=i;\\n            else if(s[i]==s[max_ind])\\n            {\\n                int j=1;\\n                while((max_ind+j)<n && s[i+j]==s[max_ind+j] && (i+j)!=max_ind) j++;\\n                \\n                if(s[i+j]>=s[max_ind+j] || (max_ind+j)>=n)\\n                    max_ind=i;\\n            }\\n            i--;\\n        }\\n        return s.substr(max_ind);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int n =s.length();\\n        int max_ind=n-1;\\n        int i=n-2;\\n        while(i>=0)\\n        {\\n            if(s[i]>s[max_ind])\\n                max_ind=i;\\n            else if(s[i]==s[max_ind])\\n            {\\n                int j=1;\\n                while((max_ind+j)<n && s[i+j]==s[max_ind+j] && (i+j)!=max_ind) j++;\\n                \\n                if(s[i+j]>=s[max_ind+j] || (max_ind+j)>=n)\\n                    max_ind=i;\\n            }\\n            i--;\\n        }\\n        return s.substr(max_ind);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023680,
                "title": "python-two-pointers-concise-o-1-space",
                "content": "\\n    def lastSubstring(self, s: str) -> str: \\n        n = len(s) \\n        p1, p2 = n-1, n-2\\n        \\n        while p2 >= 0:     \\n            t1 = p1\\n            t2 = p2\\n            \\n            while t1 < n and t2 < p1 and s[t1] == s[t2]: \\n                t1 += 1 \\n                t2 += 1  \\n        \\n            if t1 == n or t2 == p1 or s[t2] > s[t1]: \\n                p1 = p2\\n                \\n            p2 -= 1\\n            \\n        return s[p1:] \\n\\nIf you like my solution, feel free to leave a upvote!!!",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "\\n    def lastSubstring(self, s: str) -> str: \\n        n = len(s) \\n        p1, p2 = n-1, n-2\\n        \\n        while p2 >= 0:     \\n            t1 = p1\\n            t2 = p2\\n            \\n            while t1 < n and t2 < p1 and s[t1] == s[t2]: \\n                t1 += 1 \\n                t2 += 1  \\n        \\n            if t1 == n or t2 == p1 or s[t2] > s[t1]: \\n                p1 = p2\\n                \\n            p2 -= 1\\n            \\n        return s[p1:] \\n\\nIf you like my solution, feel free to leave a upvote!!!",
                "codeTag": "Python3"
            },
            {
                "id": 1965517,
                "title": "python-simple-solution-o-n-time-o-1-space",
                "content": "```\\ndef lastSubstring(self, s: str) -> str:\\n        i, j, k, n = 0, 1, 0, len(s)\\n        while j + k < n:\\n            if s[i+k] == s[j+k]:\\n                k += 1\\n            elif s[i+k] < s[j+k]:\\n                i = i+k+1\\n                j = i+1\\n                k = 0\\n            else:\\n                j += k+1\\n                k = 0\\n        return s[i:]",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef lastSubstring(self, s: str) -> str:\\n        i, j, k, n = 0, 1, 0, len(s)\\n        while j + k < n:\\n            if s[i+k] == s[j+k]:\\n                k += 1\\n            elif s[i+k] < s[j+k]:\\n                i = i+k+1\\n                j = i+1\\n                k = 0\\n            else:\\n                j += k+1\\n                k = 0\\n        return s[i:]",
                "codeTag": "Python3"
            },
            {
                "id": 1922237,
                "title": "close-to-o-n-python-solution",
                "content": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        n = len(s)\\n        str_max = max(s)\\n        \\n        candidates = [i for i, c in enumerate(s) if c == str_max]\\n        offset = 1\\n    \\n        while len(candidates) > 1:\\n            curMax = max(s[i + offset] for i in candidates if i+offset<n)\\n            newCand = []\\n            \\n            for i, st in enumerate(candidates):\\n                if i > 0 and candidates[i-1] + offset == st:\\n                    continue\\n                    \\n                if st + offset < n and s[st+offset] == curMax:\\n                    newCand.append(st)\\n\\n            candidates = newCand\\n            offset += 1\\n            \\n        return s[candidates[0]:]\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        n = len(s)\\n        str_max = max(s)\\n        \\n        candidates = [i for i, c in enumerate(s) if c == str_max]\\n        offset = 1\\n    \\n        while len(candidates) > 1:\\n            curMax = max(s[i + offset] for i in candidates if i+offset<n)\\n            newCand = []\\n            \\n            for i, st in enumerate(candidates):\\n                if i > 0 and candidates[i-1] + offset == st:\\n                    continue\\n                    \\n                if st + offset < n and s[st+offset] == curMax:\\n                    newCand.append(st)\\n\\n            candidates = newCand\\n            offset += 1\\n            \\n        return s[candidates[0]:]\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1711493,
                "title": "max-substring-will-always-end-at-the-end-of-string",
                "content": "> Can be optimized a lot, but this approach works,\\n\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        n = len(s)\\n        maxSub = \"\"\\n        for i in range(n):\\n            maxSub = max(maxSub, s[i:])\\n        return maxSub\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        n = len(s)\\n        maxSub = \"\"\\n        for i in range(n):\\n            maxSub = max(maxSub, s[i:])\\n        return maxSub\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640371,
                "title": "partially-working-python-o-n",
                "content": "UPDATE:\\nthis algo does not consider all scenarios. for example, \"xxxcccxxxaaxxxcccxxxad\". see below comment\\n\\n--- \\n\\nnotice the latest substr must end at last character of the input string `s`. if we do this naively, we need to find maximum from an array `n` substrings, each being at length from `1` to `n` and ending at last char. This costs `O(n^2)`.\\n```python\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        arr = [s[i:] for i in range(len(s))]\\n        return max(arr)\\n```\\n\\nmy approach is this:\\n- find all start indexes of longest repeated substr of the \\'biggest\\' character. and the maximum length of the repeated substr too. \\n- from those indexes and length, we create an array of **segmented** substrings, and we find the maximum of those substrings. and that\\'s the answer\\n\\ntime complexity:\\n- since there can be `k` substrings, each at length `n/k` (see below start index positions), the time complexity to find maximum of the array is `O(k*n/k) = O(n)`. Plus previous `O(n)` operations of finding all such indexes, the total time complexity is `O(n)`\\n```\\n..i1...i2...i3....ik...\\n```\\n\\ncode\\n```python\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        unique = set(s)\\n        if len(unique) == 1:\\n            return s\\n        \\n        arr, ch_max, maxl, n, prei = [-1], max(unique), 0, len(s), -1\\n        # find all (start i) of longest repeated substring of biggest character\\n        for i in range(n+1):\\n            if i < n and s[i] == ch_max:\\n                if prei < 0:\\n                    prei = i\\n            else:\\n                if prei >= 0:\\n                    l = i - prei\\n                    if l == maxl:\\n                        arr.append(prei)\\n                    elif l > maxl:\\n                        arr = [prei]\\n                        maxl = l\\n                prei = -1\\n        \\n\\t\\t# segmented substrs led by maxl number of ch_max\\n\\t\\t# answer must be one of these\\n\\t\\t# for subs1 = subs2, smaller start index si wins. hence the `-si`\\n\\t\\t# since arr is segmented substr array, `max(arr)` takes O(n) in worst case\\n        arr = [(s[si+maxl:ei], -si) for si, ei in zip(arr, arr[1:] + [n])]\\n        return s[-max(arr)[1]:]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        arr = [s[i:] for i in range(len(s))]\\n        return max(arr)\\n```\n```\\n..i1...i2...i3....ik...\\n```\n```python\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        unique = set(s)\\n        if len(unique) == 1:\\n            return s\\n        \\n        arr, ch_max, maxl, n, prei = [-1], max(unique), 0, len(s), -1\\n        # find all (start i) of longest repeated substring of biggest character\\n        for i in range(n+1):\\n            if i < n and s[i] == ch_max:\\n                if prei < 0:\\n                    prei = i\\n            else:\\n                if prei >= 0:\\n                    l = i - prei\\n                    if l == maxl:\\n                        arr.append(prei)\\n                    elif l > maxl:\\n                        arr = [prei]\\n                        maxl = l\\n                prei = -1\\n        \\n\\t\\t# segmented substrs led by maxl number of ch_max\\n\\t\\t# answer must be one of these\\n\\t\\t# for subs1 = subs2, smaller start index si wins. hence the `-si`\\n\\t\\t# since arr is segmented substr array, `max(arr)` takes O(n) in worst case\\n        arr = [(s[si+maxl:ei], -si) for si, ei in zip(arr, arr[1:] + [n])]\\n        return s[-max(arr)[1]:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581267,
                "title": "o-n-solution-using-two-arrays",
                "content": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        s_arr = [s[0]]\\n        s_arr2 = []\\n        for c in s[1:]:\\n            s_arr.append(c)\\n            if s_arr2:\\n                s_arr2.append(c)\\n                if s_arr2[-1] > s_arr[len(s_arr2)-1]:#use it instead\\n                    s_arr = s_arr2\\n                    s_arr2 = []\\n                elif s_arr2[-1] < s_arr[len(s_arr2)-1]:#this string is lesser, discard it\\n                    s_arr2 = []\\n            if s_arr[0] < c:#greater letter encountered, replace it\\n                s_arr = [c]\\n                dec_array = []\\n            elif s_arr[0] == c and s_arr[-2] < s_arr[-1]:#equal letter encountered, start checking new string\\n                s_arr2 = [c]\\n        return \"\".join(s_arr)\\n```\\nthe trick is when the start and end are equal, then we need to start checking if the array needs to \"start over\".  if the second array does worse than what we currently have, then discard it, if its better, than use that",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        s_arr = [s[0]]\\n        s_arr2 = []\\n        for c in s[1:]:\\n            s_arr.append(c)\\n            if s_arr2:\\n                s_arr2.append(c)\\n                if s_arr2[-1] > s_arr[len(s_arr2)-1]:#use it instead\\n                    s_arr = s_arr2\\n                    s_arr2 = []\\n                elif s_arr2[-1] < s_arr[len(s_arr2)-1]:#this string is lesser, discard it\\n                    s_arr2 = []\\n            if s_arr[0] < c:#greater letter encountered, replace it\\n                s_arr = [c]\\n                dec_array = []\\n            elif s_arr[0] == c and s_arr[-2] < s_arr[-1]:#equal letter encountered, start checking new string\\n                s_arr2 = [c]\\n        return \"\".join(s_arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537343,
                "title": "java-o-n-time-o-1-space-easy-understand",
                "content": "```\\n  /*\\n        Idea:\\n          compare all suffix substrings.\\n          last substring in lexicographical order is always a suffix array\\n          so need to compare all suffix array.\\n          Observe: some suffices array can be skipped if its index belongs the common parts when comparing 2 other previous\\n          suffix array\\n          Details:\\n          initially i=0,j=1.\\n            i is always the start index of the last sub-string in lexicographical order by far\\n            j is always the start index of the current suffix to be compared\\n            l is the length of common prefix of i and j.\\n              if l is not 0, it means there are some chars are common prefix of 2 suffix array start with i and j and\\n              s[i] is the max char in the common prefix\\n            operation:\\n             if s[i + l] is same as s[j + l]; then l++;\\n             else\\n               - if (s[i + l] > s[j + l]) { j = j + l + 1; l=0; }\\n                 e.g. xabcxaba\\n                      i   j\\n                      l=3\\n                      x=a[i]>= any value in scope a[index i...j+l]\\n\\n                -else if (s[i + l] < s[j + l])\\n                  E.g.:\\n                    a> s[j+l] > s[i]\\n                               a a a a a a z\\n                        index  i j\\n                        next:\\n                           i=j+l then j=i+1, l=0;\\n\\n                    b>   s[j+l] > s[i+l] but  s[j+l] <=s[i]\\n     i+l<j         ----------------------   \\uFF081\\uFF09\\n     let i=j.then j=j+l+1, l=3;\\n                         xabaaxaby\\n                         i    j\\n                       next\\n                              i   j\\n                    another case:\\n                         \"cacb\"\\n                          i j\\n                            cacb\\n                          l=1\\n                       next:\\n                          \"cacb\"\\n                             i j\\n\\n    i+l>j         ----------------------   \\uFF082\\uFF09\\n    let period=j-i;\\n    let i=j+(l/p)*p\\n    then j=j+l+1, l=4;\\n                         \"m a a m a a m b\"\\n                          i     j\\n                                m a a m b\\n                         \"m a a m a a m a b\"\\n                        next          i     j\\n\\n   Note when i+l ==j, then only there is s[i+l]==s[j]\\n     m a m a a\\n         m a a\\n\\n  O(N) time,  watch l or j always move forward, never step back.\\n  O(1) space\\n\\n      O(N) time,  watch l or j always move forward, never step back.\\n      O(1) space\\n      */\\n  public static String lastSubstring(String Str) {\\n    char[] s = Str.toCharArray();\\n    int i = 0, j = i + 1, l = 0, N = s.length;\\n    while (j + l < N) {\\n      if (s[i + l] == s[j + l]) {\\n        l++; // O(N)\\n        continue;\\n      } else {\\n        if (s[i + l] <= s[j + l]) {\\n          // find new last substring in lexicographical order\\n          if (s[j + l] > s[i]) i = j + l;\\n          else { // 2 scenarios: i+l+1 < j or i+l+1 > j\\n            int p = j - i;\\n            i = j + (l / p) * p;\\n          }\\n        }\\n        j = j + l + 1; // O(N)\\n        l = 0;\\n      }\\n    }\\n    return Str.substring(i);\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  /*\\n        Idea:\\n          compare all suffix substrings.\\n          last substring in lexicographical order is always a suffix array\\n          so need to compare all suffix array.\\n          Observe: some suffices array can be skipped if its index belongs the common parts when comparing 2 other previous\\n          suffix array\\n          Details:\\n          initially i=0,j=1.\\n            i is always the start index of the last sub-string in lexicographical order by far\\n            j is always the start index of the current suffix to be compared\\n            l is the length of common prefix of i and j.\\n              if l is not 0, it means there are some chars are common prefix of 2 suffix array start with i and j and\\n              s[i] is the max char in the common prefix\\n            operation:\\n             if s[i + l] is same as s[j + l]; then l++;\\n             else\\n               - if (s[i + l] > s[j + l]) { j = j + l + 1; l=0; }\\n                 e.g. xabcxaba\\n                      i   j\\n                      l=3\\n                      x=a[i]>= any value in scope a[index i...j+l]\\n\\n                -else if (s[i + l] < s[j + l])\\n                  E.g.:\\n                    a> s[j+l] > s[i]\\n                               a a a a a a z\\n                        index  i j\\n                        next:\\n                           i=j+l then j=i+1, l=0;\\n\\n                    b>   s[j+l] > s[i+l] but  s[j+l] <=s[i]\\n     i+l<j         ----------------------   \\uFF081\\uFF09\\n     let i=j.then j=j+l+1, l=3;\\n                         xabaaxaby\\n                         i    j\\n                       next\\n                              i   j\\n                    another case:\\n                         \"cacb\"\\n                          i j\\n                            cacb\\n                          l=1\\n                       next:\\n                          \"cacb\"\\n                             i j\\n\\n    i+l>j         ----------------------   \\uFF082\\uFF09\\n    let period=j-i;\\n    let i=j+(l/p)*p\\n    then j=j+l+1, l=4;\\n                         \"m a a m a a m b\"\\n                          i     j\\n                                m a a m b\\n                         \"m a a m a a m a b\"\\n                        next          i     j\\n\\n   Note when i+l ==j, then only there is s[i+l]==s[j]\\n     m a m a a\\n         m a a\\n\\n  O(N) time,  watch l or j always move forward, never step back.\\n  O(1) space\\n\\n      O(N) time,  watch l or j always move forward, never step back.\\n      O(1) space\\n      */\\n  public static String lastSubstring(String Str) {\\n    char[] s = Str.toCharArray();\\n    int i = 0, j = i + 1, l = 0, N = s.length;\\n    while (j + l < N) {\\n      if (s[i + l] == s[j + l]) {\\n        l++; // O(N)\\n        continue;\\n      } else {\\n        if (s[i + l] <= s[j + l]) {\\n          // find new last substring in lexicographical order\\n          if (s[j + l] > s[i]) i = j + l;\\n          else { // 2 scenarios: i+l+1 < j or i+l+1 > j\\n            int p = j - i;\\n            i = j + (l / p) * p;\\n          }\\n        }\\n        j = j + l + 1; // O(N)\\n        l = 0;\\n      }\\n    }\\n    return Str.substring(i);\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1429623,
                "title": "rust-7ms",
                "content": "\\n\\n```\\nuse std::cmp::Ordering::*;\\n\\nimpl Solution {\\n    fn last_substring(s: String) -> String {\\n        let n = s.len();\\n        let mut i = 0;\\n        let mut j = 1;\\n        let mut k = 0;\\n        let v = s.as_bytes();\\n        while j + k < n {\\n            match v[i + k].cmp(&v[j + k]) {\\n                Equal => {\\n                    k += 1;\\n                }\\n                Greater => {\\n                    j = j + k + 1;\\n                    k = 0;\\n                }\\n                Less => {\\n                    i = j.max(i + k + 1);\\n                    j = i + 1;\\n                    k = 0;\\n                }\\n            }\\n        }\\n        s[i..].to_string()\\n    }\\n}\\n\\n#[test]\\nfn test() {\\n    let s = \"abab\".to_string();\\n    let res = \"bab\".to_string();\\n    assert_eq!(Solution::last_substring(s), res);\\n    let s = \"leetcode\".to_string();\\n    let res = \"tcode\".to_string();\\n    assert_eq!(Solution::last_substring(s), res);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::cmp::Ordering::*;\\n\\nimpl Solution {\\n    fn last_substring(s: String) -> String {\\n        let n = s.len();\\n        let mut i = 0;\\n        let mut j = 1;\\n        let mut k = 0;\\n        let v = s.as_bytes();\\n        while j + k < n {\\n            match v[i + k].cmp(&v[j + k]) {\\n                Equal => {\\n                    k += 1;\\n                }\\n                Greater => {\\n                    j = j + k + 1;\\n                    k = 0;\\n                }\\n                Less => {\\n                    i = j.max(i + k + 1);\\n                    j = i + 1;\\n                    k = 0;\\n                }\\n            }\\n        }\\n        s[i..].to_string()\\n    }\\n}\\n\\n#[test]\\nfn test() {\\n    let s = \"abab\".to_string();\\n    let res = \"bab\".to_string();\\n    assert_eq!(Solution::last_substring(s), res);\\n    let s = \"leetcode\".to_string();\\n    let res = \"tcode\".to_string();\\n    assert_eq!(Solution::last_substring(s), res);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1365772,
                "title": "strange-behaviour-by-oj",
                "content": "![image](https://assets.leetcode.com/users/images/631e13e1-ea55-48fd-bd4a-2d146b012bcb_1627374109.7242675.png)\\n\\nI submitted the following code for this problem and got this strange behaviour that all the testcases passed but still gave TLE.\\n\\n\\n\\n```\\nclass Solution \\n{\\npublic:\\n    string lastSubstring(string_view s) \\n    {\\n        string_view res;\\n        int sz = s.size();\\n        for(int i = 0; i < sz; i++)\\n        {\\n            if(s.substr(i) > res)\\n            {\\n                res = s.substr(i);\\n            }\\n        }\\n        return string(res);\\n    }\\n};\\n```\\nCan anyone explain how it can happen??\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string lastSubstring(string_view s) \\n    {\\n        string_view res;\\n        int sz = s.size();\\n        for(int i = 0; i < sz; i++)\\n        {\\n            if(s.substr(i) > res)\\n            {\\n                res = s.substr(i);\\n            }\\n        }\\n        return string(res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307324,
                "title": "up-to-date-fast-simple-java-o-n-solution",
                "content": "```\\npublic String lastSubstring(String s) {\\n        char[] chs = s.toCharArray();\\n        char maxChar = chs[0];\\n        int i=1, maxIdx = 0, n=chs.length;\\n        while(i<n){\\n            if(chs[i] > maxChar){\\n                maxChar = chs[i];\\n                maxIdx = i;\\n            }\\n            else if(chs[i-1] != chs[i] && chs[i] == chs[maxIdx]){\\n                int l = 1;\\n                while(i+l<n && chs[maxIdx+l] == chs[i+l]) l++;\\n                if(i+l==n) break;\\n                if(chs[maxIdx+l] < chs[i+l]) maxIdx = i;\\n            }\\n            i++;   \\n        }\\n        return s.substring(maxIdx);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String lastSubstring(String s) {\\n        char[] chs = s.toCharArray();\\n        char maxChar = chs[0];\\n        int i=1, maxIdx = 0, n=chs.length;\\n        while(i<n){\\n            if(chs[i] > maxChar){\\n                maxChar = chs[i];\\n                maxIdx = i;\\n            }\\n            else if(chs[i-1] != chs[i] && chs[i] == chs[maxIdx]){\\n                int l = 1;\\n                while(i+l<n && chs[maxIdx+l] == chs[i+l]) l++;\\n                if(i+l==n) break;\\n                if(chs[maxIdx+l] < chs[i+l]) maxIdx = i;\\n            }\\n            i++;   \\n        }\\n        return s.substring(maxIdx);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1264657,
                "title": "javascript-short-and-easy-to-understand-solution",
                "content": "Runtime: 2132 ms, faster than 6.25% of JavaScript online submissions for Last Substring in Lexicographical Order.\\nMemory Usage: 48.3 MB, less than 37.50% of JavaScript online submissions for Last Substring in Lexicographical Order.\\n```\\nvar lastSubstring = function(s) { \\n    let res = 0;\\n    for(let i = 1; i < s.length; i++){\\n        if(s.slice(i) > s.slice(res)) res = i;     \\n    };\\n    return s.slice(res);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar lastSubstring = function(s) { \\n    let res = 0;\\n    for(let i = 1; i < s.length; i++){\\n        if(s.slice(i) > s.slice(res)) res = i;     \\n    };\\n    return s.slice(res);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1259999,
                "title": "c-easy-priority-queue-solution",
                "content": "```c++\\nclass Solution {\\npublic:\\n    struct Str{\\n        string s;\\n        int sid;\\n        int eid;\\n    };\\n    struct Compare {\\n        bool operator()(Str &s1,Str &s2){\\n            if(s1.s==s2.s){\\n                return s1.sid > s2.sid;\\n            }\\n            return s1.s < s2.s;\\n        }\\n    };\\n    priority_queue<Str,vector<Str>,Compare>pq;\\n    string lastSubstring(string s) {\\n        char maxch = \\'a\\';\\n        vector<vector<int>>index(26);\\n        int i = 0;\\n        while(i<s.size()){\\n            index[s[i] - \\'a\\'].push_back(i);\\n            char c = s[i];\\n            int j = i+1;\\n            while(j<s.size()&&s[j]==c){\\n                j++;\\n            }\\n            i = j;\\n        }\\n        int maxid = 25;\\n        while(index[maxid].size()==0) maxid--;\\n        vector<int>&mm  = index[maxid];\\n        for(int i = 0;i<mm.size();i++){\\n            int l = mm[i];\\n            int r;\\n            if(i==mm.size()-1){\\n                r = s.size()-1;\\n            }\\n            else{\\n                r = mm[i+1]-1;\\n            }\\n\\n            string temp = \"\";\\n            for(int k = l;k<=r;k++){\\n                temp+=s[k];\\n            }\\n            Str st;\\n            st.s = temp;\\n            st.sid = mm[i];\\n            st.eid = r;\\n            pq.push(st);\\n        }\\n        auto top = pq.top();\\n        while(top.eid < s.size()-1){\\n            top.eid++;\\n            top.s+=s[top.eid];\\n        }\\n        char ch = top.s[0];\\n        i = top.sid-1;\\n        while(i>=0&&s[i]==ch){\\n            top.s = ch + top.s;\\n            i--;\\n        }\\n        return top.s;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    struct Str{\\n        string s;\\n        int sid;\\n        int eid;\\n    };\\n    struct Compare {\\n        bool operator()(Str &s1,Str &s2){\\n            if(s1.s==s2.s){\\n                return s1.sid > s2.sid;\\n            }\\n            return s1.s < s2.s;\\n        }\\n    };\\n    priority_queue<Str,vector<Str>,Compare>pq;\\n    string lastSubstring(string s) {\\n        char maxch = \\'a\\';\\n        vector<vector<int>>index(26);\\n        int i = 0;\\n        while(i<s.size()){\\n            index[s[i] - \\'a\\'].push_back(i);\\n            char c = s[i];\\n            int j = i+1;\\n            while(j<s.size()&&s[j]==c){\\n                j++;\\n            }\\n            i = j;\\n        }\\n        int maxid = 25;\\n        while(index[maxid].size()==0) maxid--;\\n        vector<int>&mm  = index[maxid];\\n        for(int i = 0;i<mm.size();i++){\\n            int l = mm[i];\\n            int r;\\n            if(i==mm.size()-1){\\n                r = s.size()-1;\\n            }\\n            else{\\n                r = mm[i+1]-1;\\n            }\\n\\n            string temp = \"\";\\n            for(int k = l;k<=r;k++){\\n                temp+=s[k];\\n            }\\n            Str st;\\n            st.s = temp;\\n            st.sid = mm[i];\\n            st.eid = r;\\n            pq.push(st);\\n        }\\n        auto top = pq.top();\\n        while(top.eid < s.size()-1){\\n            top.eid++;\\n            top.s+=s[top.eid];\\n        }\\n        char ch = top.s[0];\\n        i = top.sid-1;\\n        while(i>=0&&s[i]==ch){\\n            top.s = ch + top.s;\\n            i--;\\n        }\\n        return top.s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240934,
                "title": "c-o-n",
                "content": "comments are self explanatory\\n\\n```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int n = s.length();\\n        \\n        // find largest char\\n        char lar = \\'a\\';\\n        for(int i = 0;i < n;i++){\\n            if(s[i] > lar){\\n                lar = s[i];\\n            }\\n        }\\n        \\n        // find consecutive freq of largest char \\n        int cn = 0, cnt = 0;\\n        for(int i = 0;i < n;i++){\\n            if(s[i] == lar){\\n                cn++;\\n            } else {\\n                cn = 0;\\n            }\\n            cnt = max(cnt, cn);\\n        }\\n        \\n        // build an array where each point indicates start of largest char with most freq\\n        cn = 0; \\n        vector<int> arr;\\n        for(int i = 0;i < n;i++){\\n            if(s[i] == lar){\\n                cn++;\\n            } else {\\n                cn = 0;\\n            }\\n            \\n            if(cn == cnt){\\n                arr.push_back(i - cn + 1);\\n            }\\n        }\\n        \\n        // find the answer over all substrings separated by array\\n        // total time O(N)\\n        int pos = 0;\\n        string ans = \"\";\\n        for(int i = 0;i < arr.size();i++){\\n            int len = n - arr[i];\\n            if(i != arr.size() - 1){\\n                len = arr[i+1] - arr[i];\\n            }\\n            \\n            string curr = s.substr(arr[i], len);\\n            if(ans < curr){\\n                ans = curr;\\n                pos = arr[i];\\n            }\\n        }\\n        \\n        return s.substr(pos);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int n = s.length();\\n        \\n        // find largest char\\n        char lar = \\'a\\';\\n        for(int i = 0;i < n;i++){\\n            if(s[i] > lar){\\n                lar = s[i];\\n            }\\n        }\\n        \\n        // find consecutive freq of largest char \\n        int cn = 0, cnt = 0;\\n        for(int i = 0;i < n;i++){\\n            if(s[i] == lar){\\n                cn++;\\n            } else {\\n                cn = 0;\\n            }\\n            cnt = max(cnt, cn);\\n        }\\n        \\n        // build an array where each point indicates start of largest char with most freq\\n        cn = 0; \\n        vector<int> arr;\\n        for(int i = 0;i < n;i++){\\n            if(s[i] == lar){\\n                cn++;\\n            } else {\\n                cn = 0;\\n            }\\n            \\n            if(cn == cnt){\\n                arr.push_back(i - cn + 1);\\n            }\\n        }\\n        \\n        // find the answer over all substrings separated by array\\n        // total time O(N)\\n        int pos = 0;\\n        string ans = \"\";\\n        for(int i = 0;i < arr.size();i++){\\n            int len = n - arr[i];\\n            if(i != arr.size() - 1){\\n                len = arr[i+1] - arr[i];\\n            }\\n            \\n            string curr = s.substr(arr[i], len);\\n            if(ans < curr){\\n                ans = curr;\\n                pos = arr[i];\\n            }\\n        }\\n        \\n        return s.substr(pos);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231395,
                "title": "c-o-n",
                "content": "Simple solution with std algorithm \\nTime complexity is O(n)\\n```\\nclass Solution {\\npublic:\\n    string lastSubstring(const string &s) {        \\n        const auto maxIt(max_element(s.begin(), s.end()));\\n        int largestIndex(maxIt - s.begin());\\n        int i(maxIt - s.begin() + 1);\\n        char largestChar{*maxIt};\\n        while ( i != s.length() ) {\\n            if (s[i] == largestChar) {\\n                int rightSymIndex(i);\\n                int leftSymIndex(largestIndex);\\n                int nextIndex(-1);\\n\\n                while (rightSymIndex != s.length() && \\n                       s[rightSymIndex] == s[leftSymIndex]){\\n                    \\n                    if (s[rightSymIndex] != largestChar) \\n                        nextIndex = rightSymIndex;\\n                    \\n                    ++rightSymIndex;\\n                    ++leftSymIndex;\\n                }\\n                \\n                if (nextIndex == -1) \\n                    nextIndex = rightSymIndex;\\n                \\n                if (rightSymIndex != s.length() && \\n                    s[rightSymIndex] > s[leftSymIndex]) \\n                    largestIndex = i;\\n                \\n                i = nextIndex;\\n                continue;\\n            }\\n            ++i;\\n        }\\n        \\n        return s.c_str() + largestIndex;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(const string &s) {        \\n        const auto maxIt(max_element(s.begin(), s.end()));\\n        int largestIndex(maxIt - s.begin());\\n        int i(maxIt - s.begin() + 1);\\n        char largestChar{*maxIt};\\n        while ( i != s.length() ) {\\n            if (s[i] == largestChar) {\\n                int rightSymIndex(i);\\n                int leftSymIndex(largestIndex);\\n                int nextIndex(-1);\\n\\n                while (rightSymIndex != s.length() && \\n                       s[rightSymIndex] == s[leftSymIndex]){\\n                    \\n                    if (s[rightSymIndex] != largestChar) \\n                        nextIndex = rightSymIndex;\\n                    \\n                    ++rightSymIndex;\\n                    ++leftSymIndex;\\n                }\\n                \\n                if (nextIndex == -1) \\n                    nextIndex = rightSymIndex;\\n                \\n                if (rightSymIndex != s.length() && \\n                    s[rightSymIndex] > s[leftSymIndex]) \\n                    largestIndex = i;\\n                \\n                i = nextIndex;\\n                continue;\\n            }\\n            ++i;\\n        }\\n        \\n        return s.c_str() + largestIndex;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102718,
                "title": "brute-force-with-chars-elimination",
                "content": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        # Base case: Init max char as first char and cur_max_str as s\\n        max_ch = s[0]\\n        cur_max_str = s\\n        for i in range(1, len(s)):\\n            if max_ch<s[i]:       # Creating new cur_max_str if max_ch < s[i]  \\n                max_ch = s[i]\\n                cur_max_str = s[i:]\\n            elif max_ch == s[i]:\\n                cur_max_str = max(cur_max_str, s[i:])\\n        return cur_max_str\\n        \\n        \\n        ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        # Base case: Init max char as first char and cur_max_str as s\\n        max_ch = s[0]\\n        cur_max_str = s\\n        for i in range(1, len(s)):\\n            if max_ch<s[i]:       # Creating new cur_max_str if max_ch < s[i]  \\n                max_ch = s[i]\\n                cur_max_str = s[i:]\\n            elif max_ch == s[i]:\\n                cur_max_str = max(cur_max_str, s[i:])\\n        return cur_max_str\\n        \\n        \\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 1095863,
                "title": "to-leetcode-please-add-largest-cases-like-these",
                "content": "1. \"aaa....\"\\n2. \"ababab...\"\\n3. \"a-z a-z ...\"\\n4. \"ccc...ccc **b** ccc...ccc **a**\"\\n5. \"ccc...ccc **a** ccc...ccc **b** \"\\n6. repeat \"ccc...ccc**a**ccc...ccc**b**\" sqrt(N) times, length of each group is sqrt(N)\\n7. etc",
                "solutionTags": [],
                "code": "1. \"aaa....\"\\n2. \"ababab...\"\\n3. \"a-z a-z ...\"\\n4. \"ccc...ccc **b** ccc...ccc **a**\"\\n5. \"ccc...ccc **a** ccc...ccc **b** \"\\n6. repeat \"ccc...ccc**a**ccc...ccc**b**\" sqrt(N) times, length of each group is sqrt(N)\\n7. etc",
                "codeTag": "Unknown"
            },
            {
                "id": 1075378,
                "title": "java-o-n-2-solution-with-brief-explanation",
                "content": "The basic idea is to find the positions of lexicographically largest character in S and find the lexicographically largest subtstring from these pos by incrementing offset.\\n\\n```\\nclass Solution {\\n    public String lastSubstring(String s){\\n        List<Integer> candidates = new ArrayList();\\n        char max_char = \\'a\\';\\n        int n = s.length();\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(i == 0 || s.charAt(i) > max_char)\\n            {\\n                candidates = new ArrayList();\\n                candidates.add(i);\\n                max_char = s.charAt(i);\\n            }else{\\n                if(s.charAt(i) == max_char)\\n                {\\n                    candidates.add(i);\\n                }\\n            }\\n        }\\n        \\n        // ababac\\n        int offset = 1;\\n        while(candidates.size() > 1)\\n        {\\n            char cur_max = max(candidates,s,offset);\\n            // filter out prev candidates\\n            List<Integer> new_candidates = new ArrayList();\\n            \\n            for(int i = 0 ; i < candidates.size(); i++)\\n            {\\n                int pos = candidates.get(i);\\n                \\n                if(i > 0 &&  candidates.get(i-1) + offset == pos)\\n                {\\n                    continue;\\n                }\\n                \\n                if(pos+offset < n  && s.charAt(pos+offset) == cur_max)\\n                {\\n                    new_candidates.add(pos);\\n                }    \\n            }\\n            \\n            candidates = new_candidates;\\n            offset += 1;\\n        }\\n        \\n        return s.substring(candidates.get(0));\\n        \\n    }\\n    \\n    public char max(List<Integer> candidates, String s, int offset)\\n    {\\n         char curr_max = \\'a\\';\\n         for(int i = 0 ; i < candidates.size(); i++)\\n         {\\n             int pos = candidates.get(i);\\n             if(pos+offset < s.length())\\n             {\\n                  char curr = s.charAt(pos+offset);\\n                  if( curr > curr_max)\\n                  {\\n                     curr_max = curr;\\n                  }\\n             }  \\n         }\\n        \\n        return curr_max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String lastSubstring(String s){\\n        List<Integer> candidates = new ArrayList();\\n        char max_char = \\'a\\';\\n        int n = s.length();\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(i == 0 || s.charAt(i) > max_char)\\n            {\\n                candidates = new ArrayList();\\n                candidates.add(i);\\n                max_char = s.charAt(i);\\n            }else{\\n                if(s.charAt(i) == max_char)\\n                {\\n                    candidates.add(i);\\n                }\\n            }\\n        }\\n        \\n        // ababac\\n        int offset = 1;\\n        while(candidates.size() > 1)\\n        {\\n            char cur_max = max(candidates,s,offset);\\n            // filter out prev candidates\\n            List<Integer> new_candidates = new ArrayList();\\n            \\n            for(int i = 0 ; i < candidates.size(); i++)\\n            {\\n                int pos = candidates.get(i);\\n                \\n                if(i > 0 &&  candidates.get(i-1) + offset == pos)\\n                {\\n                    continue;\\n                }\\n                \\n                if(pos+offset < n  && s.charAt(pos+offset) == cur_max)\\n                {\\n                    new_candidates.add(pos);\\n                }    \\n            }\\n            \\n            candidates = new_candidates;\\n            offset += 1;\\n        }\\n        \\n        return s.substring(candidates.get(0));\\n        \\n    }\\n    \\n    public char max(List<Integer> candidates, String s, int offset)\\n    {\\n         char curr_max = \\'a\\';\\n         for(int i = 0 ; i < candidates.size(); i++)\\n         {\\n             int pos = candidates.get(i);\\n             if(pos+offset < s.length())\\n             {\\n                  char curr = s.charAt(pos+offset);\\n                  if( curr > curr_max)\\n                  {\\n                     curr_max = curr;\\n                  }\\n             }  \\n         }\\n        \\n        return curr_max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045521,
                "title": "p23-5",
                "content": "Suffix array -> Read about it on gfg not on cp algo\\n\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1042583,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int i = 0, j = 0, p = 1, k = 0;\\n        while(p < s.size()) {\\n            if(s[p] > s[i]) {\\n                i = p;\\n                p++;\\n                continue;\\n            }\\n            if(s[p] == s[i]) {\\n                k = p;\\n                j = i;\\n                while(p < s.size() and s[j] == s[p] and j < k) {\\n                    p++; j++;\\n                }\\n                if(j < k and s[j] < s[p]) {\\n                    i = k;\\n                }\\n                continue;\\n            }\\n            p++;\\n        }\\n        return s.substr(i);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int i = 0, j = 0, p = 1, k = 0;\\n        while(p < s.size()) {\\n            if(s[p] > s[i]) {\\n                i = p;\\n                p++;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1039858,
                "title": "easy-js-solution-single-for-loop",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar lastSubstring = function(s) {\\n    let string = s;\\n    let max = s.charAt(0);\\n    let roots = [0];\\n    for (let i = 1; i < s.length; i++) {\\n        if (s.charAt(i) > max) {\\n            string = s.substring(i, s.length);\\n            max = s.charAt(i);\\n        } else if (s.charAt(i) === max) {\\n            let sub = s.substring(i, s.length);\\n            string = sub > string ? sub : string;\\n        }\\n    }\\n    return string;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar lastSubstring = function(s) {\\n    let string = s;\\n    let max = s.charAt(0);\\n    let roots = [0];\\n    for (let i = 1; i < s.length; i++) {\\n        if (s.charAt(i) > max) {\\n            string = s.substring(i, s.length);\\n            max = s.charAt(i);\\n        } else if (s.charAt(i) === max) {\\n            let sub = s.substring(i, s.length);\\n            string = sub > string ? sub : string;\\n        }\\n    }\\n    return string;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1014499,
                "title": "java-o-n-to-o-n-2-solution",
                "content": "```\\n    public String lastSubstring(String s) {\\n        if (s.length() == 1) {\\n            return s;\\n        }\\n\\n        int currentMaxIndex = 0; //\\u8BB0\\u5F55\\u6700\\u5927\\u5B57\\u7B26\\u4E0B\\u6807\\n        boolean needCompare = false; //\\u662F\\u5426\\u6709\\u6311\\u6218\\u8005\\n        int newMaxIndex = 0; //\\u6311\\u6218\\u8005\\u4E0B\\u6807\\n        for (int i = 1; i < s.length(); i++) { // \\u4E00\\u6B21\\u5FAA\\u73AF\\n            // \\u5982\\u679C\\u904D\\u5386\\u7684\\u5B57\\u7B26\\u6BD4\\u5F53\\u524D\\u5B57\\u7B26\\u8FD8\\u5927\\uFF0C\\u5219\\u6700\\u5927\\u5B57\\u7B26\\u4E0B\\u6807\\u53D8\\u4E3A\\u5F53\\u524D\\u4E0B\\u6807\\n            if (s.charAt(i) > s.charAt(currentMaxIndex)) {\\n                currentMaxIndex = i;\\n                needCompare = false; //\\u91CD\\u7F6EneedCompare \\u72B6\\u6001\\n                continue;\\n            }\\n            \\n            // \\u5982\\u679C\\u7B2C\\u4E00\\u6B21\\u51FA\\u73B0\\u6311\\u6218\\u8005\\uFF0C\\u8BB0\\u5F55\\u6311\\u6218\\u8005 \\uFF08\\uFF09\\n            if (s.charAt(i) == s.charAt(currentMaxIndex) && !needCompare) {\\n                newMaxIndex = i;\\n                needCompare = true;\\n                continue;\\n            }\\n            \\n            // \\u6709\\u6311\\u6218\\u8005\\u65F6\\uFF0C\\u5982\\u679C\\u6311\\u6218\\u6210\\u529F\\uFF0C\\u5219\\u53D8\\u66F4\\u64C2\\u4E3B\\n            if (needCompare) {\\n                if (s.charAt(i) > s.charAt(currentMaxIndex + i - newMaxIndex)) {\\n                    currentMaxIndex = newMaxIndex;\\n                    i = currentMaxIndex ; // \\u6307\\u9488\\u56DE\\u6307\\u5230\\u6700\\u5927\\u5B57\\u7B26\\u4E0B\\u6807\\n                    needCompare = false;\\n                } else if (s.charAt(i) < s.charAt(currentMaxIndex + i - newMaxIndex)) {\\n                    needCompare = false; // \\u6311\\u6218\\u5931\\u8D25\\n                }\\n            }\\n        }\\n        return s.substring(currentMaxIndex);\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\n    public String lastSubstring(String s) {\\n        if (s.length() == 1) {\\n            return s;\\n        }\\n\\n        int currentMaxIndex = 0; //\\u8BB0\\u5F55\\u6700\\u5927\\u5B57\\u7B26\\u4E0B\\u6807\\n        boolean needCompare = false; //\\u662F\\u5426\\u6709\\u6311\\u6218\\u8005\\n        int newMaxIndex = 0; //\\u6311\\u6218\\u8005\\u4E0B\\u6807\\n        for (int i = 1; i < s.length(); i++) { // \\u4E00\\u6B21\\u5FAA\\u73AF\\n            // \\u5982\\u679C\\u904D\\u5386\\u7684\\u5B57\\u7B26\\u6BD4\\u5F53\\u524D\\u5B57\\u7B26\\u8FD8\\u5927\\uFF0C\\u5219\\u6700\\u5927\\u5B57\\u7B26\\u4E0B\\u6807\\u53D8\\u4E3A\\u5F53\\u524D\\u4E0B\\u6807\\n            if (s.charAt(i) > s.charAt(currentMaxIndex)) {\\n                currentMaxIndex = i;\\n                needCompare = false; //\\u91CD\\u7F6EneedCompare \\u72B6\\u6001\\n                continue;\\n            }\\n            \\n            // \\u5982\\u679C\\u7B2C\\u4E00\\u6B21\\u51FA\\u73B0\\u6311\\u6218\\u8005\\uFF0C\\u8BB0\\u5F55\\u6311\\u6218\\u8005 \\uFF08\\uFF09\\n            if (s.charAt(i) == s.charAt(currentMaxIndex) && !needCompare) {\\n                newMaxIndex = i;\\n                needCompare = true;\\n                continue;\\n            }\\n            \\n            // \\u6709\\u6311\\u6218\\u8005\\u65F6\\uFF0C\\u5982\\u679C\\u6311\\u6218\\u6210\\u529F\\uFF0C\\u5219\\u53D8\\u66F4\\u64C2\\u4E3B\\n            if (needCompare) {\\n                if (s.charAt(i) > s.charAt(currentMaxIndex + i - newMaxIndex)) {\\n                    currentMaxIndex = newMaxIndex;\\n                    i = currentMaxIndex ; // \\u6307\\u9488\\u56DE\\u6307\\u5230\\u6700\\u5927\\u5B57\\u7B26\\u4E0B\\u6807\\n                    needCompare = false;\\n                } else if (s.charAt(i) < s.charAt(currentMaxIndex + i - newMaxIndex)) {\\n                    needCompare = false; // \\u6311\\u6218\\u5931\\u8D25\\n                }\\n            }\\n        }\\n        return s.substring(currentMaxIndex);\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 997277,
                "title": "c-optimized-for-solving-the-etl-error",
                "content": "Find the positions of the largest letter first, and then compare all the substrings starting from the largest letter. Save time for the testcase like \"aaaaaaaaaaaa.......b\".\\n\\n```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int n=s.length(),i=0;\\n        //get the positions of the largest letter\\n        vector<vector<int>> start(26);\\n        for(int i=0;i<s.length();i++)\\n            start[s[i]-\\'a\\'].push_back(i);\\n        for(i=25;i>=0;i--)\\n        {\\n            if(start[i].size()>0)\\n                break;\\n        }\\n        if(start[i].size()==1)\\n            return s.substr(start[i][0]);\\n        //only check the substring starting from the largest letter\\n        int k=0,j=1;\\n        vector<int> candi=start[i];\\n        int p=candi[0],q=candi[1];\\n        while(q+k<s.length() && j<candi.size())\\n        {\\n            if(s[p+k]>s[q+k])\\n            {\\n                j++;\\n                if(j==candi.size()) break;\\n                q=candi[j];\\n                k=0;\\n            }\\n            else if(s[p+k]<s[q+k])\\n            {\\n                p=candi[j];\\n                j++;\\n                if(j==candi.size()) break;\\n                q=candi[j];\\n                k=0;\\n            }\\n            else\\n                k++;\\n        }\\n        return s.substr(p);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string lastSubstring(string s) {\\n        int n=s.length(),i=0;\\n        //get the positions of the largest letter\\n        vector<vector<int>> start(26);\\n        for(int i=0;i<s.length();i++)\\n            start[s[i]-\\'a\\'].push_back(i);\\n        for(i=25;i>=0;i--)\\n        {\\n            if(start[i].size()>0)\\n                break;\\n        }\\n        if(start[i].size()==1)\\n            return s.substr(start[i][0]);\\n        //only check the substring starting from the largest letter\\n        int k=0,j=1;\\n        vector<int> candi=start[i];\\n        int p=candi[0],q=candi[1];\\n        while(q+k<s.length() && j<candi.size())\\n        {\\n            if(s[p+k]>s[q+k])\\n            {\\n                j++;\\n                if(j==candi.size()) break;\\n                q=candi[j];\\n                k=0;\\n            }\\n            else if(s[p+k]<s[q+k])\\n            {\\n                p=candi[j];\\n                j++;\\n                if(j==candi.size()) break;\\n                q=candi[j];\\n                k=0;\\n            }\\n            else\\n                k++;\\n        }\\n        return s.substr(p);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992670,
                "title": "js-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar lastSubstring = function(s) {\\n    /*\\n    //tle\\n    const compare = (x, y) => {\\n        let i = 0;\\n        let diff = 0;\\n        let min = Math.min(x.length, y.length);\\n        while(i < min) {\\n            if(x[i] !== y[i]) {\\n                //console.log(x, y);\\n                diff = x.charCodeAt(i) - y.charCodeAt(i);\\n                break;\\n            }\\n            i++;\\n        }\\n        if(diff !== 0) {\\n            return diff < 0 ? y : x;\\n        }\\n        return x.length > y.length ? x : y;\\n    };\\n    \\n    let ans = s;\\n    for(let i = 0; i < s.length; i++) {\\n        for(let j = i+1; j < s.length+1; j++) {\\n            const curr = s.slice(i, j);\\n            //console.log(curr);\\n            ans = compare(ans, curr);\\n        }\\n    }\\n    return ans;*/\\n    \\n    let [i, j, k] = [0, 1, 0];\\n    while(j+k < s.length) {\\n        if(s[i+k] === s[j+k]) {\\n            k++;\\n            continue;\\n        } \\n        if(s.charCodeAt(i+k) > s.charCodeAt(j+k)) {\\n            j++;\\n        } else {\\n            i = j;\\n            j = i+1;\\n        }\\n        k = 0;\\n    }\\n    return s.slice(i);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar lastSubstring = function(s) {\\n    /*\\n    //tle\\n    const compare = (x, y) => {\\n        let i = 0;\\n        let diff = 0;\\n        let min = Math.min(x.length, y.length);\\n        while(i < min) {\\n            if(x[i] !== y[i]) {\\n                //console.log(x, y);\\n                diff = x.charCodeAt(i) - y.charCodeAt(i);\\n                break;\\n            }\\n            i++;\\n        }\\n        if(diff !== 0) {\\n            return diff < 0 ? y : x;\\n        }\\n        return x.length > y.length ? x : y;\\n    };\\n    \\n    let ans = s;\\n    for(let i = 0; i < s.length; i++) {\\n        for(let j = i+1; j < s.length+1; j++) {\\n            const curr = s.slice(i, j);\\n            //console.log(curr);\\n            ans = compare(ans, curr);\\n        }\\n    }\\n    return ans;*/\\n    \\n    let [i, j, k] = [0, 1, 0];\\n    while(j+k < s.length) {\\n        if(s[i+k] === s[j+k]) {\\n            k++;\\n            continue;\\n        } \\n        if(s.charCodeAt(i+k) > s.charCodeAt(j+k)) {\\n            j++;\\n        } else {\\n            i = j;\\n            j = i+1;\\n        }\\n        k = 0;\\n    }\\n    return s.slice(i);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 991290,
                "title": "7-line-python-faster-than-94",
                "content": "Had the same approach as [this solution](https://leetcode.com/problems/last-substring-in-lexicographical-order/discuss/980014/Simple-solution-in-Python-faster-than-98-xD) but was lost in the weeds eliminating indices in rounds rather than just splitting and comparing once, before getting it to this.\\n```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        mc = max(s)\\n        indices = [i for i, _ in enumerate(s) if s[i] == mc and (i == 0 or s[i-1] != s[i])] + [len(s)]\\n        substrings = [s[indices[j-1]:indices[j]] for j in range(1, len(indices))]\\n        ms = max(substrings)\\n        return \\'\\'.join(substrings[substrings.index(ms):])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastSubstring(self, s: str) -> str:\\n        mc = max(s)\\n        indices = [i for i, _ in enumerate(s) if s[i] == mc and (i == 0 or s[i-1] != s[i])] + [len(s)]\\n        substrings = [s[indices[j-1]:indices[j]] for j in range(1, len(indices))]\\n        ms = max(substrings)\\n        return \\'\\'.join(substrings[substrings.index(ms):])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987889,
                "title": "python-o-n",
                "content": "```\\nclass Solution:\\n    # O(N)\\n    # keep track of the current best (c)\\n    # the next candidate needs to start with the same letter\\n    # there are three options:\\n    # cP_1cP_2\\n    # P_1 >= P_2: second candidate can be discarded\\n    # P_1 < P_2: second candidate is better, discard first candidate\\n    def lastSubstring(self, s: str) -> str:\\n        c = 0\\n        i = 1\\n        while i < len(s):\\n            if s[i] == s[c]:\\n                c2 = i\\n                j = 1\\n                while c2 + j < len(s) and c2 - c > j:\\n                    if s[c + j] < s[c2 + j]:\\n                        c = c2\\n                        break\\n                    elif s[c + j] > s[c2 + j]:\\n                        break\\n                    else:\\n                        j += 1\\n                i += j - 1\\n            elif s[i] > s[c]:\\n                c = i\\n            i += 1\\n            \\n        return s[c:]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # O(N)\\n    # keep track of the current best (c)\\n    # the next candidate needs to start with the same letter\\n    # there are three options:\\n    # cP_1cP_2\\n    # P_1 >= P_2: second candidate can be discarded\\n    # P_1 < P_2: second candidate is better, discard first candidate\\n    def lastSubstring(self, s: str) -> str:\\n        c = 0\\n        i = 1\\n        while i < len(s):\\n            if s[i] == s[c]:\\n                c2 = i\\n                j = 1\\n                while c2 + j < len(s) and c2 - c > j:\\n                    if s[c + j] < s[c2 + j]:\\n                        c = c2\\n                        break\\n                    elif s[c + j] > s[c2 + j]:\\n                        break\\n                    else:\\n                        j += 1\\n                i += j - 1\\n            elif s[i] > s[c]:\\n                c = i\\n            i += 1\\n            \\n        return s[c:]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564698,
                "content": [
                    {
                        "username": "qq99pp00",
                        "content": "Don\\'t see him this week! What happened? I couldnt sleep last night because I didnt see his post!"
                    },
                    {
                        "username": "hqztrue",
                        "content": "I\\'ve added two, hopefully they kill all O(n^2) algorithms.\\n[testcase 1](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/2780)\\n[testcase 2](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/2781)\\n"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Don't forget ->>\n\n\"cacacb\" -> \"cb\""
                    },
                    {
                        "username": "Jennif90b",
                        "content": "What is the logic for the example here?\\n\\nInput: s = \"leetcode\"\\nOutput: \"tcode\""
                    },
                    {
                        "username": "Sharib",
                        "content": "In Lexicographical order t is the character which is last character among cdelot, that\\'s why tcode is the output"
                    },
                    {
                        "username": "razhev2017",
                        "content": "you have a string and imagine there is an array of all substrings of that string, if you will sort that array of substrings in lexicographical order and chose the last one of the array - that will be the answer. I got it like this"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "Seems a lot of top solutions are based on Suffix Array Algorithm. Just wondering if anyone has any good template (preferably in Java) for a Suffix Array Implementation that they could share?\\n\\nThanks!"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "how bab is lexigraphically in order"
                    }
                ]
            },
            {
                "id": 1570373,
                "content": [
                    {
                        "username": "qq99pp00",
                        "content": "Don\\'t see him this week! What happened? I couldnt sleep last night because I didnt see his post!"
                    },
                    {
                        "username": "hqztrue",
                        "content": "I\\'ve added two, hopefully they kill all O(n^2) algorithms.\\n[testcase 1](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/2780)\\n[testcase 2](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/2781)\\n"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Don't forget ->>\n\n\"cacacb\" -> \"cb\""
                    },
                    {
                        "username": "Jennif90b",
                        "content": "What is the logic for the example here?\\n\\nInput: s = \"leetcode\"\\nOutput: \"tcode\""
                    },
                    {
                        "username": "Sharib",
                        "content": "In Lexicographical order t is the character which is last character among cdelot, that\\'s why tcode is the output"
                    },
                    {
                        "username": "razhev2017",
                        "content": "you have a string and imagine there is an array of all substrings of that string, if you will sort that array of substrings in lexicographical order and chose the last one of the array - that will be the answer. I got it like this"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "Seems a lot of top solutions are based on Suffix Array Algorithm. Just wondering if anyone has any good template (preferably in Java) for a Suffix Array Implementation that they could share?\\n\\nThanks!"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "how bab is lexigraphically in order"
                    }
                ]
            },
            {
                "id": 2060883,
                "content": [
                    {
                        "username": "qq99pp00",
                        "content": "Don\\'t see him this week! What happened? I couldnt sleep last night because I didnt see his post!"
                    },
                    {
                        "username": "hqztrue",
                        "content": "I\\'ve added two, hopefully they kill all O(n^2) algorithms.\\n[testcase 1](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/2780)\\n[testcase 2](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/2781)\\n"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Don't forget ->>\n\n\"cacacb\" -> \"cb\""
                    },
                    {
                        "username": "Jennif90b",
                        "content": "What is the logic for the example here?\\n\\nInput: s = \"leetcode\"\\nOutput: \"tcode\""
                    },
                    {
                        "username": "Sharib",
                        "content": "In Lexicographical order t is the character which is last character among cdelot, that\\'s why tcode is the output"
                    },
                    {
                        "username": "razhev2017",
                        "content": "you have a string and imagine there is an array of all substrings of that string, if you will sort that array of substrings in lexicographical order and chose the last one of the array - that will be the answer. I got it like this"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "Seems a lot of top solutions are based on Suffix Array Algorithm. Just wondering if anyone has any good template (preferably in Java) for a Suffix Array Implementation that they could share?\\n\\nThanks!"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "how bab is lexigraphically in order"
                    }
                ]
            },
            {
                "id": 1575012,
                "content": [
                    {
                        "username": "qq99pp00",
                        "content": "Don\\'t see him this week! What happened? I couldnt sleep last night because I didnt see his post!"
                    },
                    {
                        "username": "hqztrue",
                        "content": "I\\'ve added two, hopefully they kill all O(n^2) algorithms.\\n[testcase 1](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/2780)\\n[testcase 2](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/2781)\\n"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Don't forget ->>\n\n\"cacacb\" -> \"cb\""
                    },
                    {
                        "username": "Jennif90b",
                        "content": "What is the logic for the example here?\\n\\nInput: s = \"leetcode\"\\nOutput: \"tcode\""
                    },
                    {
                        "username": "Sharib",
                        "content": "In Lexicographical order t is the character which is last character among cdelot, that\\'s why tcode is the output"
                    },
                    {
                        "username": "razhev2017",
                        "content": "you have a string and imagine there is an array of all substrings of that string, if you will sort that array of substrings in lexicographical order and chose the last one of the array - that will be the answer. I got it like this"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "Seems a lot of top solutions are based on Suffix Array Algorithm. Just wondering if anyone has any good template (preferably in Java) for a Suffix Array Implementation that they could share?\\n\\nThanks!"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "how bab is lexigraphically in order"
                    }
                ]
            },
            {
                "id": 1572934,
                "content": [
                    {
                        "username": "qq99pp00",
                        "content": "Don\\'t see him this week! What happened? I couldnt sleep last night because I didnt see his post!"
                    },
                    {
                        "username": "hqztrue",
                        "content": "I\\'ve added two, hopefully they kill all O(n^2) algorithms.\\n[testcase 1](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/2780)\\n[testcase 2](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/2781)\\n"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Don't forget ->>\n\n\"cacacb\" -> \"cb\""
                    },
                    {
                        "username": "Jennif90b",
                        "content": "What is the logic for the example here?\\n\\nInput: s = \"leetcode\"\\nOutput: \"tcode\""
                    },
                    {
                        "username": "Sharib",
                        "content": "In Lexicographical order t is the character which is last character among cdelot, that\\'s why tcode is the output"
                    },
                    {
                        "username": "razhev2017",
                        "content": "you have a string and imagine there is an array of all substrings of that string, if you will sort that array of substrings in lexicographical order and chose the last one of the array - that will be the answer. I got it like this"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "Seems a lot of top solutions are based on Suffix Array Algorithm. Just wondering if anyone has any good template (preferably in Java) for a Suffix Array Implementation that they could share?\\n\\nThanks!"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "how bab is lexigraphically in order"
                    }
                ]
            },
            {
                "id": 1781850,
                "content": [
                    {
                        "username": "qq99pp00",
                        "content": "Don\\'t see him this week! What happened? I couldnt sleep last night because I didnt see his post!"
                    },
                    {
                        "username": "hqztrue",
                        "content": "I\\'ve added two, hopefully they kill all O(n^2) algorithms.\\n[testcase 1](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/2780)\\n[testcase 2](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/2781)\\n"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Don't forget ->>\n\n\"cacacb\" -> \"cb\""
                    },
                    {
                        "username": "Jennif90b",
                        "content": "What is the logic for the example here?\\n\\nInput: s = \"leetcode\"\\nOutput: \"tcode\""
                    },
                    {
                        "username": "Sharib",
                        "content": "In Lexicographical order t is the character which is last character among cdelot, that\\'s why tcode is the output"
                    },
                    {
                        "username": "razhev2017",
                        "content": "you have a string and imagine there is an array of all substrings of that string, if you will sort that array of substrings in lexicographical order and chose the last one of the array - that will be the answer. I got it like this"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "Seems a lot of top solutions are based on Suffix Array Algorithm. Just wondering if anyone has any good template (preferably in Java) for a Suffix Array Implementation that they could share?\\n\\nThanks!"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "how bab is lexigraphically in order"
                    }
                ]
            }
        ]
    }
]